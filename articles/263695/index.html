<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The ideal way to implement a static code analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the main difficulties with the use of static analysis tools is working with false positives. There are many ways to eliminate false positives u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The ideal way to implement a static code analyzer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/223/1e1/b8e2231e109a522fe3278058135db0c5.png" alt="Apple II emulator for Windows" align="left"><br>  One of the main difficulties with the use of static analysis tools is working with false positives.  There are many ways to eliminate false positives using the analyzer settings or by changing the code.  I took a small <b>Apple II emulator for Windows</b> project and show you how to work with the PVS-Studio static analyzer report in practice.  I will show with examples how to correct errors and suppress false positives. <br><a name="habracut"></a><br><h2>  Introduction </h2>  I will describe the ideal implementation process for a static analysis methodology project.  It consists in eliminating all false alarms of the analyzer and real errors so that the analyzer generates 0 warnings.  This is the approach we <a href="http://www.viva64.com/ru/b/0330/">used</a> when working with the Unreal Engine 4 project. <br><br>  In practice, the ideal approach is rarely possible.  Therefore, in a large project, it is reasonable to take an alternative approach.  You can hide all the current warnings and see only the messages related to the new or modified code.  For this, there is a special mechanism in the PVS-Studio analyzer that saves information in a special database.  Details can be found in the article: <a href="http://www.viva64.com/ru/b/0309/">How to embed static analysis in a project with more than 10 megabytes of source code?</a> <br><br>  So, hiding all the messages, you can closely monitor the quality of the new code.  Finding errors in the new code, you will quickly appreciate the power and benefit of the static analysis methodology.  And when you have free time, you can return to the hidden warnings and gradually make the necessary edits to the code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But back to the ideal happy world.  Imagine that we have time, and we can safely deal with the warnings given by the PVS-Studio analyzer. <br><br>  In this article I want to show how to work with analyzer warnings.  And we will go the full way - from the first check to the window, in which there will be 0 warnings. <br><br>  That is why I chose a small project.  I could take a little more, but then I get tired of writing an article, and you read it.  However, you still get tired.  The article, even for a small project, will be large, but please pay attention to it.  It can help you use our code analyzer more efficiently. <br><br>  The test mouse was the <a href="https://github.com/AppleWin/AppleWin">Apple II emulator for Windows</a> project.  The choice fell on him by accident.  Therefore, we will not dwell on it.  I did not care what project to take, as long as it turned out to be small, but at the same time there was something interesting in it. <br><br>  Project Features: <ul><li>  Source code size: 3 megabytes. </li><li>  The number of lines of code: 85700. </li><li>  Analysis time (8 processor cores): 30 seconds. </li></ul><br><h2>  First start </h2>  After the first launch of the analyzer, we have the following warnings: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24f/124/5ac/24f1245ac8ac35c72bf026824163d043.png" alt="Figure 1. Alerts issued on the first run of the PVS-Studio analyzer for the Apple II emulator for Windows project."><br>  <font color="#999999"><i>Figure 1. Alerts issued on the first run of the PVS-Studio analyzer for the Apple II emulator for Windows project.</i></font> <br><br>  In the article I will discuss only warnings 1 and 2 levels related to general purpose analysis (GA).  It would be possible to "win" and level 3, but then the article will drag on.  We look at level 3 quite quickly, and I will give some explanations, but I will not correct anything. <br><br>  Micro-optimizations (OP): not interested now. <br><br>  About 64-bit diagnostics: there is no 64-bit configuration in the project.  Not interested. <br><br>  After checking the project, I sorted all the warnings by code.  This can be done by clicking on the ‚ÄúCode‚Äù column (see Figure N2). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d5/ff3/d5c/0d5ff3d5c177a0991fd774ebc2ecbb6b.png" alt="Figure 2. Window with PVS-Studio messages. Messages are sorted by diagnostic number."><br>  <font color="#999999"><i>Figure 2. Window with PVS-Studio messages.</i></font>  <font color="#999999"><i>Messages are sorted by diagnostic number.</i></font> <br><br>  Sorting by code makes it easier to work with messages.  There are groups of similar messages.  Having understood the reason for the occurrence of one message, you can easily and quickly handle the rest. <br><br>  <b>Note.</b>  The reader may be asked why not immediately do such a sort.  The fact is that I want to allow users to look at the messages in the process of analysis.  If you sort them, the new messages will not be added to the end of the analysis, but to different places in the list.  As a result, the messages will "jump."  It will be impossible to work with such a "jerking" list. <br><br><h2>  Work with analyzer messages </h2>  There are three projects in the solution (they are visible in the Solution Explorer window in Figure N2).  Two of them, zlib and zip_lib, are not interesting to check.  Therefore, they should be excluded from the analysis.  In fact, it suffices to exclude zip_lib, since zlib is already added to exceptions by default.  This is done in the PVS-Studio settings window ( <a href="http://www.viva64.com/ru/d/0017/">Don't Check Files</a> section): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/e23/0c8/7f4e230c81e153e15b8e0b12d9293b26.png" alt="Figure N3. Exclude zip_lib from checking."><br>  <font color="#999999"><i>Figure N3.</i></font>  <font color="#999999"><i>Exclude zip_lib from checking.</i></font> <br><br>  I excluded the unnecessary project in advance.  However, this is easy to do after verification.  And it is not necessary for this to go to the settings.  In the context menu there is an item that allows you to conveniently hide all messages related to a file or a specific directory.  It is very convenient.  I recommend to get acquainted with the article " <a href="http://www.viva64.com/ru/b/0305/">PVS-Studio for Visual C ++</a> ".  It describes this and other features that will help you use the tool effectively. <br><br>  So, everything is ready to start working on messages.  Let's start with the diagnostics number V501 and go further.  In total we will consider 32 + 49 = 81 posts.  This is quite a lot.  Therefore, in some places I will write in detail, and in some places I will be brief. <br><br><h3>  False triggers on xxxxxREG macros </h3>  The first 6 messages are caused by complex macros ADDXXREG, ADCHLREG, SBCHLREG, SBCHLREG.  When disclosing them, redundant constructions arise, and the analyzer gives, for example, the following message: <br><br>  V501 operator: (tmp &gt;&gt; 8) ^ reg_ixh ^ reg_ixh z80.cpp 3444 <br><br>  The ADDXXREG macro is very large and consists of other macros.  Therefore, I will not give it in the article. <br><br>  It is important to us that the XOR operation is performed twice with the variable reg_ixh.  Accordingly, the expression can be simplified to (tmp &gt;&gt; 8).  However, there is no mistake here.  Just get a redundant expression when substituting certain macro arguments: <br><br>  ADDXXREG (reg_ixh, reg_ixl, reg_ixh, reg_ixl, 15, 2); <br><br>  These are false positives, and we must eliminate them.  Suppress all warnings associated with them.  To do this, in the header file where these macros are declared, I added the following comments: <ul><li>  // - V: ADDXXREG: 501 </li><li>  // - V: ADCHLREG: 501 </li><li>  // - V: SBCHLREG: 501 </li><li>  // - V: SBCHLREG: 501 </li></ul><br>  Details about this mechanism for suppressing warnings can be found in the <a href="http://www.viva64.com/ru/d/0021/">corresponding section of the documentation</a> . <br><br>  In principle, you can get by with one comment.  In the names of all macros there is a ‚ÄúREG‚Äù.  Therefore, you can write one comment: // - V: REG: 501.  It will suppress V501 warnings in the lines where ‚ÄúREG‚Äù will occur.  But this is bad, because you can accidentally hide a useful message that is not related to the macros listed above.  It is possible to slightly improve the situation by adding a bracket for the search: // - V: REG (: 501. In this case, I think that it is not worth being lazy and you should write 4 comments. <br><br><h3>  Error in sprintf () function parameters </h3><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>( sText, <span class="hljs-string"><span class="hljs-string">"%s %s = %s\n"</span></span> , g_aTokens[ TOKEN_COMMENT_EOL ].sToken , g_aParameters[ PARAM_CATEGORY ].m_sName , g_aParameters[ eCategory ] );</code> </pre> <br>  Warning: V510 The 'sprintf' function is not expected to receive class-type variable as the fifth actual argument.  debug.cpp 2300 <br><br>  Indeed, the fifth actual argument is a structure of type Command_t.  Apparently, g_aParameters [eCategory] .m_sName should be used as an argument.  Corrected the code. <br><br><h3>  Bad smelling ZeroMemory () </h3>  The following message tells us that one array is not fully populated: V512: pHDD-&gt; hd_buf.  harddisk.cpp 491 <br><pre> <code class="cpp hljs">BYTE hd_buf[HD_BLOCK_SIZE+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Why +1? ZeroMemory(pHDD-&gt;hd_buf, HD_BLOCK_SIZE);</span></span></code> </pre> <br>  The last byte is not reset.  I can not say whether it is a mistake or not.  Pay attention to the comment.  Perhaps even the developers themselves do not know what size the array should be and whether it should be zeroed out entirely. <br><br>  Such code is said to be smelled.  It is not necessarily erroneous, but suspicious and may cause further errors. <br><br>  I just suppress this warning with a comment.  You can make changes to the file yourself, or you can use the context menu item ‚ÄúMark selected messages as False Alarms‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/479/f5e/fd6479f5e75299855f61949037ed1deb.png" alt="Figure 3. Adding a comment to the code to suppress the warning."><br>  <font color="#999999"><i>Figure 3. Adding a comment to the code to suppress the warning.</i></font> <br><br>  Having selected this item, the analyzer will insert a comment into the code itself: <br><pre> <code class="cpp hljs">ZeroMemory(pHDD-&gt;hd_buf, HD_BLOCK_SIZE); <span class="hljs-comment"><span class="hljs-comment">//-V512</span></span></code> </pre> <br><h3>  False triggering on memcpy () function call </h3><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> random[ <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> ]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;memmain[ iByte ], random, <span class="hljs-number"><span class="hljs-number">256</span></span> );</code> </pre> <br>  The memcpy () function copies only part of the 'random' buffer.  The analyzer considers this suspicious and honestly reports this.  In this case, he is wrong, and there is no error.  I suppressed the warning, as in the previous case, with the help of a comment.  This is not very beautiful, but I don‚Äôt know how to do better in someone else‚Äôs code. <br><br><h3>  Extra action </h3><pre> <code class="cpp hljs">nAddress_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; nAddress_ = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)*(LPBYTE)(mem + nStack); nStack++; nAddress_ += ((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)*(LPBYTE)(mem + nStack)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br>  Warning: V519 The 'nAddress_' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 568, 569. debugger_assembler.cpp 569 <br><br>  The analyzer noticed that the variable nAddress_ is assigned different values ‚Äã‚Äãseveral times in a row.  There is no error here, just an extra code.  I deleted the first line, where the variable is assigned the value 0. Another option to get rid of the warning is to replace the second assignment with "+ =". <br><br>  A similar situation can be observed in two more files: <br><br>  The video.cpp file (see line 3310 and 3315).  I deleted the extra operation ‚ÄúpSrc + = nLen;‚Äù. <br><br>  The file Debug.cpp (see line 5867 and 5868).  Replaced: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = sLine; p = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( sLine, <span class="hljs-string"><span class="hljs-string">":"</span></span> );</code> </pre>  on <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( sLine, <span class="hljs-string"><span class="hljs-string">":"</span></span> );</code> </pre> <br>  I will not dwell on these fragments in more detail. <br><br><h3>  Error in switch statement </h3>  The following diagnostic V519 already indicates a real serious error.  Although the mistake is classical, and everyone knows about it, we meet it again and again in various programs. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( c ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: eThis = PS_ESCAPE; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'%'</span></span>: eThis = PS_TYPE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: sText[ nLen++ ] = c; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Warning: V519 The 'p' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 5867, 5868. debug.cpp 5868 <br><br>  After ‚ÄúeThis = PS_ESCAPE;‚Äù there is no 'break' operator.  Because of this, the value of the variable 'eThis' will immediately change to PS_STYPE.  This is an obvious mistake.  To fix it, I added a 'break' operator. <br><br><h3>  Error: always false condition </h3><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertZ80TStatesTo6502Cycles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT uTStates)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (uTStates &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (ULONG) ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)uTStates / uZ80ClockMultiplier); }</code> </pre> <br>  Warning: V547 Expression 'uTStates &lt;0' is always false.  Unsigned type value is never &lt;0. z80.cpp 5507 <br><br>  The programmer wanted to protect himself from the case when a negative value is passed to the function.  However, since the variable 'uTStates' is unsigned, protection will not work. <br><br>  I added an explicit cast to the 'int' type: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((INT)uTStates &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (ULONG) ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)uTStates / uZ80ClockMultiplier);</code> </pre> <br><h3>  Excessive caution analyzer </h3>  In the next function, the analyzer is worried that an overrun may occur. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentImageDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pszImageDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(g_sCurrentDir, pszImageDir); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( g_sCurrentDir ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( g_sCurrentDir[ nLen - <span class="hljs-number"><span class="hljs-number">1</span></span> ] != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> ) .... }</code> </pre> <br>  Warning: V557 Array underrun is possible.  The value of 'nLen - 1' index could reach -1.  applewin.cpp 553 <br><br>  If you pass an empty string to a function, its length will be zero.  Then the array will go out of bounds: g_sCurrentDir [0 - 1]. <br><br>  The analyzer does not know whether such a situation is possible or not.  Therefore, just in case, and warns. <br><br>  I also do not know whether such a situation is possible or not.  If possible, the analyzer found an error.  If not, this is a false positive. <br><br>  I decided to assume that this is a false positive.  However, it would be more useful to improve the code, rather than adding a comment to suppress the warning.  Therefore, let an additional check be added to the function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nLen == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  There is another place where, theoretically, it can occur beyond the array boundary.  But we must try not to turn the article into a thick reference book.  Therefore, I will not describe this warning and simply suppress it with the help of a comment.  See the same file (line 556). <br><br><h3>  Assignment instead of comparison </h3><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bytenum == <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp;&amp; (byteval[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xAA</span></span>)) {</code> </pre> <br>  Warning: V560 A part of conditional expression is always true: (byteval [1] = 0xAA).  diskimagehelper.cpp 439 <br><br>  I‚Äôm sure that I wanted to perform the operation '==', not '='.  If assignment is needed, it would be much more natural to write this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytenum == <span class="hljs-number"><span class="hljs-number">3</span></span>) { byteval[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xAA</span></span>;</code> </pre> <br>  Therefore, this is a mistake, and it should be fixed: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bytenum == <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp;&amp; (byteval[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0xAA</span></span>))</code> </pre> <br><h3>  False alarms due to macros </h3><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((TRACKS_MAX&gt;TRACKS_STANDARD) &amp;&amp; ....)</code> </pre> <br>  Warning: V560 A part of conditional expression is always true: ((35 + 5)&gt; 35).  diskimagehelper.cpp 548 <br><br>  If you open the macros, you get the expression ((35 + 5)&gt; 35).  The expression is always true, but it is not a mistake. <br><br>  This is the case when I do not even know how best to proceed.  Shalturu and just suppress the false positive with the comment: // - V560. <br><br><h3>  Extra variable </h3>  In the process of refactoring, sometimes ‚Äúlost‚Äù variables remain.  They are somehow used in the code, but in fact are no longer needed.  Apparently this is exactly what happened with the bForeground variable: <br><pre> <code class="cpp hljs">BOOL bForeground; .... bForeground = FALSE; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bForeground ) dwCoopFlags |= DISCL_FOREGROUND; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dwCoopFlags |= DISCL_BACKGROUND; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( hr == DIERR_UNSUPPORTED &amp;&amp; !bForeground &amp;&amp; bExclusive )</code> </pre> <br>  And more, the 'bForeground' variable is not changed or used anywhere.  This causes a warning: V560 A part of the conditional expression is always true:! BForeground.  mouseinterface.cpp 690 <br><br>  This is an interesting example for philosophy.  Is this a false positive or not?  Even a person is difficult to answer.  The analyzer is right, revealing an anomaly.  But from the point of view of a person, this fragment may be code that is not complete.  And then everything is fine. <br><br>  We assume that this is another example of the "code with the smell."  I removed the 'bForeground' variable from the code. <br><br><h3>  Behavior undefined </h3><pre> <code class="cpp hljs">*(mem+addr++) = (opcode &gt;= BENCHOPCODES) ? <span class="hljs-number"><span class="hljs-number">0x00</span></span> : ((addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  Warning: V567 Undefined behavior.  The 'addr' variable is used while being between times sequence points.  cpu.cpp 564 <br><br>  It is not known how the expression will be calculated: <ul><li>  Perhaps the 'addr' variable will increase first, and then it will be used on the right side of the expression. </li><li>  And maybe the opposite. </li></ul>  The correct code would be: <br><pre> <code class="cpp hljs">*(mem+addr) = (opcode &gt;= BENCHOPCODES) ? <span class="hljs-number"><span class="hljs-number">0x00</span></span> : ((addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; addr++;</code> </pre> <br><h3>  Invalid arguments when calling wsprintf () and similar functions. </h3>  There are several errors associated with passing an incorrect amount of actual arguments in a formatted output function.  A total of 10 such errors were found, but we will consider only one: <br><pre> <code class="cpp hljs">wsprintf( sText, TEXT(<span class="hljs-string"><span class="hljs-string">"%s full speed Break on Opcode: None"</span></span>) , sAction , g_iDebugBreakOnOpcode , g_aOpcodes65C02[ g_iDebugBreakOnOpcode ].sMnemonic );</code> </pre> <br>  Warning: V576 Incorrect format.  A different number of actual arguments is expected while calling the 'wsprintfA' function.  Expected: 3. Present: 5. debug.cpp 939 <br><br>  When forming the line, the last two parameters are not taken into account.  As an outsider, it is difficult for me to say if these parameters are superfluous, or an error is made in the format string. <br><br>  I decided that the parameters are redundant, and deleted them. <br><br>  Similar problems are observed in the following sections of the code: <ul><li>  Expected: 8. Present: 9. debug.cpp 7377 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1263 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1265 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1267 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1282 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1286 </li><li>  Expected: 3. Present: 4. debugger_help.cpp 1288 </li><li>  Expected: 5. Present: 4. debugger_help.cpp 1332 </li><li>  Expected: 3. Present: 4. frame.cpp 691 </li><li>  Expected: 3. Present: 4. frame.cpp 695 </li></ul><br>  There are also a couple of places where% 08X is used to print the pointer values.  On a 32-bit system, this works in practice.  But in a 64-bit system, only part of the pointer will be printed.  The correct solution is to use "% p".  Relevant code sections: <ul><li>  To print the value of the% p 'should be used.  tfe.cpp 507 </li><li>  To print the value of the% p 'should be used.  tfe.cpp 507 </li></ul><br><h3>  False alarms on double comparisons </h3>  Although the analyzer is not to blame, it gave two false positives on repetitive conditions.  Consider one case: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nAddress &lt;= _6502_STACK_END) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>( sText,<span class="hljs-string"><span class="hljs-string">"%04X: "</span></span>, nAddress ); PrintTextCursorX( sText, rect ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nAddress &lt;= _6502_STACK_END) { DebuggerSetColorFG( DebuggerGetColor( FG_INFO_OPCODE )); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(sText, <span class="hljs-string"><span class="hljs-string">" %02X"</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)*(LPBYTE)(mem+nAddress)); PrintTextCursorX( sText, rect ); }</code> </pre> <br>  Warning: V581 The conditional expressions of the 'if' are located alongside each other are identical.  Check lines: 2929, 2935. debugger_display.cpp 2935 <br><br>  There is no error.  The programmer simply divided the two sets of actions.  From the point of view of the analyzer, such code is suspicious.  Suddenly conditions should be different?  However, with false alarms, you need to do something.  I decided to combine two conditional operators into one: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nAddress &lt;= _6502_STACK_END) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>( sText,<span class="hljs-string"><span class="hljs-string">"%04X: "</span></span>, nAddress ); PrintTextCursorX( sText, rect ); DebuggerSetColorFG( DebuggerGetColor( FG_INFO_OPCODE )); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(sText, <span class="hljs-string"><span class="hljs-string">" %02X"</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)*(LPBYTE)(mem+nAddress)); PrintTextCursorX( sText, rect ); }</code> </pre> <br>  I think that the readability of the code did not suffer from this, but along the way we got rid of the false positives. <br><br>  The second case is similar: V581 The conditional expressions of the 'if' are agreed alongside each other are identical.  Check lines: 2237, 2245. debugger_display.cpp 2245 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab2/611/800/ab26118001faa212e23f96ac5f7c5407.png" alt="Picture 12"><br>  <font color="#999999"><i>Figure 5. In the middle of a long article, it is recommended to insert a picture so that the reader can rest.</i></font>  <font color="#999999"><i>I do not know what kind of article to insert an article.</i></font>  <font color="#999999"><i>So here's your cat.</i></font> <br><br><h3>  Pointer dereferencing before checking </h3>  In total, the analyzer issued 3 warnings on this topic.  Unfortunately, the text of the program in these places is quite confused.  Therefore, for simplicity, I will not provide real code, but pseudocode.  For the first 2 warnings, the code looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> ZEXPORT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unzGetGlobalComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *szComment)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A) { *szComment=<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UNZ_ERRNO; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((szComment != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; X) .... }</code> </pre> <br>  Warning: V595 The 'szComment' pointer was used before it was verified against nullptr.  Check lines: 1553, 1558. unzip.c 1553 <br><br>  As you can see, the passed 'szComment' pointer may be NULL.  This is evidenced by a check (szComment! = NULL). <br><br>  However, there is a code section in which the pointer is safely dereferenced without performing a check.  Is it dangerous.  It is possible that in practice situations never arise when the 'szComment' is equal to 0. But the code is dangerous and should be corrected. <br><br>  Similarly: V595 The 'pToken_' pointer was used before it was verified against nullptr.  Check lines: 811, 823. debugger_parser.cpp 811 <br><br>  But with the last, third case, everything is more complicated.  I'm already tired of proving that such a code is incorrect and should be fixed.  The function is short, so I will bring it all <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArgsGetValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Arg_t *pArg, WORD * pAddressValue_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBase )</span></span></span><span class="hljs-function"> </span></span>{ TCHAR *pSrc = &amp; (pArg-&gt;sArg[ <span class="hljs-number"><span class="hljs-number">0</span></span> ]); TCHAR *pEnd = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pArg &amp;&amp; pAddressValue_) { *pAddressValue_ = (WORD)(_tcstoul( pSrc, &amp;pEnd, nBase) &amp; _6502_MEM_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Warning: V595 The 'pArg' pointer was used before it was verified against nullptr.  Check lines: 204, 207. debugger_parser.cpp 204 <br><br>  The 'pArg' pointer may be zero, as indicated by the ‚Äúif (pArg &amp;&amp; pAddressValue_)‚Äù condition.  But before the pointer is checked, it is used in the expression: <br><pre> <code class="cpp hljs">TCHAR *pSrc = &amp; (pArg-&gt;sArg[ <span class="hljs-number"><span class="hljs-number">0</span></span> ]);</code> </pre> <br>  This expression leads to undefined program behavior.  You cannot dereference null pointers. <br><br>  Many people object that in this code memory access does not occur, but a certain address is simply calculated.  Therefore, there is no problem.  However, this is too narrow an interpretation of undefined behavior.  In general, no need to guess how the compiler will behave and how the code will work.  So you can not write, and it makes no sense to discuss why. <br><br>  Indefinite behavior in this code is not only referring to a zero memory address (which really may not be).  For example, the compiler is quite right to reduce the test condition to ‚Äúif (pAddressValue_)‚Äù.  Since there is an expression ‚ÄúpArg-&gt; xxx‚Äù, then the pointer is definitely not zero and should not be checked. <br><br>  There is no sense in discussing this issue in more detail.  I suggest to get acquainted with a special article: <a href="http://www.viva64.com/ru/b/0306/">Dereferencing a null pointer leads to undefined behavior</a> . <br><br>  To fix the code is simple.  It is enough to transfer the declaration of the variable inside the 'if'. <br><br><h3>  Scary expression </h3>  The analyzer confused the following expression: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cx &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; (cx &lt;= <span class="hljs-number"><span class="hljs-number">13</span></span>))</code> </pre> <br>  Warning: V602 Consider inspecting the '(cx&gt; 4)' expression.  '&gt;' possibly should not be replaced with '&gt;&gt;'.  debug.cpp 8933 <br><br>  The analyzer sees that the '&amp;' operator is used, whose operands are of the 'bool' type used.  This is strange.  Usually in such cases it is common to use the logical operator '&amp;&amp;'. <br><br>  The operator '&amp;' is used for bit operations.  Therefore, the analyzer suggested the possibility that they wanted to work with bits here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cx &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; (cx &lt;= <span class="hljs-number"><span class="hljs-number">13</span></span>))</code> </pre> <br>  The analyzer is too smart and wrong.  However, the programmer‚Äôs fault is also there.  This code is with a smell.  Much more natural to write: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cx &gt; <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; cx &lt;= <span class="hljs-number"><span class="hljs-number">13</span></span>)</code> </pre> <br><h3>  Unspeakable behavior and horror in macros </h3>  It is not clear what the result will be when you shift negative values ‚Äã‚Äãto the right.  It‚Äôs better not to do this, since the behavior of the code may change on another compiler. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> SPKR_DATA_INIT = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)<span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g_nSpeakerData == (SPKR_DATA_INIT &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br>  Warning: V610 Unspecified behavior.  Check the shift operator '&gt;&gt;'.  The left operand 'SPKR_DATA_INIT' is negative.  speaker.cpp 450 <br><br>  Output: you can declare the constant SPKR_DATA_INIT without a tank.  True, then you will need to make a few more minor edits to prevent the compiler and analyzer from warning about comparing signed / unsigned numbers. <br><br>  The analyzer found 3 more such dangerous places: <ul><li>  The left operand 'SPKR_DATA_INIT' is negative.  speaker.cpp 453 </li><li>  The left operand '~ 0x180' is negative.  tfe.cpp 869 </li><li>  The left operand '~ 0x100' is negative.  tfe.cpp 987 </li></ul><br>  By the way, when I started to edit the last two warnings, I found 2 more errors.  We can say that the analyzer helped to find them indirectly. <br><br>  Here is how the macro is used: <br><pre> <code class="cpp hljs">SET_PP_16(TFE_PP_ADDR_SE_BUSST, busst &amp; ~<span class="hljs-number"><span class="hljs-number">0x180</span></span>);</code> </pre> <br>  It opens in a long line.  Therefore, I will show only its part: <br><pre> <code class="cpp hljs">..... = (busst &amp; ~<span class="hljs-number"><span class="hljs-number">0x180</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; .....</code> </pre> <br>  The priority of the shift operator &gt;&gt; is greater than the priority of the &amp; operator.  See table: <a href="http://www.viva64.com/ru/t/0064/">priorities of operations</a> . <br><br>  The programmer expected the code to work like this: <br><pre> <code class="cpp hljs">..... = ((busst &amp; ~<span class="hljs-number"><span class="hljs-number">0x180</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; .....</code> </pre> <br>  And in fact, it works like this: <br><pre> <code class="cpp hljs">..... = (busst &amp; (~<span class="hljs-number"><span class="hljs-number">0x180</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; .....</code> </pre> <br>  That's why the PVS-Studio analyzer warns: ‚Äúthe left operand '~ 0x180' is negative‚Äù. <br><br>  This is how dangerous it is to use macros! <br><br><h3>  Holes in safety </h3>  The project uses the sprintf (), wsprintf (), and so on functions in a very dangerous way.  In brief, the functions are used as follows: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, STR);</code> </pre> <br>  If the string STR contains control characters such as "% s", the consequences will be unpredictable. <br><br>  Usually such a code is considered as a security hole (see <a href="http://www.viva64.com/ru/b/0129/">details</a> ). <br><br>  However, for the emulator, I think this is not critical.  No one will attack him.  However, such code is dangerous in itself.  It can easily lead to the fall of the program or to its incorrect operation. <br><br>  Correctly do this: sprintf (buf, "% s", STR); <br><br>  The analyzer found quite a lot of dangerous function calls.  In total, he <a href="http://www.viva64.com/external-pictures/txt/AppleWin-V618.txt">issued 21 warnings</a> . <br><br><h3>  Opposite conditions </h3><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// TO DO: Need way of determining if DirectX init failed if (soundtype != SOUND_WAVE) { if (soundtype == SOUND_WAVE) soundtype = SOUND_SMART;</span></span></code> </pre> <br>  Warning: V637  The second condition is always false.  Check lines: 270, 272. speaker.cpp 270 <br><br>  Judging by the comment, the code is not added.  It is difficult to say how to deal with such a code.  I decided to comment out the second meaningless 'if': <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (soundtype != SOUND_WAVE) { <span class="hljs-comment"><span class="hljs-comment">//if (soundtype == SOUND_WAVE) // soundtype = SOUND_SMART;</span></span></code> </pre> <br><h3>  Bad code alignment </h3>  The code looks as if both actions refer to the 'if' operator: <br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Slot4 == CT_MockingboardC) || (Slot4 == CT_Phasor)) m_PropertySheetHelper.GetConfigNew().m_Slot[<span class="hljs-number"><span class="hljs-number">4</span></span>] = CT_Empty; m_PropertySheetHelper.GetConfigNew().m_Slot[<span class="hljs-number"><span class="hljs-number">5</span></span>] = CT_SAM; }</code> </pre> <br>  Warning: V640 The code's operational logic does not correspond with its formatting.  The statement is indented.  It is possible that curly brackets are missing.  pagesound.cpp 229 <br><br>  As I understand it, there is no error in the code.  However, this is not a false positive.  The analyzer is absolutely right to warn about such code.  It is necessary to correct alignment: <br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Slot4 == CT_MockingboardC) || (Slot4 == CT_Phasor)) m_PropertySheetHelper.GetConfigNew().m_Slot[<span class="hljs-number"><span class="hljs-number">4</span></span>] = CT_Empty; m_PropertySheetHelper.GetConfigNew().m_Slot[<span class="hljs-number"><span class="hljs-number">5</span></span>] = CT_SAM; }</code> </pre> <br><h3>  Incorrect operation with the strncat () function </h3><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>( sText, CHC_DEFAULT, CONSOLE_WIDTH ); <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>( sText, pHelp , CONSOLE_WIDTH );</code> </pre> <br>  Warning: V645 The 'strncat' function call could lead to the 'sText' buffer overflow.  It can hold.  debugger_help.cpp 753 <br><br>  The third argument of the function is the number of characters that can still be added to the string.  Therefore, it is right and safe to do so: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>( sText, CHC_DEFAULT, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sText) - <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(sText) - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>( sText, pHelp , <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sText) - <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(sText) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Details can be found by <a href="http://www.viva64.com/ru/d/0263/">reviewing the</a> description of the <a href="http://www.viva64.com/ru/d/0263/">V645</a> diagnostic. <br><br><h3>  Extra checks </h3>  For a very long time, the 'new' operator has generated an exception std :: bad_alloc if it cannot allocate memory.  However, programs can still meet unnecessary checks: <br><pre> <code class="cpp hljs">BYTE* pNewImageBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE [uNewImageSize]; _ASSERT(pNewImageBuffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pNewImageBuffer) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Alert: V668 It is not a rule of reference for the pnewImageBuffer.  The exception will be generated in the case of memory allocation error.  diskimagehelper.cpp 197 <br><br>  _ASSERT and validation can and should be removed.  There is no point in them. <br><br>  Similar situation: <ul><li>  mouseinterface.cpp 175 </li><li>  serialcomms.cpp 839 </li><li>  savestate.cpp 108 </li><li>  savestate.cpp 218 </li><li>  speech.cpp 40 </li></ul><br><h3>  Independent declaration of system types </h3>  The project consistently defines some data types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ULONG; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *LPVOID; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UINT;</code> </pre> <br>  There is no obvious error here.  We assume that this is a "code with a smell" and suppress warnings using the comment // - V677. <br><br><h3>  Violated the "Law of the Big Two" </h3>  For example, operator = is declared in the CConfigNeedingRestart class, but there is no copy constructor.  This violates <a href="http://www.viva64.com/ru/d/0326/">the Big Two Law</a> . <br><br>  The class is large enough, so I will not give code snippets here.  Take a word. <br><br>  In this class, all fields are simple types, so your own operator = is not needed at all.  The class will be successfully copied automatically. <br><br>  With the class Disk_t the situation is similar.  And here and there, you can remove operator =. <br><br>  Analyzer Warnings: <ul><li>  V690 The 'CConfigNeedingRestart' class implements the '=' operator, but not the copy constructor.  It is dangerous to use such a class.  config.h 7 </li><li>  V690 The 'Disk_t' class implements the '=' operator, but there is no copy constructor.  It is dangerous to use such a class.  disk.cpp 74 </li></ul><br><h3>  Typo </h3><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nHeight=nHeight=g_aFontConfig[ FONT_CONSOLE ]._nFontHeight;</code> </pre> <br>  Warning: V700 Consider inspecting the 'T foo = foo = ...' expression.  It is odd that variable is initialized through itself.  debugger_display.cpp 1226 <br><br>  Just a typo.  Replaced with: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nHeight = g_aFontConfig[ FONT_CONSOLE ]._nFontHeight;</code> </pre> <br><h3>  Unnecessary analyzer concern about enumerations </h3>  The enumeration 'AppMode_e' has the following named constants: MODE_LOGO, MODE_PAUSED, MODE_RUNNING, MODE_DEBUG, MODE_STEPPING. <br><br>  The analyzer experiences that not all of them are used in this switch (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (g_nAppMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MODE_PAUSED : _tcscat(.....); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MODE_STEPPING: _tcscat(.....); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Warning: V719 The switch statement appMode_e 'enum: MODE_DEBUG, MODE_LOGO, MODE_RUNNING.  frame.cpp 217 <br><br>  In this example, I am even a little ashamed of the analyzer.  Empirical algorithms have failed.  False alarm.  There are several ways to eliminate it.  For example, you can add a branch ¬´default¬ª. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (g_nAppMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MODE_PAUSED : _tcscat(.....); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MODE_STEPPING: _tcscat(.....); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Another similar false positive: V719 The switch statement doesn‚Äôt cover all values ‚Äã‚Äãof the 'AppMode_e' enum: MODE_DEBUG, MODE_LOGO.  frame.cpp 1210 <br><br><h2>  I promised to take a quick look at level three warnings. </h2>  We do not recommend (at least in the early stages) to even look at level 3.  There are many false, uninteresting or specific messages.  Now this is the situation. <br><br>  For example, there are quite a few warnings V601. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDebugBreakpointHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !g_bDebugNormalSpeedBreakpoints ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _IsDebugBreakpointHit(); }</code> </pre> <br> : V601 The 'false' value is implicitly cast to the integer type. debug.h 210 <br><br>    'int'.     ¬´return false¬ª. <br><br>  ,     ,          .       3 . <br><br>    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> g_fClksPerSpkrSample; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)g_nRemainderBufferSize != g_fClksPerSpkrSample)</code> </pre> <br> : V550 An odd precise comparison. It's probably better to use a comparison with defined precision: fabs(A ‚Äî B) &gt; Epsilon. speaker.cpp 197 <br><br>      ‚Äî        ,       'double'. <br><br>       .  ,   double      ,  ,   .   . <br><br><h2>     </h2> ,    (1  2 ),    .   ‚Äî    (.  6). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa3/d98/4a5/fa3d984a5aac83268fa031b07e204112.png" alt=" 6.    1  2 ."><br> <font color="#999999"><i> 6.    1  2 .</i></font> <br><br>   ,     .   ,  ,    ,         .     ,     ,     . <br><br><h2>  Let's sum up </h2>   ,       .    .     ,     .          . <br><br>      . , -  ,      ,       20  ,   .    .      ,         90%. <br><br>       ,    ,     .     ,   ¬´  ¬ª.    ,       ,       .        . <br><br>      .    : ¬´  ? /?¬ª.     ,  ,       . <br><br>  ,       .      ,       . <br><br>    ,   PVS-Studio   Apple II emulator for Windows: <ul><li>    (General Analysis,    ): 81 </li><li>  : 57 </li><li>   ¬´  ¬ª,   : 9 </li><li>  : 15 </li></ul>   : <ul><li> ,   : <b>70 %</b> </li><li> ,   ¬´  ¬ª: <b>11 %</b> </li><li>  : <b>19 %</b> </li></ul><br><h2>  Conclusion </h2>    PVS-Studio   .       : <a href="http://www.viva64.com/ru/pvs-studio-download/">http://www.viva64.com/ru/pvs-studio-download/</a> <br><br>           .     twitter     .  Thank. <br><br> PS              /++,     twitter: <a href="https://twitter.com/Code_Analysis">https://twitter.com/Code_Analysis</a> <br><br>    . <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0340/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>        ,      : Andrey karpov. <a href="http://www.viva64.com/en/b/0340/">An Ideal Way to Integrate a Static Code Analyzer into a Project</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/263695/">https://habr.com/ru/post/263695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263685/index.html">How to use exceptions</a></li>
<li><a href="../263687/index.html">Magic of tensor algebra: Part 14 - Non-standard introduction to the dynamics of a rigid body</a></li>
<li><a href="../263689/index.html">Joker 2015: News July 16-27, 2015 - new speakers and reports</a></li>
<li><a href="../263691/index.html">vCloud Director for the smallest (part 5): VPN setup</a></li>
<li><a href="../263693/index.html">Why do we need business intelligence systems</a></li>
<li><a href="../263697/index.html">Central Park NY: official app redesign</a></li>
<li><a href="../263699/index.html">How-to: responsive emails in Gmail</a></li>
<li><a href="../263701/index.html">Modernization of operational data center</a></li>
<li><a href="../263703/index.html">Another hack FL.ru</a></li>
<li><a href="../263705/index.html">Testing serializers for .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>