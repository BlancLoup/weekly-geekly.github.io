<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplify converters for WPF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About a year already working with WPF and some things in it frankly vybeshivayut. One of these things is converters. For the sake of every sneeze, dec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplify converters for WPF</h1><div class="post__text post__text-html js-mediator-article">  About a year already working with WPF and some things in it frankly vybeshivayut.  One of these things is converters.  For the sake of every sneeze, declare the implementation of a dubious looking interface somewhere in the depths of the project, and then search for it via Ctrl + F by name when it is suddenly needed.  In multi-converters, so the devil himself will get confused. <br><br>  The situation is aggravated by MVVM, due to which not using this miracle of science is quite rare.  Well, it's time to ease the routine of creating and using converters a bit, let's go. <br><a name="habracut"></a><br>  Immediately, I‚Äôll make a reservation that I don‚Äôt mind the often used converters like <b>BooleanToVisibilityConverter</b> and the like, they can be easily remembered and reused in many places.  But it often happens that the converter needs some very specific, and somehow you don‚Äôt want to make a whole component out of it.  And for a long time, and clogs the global scope, then it is difficult to find the right in all this garbage. <br><br>  Converters are used when working with binding-s and allow you to convert values ‚Äã‚Äãin one-sided or two-sided order (depending on the binding mode).  Converters are also of two types - with one value and with many.  Interfaces <b>IValueConverter</b> and <b>IMultiValueConverter</b> respectively are responsible for them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With a single value, we use regular binding, usually through the <b>BindingBase</b> markup extension built into XAML: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding IntProp, Converter={StaticResource conv:IntToStringConverter}, ConverterParameter=plusOne}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  In the case of a multi-value, this monstrous design is used: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock.Text</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MultiBinding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Converter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{StaticResource conv:IntToStringConverter}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ConverterParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"plusOne"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Binding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"IntProp"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Binding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"StringProp"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MultiBinding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock.Text</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The converters themselves will look like this (There are two converters in one class at once, but it can be done separately): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IntToStringConverter</span></span> : <span class="hljs-title"><span class="hljs-title">IValueConverter</span></span>, <span class="hljs-title"><span class="hljs-title">IMultiValueConverter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Convert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type targetType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter, CultureInfo culture</span></span></span><span class="hljs-function">)</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)parameter == <span class="hljs-string"><span class="hljs-string">"plusOne"</span></span> ? ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>).ToString() : <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ToString(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type targetType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter, CultureInfo culture</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Convert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] values, Type targetType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter, CultureInfo culture</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Convert(values[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">], targetType, parameter, culture) </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">as</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{values[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type[] targetTypes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter, CultureInfo culture</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); }</code> </pre><br>  This is extremely short, since the example is synthetic, but already here without a half liter it‚Äôs not a damn thing to know what the arrays are, what the type cast, some left targetType and culture, what ConvertBack is without the implementation. <br><br>  I have several ideas to simplify this: <br><br><ol><li>  Converters in the form of pieces of c # code directly into xaml for simple calculations; </li><li>  Converters in the form of references to methods in the code-behind, for cases with very specific / special cases of conversion, that is, when there is no point in converting this to anywhere else; </li><li>  Converters in the form of the same that in the standard implementation, but so that it does not look so dumb that every time you write a new converter you do not have to go to Google and look for an example of the implementation of the converter. </li></ol><br>  Immediately break off those of you who think that I will tell you how to implement paragraph 1. I will not.  The network has several implementations of this, for example <a href="http://www.ikriv.com/dev/wpf/MathConverter/index.shtml">here</a> .  I also saw variants with expression tree and it seems some more.  Such things are suitable only for the simplest cases - to work with arithmetic and logical operations.  If there need to call some classes, use strings, and so on, then problems with escaping inside the xml and the problem of including namespaces will come out.  However, in the simplest cases, such things are quite possible to use. <br><br>  But we will consider 2 and 3 points in more detail.  Suppose it was necessary to determine the method of converting to the code-behind.  What should it look like?  I think something like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertIntToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> options</span></span></span><span class="hljs-function">)</span></span> =&gt; options == <span class="hljs-string"><span class="hljs-string">"plusOne"</span></span> ? (intValue + <span class="hljs-number"><span class="hljs-number">1</span></span>).ToString() : intValue.ToString(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertIntAndStringToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stringValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> options</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ConvertIntToString(intValue, options)}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stringValue}</span></span></span><span class="hljs-string">"</span></span>;</code> </pre><br>  Compare this with the previous option.  Code less - more clarity.  Similarly, a variant with a separate reused converter might look like: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConvertLib</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> options</span></span></span><span class="hljs-function">)</span></span> =&gt; options == <span class="hljs-string"><span class="hljs-string">"plusOne"</span></span> ? (intValue + <span class="hljs-number"><span class="hljs-number">1</span></span>).ToString() : intValue.ToString(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntAndStringToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stringValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> options</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{IntToString(intValue, options)}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stringValue}</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre><br>  Not bad, huh?  Well, how do you make xaml friends with this, because he understands only standard converter interfaces?  <b>Of</b> course, for each such class, you can make a wrapper in the form of standard <b>IValueConverter</b> / <b>IMultiValueConverter</b> which will already use beautiful methods, but then the whole point is lost if you have to declare a wrapper for each readable converter.  One solution is to make such a wrapper universal, like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericConverter</span></span> : <span class="hljs-title"><span class="hljs-title">IValueConverter</span></span>, <span class="hljs-title"><span class="hljs-title">IMultiValueConverter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenericConverter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*         - */</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { //    ,    } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { //    ,    } public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { //    ,    } public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) { //    ,    } }</span></span></code> </pre><br>  This is all in theory, how can delegates be practically transferred to the converter, and how to get them with only XAML? <br><br>  Markup extension, MarkupExtension, comes to the rescue.  It is enough to inherit the <b>MarkupExtension</b> class and override the <b>ProvideValue</b> method and in XAML it will be possible to write Binding-like expressions in curly brackets, but with their own working mechanisms. <br><br>  In order to pass a link to the conversion methods through markup extensions, the simplest thing is to use their string names.  Let's agree that the code-behind methods will be defined simply by the method name, and the static methods in external libraries will go like <b>ClrNamespace.ClassName.MethodName</b> , they can be distinguished by the presence of a dot in the latter (At least one dot will be between the class name and the method, if the class lies in the global namespace). <br><br>  How to identify the methods figured out, how to get them in the markup extension in the form of delegates to pass to the converter?  The markup extension ( <b>MarkupExtension</b> ) has a <b>ProvideValue</b> method for overriding, which looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericConvExtension</span></span> : <span class="hljs-title"><span class="hljs-title">MarkupExtension</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvideValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceProvider serviceProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  } }</span></span></code> </pre><br>  The override method must return what is eventually assigned to the property, in the value of which this XAML markup defines this markup extension.  This method can return any value, but since we will substitute this markup extension into the Converter property for binding (or multi-binding), the return value should be a converter, that is, an instance of the <b>IValueConverter</b> / <b>IMultiValueConverter type</b> .  Again, it makes no sense to make different converters, you can make one class and implement these two interfaces at once, so that the converter fits both for a single binding and for a multiple one. <br><br>  In order to pass a string to the markup extension, which defines the name of the function from the code-behind or static library that the converter should invoke, you need to define a public string property in the <b>MarkupExtension</b> instance: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FunctionName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  After that, it will be possible to write in markup like this: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding IntProp, Converter={conv:GenericConvExtension FunctionName='ConvertIntToString'}, ConverterParameter=plusOne}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  However, this can be simplified, for starters, it is not necessary to write Extension in the name of the extension class conv: GenericConvExtension in XAML, simply conv: GenericConv.  Further in the extension you can define a constructor in order not to explicitly specify the name of the property with the name of the function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenericConvExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> functionName</span></span></span><span class="hljs-function">)</span></span> { FunctionName = functionName; }</code> </pre><br>  Now the XAML expression is even simpler: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding IntProp, Converter={conv:GenericConv ConvertIntToString}, ConverterParameter=plusOne}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  Pay attention to the absence of quotes in the name of the conversion function.  In cases where there are no spaces or other unhealthy characters in the string, single quotes are optional. <br><br>  Now it only remains to get a reference to the method in the <b>ProvideValue</b> method, create an instance of the converter and pass this link to it.  A reference to a method can be obtained through the <b>Reflection</b> mechanism, but for this you need to know the runtime type in which this method is declared.  In the case of the implementation of conversion methods in static classes, the full name of the static method is passed (With the full class name indicated), respectively, you can parse this string, type the full name of the type through <b>Reflection</b> to get the type, and also get the method definition as an instance of <b>MethodInfo</b> from the type. <br><br>  In the case of the code-behind, you need not only the type, but also an instance of this type (After all, the method may not be static and take into account the <b>Window</b> state of the instance when issuing the conversion result).  Fortunately, this is not a problem, since it can be obtained through the input parameter of the <b>ProvideValue</b> method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvideValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceProvider serviceProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> rootObject = (serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IRootObjectProvider)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IRootObjectProvider).RootObject; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  <b>rootObject</b> is the object in which the code-behind is written; in the case of a window, it will be a <b>Window</b> object.  <b>By</b> calling <b>GetType</b> in it, <b>you</b> can get a conversion method that interests us through reflection, since its name is specified in the <b>FunctionName</b> property defined earlier.  Then you just need to create an instance of <b>GenericConverter</b> , passing in it the received <b>MethodInfo</b> and return this converter as a result of <b>ProvideValue</b> . <br><br>  That's the whole theory, at the end of the article I will give the code for my implementation of this whole business.  My implementation in the line with the name of the method accepts both the conversion method and optionally the reverse conversion method, the syntax is something like this: <br><br><pre> <code class="hljs 1c"> : '[___] [__.]__, [__.]___'  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    -: 'Converters.ConvertLib IntToString, StringToInt' = 'Converters.ConvertLib.IntToString, Converters.ConvertLib.StringToInt'  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> code-behind: 'IntToString' <span class="hljs-keyword"><span class="hljs-keyword"></span></span> one-way binding, 'IntToString, StringToInt' <span class="hljs-keyword"><span class="hljs-keyword"></span></span> two-way binding   (   code-behind,    ): 'IntToString, Converters.ConvertLib.StringToInt'</code> </pre><br>  It also works with multi-binders, the difference will be only in the signature of the functions for conversion (it should correspond to what goes in the binding).  Also, the <b>ConverterParameter</b> may be present in the signature of the conversion function, or it may be absent, for this it simply needs to be specified, or not specified, it is defined as simply the last parameter in the signature. <br><br>  The example considered in the article in the case of my implementation will look like this in XAML: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding IntProp, Converter={conv:ConvertFunc 'ConvertIntToString'}, ConverterParameter=plusOne}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock.Text</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MultiBinding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Converter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{conv:ConvertFunc 'ConvertIntAndStringToString'}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ConverterParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"plusOne"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Binding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"IntProp"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Binding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"StringProp"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MultiBinding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock.Text</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Cons of my implementation, which I found: <br><br><ol><li>  At the time of the method call, all sorts of checks are going on, creating arrays for the parameters, and in general I'm not sure that MethodInfo.Invoke () works as quickly as calling the method directly, but I would not say that this is a big minus in WPF / MVVM . <br><br></li><li>  It is not possible to use overloads, because at the time of receiving MethodInfo, the types of values ‚Äã‚Äãthat will be received are unknown, which means you cannot get the desired overload of the method at this moment (Maybe you can somehow, but I don‚Äôt know how).  There is another option to crawl into reflection every time when you directly call the method and find an overload, but this will already be an unjustified waste of percents.  time for some overload. <br><br></li><li>  The impossibility in multi-binning to do different behavior of the converter depending on the number of parameters passed.  That is, if the conversion function is defined for 3 parameters, then the number of multi-bindings should be exactly the same; in a standard converter, you can make a variable number. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Full source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Globalization; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Markup; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xaml; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Converters</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConvertFuncExtension</span></span> : <span class="hljs-title"><span class="hljs-title">MarkupExtension</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertFuncExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertFuncExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> functionsExpression</span></span></span><span class="hljs-function">)</span></span> { FunctionsExpression = functionsExpression; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FunctionsExpression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvideValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceProvider serviceProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> rootObject = (serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IRootObjectProvider)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IRootObjectProvider).RootObject; MethodInfo convertMethod = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; MethodInfo convertBackMethod = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ParseFunctionsExpression(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> convertType, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> convertMethodName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> convertBackType, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> convertBackMethodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (convertMethodName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = convertType ?? rootObject.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flags = convertType != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? BindingFlags.Public | BindingFlags.Static : BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((convertMethod = type.GetMethod(convertMethodName, flags)) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Specified convert method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{convertMethodName}</span></span></span><span class="hljs-string"> not found on type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.FullName}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (convertBackMethodName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = convertBackType ?? rootObject.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flags = convertBackType != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? BindingFlags.Public | BindingFlags.Static : BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((convertBackMethod = type.GetMethod(convertBackMethodName, flags)) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Specified convert method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{convertBackMethodName}</span></span></span><span class="hljs-string"> not found on type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.FullName}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Converter(rootObject, convertMethod, convertBackMethod); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseFunctionsExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type convertType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> convertMethodName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type convertBackType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> convertBackMethodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ParseFunctionsExpressionWithRegex(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> commonConvertTypeName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fullConvertMethodName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fullConvertBackMethodName)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Error parsing functions expression"</span></span>); Lazy&lt;Type[]&gt; allTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;Type[]&gt;(GetAllTypes); Type commonConvertType = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonConvertTypeName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { commonConvertType = FindType(allTypes.Value, commonConvertTypeName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonConvertType == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Error parsing functions expression: type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{commonConvertTypeName}</span></span></span><span class="hljs-string"> not found"</span></span>); } convertType = commonConvertType; convertBackType = commonConvertType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullConvertMethodName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ParseFullMethodName(allTypes, fullConvertMethodName, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> convertType, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> convertMethodName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { convertMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; convertBackMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullConvertBackMethodName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ParseFullMethodName(allTypes, fullConvertBackMethodName, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> convertBackType, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> convertBackMethodName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> convertBackMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseFunctionsExpressionWithRegex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commonConvertTypeName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullConvertMethodName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullConvertBackMethodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FunctionsExpression == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { commonConvertTypeName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertBackMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = _functionsExpressionRegex.Match(FunctionsExpression.Trim()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match.Success) { commonConvertTypeName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertBackMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } commonConvertTypeName = match.Groups[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonConvertTypeName == <span class="hljs-string"><span class="hljs-string">""</span></span>) commonConvertTypeName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertMethodName = match.Groups[<span class="hljs-number"><span class="hljs-number">2</span></span>].Value.Trim(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullConvertMethodName == <span class="hljs-string"><span class="hljs-string">""</span></span>) fullConvertMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; fullConvertBackMethodName = match.Groups[<span class="hljs-number"><span class="hljs-number">3</span></span>].Value.Trim(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullConvertBackMethodName == <span class="hljs-string"><span class="hljs-string">""</span></span>) fullConvertBackMethodName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseFullMethodName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Lazy&lt;Type[]&gt; allTypes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullMethodName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> methodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delimiterPos = fullMethodName.LastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delimiterPos == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { methodName = fullMethodName; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } methodName = fullMethodName.Substring(delimiterPos + <span class="hljs-number"><span class="hljs-number">1</span></span>, fullMethodName.Length - (delimiterPos + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeName = fullMethodName.Substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, delimiterPos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foundType = FindType(allTypes.Value, typeName); type = foundType ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Error parsing functions expression: type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{typeName}</span></span></span><span class="hljs-string"> not found"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type[] types, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullName</span></span></span><span class="hljs-function">)</span></span> =&gt; types.FirstOrDefault(t =&gt; t.FullName.Equals(fullName)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAllTypes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; AppDomain.CurrentDomain.GetAssemblies().SelectMany(a =&gt; a.GetTypes()).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Regex _functionsExpressionRegex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex( <span class="hljs-string"><span class="hljs-string">@"^(?:([^ ,]+) )?([^,]+)(?:,([^,]+))?(?:[\s\S]*)$"</span></span>, RegexOptions.Compiled | RegexOptions.CultureInvariant); <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Converter</span></span> : <span class="hljs-title"><span class="hljs-title">IValueConverter</span></span>, <span class="hljs-title"><span class="hljs-title">IMultiValueConverter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Converter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rootObject, MethodInfo convertMethod, MethodInfo convertBackMethod</span></span></span><span class="hljs-function">)</span></span> { _rootObject = rootObject; _convertMethod = convertMethod; _convertBackMethod = convertBackMethod; _convertMethodParametersCount = _convertMethod != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? _convertMethod.GetParameters().Length : <span class="hljs-number"><span class="hljs-number">0</span></span>; _convertBackMethodParametersCount = _convertBackMethod != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? _convertBackMethod.GetParameters().Length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IValueConverter object IValueConverter.Convert(object value, Type targetType, object parameter, CultureInfo culture) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethod == null) return value; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethodParametersCount == 1) return _convertMethod.Invoke(_rootObject, new[] { value }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethodParametersCount == 2) return _convertMethod.Invoke(_rootObject, new[] { value, parameter }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> throw new InvalidOperationException("Method has invalid parameters"); } object IValueConverter.ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethod == null) return value; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethodParametersCount == 1) return _convertBackMethod.Invoke(_rootObject, new[] { value }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethodParametersCount == 2) return _convertBackMethod.Invoke(_rootObject, new[] { value, parameter }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> throw new InvalidOperationException("Method has invalid parameters"); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IMultiValueConverter object IMultiValueConverter.Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethod == null) throw new ArgumentException("Convert function is not defined"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethodParametersCount == values.Length) return _convertMethod.Invoke(_rootObject, values); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertMethodParametersCount == values.Length + 1) return _convertMethod.Invoke(_rootObject, ConcatParameters(values, parameter)); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> throw new InvalidOperationException("Method has invalid parameters"); } object[] IMultiValueConverter.ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethod == null) throw new ArgumentException("ConvertBack function is not defined"); object converted; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethodParametersCount == 1) converted = _convertBackMethod.Invoke(_rootObject, new[] { value }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_convertBackMethodParametersCount == 2) converted = _convertBackMethod.Invoke(_rootObject, new[] { value, parameter }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> throw new InvalidOperationException("Method has invalid parameters"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (converted is object[] convertedAsArray) return convertedAsArray; // ToDo: Convert to object[] from Tuple&lt;&gt; and System.ValueTuple return null; } static object[] ConcatParameters(object[] parameters, object converterParameter) { object[] result = new object[parameters.Length + 1]; parameters.CopyTo(result, 0); result[parameters.Length] = converterParameter; return result; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> object _rootObject; MethodInfo _convertMethod; MethodInfo _convertBackMethod; int _convertMethodParametersCount; int _convertBackMethodParametersCount; } } }</span></span></code> </pre></div></div><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/326646/">https://habr.com/ru/post/326646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326634/index.html">Bash on Windows: Practical Experiments in Crossing Hedgehogs and Snacks</a></li>
<li><a href="../326636/index.html">Moving XenForo Forum to the modern platform</a></li>
<li><a href="../326640/index.html">How to cram your sensor in Android OS</a></li>
<li><a href="../326642/index.html">Recipe interface</a></li>
<li><a href="../326644/index.html">Scientists from ITMO University have proposed a new system for the transmission of energy over a distance</a></li>
<li><a href="../326648/index.html">St. Petersburg homeless - in Prague. Continuing the history of self-taught developer</a></li>
<li><a href="../326650/index.html">Introduction to machine learning with tensorflow</a></li>
<li><a href="../326652/index.html">Processing of personal data? No, not to us. Elegant solution from Golos</a></li>
<li><a href="../326654/index.html">About multitenancy</a></li>
<li><a href="../326656/index.html">Data science and quality code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>