<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Method of comparing algorithms and for what it may still be useful</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having recently read the article ‚ÄúIntroduction to optimization. Annealing Simulation ‚Äù wanted to take part in the comparison of optimization algorithm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Method of comparing algorithms and for what it may still be useful</h1><div class="post__text post__text-html js-mediator-article">  Having recently read the article <a href="http://habrahabr.ru/post/209610/">‚ÄúIntroduction to optimization.</a>  <a href="http://habrahabr.ru/post/209610/">Annealing Simulation ‚Äù</a> wanted to take part in the comparison of optimization algorithms.  But after all it would be really good to compare them.  And in the materials of the original article does not provide any quantitative data.  So, I thought, we must first formulate the criteria for comparison.  What I propose to do in this article. <br><img src="https://habrastorage.org/getpro/habr/post_images/0c4/2b3/962/0c42b3962d9a0f8d9e5eab7a70d7ffe6.png"><br><a name="habracut"></a><br><br>  So, by what criteria can you compare algorithms similar to "simulated annealing"?  Most often compared: <br>  ‚Ä¢ efficiency <br>  ‚Ä¢ work speed <br>  ‚Ä¢ memory usage <br>  And I would like to add <br>  ‚Ä¢ repeatability (i.e. check how stable the algorithm is in the results obtained). <br><br><h5>  Criteria for evaluation </h5><br>  As the first criterion we will use the length of the resulting route.  I have no idea what is the best route on a randomly generated set of points.  What to do?  Let's try, for simplicity, to drive everything on one set.  More pedantic, for greater reliability of the results, can then be expanded into several sets and average the results.  In the meantime, you need to add the reading of the test set from the file so that the experiment can be repeated. <br>  To determine the speed of work, we calculate the time spent by the processor on the algorithm, the benefit is in Octave such a function.  Of course, on different computers, the result will also be different.  Therefore, for comparison, all the results can be scaled by any one algorithm, always run.  For example, according to the algorithm from the original article, since he was the first to fall. <br>  At the expense of memory outright nothing was invented.  Therefore, try to estimate on the fingers.  As I understand it, the author‚Äôs main expenses are two indices arrays.  One for the current route, the other for the candidate route.  And, of course, an array of route points with two coordinates per point.  The remaining costs will not be taken into account, since they will be different in different execution environments and do not depend on the size of the test data.  (Perhaps here I am somewhat harsh, but quite open to suggestions).  Total major expenses N * 4, where N - the number of points that need to be circumvented. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>A small digression: everything described here was tested not in MatLab, as in the original article, but in Octave [http://www.gnu.org/software/octave/].</i>  <i>There are several reasons for this - firstly, I have it, secondly, its programming language is almost completely compatible with MatLab, and finally, it can be for everyone because it is free and publicly available.</i> <br><br><h5>  Analyzing ... </h5><br>  To begin with, we are convinced of the compatibility for the existing code (it is downloaded by the link at the end of the original article).  Everything works, but it turns out that there is no code generating the beautiful graphics presented in it.  It does not matter - we will write our function from which we call the original algorithm and draw the result.  Anyway, it will be needed for the entire body kit collection of statistics. <br><br>  So the Analyze function: <br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[timeUsed, distTotal]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> %         </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">points_data</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dat</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cities</span></span></span><span class="hljs-function"> %    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStart</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cputime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; %    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimulatedAnnealing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cities, 10, 0.00001)</span></span></span><span class="hljs-function">; %     </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeUsed</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cputime</span></span></span><span class="hljs-function"> - </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStart</span></span></span><span class="hljs-function">; %     </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distTotal</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PathLengthMat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function">; %    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result(:,1)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(:,2)</span></span></span><span class="hljs-function">, '-*'); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawnow</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><br>  The function for generating a file with an array of city coordinates did not begin to write.  This can be done directly from the command line: <br><pre> <code class="matlab hljs"> cities = <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span>; save points_data.dat cities;</code> </pre><br><br>  Yes, if someone noticed that the evaluation does not use the CalculateEnergy function from the original algorithm, then there are two reasons for this.  Firstly, there is an idea to try working on other metrics, and the result is better to evaluate the Euclidean distance.  And secondly, although the author of the original article described in detail the calculation of the Euclidean distance, the code in the sources calculates the Manhattan distance.  Euclidean for two points is correctly calculated as follows: <br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[dist]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distEuclid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A - B)</span></span></span><span class="hljs-function">.^2; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  Well, to determine how stable the result is from time to time, we will run it all in a cycle many times, collect the results and evaluate their average and the degree of scatter of the results: <br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Statistics</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testNum</span></span></span><span class="hljs-function"> = 1000; %      </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeUsed</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(testNum,1)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distTotal</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(testNum,1)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">=1:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testNum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[timeUsed(n), distTotal(n)]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Analyze</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> %      </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[mean(timeUsed), std(timeUsed)]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[mean(distTotal), std(distTotal)]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  The first disappointment is how long it all is!  On the core i5-3450 3.1GHz 8Gb RAM computer, one pass runs an average of 578 seconds.  So, for greater certainty, we wanted to start and average 1000 cycles, but this is ... 6.69 days.  We had to run for 100 cycles and after about 16 hours 4 minutes (that is, the next morning) we have the result: <br>  the average calculation time is 578.1926 (standard deviation in the sample is 3.056), the average length of the resulting path is 91.0844 (standard deviation is 2.49).  That is, everything is more than stable, and, therefore, suitable for use.  But how long.  I could not resist and was tempted to do optimization. <br><br><h5>  Optimization </h5><br>  The first candidate to speed up is distance estimation.  Octave, like MatLab, is optimized for matrix computing - we will rewrite it for this.  The function will take two arrays: A - the beginning of the segments, B - their ends, respectively: <br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[dist]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distEuclid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A - B)</span></span></span><span class="hljs-function">.^2; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist, 2)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  To call this function, we will enter another one that will prepare the data by cyclically shifting the original array of points to obtain an array of the ends of the segments: <br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[length]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PathLengthMat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cities)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">citiesShifted</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circshift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cities, 1)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distEuclid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cities, citiesShifted)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  And, of course, you need to rewrite the function SimulatedAnnealing and GenerateStateCandidate to work directly with arrays of points.  I will not give the full code, at the end there will be a link to the archive with all the sources for those who are interested. <br>  We start, we look ... the average calculation time is 70.554 (standard deviation in the sample is 0.096), the average length of the resulting path is 90.403 (standard deviation 2.204). <br>  The speed increase is more than eight times!  It is no longer interesting to try further - such an increase will not be obtained.  True, the memory consumption (according to the proposed method) is now two arrays of points in two coordinates (the current decision and the new candidate), that is ... N * 4.  Nothing changed. <br>  But, once we evaluate the algorithm, check the temperature data.  The initial ‚Äúenergy‚Äù of the generated arrays of points fluctuates around 500 to 700 final routes at the output fluctuate around 90 plus / minus 5. Consequently, the temperatures chosen by the author practically only provide a limit of 100,000 iterations (by the way, it is also tightly clogged in the code. To prevent looping, I guess I raised up to ten million, why should I restrain myself when checking the algorithm?).  And really, experimenting a little, we get about the same results for Tmax = 300 and Tmin = 0.001.  At the same time, the execution time was reduced to 21 seconds. <br><br><h5>  Exploring options </h5><br>  Now we will try to compare with something.  Initially, the idea was to compare with the Manhattan metric, but it turned out that it was implemented.  Then this optimization.  In short, we add code for the matrix calculation of the Manhattan distance and try for it.  As interesting as another function of temperature change will show itself.  Those who have been deceived by the linearity of the function of temperature change promised in the original article have to be disappointed - it is not.  To understand this, just look at her schedule: <br><img src="https://habrastorage.org/getpro/habr/post_images/248/46e/37a/24846e37ab2d4b9bde1bf230c4b25a82.png"><br><br>  Probably there was a view of the linearity of the denominator of the function, because the denominators of all the other options used in science really look worse. <br>  For comparison, let's try another temperature function T = Tmax * (A ^ k) where A is chosen, usually within 0.7 - 0.999.  (When implemented, it is not greedy at all - Ti = A * Ti-1).  Options for "annealing" with its use are called "quenching."  It drops much faster to the minimum temperature, but flatter at the initial stage.  That is, with it the algorithm experiments more at the beginning, but finishes work faster.  So - a summary table of results: <br><table><tbody><tr><th>  Algorithm </th><th>  Length (Scatter) </th><th>  Time (scatter) </th><th>  Memory </th></tr><tr><td>  From the article </td><td>  91.0844 (2.4900) </td><td>  578.1926 (3.0560) </td><td>  N * 4 </td></tr><tr><td>  Matrix (10-0.00001) </td><td>  90.4037 (2.2038) </td><td>  70.554593 (0.096166) </td><td>  N * 4 </td></tr><tr><td>  Matrix (300-0.001) </td><td>  90.7956 (2.1967) </td><td>  20.94024 (0.16235) </td><td>  N * 4 </td></tr><tr><td>  Manhattan Matrix (10-0.00001) </td><td>  90.0506 (3.2397) </td><td>  70.96909 (0.7807) </td><td>  N * 4 </td></tr><tr><td>  Matrix "quenching" (300-0.001) </td><td>  92.0963 (2.3129) </td><td>  22.59591 (0.39581) </td><td>  N * 4 </td></tr></tbody></table><br><br><h5>  Findings. </h5><br><ol><li>  The ability to quantify the results of the algorithm is useful even if there is no one to compare it with. </li><li>  If you take into account the features of the tool when writing a program - you can save a lot of time. </li><li>  If you choose the parameters for a specific task - you can save some more. </li><li>  It is pointless to compare algorithms for speed without optimization - the execution time will be almost a random variable. </li><li>  For modern processors, it is almost as easy to raise to the power and extract the root as it is to take a module - you can not be distorted and write math almost without simplifications. </li><li>  Many variations of one algorithm give very close results, if not a graphomaniac - use what is more convenient (or more familiar). </li></ol><br><br>  Promised sources can be found at the <a href="http://yadi.sk/d/G9eg-mQ5GxhC9">link</a> <br>  Well, if you like it, you can compare it with something else after a while. </div><p>Source: <a href="https://habr.com/ru/post/210812/">https://habr.com/ru/post/210812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210788/index.html">Google sells Lenovo's Motorola Mobility</a></li>
<li><a href="../210790/index.html">Precedent: do digital TV providers block Rain TV channel ‚Äúfor lack of likes‚Äù and ‚Äúat the request of outraged penguins‚Äù?</a></li>
<li><a href="../210796/index.html">How I knocked out a Facebook interview</a></li>
<li><a href="../210800/index.html">DUMP-2014 will be held in Yekaterinburg on March 14</a></li>
<li><a href="../210808/index.html">We are not building our analogue Google Calendar in 30 lines</a></li>
<li><a href="../210814/index.html">We do automatic watering of a room flower on Arduino in 15 minutes</a></li>
<li><a href="../210816/index.html">Creating and using Matlab clusters</a></li>
<li><a href="../210818/index.html">Resurrection Sharepoint or how not to burn at the stake of the Inquisition</a></li>
<li><a href="../210820/index.html">About using $ .Deferred to work with asynchronous tasks</a></li>
<li><a href="../210822/index.html">Better to lose a day, and then teleport wherever you want and how much you want</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>