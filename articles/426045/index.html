<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Special exceptions in .NET and how to prepare them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Different exceptions in .NET have their own characteristics, and knowing them can be very useful. How to trick the CLR? How to stay alive in runtime b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Special exceptions in .NET and how to prepare them</h1><div class="post__text post__text-html js-mediator-article">  Different exceptions in .NET have their own characteristics, and knowing them can be very useful.  How to trick the CLR?  How to stay alive in runtime by catching a StackOverflowException?  It seems that it is impossible to catch any exceptions, but if you really want to, you can? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Under the cut, the transcript of the report of Eugene ( <a href="https://habr.com/users/epeshk/" class="user_link">epeshk</a> ) Peshkov from our conference <a href="https://dotnext-piter.ru/2018/spb/talks/1fa0f066tysugkkwmeyam4/">DotNext 2018 Piter</a> , where he told about these and other features of the exceptions. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Hello!  My name is Evgeniy.  I work at SKB Kontur and develop a system for hosting and deploying applications for Windows.  The bottom line is that we have many grocery teams that write their own services and host them with us.  We provide them with an easy and simple solution to a variety of infrastructure problems.  For example, to track the consumption of system resources or drop the replicas to the service. <br><br>  Sometimes it turns out that applications hosted on our system are falling apart.  We have seen so many ways that an application can crash at runtime.  One of these ways is to throw out some unexpected and enchanting exception. <br><br>  Today I will talk about the features of exceptions in .NET.  We encountered some of these features in production, and some of them during experiments. <br><br><h2>  Plan </h2><br><ol><li>  Exception behavior in .NET <br></li><li>  Windows exception handling and hacks <br></li></ol><br>  Everything discussed below is true for Windows.  All examples were tested on the latest version of the full .NET framework 4.7.1.  There will also be few references to .NET Core. <br><br><h2>  Access Violation </h2><br>  This exception happens during incorrect memory operations.  For example, if an application tries to access a memory area to which it does not have access.  The exception is low-level, and usually, if it happens, there will be a very long debugging. <br><br>  Let's try to get this exception using C #.  To do this, we write byte 42 at 1000 (we assume that 1000 is a fairly random address and our application most likely does not have access to it). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte does just what we need: writes a byte at a given address.  We expect this call to throw an AccessViolationException.  This code will really throw this exception, it will be able to process it and the application will continue to work.  Now let's change the code a bit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  If, instead of WriteByte, you use the Copy method and copy byte 42 at address 1000, then using try-catch, AccessViolation cannot be caught.  At the same time, a message will be displayed on the console stating that the application has been terminated due to a raw AccessViolationException. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  It turns out that we have two lines of code, while the first one crashes the entire application with AccessViolation, and the second throws a processed exception of the same type.  To understand why this is happening, we will look at how these methods are designed from the inside. <br><br>  Let's start with the Copy method. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The only thing that the Copy method does is call the CopyToNative method, implemented inside .NET.  If our application does crash and an exception happens somewhere, then this can only happen inside CopyToNative.  From here you can make the first observation: if the .NET code caused the native code and AccessViolation occurred inside it, then the .NET code cannot handle this exception for some reason. <br><br>  Now let's see why we managed to process AccessViolation using the WriteByte method.  Let's look at the code for this method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  This method is implemented entirely in managed code.  Here C # -pointer is used to write data to the desired address, and NullReferenceException is also intercepted.  If an NRE is caught, an AccessViolationException is thrown.  So need because of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.writebyte">specification</a> .  At the same time, all exceptions thrown by the throw construct are processed.  Accordingly, if a nullReferenceException occurs during the execution of the code inside WriteByte, we will be able to catch AccessViolation.  Could NRE, in our case, occur when accessing not 1000 address, but address 1000? <br><br>  Let's rewrite the code using C # pointers directly, and see that when accessing a non-zero address, a NullReferenceException is really thrown: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  To understand why this is happening, we need to remember how the process memory is organized.  In the process memory all addresses are virtual.  This means that the application has a large address space and only some pages from it are displayed in real physical memory.  But there is a feature: the first 64 KB of addresses are never displayed in physical memory and are not given to the application.  Rantaym .NET knows this and uses it.  If AccessViolation occurred in a managed code, then runtime checks to which address in memory the access occurred, and generates a corresponding exception.  For addresses from 0 to 2 ^ 16 - NullReference, for all others - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Let's see why NullReference is thrown not only when accessing a zero address.  Imagine that you are accessing a field of an object of a reference type, and the reference to this object is zero: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  In this situation, we expect to get a NullReferenceException.  The reference to the field of an object occurs by offset relative to the address of this object.  It turns out that we turn to an address close enough to zero (recall that the reference to our original object is zero).  With this behavior, we get the expected exception without further checking the address of the object itself. <br><br>  But what happens if we access the field of an object, and the object itself takes more than 64 KB? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  Can we get AccessViolation in this case?  Let's do an experiment.  Create a very large object and refer to its fields.  One field - at the beginning of the object, the second - at the end: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Both methods throw a NullReferenceException.  No AccessViolationException will occur. <br>  Look at the instructions that will be generated for these methods.  In the second case, the JIT compiler added an additional cmp instruction that accesses the address of the object itself, thereby causing an AccessViolation with a zero address, which will be converted to runtime NullReferenceException. <br><br>  It is worth noting that for this experiment it is not enough to use an array as a large object.  Why?  Leave this question to the reader, write ideas in the comments :) <br><br>  Let's summarize the experiments with AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException behaves differently depending on where the exception occurred (in a managed code or in a native code).  In addition, if an exception occurred in the managed code, the address of the object will be checked. <br><br>  The question arises: can we handle an AccessViolationException that occurred in native code or in managed code, but not converted to a NullReference and not thrown using a throw?  This is sometimes a useful feature, especially when working with unsafe code.  The answer to this question depends on the version of .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  In .NET 1.0 there was no AccessViolationException at all.  All links were considered either valid or null.  By the time of .NET 2.0, it became clear that without direct work with memory - in any way, and AccessViolation appeared, while being processed.  In 4.0 and higher, it was still processed, but processing it was not so easy.  To catch this exception, you now need to mark the method that contains the catch block with the HandleProcessCorruptedStateException attribute.  Apparently, the developers did this because they thought that AccessViolationException is not the exception that should be caught in a regular application. <br>  In addition, for backward compatibility it is possible to use runtime settings: <br><br><ul><li>  legacyNullReferenceExceptionPolicy returns .NET 1.0 behavior - all AVs turn into NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy returns .NET 2.0 behavior - all AVs are intercepted <br></li></ul><br>  The .NET Core AccessViolation is not handled at all. <br><br>  In our production there was such a situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  The application compiled for .NET 4.7.1 used a common code library compiled for .NET 3.5.  In this library, there was a helper to run a periodic action: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  In this helper, we passed the action from our application.  It so happened that he fell from AccessViolation.  As a result, our application constantly logged AccessViolation, instead of falling, because  The code in the library under 3.5 could catch it.  It should be noted that interceptability does not depend on the version of the runtime on which the application is running, but on TargetFramework, under which the application was built, and its dependencies. <br><br>  Summing up.  The processing of AccessVilolation depends on where it originated ‚Äî in native or managed code ‚Äî and also on TargetFramework and runtime settings. <br><br><h2>  Thread abort </h2><br>  Sometimes in the code you need to stop the execution of one of the threads.  For this, you can use the thread.Abort () method; <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  When the Abort method is called, a ThreadAbortException is thrown in the thread being stopped.  We analyze its features.  For example, the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ‚Ä¶ } }); ... thread.Abort();</code> </pre><br>  Absolutely equivalent to this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  If you still need to handle ThreadAbort and perform some other actions in the stream that is stopped, then you can use the Thread.ResetAbort () method;  It stops the process of stopping the thread and the exception stops prokidyvatsya higher in the stack.  It is important to understand that the thread.Abort () method by itself does not guarantee anything - the code in the stream being stopped may prevent it from stopping. <br><br>  Another feature of thread.Abort () is that it will not be able to interrupt the code if it is in catch and finally blocks. <br><br>  Inside the framework code, you can often find methods in which the try block is empty, and all the logic is inside finally.  This is done in order to prevent this code from being interrupted by a ThreadAbortException. <br><br>  Also calling the thread.Abort () method waits for a ThreadAbortException to be thrown.  Let us combine these two facts and obtain that the thread.Abort () method can block the calling thread. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  In reality, this can be encountered when using the using construct.  It unfolds in try / finally, and Dispose is called inside finally.  It can be arbitrarily complex, contain calls, event handlers, use locks.  And if thread.Abort was called during execution, Dispose - thread.Abort () will wait for it.  So we get a lock almost from scratch. <br><br>  In the .NET Core, the thread.Abort () method throws a PlatformNotSupportedException.  And I think this is very good, because it motivates to use not thread.Abort (), but non-invasive methods of stopping code execution, for example, using CancellationToken. <br><br><h2>  OUT OF MEMORY </h2><br>  This exception can be obtained if the memory on the machine is less than what is required.  Or when we have rested against restrictions of 32-bit process.  But you can get it, even if the computer has a lot of free memory, and the process is 64-bit. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  The code above will throw OutOfMemory.  The thing is that in the default data objects with no more than 2 GB are not allowed.  This can be fixed by setting gcAllowVeryLargeObjects in App.config.  In this case, an array of 4 GB is created. <br><br>  And now we will try to create an array even more. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Now even gcAllowVeryLargeObjects will not help.  All due to the fact that in .NET there is a <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element">limit on the maximum index in the array</a> .  This limit is less than int.MaxValue. <br><br>  Max array index: <br><br><ul><li>  byte arrays - 0x7FFFFFC7 <br></li><li>  other arrays - 0X7F <b>E</b> FFFFF <br></li></ul><br>  In this case, an OutOfMemoryException will occur, although in reality we have rested on the data type restriction, and not on the lack of memory. <br><br>  Sometimes OutOfMemory is explicitly thrown away by managed code inside the .NET framework: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  This is an implementation of the string.Concat method.  If the length of the result string is greater than int.MaxValue, then an OutOfMemoryException is immediately thrown. <br><br>  Let us turn to the situation when OutOfMemory arises in the case, when the memory really ends. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  First, we limit the memory of our process to 64 MB.  Next, inside the loop, select the new arrays of bytes, save them to some sheet so that the GC does not collect them, and try to catch OutOfMemory. <br><br>  In this case, anything can happen: <br><br><ul><li>  Exception will be processed <br></li><li>  The process will fall <br></li><li>  Go to catch, but the exception will crash again. <br></li><li>  Go to catch, but StackOverflow will crash. <br></li></ul><br>  In this case, the program will turn out to be absolutely non-deterministic.  We analyze all the options: <br><br><ol><li>  Exception can be handled.  Inside .NET, nothing prevents you from handling OutOfMemoryException. <br></li><li>  The process may fall.  Do not forget that we have a managed application.  This means that not only our code is executed inside it, but also runtime code.  For example, GC.  Thus, a situation may happen when the runtime wants to allocate memory for itself, but cannot do it, then we will not be able to catch the exception. <br></li><li>  Go to catch, but the exception will crash again.  Inside the catch, we also perform work in which we need memory (we print an exception on the console), and this may cause a new exception. <br></li><li>  Go to catch, but StackOverflow will crash.  StackOverflow itself occurs when the WriteLine method is called, but there is no stack overflow, and a different situation occurs.  We will analyze it in more detail. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  In virtual memory, pages can be not only mapped to physical memory, but can also be reserved (reserved).  If the page is reserved, the application indicated that it was going to use it.  If the page is already mapped into real memory or a swap, then it is called ‚Äúcommitted‚Äù.  The stack uses this ability to divide memory into reserved and locked-in memory.  It looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  It turns out that we call the WriteLine method, which takes some place on the stack.  So it turns out that the entire zakommichennaya memory is over, then the operating system at this point should take another reserved page of the stack and display it in real physical memory, which is already filled with arrays of bytes.  This results in a StackOverflow exception. <br><br>  The following code will allow at the start of the thread to commit all the memory under the stack at once. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  In addition, you can use runtime setting <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/disablecommitthreadstack-element">disableCommitThreadStack</a> .  It needs to be disabled so that the thread stack commits in advance.  It should be noted that the default behavior described in the documentation and observed in reality is different. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Stack overflow </h2><br>  Let's understand in more detail with StackOverflowException.  Let's look at two code examples.  In one of them, we run an infinite recursion that causes stack overflow, in the second we just throw this exception using throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Since all exceptions thrown with throw are processed, in the second case we will catch the exception.  And with the first case all the more interesting.  Refer to <a href="https://msdn.microsoft.com/en-us/library/w6sxk224.aspx">MSDN</a> : <br><br><blockquote>  "You can‚Äôt catch the stack overflow exceptions, because the exception code may need the stack." <br>  MSDN </blockquote><br>  It says here that we will not be able to intercept a StackOverflowException, since the interception itself may require additional stack space that has already ended. <br><br>  To somehow protect against this exception, you can proceed as follows.  First, you can limit the depth of recursion.  Secondly, you can use the methods of the class RuntimeHelpers: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  ‚ÄúEnsures that the remaining stack space is large .NET Framework function.‚Äù - MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 KB - x86, AnyCPU, 2 MB - x64 (half of stack size) <br></li><li>  64/128 KB - .NET Core <br></li><li>  Check only stack address space <br></li></ul><br></blockquote><br>  The documentation for this method says that it checks that there is enough space on the stack to perform the <i>average</i> .NET function.  But what is the <i>average</i> function?  In fact, in the .NET Framework, this method checks that at least half of its size is free on the stack.  In .NET Core, it checks to have 64 KB free. <br><br>  Also in .NET Core an analog appeared: RuntimeHelpers.TryEnsureSufficientExecutionStack () returning a bool, rather than throwing an exception. <br><br>  In C # 7.2, it became possible to use Span and stackallock together without using unsafe code.  Perhaps because of this, stackalloc will be used more often in code and it will be useful to have a way to protect against StackOverflow when using it, choosing where to allocate memory.  As such a method, a method is proposed <a href="https://github.com/dotnet/corefx/issues/26954">that tests the possibility of allocation on the stack</a> and the <a href="https://github.com/dotnet/corefx/issues/26954">trystackalloc</a> construction. <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Let's go back to the StackOverflow documentation on MSDN <br><br><blockquote>  Instead, when a stack overflow occurs, the CLI terminates the process. ‚Äù <br>  MSDN <br></blockquote><br>  If there is a ‚Äúnormal‚Äù application that crashes on StackOverflow, then there is also a non- ‚Äúnormal‚Äù application that does not crash?  In order to answer this question you will have to go down to the level below from the level of the managed application to the CLR level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "It allows you to continue the process." - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  An application that is hosted by the CLR can override the behavior of a stack overflow so that instead of terminating the entire process, the Application Domain is unloaded, in the thread of which this overflow occurred.  Thus, we can turn a StackOverflowException into an AppDomainUnloadedException. <br><br>  When you run a managed application, the .NET runtime automatically starts.  But you can go the other way.  For example, write an unmanaged application (in C ++ or another language) that will use a special API to raise the CLR and run our application.  An application that runs inside of itself CLR will be called CLR-host.  Having written it, we can configure many things in runtime.  For example, replace the memory manager and the thread manager.  We in production use the CLR-host in order to avoid memory pages getting into the swap. <br><br>  The following code configures the CLR-host so that the AppDomain (C ++) is unloaded when StackOverflow: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Is this a good way to escape from StackOverflow?  Probably not.  First, we had to write code in C ++, which we would not like to do.  Secondly, we need to change our C # code so that the function that can throw a StackOverflowException is performed in a separate AppDomain and in a separate thread.  Our code will immediately turn into such noodles: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  In order to call the InfiniteRecursion method, we wrote a bunch of lines.  Third, we started using the AppDomain.  And it almost guarantees a bunch of new problems.  Including, with exceptions.  Consider an example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Since our exception is not marked as serializable, our code will drop with a SerializationException exception.  And in order to fix this problem, it is not enough for us to mark our exception with the Serializable attribute, we still need to implement an additional constructor for serialization. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  It all turns out not very nice, so we go further - to the level of the operating system and hacks, which should not be used in production. <br><br><h2>  SEH / VEH </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Note that if Managed-exceptions flew between Managed and CLR, then SEH-exceptions fly between CLR and Windows. <br><br>  SEH - Structured Exception Handling <br><br><ul><li>  Windows exception handling mechanism <br></li><li>  Uniform software and hardware exception handling <br></li><li>  C # exceptions are implemented over SEH <br></li></ul><br>  SEH is an exception handling mechanism in Windows; it allows you to handle any exceptions that came from the processor level, for example, or were related to the logic of the application itself. <br><br>  Rantaym .NET knows about SEH exceptions and knows how to convert them into managed exceptions: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Crash <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Unknown SEH exceptions -&gt; SEHException <br></li></ul><br>  We can interact with SEH via WinApi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, the throw construct also works through SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting here that the CLR-exception code is always the same, so whatever type of exception we throw, it will always be processed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH is vector-based exception handling, an extension of SEH, but operating at the process level and not at the level of a single thread. </font><font style="vertical-align: inherit;">If SEH by semantics is similar to try-catch, then VEH by semantics is similar to interrupt handler. </font><font style="vertical-align: inherit;">We simply set our handler and can receive information about all exceptions that occur in our process. </font><font style="vertical-align: inherit;">An interesting feature of VEH is that it allows you to change the SEH exception before it gets to the handler.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can put our own vector handler between the operating system and runtime, which will handle SEH-exceptions and change it so that the .NET runtime does not crash the process when it encounters EXCEPTION_STACK_OVERFLOW. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can interact with VEH via WinApi:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Context contains information about the state of all processor registers at the time of the exception. </font><font style="vertical-align: inherit;">We will be interested in EXCEPTION_RECORD and the ExceptionCode field in it. </font><font style="vertical-align: inherit;">We can replace it with our own exception code, which the CLR knows nothing about. </font><font style="vertical-align: inherit;">The vector handler looks like this:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we‚Äôll make a wrapper that installs a vector handler as a HandleSO method, which takes a delegate that can potentially fall from a StackOverflowException (for clarity, the code does not handle WinApi functions and deletes the vector handler). </font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside it also uses the SetThreadStackGuarantee method. </font><font style="vertical-align: inherit;">This method reserves stack space for processing StackOverflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we can survive a method call with infinite recursion. </font><font style="vertical-align: inherit;">Our stream will continue to work as if nothing had happened, as if no overflow occurred. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, what happens if you call HandleSO twice in the same thread?</font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there will be an AccessViolationException. Let's go back to the stack device. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The operating system can detect stack overflow. At the very top of the stack is a special page marked with the Guard page flag. When you first access this page, another exception will occur - STATUS_GUARD_PAGE_VIOLATION, and the Guard page flag will be removed from the page. If you just intercept this overflow, then this page will no longer be on the stack - on the next overflow the operating system will not be able to understand this and the stack-pointer will go beyond the boundaries of the memory allocated for the stack. As a result, AccessViolationException will occur. So you need to restore page flags after processing StackOverflow - the easiest way to do this is to use the _resetstkoflw method from runtime library C (msvcrt.dll).</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a similar way, you can catch AccessViolationException in a .NET Core under Windows, which causes the process to crash. </font><font style="vertical-align: inherit;">In this case, you need to take into account the order of calling vector handlers and set your handler to the beginning of the chain, since .NET Core also uses VEH when processing AccessViolation. </font><font style="vertical-align: inherit;">The first parameter of the AddVectoredExceptionHandler function is responsible for the order of calling handlers:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Having studied the practical issues, we summarize the results: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exceptions are not as simple as they seem; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not all exceptions are handled the same way; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exception handling occurs at different levels of abstraction; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can intervene in the process of exception handling and make the .NET runtime not work as originally intended. </font></font><br></li></ul><br><h2>  Links </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí A </font></font><a href="https://github.com/epeshk/dotnext-2018-exceptions"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository with examples from the report</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://www.youtube.com/watch%3Fv%3DU92Ts53win4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 Moscow - Adam Sitnik - Exceptional Exceptions in .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://github.com/sidristij/dotnetbook/tree/master/ExceptionalFlow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: Exceptions</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://blog.adamfurmanek.pl/blog/2018/04/07/handling-stack-overflow-exception-in-c-with-veh/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inline C # with VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - another way to intercept StackOverflow</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On November 22-23, Evgeny will speak at </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018 Moscow</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the report </font></font><a href="https://dotnext-moscow.ru/2018/msk/talks/6a8kd5su3ekeqigaw8swq0/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúSystem Metrics: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Collecting </font></b><a href="https://dotnext-moscow.ru/2018/msk/talks/6a8kd5su3ekeqigaw8swq0/"><font style="vertical-align: inherit;">Pitfalls‚Äù</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And Jeffrey Richter, Greg Young, Pavel Yosifovich and other equally interesting speakers will come to Moscow. </font><font style="vertical-align: inherit;">Report topics can be viewed </font></font><a href="https://dotnext-moscow.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and tickets </font><font style="vertical-align: inherit;">can be </font><font style="vertical-align: inherit;">bought </font></font><a href="https://dotnext-moscow.ru/registration/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Join now!</font></font></blockquote></div><p>Source: <a href="https://habr.com/ru/post/426045/">https://habr.com/ru/post/426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426029/index.html">Hands down and want to quit the task? This is effective developer training.</a></li>
<li><a href="../426031/index.html">Anxiety about the capture of the world by artificial intelligence, perhaps based on unscientific assumptions</a></li>
<li><a href="../426033/index.html">Titans from mathematics have clashed over the epic evidence of the abc hypothesis</a></li>
<li><a href="../426039/index.html">Emergency launch of Soyuz MS-10 (crew rescued, broadcast over)</a></li>
<li><a href="../426041/index.html">Symbolic solution of linear differential equations and systems by the Laplace transform method using SymPy</a></li>
<li><a href="../426047/index.html">10 great books for beginners in English</a></li>
<li><a href="../426051/index.html">Improving software debugging skills - some tips</a></li>
<li><a href="../426053/index.html">Caching event handlers and improving the performance of React applications</a></li>
<li><a href="../426055/index.html">TensorFlow.js and clmtrackr.js: tracking the direction of the user's gaze in the browser</a></li>
<li><a href="../426059/index.html">Tutu PHP Meetup # 2: Video Speeches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>