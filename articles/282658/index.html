<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile application against fraudsters and paperwork in auto insurance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we want to share our experience in the analysis of cars. No, we are not planning to launch Top Gear. We have another topic for you - how to tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile application against fraudsters and paperwork in auto insurance</h1><div class="post__text post__text-html js-mediator-article">  Today we want to share our experience in the analysis of cars.  No, we are not planning to launch Top Gear.  We have another topic for you - how to translate paperwork around voluntary auto insurance with the help of a mobile application - well-known hull insurance. <br><br>  The topic will be of interest primarily to those involved in the development of mobile business applications and automation of business processes.  We will tell interesting technical moments on the example of development for iOS. <br><img src="https://habrastorage.org/files/0a3/5fa/7cc/0a35fa7cc94243baa0f84ffba99502b8.jpg"><br><a name="habracut"></a><br><br>  So, to the problematic.  CASCO is the second largest service of insurance companies for individuals.  The most popular, of course, CTP, and then immediately CASCO.  That's just to issue a CTP can be literally at every step, and you still have to sweat for CASCO: not only choose an insurance agent, but wait for an agent, fill a pile of pieces of paper, spend an inspection of the car with the agent, wait for him to take all the papers and photos to the office the underwriter will check everything, give the go-ahead, after that you sign the documents, you are ready to accept the money, and your machine is finally protected.  Hallelujah! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/ad4/4de/9c0/ad44de9c0a9c48c488c87dfd6b1657c0.jpg"><br><br>  But insurance, of course, understand that the bureaucratic system, paperwork, poor quality of work of specialists really prevent them from developing the service and attracting new customers.  And what to do? <br><br>  We responded to this call from the mobile application for insurance agents for iOS and Android, the server part and the workplace of the underwriter.  Through the application, company representatives receive orders and they can also conduct a full inspection and photofixing procedure with instant data sending to the insurance company, where the underwriter checks them and makes a verdict. <br><br><img src="https://habrastorage.org/files/2a8/a4f/807/2a8a4f8070a34dfba804bf7cf619e92a.jpg"><br><br>  A single application solves a number of problems of the insurance company: <br><ol><li>  Provides easier "entry to the profession."  Instead of full-time training of agents, providing them with cameras, it is now enough to give the agent a link to download the application. </li><li>  This increases the quality of the agents.  Due to the multiple ‚Äúprotection against fool‚Äù sewn into the application, the procedure involves strict adherence to the technology. </li><li>  And at the same time, this technology effectively protects against all sorts of scams and fraud at the expense of control measures and restrictions provided for in the application. </li></ol><br>  As a result, the insurance company at the same time got the opportunity to reduce the costs of concluding a CASCO contract, improve the quality of agents' work and protect themselves from fraud. <br><br><h2>  And now to the implementation </h2><br>  As usual, a lot was fairly standard.  But there were also interesting technical problems, the implementation of which we want to share with you. <br><br><h3>  1. Inspection planning </h3><br>  After registration in the application (and later - after login), the user (insurance agent) sees a list of requests for inspection.  On request, he can schedule a visit to the future or start it immediately. <br><br>  To schedule an inspection, the user specifies the date and time of the inspection, and can optionally specify an address.  For inspection, an event is automatically created in the calendar of the smartphone, and a reminder is set one hour before the inspection.  If the user changes the scheduled time - the event in the calendar is also updated. <br><br><img src="https://habrastorage.org/files/46a/38b/c44/46a38bc445a94d5a91d4481478b9797d.jpg"><br><br>  To implement this synchronization, we used the standard EventKit calendar library: <br><div class="spoiler">  <b class="spoiler_title">Sync with standard calendar</b> <div class="spoiler_text"><pre><code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)syncEventForSurvey:(Survey *)survey completion:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *))completion { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!survey.dateScheduled) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore requestAccessToEntityType:EKEntityTypeEvent completion:^(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> granted, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error) { <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_main_queue(), ^{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!granted || error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completion) completion(error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">NSTimeInterval</span></span> oneHour = <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>; EKEvent *event = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (survey.eventIdentifier) { event = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore eventWithIdentifier:survey.eventIdentifier]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!event) { event = [EKEvent eventWithEventStore:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore]; event.calendar = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> surveysCalendar]; event.title = survey.title; <span class="hljs-built_in"><span class="hljs-built_in">NSTimeInterval</span></span> alarmOffset = -oneHour; EKAlarm *alarm = [EKAlarm alarmWithRelativeOffset:alarmOffset]; event.alarms = @[alarm]; } event.startDate = survey.dateScheduled; <span class="hljs-built_in"><span class="hljs-built_in">NSTimeInterval</span></span> surveyDuration = oneHour; event.endDate = [event.startDate dateByAddingTimeInterval:surveyDuration]; <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *saveError = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore saveEvent:event span:EKSpanThisEvent commit:<span class="hljs-literal"><span class="hljs-literal">YES</span></span> error:&amp;saveError]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!saveError) { survey.eventIdentifier = event.eventIdentifier; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completion) completion(saveError); }); }]; }</code> </pre> <br></div></div><br><br>  eventStore is just [[EKEventStore alloc] init]; <br>  surveysCalendar is a bit more complicated: <br><br><div class="spoiler">  <b class="spoiler_title">surveysCalendar</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">- (EKCalendar *)surveysCalendar { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *calendarTitle = <span class="hljs-string"><span class="hljs-string">@" "</span></span>; EKCalendar *calendar = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.surveysCalendarIdentifier) { calendar = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore calendarWithIdentifier:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.surveysCalendarIdentifier]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!calendar) { <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *allCalendars = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore calendarsForEntityType:EKEntityTypeEvent]; calendar = [allCalendars etr_filter:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(EKCalendar *obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [obj.title isEqualToString:calendarTitle]; }].firstObject; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!calendar) { calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore]; calendar.source = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore.defaultCalendarForNewEvents.source; calendar.title = calendarTitle; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eventStore saveCalendar:calendar commit:<span class="hljs-literal"><span class="hljs-literal">YES</span></span> error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.surveysCalendarIdentifier = calendar.calendarIdentifier; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calendar; }</code> </pre><br></div></div><br>  When the inspection is set to dateScheduled, it synchronizes with the calendar.  In our application, this happens when you save a scheduled inspection. <br><br><h3>  2. Inspection </h3><br>  To conduct an inspection, the user selects an object from the list of scheduled or recently uploaded inspection requests and clicks on the ‚ÄúInspect‚Äù button.  The inspection itself consists of two parts - the inspection of the vehicle and the addition of documents. <br><br><img src="https://habrastorage.org/files/a50/5fa/fd5/a505fafd520643769578fbb9de469384.jpg"><br><br>  The "Documents" block is simply a list of documents that, if necessary, can be photographed and sent to the server.  This part is not mandatory, and there are no restrictions on it either. <br><br>  In the inspection of the car is much more interesting.  It consists of several blocks: <br><ul><li>  mandatory vehicle photography block, </li><li>  optional blocks for specifying additional equipment and damage. </li></ul><br><br>  To prevent the "fake" photo in the application has several limitations: <br><ul><li>  inspection time limit - 30 minutes, </li><li>  fixing the geolocation of each photo, </li><li>  There is no possibility to add photos from the library of the smartphone. </li></ul><br><br><h3>  2.1.  Timer, or have time for 30 minutes </h3><br>  As soon as the user clicks the ‚ÄúStart Inspection‚Äù button, a countdown starts.  And on all screens of the application in the mode of inspection, a timer is displayed.  If the vehicle inspection (TC) was not carried out in 30 minutes, all photos taken for this inspection are deleted, and the inspection must be started anew.  This restriction prevents fraudulent photographing of different cars for a single inspection. <br><br><h3>  2.2 Restriction on geolocation </h3><br>  Also, to prevent fraud, at first we wanted to interrupt the inspection if the user retired more than 500 meters from the point of the beginning of the inspection.  We even implemented it like this: <br><br>  <i>At the start of the inspection, the application saves the current geolocation as the starting one and subscribes to notifications on geolocation changes for the next 30 minutes.</i>  <i>When receiving new coordinates, it is compared whether the distance to the starting point has exceeded 500 meters.</i>  <i>In case of removal from the point of the beginning of inspection more than 500 meters, the inspection ends and it needs to be started anew.</i> <br><br>  So it was intended.  But this idea had to be abandoned, because the accuracy of obtaining coordinates strongly depends on the source of the signal.  In some situations, when the mobile device determines the geolocation by Wi-Fi points, when reconnecting between them, the application can receive information about a distance change of more than 500 meters, although the user has not passed three.  Due to such surges, the inspection was interrupted.  We cannot limit the location of the inspection, as well as the sources of information about geo-location, therefore we had to refuse from this restriction. <br><br>  However, security is maintained.  Geodata are added to all photos taken during the inspection process, which are transmitted to the server.  And without determining geolocation, the possibility of conducting an inspection is blocked. <br><br><h3>  2.3.  Correct photofixation </h3><br>  Photos that are used in the application are created and stored only in the application.  There is no way to save photos to the library or transfer them to anywhere other than the insurance company's server.  This means that the agent will not be able to fake the photo, and the photo of the vehicle will not fall into the wrong hands. <br><br>  In the course of the inspection, the agent photographs all the elements of the car, following the procedure by which the application conducts it.  Each inspection element for which you need to take a photo has a name: ‚ÄúWindshield‚Äù, ‚ÄúVehicle on the right side‚Äù, ‚ÄúDiagonal Vehicle on the right corner of the rear bumper‚Äù.  In order to make it easier to choose the right angle of shooting, masks and prompts are implemented in the application.  On the mask, which is displayed in the photographing mode, marked by the frame position of the wheels of the car.  A hint is also available from the photographing mode, which contains an example of the finished photo in the appropriate perspective. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/442/01f/7a6/44201f7a668940269988fd09152ac62a.jpg"></div><br><br><h3>  2.4.  Damage photos </h3><br>  And finally, in the application, the agent points out and separately photographs all the detected damage to the car.  The part on which there is damage should be noted on the diagram.  After the part is selected, the user can specify the specific part of the part and the type of damage and take two photos: a detailed photo of the damage and a photo of the defect in the general plan of the part of the car. <br><br><img src="https://habrastorage.org/files/cc4/1fd/a6b/cc41fda6b1f84f268cb70e2b9ca90e03.jpg"><br><br>  In the application on the auto layout, the agent selects the part of the vehicle on which there is damage, it is highlighted in color, and then the application proceeds to the photographing stage of the damage. <br><br>  To realize the selection on the diagram of curvilinear elements (and the details of the car are all like that), we used Bezier curves obtained from the SVG (Scalable Vector Graphics) format. <br><br>  Bezier curves allow you to set the equation for complex curves, and in our case, the contours of car parts, and SVG, a two-dimensional vector image format based on XML.  Curiously, the Bezier curves were developed specifically for the design of body parts of cars. <br>  More information about the curves and the SVG format can be found here: <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">ru.wikipedia.org/wiki/Kriva_Bezier</a> <br>  <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">en.wikipedia.org/wiki/Scalable_Vector_Graphics</a> <br><br>  And our recipe for selecting parts on the diagram looks like this: <br>  First, the designers drew a diagram of the car in three projections in the SVG.  We converted the image from the SVG format into a set of individual parts files in the form of Bezier curves (you can use PocketSVG - <a href="https://github.com/arielelkin/PocketSVG">github.com/arielelkin/PocketSVG</a> for this). <br><br>  All .bezier files were added to the project and used on the screen with the scheme: the background image with the car is used, and the details from the UIBezierPath are added from above: <br><div class="spoiler">  <b class="spoiler_title">Work with Bezier curves</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)awakeFromNib { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *carParts = [SurveyStructure sharedStructure].carParts; <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *newLayers = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (SurveyStructureCarPart* part <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> carParts) { <span class="hljs-keyword"><span class="hljs-keyword">@autoreleasepool</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *filepath = [[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] pathForResource:part.identifier ofType:<span class="hljs-string"><span class="hljs-string">@"bezier"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> *bezier = [<span class="hljs-built_in"><span class="hljs-built_in">NSKeyedUnarchiver</span></span> unarchiveObjectWithFile:filepath]; CarPartLayer* layer = [[CarPartLayer alloc] initWithCarPart:part]; layer.anchorPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointZero</span></span>; layer.path = bezier.CGPath; layer.actions = @{<span class="hljs-string"><span class="hljs-string">@"fillColor"</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> null], <span class="hljs-string"><span class="hljs-string">@"opacity"</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> null]}; [newLayers addObject:layer]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layersContainer.layer insertSublayer:layer atIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carPartLayers = newLayers; }      : - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)hightlightPartAtPoint:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)point { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (CarPartLayer *layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carPartLayers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">CGPathContainsPoint</span></span>(layer.path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, point, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.highlightedLayer != layer) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.highlightedLayer = layer; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.highlightedLayer != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.highlightedLayer = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } }</code> </pre><br></div></div><br><br>  For the convenience of selecting parts on the diagram, a ‚Äúmagnifying glass‚Äù is used (for example, <a href="https://cocoapods.org/pods/iOS-MagnifyingGlass">cocoapods.org/pods/iOS-MagnifyingGlass</a> ). <br><br><h3>  3. Data transfer </h3><br>  After all the necessary photos have been taken, the application prompts the user to complete the inspection and send the data to the server.  The user presses the magic button, and the inspection is transferred to the send queue. <br><br><h3>  3.1.  Sending in the background </h3><br>  Sending inspections is made in the background.  And when the application is running, and when the application is in the background.  In the UploadManager singleton, FetchResultsController is used, which selects objects in the ‚ÄúTo Send‚Äù status from the list of inspections.  When translating some inspection for shipment, Fetcher tells the manager what to download.  The manager downloads the inspection data to the server, and changes the status of the object.  After that, a check is made about the presence of other inspections for shipment.  If there are no other contracts at this time, the download manager will wait for the next notification from the fetcher. <br><br><img src="https://habrastorage.org/files/1b5/030/a13/1b5030a138184a8196106d3cf7864b9c.jpg"><br><br>  That the application sent the data on inspections in a background, we added backgroud task: <br><div class="spoiler">  <b class="spoiler_title">Synchronization in the background</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)applicationDidEnterBackground:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> *)application { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([[UploadSurveysManager sharedManager] isNeedUpload]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bgTask = [application beginBackgroundTaskWithExpirationHandler:^{ [application endBackgroundTask:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bgTask]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bgTask = <span class="hljs-built_in"><span class="hljs-built_in">UIBackgroundTaskInvalid</span></span>; }]; [[UploadSurveysManager sharedManager] uploadIfNeeded]; } }</code> </pre><br></div></div><br>  In the Info.plist of the project, you must specify Required background modes: ‚ÄúApp downloads content from the network‚Äù <br>  A more detailed description of running processes in the background can be found here: <br><br>  <a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html">developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH5-SW6</a> <br><br>  It is important to remember that tasks in backgrund have a time limit.  In order to effectively use the download in the background, it must be done in small portions and save the current state in order to restore sending the next time you run the background task.  To meet these limitations, we process the dispatch of inspections in turn.  First, photographs related to the inspection are sent separately, and then a special request with a list of photographic identifiers that link them to the inspection on the relevant task.  Only after this inspection is considered sent. <br><br><h3>  3.2.  Mobile traffic optimization </h3><br>  To save mobile traffic, the application implements a check of the type of Internet connection.  In the settings of the application, you can enable the option "Do not transfer data via cellular communication in automatic mode".  When this setting is enabled, information on inspections will be sent to the server only when the smartphone is connected to the Wi-Fi network.  In addition, you can enable cell phone sending for a separate contract. <br><br>  For cases when the inspection needs to be sent urgently, and Wi-Fi is not available, you can turn on the setting for one contract: if Wi-Fi is available, any inspection is sent, and if mobile communication, then only contracts with the cellphone setting enabled. <br><br><h2>  Conclusion </h2><br>  So thanks to us, car owners were able to arrange hull insurance as easily as possible. <br><br>  For the insurance company, we have made a convenient tool that solves a complex of tasks: <br><ol><li>  increase work efficiency </li><li>  standardization of the inspection process, </li><li>  fraud protection. </li></ol><br><br>  And we solved some interesting problems and we hope that it was also interesting for you to learn how: <br><ul><li>  to realize the choice of an element in a diagram based on a vector image, </li><li>  set up synchronization with the system calendar, </li><li>  and implement data loading in the background. </li></ul><br><br>  See you again! </div><p>Source: <a href="https://habr.com/ru/post/282658/">https://habr.com/ru/post/282658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282644/index.html">Web sites continue to use ‚Äúdark patterns‚Äù: interfaces designed to deceive</a></li>
<li><a href="../282648/index.html">Million and one day INotifyPropertyChanged</a></li>
<li><a href="../282652/index.html">Lazy threads: optional parallelism</a></li>
<li><a href="../282654/index.html">Record of the webinar "How easy it is to protect the company from encrypters and hidden threats"</a></li>
<li><a href="../282656/index.html">Piter Py # 3 - Personal Impressions</a></li>
<li><a href="../282660/index.html">Another Reflection Library and ORM for C ++</a></li>
<li><a href="../282662/index.html">How I left elma</a></li>
<li><a href="../282664/index.html">Installing Joomla 3.5 on Freebsd 10.3</a></li>
<li><a href="../282670/index.html">The digest of interesting materials from the world of MODX # 2</a></li>
<li><a href="../282672/index.html">The benefits of inspections</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>