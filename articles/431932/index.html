<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Byte-machine for the fort (and not only) in Indian</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yes, yes, it is "byte" and it is on the Indian (not Indian). I'll start in order. Recently here, on Habr√©, articles on bytecode began to appear. And o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Byte-machine for the fort (and not only) in Indian</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="image"><br><br>  Yes, yes, it is "byte" and it is on the Indian (not Indian).  I'll start in order.  Recently here, on Habr√©, articles on bytecode began to appear.  And once upon a time I was amused by what the fort system was writing.  Of course, in assembly language.  They were 16 bit.  On x86-64 never programmed.  Even with 32 it was not possible to play.  So the thought came - why not?  Why not stir up a 64-bit fort, and even with a byte-code?  Yes, and on Linux, where I also did not write anything system. <br><br>  I have a home server with Linux.  In general, I googled a bit and found out that the assembler on Linux is called GAS, and the as command.  Connecting via SSH to the server, typing as - is!  I have it already installed.  I still need a linker, I type ld - there is!  So, and try to write something interesting in assembly language.  Without civilization, only forest, like real Indians :) Without development environment, only command line and Midnight Commander.  The editor will be Nano, which hangs on my F4 in mc.  How is the Zero band singing?  A real Indian needs only one thing ... What else does a real Indian need?  Of course, debugger.  We type gdb - there is!  Well, let's press Shift + F4, and go! <br><a name="habracut"></a><br><h2>  Architecture </h2><br>  For a start, we will define architecture.  With digit capacity already defined, 64 bits.  In the classic implementations of the fort, the data and code segment is the same.  But, we will try to do it right.  We will only have code in the code segment, data in the data segment.  As a result, you get a kernel for the platform and a completely platform independent bytecode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's try to make the fastest possible stack byte-machine (but without JIT).  So, we will have a table containing 256 addresses - one for each byte-command.  There is nothing less - an extra check, this is already 1-2 processor commands.  And we need to quickly, without compromise. <br><br><h4>  Stacks </h4><br>  Usually, in implementations of a fort, the processor's return (* SP) stack is used as a data stack, and the return stack is implemented by other means.  Indeed, our machine will have a stack, and the main work goes on the data stack.  Therefore, we will do the same - RSP will be a data stack.  Well, let the stack of returns be RBP, which also, by default, works with the stack segment.  Thus, we will have three memory segments: a code segment, a data segment and a stack segment (it will contain both a data stack and a stack of returns). <br><br><h4>  Registers </h4><br>  I go into the description of the registers x86-64, and oops!  There are as many as 8 additional general-purpose registers (R8 - R16) compared to 32 or 16 bit modes. Not bad ... <br><br>  Already decided that they will need RSP and RBP.  You also need a pointer (counter) bytecode commands.  From operations on this register only reading of memory is necessary.  The main registers (RAX, RBX, RCX, RDX, RSI, RDI) are more flexible, universal, there are many special commands with them.  They will be useful to us for various tasks, and for the bytecode command counter we take one of the new registers for me, let it be R8. <br><br><h2>  Let's start? </h2><br>  I have no programming experience on Linux in assembler.  Therefore, to begin with, we will find the ready ‚ÄúHello, world‚Äù to understand how the program starts and displays the text.  Unexpectedly for me, I found variants with a strange syntax, where even the source and receiver are swapped.  As it turned out, this is AT &amp; T syntax, and it is mainly written for Linux on it.  But, another variant of syntax is also supported, it is called Intel-syntax.  Thinking, I decided to use it all the same.  Well, we write in the beginning .intel_syntax noprefix. <br><br>  Compile and execute ‚ÄúHello, world‚Äù to make sure everything works.  By reading the help and experiments, I began to use the following command to compile: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Here, the -o switch specifies the result file, the -g switch instructs to generate debugging information, and the -ahlsm switch specifies the listing format.  And the output is saved in the listing, you can see a lot of useful information in it.  I admit, at the beginning of work I did not make a listing, and did not even specify the -g option.  I began to use the -g switch after the first use of the debugger, and I started to make the listing after the macros appeared in the code :) <br><br>  After that we use the linker, but there is nowhere easier: <br><br> <code>$ ld forth.o -o forth</code> <br>  Well, run! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Works. <br><br><div class="spoiler">  <b class="spoiler_title">That was such a first forth.asm (actually it is 'Hellow, world!', Of course)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  By the way, a little later I learned that in x86-64, it is more correct to use syscall for the system call, and not int 0x80.  The 0x80 call is considered obsolete for this architecture, although it is supported. <br></div></div><br>  A start, and now ... <br><br><h2>  Go! </h2><br>  What would have been at least some specifics, we write the code of one byte-command.  Let it be the Fortov word "0", putting 0 on the top of the stack: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  At the time of execution of this command, R8 already points to the next byte command.  It is necessary to read it, increase R8, determine the executable address from the byte-command code, and transfer control to it. <br><br>  But ... what is the bitness of the address table of byte commands?  Here I had to dig a little in the new for me x86-64 command system.  Alas, I did not find the commands that allow you to go on the shift in memory.  This means either to calculate the address, or the address will be ready - 64 bits.  We have no time to calculate, it means - 64 bits.  In this case, the size of the table will be 256 * 8 = 4096 bytes.  Well, finally encode the _next call: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Not bad, it seems to me ... Only three processor commands, when moving from one byte-command to another. <br><br>  Actually, these commands were not so easy for me.  I had to dig in the command system 0x86-64 again and find the new MOVZX command for me.  In fact, this command converts a size of 8, 16, or 32 bits into a 64-bit register.  There are two variants of this command: unsigned, where the most significant digits are padded with zeros, and the sign bit is MOVSX.  In the sign version, the sign expands, that is, for positive numbers, zeros will go to the upper digits, and for negative numbers - ones.  This option is still useful to us for the lit byte command. <br><br>  By the way, is this option the fastest?  Maybe someone will offer even faster? <br><br>  Well, we now have a byte-machine that can run in a sequence of byte commands and execute them.  We must try it out in business, make it execute at least one command.  But what?  Zero to stack?  But here you don‚Äôt even know the result, if you don‚Äôt watch the stack under the debugger ... But if the program started, you can complete it :) <br><br>  Let's write the bye command, which completes the execution of the program and writes about it, especially since we have ‚ÄúHellow, world!‚Äù. <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  It remains to be easy - to create a table of addresses of byte commands, initialize registers, and start the byte machine.  So ... in the table 256 values, and two teams.  What is in the remaining cells? <br>  The rest will have an invalid opcode.  But, it is impossible to do a check on it, these are extra commands, we now have three, and with a check it will be five.  So, we make such a stub command - a bad command.  First we fill the entire table with it, and then we start to occupy the cells with useful commands.  Let the bad command have the code 0x00, the bye command will have 0x01, and the '0' will have the code 0x02, since it has already been written.  A bad team will still do the same thing as bye, only with a different completion code and text (I‚Äôll put in the spoiler, almost the same as bye): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Now draw a table of addresses.  For convenience, we will place eight in each row, the rows will be 16. The table is quite large in size: <br><br><div class="spoiler">  <b class="spoiler_title">Table of byte-command addresses</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Write the body of the byte program.  To do this, assign the command codes to assembler variables.  We will have the following agreements: <br><br><ul><li>  Addresses for the execution of byte commands will begin on bcmd_ </li><li>  The command codes themselves will be stored in variables starting with b_ </li></ul><br>  Thus, the body of the byte program will be as follows: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Declare the size of the data stack as stack_size.  Let it be 1024 so far. When initializing, let's do RBP = RSP - stack_size. <br><br><div class="spoiler">  <b class="spoiler_title">Actually, we get such a program code (forth.asm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Compile, run: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Works!  Our first bytecode program was launched from one byte :) <br>  Of course, it will be, if everything is done correctly.  And if not, the result is likely to be: <br><br> <code>$ ./forth <br>   <br></code> <br>  Of course, other options are possible, but I came across this most often.  And we need a debugger. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression about debugger</b> <div class="spoiler_text">  As already mentioned, I used GDB.  This is a pretty powerful debugger, but with a command line interface.  Running it is very simple: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Further, entering commands, we make debugging.  It took me an hour to find a few necessary commands and learn how to use them for debugging.  Here they are: <br>  b &lt;mark&gt; - put a breakpoint <br>  l &lt;tag&gt; - view source code <br>  r - start or restart of the program <br>  ir - see the state of the processor registers <br>  s - step <br><br>  By the way, remember that you need to compile the program with the -g key?  Otherwise, tags and source code will not be available.  In this case, it will be possible to debug only the disassembled code and use the addresses in memory.  We are, of course, Indians, but not to the same degree ... </div></div><br>  But somehow the program does very little.  We tell her only "Hello", and she immediately "Bye!".  Let's do the real ‚ÄúHello, world!‚Äù Bytecode.  To do this, put on the stack the address and length of the string, then execute the command that outputs the string, and after the bye command.  To do all this, you need new commands: type to display the string, and lit to put the address and length of the string.  In the beginning we will write type, let its code be 0x80.  We, again, need that piece of code with the sys_write call: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Here we take the address and length of the string from the data stack by the POP commands.  The call int 0x80 can change the register of R8, therefore we save it.  Previously, we did not do that, because the program was completed.  The contents of these registers did not care.  Now this is a normal byte command, after which the execution of the byte code continues, and we must behave well. <br><br>  Now we will write the command lit.  This will be our first command with parameters.  After the byte with the code of this command, there will be bytes containing the number that it will put on the stack.  Immediately the question arises - what kind of bit is needed here?  To be able to put any number, you need 64 bits.  But, each time the command will occupy 9 bytes, what would put one number?  So we lose compactness, one of the main properties of the byte-code, and the Fort code, too ... <br><br>  The solution is simple - we will make several commands for different digits.  These will be lit8, lit16, lit32 and lit64.  For small numbers we will use lit8 and lit16, for the big ones - lit32 and lit64.  Small numbers are most often used, and for them there will be the shortest command that occupies two bytes.  Not bad! .. The codes for these commands will be 0x08 - 0x0B. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Here we use the MOVSX command - this is a symbolic version of the MOVZX command already known to us.  R8 we have a byte-command counter.  We load on it the value of the desired size, move it to the next command, and convert the value converted to 64 bits to the stack. <br><br>  <b>Do not forget to put the address of the new teams in the table on the desired position.</b> <br><br>  That's all ready to write your first program ‚ÄúHello, world!‚Äù On our bytecode.  Let's work as the compiler!  :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  We use two different lit commands: lit64 to put the address of the line on the stack, and lit8, with which we push the length onto the stack.  Then we execute two more byte commands: type and bye. <br>  Compile, run: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Earn our bytecode!  That is the result should be, if everything is normal. <br><br><div class="spoiler">  <b class="spoiler_title">Full source</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  But the possibilities are still very primitive, it is impossible to make a condition, a cycle. <br><br>  How can not?  You can, everything is in our hands!  We will draw this line in a loop, 10 times.  This will require a conditional branch command, as well as some stack arithmetic: a command decreasing the value on the stack by 1 (on the fort ‚Äú1-‚Äù) and a duplicate vertex command (‚Äúdup‚Äù). <br><br>  Everything is simple with arithmetic, I will not even comment: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Now conditional transition.  To begin with, we will make the task easier - an unconditional transition.  It is clear that you just need to change the value of the register R8.  The first thing that comes to mind is that it will be a byte-command, followed by a parameter ‚Äî the 64-bit transition address.  Again nine bytes.  Do we need these nine bytes?  Transitions usually occur over short distances, often within a few hundred bytes.  So, we will not use the address, but the offset! <br><br>  Digit capacity?  In many cases, 8 bits (127 forward / backward) will suffice, but sometimes this will not be enough.  Therefore, we will act in the same way as with the lit command, we will make two options - 8 and 16 bits, the command codes will be 0x10 and 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Now the conditional transition is quite simple to implement.  If on stack 0, go to _next, and if not, go to the branch command! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre>     ,    : <pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br>    ‚Äî     .    Hello.   1  ,     (  ) .    ,         .    ,      . <br><br>      ,   . <br><br><div class="spoiler"> <b class="spoiler_title">  ,      )</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br> ,       ! <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br>    -       .       - .    ,   , ,  ..             ,    . <br><br>    .      .    ‚Äî      (call  exit). <br><br>  call,  ,    ,   branch ‚Äî      -. ,    branch,        ,        .     ‚Äî        .    call   branch,     ‚Äî 8, 16  32 . <br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br>  , ,    ,  3 .     R8   -,         . ,            ,        .      ‚Äî  .  ,      . <br><br>   ,      call  ,    branch.  branch          ,   -.    call         .  Why do you need it?     . <br><br>   . ,     R8        -: <br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br>      ,      . - exit    .    - ? , !      :) <br><br>        - _next: <br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br> ,       (,   call)     -,        .     .  . <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br>    265  271  jmp   2 ,    277       5 ,         . <br><br>  -, ,  bad, bye, type  ,  ,  call, branch, lit ‚Äî .  ,   127      . <br>       ,   . <br><br> ,       ,  !        ,       .       . <br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br>      call8,     call16,    .  2  -     - call,    .  call8    1,  call32, , 4. <br>   : <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br> ‚Ä¶  , -    :)   ,  GDB     .       bcmd_exit,   ,   sub_hello ,    ‚Ä¶ ‚Ä¶       .      -. , ,    . b_exit    0x1f,         0x17.   ,   b_exit  0x17    : <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br>    ,    .     :) <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4>  What is the result </h4><br>         64-  -.  , ,  -         ( -  JIT).     ,     ,  ,   .      -   .  , -  1-3 ,  ‚Äî    (   ,     ).      -,   . ,       (drop, swap, over, root  ..     20,       ). <br><br>   . -,        ,    ,         .          ,      . <br><br>   -    -  .          ,        ,        . <br><br>     ,    ,   ,   -   , -,  .   ¬´¬ª  .       ,     -.       -          .  , ,  ,  . <br><br>      . ,    16- ,  ,     .     _next   ,       -       (       _next).  ,       _next,     _next ( 14 ).  ,     .     ,  . ,           .         . <br><br>     ,     (, A = 5 + (B + C * 4) ). <br><br>  ,    !  :) </div><p>Source: <a href="https://habr.com/ru/post/431932/">https://habr.com/ru/post/431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431920/index.html">Frontend Mix - talk about Node.js, scalability and native web</a></li>
<li><a href="../431922/index.html">What is Method Handles in Java?</a></li>
<li><a href="../431924/index.html">Warehouse management system using CQRS and Event Sourcing. Development Process</a></li>
<li><a href="../431928/index.html">Fatigue of disposable items. Or ode A.S. Makarenko</a></li>
<li><a href="../431930/index.html">Mitap on DevOps in St. Petersburg</a></li>
<li><a href="../431934/index.html">How does artificial intelligence help work with legal documents? Lecture of Egor Budnikov from ABBYY</a></li>
<li><a href="../431936/index.html">Results of the contest "TechnoText"</a></li>
<li><a href="../431938/index.html">Integer Cube Root in Verilog</a></li>
<li><a href="../431940/index.html">People burn out if they don‚Äôt feel their importance. What to do with it?</a></li>
<li><a href="../431942/index.html">Hierarchical dependency injection in React and MobX State Tree as a domain model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>