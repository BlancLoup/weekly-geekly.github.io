<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reducing the operating voltage of the processor, or tuning Enhanced Intel SpeedStep</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern desktop and (especially) mobile processors use a number of energy-saving technologies: ODCM, CxE, EIST, etc. Today we will be interested in, pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reducing the operating voltage of the processor, or tuning Enhanced Intel SpeedStep</h1><div class="post__text post__text-html js-mediator-article">  Modern desktop and (especially) mobile processors use a number of energy-saving technologies: ODCM, CxE, EIST, etc. Today we will be interested in, perhaps, the highest level of them: flexible control of the frequency and voltage of the processor core during operation - Cool 'n 'Quiet, PowerNow!  from AMD and Enhanced SpeedStep (EIST) from Intel. <br><br>  Most often, a user of a computer or laptop can simply turn on (tick) support for a particular technology in the BIOS and / or the operating system ‚Äî no tweaking is usually provided, although, as practice shows, it can be very useful.  In this article I will talk about how you can control the operating voltage of the processor core from the operating system (using the example of Intel Pentium M and FreeBSD), and why this may be needed. <br><br>  Despite the large number of manuals, it‚Äôs rare to find a detailed description of the Enhanced SpeedStep technology from the point of view of the operating system (and not the end user), especially in Russian, so much of the article is devoted to implementation details and is to some extent theoretical in nature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I hope the article will be useful not only to FreeBSD users: we will also touch on GNU / Linux, Windows and Mac OS X a bit. However, in this case, a specific operating system is of secondary importance. <br><a name="habracut"></a><br><h2>  Foreword </h2><br>  Last year I upgraded the processor in my old laptop: I installed the Pentium M 780 instead of the standard 735, finished it to the maximum, so to speak.  The laptop began to warm up more under load (due to the heat release increased by 10 W);  I didn‚Äôt pay much attention to this (unless I cleaned and smeared the cooler just in case), but one day, during a long compilation, the computer ... just turned off (the temperature did reach a critical hundred degrees).  I brought the value of the system variable <code>hw.acpi.thermal.tz0.temperature</code> to tray, in order to monitor the temperature and, if anything, to interrupt the ‚Äúhard‚Äù task in time.  But after some time I lost my vigilance (the temperature always remained within the normal range), and everything repeated.  At that moment, I decided that I no longer want to constantly fear emergency shutdown during a long CPU load and keep my hand on Ctrl-C or force the processor. <br><br>  Usually, a change in the nominal voltage implies its increase in order to ensure stable operation of the processor during acceleration (i.e., at a higher frequency).  Roughly speaking, each voltage value corresponds to a certain range of frequencies at which it can work, and the task of the overclocker is to find the maximum frequency at which the processor is not yet ‚Äúbuggy‚Äù.  In our case, the task is in a certain sense symmetrical: for a known frequency (more precisely, as we will soon find out, a set of frequencies) to find the lowest voltage that ensures stable operation of the CPU.  But I do not want to lower the working frequency in order not to lose in performance - the laptop is already far from being top-notch.  In addition, lower voltage is <em>more profitable</em> . <br><br><h2>  Some theory </h2><br>  As you know, the processor's heat dissipation is proportional to its capacity, frequency, and voltage <em>square</em> (who cares why this is the case, they can try to derive the dependency on their own, considering the processor as a set of elementary <a href="https://courseware.ee.calpoly.edu/~dbraun/courses/ee307/F02/02_Shelley/Section2_BasilShelley.htm">CMOS inverters</a> (logical negatives), or refer to the links: <a href="http://software.intel.com/en-us/blogs/2009/06/29/why-p-scales-as-cv2f-is-so-obvious/">one</a> , <a href="http://software.intel.com/en-us/blogs/2009/08/25/why-p-scales-as-cv2f-is-so-obvious-pt-2-2/">two</a> , <a href="http://electronics.stackexchange.com/questions/33318/power-consumed-by-a-cpu">three</a> ). <br><br>  Modern mobile processors can consume up to 50-70 watts, which eventually dissipate into heat.  This is a lot (remember incandescent bulbs), especially for a laptop that in offline mode under load will ‚Äúeat‚Äù the battery like that pig oranges.  In conditions of limited space, the heat will most likely have to be removed actively, and this means additional energy consumption for the rotation of the fan of the cooler (possibly several). <br><br>  Naturally, this situation did not suit anyone, and processor manufacturers began to think about how to optimize power consumption (and, accordingly, heat transfer), and at the same time prevent the processor from overheating.  I recommend to those interested in reading a <a href="http://www.ixbt.com/cpu/intel-thermal-features-p4.shtml">number of</a> <a href="http://www.ixbt.com/cpu/intel-thermal-features-p4-2.shtml">remarkable</a> <a href="http://www.ixbt.com/cpu/intel-thermal-features-pm.shtml">articles by</a> Dmitriy Besedin, and in the meantime I will proceed directly to the point. <br><br><h2>  A bit of history </h2><br>  For the first time, SpeedStep technology (version 1.1) appeared in the second generation of third Pentiums (Coppermine mobile for notebooks produced according to the .18 micron process technology, 2000), which could switch between high and low depending on the load or power source of the computer frequencies due to a variable multiplier.  In economy mode, the processor consumed about half the energy. <br><br>  With the transition to the .13 micron technical process, the technology gets the version number 2.1 and becomes ‚Äúenhanced‚Äù (enhanced) - now the processor is able to lower not only the frequency, but also the voltage.  Version 2.2 is an adaptation for the NetBurst architecture, and by the third version (Centrino platform) the technology will be officially called Enhanced Intel SpeedStep (EIST). <br><br>  Version 3.1 (2003) is first used in the first and second generation Pentium M processors (Banias and Dothan cores).  The frequency varied (at first - only switched between two values) from 40% to 100% of the baseline, in 100 MHz increments (for Banias) or 133 MHz (for Dothan, our case).  At the same time, Intel introduces dynamic management of second-level cache capacity (L2), which allows for even better optimization of power consumption.  Version 3.2 (Enhanced EIST) - adaptation for multi-core processors with shared L2 cache.  (A small <a href="http://www.intel.com/support/processors/sb/cs-028855.htm">FAQ</a> from Intel on technology SpeedStep.) <br><br>  Now, instead of blindly following the numerous howto and tutorials, download the <a href="http://download.intel.com/design/network/papers/30117401.pdf">pdf</a> and try to understand the principle of the EST (I will continue to use this abbreviation, because it is more universal and shorter). <br><br><h2>  How does the est </h2><br>  So, EST allows you to control the performance and power consumption of the processor, and <em>dynamically</em> , during its operation.  Unlike earlier implementations, which required hardware support (in the chipset) to change the operating parameters of the processor, EST allows <em>software</em> , i.e.  by means of the BIOS or the operating system, change the multiplier (ratio of processor frequency to bus frequency) and core voltage (V <sub>cc</sub> ) depending on the load, type of computer power supply, CPU temperature conditions and / or operating system settings (policies). <br><br>  During operation, the processor is in one of several power states: T (throttle), S (sleep), C (idle), P (performance), switching between them according to certain rules (p. 386 of <a href="http://www.acpi.info/DOWNLOADS/ACPIspec50.pdf">the ACPI</a> 5.0 <a href="http://www.acpi.info/DOWNLOADS/ACPIspec50.pdf">specification</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/9e3/32f/d989e332fbe91870c944c2d644049eba.png" width="599" height="463" alt="Processor Power States"></div><br><br>  Each processor present in the system must be described in the DSDT table, most often in the <code>\_PR</code> , and usually provides a number of methods through which it interacts with the operating system (driver PM) and which describe the capabilities of the processor ( <code>_PDC</code> , <code>_PPC</code> ) , supported states ( <code>_CST</code> , <code>_TSS</code> , <code>_PSS</code> ) and their management ( <code>_PTC</code> , <code>_PCT</code> ).  The required values ‚Äã‚Äãfor each CPU (if it is included in the so-called CPU support package) are determined by the motherboard BIOS, which fills the corresponding tables and ACPI methods (p. 11 pdf) when the machine boots. <br><br>  EST controls the operation of the processor in the P-state (P-state), and they will interest us.  For example, the Pentium M supports six P-states (see Fig. 1.1 and Tab. 1.6 pdf), which differ in voltage and frequency: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/9ab/a7d/f479aba7d2bce282d6c2b5a1679959b4.png" width="600" height="354" alt="Power vs.  Core Voltage for Intel Pentium M 1.6GHz"></div><br><br>  In the general case, when the processor is not known in advance, the only more or less reliable (and recommended by Intel) method of working with it is ACPI.  You can interact with a specific processor directly, bypassing ACPI, through the Model-Specific Register (MSR) registers, including directly from the command line: starting from version 7.2, the <code>cpucontrol(8)</code> utility is used for this in FreeBSD. <br><br>  To find out if your processor supports EST, you can look at the 16th bit in the <code>IA_32_MISC_ENABLE</code> (0x1A0) register, it should be set: <br><br><pre> <code class="xml hljs"># kldload cpuctl # cpucontrol -m 0x1a0 /dev/cpuctl0 | (read _ msr hi lo ; echo $((lo &gt;&gt; 16 &amp; 1))) 1</code> </pre> <br>  A similar command for GNU / Linux (the msr-tools package is required): <br><br><pre> <code class="xml hljs"># modprobe msr # echo $((`rdmsr -c 0x1a0` &gt;&gt; 16 &amp; 1)) 1</code> </pre> <br>  The transition between states occurs when writing to the register <code>IA32_PERF_CTL</code> (0x199).  You can find out the current operation mode by reading the register <code>IA32_PERF_STATUS</code> (0x198), which is dynamically updated (tab. 1.4 pdf'ki).  In the future, the prefix <code>IA32_</code> I will omit for brevity. <br><br>  Let's try to start reading the current <code>PERF_STATUS</code> value: <br><br><pre> <code class="xml hljs"># cpucontrol -m 0x198 /dev/cpuctl0 MSR 0x198: 0x0612112b 0x06000c20</code> </pre> <br>  It follows from the documentation that the current state is encoded in the lower 16 bits (if you execute the command several times, their value may change - this means that the EST is working).  If you look closely at the other bits, they are also clearly not rubbish.  Googling, you can <a href="http://www.projectosx.com/forum/index.php%3Fshowtopic%3D610">find out</a> what they mean. <br><br><h2>  PERF_STATUS register structure </h2><br>  Data read from <code>PERF_STATUS</code> is represented by the following structure (we <code>PERF_STATUS</code> that the data is stored as little-endian): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msr_perf_status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> curr_psv : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Current PSV */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> status : <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Status flags */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> min_mult : <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Minimum multiplier */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> max_psv : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Maximum PSV */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> init_psv : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Power-on PSV */</span></span> };</code> </pre> <br>  Three 16-bit fields are the so-called Performance State Values ‚Äã‚Äã(PSV), we will consider their structure below: the current PSV value, the maximum (depending on the processor) and the value at the start of the system (when turned on).  The current value (curr_psv) obviously changes when the operation mode changes, the maximum (max_psv) usually remains constant, the starting value (init_psv) does not change: as a rule, it is equal to the maximum value for desktops and servers, but the minimum for mobile CPUs.  The minimum factor (min_mult) for Intel processors is almost always six.  The status field contains the value of some flags, for example, upon the occurrence of an EST or THERM event (that is, at the moment the P-state changes or the processor overheats, respectively). <br><br>  Now that we know the assignment of all 64 bits of the <code>PERF_STATUS</code> register, we can decipher the word read above: <b>0x <font color="deepskyblue">0612</font> <font color="#FF6614">112b</font> 0x <font color="#9966CC">06</font> <font color="#0084D1">00</font> <font color="lime">0c20</font></b> ‚áí PSV at start 0x0612, maximum value 0x112b, minimum factor 6 (as expected), the flags are reset, the current value PSV = 0x0c20.  What exactly do these 16 bits mean? <br><br><h2>  Performance State Value (PSV) structure </h2><br>  It is very important to know and understand what PSV is, because it is in this form that the modes of operation of the processor are set. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">psv</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> vid : <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Voltage Identifier */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _reserved1 : <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> freq : <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Frequency Identifier */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _reserved2 : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> nibr : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Non-integer bus ratio */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> slfm : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Dynamic FSB frequency (Super-LFM) */</span></span> };</code> </pre> <br>  Dynamic FSB frequency switching indicates to skip every second FSB clock, i.e.  double the operating frequency;  This feature was first implemented in Core 2 Duo processors (Merom core) and does not concern us, as does the Non-integer bus ratio - a special mode supported by some processors, which allows, as the name implies, to more finely control their frequency. <br><br>  EST technology itself has two fields: frequency identifiers (Frequency Identifier, Fid), which is numerically equal to the multiplier, and voltages (Voltage Identifier, Vid), which corresponds to the voltage level (it is usually the least documented). <br><br><h2>  Voltage Identifier </h2><br>  Intel is very <a href="http://software.intel.com/en-us/forums/topic/304014">reluctant to</a> disclose information (usually an NDA is required to sign) about how the voltage identifier is encoded for each processor.  But for most popular CPUs, fortunately, this formula is well known;  in particular, for our Pentium M (and many others): V <sub>cc</sub> = Vid <sub>0</sub> + (Vid √ó V <sub>step</sub> ), where V <sub>cc</sub> is the current (real) voltage, Vid <sub>0</sub> is the base voltage (when Vid == 0), V <sub>step</sub> - step.  Table for some popular processors (all values ‚Äã‚Äãare in millivolts): <br><table><tbody><tr><th>  CPU </th><th>  Vid <sub>0</sub> </th><th>  V <sub>step</sub> </th><th>  V <sub>boot</sub> </th><th>  V <sub>min</sub> </th><th>  V <sub>max</sub> </th></tr><tr><td>  Pentium M </td><td>  700.0 </td><td>  16.0 </td><td>  xxxx, x </td><td>  xxx, x </td><td>  xxxx, x </td></tr><tr><td>  E6000, E4000 </td><td>  825.0 </td><td>  12.5 </td><td>  1100.0 </td><td>  850.0 </td><td>  1500.0 </td></tr><tr><td>  E8000, E7000 </td><td>  825.0 </td><td>  12.5 </td><td>  1100.0 </td><td>  850.0 </td><td>  1362.5 </td></tr><tr><td>  X9000 </td><td>  712.5 </td><td>  12.5 </td><td>  1200.0 </td><td>  800.0 </td><td>  1325.0 </td></tr><tr><td>  T9000 </td><td>  712.5 </td><td>  12.5 </td><td>  1200.0 </td><td>  750.0 </td><td>  1300.0 </td></tr><tr><td>  P9000, P8000 </td><td>  712.5 </td><td>  12.5 </td><td>  1200.0 </td><td>  750.0 </td><td>  1300.0 </td></tr><tr><td>  Q9000D, Q8000D </td><td>  825.0 </td><td>  12.5 </td><td>  1100.0 </td><td>  850.0 </td><td>  1362.5 </td></tr><tr><td>  Q9000M </td><td>  712.5 </td><td>  12.5 </td><td>  1200.0 </td><td>  850.0 </td><td>  1300.0 </td></tr></tbody></table>  The multiplier (i.e., Fid) is written in PSV shifted 8 bits to the left, the lower six bits are occupied by Vid.  Since  in our case, the remaining bits can be neglected, then PSV, processor frequency, system bus and physical voltage are related by a simple formula (for Pentium M): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/671/c80/177/671c80177ce928650d607e67dc3164de.png" width="276" height="35" alt="PSV = (frequency / bus clock) * 256 + (Vcc - 700) / 16"></div><br>  Now consider the control register ( <code>PERF_CTL</code> ).  Writing to it should be done as follows: first, the current value is read (the 64-bit word entirely), the necessary bits are changed in it, and written back to the register (the so-called read-modify-write). <br><br><h2>  PERF_CTL register structure </h2><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msr_perf_ctl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> psv : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Requested PSV */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _reserved1 : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> ida_diseng : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* IDA disengage */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _reserved2 : <span class="hljs-number"><span class="hljs-number">31</span></span>; };</code> </pre> <br>  IDA (Intel Dynamic Acceleration) disengage bits allows you to temporarily disable adaptive (frequency) frequency control on Intel Core 2 Duo T7700 and later processors - again, we are not interested.  The lower 16 bits (PSV) is the mode in which we ‚Äúask‚Äù the processor to switch. <br><br><h2>  _PSS table </h2><br>  The <code>_PSS</code> table is an array of states ( <i>Package</i> in ACPI terminology) or a method that returns such an array;  each state (P-state) in turn is defined by the following structure (p. 409 of the ACPI specification): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pstate</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> CoreFrequency; <span class="hljs-comment"><span class="hljs-comment">/* Core CPU operating frequency, MHz */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Power; <span class="hljs-comment"><span class="hljs-comment">/* Maximum power dissipation, mW */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Latency; <span class="hljs-comment"><span class="hljs-comment">/* Worst-case latency of CPU unavailability during transition, ¬µs */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> BusMasterLatency; <span class="hljs-comment"><span class="hljs-comment">/* Worst-case latency while Bus Masters are unable to access memory, ¬µs */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Control; <span class="hljs-comment"><span class="hljs-comment">/* Value to be written to the PERF_CTL to switch to this state */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Status; <span class="hljs-comment"><span class="hljs-comment">/* Value (should be equal to the one read from PERF_STATUS) */</span></span> };</code> </pre> <br>  Thus, each P-state is characterized by some core operating frequency, maximum power dissipation, transit delays (actually, the transition time between states during which the CPU and memory are unavailable), finally, the most interesting: PSV, which corresponds to this state and which must be written to <code>PERF_CTL</code> in order to go to this state (Control).  To verify that the processor has successfully transitioned to a new state, you need to read the register <code>PERF_STATUS</code> and compare it with the value recorded in the Status field. <br><br>  The EST driver of the operating system may ‚Äúknow‚Äù about some processors, i.e.  will manage them without ACPI support.  But this is rare, especially nowadays (although for Linux undervolting, somewhere before version 2.6.20, it was necessary to patch the tables in the driver, and back in 2011 this method was <a href="http://forums.gentoo.org/viewtopic-p-7076470.html">quite common</a> ). <br><br>  It is worth noting that the EST driver can work even in the absence of the <code>_PSS</code> table and an unknown processor, since  the maximum and minimum values ‚Äã‚Äãcan be <code>PERF_STATUS</code> from <code>PERF_STATUS</code> (in this case, obviously, the number of P-states degenerates into two). <br><br><h2>  Enough theory.  What to do with it all? </h2><br>  Now, when we know 1) the assignment of all bits in the right MSR words, 2) how exactly PSV is encoded for our processor, and 3) where in DSDT to search for the necessary settings, it's time to create a table of frequencies and voltages <em>by default</em> .  Let's take the DSDT and look for the <code>_PSS</code> table <code>_PSS</code> .  For the Pentium M 780, it should look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Default _PSS values</b> <div class="spoiler_text"><pre> <code class="vala hljs"> Name (_PSS, Package (<span class="hljs-number"><span class="hljs-number">0x06</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   6  (P-states) Package (0x06) { 0x000008DB, // 2267 MHz (cf. Fid √ó FSB clock) 0x00006978, // 27000 mW 0x0000000A, // 10 ¬µs ( ) 0x0000000A, // 10 ¬µs 0x0000112B, // 0x11 = 17 (, Fid), 0x2b = 43 (Vid) 0x0000112B }, Package (0x06) { 0x0000074B, // 1867 MHz (82%  ) 0x000059D8, // 23000 mW 0x0000000A, 0x0000000A, 0x00000E25, // Fid = 14, Vid = 37 0x00000E25 }, Package (0x06) { 0x00000640, // 1600 MHz (71%  ) 0x00005208, // 21000 mW 0x0000000A, 0x0000000A, 0x00000C20, // Fid = 12, Vid = 32 0x00000C20 }, Package (0x06) { 0x00000535, // 1333 MHz (59%  ) 0x00004650, // 18000 mW 0x0000000A, 0x0000000A, 0x00000A1C, // Fid = 10, Vid = 28 0x00000A1C }, Package (0x06) { 0x0000042B, // 1067 MHz (47%  ) 0x00003E80, // 16000 mW 0x0000000A, 0x0000000A, 0x00000817, // Fid = 8, Vid = 23 0x00000817 }, Package (0x06) { 0x00000320, // 800 MHz (35%  ) 0x000032C8, // 13000 mW 0x0000000A, 0x0000000A, 0x00000612, // Fid = 6, Vid = 18 0x00000612 } })</span></span></code> </pre> </div></div><br>  So, we know the default Vid for each P-level: 43, 37, 32, 28, 23, 18, which corresponds to voltages from 1388 mV to 988 mV.  The essence of undervolting is that these voltages are probably somewhat higher than is really necessary for the stable operation of the processor.  Let's try to determine the "boundaries of what is permitted." <br><br>  I wrote a simple <a href="">shell script</a> for this, which gradually lowers the Vid and performs an uncomplicated loop (the <code>powerd(8)</code> daemon <code>powerd(8)</code> , of course, be nailed before).  Thus, I determined the voltages that allow the processor to at least not hang, then I drove the Super Pi test and reassembly of the core several times;  Later, I raised the Vid value for the two maximum frequencies by one more point, otherwise gcc occasionally crashed due to an error in the illegal instruction.  As a result of all the experiments for several days, such a set of ‚Äústable‚Äù Vid was obtained: 30, 18, 12, 7, 2, 0. <br><br><h2>  Results analysis </h2><br>  Now that we have empirically determined the minimum safe voltages, it is interesting to compare them with the original ones: <br><table><tbody><tr><th>  Frequency, MHz (multiplier) </th><th>  View <sub>old</sub> </th><th>  Vid <sub>new</sub> </th><th>  Change V <sub>cc</sub> </th></tr><tr><td>  2267 (17) </td><td>  43 </td><td>  thirty </td><td>  -15% </td></tr><tr><td>  1867 (14) </td><td>  37 </td><td>  18 </td><td>  -24% </td></tr><tr><td>  1600 (12) </td><td>  32 </td><td>  12 </td><td>  -26% </td></tr><tr><td>  1333 (10) </td><td>  28 </td><td>  7 </td><td>  -29% </td></tr><tr><td>  1067 (8) </td><td>  23 </td><td>  2 </td><td>  -31% </td></tr><tr><td>  800 (6) </td><td>  18 </td><td>  0 </td><td>  -29% </td></tr></tbody></table>  Even lowering the maximum voltage by 15% yielded quite tangible results: a prolonged load not only does not lead to more processor overheating and emergency shutdown, the temperature in general now almost never exceeds 80 ¬∞ C.  The predicted battery life in the ‚Äúoffice‚Äù mode, judging by the <code>acpiconf -i 0</code> , increased from 1 h. 40 to 2 h. 25 m. (Not so much, but the lithium-ion cells get tired with time, I haven't changed the battery since I bought a laptop about seven years ago.) <br><br>  Now we need to make sure that the settings are applied automatically.  You can, for example, modify the <code>cpufreq(4)</code> driver so that the PSV values ‚Äã‚Äãare taken from your own table, and not via ACPI.  But this is inconvenient even if it is necessary to remember to patch the driver when updating the system, and in general it looks more like a dirty hack than a solution.  You can probably somehow patch <code>powerd(8)</code> , which is bad for about the same reasons.  You can simply run the script, lowering the voltage by writing directly to the MSR (which, in fact, I did to determine the "stable" voltages), but then you have to remember about and independently handle the transitions between states (not only P-states, in general, any, for example when the laptop exits from sleep).  Not a deal either. <br><br>  If we get PSV values ‚Äã‚Äãvia ACPI, then it is most logical to change the <code>_PSS</code> table in DSDT.  Fortunately, the BIOS for this will not have to pick: FreeBSD is able to load DSDT from a file (we <a href="http://habrahabr.ru/post/128449/">didn‚Äôt</a> <a href="http://habrahabr.ru/post/165401/">write</a> about the modification of the ACPI tables on Habr√© more <a href="http://habrahabr.ru/post/128449/">than</a> <a href="http://habrahabr.ru/post/150887/">once</a> , so we‚Äôll not discuss this in detail now).  Replace the required fields in DSDT: <br><br><div class="spoiler">  <b class="spoiler_title">Undervolting patch for _PSS</b> <div class="spoiler_text"><pre> <code class="diff hljs">@@ -7385,8 +7385,8 @@ 0x00006978, 0x0000000A, 0x0000000A, - 0x0000112B, - 0x0000112B + 0x0000111D, + 0x0000111D }, Package (0x06) @@ -7395,8 +7395,8 @@ 0x000059D8, 0x0000000A, 0x0000000A, - 0x00000E25, - 0x00000E25 + 0x00000E12, + 0x00000E12 }, Package (0x06) @@ -7405,8 +7405,8 @@ 0x00005208, 0x0000000A, 0x0000000A, - 0x00000C20, - 0x00000C20 + 0x00000C0C, + 0x00000C0C }, Package (0x06) @@ -7415,8 +7415,8 @@ 0x00004650, 0x0000000A, 0x0000000A, - 0x00000A1C, - 0x00000A1C + 0x00000A07, + 0x00000A07 }, Package (0x06) @@ -7425,8 +7425,8 @@ 0x00003E80, 0x0000000A, 0x0000000A, - 0x00000817, - 0x00000817 + 0x00000802, + 0x00000802 }, Package (0x06) @@ -7435,8 +7435,8 @@ 0x000032C8, 0x0000000A, 0x0000000A, - 0x00000612, - 0x00000612 + 0x00000600, + 0x00000600 } })</code> </pre> </div></div><br>  Compile the new AML file (ACPI bytecode) and modify / boot / loader.conf so that FreeBSD loads our modified DSDT instead of the default one: <br><br><pre> <code class="xml hljs">acpi_dsdt_load="YES" acpi_dsdt_name="/root/undervolt.aml"</code> </pre> <br>  Here, in general, and all.  The only thing, do not forget to comment out these two lines in / <code>/boot/loader.conf</code> , if you change the processor. <br><br>  Even if you are not going to lower the nominal voltages, the ability to tune the management of processor states (not just P-states) can be useful.  After all, it is often the case that the ‚Äúcurve‚Äù BIOS fills the tables incorrectly, not completely, or does not fill them at all (for example, because the Tseleron does not support EST, and the manufacturer does not officially provide for its replacement).  In this case, you have to do all the work <a href="http://pat.erley.org/Other/P4EISTSSDT">yourself</a> .  Note that adding only the <code>_PSS</code> table <code>_PSS</code> not be enough;  so, C-states are defined by the <code>_CST</code> table, and in addition, you may need to describe the control procedures themselves (Performance Control, <code>_PCT</code> ).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fortunately, this is easy and fairly detailed, with examples described in the eighth chapter of the ACPI specification. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GNU / Linux Undervolting </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In truth, at first I thought it would be enough for me to read the </font></font><a href="http://www.gentoo-wiki.info/Pentium_M/Undervolting"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gentoo Undervolting Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and just adapt it for FreeBSD. </font><font style="vertical-align: inherit;">This was not so easy, because the document turned out to be extremely confused (which is actually strange for the Gentoo Wiki). </font><font style="vertical-align: inherit;">Unfortunately, </font><font style="vertical-align: inherit;">I did not find anything similar </font><font style="vertical-align: inherit;">on their new </font></font><a href="http://wiki.gentoo.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">website,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I had to be content with the old copy; </font><font style="vertical-align: inherit;">and although I understand that this guide has lost much of its relevance, I still criticize it a bit.</font></font> :-) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For some reason, immediately, </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without a declaration of war, I</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> am offered a patch kernel (in FreeBSD, for a moment, we don‚Äôt have any system </font><em><font style="vertical-align: inherit;">code</font></em><font style="vertical-align: inherit;"> at all</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it was not necessary to modify). To hammer inside the driver or to write in some init scripts the values ‚Äã‚Äãof some ‚Äúsafe‚Äù voltages, unintelligibly obtained by whom and how, from a special table (in which the Pentium M 780 is mockingly represented as a string consisting of only question marks). Follow the tips, among which are written by people who clearly do not understand what they are talking about. And most importantly, it is completely unclear why and how exactly these magical replacements of some numbers for others work; there is no suggested way to ‚Äútouch‚Äù EST, before patching and rebuilding the kernel, the MSR registers and the work with them from the command line are never mentioned. Modification of ACPI tables is not considered as an alternative and more preferred option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThinkWiki tutorial a </font></font><a href="http://www.thinkwiki.org/wiki/Pentium_M_undervolting_and_underclocking"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">little better</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and newer), but not by much. </font><font style="vertical-align: inherit;">The </font><font style="vertical-align: inherit;">ArchWiki </font></font><a href="https://wiki.archlinux.org/index.php/PHC"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">page is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> even more concise </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This line delivers especially:</font></font><br><br><pre> <code class="xml hljs"># echo 34 26 18 12 8 5 &gt; /sys/devices/system/cpu/cpu0/cpufreq/phc_vids</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so Lost's ‚Äú4, 8, 15, 16, 23, 42‚Äù are asked (albeit in the reverse order, which spoils the joke somewhat). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the most sensible description of the entire process for Linux by Pat Erley, the </font></font><a href="http://pat.erley.org/Other/P4EISTSSDT"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to which I gave above.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Undervolting in Windows and Mac OS X </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no particular point in talking about Windows: there is both software and discussions on the forums, so I‚Äôll just leave a </font></font><a href="http://forum.notebookreview.com/hardware-components-aftermarket-upgrades/235824-undervolting-guide.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couple of </font></font></a> <a href="http://forum.notebookreview.com/hardware-components-aftermarket-upgrades/531329-throttlestop-guide.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">links</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> here </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Makos rather closely interacts with (and relies on correct operation) ACPI, and modification of the tables is one of the main methods for setting it up for a specific hardware. So the first thing that comes to mind - just </font></font><a href="http://www.insanelymac.com/forum/topic/278170-dsdt-%25E2%2580%2594-what-is-it-and-how-do-i-get-it/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdampit </font></font></a> <a href="https://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/wiki/How-to-patch-your-DSDT"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font></a> <a href="http://www.macbreaker.com/2012/03/make-dsdt-with-dsdt-editor.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch her the DSDT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Alternative method: </font></font><code>google://IntelEnhancedSpeedStep.kext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for example, </font></font><a href="http://www.insanelymac.com/forum/topic/119370-experimental-intel-speedstep-kext/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://code.google.com/p/xnu-speedstep/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://forums.macrumors.com/showthread.php%3Ft%3D751657"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">three</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another "wonderful" </font></font><a href="http://www.coolbook.se/CoolBook.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utility</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (fortunately, already outdated) offers to buy for $ 10 the opportunity to change the voltage and frequency.</font></font> :-) <br><br><h2>  What else to read </h2><br>  FreeBSD: <a href="http://forums.freebsd.org/showthread.php%3Ft%3D172"></a>  ,    <a href="http://markmail.org/message/3kgpkxdbznagzx5w"></a>  ;       <a href="https://wiki.freebsd.org/TuningPowerConsumption"></a> .  Linux     <a href="https://wiki.archlinux.org/index.php/Power_saving"></a>  ArchWiki. <br><br>  ,     ,          ,  <a href="http://people.cs.pitt.edu/~kirk/cs3150spring2010/"></a> ‚Äî    ( , )       (, Comic Sans). </div><p>Source: <a href="https://habr.com/ru/post/228233/">https://habr.com/ru/post/228233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228223/index.html">Astrobench: JavaScript code performance testing</a></li>
<li><a href="../228225/index.html">Torrent render for 3ds max - almost everything will have to be redone</a></li>
<li><a href="../228227/index.html">Ignatius Kolesnichenko: "You will not ask for money from a bacterium"</a></li>
<li><a href="../228229/index.html">An algorithm is developed that effectively removes all the "boring" fragments from the video.</a></li>
<li><a href="../228231/index.html">HD-Voice for cellular communication - Khariton, Dmitry, Vladimir, Oleg, Irina, Glory!</a></li>
<li><a href="../228235/index.html">Growth Hacks for SaaS service: How to increase revenue and reduce customer churn?</a></li>
<li><a href="../228237/index.html">Home sales of Epson Moverio BT-200 video glasses</a></li>
<li><a href="../228239/index.html">Expansion of anti-piracy law. Block content will be without a court order</a></li>
<li><a href="../228241/index.html">Protecting .NET Applications with the Sentinel LDK Envelope</a></li>
<li><a href="../228243/index.html">It's time to learn to neglect gadgets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>