<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of 3D games for Windows 8 using C ++ and Microsoft DirectX</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Game development is a constantly relevant topic: everyone likes to play games, they are willing to buy them, so they are profitable to sell. But when ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of 3D games for Windows 8 using C ++ and Microsoft DirectX</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/65d/e37/0b0/65de370b01cf44e1a61d2f8e6aa905c7.jpg"><br><br>  Game development is a constantly relevant topic: everyone likes to play games, they are willing to buy them, so they are profitable to sell.  But when developing good games you should pay a lot of attention to performance.  No one will like a game that ‚Äúslows down‚Äù or jerks even on not the most powerful devices. <br>  In this article, I will show how to develop a simple 3D football game using Microsoft DirectX and C ++, although mainly I am developing in C #.  In the past I have worked quite a bit with C ++, but now this language is not so simple for me.  In addition, DirectX for me is a novelty, so this article can be considered a newbie‚Äôs point of view on game development.  I ask experienced developers to forgive me for any errors. <br><a name="habracut"></a><br>  We will use the Microsoft Visual Studio 3D Starter Kit - a natural initial resource for everyone who wants to develop games for Windows 8.1. <br><br><h4>  Microsoft Visual Studio 3D Starter Kit </h4>  After downloading the <a href="http://code.msdn.microsoft.com/windowsapps/Visual-Studio-3D-Starter-54ec8d19">Starter Kit,</a> you can unzip it into a folder and open the StarterKit.sln file.  This solution has a ready-made C ++ project for Windows 8.1.  When it starts, an image similar to fig.  one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/105/2f8/af6/1052f8af6da1401fb8bbed5e9ad66631.png"><br>  <i>Figure 1. The initial state of the Microsoft Visual Studio 3D Starter Kit</i> <br><br>  This program as part of the Starter Kit demonstrates several useful items. <br><ul><li>  Five objects are animated: four figures revolve around the kettle, and the kettle, in turn, ‚Äúdances‚Äù. </li><li>  Each item is made from a separate material;  some have a solid color, and the surface of the cube is a raster pattern. </li><li>  The light source is in the upper left corner of the scene. </li><li>  In the lower right corner of the screen is the frame rate counter (the number of frames per second). </li><li>  Above is the points indicator. </li><li>  If you click on an item, it is highlighted and the number of points increases. </li><li>  If you click the game screen with the right mouse button or drag the screen from the bottom edge to the middle, two buttons will appear to sequentially switch the color of the kettle. </li></ul><br><br>  The main game loop is in the <i>StarterKitMain.cpp</i> file, where the page and frame rate counter are drawn.  <i>Game.cpp</i> contains a game loop and click test.  In this file, animation is calculated in the <i>Update</i> method, and in the <i>Render</i> method all objects are drawn.  The frame rate counter is drawn in <i>SampleFpsTextRenderer.cpp</i> .  Objects of the game are in the <i>Assets</i> folder.  <i>Teapot.fbx</i> is a teapot, and the <i>GameLevel.fbx</i> file contains four shapes that rotate around a dancing teapot. <br>  Now, having familiarized with the sample application in the Starter Kit package, you can proceed to creating your own game. <br><br><h4>  Adding resources to the game </h4>  We are developing a game of football, so our very first resource should be a soccer ball, which we will add to <i>Gamelevel.fbx</i> .  First you need to delete four figures from this file, selecting each one and pressing the Delete button.  In the solution browser, delete the <i>CubeUVImage.png</i> file as <i>well</i> , since we don‚Äôt need it: this is the texture for the cube we just deleted. <br>  Now add a sphere to the model.  Open the tools (if you can't see them, click View&gt; Toolbox) and double-click the sphere to add it to the model.  We also need a stretched texture, such as in fig.  2 <br><br><img src="https://habrastorage.org/files/a2f/63e/c79/a2f63ec79da644b28aabc86fdf19c524.jpg"><br>  <i>Figure 2. The texture of a soccer ball adapted to the sphere</i> <br><br>  If you do not want to create your own models in Visual Studio, you can find ready-made models on the Internet.  Visual Studio supports any model in the format of FBX, DAE and OBJ: just add them to the solution resources.  For example, you can use an .obj file similar to the one shown in Figure.  3 (free model from the site <a href="http://www.turbosquid.com/">TurboSquid</a> ). <br><br><img src="https://habrastorage.org/files/352/eae/4a6/352eae4a64f443b0a88648695b2889fa.jpg"><br>  <i>Figure 3. Three-dimensional OBJ-ball model</i> <br><br><h4>  Model animation </h4>  The model is ready, now it's time to animate it.  But first you need to remove the kettle, because we do not need it.  In the Assets folder, delete the file <i>teapot.fbx</i> .  Now remove its download and animation.  In the <i>Game.cpp</i> file, models are loaded asynchronously in <i>CreateDeviceDependentResources</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Load the scene objects. auto loadMeshTask = Mesh::LoadFromFileAsync( m_graphics, L"gamelevel.cmo", L"", L"", m_meshModels) .then([this]() { // Load the teapot from a separate file and add it to the vector of meshes. return Mesh::LoadFromFileAsync(</span></span></code> </pre> </div></div><br>  You need to change the model and delete the continuation of the task so that only the ball is loaded: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::CreateDeviceDependentResources() { m_graphics.Initialize(m_deviceResources-&gt;GetD3DDevice(), m_deviceResources-&gt;GetD3DDeviceContext(), m_deviceResources-&gt;GetDeviceFeatureLevel()); <span class="hljs-comment"><span class="hljs-comment">// Set DirectX to not cull any triangles so the entire mesh will always be shown. CD3D11_RASTERIZER_DESC d3dRas(D3D11_DEFAULT); d3dRas.CullMode = D3D11_CULL_NONE; d3dRas.MultisampleEnable = true; d3dRas.AntialiasedLineEnable = true; ComPtr&lt;ID3D11RasterizerState&gt; p3d3RasState; m_deviceResources-&gt;GetD3DDevice()-&gt;CreateRasterizerState(&amp;d3dRas, &amp;p3d3RasState); m_deviceResources-&gt;GetD3DDeviceContext()-&gt;RSSetState(p3d3RasState.Get()); // Load the scene objects. auto loadMeshTask = Mesh::LoadFromFileAsync( m_graphics, L"gamelevel.cmo", L"", L"", m_meshModels); (loadMeshTask).then([this]() { // Scene is ready to be rendered. m_loadingComplete = true; }); }</span></span></code> </pre></div></div><br>  The <i>ReleaseDeviceDependentResources</i> method only needs to clear the grids: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::ReleaseDeviceDependentResources() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Mesh* m : m_meshModels) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m; } m_meshModels.clear(); m_loadingComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre></div></div><br>  Now you need to change the <i>Update</i> method so that only the ball rotates: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; timer) { <span class="hljs-comment"><span class="hljs-comment">// Rotate scene. m_rotation = static_cast&lt;float&gt;(timer.GetTotalSeconds()) * 0.5f; }</span></span></code> </pre></div></div><br>  A multiplier (0.5f) is used to control the rotation speed.  To make the ball spin faster, you just need to increase this multiplier.  For each second, the ball will turn at an angle of 0.5 / (2 * Pi) radians.  The <i>Render</i> method draws the ball with the desired rotation angle: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Render() { <span class="hljs-comment"><span class="hljs-comment">// Loading is asynchronous. Only draw geometry after it's loaded. if (!m_loadingComplete) { return; } auto context = m_deviceResources-&gt;GetD3DDeviceContext(); // Set render targets to the screen. auto rtv = m_deviceResources-&gt;GetBackBufferRenderTargetView(); auto dsv = m_deviceResources-&gt;GetDepthStencilView(); ID3DllRenderTargetView *const targets[1] = { rtv }; context-&gt;OMSetRenderTargets(1, targets, dsv); // Draw our scene models. XMMATRIX rotation = XMMatrixRotationY(m_rotation); for (UINT i = 0; i &lt; m_meshModels.size() ; i++) { XMMATRIX modelTransform = rotation; String^ meshName = ref new String (m_meshModels [i]-&gt;Name ()) ; m_graphics.UpdateMiscConstants(m_miscConstants); m_meshModels[i]-&gt;Render(m_graphics, modelTransform); } } ToggleHitEffect    :       . void Game :: ToggleHitEf feet (String^ object) { }</span></span></code> </pre></div></div><br>  We do not need to change the illumination of the ball, but we need to get data about its touch.  To do this, use the modified <i>onHitobject</i> method: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">String^ Game: :OnHitobject (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x , <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) { String^ result = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; XMFLOAT3 point; XMFLOAT3 dir; m_graphics.GetCamera().GetWorldLine(x, y, &amp;point, &amp;dir); XMFLOAT4X4 world; XMMATRIX worldMat = XMMatrixRotationY(m_rotation); XMStoreFloat4x4(&amp;world, worldMat); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> closestT = FLT_MAX; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Mesh* m : m_meshModels) { XMFLOAT4X4 meshTransform = world; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> name = ref <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(m-&gt;Name()); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hit = HitTestingHelpers::LineHitTest(*m, &amp;point, &amp;dir, SmeshTransform, &amp;t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit &amp;&amp; t &lt; closestT) { result = name; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre></div></div><br>  If you start the project now, you will see that the ball rotates around its Y axis. <br><br><h4>  Ball movement </h4>  To move the ball, you need to move it, for example, up and down.  First you need to declare a variable for the current position of the ball in <i>Game.h</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// snip private: // snip float m_translation;</span></span></code> </pre></div></div><br>  Then in the Update method you need to calculate the current position: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-comment"><span class="hljs-comment">// Rotate scene. m_rotation = static_cast&lt;float&gt;(timer.GetTotalSeconds()) * 0.5f; const float maxHeight = 7. Of; auto totalTime = (float) fmod(timer.GetTotalSeconds(), 2.0f); m_translation = totalTime &gt; 1.0f ? maxHeight - (maxHeight * (totalTime - 1.0f)) : maxHeight *totalTime; }</span></span></code> </pre></div></div><br>  Now the ball will rise and fall every 2 seconds.  During the first second the ball will rise, during the next second it will lower.  The Render method calculates the resulting matrix and draws the ball in a new position: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Render() { <span class="hljs-comment"><span class="hljs-comment">// snip // Draw our scene models. XMMATRIX rotation = XMMatrixRotationY(m_rotation); rotation *= XMMatrixTranslation(0, m_translation, 0);</span></span></code> </pre></div></div><br>  If you run the project now, you will see that the ball moves up and down at a constant speed.  Now you need to give the ball physical properties. <br><br><h4>  Adding ball physics </h4>  In order to give the ball physical effects, it is necessary to simulate the effect on it of a force representing gravity.  If you remember the school course of physics, you know that the accelerated motion of the body is described by the following equations: <br>  <i>s = s <sub>0</sub> + v <sub>0</sub> t + 1 / 2at <sup>2</sup></i> <i><br></i>  <i>v = v <sub>0</sub> + at</i> <br>  Where s is the position of the body at time t, s <sub>0</sub> is the initial position, v <sub>0</sub> is the initial velocity, a is acceleration.  For vertical movement, a is the acceleration of gravity (-10 m / s <sup>2</sup> ), and s <sub>0</sub> = 0 (first, the ball is on the ground, that is, at zero height).  The equations turn into the following: <br>  <i>s = v <sub>0</sub> t-5t <sup>2</sup></i> <i><br></i>  <i>v = v <sub>0</sub> -10t</i> <br>  We want to reach the maximum height in 1 second.  At the maximum height, the speed is 0. Therefore, the second equation allows us to find the initial speed: <br>  <i>0 = v <sub>0</sub> - 10 * 1 =&gt; v <sub>0</sub> = 10 m / s</i> <br>  This gives us the ball movement: <br>  <i>s = 10t - 5t <sup>2</sup></i> <br>  You need to change the <i>Update</i> method to use this equation: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-comment"><span class="hljs-comment">// Rotate scene. m_rotation = static_cast&lt;float&gt;(timer.GetTotalSeconds()) * 0.5f; auto totalTime = (float) fmod(timer.GetTotalSeconds(), 2.0f); m_translation = 10*totalTime - 5 *totalTime*totalTime; }</span></span></code> </pre></div></div><br>  Now that the ball is moving up and down realistically, it's time to add a football field. <br><br><h4>  Adding a football field </h4>  To add a football field, you need to create a new scene.  In the Assets folder, right-click to add a new 3D scene, and name it <i>field.fbx</i> .  From the toolbox, add a plane and select it, change its size along the X axis to 107, and along the Z axis to 60. Set the properties of this plane <i>Texture1 to an</i> image of a football field. <br>  You can now use the zoom tool (or press the Z key) to reduce the image. <br>  Then you need to load the model in <i>CreateDeviceDependentResources</i> in <i>Game.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::CreateDeviceDependentResources() { <span class="hljs-comment"><span class="hljs-comment">// snip // Load the scene objects. auto loadMeshTask = Mesh::LoadFromFileAsync( m_graphics, L"gamelevel.cmo", L"", L"", m_meshModels) .then([this]() { return Mesh::LoadFromFileAsync( m_graphics, L"field.cmo", L"", L"", m_meshModels, false // Do not clear the vector of meshes ); }); (loadMeshTask) .then([this] () { // Scene is ready to be rendered. m_loadingComplete = true; }); }</span></span></code> </pre></div></div><br>  When you start the program, you will see that the field jumps with the ball.  To stop the field from moving, you need to change the Render method: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Renders one frame using the Starter Kit helpers, void Game::Render() { // snip for (UINT i = 0; i &lt; m_meshModels.size(); i++) { XMMATRIX modelTransform = rotation; String^ meshName = ref new String(m_meshModels[i]-&gt;Name()); m_graphics.UpdateMiscConstants(m_miscConstants); if (String::CompareOrdinal(meshName, L"Sphere_Node") == 0) m_meshModels[i]-&gt;Render(m_graphics, modelTransform); else m_meshModels[i]-&gt;Render(m_graphics, XMMatrixIdentity()); } }</span></span></code> </pre></div></div><br>  With this change, the conversion applies only to the ball.  The field is drawn without conversion.  If you run the code now, you will see that the ball bounces off the field, but ‚Äúfalls‚Äù into it at the bottom.  To correct this error, move the field to -0.5 along the Y axis. Select the field and change its translation along the Y axis to -0.5.  Now when you start the application, the ball will bounce off the field, as in fig.  four. <br><br><img src="https://habrastorage.org/files/a64/a69/eef/a64a69eef65c419eadeb9dfd2e6e8b87.jpg"><br>  <i>Figure 4. The ball bounces off the field.</i> <br><br><h4>  Setting the position of the camera and the ball </h4>  The ball is located in the center of the field, but we do not need it there.  In this game, the ball must be on the 11-meter mark.  You should move the ball along the X axis by changing the ball movement in the <i>Render</i> method in <i>Game.cpp</i> : <br><pre> <code class="cpp hljs">rotation *= XMMatrixTranslation(<span class="hljs-number"><span class="hljs-number">63.0</span></span>, m_translation, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  The ball moves 63 units along the X axis, that is, it is placed on the 11-meter mark.  After this change, you will no longer see the ball, because it is out of the camera‚Äôs field of view: the camera is installed in the center of the field and aimed at the middle.  The camera needs to be repositioned so that it is aimed at the goal line.  You need to do this in the <i>CreateWindowSizeDependentResources</i> file in the <i>Game.cpp</i> file: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">m_graphics.GetCamera().SetViewport((UINT) outputSize.Width, (UINT) outputSize.Height); m_graphics.GetCamera().SetPosition(XMFLOAT3(<span class="hljs-number"><span class="hljs-number">25.</span></span>Of, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); m_graphics.GetCamera().SetLookAt(XMFLOAT3(<span class="hljs-number"><span class="hljs-number">100.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> aspectRatio = outputSize.Width / outputSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fovAngleY = <span class="hljs-number"><span class="hljs-number">30.0f</span></span> * XM_PI / <span class="hljs-number"><span class="hljs-number">180.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aspectRatio &lt; <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Portrait or snap view m_graphics.GetCamera().SetUpVector(XMFLOAT3(1.0f, 0.0f, 0.0f)); fovAngleY = 120.0f * XM_PI / 180.0f; } else { // Landscape view. m_graphics.GetCamera().SetUpVector(XMFLOAT3(0.0f, 1.0f, 0.0f)); } m_graphics.GetCamera().SetProjection(fovAngleY, aspectRatio, 1.0f, 100.0f);</span></span></code> </pre></div></div><br>  The camera is now located between the mid-field mark and the 11-meter mark and is directed towards the goal line.  The new view is shown in Fig.  five. <br><br><img src="https://habrastorage.org/files/614/a4b/bd2/614a4bbd26ea458badcf731d6513e39f.jpg"><br>  <i>Figure 5. Modified ball position and new camera position</i> <br><br><h4>  Adding a goal post </h4>  To add to the field of the gate, you need a new three-dimensional scene with a gate.  You can create your own model or use the finished one.  This model should be added to the Assets folder so that it can be compiled and used. <br>  This model needs to be loaded in the <i>CreateDeviceDependentResources method</i> in the <i>Game.cpp</i> file: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> loadMeshTask = Mesh::LoadFromFileAsync( m_graphics, <span class="hljs-string"><span class="hljs-string">L"gamelevel.cmo"</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, m_meshModels) .then([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mesh::LoadFromFileAsync( m_graphics, <span class="hljs-string"><span class="hljs-string">L"field.cmo"</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, m_meshModels, <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// Do not clear the vector of meshes ); }).then([this]() { return Mesh::LoadFromFileAsync( m_graphics, L"soccer_goal.cmo", L"", L"", m_meshModels, false // Do not clear the vector of meshes ); });</span></span></code> </pre></div></div><br>  After loading, set the position and draw in the <i>Render</i> method in <i>Game.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> goalTransform = XMMatrixScaling(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>) * XMMatrixRotationY(-XM_PIDIV2)* XMMatrixTranslation(<span class="hljs-number"><span class="hljs-number">85.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (UINT i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_meshModels.size() ; i++) { XMMATRIX modelTransform = rotation; String'^ meshName = ref <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String (m_meshModels [i]-&gt;Name ()) ; m_graphics.UpdateMiscConstants(m_miscConstants); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String::CompareOrdinal(meshName, <span class="hljs-string"><span class="hljs-string">L"Sphere_Node"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) m_meshModels[i]-&gt;Render(m_graphics, modelTransform); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String::CompareOrdinal(meshName, <span class="hljs-string"><span class="hljs-string">L"Plane_Node"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) m_meshModels[i]-&gt;Render(m_graphics, XMMatrixIdentity()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_meshModels[i]-&gt;Render(m_graphics, goalTransform); }</code> </pre></div></div><br>  This change applies the transform to the gate and draws it.  This transformation is a combination of three transformations: scaling (2 times increase in the original size), rotated 90 degrees and moving 85.5 units along the X axis and ‚Äì0.5 units along the Y axis due to the depth of the field.  After that, the gate is set facing the field on the goal line.  Note that the order of transformations is important: if you apply a rotation after moving, the gate will be drawn in a completely different place and you will not see them. <br><br><h4>  Kick the ball </h4>  All elements are set in place, but the ball still bounces.  It's time to hit him.  For this you need to re-apply physical skills.  Hitting the ball looks like it is shown in fig.  6 <br><br><img src="https://habrastorage.org/files/693/b74/143/693b7414336742939ee22543a9d5caae.png"><br>  <i>Figure 6. The scheme of hitting the ball</i> <br><br>  The ball is hit at an initial speed of v <sub>0</sub> at an angle Œ± (if you don‚Äôt remember school physics lessons, play a little bit at Angry Birds to see this principle in action).  The movement of the ball can be decomposed into two different movements: horizontally - this is movement at a constant speed (we assume that there is no air resistance and the effect of the wind), as well as vertical movement - the same as we used before.  Horizontal equation of motion: <br>  <i>s <sub>X</sub> = s <sub>0</sub> + v <sub>0</sub> * cos (Œ±) * t</i> <br>  Vertical motion equation: <br>  <i>s <sub>Y</sub> = s <sub>0</sub> + v <sub>0</sub> * sin (Œ±) * t - 1/2 * g * t <sup>2</sup></i> <br>  Thus, we have two movements: one along the X axis, the other along the Y axis. If the blow was struck at an angle of 45 degrees, then <i>cos (Œ±) = sin (Œ±) = sqrt (2) / 2</i> , therefore <i>v <sub>0</sub> * cos ( Œ±) = v <sub>0</sub> * sin (a) * t</i> .  It is necessary that the ball hit the goal, so the range of impact should exceed 86 units (the distance to the goal line is 85.5).  It is necessary that the flight of the ball took 2 seconds.  When substituting these values ‚Äã‚Äãin the first equation we get: <br>  <i>86 = 63 + v <sub>0</sub> * cos (Œ±) * 2&gt; = v <sub>0</sub> * cos (Œ±) = 23/2 = 11.5</i> <br>  If we replace the values ‚Äã‚Äãin the equation, then the equation of displacement along the Y axis will be: <br>  <i>s <sub>Y</sub> = 0 + 11.5 * t-5 * t <sup>2</sup></i> <br>  And on the X axis - this: <br>  <i>s <sub>X</sub> = 63 + 11.5 * t</i> <br>  The equation for the Y axis gives us time when the ball hits the ground again.  To do this, you need to solve the quadratic equation (yes, I understand that you hoped to say goodbye to them forever after the school algebra course, but nevertheless, here it is): <br>  <i>(-b ¬± sqrt (b <sup>0</sup> - 4 * a * c)) / 2 * a&gt; = (-11.5 ¬± sqrt (11.52 - 4 * -5 * 0) / 2 * -5&gt; = 0 or 23/10&gt; = 2.3 s</i> <br>  These equations can replace the movement for the ball.  First, in <i>Game.h,</i> create variables to save the movement along three axes: <br>  <i>float m_translationX, m_translationY, m_translationZ;</i> <br>  Then in the <i>Update</i> method in <i>Game.cpp</i> add the equations: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-comment"><span class="hljs-comment">// Rotate scene. m_rotation = static_cast&lt;float&gt;(timer.GetTotalSeconds()) * 0.5f; auto totalTime = (float) fmod(timer.GetTotalSeconds(), 2.3f); m_translationX = 63.0 + 11.5 * totalTime; m_translationY = 11.5 * totalTime - 5 * totalTime*totalTime; }</span></span></code> </pre></div></div><br>  The <i>Render</i> method uses these new movements: <br>  <i>rotation * = XMMatrixTranslation (m_translationX, m_translationY, 0);</i> <br>  If you run the program now, you will see the ball fly into the middle of the gate.  If you want the ball to move in other directions, you need to add a horizontal angle of impact.  To do this, we use the displacement along the Z axis. <br>  The distance from the 11-meter mark to the gate is 22.5 units, and the distance between the goal posts is 14 units.  This gives us the angle Œ± = atan (7 / 22.5), that is, 17 degrees.  You can calculate and move along the Z axis, but you can make it easier: the ball should move to the line at the same moment when it reaches the bar.  This means that the ball must move 7 / 22.5 units along the Z axis and 1 unit along the X axis. The equation for the Z axis will be: <br>  s <sub>z</sub> = 11,5 * t / 3,2 ‚â• s <sub>z</sub> = 3,6 * t <br><br>  This move to the goal post.  Any movement with a lower speed will have a smaller angle.  For the ball to reach the goal, the speed must be between -3.6 (left bar) and 3.6 (right bar).  If we consider that the ball must completely hit the gate, the maximum distance is 6 / 22.5, and the speed is from 3 to -3.  With these numbers, you can set the angle of impact in the <i>Update</i> method: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-comment"><span class="hljs-comment">// Rotate scene. m_rotation = static_cast&lt;float&gt;(timer.GetTotalSeconds()) * 0.5f; auto totalTime = (float) fmod(timer.GetTotalSeconds(), 2.3f); m_translationX = 63.0 + 11.5 * totalTime; m_translationY = 11.5 * totalTime - 5 * totalTime*totalTime; m_translationZ = 3 * totalTime; }    Z     Render: rotation *= XMMatrixTranslation(m_translationX, m_translationY, m_translationZ); ‚Ä¶ .</span></span></code> </pre></div></div><br>  The result should be approximately the same as in fig.  7 <br><br><img src="https://habrastorage.org/files/f5d/988/6ed/f5d9886ede98459aba7cd057bf32b1b8.jpg"><br>  <i>Figure 7. Blow at an angle</i> <br><br><h4>  Adding a goalkeeper </h4>  The movement of the ball is ready, the gate is in place, now you need to add a goalkeeper who will catch the ball.  In the role of the goalkeeper, we will have a distorted cube.  In the Assets folder, add a new item (new 3D scene) and name it <i>goalkeeper.fbx</i> . <br>  Add a cube from the toolbox and select it.  Set the scale: 0.3 for the X axis, 1.9 for the Y axis and 1 for the Z axis. Set the <i>MaterialAmbient</i> property to 1 for red and 0 for blue and green to make the object red. <br>  Change the value of the <i>Red</i> property in the <i>MaterialSpecular</i> section to 1 and the value of the <i>MaterialSpecularPower</i> property to 0.2. <br>  Load a new resource in the <i>CreateDeviceDependentResources method</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> loadMeshTask = Mesh::LoadFromFileAsync( m_graphics, <span class="hljs-string"><span class="hljs-string">L"gamelevel.cmo"</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, m_meshModels) .then([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mesh::LoadFromFileAsync( m_graphics, <span class="hljs-string"><span class="hljs-string">L"field.cmo"</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, <span class="hljs-string"><span class="hljs-string">L""</span></span>, m_meshModels, <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// Do not clear the vector of meshes ); }).then([this]() { return Mesh::LoadFromFileAsync( m_graphics, L"soccer_goal.cmo", L"", L"", m_meshModels, false // Do not clear the vector of meshes ); }).then([this]() { return Mesh::LoadFromFileAsync( m_graphics, L"goalkeeper.cmo", L"", L"", m_meshModels, false // Do not clear the vector of meshes ); });</span></span></code> </pre></div></div><br>  Now you need to position the goalkeeper in the middle of the gate and draw it.  This must be done in the <i>Render</i> method in <i>Game.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Render() { <span class="hljs-comment"><span class="hljs-comment">// snip auto goalTransform = XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixRotationY(-XM_PIDIV2)* XMMatrixTranslation(85.5f, -0.5f, 0); auto goalkeeperTransform = XMMatrixTranslation(85.65f, 1.4f, 0) ; for (UINT i = 0; i &lt; m_meshModels.size(); i++) { XMMATRIX modelTransform = rotation; String^ meshName = ref new String (m_meshModels [i]-&gt;Name ()) ; m_graphics.UpdateMiscConstants(m_miscConstants); if (String::CompareOrdinal(meshName, L"Sphere_Node") == 0) m_meshModels[i]-&gt;Render(m_graphics, modelTransform); else if (String::CompareOrdinal(meshName, L"Plane_Node") == 0) m_meshModels[i]-&gt;Render(m_graphics, XMMatrixIdentity()); else if (String::CompareOrdinal(meshName, L"Cube_Node") == 0) m_meshModels[i]-&gt;Render(m_graphics, goalkeeperTransform); else m_meshModels[i]-&gt;Render(m_graphics, goalTransform); } }</span></span></code> </pre></div></div><br>  This code places the goalkeeper in the middle of the gate.  Now you need to make sure that the goalkeeper can move left and right to catch the ball.  To control the movement of the goalkeeper, the user will press the left and right arrow keys. <br>  The goalkeeper‚Äôs movement is limited by goalposts located at a distance of +7 and -7 units along the Z axis. The goalkeeper‚Äôs width is 1 unit each way, so he can move 6 units left or right. <br>  The keystroke is <i>captured</i> on the XAML page ( <i>Directxpage.xaml</i> ) and redirected to the <i>Game</i> class.  Add the <i>KeyDown event</i> handler to <i>Directxpage.xaml</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"StarterKit.DirectXPage"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:local</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"using:StarterKit"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:d</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:mc</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mc:Ignorable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"d"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">KeyDown</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"OnKeyDown"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  Event handler in <i>DirectXPage.xaml.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DirectXPage::OnKeyDown(Platform::ObjectŒõ sender, Windows::UI::Xaml::Input::KeyRoutedEventArgsŒõ e) { m_main-&gt;OnKeyDown( -&gt;Key); }</code> </pre></div></div><br>  m_main is an instance of the <i>StarterKitMain</i> class that <i>renders the</i> game's scenes and frame rate counter.  You need to declare a public method in <i>StarterKitMain.h</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarterKitMain</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DX::IDeviceNotify { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StarterKitMain(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;DX::DeviceResources&gt;&amp; deviceResources); ~StarterKitMain(); <span class="hljs-comment"><span class="hljs-comment">// Public methods passed straight to the Game renderer. Platform: : String'^ OnHitObject (int x, int y) { return m_sceneRenderer-&gt;OnHitObject(x, y); } void OnKeyDown(Windows::System::VirtualKey key) { m_sceneRenderer-&gt;OnKeyDown(key); } ‚Ä¶ .</span></span></code> </pre></div></div><br>  This method redirects the key to the <i>OnKeyDown</i> method in the <i>Game</i> class.  Now we need to declare the <i>OnKeyDown</i> method in the <i>Game.h</i> file: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Gamefconst <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;DX::DeviceResources&gt;&amp; deviceResources); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeviceDependentResources</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWindowSizeDependentResources</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReleaseDeviceDependentResources</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DX::StepTimer consts timer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnKeyDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Windows::System::VirtualKey key)</span></span></span></span>; ‚Ä¶</code> </pre></div></div><br>  This method handles keystrokes and moves the goalkeeper in the appropriate direction.  Before creating this method, you need to declare a private field in the <i>Game.h</i> file to save the position of the goalkeeper: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// snip private: // snip float m_goalkeeperPosition;</span></span></code> </pre></div></div><br>  Initially, the goalkeeper is at position 0. This value will increase or decrease when the user presses an arrow key.  If the position is greater than 6 or less than -6, the position of the goalkeeper does not change.  This must be done in the <i>OnKeyDown</i> method in <i>Game.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::OnKeyDown(Windows::System::VirtualKey key) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MaxGoalkeeperPosition = <span class="hljs-number"><span class="hljs-number">6.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MinGoalkeeperPosition = <span class="hljs-number"><span class="hljs-number">-6.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == Windows::System::VirtualKey::Right) m_goalkeeperPosition = m_goalkeeperPosition &gt;= MaxGoalkeeperPosition ? m_goalkeeperPosition : m_goalkeeperPosition + <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == Windows::System::VirtualKey::Left) m_goalkeeperPosition = m_goalkeeperPosition &lt;= MinGoalkeeperPosition ? m_goalkeeperPosition : m_goalkeeperPosition - <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; }</code> </pre></div></div><br>  The new position of the goalkeeper is used in the <i>Render</i> method of the <i>Game.cpp</i> file, where the goalkeeper movement is calculated: <br>  <i>auto goalkeeperTransform = XMMatrixTranslation (85.65f, 1.40f, m_goalkeeperPosition);</i> <br>  By applying these changes, you can start the game: you will see that the goalkeeper moves to the right or left when you press the corresponding arrow keys (see Figure 8). <br><br><img src="https://habrastorage.org/files/7f0/bdc/ec1/7f0bdcec1668430dbc063429c61aac87.jpg"><br>  <i>Figure 8. Playing with the goalkeeper in the desired position.</i> <br><br>  Until now, the ball moved constantly, but we do not need it.  The ball must begin movement immediately after the strike and stop when the goal is reached.  The goalkeeper should also not move before hitting the ball. <br>  You must declare the private field <i>m_isAnimating</i> in the <i>Game.h</i> file <i>so</i> that the game ‚Äúknows‚Äù when the ball is moving: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// snip private: // snip bool m_isAnimating;</span></span></code> </pre></div></div><br>  This variable is used in the <i>Update</i> and <i>Render</i> methods in <i>Game.cpp</i> , so the ball moves only when <i>m_isAnimating</i> is true: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isAnimating) { m_rotation = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> totalTime = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(timer.GetTotalSeconds(), <span class="hljs-number"><span class="hljs-number">2.3f</span></span>); m_translationX = <span class="hljs-number"><span class="hljs-number">63.0f</span></span> + <span class="hljs-number"><span class="hljs-number">11.5f</span></span> * totalTime; m_translationY = <span class="hljs-number"><span class="hljs-number">11.5f</span></span> * totalTime - <span class="hljs-number"><span class="hljs-number">5.</span></span>Of * totalTime*totalTime; m_translationZ = <span class="hljs-number"><span class="hljs-number">3.0f</span></span> * totalTime; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Render() { <span class="hljs-comment"><span class="hljs-comment">// snip XMMATRIX modelTransform; if (m_isAnimating) { modelTransform = XMMatrixRotationY(m_rotation); modelTransform *= XMMatrixTranslation(m_translationX, m_translationY, m_translationZ); } else modelTransform = XMMatrixTranslation(63.0f, 0.0f, 0.0f); ‚Ä¶ .</span></span></code> </pre></div></div><br>  The variable <i>modelTransform</i> moves from the loop to the beginning.  The arrow keys should be processed in the <i>OnKeyDown</i> method only when <i>m_isAnimating</i> is true: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::OnKeyDown(Windows::System::VirtualKey key) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MaxGoalkeeperPosition = <span class="hljs-number"><span class="hljs-number">6.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isAnimating) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> goalKeeperVelocity = key == Windows::System::VirtualKey::Right ? <span class="hljs-number"><span class="hljs-number">0.1f</span></span> : <span class="hljs-number"><span class="hljs-number">-0.1f</span></span>; m_goalkeeperPosition = <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(m_goalkeeperPosition) &gt;= MaxGoalkeeperPosition ? m_goalkeeperPosition : m_goalkeeperPosition + goalKeeperVelocity; } }</code> </pre></div></div><br>  Now you need to hit the ball.  This happens when the user presses the space bar.  Declare a new private field <i>m_isKick</i> in the <i>Game.h</i> file: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// snip private: // snip bool m_isKick;</span></span></code> </pre></div></div><br>  Set this field to true in the <i>OnKeyDown</i> method in <i>Game.cpp</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::OnKeyDown(Windows::System::VirtualKey key) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MaxGoalkeeperPosition = <span class="hljs-number"><span class="hljs-number">6.</span></span> Of; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isAnimating) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> goalKeeperVelocity = key == Windows::System::VirtualKey::Right ? <span class="hljs-number"><span class="hljs-number">0.1f</span></span> : <span class="hljs-number"><span class="hljs-number">-0.1f</span></span>; m_goalkeeperPosition = <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(m_goalkeeperPosition) &gt;= MaxGoalkeeperPosition ? m_goalkeeperPosition : m_goalkeeperPosition + goalKeeperVelocity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( y == Windows::System::VirtualKey::Space) m_isKick = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre></div></div><br>  When <i>m_isKick</i> is true, the animation method starts in the <i>Update</i> method: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isKick) { m_startTime = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()); m_isAnimating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; m_isKick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isAnimating) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> totalTime = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()) ‚Äì m_startTime; m_rotation = totalTime * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; m_translationX = <span class="hljs-number"><span class="hljs-number">63.0f</span></span> + <span class="hljs-number"><span class="hljs-number">11.5f</span></span> * totalTime; m_translationY = <span class="hljs-number"><span class="hljs-number">11.5f</span></span> * totalTime - <span class="hljs-number"><span class="hljs-number">5.</span></span>Of * totalTime*totalTime; m_translationZ = <span class="hljs-number"><span class="hljs-number">3.0f</span></span> * totalTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (totalTime &gt; <span class="hljs-number"><span class="hljs-number">2.3f</span></span>) ResetGame(); } }</code> </pre></div></div><br>       <i>m_startTime</i> (      <i>Game.h</i> ),      .    2,3 ,   (        ).  <i>ResetGame</i>     <i>Game.h</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::ResetGame() { m_isAnimating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_goalkeeperPosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>     <i>m_isAnimating</i>  false    .     :     11- ,  <i>m_isAnimating</i>   false.     .       : <br> <i>m_translationZ = 3.0f * totalTime;</i> <br>    ,        ,     .     <i>m_ballAngle</i>   <i>Game.h</i>          <i>Update</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; timer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isKick) { m_startTime = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()); m_isAnimating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; m_isKick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_ballAngle = (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; (rand()) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; (RAND_MAX) <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) * <span class="hljs-number"><span class="hljs-number">6.0f</span></span>; } ‚Ä¶ .</code> </pre></div></div><br> <i>Rand()/RAND_MAX</i>    0  1.     0,5,     -0,5  0,5,     6,      -3  3.       ,   ,  srand   <i>CreateDeviceDependentResources</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::CreateDeviceDependentResources() { srand(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; (time(<span class="hljs-number"><span class="hljs-number">0</span></span>))); ‚Ä¶ .</code> </pre></div></div><br>    ,   <i>ctime</i> .      ,   <i>m_ballAngle</i>   <i>Update</i> : <br> <i>m_translationZ = m_ballAngle * totalTime;</i> <br>     ,   ,    ,     .     : ,             . ,          ,        .      <i>Update</i> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Update(DX::StepTimer consts timer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isKick) { m_startTime = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()); m_isAnimating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; m_isKick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_isGoal = m_isCaught = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_ballAngle = (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; (rand()) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; (RAND_MAX) <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) * <span class="hljs-number"><span class="hljs-number">6.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isAnimating) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> totalTime = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(timer.GetTotalSeconds()) ‚Äì m_startTime; m_rotation = totalTime * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !m_isCaught) { <span class="hljs-comment"><span class="hljs-comment">// ball traveling m_translationX = 63.0f + 11.5f * totalTime; m_translationY = 11.5f * totalTime - 5.0f * totalTime*totalTime; m_translationZ = m_ballAngle * totalTime; } else { // if ball is caught, position it in the center of the goalkeeper m_translationX = 83.35f; m_translationY = 1.8f; m_translationZ = m_goalkeeperPosition; } if (!m_isGoal &amp;&amp; !m_isCaught &amp;&amp; m_translationX &gt;= 85.5f) { // ball passed the goal line - goal or caught auto ballMin = m_translationZ - 0.5f + 7.0f; auto ballMax = m_translationZ + 0.5f + 7.0f; auto goalkeeperMin = m_goalkeeperPosition - 1.0f + 7.0f; auto goalkeeperMax = m_goalkeeperPosition + 1.0f + 7.0f; m_isGoal = (goalkeeperMax &lt; ballMin || goalkeeperMin &gt; ballMax); m_isCaught = !m_isGoal; } if (totalTime &gt; 2.3f) ResetGame(); } }</span></span></code> </pre></div></div><br>       <i>Game.h</i> : <i>m_isGoal</i>  <i>m_IsCaught</i> .      ,  :       .      false,   .    ,        ,       .    ,  ,    7.0 f   .   ,       ,     .  7.0 f,   ,     ,   .   ,      . <i>m_isGoal</i>  <i>m_IsCaught</i>   . <br><br> ,      .    ,  ,      ,   <a href="https://software.intel.com/en-us/articles/developing-3d-games-for-windows-8-with-c-and-microsoft-directx">   IDZ</a> . <br><br><h4>  Conclusion </h4> ,  .         DirectX.      ,   C++/DX      ,   C#. <br>       ,       .      , ,   . <br>     ,  ,       .             . </div><p>Source: <a href="https://habr.com/ru/post/241085/">https://habr.com/ru/post/241085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241069/index.html">Online course ‚ÄúData Visualization. Basics</a></li>
<li><a href="../241073/index.html">Feedback 2014-2015!</a></li>
<li><a href="../241079/index.html">Examine databases using T-SQL</a></li>
<li><a href="../241081/index.html">Batniki against exploits (version for Windows XP)</a></li>
<li><a href="../241083/index.html">How we do World of Warships: export automation and content verification</a></li>
<li><a href="../241087/index.html">Veeam announces free utility for backup of physical machines and servers</a></li>
<li><a href="../241089/index.html">Mobile applications for web developers</a></li>
<li><a href="../241095/index.html">Git as subversion</a></li>
<li><a href="../241099/index.html">How to make profitable design development sites (part 1)</a></li>
<li><a href="../241103/index.html">Rendering Clones in a Python Project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>