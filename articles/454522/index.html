<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js: managing the memory available to applications running in containers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When running Node.js applications in Docker containers, traditional memory settings do not always work as expected. The material, the translation of w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js: managing the memory available to applications running in containers</h1><div class="post__text post__text-html js-mediator-article">  When running Node.js applications in Docker containers, traditional memory settings do not always work as expected.  The material, the translation of which we are publishing today, is dedicated to finding an answer to the question of why this is so.  Practical guidelines for managing the memory available to Node.js applications running in containers will also be provided here. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/454522/"><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Review of recommendations</font> </h2><br>  Suppose a Node.js application runs in a container with a set memory limit.  If we are talking about Docker, then to set this limit the option <code>--memory</code> could be used.  Something similar is possible when working with container orchestration systems.  In this case, it is recommended that when launching a Node.js application, use the <code>--max-old-space-size</code> option.  This allows the platform to inform about how much memory is available to it, as well as to take into account the fact that this volume must be less than the limit set at the container level. <br><br>  When a Node.js application runs inside a container, set the capacity of its available memory according to the peak usage of the active memory by the application.  This is done if the container's memory limits can be configured. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now let's talk about the problem of using memory in containers in more detail. <br><br><h2>  <font color="#3AC1EF">Docker memory limit</font> </h2><br>  By default, containers have no resource limits and can use as much memory as the operating system allows them.  The <code>docker run</code> command has command line options that allow you to set limits for memory usage or processor resources. <br><br>  The container launch command may look like this: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Note the following: <br><br><ul><li>  <code>x</code> is the limit of the amount of memory available to the container, expressed in units of <code>y</code> . </li><li>  <code>y</code> can be <code>b</code> (bytes), <code>k</code> (kilobytes), <code>m</code> (megabytes), <code>g</code> (gigabytes). </li></ul><br>  Here is an example of a container launch command: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Here the memory limit is set to <code>1000000</code> bytes. <br><br>  To check the memory limit set at the container level, you can, in the container, run the following command: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Let's talk about the behavior of the system when specifying the memory limit of the Node.js application with the <code>--max-old-space-size</code> key.  At the same time, this memory limit will correspond to the limit set at the container level. <br><br>  The fact that the name of the key is called ‚Äúold-space‚Äù is one of the fragments of the heap managed by V8 (the place where the ‚Äúold‚Äù JavaScript objects are located).  This key, if you do not go into details, which we touch below, controls the maximum heap size.  Details about the command line keys for Node.js can be found <a href="https://nodejs.org/api/cli.html">here</a> . <br><br>  In general, when an application tries to use more memory than is available in the container, its operation is terminated. <br><br>  In the following example (the application file is called <code>test-fatal-error.js</code> ) in the <code>list</code> array, with an interval of 10 milliseconds, put the objects <code>MyRecord</code> .  This leads to uncontrolled growth of the heap, simulating a memory leak. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Please note that all the examples of programs that we will consider here are placed in the Docker image, which can be downloaded from the Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  You can use this method for independent experiments. <br><br>  In addition, you can pack the application in the Docker container, build the image and run it with the memory limit: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Here <code>ravali1906/dockermemory</code> is the name of the image. <br><br>  Now you can start the application by specifying a memory limit for it that exceeds the container limit: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Here the key <code>--max_old_space_size</code> is a memory limit, specified in megabytes.  The <code>process.memoryUsage()</code> method provides information about memory usage.  Values ‚Äã‚Äãare expressed in bytes. <br><br>  The application at some point in time is forcibly terminated.  This happens when the amount of memory used by them passes a certain limit.  What is this border?  What are the limitations on the amount of memory you can talk about? <br><br><h2>  <font color="#3AC1EF">The expected behavior of an application running with the --max-old-space-size key</font> </h2><br>  By default, the maximum heap size in Node.js (up to version 11.x) is 700 MB on 32-bit platforms, and 1400 MB on 64-bit ones.  About setting these values ‚Äã‚Äãcan be read <a href="https://github.com/nodejs/node/pull/25576">here</a> . <br><br>  In theory, if you set a memory limit using the <code>--max-old-space-size</code> key that exceeds the container‚Äôs memory limit, you can expect the application to be terminated by the Linux OOM Killer protection mechanism. <br><br>  In reality, this may not happen. <br><br><h2>  <font color="#3AC1EF">The real behavior of the application running with the key --max-old-space-size</font> </h2><br>  The application, immediately after the launch, does not allocate all the memory whose limit is specified using - <code>--max-old-space-size</code> .  The size of the JavaScript heap depends on the needs of the application.  The size of the memory used by the application can be judged based on the value of the <code>heapUsed</code> field from the object returned by the <code>process.memoryUsage()</code> method.  In fact, we are talking about the memory allocated in the heap for objects. <br><br>  As a result, we conclude that the application will be forcibly terminated if the heap size is greater than the limit set by the <code>--memory</code> key when the container is started. <br><br>  But in reality this may not happen either. <br><br>  When profiling resource-intensive Node.js applications that run in containers with a given memory limit, the following patterns can be observed: <br><br><ol><li>  The OOM Killer is triggered much later than the moment when the <code>heapTotal</code> and <code>heapUsed</code> are significantly higher than the memory limits. </li><li>  OOM Killer does not respond to exceeding the limits. </li></ol><br><h2>  <font color="#3AC1EF">Explaining the behavior of Node.js applications in containers</font> </h2><br>  The container monitors one important indicator of the applications that it runs.  This is <a href="https://ru.wikipedia.org/wiki/Resident_set_size">RSS</a> (resident set size).  This indicator represents a certain part of the virtual memory of the application. <br><br>  Moreover, it is a fragment of memory that is allocated to the application. <br><br>  But that's not all.  RSS is part of the active memory allocated to the application. <br><br>  Not all memory allocated to an application may be active.  The fact is that "allocated memory" is not necessarily physically allocated until the process really starts using it.  In addition, in response to requests for memory allocation from other processes, the operating system can flush the inactive parts of the application's memory to the paging file and transfer the vacated space to other processes.  And when the application needs these fragments again, they will be taken from the paging file and returned to physical memory. <br><br>  The RSS indicator indicates the amount of active and available memory for the application in its address space.  It is he who influences the decision to force the application to shut down. <br><br><h2>  <font color="#3AC1EF">Proof of</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçExample No. 1.</font>  <font color="#3AC1EF">An application that allocates memory for buffer</font> </h3><br>  In the following example, <code>buffer_example.js</code> , a program is shown that allocates memory for the buffer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  In order for the amount of memory allocated by the program to exceed the limit set when the container was started, we first start the container with the following command: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  After that, run the program: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  As you can see, the system has not completed the program execution, although the memory allocated by the program exceeds the container limit.  This happened due to the fact that the program does not work with all allocated memory.  The RSS feed is very small, it does not exceed the container's memory limit. <br><br><h3>  <font color="#3AC1EF">‚ñçExample number 2.</font>  <font color="#3AC1EF">Data buffer application</font> </h3><br>  In the following example, <code>buffer_example_fill.js</code> , the memory is not just allocated, but also filled with data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Run the container: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  After that, run the application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  As you can see, even now the application does not end!  Why?  The fact is that when the amount of active memory reaches the limit specified when the container is started, and there is a place in the paging file, some of the old pages of the process memory are moved to the paging file.  Released memory is available to the same process.  By default, Docker allocates a space for the paging file that equals the memory limit specified by the - memory flag.  Given this, we can say that the process has 2 GB of memory - 1 GB in active memory, and 1 GB in the paging file.  That is, due to the fact that the application can use its own memory, the contents of which are temporarily moved to the paging file, the size of the RSS index is within the limit of the container.  As a result, the application continues to work. <br><br><h3>  <font color="#3AC1EF">‚ñçSample number 3.</font>  <font color="#3AC1EF">An application that fills a buffer with data, running in a container in which the paging file is not used.</font> </h3><br>  Here is the code we will experiment with here (this is the same <code>buffer_example_fill.js</code> file): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  This time we will launch the container, explicitly setting up the features of working with the paging file: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Run the application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  See the <code>Killed</code> post?  When the value of the <code>--memory-swap</code> key is equal to the value of the <code>--memory</code> key, this indicates to the container that it should not use the paging file.  In addition, by default, the kernel of the operating system in which the container itself is running can dump a certain amount of anonymous memory pages used by the container into the paging file.  We set the flag - <code>--memory-swappiness</code> to <code>0</code> , disable this feature.  As a result, it turns out that inside the container the paging file is not used.  The process ends when the RSS exceeds the container's memory limit. <br><br><h2>  <font color="#3AC1EF">General recommendations</font> </h2><br>  When Node.js applications are launched with the <code>--max-old-space-size</code> key, the value of which exceeds the memory limit set when the container was started, it may seem that Node.js is ‚Äúnot paying attention‚Äù to the container limit.  But, as can be seen from the previous examples, the obvious reason for this behavior is the fact that the application simply does not use the entire heap volume specified using the <code>--max-old-space-size</code> flag. <br><br>  Remember that an application will not always behave in the same way if it uses more memory than is available in the container.  Why?  The fact is that the active process memory (RSS) is influenced by many external factors that the application itself cannot influence.  They depend on the system load and on the characteristics of the environment.  For example, these are the features of the application itself, the level of concurrency in the system, features of the operating system scheduler, features of the garbage collector, and so on.  In addition, these factors, from launch to launch of the application, may vary. <br><br><h2>  <font color="#3AC1EF">Recommendations for configuring the size of the Node.js heap for cases in which this parameter can be controlled, but not for container-level memory constraints</font> </h2><br><ul><li>  Run the minimal Node.js application in a container and measure the static RSS size (in my case, for Node.js 10.x, this is about 20 MB). </li><li>  The Node.js heap contains not only the old_space area, but others as well (such as new_space, code_space, and so on).  Therefore, if we consider the standard configuration of the platform, we should count on the fact that the program will need about 20 more MB of memory.  If the default settings have changed - these changes also need to be considered. </li><li>  Now you need to subtract the resulting value (suppose it will be 40 MB) from the amount of memory available in the container.  What remains is a value that, without fear of program termination due to lack of memory, can be specified as the key value - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Recommendations for configuring container memory limits for cases where this parameter can be controlled, and the parameters of the Node.js application are not.</font> </h2><br><ul><li>  Run the application in modes that allow you to find out the peak values ‚Äã‚Äãof the memory it consumes. </li><li>  Analyze the RSS feed.  In particular, here, along with the <code>process.memoryUsage()</code> method, the Linux <code>top</code> command is also useful. </li><li>  Provided that in the container in which it is planned to launch the application, nothing but it will be executed, the resulting value can be used as a container memory limit.  In order to hedge, it is recommended to increase it by at least 10%. </li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In Node.js 12.x, some of the problems discussed here are solved by adaptively adjusting the heap size, performed according to the amount of available RAM.  This mechanism also works when running Node.js applications in containers.  But the settings may differ from the default settings.  This, for example, occurs in cases when the key <code>--max_old_space_size</code> used when the application was <code>--max_old_space_size</code> .  For such cases, all of the above remains relevant.  This suggests that the person who runs Node.js applications in containers should be attentive and responsive to the memory settings.  In addition, knowledge of the standard restrictions on the use of memory, rather conservative, allows to improve the performance of applications due to a deliberate change in these restrictions. <br><br>  <b>Dear readers!</b>  Have you encountered memory shortage problems when running Node.js applications in Docker containers? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://ruvds.com/ru-rub/news/read/104"><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div><p>Source: <a href="https://habr.com/ru/post/454522/">https://habr.com/ru/post/454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454512/index.html">Report from breakfast with Charles Wetzerell, author of the cult book "Etudes for Programmers"</a></li>
<li><a href="../454514/index.html">Developing a simple music synthesizer on ATMEGA8</a></li>
<li><a href="../454516/index.html">How to get a good text for 200 rubles</a></li>
<li><a href="../454518/index.html">Wasmer: the fastest go-library for running WebAssembly code</a></li>
<li><a href="../454520/index.html">Recommendations for writing clean code in JavaScript</a></li>
<li><a href="../454524/index.html">Repair Headphone Headband Samsung Level On Pro</a></li>
<li><a href="../45453/index.html">iLike is looking for a buyer</a></li>
<li><a href="../454530/index.html">DJI has created an Octocopter that can shoot movies.</a></li>
<li><a href="../454532/index.html">About the engineering approach I put in a word</a></li>
<li><a href="../454534/index.html">Unscientific about monads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>