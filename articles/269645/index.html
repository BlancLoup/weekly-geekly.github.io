<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a dynamically changing landscape for RTS on Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time I had the joy of playing the wonderful RTS called ‚ÄúPerimeter: Geometry of Warriors‚Äù from the local developer KD Labs. This is a game ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a dynamically changing landscape for RTS on Unity3D</h1><div class="post__text post__text-html js-mediator-article">  Once upon a time I had the joy of playing the wonderful RTS called ‚ÄúPerimeter: Geometry of Warriors‚Äù from the local developer KD Labs.  This is a game about how huge flying cities called Frames plow the expanses of Spunja - a chain of interconnected worlds.  The plot is rather strange and abstract, but a much more interesting and innovative component of the game was one of its technical features, and not the plot.  Unlike most RTS, where battles take place on static terrain, in the "Perimeter", one of the key game mechanics was terraforming.  The player had the means to manipulate the landscape in order to build his structures on it, as well as a whole arsenal of combat units capable of turning this landscape into cracked, sailing and belching heated stones / nasty insects. <br><br>  As you know, the world of RTS is now experiencing some decline.  Indie developers are too busy riveting retro platformers and rouge-like games of insubstantial complexity, and therefore, having replayed Perimeter some time ago, I decided that I should try to implement something like that myself - the idea was interesting and technical and gameplay points of view.  Having some practical experience in game development (I tried to do something on XNA before), I thought that in order to achieve at least some success alone I would have to use something higher level and simpler.  My choice fell on Unity 3D, whose fifth version just came out from under the press. <br><br>  Armed with a car of enthusiasm, inspiration from the newly completed ‚ÄúPerimeter‚Äù and a scanned series of video tutorials on Unity, I began to make sketches and get acquainted with the tools that the Unity Editor offered me. <br><a name="habracut"></a><br><h4>  <b>What does the community offer?</b> </h4><br>  As always, my first pancake came out lumpy.  Without sufficient deliberation, I began to implement the landscape using a plane and code that was supposed to raise or lower the vertices of this plane.  Many readers, at least a little familiar with Unity, may object, ‚ÄúBut after all, Unity has a Terrain component designed specifically for this purpose!‚Äù - and they will be right.  The only problem is that I, being too passionate about the implementation of my idea, forgot about one important thing: RTFM!  I studied the documentation and forums a little more thoroughly; I would not solve the problem in such an openly foolish way, but I would immediately use the ready-made component. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After two days of useless sweat and algorithmism (the plane was clearly not intended to be used for such purposes), I started making terrain using Terrain.  I must say that among the individual members of the Unity community, there was the idea of ‚Äã‚Äãcreating a dynamic landscape for your game.  Some people asked questions in the forums and received answers.  They were recommended to use the SetHeights method, which takes as input a piece of normalized from 0f to 1f heightmap, which will be set starting from the point (xBase; yBase) on the selected terrain. <br><br>  Pleased with the results of my searches, I began developing.  The first working prototype was ready a couple of hours later and included a simple camera dvigalka (using the right key), a simple crater generator and actually adding these craters to the landscape by pressing the left key (you can grab the build and see <a href="https://drive.google.com/file/d/0ByET7N3PxyMbM3dBc2dkU1VWWms/view%3Fusp%3Dsharing">here</a> ). <br><br>  By itself, the deforming part was obscenely simple. <br><br><div class="spoiler">  <b class="spoiler_title">This was a script similar to the following:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DeformationData data</span></span></span><span class="hljs-function">)</span></span> { currentHeights = data.terrainData.GetHeights(data.X - data.W/<span class="hljs-number"><span class="hljs-number">2</span></span>, data.Y - data.H/<span class="hljs-number"><span class="hljs-number">2</span></span>, W, H); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.W; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; data.H; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.Type == DeformationType.Additive) currentHeights[i, j] += data.heightmap[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> currentHeights[i, j] *= data.heightmap[i, j]; } } data.terrainData.SetHeights(data.X - data.W/<span class="hljs-number"><span class="hljs-number">2</span></span>, data.Y - data.H/<span class="hljs-number"><span class="hljs-number">2</span></span>, currentHeights); }</code> </pre> <br></div></div><br>  The DeformationData object contained the X and Y coordinates to which the deformation should be applied, normalized to heightmap, which additively or multiplicatively superimposed on the current landscape and the other boilerplate necessary for the deformation mechanism to work. <br><br>  There was also a strain generator, allowing, for example, <br><br><div class="spoiler">  <b class="spoiler_title">generate crater according to specified parameters</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     -  H, W   . //  ,  H -   , W -  . float GetDepth(float distanceToCenter, int holeDepth, int wallsHeight, int holeRadius, int craterRadius) { if (distanceToCenter &lt;= holeRadius) { return (Mathf.Pow(distanceToCenter, 2) * (holeDepth + wallsHeight) / Mathf.Pow(holeRadius, 2)) - holeDepth; } else if (distanceToCenter &lt;= craterRadius) { return Mathf.Pow(craterRadius - distanceToCenter, 2) * wallsHeight / Mathf.Pow(craterRadius - holeRadius, 2); } else return 0f; } float[,] Generate(int holeDepth, int wallsHeight, int holeRadius, int craterRadius) { var heightmap = new float[W, H]; for (var x = 0; x &lt; W; x++) { for (var y = 0; y &lt; H; y++) { var offsetX = x - W / 2; var offsetY = y - H / 2; var depth = GetDepth(Mathf.Sqrt(offsetX * offsetX + offsetY * offsetY), holeDepth, wallsHeight, holeRadius, craterRadius); heightmap[x, y] = depth; } } }</span></span></code> </pre><br></div></div><br>  And all this was the basis of the Tech Demo, if so of course you can put it. <br><br><h4>  <b>Analysis of the results of the first attempt</b> </h4><br>  If you watched Tech Demo, you probably immediately noticed certain problems in the mechanism of deformations.  If you did not watch it (for which I do not blame you), then I will tell you what was wrong.  The main problem was performance.  More precisely, its complete absence.  When the deformations began, the framerate fell to very small (on some machines unambiguous) numbers, which was unacceptable, because in fact there was no graphics in the game.  I was able to find out that the SetHeights () method itself causes a very complicated series of LOD calculations for a landscape and for this reason is not suitable for landscape deformations in real time.  It would seem that my hopes collapsed and the implementation of real-time deformations on Unity is impossible, but I did not give up and found out the obvious, but very important feature of the LOD recalculation mechanism. <br><br>  The lower the resolution of the terrain height map, the less impact on performance when using SetHeights (). <br><br>  The resolution of the height map is a parameter characterizing the quality of the landscape display.  It is an integer (obviously), why in the snippet above, integer variables were used to indicate the coordinates on the map.  And it can be more than the size of the landscape, for example, for a landscape of 256x256, you can set the resolution of the height map to 513, which will give the landscape accuracy and less angular outlines.  Why 513, and not 512, I will tell in the next section. <br><br>  Games with a resolution map of heights allowed me to find more or less optimal sizes for my configuration, but I was very disappointed with the results.  For the successful application of such a landscape in the RTS, its size must be large enough so that at least two players can coexist on it for some time.  According to my initial estimates, a 2x2 km map (or 2048x2048 Unity Units) should have been just right.  In order not to notice the effect on the framerate of deformations in real time, the size of the landscape had to be no more than 512x512 units.  Moreover, the single accuracy of the height map did not give the most impressive results when it came to visual quality.  The landscape was angular and crooked in places, which required doubling the accuracy of height maps. <br><br>  In general, things were not very good. <br><br><h4>  <b>Super Terrain - concept and theory</b> </h4><br><pre> <code class="cs hljs"> :         Super Terrain.        .</code> </pre><br>  Approximately then the following thought began to visit me: ‚ÄúSince we cannot make one big landscape and still have sufficient performance during deformations, why not make a lot of small ones and not place them side by side?  ‚ÄúHow are chunk's in Minecraft?‚Äù The idea was not bad, but there were some problems: <br><br><ul><li>  How to choose a size for "chunk" </li><li>  How to make so that the joints "chunk'ov" there were no noticeable seams </li><li>  How to apply deformations that occur at the joints of neighboring chunk'ov </li></ul><br><h6>  <b>First problem</b> </h6><br>  The first problem was quite trivial: I just chose a size for a 256x256 chunk with double precision (heightmap resolution = 513).  This setup did not cause performance problems <i>on my machine</i> .  Perhaps in the future it would be necessary to revise the size of the chunk, but at the current stage, this decision was fine with me. <br><br><h6>  <b>Second problem</b> </h6><br>  As for the second problem, she had two components.  The first, obviously, was to equalize the heights of the neighboring "pixels" of the heights of the neighboring chunk's.  It was during the solution of this problem that I understood why the resolution of the height map is a power of two + 1. I will demonstrate in the illustration: <br><br><img src="https://habrastorage.org/files/b23/f02/e53/b23f02e53c834f9b8d63115f376d5373.png"><br><br>  It is obvious that in order to maintain the equality of heights in neighboring landscapes, the ‚Äúlast‚Äù pixel of the height map of the first landscape must be equal in height to the ‚Äúfirst‚Äù pixel of the following: <br><br><img src="https://habrastorage.org/files/9e1/ee4/370/9e1ee43709fc4c9da9034c7807cdb002.png"><br><br>  Obviously, ‚ÄúSuper Terrain‚Äù is the matrix of the Unity Terrain, united by the mechanism of imposing heightmap and deformation. <br><br>  After the implementation of the code for combining landscapes was completed (the application of local deformations of small size was left for later - now it was necessary to develop a mechanism for creating a matrix of Terrains and initial initialization of the height map), another component of the second problem was discovered (no seams ), which fortunately was resolved quite simply.  The problem was that for such a ‚Äúblending‚Äù of landscapes, it is necessary to explain to Unity that they are shared and neighboring.  For this, the developers provided the <a href="http://docs.unity3d.com/ScriptReference/Terrain.SetNeighbors.html">SetHeighbors</a> method.  I still do not quite understand how it works, but without it, artifacts with shadows and dark stripes appear at the junctions of landscapes. <br><br><h6>  <b>Third problem</b> </h6><br>  The most interesting and difficult of the three, this problem gave me no rest for at least a week.  I discarded four different implementations until I reached the final one, which I will tell you about.  I will immediately make a small remark about one important limitation of my implementation - it assumes that the local deformation cannot be larger than one chunk.  The deformation can still be at their junction, however, the side of the deformation matrix should not exceed the resolution of the chunk elevation map and all of them should be square (elevation maps, chunks themselves, and deformations).  In general, this is not a big limitation, since any deformation of a large size can be obtained by applying several small ones in turn.  As for the "square", then this is a restriction of the height map.  That is, only its height map should be square, on which there can be ‚Äúzero‚Äù sections with additive or ‚Äúsingle‚Äù with multiplicative applications. <br><br>  The very idea of ‚Äã‚Äãthe algorithm for the universal application of deformation was as follows: <br><br><ol><li>  Divide the heightmap deformations into nine parts, one for each of the chunks, which can potentially be affected by the deformation.  So the central part will be responsible for the deformation of the chunk, which is directly affected by the deformation, the sides are responsible for the chunk, which are left / right or top / bottom, etc.  If the deformation does not change the chunk, then its component will be equal to null. </li><li>  Apply partial heightmap to the appropriate chunk, or ignore the changes if the partial heightmap is null. </li></ol><br>  Such an approach allows to apply universally both deformations located both in the very center of the chunk and not affecting other chunkes, and at the borders with them or even in the corners.  It is necessary to divide it into nine parts (and not into four) due to the fact that if the deformation begins or ends at the border of the chunk, the boundary pixels of the one next to it must also be changed.  (In order to avoid visible seams - see the solution to problem number 2). <br><br><h4>  <b>Super Terrain - practice</b> </h4><br><h6>  <b>Creating SuperTerrain</b> </h6><br>  Within the framework of the second problem, the mezanism was developed, which allows to combine several Terrains into one and apply ‚Äúglobal‚Äù height maps, which lie on the entire landscape as a whole. <br><br>  Let me say at once that this possibility of the global use of the height map was needed because the landscape creation was procedural, and for its use the <a href="http://www.playfuljs.com/realistic-terrain-in-130-lines/">Square-Diamond algorithm was used</a> , the output of which was a large matrix of floats ‚Äî our large height map. <br><br>  In general, creating SuperTerrain is a fairly simple and intuitive process, described <br><br><div class="spoiler">  <b class="spoiler_title">here</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Compound terrain object. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class SuperTerrain { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Contains the array of subterrain objects </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private Terrain[,] subterrains; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Superterrain detail. The resulting superterrain is 2^detail terrains. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;value&gt;</span></span></span><span class="hljs-comment">The detail.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/value&gt;</span></span></span><span class="hljs-comment"> public int Detail { get; private set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Parent gameobject to nest created terrains into. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;value&gt;</span></span></span><span class="hljs-comment">The parent.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/value&gt;</span></span></span><span class="hljs-comment"> public Transform Parent { get; private set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Builds the new terrain object. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">The new terrain.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private Terrain BuildNewTerrain() { // Using this divisor because of internal workings of the engine. // The resulting terrain is still going to be subterrain size. var divisor = GameplayConstants.SuperTerrainHeightmapResolution / GameplayConstants.SubterrainSize * 2; var terrainData = new TerrainData { size = new Vector3 (GameplayConstants.SubterrainSize / divisor, GameplayConstants.WorldHeight, GameplayConstants.SubterrainSize / divisor), heightmapResolution = GameplayConstants.SuperTerrainHeightmapResolution }; var newTerrain = Terrain.CreateTerrainGameObject(terrainData).GetComponent</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Terrain&gt;</span></span></span><span class="hljs-comment">(); newTerrain.transform.parent = Parent; newTerrain.transform.gameObject.layer = GameplayConstants.TerrainLayer; newTerrain.heightmapPixelError = GameplayConstants.SuperTerrainPixelError; return newTerrain; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Initializes the terrain array and moves the terrain transforms to match their position in the array. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void InitializeTerrainArray() { subterrains = new Terrain[Detail, Detail]; for (int x = 0; x </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Detail; x++) { for (int y = 0; y &lt; Detail; y++) { subterrains[y, x] = BuildNewTerrain(); subterrains[y, x].transform.Translate(new Vector3(x * GameplayConstants.SubterrainSize, 0f, y * GameplayConstants.SubterrainSize)); } } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Initializes a new instance of the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="SuperTerrain"/&gt;</span></span></span><span class="hljs-comment"> class. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="detail"&gt;</span></span></span><span class="hljs-comment">Superterrain detail. The resultsing superterrain is 2^detail terrains.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="parent"&gt;</span></span></span><span class="hljs-comment">Parent gameobject to nest created terrains into.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public SuperTerrain(int detail, Transform parent) { Detail = detail; Parent = parent; InitializeTerrainArray(); SetNeighbors(); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Iterates through the terrain object and sets the neightbours to match LOD settings. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void SetNeighbors() { ForEachSubterrain ((x, y, subterrain) =&gt; { subterrain.SetNeighbors(SafeGetTerrain(x - 1, y), SafeGetTerrain(x, y + 1), SafeGetTerrain(x + 1, y), SafeGetTerrain(x, y - 1)); }); } #region [ Array Helpers ] </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Safely retrieves the terrain object from the array. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="x"&gt;</span></span></span><span class="hljs-comment">The x coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="y"&gt;</span></span></span><span class="hljs-comment">The y coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private Terrain SafeGetTerrain(int x, int y) { if (x </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; 0 || y &lt; 0 || x &gt;</span></span></span><span class="hljs-comment">= Detail || y &gt;= Detail) return null; return subterrains[y, x]; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Iterates over terrain object and executes the given action </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="lambda"&gt;</span></span></span><span class="hljs-comment">Lambda.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private void ForEachSubterrain(Action</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;int, int, Terrain&gt;</span></span></span><span class="hljs-comment"> lambda) { for (int x = 0; x </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Detail; x++) { for (int y = 0; y &lt; Detail; y++) { lambda (x, y, SafeGetTerrain(x, y)); } } } #endregion }</span></span></span></span></code> </pre><br></div></div><br>  The actual creation of landscapes takes place in the InitializeTerrainArray () method, which fills the Terrain array with new instances and moves them to the right place in the game world.  The BuildNewTerrain () method creates the next instance and initializes it with the necessary parameters and also places the ‚Äúparent‚Äù inside the GameObject (it is assumed that a game object will be created on the scene that contains the chunk and SuperTerrain in order not to pollute objects and simplify cleanup if need be.) <br><br>  It also applies to the treatment of one of the problems with black stripes on the borders of the landscape - the SetNeighbours () method, which is iterated over the created landscapes and puts down their neighbors.  <b>Important note:</b> the TerrainData.SetNeighbors () method should apply <b>to all</b> landscapes in a group.  That is, if you indicated that landscape A is a neighbor on top of landscape B, then you also need to indicate that landscape B is a neighbor below for landscape A. This redundancy is not entirely clear, but it greatly simplifies the iterative application of the method, as in our case. <br><br>  In the code above, there are several interesting points, for example, the use of the divisor when creating the next landscape.  To be honest, I myself do not understand why this is necessary - just creating a landscape in the usual way (without a divisor) creates a landscape of the wrong size (which may be a bug, or maybe I just didn‚Äôt read the documentation well).  This amendment was received empirically and still did not fail, so I decided to leave it as it is. <br><br>  You may also have noticed that at the bottom of the listing there are two suspicious helper methods.  In fact, this is simply the result of refactoring (as I show listings of a more or less stable version, which has undergone several refactorings, but is still not perfect).  These methods are used further in the application of local and global deformations.  From their name it is easy to guess what they are doing. <br><br><h6>  <b>Application of a global height map</b> </h6><br>  Now that the landscape has been created, it‚Äôs time to teach him to use the ‚Äúglobal height map‚Äù.  For this, SuperTerrain provides <br><br><div class="spoiler">  <b class="spoiler_title">couple of methods</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Sets the global heightmap to match the given one. Given heightmap must match the (SubterrainHeightmapResolution * Detail). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="heightmap"&gt;</span></span></span><span class="hljs-comment">Heightmap to set the heights from.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public void SetGlobalHeightmap(float[,] heightmap) { ForEachSubterrain((x, y, subterrain) =&gt; { var chunkStartX = x * GameplayConstants.SuperTerrainHeightmapResolution; var chunkStartY = y * GameplayConstants.SuperTerrainHeightmapResolution; var nextChunkStartX = chunkStartX + GameplayConstants.SuperTerrainHeightmapResolution + 1; var nextChunkStartY = chunkStartY + GameplayConstants.SuperTerrainHeightmapResolution + 1; var sumHm = GetSubHeightMap(heightmap, nextChunkStartX, nextChunkStartY, chunkStartX, chunkStartY)); subterrain.terrainData.SetHeights(0, 0, subHm); }); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Retrieves the minor heightmap from the entire heightmap array. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">The minor height map.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="heightMap"&gt;</span></span></span><span class="hljs-comment">Major heightmap.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Xborder"&gt;</span></span></span><span class="hljs-comment">Xborder.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Yborder"&gt;</span></span></span><span class="hljs-comment">Yborder.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="x"&gt;</span></span></span><span class="hljs-comment">The x coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="y"&gt;</span></span></span><span class="hljs-comment">The y coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private float[,] GetSubHeightMap (float[,] heightMap, int Xborder, int Yborder, int x, int y) { if (Xborder == x || Yborder == y || x </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; 0 || y &lt; 0) return null; var temp = new float[Yborder - y, Xborder - x]; for (int i = x; i &lt; Xborder; i++) { for(int j = y; j &lt; Yborder; j++) { temp[j - y, i - x] = heightMap[j, i]; } } return temp; }</span></span></span></span></code> </pre><br></div></div><br>  I agree, this pair of methods does not look very nice, but I will try to explain everything.  So, the name of the SetGlobalHeightmap method speaks for itself.  All he does is iterate over all chunks (which are called subterrains here) and apply to them exactly that piece of height map, which corresponds to its coordinates.  It is here that the ill-fated SetHeights are used, the performance of which forces us to go to all these perversions.  As can be seen from the code, the SuperTerrainHeightmapResolution constant does not take into account the difference by 1 resolution of the height map from the power of two (whose existence is justified in the previous section).  And don't let her name confuse you - this constant stores the resolution of the height map for a chunk, not for the whole SuperTerrain.  Since the SuperTerrain code is actively using various constants, I will immediately show you the GameplayConstants class.  Perhaps it will be clearer what all the same is happening.  I removed from this class all not related to SuperTerrain. <br><br><div class="spoiler">  <b class="spoiler_title">GameplayConstants.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Habitat.Game</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Contains the gameplay constants. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static class GameplayConstants { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The height of the world. Used in terrain raycasting and Superterrain generation. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const float WorldHeight = 512f; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Number of the "Terrain" layer </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const int TerrainLayer = 8; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Calculated mask for raycasting against the terrain. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const int TerrainLayerMask = 1 </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;&lt; TerrainLayer; /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Superterrain part side size. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const int SubterrainSize = 256; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Heightmap resolution for the SuperTerrain. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const int SuperTerrainHeightmapResolution = 512; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Pixel error for the SuperTerrain. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public const int SuperTerrainPixelError = 1; } }</span></span></code> </pre><br></div></div><br>  As for the GetSubHeightMap method, this is just another helper, copying a part of the transferred matrix into the matrix minor.  This is necessary because SetHeights cannot apply part of the matrix.  This restriction causes a whole bunch of extra memory allocations, but nothing can be done about it.  Unfortunately, Unity developers have not provided a scenario for changing the landscape in real time. <br><br>  The GetSubHeightMap method is used further when applying local deformations, but more on that later. <br><br><h6>  <b>Application of local deformations</b> </h6><br>  To use deformations, you need not only a height map, but also other information such as coordinates, method of use, dimensions, etc.  In this version, all information is encapsulated in the TerrainDeformation class, the listing of which can be seen <br><br><div class="spoiler">  <b class="spoiler_title">here.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Habitat.DynamicTerrain.Deformation</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TerrainDeformation</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Height of the deformation in hightmap pixels. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public int H { get; private set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Width of the deformation in hightmap pixels. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public int W { get; private set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Heightmap matrix object </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public float[,] Heightmap { get; private set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Initializes a new instance of the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="Habitat.DynamicTerrain.Deformation.TerrainDeformation"/&gt;</span></span></span><span class="hljs-comment"> class. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="height"&gt;</span></span></span><span class="hljs-comment">Height in heightmap pixels</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="width"&gt;</span></span></span><span class="hljs-comment">Width in heightmap pixels</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected TerrainDeformation(int height, int width) { H = height; W = width; Heightmap = new float[height,width]; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Initializes a new instance of the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="Habitat.DynamicTerrain.Deformation.TerrainDeformation"/&gt;</span></span></span><span class="hljs-comment"> class. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="bitmap"&gt;</span></span></span><span class="hljs-comment">Normalized heightmap matrix.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected TerrainDeformation(float[,] bitmap) { Heightmap = bitmap; H = bitmap.GetUpperBound(0); W = bitmap.GetUpperBound(1); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Applies deformation to the point. Additive by default. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">The to point.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="currentValue"&gt;</span></span></span><span class="hljs-comment">Current value.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="newValue"&gt;</span></span></span><span class="hljs-comment">New value.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public virtual float ApplyToPoint(float currentValue, float newValue) { return currentValue + newValue; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Generates the heightmap matrix based on constructor parameters. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract TerrainDeformation Generate(); } }</span></span></code> </pre><br></div></div><br>  It is easy to guess that the heirs of this class implement the abstract method Generate (), where they describe the logic for creating the appropriate heightmap for deformation.  TerrainDeformation also contains information about exactly how it should be applied to the current landscape ‚Äî this defines the ApplyToPoint virtual method.  By default, it defines the deformation as additive, but by overloading the method it is possible to achieve more complex methods of combining two heights.  As for the separation of the deformation matrix into sub-matrices and applying them to the corresponding chunks, this code is in the class SuperTerrain and is highlighted in <br><br><div class="spoiler">  <b class="spoiler_title">The following group of methods:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Compound terrain object. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class SuperTerrain { //... </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Resolution of each terrain in the SuperTerrain; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private readonly int hmResolution = GameplayConstants.SuperTerrainHeightmapResolution; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Applies the partial heightmap to a single terrain object. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="heightmap"&gt;</span></span></span><span class="hljs-comment">Heightmap.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="chunkX"&gt;</span></span></span><span class="hljs-comment">Terrain x.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="chunkY"&gt;</span></span></span><span class="hljs-comment">Terrain y.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="startX"&gt;</span></span></span><span class="hljs-comment">Start x.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="startY"&gt;</span></span></span><span class="hljs-comment">Start y.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="type"&gt;</span></span></span><span class="hljs-comment">Deformation type.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private void ApplyPartialHeightmap(float[,] heightmap, int chunkX, int chunkY, int startX, int startY, TerrainDeformation td) { if (heightmap == null) return; var current = subterrains [chunkY, chunkX].terrainData.GetHeights( startX, startY, heightmap.GetUpperBound (1) + 1, heightmap.GetUpperBound (0) + 1); for (int x = 0; x </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= heightmap.GetUpperBound(1); x++) { for (int y = 0; y &lt;= heightmap.GetUpperBound(0); y++) { current[y, x] = td.ApplyToPoint(current[y, x], heightmap[y, x]); } } subterrains[chunkY, chunkX].terrainData.SetHeights (startX, startY, current); } private int TransformCoordinate (float coordinate) { return Mathf.RoundToInt(coordinate * hmResolution / GameplayConstants.SubterrainSize); } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Applies the local deformation. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="deformation"&gt;</span></span></span><span class="hljs-comment">Deformation.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="x"&gt;</span></span></span><span class="hljs-comment">The x coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="y"&gt;</span></span></span><span class="hljs-comment">The y coordinate.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public void ApplyDeformation(TerrainDeformation td, float xCoord, float yCoord) { int x = TransformCoordinate (xCoord); int y = TransformCoordinate (yCoord); var chunkX = x / hmResolution; var chunkY = y / hmResolution; ApplyPartialHeightmap(GetBottomLeftSubmap(td, x, y), chunkX - 1, chunkY - 1, hmResolution, hmResolution, td); ApplyPartialHeightmap(GetLeftSubmap(td, x, y), chunkX - 1, chunkY, hmResolution, y % hmResolution, td); ApplyPartialHeightmap(GetTopLeftSubmap(td, x, y), chunkX - 1, chunkY + 1, hmResolution, 0, td); ApplyPartialHeightmap(GetBottomSubmap(td, x, y), chunkX, chunkY - 1, x % hmResolution, hmResolution, td); ApplyPartialHeightmap(GetBottomRightSubmap(td, x, y), chunkX + 1, chunkY - 1, 0, hmResolution, td); ApplyPartialHeightmap(GetMiddleSubmap(td, x, y), chunkX, chunkY, x % hmResolution, y % hmResolution, td); ApplyPartialHeightmap(GetTopSubmap(td, x, y), chunkX, chunkY + 1, x % hmResolution, 0, td); ApplyPartialHeightmap(GetRightSubmap(td, x, y), chunkX + 1, chunkY, 0, y % hmResolution, td); ApplyPartialHeightmap(GetTopRightSubmap(td, x, y), chunkX + 1, chunkY + 1, 0, 0, td); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the bottom-left part of the deformation (Subheightmap, applied to the bottom </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">left chunk of the targetChunk) or null if no such submap has to be applied. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Covers corner cases private float[,] GetBottomLeftSubmap(TerrainDeformation td, int x, int y) { if (x % hmResolution == 0 &amp;&amp; y % hmResolution == 0 &amp;&amp; x / hmResolution &gt; 0 &amp;&amp; y / hmResolution &gt; 0) { return new float[,] {{ td.Heightmap[0, 0] }}; } return null; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the left part of the deformation (Subheightmap, applied to the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">left chunk of the targetChunk) or null if no such submap has to be applied. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Covers edge cases private float[,] GetLeftSubmap(TerrainDeformation td, int x, int y) { if (x % hmResolution == 0 &amp;&amp; x / hmResolution &gt; 0) { int endY = Math.Min((y / hmResolution + 1) * hmResolution, y + td.H); return GetSubHeightMap(td.Heightmap, 1, endY - y, 0, 0); } return null; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the bottom part of the deformation (Subheightmap, applied to the bottom </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">chunk of the targetChunk) or null if no such submap has to be applied. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Covers edge cases private float[,] GetBottomSubmap(TerrainDeformation td, int x, int y) { if (y % hmResolution == 0 &amp;&amp; y / hmResolution &gt; 0) { int endX = Math.Min((x / hmResolution + 1) * hmResolution, x + td.W); return GetSubHeightMap(td.Heightmap, endX - x, 1, 0, 0); } return null; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the top-left part of the deformation (Subheightmap, applied to the top </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">left chunk of the targetChunk) or null if no such submap has to be applied. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Covers split edge cases private float[,] GetTopLeftSubmap(TerrainDeformation td, int x, int y) { if (x % hmResolution == 0 &amp;&amp; x / hmResolution &gt; 0) { int startY = (y / hmResolution + 1) * hmResolution; int endY = y + td.H; if (startY &gt; endY) return null; return GetSubHeightMap(td.Heightmap, 1, td.H, 0, startY - y); } return null; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the bottom-right part of the deformation (Subheightmap, applied to the bottom </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">right chunk of the targetChunk) or null if no such submap has to be applied. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Covers split edge cases private float[,] GetBottomRightSubmap(TerrainDeformation td, int x, int y) { if (y % hmResolution == 0 &amp;&amp; y / hmResolution &gt; 0) { int startX = (x / hmResolution + 1) * hmResolution; int endX = x + td.W; if (startX &gt; endX) return null; return GetSubHeightMap(td.Heightmap, td.W, 1, startX - x, 0); } return null; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the main deformation part. private float[,] GetMiddleSubmap(TerrainDeformation td, int x, int y) { int endX = Math.Min((x / hmResolution + 1) * hmResolution, x + td.W); int endY = Math.Min((y / hmResolution + 1) * hmResolution, y + td.H); return GetSubHeightMap(td.Heightmap, Math.Min(endX - x + 1, td.Heightmap.GetUpperBound(0) + 1), Math.Min(endY - y + 1, td.Heightmap.GetUpperBound(1) + 1), 0, 0); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">Retrieves the top deformation part or null if none required private float[,] GetTopSubmap(TerrainDeformation td, int x, int y) { int startY = (y / hmResolution + 1) * hmResolution; if (y + td.H </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; startY) return null; int endX = Math.Min((x / hmResolution + 1) * hmResolution, x + td.W); return GetSubHeightMap(td.Heightmap, Math.Min (endX - x + 1, td.Heightmap.GetUpperBound(0) + 1), td.H, 0, startY - y); } ///Retrieves the left deformation part or null if none required private float[,] GetRightSubmap(TerrainDeformation td, int x, int y) { int startX = (x / hmResolution + 1) * hmResolution; if (x + td.W &lt; startX) return null; int endY = Math.Min((y / hmResolution + 1) * hmResolution, y + td.H); return GetSubHeightMap(td.Heightmap, td.W, Math.Min(endY - y + 1, td.Heightmap.GetUpperBound(1) + 1), startX - x, 0); } ///Retrieves the top-right part of the main deformation. private float[,] GetTopRightSubmap(TerrainDeformation td, int x, int y) { int startX = (x / hmResolution + 1) * hmResolution; int startY = (y / hmResolution + 1) * hmResolution; if (x + td.W &lt; startX || y + td.H &lt; startY) return null; return GetSubHeightMap(td.Heightmap, td.W, td.H, startX - x, startY - y); } }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you probably already guessed, the only public method that is in the listing is the most important one. The ApplyDeformation () method allows you to apply the specified deformation to the landscape in the given coordinates. The first thing you do when you call it is to convert the coordinates on the landscape into the coordinates on the height map (remember? If the size of the landscape differs from the resolution of the height map, then this should be taken into account). All work on the application of deformation occurs within nine ApplyPartialHeightmap calls that apply chunks of heights from deformation to the corresponding chunks. As I said earlier, we need exactly nine parts, not four, to take into account all possible boundary and angular cases:</font></font><br><br><img src="https://habrastorage.org/files/3e8/561/7b6/3e85617b67db4d599ea0a7e500afa224.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is this division that GetXXXSubmap () methods do - obtaining the necessary strain minors based on the position of the deformation and the boundaries of various chunks. </font><font style="vertical-align: inherit;">Each of the methods returns null if the deformation does not affect the corresponding chunk and the method for applying these same minors (ApplyPartialHeightmap ()) does nothing if it receives null as input.</font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Results and conclusions</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resulting mechanism is certainly far from ideal, but it is already functional and allows you to adjust important landscape parameters in order to achieve some flexibility in terms of performance settings. </font><font style="vertical-align: inherit;">Among the major potential improvements are the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hard work is done in a separate process to reduce the impact on the framerate in particularly intense scenes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimize the splitting into minors, getting rid of memory allocation every time, by, for example, caching. </font><font style="vertical-align: inherit;">So far, it‚Äôs hard to imagine how you can cache something like that. </font><font style="vertical-align: inherit;">For starters, you can limit yourself to the most frequent cases - a slight deformation right in the middle of the chunk.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add the ability to influence not only the geometry of the landscape, but also its texture - deformations with a change in the splat-map. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimize for applying multiple defamations in a single frame. </font><font style="vertical-align: inherit;">For example, to accumulate deformations for chunk's in some buffer and at the end of processing logic in some way to combine and apply them - we get one setHeights call per chunk, even if there were several deformations.</font></font></li></ul><br><div class="spoiler">  <b class="spoiler_title">Screenshots</b> <div class="spoiler_text"> ,    -   : <br><br><img src="https://habrastorage.org/files/4ad/307/b8c/4ad307b8c936403aa9fba8f24d798135.png"><br><br>      (     ,   ‚Äî ¬´¬ª . <br><br><img src="https://habrastorage.org/files/17e/05e/0cb/17e05e0cb756495e8203eecb42e2a725.png"><br><br>   chunk' ,     ,   : <br><br><img src="https://habrastorage.org/files/b70/586/623/b70586623d034a24a86f704833586f65.png"><br><br>  ,   chunk. <br><br><img src="https://habrastorage.org/files/c7e/838/bf4/c7e838bf4e9f48bd811ab5c27cf311da.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"> <a href="https://www.youtube.com/watch%3Fv%3DGGgEALJ1MoE">   </a> <br><br> <a href="https://www.youtube.com/watch%3Fv%3DyMv34YodQbE">   </a> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, of course, links to playable demos: </font></font><br><br> <a href="https://drive.google.com/file/d/0ByET7N3PxyMbOEE4ZWlURmtvcnM/view%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Windows</font></font></a> <br><br>  <a href="https://drive.google.com/file/d/0ByET7N3PxyMbb2xGMkc5N0ljTFU/view%3Fusp%3Dsharing">For Linux</a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Few instructions</font></font></b> <div class="spoiler_text">     ,   RTS,   .            .  ,       ‚Äî   . ,    "~"     development console.  ¬´man¬ª  ¬´help¬ª,     ,    spawn_crater  sv_spawn_animdef.      /    .     ,            benchmark'    ( framerate    ,    )        ( google drive). <br><br>   :  + WASD =  .   = . Ctrl =  . <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/269645/">https://habr.com/ru/post/269645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269635/index.html">Data ONTAP 8.3 ADP: Root-Data Partitioning</a></li>
<li><a href="../269637/index.html">Forecasting in the gaming industry. Part 1: All About Prediction</a></li>
<li><a href="../269639/index.html">Welcome to #PostgreSQLRussia November 3</a></li>
<li><a href="../269641/index.html">How a drone can hack your home network just by flying nearby</a></li>
<li><a href="../269643/index.html">Meet the Unity Demo Team and The Blacksmith FAQ</a></li>
<li><a href="../269649/index.html">Accelerate OSB</a></li>
<li><a href="../269651/index.html">0xDBE 1.0 Preview available</a></li>
<li><a href="../269657/index.html">NoSQL era behind</a></li>
<li><a href="../269659/index.html">We write own gateway for Thrift API</a></li>
<li><a href="../269661/index.html">The basic structure of the module Magento [Magento Certification]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>