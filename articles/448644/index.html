<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Applicative regular expressions as a free alternative functor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I bring to your attention the translation of a wonderful fresh article by Justin Le. In his blog in Code, this author speaks in a fairly easy way abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Applicative regular expressions as a free alternative functor</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>I bring to your attention the translation of a wonderful fresh article by Justin Le.</em>  <em>In his blog <a href="https://blog.jle.im/">in Code,</a> this author speaks in a fairly easy way about the mathematical essence of beautiful and elegant functional solutions for practical problems.</em>  <em>This article examines in detail an example of how the transfer of the mathematical structure, which the data in the domain forms to the program type system, can immediately, as Gerald and Sassman wrote "automagically", lead to a working solution.</em> </p><br><p>  <em>The code shown in the picture is a complete, self-contained, extensible implementation of the regular expression parser, written from scratch.</em>  <em>The highest class, the real magic of types!</em> </p><a name="habracut"></a><br><p>  Today we implement applicative regular expressions and parsers (in the spirit of the <a href="https://hackage.haskell.org/package/regex-applicative">regex-applicative</a> library) using free algebraic structures!  Free structures are one of my favorite tools in Haskell, and I already wrote earlier about <a href="https://blog.jle.im/entry/alchemical-groups.html">free groups</a> , variations on the theme of <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">free monads,</a> and about the <a href="https://blog.jle.im/entry/const-applicative-and-monoids.html">"free" applicative functor on monoids</a> . </p><br><p>  Regular expressions (and parsers for them) are ubiquitous in programming and computer science, so I hope, with my demonstration of how simple they are implemented using free structures, I will help the reader to appreciate the merits of this approach without fear of getting bogged down in unnecessary details. </p><br><p> All the code in this article is <a href="">available</a> online in the form of ‚Äústack executable‚Äù.  If you start it ( <code>./regexp.hs</code> ), the GHCi session will be launched with all the definitions, so you will have the opportunity to play with the functions and their types. </p><br><p>  This article will be quite understandable to the ‚Äúadvanced novice‚Äù or ‚Äúnovice specialist‚Äù in Haskell.  It requires knowledge of the basic concepts of a language: pattern matching, algebraic data types, and abstractions such as monoids, functors, and do-notations. </p><br><h1 id="regulyarnye-yazyki">  Regular languages </h1><br><p>  A regular expression is a way to define some regular language.  Formally, such an expression is built from three basic elements: </p><br><ol><li>  An empty set is an element that does not match anything. </li><li>  An empty string is a neutral element that is trivially matched with an empty string. </li><li>  A literal is a symbol associated with itself.  A lot of one element. </li></ol><br><p>  And also from three operations: </p><br><ol><li>  Concatenation: <code>RS</code> , sequence of expressions.  The product of sets (Cartesian). </li><li>  Alternative: <code>R|S</code> , choice between expressions.  Union of sets. </li><li>  Star Kleene: <code>R*</code> , the expression is repeated an arbitrary number of times (including zero). </li></ol><br><p>  And this is all that makes up regular expressions, no more, no less.  From these basic components, you can construct all other known operations on regular expressions ‚Äî for example, <code>a+</code> can be expressed as <code>aa*</code> , and categories like <code>\w</code> can be represented as an alternative to suitable characters. </p><br><div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text"><p>  The given minimal definition of a regular language is sufficiently complete for a mathematician, but impractical.  For example, the operation of negation or addition (‚Äúany character except the specified one‚Äù) can be written within the framework of the basic definition, but its direct application will lead to an exponential growth of the resources used. </p></div></div><br><h1 id="alternativnyy-funktor">  Alternative functor </h1><br><p>  When looking at the structure of regular expressions, does it seem familiar?  It reminds me very much of the <code>Alternative</code> type class.  If the functor belongs to this class, then this means that for it is defined: </p><br><ol><li>  Empty empty element, corresponding to failure, or an error in the calculations. </li><li>  <code>pure x</code> is a single element (from the <code>Applicative</code> class). </li><li>  The <code>&lt;*&gt;</code> operation organizing sequential calculations. </li><li>  Operation <code>&lt;|&gt;</code> , organizing alternative calculations. </li><li>  The <code>many</code> function is an operation of repeating the calculations zero or more times. </li></ol><br><p>  All this is very similar to the construction of a regular language, isn't it?  Perhaps the alternative functor is almost what we need, the only thing missing is the primitive corresponding to the literal symbol. </p><br><p>  Anyone not familiar with the <code>Alternative</code> class can find a good introduction to <a href="https://wiki.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf">Typeclassopedia</a> .  But within our article, this class is simply a "double monoid" with two ways of combining <code>&lt;*&gt;</code> and <code>&lt;|&gt;</code> , which, in a sense, can be compared with the operations <code>*</code> and <code>+</code> for numbers.  In general, for the definition of an alternative functor, the five points listed above and some additional laws of commutativity and distributivity are sufficient. </p><br><div class="spoiler">  <b class="spoiler_title">Translator's Note (Nerds)</b> <div class="spoiler_text"><p>  To be precise, the author got a little excited with the "double monoid".  The class <code>Alternative</code> extends the applicative functor, which is (under certain restrictions) a semigroup, to a semiring, where the addition operation <code>&lt;|&gt;</code> with the neutral element <code>empty</code> plays the role of a commutative monoid.  Application operator </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  cannot act as an analogue of the multiplication operation in a semiring, because it does not even form <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25BC%25D0%25B0_(%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0)">magma</a> .  However, along with the <code>&lt;*&gt;</code> operator, the "one-sided" <code>*&gt;</code> and <code>&lt;*</code> operators are defined in the <code>Control.Applicative</code> package.  Each of them ignores the result of the work of the operand, which does not show the "corner": </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  If the types <code>a</code> and <code>b</code> coincide, then with these operations we get a semigroup (associativity follows from the properties of the composition).  It can be verified that for an alternative functor, multiplication is distributive with respect to addition, both on the right and on the left, and, moreover, the neutral element for addition (analogue of zero) is an absorbing element for the multiplication operation. </p><br><p>  Semi-rings also form numbers, sets, matrices of semirings, algebraic types, and ... regular expressions, so, in fact, we are talking about the same algebraic structure. </p></div></div><br><p>  Thus, we can consider regular expressions as an alternative functor, plus a primitive for a literal character.  But there is another way to look at them, and it leads us straight to free structures.  Instead of "an alternative functor with literals", we can turn the literal into an instance of the class <code>Alternative</code> . </p><br><h1 id="svoboda">  freedom </h1><br><p>  Let's write this.  Type for primitive literal: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Note that since we work with functors (applicative, alternative), then a certain ‚Äúresult‚Äù will be associated with all our regular expressions.  This is due to the fact that when defining an instance for the classes <code>Functor</code> , <code>Applicative</code> and <code>Alternative</code> we must have type-parameter. </p><br><p>  On the one hand, you can ignore this type, but on the other hand, you should use this value as a result of matching with a regular expression, as is done in industrial applications that work with regular games. </p><br><p>  In our case, <code>Prim 'a' 1 :: Prim Int</code> will represent the primitive that is mapped to the character <code>'a'</code> , and is immediately interpreted, resulting in a one. </p><br><p>  Well, now ... let's give our primitive the necessary mathematical structure using the free alternative functor from the <a href="http://hackage.haskell.org/package/free-5.1/docs/Control-Alternative-Free.html"><code>free</code></a> library: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  That's all!  This is our full-fledged type for regular expressions!  By declaring the <code>Alt</code> type as an instance of the <code>Functor</code> class, we obtained all the operations from the <code>Applicative</code> and <code>Alternative</code> classes, since in this case there are instances of <code>Applicative (Alt f)</code> and <code>Alternative (Alt f)</code> .  Now we have: </p><br><ul><li>  Trivial empty set - <code>empty</code> from class <code>Alternative</code> </li><li>  The empty string is <code>pure</code> from the <code>Applicative</code> class. </li><li>  Symbol Literal - <code>Prim</code> Base <code>Prim</code> </li><li>  Concatenation - <code>&lt;*&gt;</code> from the <code>Applicative</code> class </li><li>  Alternative - <code>&lt;|&gt;</code> from class <code>Alternative</code> </li><li>  Star wedge - <code>many</code> from class <code>Alternative</code> </li></ul><br><p>  And we got all this completely "free", that is, "for free"! </p><br><p>  Essentially, a free structure automatically provides us with only an abstraction for the base type and nothing more.  But regular expressions, by themselves, also represent only a structure: the basic elements and a set of operations, no more, no less, so a free alternative functor provides us with exactly what we need.  Not more, but not less. </p><br><p>  After adding some handy wrapper functions ... the work on the type is complete! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Examples </h1><br><p>  Well, what, try?  Let's construct the expression <code>(a|b)(cd)*e</code> , returning, in case of successful matching, the unit type <code>()</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  The function <code>void :: Functor f =&gt; fa -&gt; f ()</code> from the <code>Data.Functor</code> package discards the result, we use it, because here we are only interested in the success of the comparison.  But the operators <code>&lt;|&gt;</code> , <code>*&gt;</code> and <code>many</code> are used by us exactly as it is assumed during concatenation or selection of one of the options. </p><br><p>  Here is an interesting example more difficult, let's define the same regular expression, but now, as a result of matching, we count the number of repetitions of the substring <code>cd</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  There is a subtlety in the work of the operators <code>*&gt;</code> and <code>&lt;*</code> : arrows show the result that should be kept.  And since <code>many (string "cd") :: RegExp [String]</code> returns a list of duplicate elements, we can, staying inside the functor, calculate the length of this list, getting the number of repetitions. </p><br><p>  Moreover, the GHC compiler <code>-XApplicativeDo</code> allows <code>-XApplicativeDo</code> to write our expression using do-notation, which is probably easier to understand: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  It's all in something like how we ‚Äúcapture‚Äù the result of parsing a string using a regular expression, accessing it.  Here is an example in Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  with the only difference that we added some post-processing to calculate the number of repetitions. </p><br><p>  Here is another convenient regular <code>\d</code> , corresponding to a digit from 0 to 9 and returning a number: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Here, the <code>asum</code> function from the <code>Control.Applicative.Alternative</code> package represents a choice from the elements of the <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> <code>intToDigit</code> , and the <code>intToDigit</code> function <code>intToDigit</code> defined in the <code>Data.Char</code> package.  And, again, we can create quite elegant things, for example, the expression <code>\[\d\]</code> corresponding to a number in square brackets: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Parsing </h1><br><p>  Well, well, all we did was describe the data type for the literal with concatenation, choices and repetitions.  Fine!  But what we really need is a matching string with a regular expression, right?  How will the free alternative functor help us in this?  In fact, significantly help.  Let's look at two ways to do it! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Unload an alternative functor </h2><br><p>  <strong>What is "freedom"?</strong> </p><br><p>  The canonical way to use a free structure is to wrap it into a specific structure using a suitable algebra.  For example, the <code>foldMap</code> transformation turns a free monoid (list) into the value of any instance of the <code>Monoid</code> class: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  The <code>foldMap</code> function turns the transformation <code>a -&gt; m</code> into the transformation <code>[a] -&gt; m</code> (or, <code>FreeMonoid a -&gt; m</code> ), with a specific monoid <code>m</code> .  The general idea is that using a free structure allows you to postpone its specific use ‚Äúfor later‚Äù, separating the creation time and the time it takes to use the structure. </p><br><p>  For example, we can construct a free monoid of numbers: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  And now we can decide how we want to interpret the <code>&lt;&gt;</code> operation: <br>  Maybe this addition? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  Or multiplication? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  Or maybe the calculation of the maximum number? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  The idea is to postpone the choice of a particular monoid, first constructing a free collection of numbers 1, 2, 3, and 4. A free monoid on numbers defines such a structure over them as needed, no more, no less.  To use <code>foldMap</code> we specify "how to perceive the base type" by passing the <code>&lt;&gt;</code> operator to a particular monoid. </p><br><p>  <strong>Interpretation in the <code>State</code> functor</strong> </p><br><p>  In practice, obtaining a result from a free structure consists in finding (or creating) a suitable functor that will provide us with the desired behavior.  In our case, we are lucky, there is a concrete implementation of the class <code>Alternative</code> , which works exactly as we need: <code>StateT String Maybe</code> . </p><br><p>  The product <code>&lt;*&gt;</code> for this functor consists in organizing a sequence of state changes.  In our case, under the state, we will consider the remainder of the line being parsed, so that the consistent parsing is the best possible match for the operation <code>&lt;*&gt;</code> . </p><br><p>  And its sum <code>&lt;|&gt;</code> works as backtracking, search with return to alternative in case of failure.  It saves the state since the last successful parsing and returns to it when an alternative is unsuccessful.  This is exactly the behavior that we expect from the expression <code>R|S</code> </p><br><p>  Finally, the natural transformation for a free alternative functor is called <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  Or, for the RegExp type: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  If you are not familiar with <code>RankN</code> types (with the <code>forall b.</code> Construction), then you can see a good introduction <a href="https://ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html">here</a> .  The point here is that you need to provide a <code>runAlt</code> function that works with <code>Prim b</code> for absolutely any <code>b</code> , and not for any particular type, like <code>Int</code> and <code>Bool</code> , for example.  That is, as with working with <code>foldMap</code> we only need to specify what to do with the base type.  In our case, answer the question: "What should be done with the <code>Prim</code> type?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  This is the interpretation of <code>Prim</code> as an action in the context of a <code>StateT String Maybe</code> , where the state is an unassembled string.  Recall that <code>Prim</code> contains information about the matching character <code>c</code> and its interpretation in the form of some value <code>x</code> .  <code>Prim</code> processing consists of the following steps: </p><br><ul><li>  Using <code>get</code> state (the part of the line that was not parsed yet), and right there we pop out its first character and its remainder.  If the string is empty, it will return with an alternative.  ( <em>The <code>StateT</code> transformer acts inside the Maybe functor and if it is impossible to match the sample on the right side of the <code>&lt;-</code> operator inside the do block, the calculation will end with the result <code>empty</code> , that is, <code>Nothing</code> . Note. Lane</em> ). </li><li>  Use guard expression to match the current character with the given one.  In case of failure, it returns <code>empty</code> , and we proceed to an alternative option. </li><li>  We change the state by replacing the parsed string with its "tail", since by this time the current symbol can already be considered successfully parsed. </li><li>  We return what the primitive <code>Prim</code> should return. </li></ul><br><p>  This function can already be used to match RegEx with a string prefix.  To do this, you need to run calculations using <code>runAlt</code> and <code>runStateT</code> , passing the last string to the function to be parsed as an argument: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  That's all!  Let's see how our first solution works: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Wait, what was that?</strong> </p><br><p>  It seems that everything happened a little faster than you expected.  A minute ago we wrote our primitive, and then again!  and a working parser is ready.  Here, in fact, all the key code, a few lines in Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  And do we have a full-featured regular expression parser?  What happened? </p><br><p>  Recall that at a high level of abstraction, <code>Alt Prim</code> already contains <code>pure</code> , <code>empty</code> , <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , and <code>many</code> in its structure (with this operator there is one unpleasant subtlety, but more about it later).  What essentially does <code>runAlt</code> - uses the behavior of a particular alternative functor (in our case, <code>StateT String Maybe</code> ) to control the behavior of the operators <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , and <code>many</code> .  However, <code>StateT</code> does not have a built-in operator, similar to <code>Prim</code> , and for this we need to write a <code>processPrim</code> . </p><br><p>  So, for the <code>Prim</code> type, the <code>runAlt</code> function uses the <code>runAlt</code> , and for <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , and <code>many</code> , the appropriate instance of the <code>Alternative</code> class is used.  Thus, the <code>StateT</code> functor performs 83% of the work for us, and the remaining 17% is the <code>processPrim</code> .  In truth, this is somewhat disappointing.  One may ask: why was it at all to start with the <code>Alt</code> wrapper?  Why not immediately determine the type <code>RegExp = StateT String Maybe</code> and the appropriate primitive <code>char :: Char -&gt; StateT String Maybe Char</code> ?  If everything is done in the StateT <code>StateT</code> , then why bother with <code>Alt</code> , a free alternative functor? </p><br><p>  The main advantage of <code>Alt</code> over <code>StateT</code> is that <code>StateT</code> is ... quite a powerful tool.  But in fact, it is powerful, to the point of absurdity.  With it, you can represent a huge number of various calculations and structures, and, which is unpleasant, it is easy to imagine something that is not a regular expression.  Let's say something elementary like <code>put "hello" :: StateT String Maybe ()</code> does not match any regular regular expression, but it is of the same type as <code>RegExp ()</code> .  Thus, while we say that <code>Alt Prim</code> matches a regular expression, not more, but not less, we cannot say the same about <code>StateT String Maybe</code> .  The <code>Alt Prim</code> type is the perfect representation of a regular expression.  Everything that can be expressed with its help is a regular expression, but something that is not such an expression with its help will not work.  Here, however, there are also some unpleasant subtleties associated with Haskell's laziness, more on this later. </p><br><p>  Here we can view <code>StateT</code> only as a context used for one <br>  Regular expression interpretations - in the form of a parser.  But you can imagine other ways to use the type <code>RegExp</code> .  For example, we may need its textual representation; this is what <code>StateT</code> will not allow. </p><br><p>  We cannot say that <code>StateT String Maybe</code> is a regular expression, only that this functor can represent a parser based on regular grammars.  But about <code>Alt Prim</code> we can say for sure that this is a regular expression ( <em>as mathematicians say, they are equal to within isomorphism, approx. Lane</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Direct use of free structure </h2><br><p>  All this, of course, is very good, but what if we don‚Äôt want to shift 83% of the work to code for a type that was written by someone for us.  Is it possible to use the free <code>Alt</code> structure directly to write a parser?  This question is similar to this: how to write a function that processes lists (by matching constructors <code>(:)</code> and <code>[]</code> ) instead of using only <code>foldMap</code> ?  How to directly operate this structure instead of delegating work to a specific monoid? </p><br><p>  Glad you asked!  Let's take a look at the definition of a free alternative functor: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  This is an unusual type, defined through mutual recursion, so that it can look very confusing.  One of the ways to understand it is to imagine that <code>Alt xs</code> contains a chain of alternatives formed by the operator <code>&lt;|&gt;</code> .  And each such alternative is represented by the type <code>AltF</code> , which is a sequence of functors <code>f</code> , formed by the operator <code>&lt;*&gt;</code> (as a sequence of nested functions). </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be considered </font></font><code>AltF fa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a simply linked list </font></font><code>[fr]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, with different </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for each element. </font></font><code>Ap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponds to the constructor </font></font><code>(:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that contains </font></font><code>fr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>Pure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the end of the list </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The construction </font></font><code>forall r.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here denotes a quantifier of existence from an extension, </font></font><code>-XExistentialQuantification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and it is this one that allows connecting various types into a chain.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, </font></font><code>Alt f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">like a list of alternatives, each of which represents a chain of applications. </font><font style="vertical-align: inherit;">Or you can look at it as a normalized form of sequential (or nested) operations </font></font><code>&lt;*&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>&lt;|&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, just as the type </font></font><code>[a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a normalized form of sequential operations </font></font><code>&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br><div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () ‚Äî ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () ‚Äî  ,   <code>+</code> ,   ‚Äî ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) ‚Äî  ,   <code>&lt;|&gt;</code> ,   ‚Äî ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> ‚Äî   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   ‚Äî    ,           ‚Äî    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    ‚Äî . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x22A5;</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/448644/&amp;xid=25657,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhjzPtyERcWMY1YRY4A0CLULCt2nUQ#MJMAIN-22A5" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">‚ä•</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" .</em>  <em>approx.</em> <em>.</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://en.wikipedia.org/wiki/Star-free_language"> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://github.com/ekmett/free/pull/188"> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://hackage.haskell.org/package/regex-applicative">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     ‚Äî  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/448644/">https://habr.com/ru/post/448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448632/index.html">Is Java now paid? Dispel rumors (or not?)</a></li>
<li><a href="../448634/index.html">Ukrainian lessons</a></li>
<li><a href="../448636/index.html">Hackaday case for retrocomputer badge</a></li>
<li><a href="../448638/index.html">Buildroot - part 1. General information, building a minimal system, setting through the menu</a></li>
<li><a href="../448642/index.html">Mandatory distribution model of rights in FreeBSD</a></li>
<li><a href="../448648/index.html">How to spread all on science and not to turn the office into a hotbed of hatred</a></li>
<li><a href="../448652/index.html">Mozilla WebThings on Raspberry Pi - Getting Started</a></li>
<li><a href="../448654/index.html">Mozilla WebThings - gateway setup</a></li>
<li><a href="../448656/index.html">Big Brother is watching yourself ... or a map with a history of movements in HomeAssistant</a></li>
<li><a href="../448658/index.html">What can be done through the OBD connector in the car</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>