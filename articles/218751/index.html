<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We work asynchronously in PHP or the story of another chat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am very pleased with the rapid development of PHP over the past few years. Probably you too. There are constantly new opportunities that keep enthus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We work asynchronously in PHP or the story of another chat</h1><div class="post__text post__text-html js-mediator-article">  I am very pleased with the rapid development of PHP over the past few years.  Probably you too.  There are constantly new opportunities that keep enthusiasts staying on this platform.  That only is the recent news about the release of <a href="http://hacklang.org/">Hack</a> . <br><br>  Surely someone reading even the title of this article will grin and think: "Monsieur knows a lot about perversions!"  Disputes about the coolness of a language never subside, but anyway, I personally see for myself not so many conditions for changing the language, because I like to squeeze out all the possibilities before radically changing the whole stack.  Recently there was a <a href="http://habrahabr.ru/post/217863/">post</a> about creating a chat on Tornado and I wanted to talk about how I solved a similar problem with PHP. <br><br><h5>  Prehistory </h5><br>  One day I decided to get acquainted with WebSockets.  I was intrigued by the technology, although I wouldn‚Äôt say that it appeared only yesterday, and this coincided with the launch of a single chat service of socionic topics that suffered from a mass of flaws.  It gave me the excitement to take part in a competitive race.  Using web sockets was a fundamentally new and promising solution. <br><a name="habracut"></a><br>  The connection is established permanent and bidirectional, and on the client side, the work is reduced to processing 4 events: <b>onopen</b> , <b>onclose</b> , <b>onerror,</b> and of course <b>onmessage</b> .  No more requests via setInterval, excess traffic and server load. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let me make a small digression here for those who do not understand what it is about. <br>  Those who are familiar with the runet of the early 2000s may remember the variety of chat services, where everything slowed down and worked awkwardly. <br>  AJAX appeared a bit later and it became much better, however, in essence, the principle has not changed.  The client part still polled the server with a predetermined frequency, except that now it was possible to abandon the use of the iframe and reduce the server load a little at the expense of less data being sent. <br>  Actually, the mentioned chat service was a classic ajax chat. <br><br>  There is a truth and the reverse side of the coin in the chosen approach: <br><ul><li>  lack of support on older browsers </li><li>  manual control of maintaining the connection </li><li>  use of the daemon in the server part </li></ul><br><br>  If I didn‚Äôt worry about the first one, because my target audience was young people with modern computers and mobile gadgets, in which WebSockets support was implemented for a long time, then later on the difficulties that I‚Äôll tell you later. <br>  Using the same demon has a number of features: <br><ol><li>  You can update the code only by restarting the daemon - respectively, for the chatlan, this happens to some extent noticeably </li><li>  Fatal errors and unhandled exceptions lead to the crash of the daemon - the code should be written "bulletproof" </li><li>  The daemon must use a dedicated free port - this is a problem for those who sit behind a strict firewall. </li><li>  Use non-blocking functions </li></ol><br><br>  Those who have never heard of what the "resident program" is, and wrote only the code for the web page that works on the "started-worked-died" principle, experience a break in the pattern when writing a demon for the first time.  For example, it turns out that instantiated objects can ‚Äúlive‚Äù for a long time and store information without using database-type storage, and access to which can be obtained from different connections to the daemon.  Perhaps it is when writing it that one can most acutely encounter the problem of blocking functions and simply the lack of sharpening PHP under asynchrony. <br><br>  What is generally asynchronous?  If in simple terms, this is the ability of the code to <i>"parallelize"</i> , <strike>to execute several pieces of code independently of each other</strike> . <br>  UPD: <a href="http://habrahabr.ru/users/alekciy/" class="user_link">alekciy</a> rightly remarked: <br><blockquote>  Do not be confused.  Asynchronous! = Parallel.  Classic JS can work asynchronously, but not in parallel (on the one-thread VM).  Useful reading: <a href="http://habrahabr.ru/post/138062/">How timers work in JavaScript</a> . <br><br>  Asynchrony - the possibility of inconsistent code execution.  Parallelism - the ability to execute the same code at the same time. </blockquote><br><br>  I hope that the reader is familiar with at least the basics of JavaScript.  Most have ever written something like: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDomElement.onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"I'm hit!"</span></span>); }</code> </pre> <br><br>  Elementary, yes?  The event handler for a click event on a page element is determined.  But what if we try to do something similar in PHP? <br><br>  The first question will arise "where to determine the event object."  The second ‚Äúhow to make sure that the object is constantly polled for this event?‚Äù.  Well, let's say we make some endless loop in which this event will be polled.  And then we will face a number of serious restrictions.  First, the polling frequency should not be too low for the system to respond satisfactorily.  And should not be too high, so as not to create problems with the load on the system.  Secondly, when there are several events, there will be a problem with the fact that until the first handler runs out, the other will not start its work.  And if you need to handle thousands of connections at the same time? <br><br>  But <a href="http://reactphp.org/">ReactPHP</a> appears on the scene and does magic. <br><br><h5>  Ingredients </h5><br><ul><li>  The basis of the server part was the <a href="http://socketo.me/">Ratchet</a> package, which is essentially an add-on to ReactPHP for working with WebSockets. </li><li>  It was thought to use a javascript framework, something like AngularJS, but at that time I wanted to quickly launch a project and learning a new framework did not fit into a tight schedule.  So at first there was naked javascript, then jQuery also connected. </li><li>  I didn‚Äôt want to bother with layout and design, so I turned to Twitter Bootstrap 3 </li><li>  I considered that it would be rather important to use HTML5 Notifications, instead of blinking the page title or the sound notification. </li><li>  The resulting daemon required its own separate port, so I used nginx and set up WebSockets proxying to solve the problem with firewalls.  For the sake of interest also screwed SSL-certificate </li></ul><br><br><h5>  Brief structure </h5><br><br>  The server part consists of two parts of the code that are asymmetric in size: cassic web pages (index, password recovery) and a demon service. <br>  The main page solves the tasks of downloading the client web application, as well as the session initialization. <br><br>  The daemon is at the core of the implementation of the MessageComponentInterface interface from the Ratchet package as a class MyApp \ Chat.  Implemented methods handle the <b>onOpen</b> , <b>onClose</b> , <b>onError,</b> and <b>onMessage events</b> . <br>  Each of the handlers, with the exception of onError, is a Chain-of-Responsibility template.  The most voluminous piece of code came in onMessage, where it was decomposed into controllers. <br><br><h5>  Problems encountered and solutions </h5><br><br><ol><li>  The first thing we had to face was that fatals, any errors without a custom handler, and unhandled exceptions kill the demon.  With fatals and exceptions, the problem is solved only with the help of tests.  To my shame, the hands did not reach the tests due to a strong lack of time, but still it will be.  Simple errors, probably, they themselves know, are solved simply by using custom ErrorHandler + logging. </li><li>  A problem was discovered when, after several days of operation, someone disconnected and the chat demon began to eat 100% of the CPU, although there were no brakes in the chat.  Corrected a patch from the author Ratchet, found in GitHub.  However, for some reason it is still not included in the ReactPHP package. <br><div class="spoiler">  <b class="spoiler_title">Patch</b> <div class="spoiler_text">  diff --git a / vendor / react / stream / React / Stream / Buffer.php b / vendor / react / stream / React / Stream / Buffer.php <br>  index e516628..4560ad9 100644 <br>  @@ -83.8 +83.8 @@ class Buffer extends EventEmitter implements WritableStreamInterface <br><br>  public function handleWrite () <br>  { <br>  - if (! Is_resource ($ this-&gt; stream) || ('generic_socket' === $ this-&gt; meta ['stream_type'] &amp;&amp; feof ($ this-&gt; stream))) { <br>  - $ this-&gt; emit ('error', array (new \ RuntimeException ('Tried to write or closed stream.'))); <br>  + if (! is_resource ($ this-&gt; stream)) { <br>  + $ this-&gt; emit ('error', array (new \ RuntimeException ('Tried to write to invalid stream.'), $ this)); <br><br>  return; <br>  } <br>  @@ -107.6 +107.12 @@ class Buffer extends EventEmitter implements WritableStreamInterface <br>  return; <br>  } <br><br>  + if (0 === $ sent &amp;&amp; feof ($ this-&gt; stream)) { <br>  + $ this-&gt; emit ('error', array (new \ RuntimeException ('Tried to write to closed stream.'), $ this)); <br>  + <br>  + return; <br>  +} <br>  + <br>  $ len = strlen ($ this-&gt; data); <br>  if ($ len&gt; = $ this-&gt; softLimit &amp;&amp; $ len - $ sent &lt;$ this-&gt; softLimit) { <br>  $ this-&gt; emit ('drain'); <br></div></div><br></li><li>  Retention of connections - perhaps quite an important problem.  On normal connections via a wired network or decent wi-fi, everything was fine.  However, when entering from the mobile Internet, it was revealed that mobile operators do not like permanent connections and cut them off, apparently, depending on several conditions.  For example, if the BS is lightly loaded and everyone is silent in the chat, it could throw it away after 30 seconds.  And it could not even throw out.  So, for prevention, I added a cyclic sending of the ‚Äúping‚Äù command to the server to create activity.  But as it turned out, with greater workload of the BS, it did not roll either. <br>  In general, the implementation of the algorithm long ago suggested itself: a delayed disconnection of a user from an array of present users after a timeout expired.  Obviously, this requires the use of asynchronous code.  Naturally, no sleep () was suitable here.  I wondered about all sorts of implementation options, including even the server queues.  The solution was found and turned out to be simple and elegant: ReactPHP allows the use of timers that hang on the EventLoop.  It looks like this: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleDisconnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User $user)</span></span></span><span class="hljs-function"> </span></span>{ $loop = MightyLoop::get()-&gt;fetch(); <span class="hljs-comment"><span class="hljs-comment">//   EventLoop,      $detacher = function() use ($user) { //         ... }; if ($user-&gt;isAsyncDetach()) { $timer = $loop-&gt;addTimer(30, $detacher); // 30  $user-&gt;setTimer($timer); } else { $detacher(); } $user-&gt;getConnection()-&gt;close(); }</span></span></code> </pre><br></li><li>  Connecting to the database in daemon mode makes sense to keep it open for reasons of performance and to minimize logging clutter with connection errors.  In any case, we had to add a crutch method called before each request to the PDO wrapper to ensure connection with the database: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;dbh-&gt;query(<span class="hljs-string"><span class="hljs-string">'select 1'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (\<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;init(); } }</code> </pre><br>  Alas, I have not found a more elegant solution.  We still have to experiment with Redis, especially since there is a ready-made package <a href="https://github.com/nrk/predis-async">predis-async</a> . </li><li>  Each browser tab generates a new connection.  And letting the user multiply by cloning somehow did not want to.  It was necessary to prohibit connections with the same session.  This behavior is different from the classic chat rooms, which make it easy to work simultaneously in an arbitrary number of windows or tabs with one session. </li></ol><br><br><h5>  What can chat now and what else will learn </h5><br>  Of the main features: <br><ul><li>  chat daemon takes up about 20mb in memory and this figure is stable.  That's not bad; </li><li>  lack of mandatory registration, the user enters the chat immediately; </li><li>  registration, authorization and password recovery; </li><li>  can do private sessions and private messages (without creating a separate channel); </li><li>  personal blacklist; </li><li>  chat roulette on the basis of socionic type; </li><li>  imperceptibly to the user when the connection is broken, reconnection is made; </li><li>  avoid duplication of connections; </li><li>  flood control. </li></ul><br>  What is wrong: <br><ul><li>  no decent ORM, samopal; </li><li>  the session handler is also self-made; </li><li>  no tests; </li><li>  no multithreading. </li></ul><br>  What is expected to finalize: <br><ul><li>  to experiment with NoSQL DB, for example Redis; </li><li>  separate rooms-channels; </li><li>  downloadable avatars; </li><li>  setting up various types of notifications; </li><li>  setting personal notes on users; </li><li>  indication "now prints" in private channels. </li></ul><br><br>  What conclusions can be made after 2 months of project development?  PHP still has potential.  At least the beginning of work with the event-oriented paradigm is supposed to.  But alas, so far the language is trying to catch up, not to become the head of the movement.  If we compare the Ratchet and Tornado, then according to the possibilities they are not equal.  Hopefully, development in this direction will continue with positive acceleration. <br><br>  For the curious, the source code of the project can be seen <a href="https://github.com/kryoz/sociochat">here</a> . <br>  Constructive comments are welcome. <br><br>  PS <br>  Article on performance comparison <a href="http://philsturgeon.co.uk/blog/2013/11/benchmarking-codswallop-nodejs-v-php">Node.js vs ReactPHP</a> . <br>  Sample proxy <a href="http">socket2http</a> . </div><p>Source: <a href="https://habr.com/ru/post/218751/">https://habr.com/ru/post/218751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218741/index.html">RabbitMQ monitoring in Zabbix and hidden features of Zabbix key</a></li>
<li><a href="../218743/index.html">How to use handlebars</a></li>
<li><a href="../218745/index.html">[video] How to avoid unplanned rollback: analysis of 7 real negotiation situations</a></li>
<li><a href="../218747/index.html">Solar charging for lithium battery</a></li>
<li><a href="../218749/index.html">JoysMaker R2 Black - 3D printer for the inexperienced</a></li>
<li><a href="../218753/index.html">Variation in programming</a></li>
<li><a href="../218757/index.html">Another migration of PROXMOX to softRAID1, but now already 3.2 and on GPT partitions, installing FreeNAS 9.2 on a virtual machine and forwarding a physical disk to it</a></li>
<li><a href="../218759/index.html">Windows command line subtleties</a></li>
<li><a href="../218761/index.html">Capture video in OpenGL applications using Intel INDE Media Pack</a></li>
<li><a href="../218763/index.html">The sound on the chip AY-3-8910 (or Yamaha YM2149F) comes from the ZX Spectrum on the PC via LPT-port</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>