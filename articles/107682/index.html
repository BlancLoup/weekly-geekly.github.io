<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OOP Practice PHP5: emulation of impurities (mixin) in the language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One evening, in order to implement the behavior patterns in the ORM in my bike framework, I needed something that behaves like a mixin in Ruby or an e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OOP Practice PHP5: emulation of impurities (mixin) in the language</h1><div class="post__text post__text-html js-mediator-article">  One evening, in order to implement the behavior patterns in the ORM in my <s>bike</s> framework, I needed something that behaves like a mixin in Ruby or an extension method in C # (or as a treit / graft in future versions of PHP) I decided for interest to see how I can implement the impurities in PHP.  If you do not know what an impurity is, it does not matter, now I'll tell you everything. <br><br>  I invite you to follow me in the arguments about the implementation of impurities in PHP and programming a small library that allows them to be implemented.  The article is focused on PHP developers, beginner and intermediate level (the main thing is that you are well oriented in OOP).  In the process, I will also make a small mistake regarding the intricacies of working with PHP 5.3 with classes, I will point out to it over time and offer to correct it.  And also give my solution to your criticism.  Enjoy reading. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  What is an impurity? </h1><br>  Impurity is a class that simply provides its methods and properties to other classes.  We can assume that adding other classes to the class is simply a variant of emulation of multiple inheritance, which is not implemented in PHP.  I will give a small example in pseudocode, syntax-like in PHP for clarity: <br><pre> &lt;? php
 mixin Timeable {
     private $ timeStarted;
     private $ timeStopped;
     public function start () {$ timeStarted = time ();  }
     public function stop () {$ timeStopped = time ();  }
     public function getElapsed () {return $ timeStopped - $ timeStarted}
 }<font></font>
<font></font>
 mixin Dumpable {
     public function dump () {var_dump ($ this);  }
 }<font></font>
<font></font>
 class MyClass mixing Timeable, Dumpable {
     public function hello () {}
 }<font></font>
<font></font>
 $ a = new MyClass ();
 $ a-&gt; start ();
 sleep (250);
 $ a-&gt; stop ();
 echo $ a-&gt; getElapsed ();
 $ a-&gt; dump ();
 ?&gt;
</pre><br><br>  Is the idea clear?  Impurities simply add their functionality to the class, as if the class is inherited immediately from them all.  In doing so, they can manipulate the members of the class in which they are mixed.  Here we will implement such functionality in PHP. <br>  Let's set ourselves a task. <br><ul><li>  We need to implement the ability to add a functional from the indicated classes of impurities to instances of given classes. </li><li>  Impurity classes should not be loaded before the class in which they are mixed.  The example above uses pseudo-syntax, which allowed us to define impurity classes directly in the class declaration.  But this method has its drawbacks.  What if, in the course of the program, we need to add plugins that will act as impurities to the classes of our system?  In this case, we could declare all impurities somewhere in the initialization script and it is important for us that such an announcement does not lead to the loading of classes. </li><li>  If an admixture is mixed into a class, this means that its functionality must be available in the descendant class of this class.  Nevertheless, we use object-oriented language and it will be logical. </li><li>  When implementing it is desirable to take into account that the use of members of the classes of impurities should not be too inhibitory, especially if the system will use a lot of impurities. </li><li>  Modification of existing classes for the use of impurities should not require redesign of the existing system.  As a consequence, this means that there must be another possibility, in addition to inheriting from an abstract class, in order to teach the class to add functionality from other classes. </li><li>  Public properties and methods of impurities should be available through an instance of the host class (hereinafter I will call it ‚Äúaggregator‚Äù, since it can aggregate several impurities in itself).  And private and protected should be visible only to the impurity itself. </li><li>  An impurity should be able to address even the hidden and protected fields of its class-aggregator (when setting such a demand, I was guided by Ruby, in which there are no hidden and protected properties in the sense that they are in C ++, PHP or C #. There are addresses from everywhere It is possible to any class fields. But, since an impurity can add new behavior, it may need protected information from the aggregator class). </li></ul><br><br><h1>  Design the registry. </h1><br>  Let's think about it.  We may want to add different impurities to different classes of the system.  That is, somewhere we must store information about which classes which impurities are mixed into.  Such information for the project is global and should be accessible from everywhere.  Therefore, to implement such a repository, I chose a static class (In PHP, there are no static classes as they exist in C #. By static class, I mean a class that does not need to be instantiated. All its functionality will be implemented by static methods accessible through the name class).  As a small task, I suggest (if you are interested, after you finish reading the article to the end) to redesign the registry so that the use of a singleton is not required. <br><br>  It follows from the above that the registry should be able to register impurities for aggregator classes.  And a little higher we said that if we register an impurity for some class, then the functional of this impurity should be mixed into all descendant classes.  We cannot get a list of ancestor classes right at the time of registration (after all, we need to avoid loading classes, and the inspection of the class hierarchy will require this).  From this it follows that we will build the list of correspondences (class =&gt; list of impurities) when it is really needed.  In addition, such a list will need to be cached so that when creating new instances of aggregator classes, it will not be rebuilt. <br><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registry</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $registeredMixins = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($className, $mixinClassName)</span></span></span><span class="hljs-function"> </span></span>{ $mixinClassNames = func_get_args(); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($mixinClassNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($mixinClassNames <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $mixinClassName) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$registeredMixins[$className][] = $mixinClassName; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$classNameToMixinCache = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); } }</code> </pre> <br>  The registration function turned out pretty simple.  We give it the name of the aggregator class and a list of impurities for it.  The list of impurities for convenience can be specified through a comma.  Func_get_args () will take care of this (add elegant support for specifying the list of impurities with an array if you're interested).  Then we simply add each impurity to the list of impurities for this class.  And the last call at the end of the function clears the cache, since registering an impurity for a given class will add it also to all its descendants, which will require rebuilding the cache. <br><br>  Now let's write the caching function.  It should go through the list of classes and impurities registered for them and add to it all descendant classes given with the same list of impurities.  The result is a cache. <br>  For the caching function, we need a function that retrieves the list of ancestors of this class: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $classNameToMixinCache = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAncestors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($className)</span></span></span><span class="hljs-function"> </span></span>{ $classes = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($className); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($className = get_parent_class($className)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { $classes[] = $className; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $classes; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">precacheMixinListForClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($className)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$classNameToMixinCache[$className])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $ancestors = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::getAncestors($className); $result = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ancestors <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ancestor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$registeredMixins[$ancestor])) { $result = array_merge($result, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$registeredMixins[$ancestor]); } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$classNameToMixinCache[$className] = array_unique($result); }</code> </pre><br><br>  Please note that the function adds to the cache a list of impurities only for the specified class.  We will not immediately build the entire cache, since most of its contents may never be needed.  Before building a cache, we checked if we had already done it before. <br><br>  Now, if we need to get a list of impurities for a given class, we can use this function: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMixinsFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($className)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::precacheMixinListForClass($className); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$classNameToMixinCache[$className]; }</code> </pre><br>  Go to the next step.  Imagine that we are calling a method of an aggregator class that is defined not in it, but in one of the impurities.  What do we need to do?  We need to get a list of impurities of this class, then go over them and see if there is a method that we need is not defined in any of them. <br>  Since the impurity is the essence of the class, we do something like this: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $methodLookupCache = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMixinNameByMethodName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($className, $methodName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$methodLookupCache[$className][$methodName])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$methodLookupCache[$className][$methodName]; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::precacheMixinListForClass($className); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$classNameToMixinCache[$className] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $mixin) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method_exists($mixin, $methodName)) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$methodLookupCache[$className][$methodName] = $mixin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $mixin; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberNotFoundException(<span class="hljs-string"><span class="hljs-string">"$className has no mixed method $methodName()!"</span></span>); }</code> </pre><br><br>  That is, if there is already an entry in the cache for this class and the name of the method, we simply return them.  If not, we get a list of impurities for this class from our cache, go around them and check if any method we need implements.  If yes, add it to the cache and return the name of the impurity.  If nothing was found, we throw an exception. <br>  Exactly the same option is obtained for properties.  I suggest you write it yourself. <br>  That's all.  The registry we have implemented.  We proceed to programming the impurity class. <br><br><h1>  We program an impurity. </h1><br>  So, admixture.  And what admixture?  Impurity is the usual class.  He just knows how to work with fields of another class.  And it will be logical to pass an instance of this other class to it in the constructor. <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_owningClassInstance; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_owningClassName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($owningClassInstance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassInstance = $owningClassInstance; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassName = get_class($owningClassInstance); } }</code> </pre><br><br>  I called the base impurity class Base simply because in my project it belongs to the Mixins namespace and it is not specifically required to call it.  But you can name it as you wish. <br><br>  We can work with public fields and methods directly through the variable owningClassInstance.  But with hidden and protected will have to work through the reflection.  Nothing complicated.  I give all the definitions of functions: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_owningPropertyReflectionCache; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_owningMethodReflectionCache; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name])) { $property = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \ReflectionProperty(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassName, $name); $property-&gt;setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name] = $property; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name]-&gt;getValue(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassInstance); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setProtected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name])) { $property = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \ReflectionProperty(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassName, $name); $property-&gt;setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name] = $property; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningPropertyReflectionCache[$name]-&gt;setValue(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassInstance, $value); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeProtected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $parameters)</span></span></span><span class="hljs-function"> </span></span>{ $method = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \ReflectionMethod(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassName, $name); $method-&gt;setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $parameters = func_get_args(); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($parameters[<span class="hljs-number"><span class="hljs-number">0</span></span>]); $method-&gt;invokeArgs(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_owningClassInstance, $parameters); }</code> </pre><br><br>  Please note that here I again activated caching in order not to constantly create and not configure instances of the system classes for the reflection operation.  To reduce memory consumption, you can refuse caching, if necessary. <br>  Someone may have already noticed that the method_exists () and property_exists () functions that we used in the registry class check for the presence of implicit and hidden and protected functions with the given name, along with the public ones.  This leads to the fact that the aggregator class will ‚Äútry‚Äù to call a function with that name if it is defined as hidden or protected.  As a result, we still get an error, but I prefer to do it explicitly: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, array $arguments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberNotFoundException( <span class="hljs-string"><span class="hljs-string">"Method $name is not defined or is not accessible in mixin \""</span></span> . get_class() . <span class="hljs-string"><span class="hljs-string">"\""</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberNotFoundException( <span class="hljs-string"><span class="hljs-string">"Property $name is not defined or is not accessible in mixin \""</span></span> . get_class() . <span class="hljs-string"><span class="hljs-string">"\""</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberNotFoundException( <span class="hljs-string"><span class="hljs-string">"Property $name is not defined or is not accessible in mixin \""</span></span> . get_class() . <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br><br>  As a small assignment, try to correct such unworthy behavior of our registry class.  Especially since it will lead to the inability to call the public impurity method with a name that has already come across as hidden or protected in another. <br><br>  Um  That's all.  Impurity is ready to use.  The last step remains - the implementation of a platform for mixing in impurities - aggregator classes.  This is what we will do now. <br><br><h1>  We write class aggregator. </h1><br>  What we can class aggregator?  He can keep copies of classes of impurities in himself and call their methods.  Well, to apply to the properties.  We will implement this behavior using the "magic" methods of PHP. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Aggregator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_mixins; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_className; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($aggregatorClassInstance = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className = $aggregatorClassInstance ? get_class($aggregatorClassInstance) : get_class(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); $mixinNames = Registry::getMixinsFor(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($mixinNames <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $mixinName) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_mixins[$mixinName] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $mixinName($aggregatorClassInstance ? $aggregatorClassInstance : <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); } } }</code> </pre><br><br>  In the constructor code, we simply get a list of impurities for the class, then we loop through them and create their instances. <br>  The $ aggregatorClassInstance variable serves to make it unnecessary for us to inherit our class from the Aggregator class.  We can include the Aggregator class in another class and call its constructor with the $ aggregatorClassInstance parameter equal to an instance of this other class.  Accordingly, in this case, we obtain a list of impurities for this class-owner and pass the corresponding instance of the aggregator class to the impurities. <br><br>  If the explanation above seemed too complicated to you - it doesn't matter.  Slide just below, there are examples.  See how the Inheritance example differs from the Composition example and how they work. <br><br>  We implement the "magic methods". <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, array $arguments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_user_func_array(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_mixins[Registry::getMixinNameByMethodName(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className, $name)], $name), $arguments); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_mixins[Registry::getMixinNameByPropertyName(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className, $name)]-&gt;$name; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_mixins[Registry::getMixinNameByPropertyName(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className, $name)]-&gt;$name = $value; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__isset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_mixins[Registry::getMixinNameByPropertyName(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_className, $name)]-&gt;$name); }</code> </pre><br><br>  Each of the magical methods refers to the registry for information.  It's simple. <br><br>  The exception class that we used looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemberNotFoundException</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre><br><br><h1>  Let's look at a few examples. </h1><br><br>  First, the traditional scheme with inheritance: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MixinAggregatorSample</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mixins</span></span></span><span class="hljs-class">\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Aggregator</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MixinHello</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mixins</span></span></span><span class="hljs-class">\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $inaccessible; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $text = <span class="hljs-string"><span class="hljs-string">"I am a text!\r\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> (<span class="hljs-string"><span class="hljs-string">"Hello from mixin!\r\n"</span></span>); } } Mixins\Registry::register(<span class="hljs-string"><span class="hljs-string">"MixinAggregatorSample"</span></span>, <span class="hljs-string"><span class="hljs-string">"MixinHello"</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MixinAggregatorSample(); $a-&gt;hello(); <span class="hljs-comment"><span class="hljs-comment">//Accesing mixed methid echo ($a-&gt;text); //Accessing mixed property $a-&gt;text = "I am also a text!\r\n"; //Setting mixed property //$a-&gt;inaccessible = 'Error here'; //Throws exception //$a-&gt;inaccessible2 = 'Error here'; //Throws yet another exception (Homework: explain, why) echo ($a-&gt;text); var_dump(isset($a-&gt;text));</span></span></code> </pre><br><br>  And now take a look at the inclusion scheme: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MixinAggregatorSample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_aggregator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_aggregator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mixins\Aggregator(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $arguments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_aggregator-&gt;__call($name, $arguments); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MixinHello</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mixins</span></span></span><span class="hljs-class">\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> (<span class="hljs-string"><span class="hljs-string">"Hellp from mixin!"</span></span>); } } Mixins\Registry::register(<span class="hljs-string"><span class="hljs-string">"MixinAggregatorSample"</span></span>, <span class="hljs-string"><span class="hljs-string">"MixinHello"</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MixinAggregatorSample(); $a-&gt;hello();</code> </pre><br><br>  See the difference?  In the case of inclusion, we are free to inherit our class aggregator from any other without losing functionality.  Of course, for its normal use, you will have to implement all the magic methods, and not just __call (). <br><br><h1>  Speed ‚Äã‚Äãperformance </h1><br><br>  I made some measurements of the speed of the resulting library.  The measurements are very approximate, carried out on a home computer with an open IDE, Winamp and everything that is necessary. <br><br><pre> Time native: 0.57831501960754
 Time byname: 1.5227220058441
 Time mixed: 7.5425450801849
 Time reflection: 12.221807956696
</pre><br><br><ul><li>  Native - the time to directly call a class method in PHP </li><li>  Byname - the time to call a class method through the name $ myClass -&gt; $ methodName </li><li>  Mixed - time to call the mixed method </li><li>  Reflection - the time of invoking a mixed method that changes a property of a class through Reflection.  Those.  = mixed + reflection. </li><li>  The time is given in seconds for 800,000 calls. </li></ul><br><br>  I think the figures cited are quite acceptable so that such an approach can be used in a large project.  As a rule, impurity methods are not called thousands of times in a script and 10 microseconds to call a method versus 0.7 microseconds for native methods is an acceptable option.  Especially if you take into account that the time spent on htmlspecialchars (), for example, on a large amount of text or on a query to the database is much higher. <br><br>  Since we use almost everywhere caching based on PHP hashed arrays, as the number of impurities and aggregator classes grows, the speed should not drop much.  However, if someone does the necessary tests, I will be very happy. <br><br><h1>  Epilogue </h1><br>  I am pleased to hear your criticism regarding this article.  I am especially interested in whether I was able to make the material understandable to all readers. <br><br>  Of course, this article does not claim to be complete, accurate or free from errors.  I would be very grateful if you correct me.  I spread the code of the library <a href="http://narod.ru/disk/27133940000/Mixins.rar.html">here</a> .  Of course, the project is an educational project and before using it in a real project it is worthwhile to think well and test everything.  Some problem points like several impurities with the same names of public methods in the same class are present. <br><br>  If the topic of impurities in PHP you are interested in, I suggest also to go through Google. </div><p>Source: <a href="https://habr.com/ru/post/107682/">https://habr.com/ru/post/107682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../107675/index.html">My experience of opening a free hosting</a></li>
<li><a href="../107677/index.html">First look at Activiti</a></li>
<li><a href="../107678/index.html">Book The Art of Unit Testing with Examples in .NET</a></li>
<li><a href="../107679/index.html">Encodings</a></li>
<li><a href="../107680/index.html">Gimpbox - Single Window Gimp</a></li>
<li><a href="../107683/index.html">Forwarding block devices to a XenServer virtual machine</a></li>
<li><a href="../107684/index.html">.Net connector for elFinder file manager</a></li>
<li><a href="../107685/index.html">The algorithm of the user's popularity on the site - ‚ÄúNon-standard approach to standard things‚Äù</a></li>
<li><a href="../107689/index.html">Zend_Acl component update breaks application functionality</a></li>
<li><a href="../107696/index.html">Xperia x10 / x10 mini / x10 mini pro - upgrade from 1.6 to 2.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>