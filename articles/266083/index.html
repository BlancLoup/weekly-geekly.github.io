<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Restriction of memory available to the program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to do something about sorting a million integers with 1 MB of available memory. But before that, I had to think about how you can limit the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Restriction of memory available to the program</h1><div class="post__text post__text-html js-mediator-article">  I decided to do something about sorting a million integers with 1 MB of available memory.  But before that, I had to think about how you can limit the amount of available memory for the program.  And that's what I came up with. <br><br><h4>  Process virtual memory </h4><br>  Before plunging into different methods of memory limitation, you need to know how the virtual memory of the process is organized.  The best article on this topic is <a href="http://habrahabr.ru/post/265509/">‚ÄúAnatomy of a program in memory‚Äù</a> . <br><br>  After reading the article, I can offer two possibilities for limiting memory: to reduce the virtual address space or the volume of the heap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First: a decrease in the amount of address space.  It's pretty simple, but not entirely correct.  We can not reduce the entire space to 1 MB - not enough space for the core and libraries. <br><br>  Second: heap reduction.  It is not so easy to do, and usually nobody does it, because it is only available through fussing with the linker.  But for our task it would be a more correct option. <br><br>  I will also consider other methods, such as tracking memory usage through intercepting library and system calls, and changing the program environment through emulation and sandboxing. <br><br>  For testing, we will use a small program called big_alloc, which places and then releases 100 MiB. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; // 1000   100 KiB = 100 000 KiB = 100 MiB #define NALLOCS 1000 #define ALLOC_SIZE 1024*100 // 100 KiB int main(int argc, const char *argv[]) { int i = 0; int **pp; bool failed = false; pp = malloc(NALLOCS * sizeof(int *)); for(i = 0; i &lt; NALLOCS; i++) { pp[i] = malloc(ALLOC_SIZE); if (!pp[i]) { perror("malloc"); printf("  %d \n", i); failed = true; break; } //     ,   copy-on-write. memset(pp[i], 0xA, 100); printf("pp[%d] = %p\n", i, pp[i]); } if (!failed) printf("  %d \n", NALLOCS * ALLOC_SIZE); for(i = 0; i &lt; NALLOCS; i++) { if (pp[i]) free(pp[i]); } free(pp); return 0; }</span></span></span></span></code> </pre> <br><br>  All source code is on <a href="https://github.com/dzeban/restrict-memory">github</a> . <br><br><h4>  ulimit </h4><br>  What the old unix hacker immediately recalls when he needs to limit memory.  This is a bash utility that allows you to limit program resources.  In fact, this is an interface to setrlimit. <br><br>  We can set a limit on the amount of memory for the program. <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">ulimit</span></span> -m 1024</code> </pre><br><br>  Checking: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">ulimit</span></span> -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 7802 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) 1024 open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 1024 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited</code> </pre><br><br>  We set the limit of 1024 kb - 1 MiB.  But if we try to run the program, it will work without errors.  Despite the limit of 1024 kb, the top shows that the program takes as much as 4872 kb. <br><br>  The reason is that Linux does not set hard limits, and the man says: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">ulimit</span></span> [-HSTabcdefilmnpqrstuvx [<span class="hljs-built_in"><span class="hljs-built_in">limit</span></span>]] ... -m The maximum resident <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> size (many systems <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> not honor this <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span>)</code> </pre><br>  There is also a ulimit -d option that <a href="">should work</a> , but still doesn't work because of mmap (see the linker section). <br><br><h4>  QEMU </h4><br>  QEMU is great for manipulating the software environment.  It has the ‚ÄìR option to limit the virtual address space.  But it cannot be limited to too small values ‚Äã‚Äã- libc and kernel won't fit. <br><br>  Look: <br><br><pre> <code class="bash hljs">$ qemu-i386 -R 1048576 ./big_alloc big_alloc: error <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> loading shared libraries: libc.so.6: failed to map segment from shared object: Cannot allocate memory</code> </pre><br>  Here -R 1048576 leaves 1 MiB to the virtual address space. <br><br>  For this you need to take something about 20 MB.  Here is: <br><br><pre> <code class="bash hljs">$ qemu-i386 -R 20M ./big_alloc malloc: Cannot allocate memory Failed after 100 allocations</code> </pre><br>  Stops after 100 iterations (10 MB). <br><br>  In general, QEMU is still the leader among the methods for limiting it; you just need to play around with the ‚ÄìR value. <br><br><h4>  Container </h4><br>  Another option is to run the program in a container and limit resources.  To do this, you can: <br><ul><li>  use some docker </li><li>  use the usermode tools from the lxc package </li><li>  write your script with libvirt. </li><li>  something else‚Ä¶ </li></ul><br><br>  But resources will be limited by the Linux subsystem called cgroups.  You can play with them directly, but I recommend through lxc.  I would like to use docker, but it only works on 64-bit machines. <br><br>  LXC is the LinuX Containers.  This is a set of tools and libraries from userspace for managing kernel functions and creating containers ‚Äî isolated secure environments for applications, or for the entire system. <br><br>  The kernel functions are as follows: <br><ul><li>  Control groups (cgroups) </li><li>  Kernel namespaces </li><li>  chroot </li><li>  Kernel capabilities </li><li>  SELinux, AppArmor </li><li>  Seccomp policies </li></ul><br><br>  Documentation can be found on the <a href="https://linuxcontainers.org/">site</a> or in the <a href="https://www.stgraber.org/2013/12/20/lxc-1-0-blog-post-series/">author's blog</a> . <br><br>  To run an application in a container, you must provide lxc-execute config, where you specify all the settings of the container.  You can start with examples in / usr / share / doc / lxc / examples.  Man recommends starting with lxc-macvlan.conf.  Let's start: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cp /usr/share/doc/lxc/examples/lxc-macvlan.conf lxc-my.conf # lxc-execute -n foo -f ./lxc-my.conf ./big_alloc Successfully allocated 102400000 bytes</span></span></code> </pre><br><br>  Works! <br><br>  Now let's limit the memory with cgroup.  LXC allows you to configure a memory subsystem for a cgroup container, setting memory limits.  Parameters can be found in the <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/sec-memory.html">RedHat documentation</a> .  I found 2: <br><br><ul><li>  memory.limit_in_bytes - sets the maximum amount of user memory, including the file cache </li><li>  memory.memsw.limit_in_bytes - sets the maximum amount in the sum of memory and swap </li></ul><br>  What I added to lxc-my.conf: <br><br><pre> <code class="bash hljs">lxc.cgroup.memory.limit_in_bytes = 2M lxc.cgroup.memory.memsw.limit_in_bytes = 2M</code> </pre><br>  Run: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># lxc-execute -n foo -f ./lxc-my.conf ./big_alloc #</span></span></code> </pre><br>  Silence - apparently, the memory is too little.  Let's try to run from the shell <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># lxc-execute -n foo -f ./lxc-my.conf /bin/bash #</span></span></code> </pre><br>  bash did not start.  Let's try / bin / sh: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># lxc-execute -n foo -f ./lxc-my.conf -l DEBUG -o log /bin/sh sh-4.2# ./dev/big_alloc/big_alloc Killed</span></span></code> </pre><br>  And in the dmesg you can track the glorious death process: <br><br><pre> <code class="bash hljs">[15447.035569] big_alloc invoked oom-killer: gfp_mask=0xd0, order=0, oom_score_adj=0 ... [15447.035779] Task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /lxc/foo [15447.035785] killed as a result of <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> of [15447.035789] /lxc/foo [15447.035795] memory: usage 3072kB, <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> 3072kB, failcnt 127 [15447.035800] memory+swap: usage 3072kB, <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> 3072kB, failcnt 0 [15447.035805] kmem: usage 0kB, <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> 18014398509481983kB, failcnt 0 [15447.035808] Memory cgroup stats <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> /lxc/foo: cache:32KB rss:3040KB rss_huge:0KB mapped_file:0KB writeback:0KB swap:0KB inactive_anon:1588KB active_anon:1448KB inactive_file:16KB active_file:16KB unevictable:0KB [15447.035836] [ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name [15447.035963] [ 9225] 0 9225 942 308 10 0 0 init.lxc [15447.035971] [ 9228] 0 9228 833 698 6 0 0 sh [15447.035978] [ 9252] 0 9252 16106 843 36 0 0 big_alloc [15447.035983] Memory cgroup out of memory: Kill process 9252 (big_alloc) score 1110 or sacrifice child [15447.035990] Killed process 9252 (big_alloc) total-vm:64424kB, anon-rss:2396kB, file-rss:976kB</code> </pre><br>  Although we did not receive an error message from big_alloc about malloc failure and the amount of available memory, it seems to me that we successfully limited the memory with the help of containers.  For now let's stop on this. <br><br><h4>  Linker </h4><br>  Let's try to change the binary image, limiting the available heap space.  Layout - the last step in building the program.  To do this, use the linker and its script.  Script - the description of sections of the program in memory, along with all sorts of attributes and other things. <br><br>  Layout script example: <br><br><pre> <code class="cpp hljs">ENTRY(main) SECTIONS { . = <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; .text : { *(.text) } . = <span class="hljs-number"><span class="hljs-number">0x8000000</span></span>; .data : { *(.data) } .bss : { *(.bss) } }</code> </pre><br>  Point means current position.  For example, the .text section starts at 0 √ó 10,000, and then, starting at 0 √ó 8000000, we have the following two sections: .data and .bss.  The entry point is main. <br><br>  Everything is cool, but it won't work in real programs.  The main function, which you write in C programs, is not really the first to be called.  First a lot of initializations and erasures are done.  This code is contained in the C runtime (crt) library and distributed among the crt # .o libraries in / usr / lib. <br><br>  Details can be seen by running gcc ‚Äìv.  First, it calls ccl, creates an assembler code, translates it into an object file via as, and finally collects everything together with ELF using collect2.  collect2 - ld wrapper.  It accepts an object file and 5 additional libraries to create the final binary image: <br><br><pre> <code class="bash hljs"> /usr/lib/gcc/i686-redhat-linux/4.8.3/./././crt1.o /usr/lib/gcc/i686-redhat-linux/4.8.3/./././crti.o /usr/lib/gcc/i686-redhat-linux/4.8.3/crtbegin.o /tmp/ccEZwSgF.o &lt;-     /usr/lib/gcc/i686-redhat-linux/4.8.3/crtend.o /usr/lib/gcc/i686-redhat-linux/4.8.3/./././crtn.o</code> </pre><br>  All this is very difficult, so instead of writing my own script, I will edit the linker script by default.  Get it by passing -Wl, -verbose to gcc: <br><br><pre> <code class="bash hljs">gcc big_alloc.c -o big_alloc -Wl,-verbose</code> </pre><br>  Now we will think how to change it.  Let's see how the binary is built by default.  Let's compile and look for the address of the .data section.  Here is the output of objdump -h big_alloc <br><br><pre> <code class="bash hljs">Sections: Idx Name Size VMA LMA File off Algn ... 12 .text 000002e4 080483e0 080483e0 000003e0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE ... 23 .data 00000004 0804a028 0804a028 00001028 2**2 CONTENTS, ALLOC, LOAD, DATA 24 .bss 00000004 0804a02c 0804a02c 0000102c 2**2 ALLOC</code> </pre><br>  The .text, .data and .bss sections are located around 128 MiB. <br><br>  Let's see where the stack is with gdb: <br><br><pre> <code class="bash hljs">[restrict-memory]$ gdb big_alloc ... Reading symbols from big_alloc...done. (gdb) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> main Breakpoint 1 at 0x80484fa: file big_alloc.c, line 12. (gdb) r Starting program: /home/avd/dev/restrict-memory/big_alloc Breakpoint 1, main (argc=1, argv=0xbffff164) at big_alloc.c:12 12 int i = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.18-16.fc20.i686 (gdb) info registers eax 0x1 1 ecx 0x9a8fc98f -1701852785 edx 0xbffff0f4 -1073745676 ebx 0x42427000 1111650304 esp 0xbffff0a0 0xbffff0a0 ebp 0xbffff0c8 0xbffff0c8 esi 0x0 0 edi 0x0 0 eip 0x80484fa 0x80484fa &lt;main+10&gt; eflags 0x286 [ PF SF IF ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51</code> </pre><br>  esp indicates 0xbffff0a0, which is about 3 GiB.  So we have a bunch of ~ 2.9 GiB. <br><br>  In the real world, the top address of the stack is random, it can be seen, for example, in the output: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /proc/self/maps</span></span></code> </pre><br>  As we know, the heap grows from the end of .data towards the stack.  What if we move the .data section as high as possible? <br><br>  Let's place a data segment in 2 MiB in front of the stack.  We take the top of the stack, subtract 2 MiB: <br><br>  0xbffff0a0 - 0x200000 = 0xbfdff0a0 <br><br>  Shift all sections starting with .data to this address: <br><br><pre> <code class="cpp hljs">. = <span class="hljs-number"><span class="hljs-number">0xbfdff0a0</span></span> .data : { *(.data .data.* .gnu.linkonce.d.*) SORT(CONSTRUCTORS) }</code> </pre><br>  Compile: <br><br><pre> <code class="bash hljs">$ gcc big_alloc.c -o big_alloc -Wl,-T hack.lst</code> </pre><br>  The -Wl and -T hack.lst options tell the linker to use hack.lst as a work script. <br><br>  Look at the title: <br><br><pre> <code class="bash hljs">: Idx Name Size VMA LMA File off Algn ... 23 .data 00000004 bfdff0a0 bfdff0a0 000010a0 2**2 CONTENTS, ALLOC, LOAD, DATA 24 .bss 00000004 bfdff0a4 bfdff0a4 000010a4 2**2 ALLOC</code> </pre><br>  Still, the data is stored in memory.  How?  When I tried to look at the values ‚Äã‚Äãof the pointers returned by malloc, I saw that the placement starts somewhere after the end of the section. Data at addresses like 0xbf8b7000, gradually continues with increasing pointers, and then returns to lower addresses like 0xb5e76000.  It looks like the pile is growing down. <br><br>  If you think, nothing strange about it.  I checked the glibc source and found out that when brk fails, mmap is used.  This means that glibc asks the kernel to place pages, the kernel sees that the process has a lot of holes in virtual memory, and places a page in one of the empty spaces, after which glibc returns a pointer from it. <br><br>  Running big_alloc under strace confirmed the theory.  Look at the normal binary: <br><br><pre> <code class="bash hljs">brk(0) = 0x8135000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77df000 mmap2(NULL, 95800, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb77c7000 mmap2(0x4226d000, 1825436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x4226d000 mmap2(0x42425000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b8000) = 0x42425000 mmap2(0x42428000, 10908, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x42428000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77c6000 mprotect(0x42425000, 8192, PROT_READ) = 0 mprotect(0x8049000, 4096, PROT_READ) = 0 mprotect(0x42269000, 4096, PROT_READ) = 0 munmap(0xb77c7000, 95800) = 0 brk(0) = 0x8135000 brk(0x8156000) = 0x8156000 brk(0) = 0x8156000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77de000 brk(0) = 0x8156000 brk(0x8188000) = 0x8188000 brk(0) = 0x8188000 brk(0x81ba000) = 0x81ba000 brk(0) = 0x81ba000 brk(0x81ec000) = 0x81ec000 ... brk(0) = 0x9c19000 brk(0x9c4b000) = 0x9c4b000 brk(0) = 0x9c4b000 brk(0x9c7d000) = 0x9c7d000 brk(0) = 0x9c7d000 brk(0x9caf000) = 0x9caf000 ... brk(0) = 0xe29c000 brk(0xe2ce000) = 0xe2ce000 brk(0) = 0xe2ce000 brk(0xe300000) = 0xe300000 brk(0) = 0xe300000 brk(0) = 0xe300000 brk(0x8156000) = 0x8156000 brk(0) = 0x8156000 +++ exited with 0 +++</code> </pre><br>  And now on the modified: <br><br><pre> <code class="bash hljs">brk(0) = 0xbf896000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb778f000 mmap2(NULL, 95800, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7777000 mmap2(0x4226d000, 1825436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x4226d000 mmap2(0x42425000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b8000) = 0x42425000 mmap2(0x42428000, 10908, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x42428000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7776000 mprotect(0x42425000, 8192, PROT_READ) = 0 mprotect(0x8049000, 4096, PROT_READ) = 0 mprotect(0x42269000, 4096, PROT_READ) = 0 munmap(0xb7777000, 95800) = 0 brk(0) = 0xbf896000 brk(0xbf8b7000) = 0xbf8b7000 brk(0) = 0xbf8b7000 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb778e000 brk(0) = 0xbf8b7000 brk(0xbf8e9000) = 0xbf8e9000 brk(0) = 0xbf8e9000 brk(0xbf91b000) = 0xbf91b000 brk(0) = 0xbf91b000 brk(0xbf94d000) = 0xbf94d000 brk(0) = 0xbf94d000 brk(0xbf97f000) = 0xbf97f000 ... brk(0) = 0xbff8e000 brk(0xbffc0000) = 0xbffc0000 brk(0) = 0xbffc0000 brk(0xbfff2000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7676000 brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7576000 brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7476000 brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7376000 ... brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb1c76000 brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb1b76000 brk(0) = 0xbffc0000 brk(0xbfffa000) = 0xbffc0000 mmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb1a76000 brk(0) = 0xbffc0000 brk(0) = 0xbffc0000 brk(0) = 0xbffc0000 ... brk(0) = 0xbffc0000 brk(0) = 0xbffc0000 brk(0) = 0xbffc0000 +++ exited with 0 +++</code> </pre><br>  Shifting the .data section to the stack in order to reduce heap space does not make sense, since the kernel will place the page in empty space. <br><br><h4>  Sandbox </h4><br>  Another way to limit the program's memory is sandboxing.  The difference from emulation is that we do not emulate anything, but simply track and control some things in the behavior of the program.  Usually used in security research, when you isolate a malware and analyze it so that it does not harm your system. <br><br><h5>  Trick with LD_PRELOAD </h5><br>  LD_PRELOAD is a special environment variable forcing the dynamic linker to use preloaded libraries in priority, incl.  libc.  This trick, by the way, is also used by <a href="http://blog.malwaremustdie.org/2014/05/elf-shared-so-dynamic-library-malware.html">some malware</a> . <br><br>  I wrote a simple sandbox that intercepts malloc / free calls, works with memory, and returns ENOMEM when the limit is reached. <br><br>  To do this, I made a shared library with my implementations around malloc / free, increasing the counter by the amount of malloc, and decreasing when free is called.  It is preloaded via LD_PRELOAD. <br><br>  My implementation of malloc is: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *p = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (libc_malloc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) save_libc_malloc(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem_allocated &lt;= MEM_THRESHOLD) { p = libc_malloc(size); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { errno = ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!no_hook) { no_hook = <span class="hljs-number"><span class="hljs-number">1</span></span>; account(p, size); no_hook = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre><br>  libc_malloc is a pointer to the original malc from libc.  no_hook local flag in the stream.  Used to enable malloc in hooks and to avoid recursive calls. <br><br>  malloc is used implicitly in the account function by the <a href="http://troydhanson.github.io/uthash/">uthash</a> library.  Why use a hash table?  Because when you call free, you only pass a pointer to it, and inside free it is not known how much memory was allocated.  Therefore, you have a table with pointers-keys and the amount of memory allocated as values.  This is what I do in malloc: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">malloc_item</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">;</span></span> item = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*item)); item-&gt;p = ptr; item-&gt;size = size; HASH_ADD_PTR(HT, p, item); mem_allocated += size; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Alloc: %p -&gt; %zu\n"</span></span>, ptr, size);</code> </pre><br>  mem_allocated is a static variable that is compared to a constraint in malloc. <br><br>  Now when you call free, the following happens: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">malloc_item</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">found</span></span></span><span class="hljs-class">;</span></span> HASH_FIND_PTR(HT, &amp;ptr, found); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (found) { mem_allocated -= found-&gt;size; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Free: %p -&gt; %zu\n"</span></span>, found-&gt;p, found-&gt;size); HASH_DEL(HT, found); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(found); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Freeing unaccounted allocation %p\n"</span></span>, ptr); }</code> </pre><br>  Yes, just reduce mem_allocated. <br><br>  And the coolest thing is that it works. <br><br><pre> <code class="bash hljs">[restrict-memory]$ LD_PRELOAD=./libmemrestrict.so ./big_alloc pp[0] = 0x25ac210 pp[1] = 0x25c5270 pp[2] = 0x25de2d0 pp[3] = 0x25f7330 pp[4] = 0x2610390 pp[5] = 0x26293f0 pp[6] = 0x2642450 pp[7] = 0x265b4b0 pp[8] = 0x2674510 pp[9] = 0x268d570 pp[10] = 0x26a65d0 pp[11] = 0x26bf630 pp[12] = 0x26d8690 pp[13] = 0x26f16f0 pp[14] = 0x270a750 pp[15] = 0x27237b0 pp[16] = 0x273c810 pp[17] = 0x2755870 pp[18] = 0x276e8d0 pp[19] = 0x2787930 pp[20] = 0x27a0990 malloc: Cannot allocate memory Failed after 21 allocations</code> </pre><br>  Full library code on <a href="">github</a> <br><br>  It turns out that LD_PRELOAD is a great way to limit memory. <br><br><h5>  ptrace </h5><br>  ptrace is another opportunity to build a sandbox.  This is a system call allowing you to control the execution of another process.  Built into various POSIX OS. <br><br>  This is the basis of such tracers as strace, ltrace, and almost all sandboxing programs - systrace, sydbox, mbox and debuggers, including gdb. <br><br>  I made my tool with ptrace.  It tracks the calls to brk and measures the distance between the initial break value and the new one, which is set by the next call to brk. <br><br>  The program forks and runs 2 processes.  The parent is the tracer, and the child is the tracer.  In the child process, I call ptrace (PTRACE_TRACEME) and then execv.  In the parent, I use ptrace (PTRACE_SYSCALL) to stop at syscall and filter out calls to brk from the child, and then another ptrace (PTRACE_SYSCALL) to get the value returned by brk. <br><br>  When brk is outside the specified value, I set -ENOMEM as the return value for brk.  This is set in the eax register, so I just overwrite it with ptrace (PTRACE_SETREGS).  Here is the tastiest part: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    if (!syscall_trace(pid, &amp;state)) { dbg("brk return: 0x%08X, brk_start 0x%08X\n", state.eax, brk_start); if (brk_start) // We have start of brk { diff = state.eax - brk_start; //      //    brk  -ENOMEM if (diff &gt; THRESHOLD || threshold) { dbg("THRESHOLD!\n"); threshold = true; state.eax = -ENOMEM; ptrace(PTRACE_SETREGS, pid, 0, &amp;state); } else { dbg("diff 0x%08X\n", diff); } } else { dbg("Assigning 0x%08X to brk_start\n", state.eax); brk_start = state.eax; } }</span></span></code> </pre><br>  I also intercept calls to mmap / mmap2, since libc has enough brains to call them when there are problems with brk.  So when the specified value is exceeded and I see a call to mmap, I break it off with ENOMEM. <br><br>  Works! <br><br><pre> <code class="bash hljs">[restrict-memory]$ ./ptrace-restrict ./big_alloc pp[0] = 0x8958fb0 pp[1] = 0x8971fb8 pp[2] = 0x898afc0 pp[3] = 0x89a3fc8 pp[4] = 0x89bcfd0 pp[5] = 0x89d5fd8 pp[6] = 0x89eefe0 pp[7] = 0x8a07fe8 pp[8] = 0x8a20ff0 pp[9] = 0x8a39ff8 pp[10] = 0x8a53000 pp[11] = 0x8a6c008 pp[12] = 0x8a85010 pp[13] = 0x8a9e018 pp[14] = 0x8ab7020 pp[15] = 0x8ad0028 pp[16] = 0x8ae9030 pp[17] = 0x8b02038 pp[18] = 0x8b1b040 pp[19] = 0x8b34048 pp[20] = 0x8b4d050 malloc: Cannot allocate memory Failed after 21 allocations</code> </pre><br>  But I do not like it.  This is tied to the ABI, i.e.  here you have to use rax instead of eax on a 64-bit machine, so you should either make a separate version, or use #ifdef, or use the -m32 option option.  And most likely it will not work on other POSIX-like systems that may have a different ABI. <br><br><h4>  Other ways </h4><br>  What else can you try (these options were rejected for various reasons): <br><br><ul><li>  <a href="http://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html">malloc hooks</a>  In man it is written that they are no longer supported. </li><li>  <a href="http://man7.org/linux/man-pages/man2/prctl.2.html">Seccomp and prctl</a> with PR_SET_MM_START_BRK.  It may work - but, as stated in the <a href="http://lxr.free-electrons.com/source/Documentation/prctl/seccomp_filter.txt">documentation</a> , this is not a sandbox, but a way to minimize the accessible surface of the kernel.  That is, it will be even more crooked than using manual ptrace </li><li>  <a href="http://sandbox.libvirt.org/quickstart/">libvirt-sandbox</a> .  Just a wrapper for lxc and qemu. </li><li>  <a href="http://linux.die.net/man/8/sandbox">SELinux sandbox</a> .  It does not work, because it uses cgroup. </li></ul><br><h4>  Links </h4><br><ul><li>  <a href="http://habrahabr.ru/post/265509/">Article by Gustavo Duarte</a> </li><li>  <a href="http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/40">Limiting time and memory consumption of a program in Linux</a> . </li><li>  <a href="http://stackoverflow.com/questions/4249063/run-an-untrusted-c-program-in-a-sandbox-in-linux-that-prevents-it-from-opening-f">Linux sandboxing</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/266083/">https://habr.com/ru/post/266083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266073/index.html">Emacs: we train the cursor (continuation)</a></li>
<li><a href="../266075/index.html">A simple rotary encoder driver for Qt4 Embedded under Linux</a></li>
<li><a href="../266077/index.html">Analysis of one of the VaultCrypt encryption modifications</a></li>
<li><a href="../266079/index.html">‚ÄúFortran - Alive and Alive‚Äù or ‚ÄúWhat‚Äôs new ifort‚Äôs grandfather‚Äù</a></li>
<li><a href="../266081/index.html">In the footsteps of Meteor, or cycling reactivity</a></li>
<li><a href="../266085/index.html">We build real-time web applications with RethinkDB</a></li>
<li><a href="../266087/index.html">Broadband Method (Class Library)</a></li>
<li><a href="../266089/index.html">Linux container developers meeting</a></li>
<li><a href="../266091/index.html">We integrate Paypal payment into web-application</a></li>
<li><a href="../266093/index.html">Healthcare IT: or how to exceed the budget by 420%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>