<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Death of microservice madness in 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : This material, written by an experienced developer, is not intended to bury the idea of ‚Äã‚Äãmicroservices, as you might think, looking at ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Death of microservice madness in 2018</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: This material, written by an experienced developer, is not intended to bury the idea of ‚Äã‚Äãmicroservices, as you might think, looking at the title.</i>  <i>The article is a reasonable warning for those who decided that microservices are a ‚Äúsilver bullet‚Äù, which in itself solves all architectural and operational problems.</i>  <i>To demonstrate this, the author has collected and systematized popular problems that are often found in today's projects that already use microservices or migrate to them.</i> <br><br><img src="https://habrastorage.org/webt/-0/t1/l0/-0t1l0j7yjj4y-ysaqxqu5no3my.png"><br><br>  In recent years, microservices have become a very popular topic.  "Microservice madness" looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  ‚ÄúNetflix is ‚Äã‚Äãgood at DevOps.  Netflix make microservices.  So, if I do microservices, I'm good at DevOps. ‚Äù </blockquote><a name="habracut"></a><br>  There are a lot of cases when significant efforts were made to introduce microservice patterns without necessarily understanding what disadvantages and advantages this will lead to in the context of the specific problem being solved. <br><br>  I will tell in detail about what microservices are, why their pattern is so attractive and what are some of the main difficulties in the way of their use.  I will finish with simple questions that you should ask yourself when the relevance of the microservice pattern for <i>your</i> needs is considered.  These questions are presented at the end of the article. <br><br><h2>  What are microservices and why are they so popular? </h2><br>  Let's start with the basics.  Here is an example of a possible implementation of a hypothetical video sharing platform: first in a monolithic representation (one large block), and then in a microservice. <br><br><img src="https://habrastorage.org/webt/98/ya/fp/98yafp4gof8n6vdmpjplinrbwvk.png"><br><br>  The difference between these two systems is that the first is a single large block, i.e.  monolith.  The second is a set of small specific services.  Each service has its own specific role. <br><br>  When the scheme is presented at this level of detail, it is easy to see its appeal.  There is a whole set of potential advantages: <br><br>  <b>Independent development</b> .  Small independent components can be created by small independent teams.  The group can work on changes in the <i>Upload</i> service without affecting the <i>Transcode</i> service or even knowing about it.  The amount of time required to study a component is significantly reduced, and it becomes easier to develop new functions. <br><br>  <b>Independent deployment</b> .  Every single component can be deployed independently.  This allows you to release new features quickly and with less risk.  Corrections or features for the <i>Streaming</i> component can be deployed without the need to add other components. <br><br>  <b>Independent scalability</b> .  Each component can be scaled independently of the other.  In times of increased user demand, when new broadcasts come out, the <i>Download</i> component can be scaled for increased load without the need to scale each component, which makes scaling flexible and reduces costs. <br><br>  <b>Reusability</b> .  Components realize their small specific function.  This means that it is easier to adapt them for use in other systems, services or products.  The <i>Transcode</i> component can be used by other business units or even turned into a new business offering transcoding services to a different audience. <br><br>  <i>At this level of</i> detail, the advantages of the microservice model over the monolithic seem obvious.  If so, then why did the pattern come into fashion only now?  Where has he been all my life? <br><br><h2>  If everything is so great, then why hasn't anyone done it before? </h2><br>  There are two answers to this question.  The first - <i>actually did</i> , to the best of technical capabilities.  Second - recent technological improvements have allowed us to reach a new level in this approach. <br><br>  When I started preparing an answer to this question, I got a <i>long</i> description, so I‚Äôll better highlight it in a separate article and post it a little later.  Here, the path from one program to the set, ESB <i>(enterprise service bus, i.e. "enterprise service bus" - approx. Transl.)</i> And SOA <i>(service-oriented architecture, i.e. "service-oriented architecture"</i> <i>)</i> will be omitted <i>. - approx. Transl.</i> , Component design and bounded contexts <i>("limited context" - pattern from Domain-Driven Design - approx. Transl.)</i> , Etc. <br><br>  Instead, I‚Äôll write that in many ways we‚Äôve done it all for a while, but only with the recent explosive growth of container technologies (especially Docker) and orchestration technologies (such as Kubernetes, Mesos, Consul, etc.) the pattern has become much more expedient to implement from a technical point of view. <br><br>  If we take for granted the <i>possibility of</i> implementing a microservice approach, it is necessary to carefully consider the <i>need</i> .  We saw high-level theoretical advantages, but what about the difficulties? <br><br><h2>  What is the problem of microservices? </h2><br>  If microservices are so beautiful, what's the matter?  Here are some of the most significant problems that I have seen. <br><br><h3>  Increased complexity for developers </h3><br>  Developing life <i>can</i> be much harder.  If a developer wants to work on features that affect many <i>[journey]</i> services, he will have to run all of them on his machine and connect to them.  This is often more difficult than just running one program. <br><br>  This complexity can be partially alleviated with the help of appropriate tools <i>[tooling]</i> , but the greater the number of services that make up the system, the more difficulties developers will have when starting the system as a whole. <br><br><h3>  Increased complexity for operation </h3><br>  For teams that do not develop services, but support them, there will be an explosion in potential complexity.  Instead of managing several running services, they will have to work with tens, hundreds, or thousands.  More services, more ways to interact and more opportunities for potential problems. <br><br><h3>  Increased difficulty for DevOps </h3><br>  Looking at the two previous points, it may seem - especially because of the popularity of DevOps as a practice (of which I am a big supporter) - that exploitation and development are considered separately.  So, isn‚Äôt it getting better thanks to DevOps? <br><br>  The difficulty is that many organizations still have separate development and operation teams, and in such cases they are likely to have a hard time adapting microservices. <br><br>  For organizations already using DevOps, this is also not so simple.  Being at the same time a developer and a sysadmin is already difficult (but critical for creating good software), and with the need to also understand the nuances of container orchestration systems and, in particular, systems that are rapidly evolving, even harder.  So I come to the next item. <br><br><h3>  Requires serious competence </h3><br>  The results can be great if the work was done by experts.  But imagine an organization in which not everything is perfect with the work of a single monolithic system.  Why, with an increase in the number of systems, which complicates the operation, the situation will become better? <br><br>  Yes, with efficient automation, monitoring, orchestration, etc.  - all this is possible.  However, complexity is rarely a technology - usually this is a search for people who can use it effectively.  The demand for such skills is huge now, and finding them is not easy. <br><br><h3>  Real systems usually do not have clearly defined boundaries. </h3><br>  In all the examples used to describe the benefits of microservices, it was about independent components.  However, in many cases, the components are not simply independent.  If on paper certain areas may look related, then in reality, when you get to the bottom of all the details, it is easy to find that everything is much more complicated than in the intended model. <br><br>  This is where everything becomes very complicated.  If the boundaries are not really well defined, it will happen that - even in the case of the theoretical possibility of an isolated deployment of services - interdependencies will emerge between the services, due to which the sets of services will have to be deployed as a group. <br><br>  In turn, this means that it is necessary to maintain consistent versions of services that have been tested and tested in working with each other.  It turns out that there is actually no system, parts of which can be deployed independently, because deploying a new feature will have to carefully manage the deployment of multiple services. <br><br><h3>  Stateful difficulties are often ignored. </h3><br>  In the previous example, the occasional need for a simultaneous rollout of multiple versions of multiple services during a delay feature is mentioned.  I would like to say that thoughtful deployment techniques will make life easier: for example, blue-green <i>deployments</i> (require minimal effort on most platforms for service orchestration) or parallel launch of multiple versions of a service with the possibility of choosing the right one on the side of their user. <br><br>  These techniques remove many obstacles if the services are stateless.  But working with stateless services is actually quite simple.  Actually, if you have stateless-services, I recommend thinking about skipping all these microservices and using the serverless model. <br><br>  In reality, many services need to store the state.  An example for a video sharing platform is a subscription service.  Let the new version of the subscription service stores data in the database of a new type.  If both services are running in parallel, then you have a system that simultaneously uses two schemes.  If you make a blue-green patch, and other services depend on data in a new form, they need to be updated at the same time.  If the subscription service has failed and is rolled back, then most likely it is necessary to roll back these services too, and then ‚Äúby the cascade‚Äù. <br><br>  Again, it is tempting to think that such schema-related problems will go away with databases from the world of NoSQL, but this is not the case.  Databases that do not require strict schemas do not mean that the system does not have schemas, because in essence it simply means the need to manage the schema at the application level, not at the DBMS level.  It is impossible to eradicate the fundamental problem of understanding the type of your data and how it changes. <br><br><h3>  Interaction difficulties are often ignored. </h3><br>  Since you are creating a large network of services dependent on each other, a large field for interservice interaction is likely to appear.  There are a number of difficulties.  First, there are more places for potential failures.  It is necessary to foresee the possibility that network calls will not work, that is, each time one service accesses another, it must at least try to repeat its attempts.  When the service needs to address a variety of services, the situation will become more complicated. <br><br>  Imagine that a user uploads a video to a sharing service.  We need to start the download service, transfer the data to the transcoding service, update the subscriptions, update the recommendations, and so on.  All of these challenges require a certain orchestration, and if something breaks, the action must be repeated. <br><br>  Repeat calls can be difficult to manage.  Attempts to do everything synchronously often become untenable, because they have too many points of failure.  In this case, a more reliable solution will be the use of asynchronous interaction patterns.  But the difficulty lies in the fact that due to asynchronous patterns, the system becomes stateful.  And as already mentioned in the last paragraph, it is very difficult to manage stateful-systems and systems with distributed states. <br><br>  When a message queue for inter-service communication is used in a microservice system, you basically have a large database (message queue or broker) that sticks together all the services.  Again, even though all this does not seem to be a problem at first, the circuit will catch up with you and remind you of yourself.  Service version X can write messages in a specific format, so services that depend on such a message also need to be updated when the sender service changes something in its message. <br><br>  You can have services that process messages in many different formats, but they are difficult to manage.  When deploying new versions of services, it will happen that two versions of the service will try to process messages from the same queue and, possibly, even from the sending services of different versions too.  This can lead to confusing, inadequate situations.  It may turn out that in order to avoid them it is easier to allow only certain versions of messages to exist: this means that you have to deploy consistent sets of versions for sets of services, ensuring that messages of old versions are processed appropriately (first). <br><br>  This again confirms the idea that, if we go into details, independent deployments do not always work as intended. <br><br><h3>  Versioning can be tricky </h3><br>  To overcome the mentioned obstacles, it is necessary to manage versions very carefully.  Again, there is a tendency to believe that following a standard like <a href="https://semver.org/">semver</a> will solve the problem.  This is not true.  Semver is an agreement that is advisable to use, but you still have to keep track of the versions of services and APIs that can interact. <br><br>  Very quickly, you can come to significant difficulties and find yourself in a situation where you do not know which versions of the services actually work correctly with each other. <br><br>  It is well known how hard it is to manage dependencies in software systems, whether they are modules for Node or Java, libraries for C, etc.  It is very difficult to deal with the problems of conflicts of independent components used by one entity. <br><br>  It is difficult to cope with these problems when dependencies are static and can be patched, updated, edited, and so on.  If the working services serve as dependencies, it will not be possible to simply update them: you need to run several versions (with the problems described above) or pause the system until everything is completely fixed. <br><br><h3>  Distributed transactions </h3><br>  In situations where transactional integrity is required during operation, microservices can be a big pain.  It‚Äôs not easy to work with a distributed state, and the multitude of small components that can break make transaction orchestration really hard. <br><br>  It may seem attractive to try to avoid problems by making the operations idempotent, suggesting retry mechanisms, etc.  - and in many cases it will work.  However, there may be scenarios in which a successful or unsuccessful transaction is simply needed, without an intermediate state.  The complexity of the workaround for this task or its implementation in the microservice model can be very high. <br><br><h3>  Microservices can be disguised monoliths </h3><br>  Yes, individual services and components can be deployed in isolation, but in most cases some kind of orchestration platform like Kubernetes will be launched.  If you use a managed service like <a href="https://cloud.google.com/kubernetes-engine/">GKE</a> from Google or <a href="https://aws.amazon.com/eks/">EKS</a> from Amazon, most of the cluster management has been solved for you. <br><br>  However, if you manage the cluster yourself, then you are working with a large, complex and critical system.  Although individual services may have all the advantages described above, it is necessary to manage the cluster very thoughtfully.  Deploying such a system can be tricky, upgrades are tricky, failover is tricky, and so on. <br><br>  In many cases, the overall benefits remain, but it is important not to simplify or underestimate the additional complexity caused by managing another large and complex system.  Managed services can help, but they are often too young (for example, Amazon EKS was announced only at the end of 2017). <br><br><h2>  Death of microservice madness! </h2><br>  Avoid madness by making prudent and thoughtful decisions.  And to help with this, I prepared several questions that you can ask yourself, and explanations for the answers to them.  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: The original <a href="">image is</a> translated and presented in text below.</i> <br><br><h3>  1. Team size </h3><br>  Is it possible to seat your whole team at one big table? <br><br><ul><li>  <b>Yes!</b>  Perhaps microservices are not needed yet.  The difficulties associated with deployment, development, operation, etc., are probably easily solved with the help of <b>good communications</b> and <b>good architecture</b> , and microservices can be a solution to a problem that you don‚Äôt have. </li><li>  <b>Not!</b>  Microservices can help.  If you have a large team or several teams, it may be difficult to strictly define the boundaries of components using only one architecture.  Extracting components into isolated services can help in implementing these boundaries. </li></ul><br><h3>  2. Stateless / stateful </h3><br>  Is your system primarily stateless? <br><br><ul><li>  <b>Yes!</b>  Consider serverless.  If your system is basically stateless, you can probably skip the microservice step and go straight to serverless ‚Äî at least partially. </li><li>  <b>Not!</b>  Microservices will bring complexity.  This does not mean that you should not use microservices, but remember that it is not easy to implement and manage them - especially because the <b>system changes over time</b> . </li></ul><br><h3>  3. "Users" of the system </h3><br>  Are you building a solution for a single application or service? <br><br><ul><li>  <b>Yes!</b>  Be careful - there may be ‚Äúblurry‚Äù subject areas.  If everything you build is intended for the same user application, it may become clear that building features will require the simultaneous updating of multiple services.  Microservices may be appropriate, but be very careful with the design of subject areas. </li><li>  <b>Not!</b>  Microservices can be very useful.  If you design a system that will be used by different applications, microservices can be a very appropriate pattern to quickly deliver new features to new ‚Äúuser‚Äù applications. </li></ul><br><h3>  4. Dependencies </h3><br>  Do you have a solid dependency? <br><br><ul><li>  <b>Yes!</b>  Performance can cause problems.  In this case, independently scalable services are unlikely to help, because the effect of dependency performance remains.  It turns out that one of the main advantages will not be relevant.  In addition, the boundaries of your services may be worse defined. </li><li>  <b>Not!</b>  Microservices can be very useful.  If the monoliths do not pull you to the bottom, you may be able to achieve the high level of independence required to effectively scale up microservices. </li></ul><br><h3>  5. Competence </h3><br>  Do you have any experts in container, orchestration, DevOps? <br><br><ul><li>  <b>Yes!</b>  Microservices can be very useful.  If you have the appropriate frames, you should study microservices.  Existing skills will deal with potential difficulties and take advantage. </li><li>  <b>Not!</b>  Test the ground first!  In the absence of due competence or in the case of existing difficulties with DevOps, you can jump over your head.  Consider adapting one simple service as proof of concept.  Get the first experience you need on projects that are not critical for business. </li></ul><br>  Download the original PDF with all questions and answers <i>(in English)</i> <a href="https://github.com/dwmkerr/blog/raw/master/2018/microservice-madness/images/microservice-questions.pdf">here</a> . <br><br><h2>  Last thoughts: do not confuse microservices with architecture </h2><br>  I intentionally avoided the word ‚Äúa‚Äù in this article.  But my friend <a href="https:/twitter.com/zoltanarvai">Zoltan</a> , checking it, made a very good comment. <br><br>  Microservice architecture does not exist.  Microservices are just another pattern or implementation of components, no more, no less.  Whether they are presented in the system or not does not mean that the system architecture is ready. <br><br>  Microservices are in many ways more related to technical processes related to packaging and operation than to the system architecture itself.  Appropriate boundaries for components remain one of the main difficulties in engineering systems. <br><br>  Regardless of the size of your services, whether they are in Docker containers or not - you should always think carefully about how to put the system together.  There are no correct answers, but there are many options. <br><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  <a href="https://habrahabr.ru/company/flant/blog/340270/">Statistics The New Stack on the Difficulties of Implementing Kubernetes</a> ; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> " <i>(video of the report, which includes an introduction to the technical device Kubernetes);</i> </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/341760/">Infrastructure with Kubernetes as an affordable service</a> "; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/327338/">Why do you need Kubernetes and why is it more than PaaS?</a>  "; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/327536/">What is a service mesh and why do I need it [for a cloud microservice application]?</a>  "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/326414/">Operators for Kubernetes: how to run stateful applications</a> ." </li></ul></div><p>Source: <a href="https://habr.com/ru/post/347518/">https://habr.com/ru/post/347518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347508/index.html">Happy Birthday, Vivaldi !.</a></li>
<li><a href="../347510/index.html">Some aspects of the quality of training sequences</a></li>
<li><a href="../347512/index.html">I modeled the bitcoin price for the entire 2018. You will not believe in the result (approx. Translation. And you will be right)</a></li>
<li><a href="../347514/index.html">GR8 CUL8R - WTF?!?! Understand popular abbreviations in English</a></li>
<li><a href="../347516/index.html">Dynamic code analysis with Iroh.js</a></li>
<li><a href="../347520/index.html">The book "Programming for children. Learning to create websites, applications and games. HTML, CSS and JavaScript ¬ª</a></li>
<li><a href="../347522/index.html">Dependencies between SQL objects: use regular expressions and small algorithmic focus</a></li>
<li><a href="../347524/index.html">Major advances in natural language processing in 2017</a></li>
<li><a href="../347526/index.html">Telegram-bot for Redmine. How to simplify the life of yourself and people</a></li>
<li><a href="../347528/index.html">NLog extension for error monitoring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>