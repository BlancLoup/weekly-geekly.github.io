<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some aspects of monitoring MS SQL Server. Recommendations for setting trace flags</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Quite often, users, developers and administrators of the MS SQL Server DBMS face problems with the performance of the DB or the DBMS as a w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some aspects of monitoring MS SQL Server. Recommendations for setting trace flags</h1><div class="post__text post__text-html js-mediator-article"><h3>  Foreword </h3><br>  Quite often, users, developers and administrators of the MS SQL Server DBMS face problems with the performance of the DB or the DBMS as a whole, therefore monitoring of MS SQL Server is very relevant. <br><br>  This article is an addition to the article <a href="https://habr.com/ru/post/338498/">Using Zabbix to monitor the MS SQL Server database</a> and it will cover some aspects of MS SQL Server monitoring, in particular: how to quickly determine what resources are missing, as well as recommendations on setting trace flags. <br><br>  For the following scripts to work, you need to create an inf scheme in the correct database as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Creating inf schema</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> &lt;_&gt;; go <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> inf;</code> </pre> </div></div><a name="habracut"></a><br><h3>  Method of detecting a shortage of RAM </h3><br>  The first indicator of a shortage of RAM is the case when an instance of MS SQL Server eats up all the RAM allocated to it. <br><br>  To do this, create the following inf.vRAM view: <br><br><div class="spoiler">  <b class="spoiler_title">Creating the inf.vRAM view</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vRAM] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.[TotalAvailOSRam_Mb] <span class="hljs-comment"><span class="hljs-comment">--       , a.[RAM_Avail_Percent] --     , a.[Server_physical_memory_Mb] --       , a.[SQL_server_committed_target_Mb] --     MS SQL Server   , a.[SQL_server_physical_memory_in_use_Mb] --    MS SQL Server       , a.[SQL_RAM_Avail_Percent] --    MS SQL Server      MS SQL Server , a.[StateMemorySQL] --    MS SQL Server , a.[SQL_RAM_Reserve_Percent] --    MS SQL Server     --     , (case when a.[RAM_Avail_Percent]&lt;10 and a.[RAM_Avail_Percent]&gt;5 and a.[TotalAvailOSRam_Mb]&lt;8192 then 'Warning' when a.[RAM_Avail_Percent]&lt;=5 and a.[TotalAvailOSRam_Mb]&lt;2048 then 'Danger' else 'Normal' end) as [StateMemoryServer] from ( select cast(a0.available_physical_memory_kb/1024.0 as int) as TotalAvailOSRam_Mb , cast((a0.available_physical_memory_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [RAM_Avail_Percent] , a0.system_low_memory_signal_state , ceiling(b.physical_memory_kb/1024.0) as [Server_physical_memory_Mb] , ceiling(b.committed_target_kb/1024.0) as [SQL_server_committed_target_Mb] , ceiling(a.physical_memory_in_use_kb/1024.0) as [SQL_server_physical_memory_in_use_Mb] , cast(((b.committed_target_kb-a.physical_memory_in_use_kb)/casT(b.committed_target_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Avail_Percent] , cast((b.committed_target_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Reserve_Percent] , (case when (ceiling(b.committed_target_kb/1024.0)-1024)&lt;ceiling(a.physical_memory_in_use_kb/1024.0) then 'Warning' else 'Normal' end) as [StateMemorySQL] from sys.dm_os_sys_memory as a0 cross join sys.dm_os_process_memory as a cross join sys.dm_os_sys_info as b cross join sys.dm_os_sys_memory as v ) as a;</span></span></code> </pre></div></div><br>  Then you can determine that the MS SQL Server instance consumes all the memory allocated to it by the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SQL_server_physical_memory_in_use_Mb, SQL_server_committed_target_Mb <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vRAM];</code> </pre><br>  If the SQL_server_physical_memory_in_use_Mb indicator is constantly not less than SQL_server_committed_target_Mb, then it is necessary to check the statistics of expectations. <br><br>  To determine the lack of RAM through the statistics of expectations, create an inf.vWaits view: <br><br><div class="spoiler">  <b class="spoiler_title">Creating the inf.vWaits view</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> [Waits] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [wait_type], <span class="hljs-comment"><span class="hljs-comment">--   [wait_time_ms] / 1000.0 AS [WaitS],--      .    signal_wait_time_ms ([wait_time_ms] - [signal_wait_time_ms]) / 1000.0 AS [ResourceS],--        signal_wait_time_ms [signal_wait_time_ms] / 1000.0 AS [SignalS],--           [waiting_tasks_count] AS [WaitCount],--   .         100.0 * [wait_time_ms] / SUM ([wait_time_ms]) OVER() AS [Percentage], ROW_NUMBER() OVER(ORDER BY [wait_time_ms] DESC) AS [RowNum] FROM sys.dm_os_wait_stats WHERE [waiting_tasks_count]&gt;0 and [wait_type] NOT IN ( N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP', N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE', N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE', N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') ) , ress as ( SELECT [W1].[wait_type] AS [WaitType], CAST ([W1].[WaitS] AS DECIMAL (16, 2)) AS [Wait_S],--      .    signal_wait_time_ms CAST ([W1].[ResourceS] AS DECIMAL (16, 2)) AS [Resource_S],--        signal_wait_time_ms CAST ([W1].[SignalS] AS DECIMAL (16, 2)) AS [Signal_S],--           [W1].[WaitCount] AS [WaitCount],--   .         CAST ([W1].[Percentage] AS DECIMAL (5, 2)) AS [Percentage], CAST (([W1].[WaitS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgWait_S], CAST (([W1].[ResourceS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgRes_S], CAST (([W1].[SignalS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgSig_S] FROM [Waits] AS [W1] INNER JOIN [Waits] AS [W2] ON [W2].[RowNum] &lt;= [W1].[RowNum] GROUP BY [W1].[RowNum], [W1].[wait_type], [W1].[WaitS], [W1].[ResourceS], [W1].[SignalS], [W1].[WaitCount], [W1].[Percentage] HAVING SUM ([W2].[Percentage]) - [W1].[Percentage] &lt; 95 -- percentage threshold ) SELECT [WaitType] ,MAX([Wait_S]) as [Wait_S] ,MAX([Resource_S]) as [Resource_S] ,MAX([Signal_S]) as [Signal_S] ,MAX([WaitCount]) as [WaitCount] ,MAX([Percentage]) as [Percentage] ,MAX([AvgWait_S]) as [AvgWait_S] ,MAX([AvgRes_S]) as [AvgRes_S] ,MAX([AvgSig_S]) as [AvgSig_S] FROM ress group by [WaitType];</span></span></code> </pre></div></div><br>  In this case, you can determine the lack of RAM by the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [Percentage]      ,[AvgWait_S]  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [inf].[vWaits]  <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre><br>  Here you need to pay attention to the indicators Percentage and AvgWait_S.  If they are significant in their entirety, then there is a very high probability that the RAM is not enough for the MS SQL Server instance.  Essential values ‚Äã‚Äãare determined individually for each system.  However, you can start with the following indicator: Percentage&gt; = 1 and AvgWait_S&gt; = 0.005. <br><br>  To output indicators to the monitoring system (for example, Zabbix), you can create the following two queries: <br><br><ol><li>  How many percent of RAM expectations are occupied (sum for all such types of expectations): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([Percentage]), <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Percentage] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li><li>  how many milliseconds occupy the RAM expectation types (maximum value of all average delays for all such expectation types): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([AvgWait_S])*<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [AvgWait_MS] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li></ol><br>  Based on the dynamics of the values ‚Äã‚Äãobtained for these two indicators, it can be concluded that there is enough RAM for an instance of MS SQL Server. <br><br><h3>  Method for detecting excessive load on the CPU </h3><br>  To detect processor shortages, it suffices to use the sys.dm_os_schedulers system view.  Here, if the runnable_tasks_count indicator is constantly greater than 1, then there is a high probability that the number of cores is not enough for the MS SQL Server instance. <br><br>  To output the indicator to the monitoring system (for example, Zabbix), you can create the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([runnable_tasks_count]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [runnable_tasks_count] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_os_schedulers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduler_id&lt;<span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre><br>  Based on the dynamics of the obtained values ‚Äã‚Äãfor this indicator, it can be concluded whether the CPU time (the number of CPU cores) is sufficient for an instance of MS SQL Server. <br>  However, it is important to keep in mind the fact that the queries themselves can request several threads at once.  And sometimes the optimizer cannot correctly estimate the complexity of the query itself.  Then the request may be allocated too many threads that are currently not can be processed simultaneously.  And this also causes the type of wait associated with a shortage of CPU time, and the queue growth for schedulers that use specific CPU cores, te the runnable_tasks_count indicator will grow in such conditions. <br><br>  In this case, before increasing the number of CPU cores, you must correctly configure the concurrency properties of the MS SQL Server instance itself, and from the 2016 version you must correctly configure the concurrency properties of the required databases: <br><br><img src="https://habrastorage.org/webt/iu/dz/ul/iudzulebjpipajxjwgxc9vkgoka.png"><br><br><img src="https://habrastorage.org/webt/7u/pk/qf/7upkqfeuffvrmi98yx5bid3h3wm.png"><br><br>  Here you should pay attention to the following parameters: <br><br><ol><li>  Max Degree of Parallelism-sets the maximum number of streams that can be allocated to each request (the default is 0-restriction only by the operating system itself and by the edition of MS SQL Server) </li><li>  Cost Threshold for Parallelism ‚Äî estimated cost of parallelism (default is 5) </li><li>  Max DOP-sets the maximum number of threads that can be allocated to each query at the database level (but no more than the value of the Max Degree of Parallelism property) (the default is 0-limiting only by the operating system itself and MS SQL Server editors as well as a restriction on the ‚ÄúMax Degree of Parallelism‚Äù property of the entire instance of MS SQL Server) </li></ol><br>  It is impossible to give an equally good recipe for all cases, that is, you need to analyze heavy queries. <br><br>  From my own experience, I recommend the following algorithm of actions for OLTP systems for setting the properties of parallelism: <br><br><ol><li>  first prohibit parallelism by setting the entire instance of Max Degree of Parallelism to 1 </li><li>  analyze the most difficult requests and select the optimal number of threads for them </li><li>  set Max Degree of Parallelism to the selected optimal number of streams obtained from item 2, as well as for specific databases set Max DOP value obtained from item 2 for each database </li><li>  analyze the most difficult requests and identify the negative effect of multithreading.  If it is, then increase the cost threshold for parallelism. <br>  For systems such as 1C, Microsoft CRM and Microsoft NAV, in most cases, the prohibition of multithreading will be suitable. </li></ol><br>  Also, if there is a Standard edition, in most cases a multithreading ban will be appropriate in view of the fact that this edition is limited in the number of CPU cores. <br><br>  For OLAP systems, the algorithm described above is not suitable. <br><br>  From my own experience, I recommend the following algorithm of actions for OLAP-systems for setting the properties of parallelism: <br><br><ol><li>  analyze the most difficult requests and select the optimal number of threads for them </li><li>  set Max Degree of Parallelism to the selected optimal number of flows obtained from item 1, and also for specific databases set Max DOP value obtained from item 1 for each database </li><li>  analyze the most difficult requests and identify the negative effect of parallelism limitation.  If it is, then either lower the value of Cost Threshold for Parallelism, or repeat steps 1-2 of this algorithm </li></ol><br>  T e for OLTP systems we go from single-threading to multithreading, and for OLAP-systems, on the contrary, we go from multi-threading to single-threading.  In this way, it is possible to select the optimal concurrency settings for both a specific database and the entire instance of MS SQL Server. <br>  It is also important to understand that the settings of the properties of parallelism need to be changed over time, based on the results of monitoring the performance of MS SQL Server. <br><br><h3>  Recommendations for setting trace flags </h3><br>  From my own experience and the experience of my colleagues for optimal performance, I recommend setting the following trace flags at the start level of the MS SQL Server service for the 2008-2016 version: <br><br><ol><li>  610 - Reducing logging inserts in indexed tables.  Can help with inserts into tables with a large number of records and multiple transactions, with frequent long waits for WRITELOG to change in indexes </li><li>  1117 - If a file in the filegroup meets the auto-zoom threshold requirements, all files in the filegroup increase. </li><li>  1118 ‚Äî Makes all objects be located in different extents (ban on mixed extents), minimizing the need to scan an SGAM page, which is used to track mixed extents. </li><li>  1224 - Disables lock escalation based on the number of locks.  However, excessive memory usage may enable lock escalation. </li><li>  2371 - Changes the threshold for fixed automatic update statistics on the threshold for dynamic automatic update statistics.  It is important to update query plans for large tables, where incorrectly determining the number of records leads to erroneous execution plans. </li><li>  3226 - Suppresses backup success messages in the error log </li><li>  4199 - Includes changes to the query optimizer released in update rollup packages and SQL Server update packages. </li><li>  6532-6534 - Includes improving the performance of query operations with spatial data types </li><li>  8048 - Converts NUMA partitioned memory objects to CPU partitioned. </li><li>  8780 - Includes additional time allocation for scheduling a request.  Some requests without this flag may be rejected because they do not have a request plan (a very rare error) </li><li>  9389 ‚Äî Enables additional dynamic temporarily-provided memory buffer for batch mode operators, which allows the batch mode operator to request additional memory and avoid data transfer to tempdb if additional memory is available. </li></ol><br>  Also, before the 2016 version, it is useful to include the trace flag 2301, which includes the optimization of the extended decision support and thereby helps in choosing more accurate query plans.  However, starting from version 2016, it often has a negative effect in a fairly long total query execution time. <br><br>  Also for systems in which there are a lot of indexes (for example, for 1C databases), I recommend including the trace flag 2330, which disables the collection on the use of indexes, which generally has a positive effect on the system. <br><br>  More details about the trace flags can be found <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql%3Fview%3Dsql-server-2017">here</a> . <br><br>  For the link above, it is also important to consider the versions and assemblies of MS SQL Server, since for newer versions, some trace flags are enabled by default or have no effect. <br><br>  You can enable and disable the trace flag using the DBCC TRACEON and DBCC TRACEOFF commands, respectively.  See <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/database-console-commands/dbcc-traceoff-transact-sql%3Fview%3Dsql-server-2017">here for</a> more details. <br><br>  You can get the status of the trace flags using the DBCC TRACESTATUS command: <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/database-console-commands/dbcc-tracestatus-transact-sql%3Fview%3Dsql-server-2017">more</a> . <br><br>  In order for the trace flags to be included in the autostart of the MS SQL Server service, you need to go to the SQL Server Configuration Manager and add the following trace flags through -T in the service properties: <br><br><img src="https://habrastorage.org/webt/nt/oe/l7/ntoel7jpaujursvrp07tvcbnw80.png"><br><br><h3>  Results </h3><br>  This article has examined some aspects of monitoring MS SQL Server, with which you can quickly identify the lack of RAM and free CPU time, as well as a number of other less obvious problems.  The most commonly used trace flags were considered. <br><br><h3>  Sources </h3><br>  ¬ª <a href="https://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/">SQL Server Wait Statistics</a> <br>  " <a href="https://habrahabr.ru/post/216309/">SQL Server wait statistics or please tell me where it hurts</a> <br>  ¬ª <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql%3Fview%3Dsql-server-2017">System view sys.dm_os_schedulers</a> <br>  ¬ª <a href="https://habr.com/ru/post/338498/">Using Zabbix to monitor MS SQL Server database</a> <br>  <a href="http://sqlcom.ru/">SQL Lifestyle</a> <br>  ¬ª <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql%3Fview%3Dsql-server-2017">Trace Flags</a> <br>  " <a href="http://sql.ru/">Sql.ru</a> </div><p>Source: <a href="https://habr.com/ru/post/448044/">https://habr.com/ru/post/448044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448030/index.html">Display and optimization of output to the terminal on the web</a></li>
<li><a href="../448032/index.html">More robots: Walmart introduces thousands of machines to work in its stores</a></li>
<li><a href="../448034/index.html">Search for tasks in JIRA (simple language). Part 1: Quick and Basic Search</a></li>
<li><a href="../448036/index.html">Import to J.Connect from the file of the list of users through the API</a></li>
<li><a href="../448040/index.html">The digest of interesting materials for the mobile developer # 294 (April 8 - 14)</a></li>
<li><a href="../448048/index.html">Understanding Angular Ivy: Increase DOM and Virtual DOM</a></li>
<li><a href="../448050/index.html">Amateur holography - silver halide photographic materials</a></li>
<li><a href="../448052/index.html">Mikrotik. IPSEC vpn over NAT as client</a></li>
<li><a href="../448054/index.html">SciPy, conditions optimization</a></li>
<li><a href="../448058/index.html">Developing a hexapod from scratch (part 5) - electronics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>