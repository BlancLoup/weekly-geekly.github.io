<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of glass balls - the solution in general</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task of a hundred-story house and two glass balls has long been agitated by the online community ( Habrahabr , LJ , forums ). Inquiring minds cert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of glass balls - the solution in general</h1><div class="post__text post__text-html js-mediator-article"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d05/777/544/d057775444f1abfb4659d99be75ac282.jpg" alt="Ball on the palm" width="345" height="250" align="right"></a>  The task of a hundred-story house and two glass balls has long been agitated by the online community ( <a href="http://habrahabr.ru/post/19367/">Habrahabr</a> , <a href="http://zadacha.livejournal.com/89695.html">LJ</a> , <a href="http://dxdy.ru/topic9229.html">forums</a> ).  Inquiring minds certainly ask themselves: what to do in the general case when we have <i>n</i> floors and <i>k</i> balls? <br><br>  Say, how many shots (at least approximately) will be needed in the case of <i>n</i> = 2 <sup>40</sup> , <i>k</i> = 10? <br><br>  Combining the information found in the vastness of the network and my own work, I want to present you a post about the key ideas for solving this problem, as well as the main results and interesting observations obtained during the study. <br><a name="habracut"></a><br>  So, we formulate the <b>condition</b> : we have <i>k</i> identical glass balls.  If they fall from the ‚Äú <i>x</i> ‚Äù or higher floor of the ‚Äú <i>n</i> ‚Äù -storeyed house, they break up; if they fall from the ‚Äú <i>x</i> - 1‚Äù -th or lower floor, they remain intact.  The value of <i>x is</i> unknown and can be any natural number from 1 to <i>n</i> .  Required: <br>  1. Determine the smallest number of tests (throws of the ball) for which you can guaranteed to find <i>x</i> (regardless of its value, in the worst case for us). <br>  2. Develop an algorithm that allows you to guaranteedly find <i>x</i> for no more than the above number of tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Rough estimate of the smallest number of tests </h4><br>  It is easy to distinguish two extreme cases: <br>  A) we <u>only have 1 ball</u> .  Then we are forced to throw it in turn from each floor, starting from the first, until it breaks or until we get to the " <i>n</i> - 1" -th floor.  If the ball broke on the ‚Äú <i>a</i> ‚Äù -th floor (1 ‚â§ <i>a</i> ‚â§ <i>n</i> - 1), then <i>x</i> = <i>a</i> .  If not crashed on " <i>n</i> - 1" -th, then <i>x</i> = <i>n</i> .  In the worst case, you will need <i>n</i> - 1 test. <br>  B) we have a <u>lot of balls</u> (namely, <i>k</i> ‚â• log <sub>2</sub> <i>n</i> ).  Then you can apply <div class="spoiler">  <b class="spoiler_title">search method "dividing the segment in half"</b> <div class="spoiler_text">  We throw the ball from the middle of the house (from the floor with the number ‚åà <i>n</i> / 2‚åâ, where ‚åà <i>n</i> / 2‚åâ is the smallest integer greater than or equal to <i>n</i> / 2).  If it has not crashed, we throw it from the middle of the upper half of the building; if it has broken, we throw the second ball from the middle of the lower half of the building, and so on, each time ‚Äúdividing‚Äù the corresponding section of the building in half. </div></div>  In the worst case, you will need ‚åàlog <sub>2</sub> <i>n</i> ‚åâ tests and the same number of balls (all of a sudden they will break each throw). <br><br>  Thus, the <b>smallest number of tests is in the range</b> from ‚åàlog <sub>2</sub> <i>n</i> ‚åâ to <i>n</i> - 1 inclusive.  Denote this number by the function <i>f</i> ( <i>n</i> , <i>k</i> ). <br><br>  For example, for the case of a one-story house and <i>k</i> balls, ‚åàlog <sub>2</sub> 100‚åâ = 7, 100 - 1 = 99, which means 7 ‚â§ <i>f</i> (100, <i>k</i> ) ‚â§ 99. Generally speaking, the value of <i>f</i> ( <i>n</i> , <i>k</i> ) decreases quite rapidly with increasing <i>k</i> .  So, <i>f</i> (100, 1) = 99, <i>f</i> (100, 2) = 14, <br>  <i>f</i> (100, 3) = 9, <i>f</i> (100, 4) = 8, <i>f</i> (100, 5) = <i>f</i> (100, 6) = <i>f</i> (100, 7) = ... = 7. <br><br>  A remarkable fact: in the case of a one-story house you can find <i>x</i> in seven attempts with <u>only five balls</u> !  That is, the search method ‚Äúdividing a segment in half‚Äù is not a panacea - it is fast, but not always the most optimal in terms of the required number of balls. <br><br><h4>  Recurrent formula for counting the smallest number of tests </h4><br>  So, how do you find the exact value of <i>f</i> ( <i>n</i> , <i>k</i> )? <br>  In the simplest situations, everything is clear: <i>f</i> ( <i>n</i> , 1) = <i>n</i> - 1 (see case A), <i>f</i> ( <i>n</i> , <i>k</i> ) = ‚åàlog <sub>2</sub> <i>n</i> ‚åâ for <i>k</i> ‚â• log <sub>2</sub> <i>n</i> (see case B), in the number <i>f</i> (1, <i>k</i> ) = 0 (if there is only one floor, then it is also the desired one according to the condition of the problem). <br><br>  Consider the case of <i>n</i> ‚â• 2 and <i>k</i> ‚â• 2. Suppose that the first test we threw a ball from the ‚Äú <i>a</i> ‚Äù -th floor, <i>a</i> can be from 1 to <i>n</i> - 1 inclusive (throwing the ball from the ‚Äú <i>n</i> ‚Äù -th floor is meaningless).  There are two possible outcomes: <br>  Exodus 1: The ball crashed.  This means that 1 ‚â§ <i>x</i> ‚â§ <i>a</i> .  We have <i>a</i> unexplored floors, <i>k</i> - 1 balls, i.e.  To ensure that <i>x is</i> found, you need to do more <i>f</i> ( <i>a</i> , <i>k</i> - 1) tests. <br>  Exodus 2: the ball did not crash.  This means that <i>a</i> + 1 ‚â§ <i>x</i> ‚â§ <i>n</i> .  We have <i>n</i> - <i>a</i> unexplored floors, <i>k</i> balls, i.e.  To ensure that <i>x is</i> found, you need to do more <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> ) tests. <br>  As a result, after throwing the ball from the ‚Äú <i>a</i> ‚Äù -th floor, you may need more max { <i>f</i> ( <i>a</i> , <i>k</i> - 1), <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> )} tests to ensure that <i>x is found</i> . <br>  We want to minimize the number of tests, so we take <i>a</i> such that max { <i>f</i> ( <i>a</i> , <i>k</i> - 1), <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> )} is the smallest, namely min <sub><i>a</i></sub> {max { <i>f</i> ( <i>a</i> , <i>k</i> - 1) , <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> )}}. <br><br>  Thus, the <b>smallest number of tests is equal to</b> : <br>  <i>f</i> ( <i>n</i> , <i>k</i> ) = 1 + min <sub><i>a</i></sub> {max { <i>f</i> ( <i>a</i> , <i>k</i> - 1), <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> )}} (formula 1). <br><br>  This formula is sufficient to calculate <i>f</i> ( <i>n</i> , <i>k</i> ) for any given <i>n</i> and <i>k</i> , as well as the floor number <i>a</i> ( <i>n</i> , <i>k</i> ) = <i>a</i> , from which to throw the ball - it can be any of those for which the value max { <i>f</i> ( <i>a</i> , <i>k</i> - 1), <i>f</i> ( <i>n</i> - <i>a</i> , <i>k</i> )} reaches a minimum. <br>  Calculation is easy to implement, for example, in <i>Excel</i> . <br><div class="spoiler">  <b class="spoiler_title">Who is interested</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/617/628/39b617628a4e16f4156b1fd21dcb4d6d.jpg" width="700" height="400" title="Excel implementation"></div><br>  In column A, starting from the second row, we will write the values ‚Äã‚Äãof <i>n</i> in order from 1 to the required.  In column B in the corresponding rows we write the values ‚Äã‚Äãof <i>f</i> ( <i>n</i> , 1), in column C - the values ‚Äã‚Äãof <i>f</i> ( <i>n</i> , 2) and so on; shifting one column to the right means increasing by one the number of balls. <br>  When <i>n</i> = 1, the value of the function <i>f</i> ( <i>n</i> , <i>k</i> ) is zero, therefore we fill the corresponding string with zeros. <br>  Write the formula = <i>A</i> 3 - 1 in cell B3, since <i>f</i> ( <i>n</i> , 1) = <i>n</i> - 1. Copy (or stretch) it down the required number of lines. <br>  In the cell C3 write the formula: <br>  = 1 + MIN (IF (B $ 2: B2&gt; LARGE (C $ 2: C2; $ A $ 2: $ A2); B $ 2: B2; LARGE (C $ 2: C2; $ A $ 2: $ A2))) <br>  and <b>press CTRL + SHIFT + ENTER</b> , i.e.  enter the array formula.  Copy (or stretch) it to the desired number of rows down and columns to the right. <br><br>  The values ‚Äã‚Äãof <i>a</i> ( <i>n</i> , <i>k</i> ) will be calculated in columns to the right of those used to calculate <i>f</i> ( <i>n</i> , <i>k</i> ), according to the same principle: the rows correspond to the value of <i>n</i> , shifting by one column to the right means increasing by one the number of balls. <br>  In the situation as in the screenshot, column H, starting from the third row, is filled with ones, since <i>a</i> ( <i>n</i> , 1) = 1 (see case A, we always throw a single ball from the first floor). <br>  In the cell I3 write the formula: <br>  = MAX ((B $ 2: B2 &lt;C3) * (LARGE (C $ 2: C2; $ A $ 2: $ A2) &lt;C3) * $ A $ 2: $ A2) <br>  and <b>press CTRL + SHIFT + ENTER</b> , i.e.  enter the array formula.  Copy (or stretch) it to the desired number of rows down and columns to the right. </div></div><br><h4>  Search algorithm <i>x</i> </h4><br>  If we know the values ‚Äã‚Äãof <i>a</i> ( <i>n</i> , <i>k</i> ), then it is easy to describe the search algorithm <i>x</i> in no more than <i>f</i> ( <i>n</i> , <i>k</i> ) tests. <br>  Login: <i>n</i> - the number of floors of the house, <i>k</i> - the number of balls. <br>  Output: <i>x</i> is the number of the required floor. <br>  The beginning of the algorithm. <br>  Step 1. Initialize the variable: <i>x</i> : = 1. Go to step 2. <br>  Step 2. Stop condition: if <i>n</i> = 1, then output <i>x</i> and STOP, otherwise go to step 3. <br>  Step 3. We throw the ball from the floor with the number <i>x</i> - 1 + <i>a</i> ( <i>n</i> , <i>k</i> ).  If the ball is broken, then update the values ‚Äã‚Äãof the variables: <i>n</i> : = <i>a</i> ( <i>n</i> , <i>k</i> ), <i>k</i> : = <i>k</i> - 1. <br>  If the ball is not broken, then update the values ‚Äã‚Äãof the variables: <i>x</i> : = <i>x</i> + <i>a</i> ( <i>n</i> , <i>k</i> ), <i>n</i> : = <i>n</i> - <i>a</i> ( <i>n</i> , <i>k</i> ).  Go to step 2. <br>  The end of the algorithm. <br><br>  Consider an example of how to find <i>x</i> in seven tests, if we have a hundred floors and five balls.  Using the values ‚Äã‚Äãof <i>a</i> ( <i>n</i> , <i>k</i> ) from a table built in <i>Excel</i> , we will write the numbers of the floors from which we throw the ball, <br>  in case they break all the time: <br>  <b>57</b> -&gt; <b>26</b> -&gt; <b>11</b> -&gt; <b>4</b> -&gt; <b>1</b> (if not crashed, then further) -&gt; <b>2</b> (if not crashed, then below) -&gt; <b>3</b> . <br>  If, for example, after throwing the ball from the 26th floor it did not crash, we find ourselves in the situation <i>n</i> = 31, <i>k</i> = 4. Then the sequence of throws looks like: <br>  <b>57</b> -&gt; <b>26</b> -&gt; 26 + 15 = <b>41</b> -&gt; 26 + 7 = <b>33</b> -&gt; 26 + 3 = <b>29</b> -&gt; 26 + 1 = <b>27</b> (if not crashed, then further) -&gt; 27 + 1 = <b>28</b> . <br><br>  All possible options will not be considered.  It can be seen that the algorithm differs from the search method by ‚Äúdividing the segment in half‚Äù. <br><br><h4>  Explicit formula for counting the smallest number of tests </h4><br>  The main disadvantage of formula 1 is that quite a lot of resources are needed to calculate it.  I managed to solve this recurrent formula explicitly on my own only for <i>k</i> = 2 and <i>k</i> = 3 by searching and justifying the patterns in the table of function values.  In particular, in the first case, the result is as follows: <br>  <i>f</i> ( <i>n</i> , 2) = ‚åà <img src="https://habrastorage.org/getpro/habr/post_images/633/37c/5ea/63337c5ea8146d2b1d118b3a8e3ddb97.png" alt="image">  ‚åâ. <br><br>  Similar results people received from other considerations: <a href="http://nightmare4all.narod.ru/100/100.htm">article</a> (author - <a href="http://habrahabr.ru/users/stebanoid/" class="user_link">Stebanoid</a> ).  True answer in it <img src="https://habrastorage.org/getpro/habr/post_images/434/1c4/65c/4341c465cb7f92cd72625f0a6a3321c0.png" alt="image">  , which is caused by a slightly different condition of the problem - the ball does not have to break when throwing from the very top floor.  If we want to take into account this possibility, then in our answer we should substitute the expression <i>n</i> + 1 instead of <i>n</i> (ie, add a floor), and we will get the formula from the article. <br><br>  Gradually, however, I came to a dead end, because the general formula could not be found, the recurrence relation is too complicated.  It was at this moment that I discovered the wonderful ideas of the users of <a href="http://ru-olymp-math.livejournal.com/52699.html"><i>irishoak</i></a> , <a href="http://www.sciteclibrary.ru/cgi-bin/yabb2/YaBB.pl%3Fnum%3D1314087950/0"><i>Bert</i></a> , <a href="http://zadacha.livejournal.com/89695.html"><i>mikhail_vs</i></a> and others, which allow us to reduce the calculation of <i>f</i> ( <i>n</i> , <i>k</i> ) to the solution of an interesting inequality. <br><br>  To do this, we need to consider another function: <i>g</i> ( <i>m</i> , <i>k</i> ) is the largest number of floors, among which you can guaranteedly find <i>x</i> in no more than <i>m</i> tests if there are <i>k</i> balls. <br>  In the simplest situations, the function takes the following values: <i>g</i> ( <i>m</i> , 1) = <i>m</i> + 1 (see case A), <i>g</i> ( <i>m</i> , <i>k</i> ) = <i>g</i> ( <i>m</i> , <i>m</i> ) for <i>k</i> &gt; <i>m</i> (since for <i>m</i> tests you can break at most <i>m</i> balls, the remaining <i>k</i> - <i>m</i> balls are superfluous and do not affect the value of the function). <br>  When <i>m</i> ‚â• 2, <i>k</i> ‚â• 2, one can derive the recurrence formula: <br>  <i>g</i> ( <i>m</i> , <i>k</i> ) = <i>g</i> ( <i>m</i> - 1, <i>k</i> - 1) + <i>g</i> ( <i>m</i> - 1, <i>k</i> ) (formula 2). <br><div class="spoiler">  <b class="spoiler_title">It is easy to understand from the following reasoning:</b> <div class="spoiler_text">  If we throw a ball from the ‚Äú <i>a</i> ‚Äù -th floor and it breaks, then we will have <i>m</i> - 1 attempt and <i>k</i> - 1 ball to find <i>x</i> in the range from 1 to <i>a</i> inclusive.  For this, <i>a</i> must satisfy the condition: <i>a</i> ‚â§ <i>g</i> ( <i>m</i> - 1, <br>  <i>k</i> - 1).  This means that the highest floor from which we can throw the ball is <i>a</i> = <i>g</i> ( <i>m</i> - 1, <i>k</i> - 1).  If it does not break, then we will have <i>m</i> - 1 attempts and <i>k</i> balls, with the help of which we can explore more <i>g</i> ( <i>m</i> - 1, <i>k</i> ) floors.  Thus, the maximum will be to investigate the entire <i>g</i> ( <i>m</i> - 1, <i>k</i> - 1) + <i>g</i> ( <i>m</i> - 1, <i>k</i> ) floors. </div></div><br>  The recurrent formula 2, in contrast to formula 1, is easy to solve, i.e.  express <i>g</i> ( <i>m</i> , <i>k</i> ) in explicit form: <br>  <i>g</i> ( <i>m</i> , <i>k</i> ) = C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> + ... + C <i><sub>m</sub></i> <i><sup>k</sup></i> , <br>  where C <i><sub>m</sub></i> <i><sup>i</sup></i> is the number of combinations of <i>m</i> by <i>i</i> , C <i><sub>m</sub></i> <i><sup>i</sup></i> = <i>m</i> ! / ( <i>i</i> ! ( <i>m</i> - <i>i</i> )!). <br>  This equality can be derived "constructively", but you can "guess" and prove it by induction, which is much simpler (here I don‚Äôt give proof). <br>  Now to find the smallest number of tests it is required to calculate: <br>  <i>f</i> ( <i>n</i> , <i>k</i> ) = ‚åàlog <sub>2</sub> <i>n</i> ‚åâ for <i>k</i> ‚â• log <sub>2</sub> <i>n</i> , <br>  <i>f</i> ( <i>n</i> , <i>k</i> ) = min {natural <i>m</i> |  C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> +‚Ä¶ + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â• <i>n</i> } with <i>k</i> &lt;log <sub>2</sub> <i>n</i> . <br>  By the way, when deriving a recurrent formula for <i>g</i> ( <i>m</i> , <i>k</i> ), another way is to determine the number of the floor from which you can throw the ball in order to find <i>x</i> for no more than <i>f</i> ( <i>n</i> , <i>k</i> ) tests: <i>a</i> ( <i>n</i> , <i>k</i> ) = <i>g</i> ( <i>m</i> - 1, <i>k</i> - 1), <br>  where <i>m</i> = <i>f</i> ( <i>n</i> , <i>k</i> ), i.e. <br>  <i>a</i> ( <i>n</i> , <i>k</i> ) = C <sub><i>f</i> ( <i>n</i> , <i>k</i> ) - 1</sub> <sup>0</sup> + C <sub><i>f</i> ( <i>n</i> , <i>k</i> ) - 1</sub> <sup>1</sup> + C <sub><i>f</i> ( <i>n</i> , <i>k</i> ) - 1</sub> <sup>2</sup> +‚Ä¶ + C <sub><i>f</i> ( <i>n</i> , <i>k</i> ) - 1</sub> <sup><i>k</i> - 1</sup> for <i>k</i> &lt; <i>f</i> ( <i>n</i> , <i>k</i> ) (formula 3), <br>  <i>a</i> ( <i>n</i> , <i>k</i> ) = 2 <sup><i>f</i> ( <i>n</i> , <i>k</i> ) - 1</sup> for <i>k</i> ‚â• <i>f</i> ( <i>n</i> , <i>k</i> ) (formula 4). <br><br><h4>  Conclusions and adventurous evaluation of the smallest number of tests </h4><br>  Starting the task, I intuitively outlined for myself a solution plan - first understand the principle of finding the right floor (i.e. develop an algorithm), then find how many shots it will require in the worst case. <br>  To my surprise, the way turned out to be different - a rather simple algorithm easily followed from the formulas for calculating the smallest number of tests, which we denoted by <i>f</i> ( <i>n</i> , <i>k</i> ). <br><br>  Practically knowing nothing about the function <i>f</i> , we roughly estimated it as: <br>  log <sub>2</sub> <i>n</i> ‚â§ <i>f</i> ( <i>n</i> , <i>k</i> ) ‚â§ <i>n</i> - 1. <br><br>  We know that the left boundary is certainly achieved for ‚Äúlarge‚Äù <i>k</i> , namely, for <i>k</i> ‚â• log <sub>2</sub> <i>n</i> , and the right one - for <i>k</i> = 1. We also learned that for intermediate values ‚Äã‚Äãof <i>k, the</i> search for <i>f</i> ( <i>n</i> , <i>k</i> ) is reduced to finding the least natural <i>m</i> (we denote it by <i>m</i> <sub>0</sub> ) satisfying the inequality: <br>  C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> +‚Ä¶ + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â• <i>n</i> (inequality 1). <br>  However, solving it in order to obtain a truly explicit formula for <i>f</i> ( <i>n</i> , <i>k</i> ) seems to be a non-trivial task.  It would be interesting to hear your suggestions. <br><br>  But even if the inequality is not solved, it is possible to estimate the range in which the desired <i>m</i> <sub>0</sub> is located, which is also the value of the function <i>f</i> ( <i>n</i> , <i>k</i> ). <br><br>  Generally speaking, the presented sum of binomial coefficients can be considered as a polynomial of degree <i>k</i> in variable <i>m</i> .  Then finding <i>m</i> <sub>0</sub> from inequality 1 reduces, in fact, to finding the positive roots of the polynomial C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> + ... + C <i><sub>m</sub></i> <i><sup>k</sup></i> - <i>n</i> . <br>  There are methods that allow us to estimate the roots of a polynomial, but for this we need to know its coefficients, and in our case they look scary (expressed in eerie sums that are not the fact that they fold).  Therefore, we proceed differently. <br><br>  Let us choose two functions <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) and <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ) so that, first, the inequalities <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) ‚â§ C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> + ... + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â§ <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ), and secondly, for fixed <i>k, the</i> inequalities <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) ‚â• <i>n</i> and <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ) ‚â• <i>n are</i> easily solved. <br>  It is easy to understand that the solution <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ) ‚â• <i>n</i> will give us an estimate of the desired <i>m</i> <sub>0</sub> from below, and the solution <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) ‚â• <i>n</i> - from above. <br><br>  As for the upper estimate of the sum of the binomial coefficients (i.e., the function <i>h</i> <sub>2</sub> ), the best of these is <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BD%25D0%25BE%25D0%25BC%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D1%258D%25D1%2584%25D1%2584%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582">Chernoff's inequality</a> : <br>  C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> +‚Ä¶ + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â§ <img src="https://habrastorage.org/getpro/habr/post_images/3e6/217/1c8/3e62171c84f47ed1273d4a7ac61da403.png" alt="image">  . <br>  Decision <img src="https://habrastorage.org/getpro/habr/post_images/3e6/217/1c8/3e62171c84f47ed1273d4a7ac61da403.png" alt="image">  ‚â• <i>n</i> <b>gives the following estimate of the smallest number of tests from below</b> : <br>  <i>f</i> ( <i>n</i> , <i>k</i> ) ‚â• <img src="https://habrastorage.org/getpro/habr/post_images/9ce/702/714/9ce702714596442283e414326d375d4e.png" alt="image">  with <i>k</i> &lt; <img src="http://mathurl.com/mbc3gvd.png" alt="image">  . <br><br>  Honestly, I don‚Äôt really like this formula - it is bulky and works only for ‚Äúsmall‚Äù <i>k</i> .  But still it is better than our first ‚Äî rough ‚Äî assessment, although not always. <br>  Generally speaking, the lower limit of the range is not so important to us, since the value of the function drops rather quickly with increasing <i>k</i> . <br><br>  Much more interesting to clarify the upper limit.  To do this, select <i>h</i> <sub>1</sub> .  I did not manage to find any acceptable results on the lower estimate of the sum of the binomial coefficients.  Own attempts to invent something led to a funny situation. <br>  Reflecting, I came to the conclusion that C <i><sub>m</sub></i> <i><sup>i</sup></i> ‚â• <img src="https://habrastorage.org/getpro/habr/post_images/da2/e42/1c1/da2e421c1f1d9b33695f792d674290fc.png" alt="image">  with <i>m</i> ‚â• <i>i</i> ‚â• 1. <br>  Later I found an error in the reasoning, but the inequality still seems to me true, and with a decent margin (as shown by numerical experiments). <br>  It is even more important that not the inequality itself be fulfilled, but <img src="https://habrastorage.org/getpro/habr/post_images/242/0bb/439/2420bb439f0e8f67acc042455b33798d.png" alt="image">  ‚â§ C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> + ... + C <i><sub>m</sub></i> <i><sup>k</sup></i> , which is even more likely. <br>  Unfortunately, this has not yet been formally proved, I will be grateful for suggestive thoughts or references, and possibly counterexamples. <br><br>  In the end, I decided to continue the study, based on the assumption that my hypothesis is correct, therefore I call the resulting estimate adventurous. <br>  So, <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) = <img src="https://habrastorage.org/getpro/habr/post_images/242/0bb/439/2420bb439f0e8f67acc042455b33798d.png" alt="image">  . <br><br>  The inequality <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) ‚â• <i>n is</i> also not necessarily solved.  We know the coefficients for powers of <i>m</i> , so we can estimate the roots of the polynomial <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) - <i>n</i> .  Using the <a href="http://stu.sernam.ru/lect_alg.php%3Fid%3D112">assessment of Maclaurin</a> , we get that all his positive roots do not exceed <img src="https://habrastorage.org/getpro/habr/post_images/0ea/b67/89f/0eab6789f2a28a02e538ea502f29ecca.png" alt="image">  . <br><br>  This means that we are looking for <i>m</i> <sub>0</sub> ‚â§ <img src="https://habrastorage.org/getpro/habr/post_images/287/bf1/9cb/287bf19cb105c1250eb893d02198938d.png" alt="image">  (score 2). <br>  In my opinion, a very beautiful formula is compact, depends on both variables in an interesting way, and, most importantly, narrows the range well. <br>  Another way to estimate <i>f</i> ( <i>n</i> , <i>k</i> ) from above is to limit it to <i>f</i> ( <i>n</i> , 2) = <img src="https://habrastorage.org/getpro/habr/post_images/633/37c/5ea/63337c5ea8146d2b1d118b3a8e3ddb97.png" alt="image">  ‚åâ.  Despite the fact that the number of balls in this formula is not taken into account, sometimes it still gives the best result compared to the estimate 2. <br>  To be sure, <b>we can write the following estimate of the smallest number of tests from above</b> : <br>  <i>f</i> ( <i>n</i> , <i>k</i> ) ‚â§ min { <img src="https://habrastorage.org/getpro/habr/post_images/287/bf1/9cb/287bf19cb105c1250eb893d02198938d.png" alt="image">  , <img src="https://habrastorage.org/getpro/habr/post_images/633/37c/5ea/63337c5ea8146d2b1d118b3a8e3ddb97.png" alt="image">  + 1}. <br><br>  Applying the formulas in practice, we obtain, for example, that <i>f</i> (400, 4) lies in the range from 9 to 19, with a real value of 11. Moreover, the right limit of the range is given by estimate 2, while <i>f</i> (400, 2) = 28. <br>  For more extreme values, for example, <i>n</i> = 2 <sup>40</sup> , <i>k</i> = 10, we get the left boundary - 58, the right border - 162. For comparison: log <sub>2</sub> <i>n</i> = 40, <i>f</i> ( <i>n</i> , 2) = 1482910, that is, estimate 1 and especially 2 worked very well.  The exact value can be found by solving inequality 1, the search gives the answer 76. <br><br><h4>  Conclusion </h4><br>  Taking into account all the above, it can be stated that the problem of two glass balls in general is solved. <br>  Although no explicit formula for the smallest number of tests has been obtained, it can be determined by solving inequality 1 by brute force or other methods. <br>  Taking into account formulas 3 and 4, this is also sufficient for the operation of a simple algorithm for finding the desired floor. <br>  Analytical calculations (estimates 1 and 2) make it possible to significantly narrow the range in which the smallest number of tests are located, which can be useful in cases where the calculation of the exact value is too time-consuming or is not required. <br><br>  PS: by the time the post was published, I was able to prove the hypothesis that I used to evaluate 2, namely: <br>  C <i><sub>m</sub></i> <i><sup>i</sup></i> ‚â• <img src="https://habrastorage.org/getpro/habr/post_images/da2/e42/1c1/da2e421c1f1d9b33695f792d674290fc.png" alt="image">  with <i>m</i> ‚â• <i>i</i> ‚â• 1. <br>  Therefore, the assessment is now full, not adventurous. <br><br>  At the same time, <b>I will</b> still <b>be grateful</b> for references to the literature, where lower estimates for the binomial coefficients or their sum are considered. <br><br>  <b>Important UPD:</b> In the process of discussing the problem, the user <a href="http://habrahabr.ru/users/grechnik/" class="user_link">grechnik</a> proposed his own version of the lower and upper estimates of the sum of the binomial coefficients: <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) = <img src="https://habrastorage.org/getpro/habr/post_images/78e/2a9/afb/78e2a9afba7e1b3d9b7fda87d53ef1bf.png" alt="image">  and <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ) = <img src="https://habrastorage.org/getpro/habr/post_images/cae/125/455/cae12545553e0db04e344a57dc6457ba.png" alt="image">  . <br><div class="spoiler">  <b class="spoiler_title">Clarify</b> <div class="spoiler_text">  We show that <i>h</i> <sub>1</sub> ( <i>m</i> , <i>k</i> ) ‚â§ C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> +‚Ä¶ + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â§ <i>h</i> <sub>2</sub> ( <i>m</i> , <i>k</i> ).  This follows from the chain of inequalities: <br><img src="https://habrastorage.org/getpro/habr/post_images/78e/2a9/afb/78e2a9afba7e1b3d9b7fda87d53ef1bf.png" alt="image">  ‚â§ <img src="https://habrastorage.org/getpro/habr/post_images/18e/bf7/338/18ebf73389136c9608d766456750b864.png" alt="image">  = C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â§ C <i><sub>m</sub></i> <sup>0</sup> + C <i><sub>m</sub></i> <sup>1</sup> + C <i><sub>m</sub></i> <sup>2</sup> +‚Ä¶ + C <i><sub>m</sub></i> <i><sup>k</sup></i> ‚â§ 1 + <i>m</i> + <img src="https://habrastorage.org/getpro/habr/post_images/ce5/dea/fd7/ce5deafd7bf40ec7d652995cb96509da.png" alt="image">  ‚â§ <img src="https://habrastorage.org/getpro/habr/post_images/cae/125/455/cae12545553e0db04e344a57dc6457ba.png" alt="image">  . <br>  The last inequality is true, since the coefficients with powers of <i>m</i> on the left side are not greater than on the right side (for <i>m</i> <sup><i>l,</i></sup> on the left side, the coefficient is <img src="https://habrastorage.org/getpro/habr/post_images/01f/4d1/910/01f4d19106149bb9ae000fa33fc4a696.png" alt="image">  , and on the right: <img src="https://habrastorage.org/getpro/habr/post_images/88a/f5a/cb7/88af5acb72d6b3069d3e06f4157ad43f.png" alt="image">  ). </div></div><br>  Now we can <b>estimate the smallest number of tests</b> as: <img src="https://habrastorage.org/getpro/habr/post_images/ba9/39f/80d/ba939f80df818abe4cb2784097c7f3d4.png" alt="image">  - <i>k</i> ‚â§ <i>f</i> ( <i>n</i> , <i>k</i> ) ‚â§ <img src="https://habrastorage.org/getpro/habr/post_images/ba9/39f/80d/ba939f80df818abe4cb2784097c7f3d4.png" alt="image">  + <i>k</i> . <br>  This means that the <b>smallest number of tests is equal to</b> <img src="https://habrastorage.org/getpro/habr/post_images/ba9/39f/80d/ba939f80df818abe4cb2784097c7f3d4.png" alt="image">  with an accuracy of plus / minus number equal to the number of balls!  Great, awesome formula! <br><br>  In the comments, users <a href="http://habrahabr.ru/users/grechnik/" class="user_link">grechnik</a> and <a href="http://habrahabr.ru/users/mrrl/" class="user_link">Mrrl</a> also offer interesting asymptotic estimates for the value <i>f</i> ( <i>n</i> , <i>k</i> ). </div><p>Source: <a href="https://habr.com/ru/post/211200/">https://habr.com/ru/post/211200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211184/index.html">Mice cried, pricked, but continued to gnaw cactus</a></li>
<li><a href="../211188/index.html">Algorithms of logic of the bot for the game "Minesweeper"</a></li>
<li><a href="../211192/index.html">How mobile phones have changed the game industry</a></li>
<li><a href="../211194/index.html">An example of optimizing computing on CUDA</a></li>
<li><a href="../211198/index.html">Post news with a picture in the Vkontakte group (Perl)</a></li>
<li><a href="../211202/index.html">Unity3D multiplayer basics</a></li>
<li><a href="../211204/index.html">Qwt and Qt Creator. Quick and easy. Part 1: Data Visualizer</a></li>
<li><a href="../211206/index.html">Incoding Rapid Development Framework (part 2 CQRS)</a></li>
<li><a href="../211208/index.html">Evolution in data center networks. Software defined SDN</a></li>
<li><a href="../211210/index.html">Browser Development - Functional Level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>