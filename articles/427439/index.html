<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 16. Signals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will look at signals that are the simplest mechanisms for interaction between tasks in Nucleus SE. They provide a low-cost way to transfe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 16. Signals</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/px/wm/t4/pxwmt4bbchih_uwlzsmgubcn1cy.jpeg"><br><br>  This article will look at signals that are the simplest mechanisms for interaction between tasks in Nucleus SE.  They provide a low-cost way to transfer simple messages between tasks. <br><a name="habracut"></a><br><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Use of signals </h2><br>  Signals differ from all other types of kernel objects in that they are not autonomous: signals are associated with tasks and cannot exist without them.  If the application is configured to use signals, then each task has a set of eight signal flags. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Any task can set signals for another task.  Only the task owner of the signal can read signals.  In the process of reading the signals are reset.  Tasks cannot read or discard signals from other tasks. <br><br>  In Nucleus RTOS, there is a tool that allows tasks to assign functions that run when another task sets one or more signal flags.  This is somewhat similar to the interrupt handling procedure.  This feature is not supported in the Nucleus SE, here tasks should request signal flags explicitly. <br><br><h2>  Signal setup </h2><br>  As with most Nucleus SE objects, the signal setting is determined by the <b>#define</b> directives in <b>nuse_config.h</b> .  The main parameter is <b>NUSE_SIGNAL_SUPPORT</b> , which activates support for functionality (for all tasks in the application).  The question of specifying the number of signals is not worth it: 8 flags are allocated for each task. <br><br>  The setting of this enable parameter serves as the main signal activator.  This provides a well-defined data structure with an appropriate size.  In addition, this parameter activates the API settings. <br><br><h3>  Activate API calls </h3><br>  Each API function (service call) in the Nucleus SE is activated by the <b>#define</b> directive in <b>nuse_config.h</b> .  For signals, these include: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">NUSE_SIGNALS_SEND</span></span> NUSE_SIGNALS_RECEIVE</code> </pre> <br>  By default, they are assigned the value <b>FALSE</b> , thus disabling each service call and preventing the inclusion of the code implementing them.  To set up signals in the application, you need to select the necessary API calls and set the corresponding directives to <b>TRUE</b> . <br><br>  The following is an excerpt from the default <b>nuse_config.h</b> file: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNAL_SUPPORT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enables support for signals */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_SEND FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_RECEIVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  An activated API function with signal support disabled will result in a compilation error.  If your code uses an API call that has not been activated, a build error will occur because the implementation code was not included in the application.  Of course, the inclusion of two API functions is in some way unnecessary, since there is no point in activating signal support in the absence of these APIs.  Activators have been added for compatibility with other features of Nucleus SE. <br><br><h2>  Alarm Calls </h2><br>  Nucleus RTOS supports four signal-related service calls, which provide the following functionality: <br><br><ul><li>  Sending signals to a given task.  The Nucleus SE is implemented as a <b>NUSE_Signals_Send ()</b> function. </li><li>  Reception of signals.  In Nucleus SE, it is implemented in the <b>NUSE_Signals_Receive ()</b> function. </li><li>  Signal handler registration.  Not implemented in the Nucleus SE. </li><li>  Enable / disable (control) signals.  Not implemented in the Nucleus SE. </li></ul><br>  The implementation of each of these calls is discussed in detail below. <br><br><h2>  Signal sending and receiving services </h2><br>  The fundamental operations that can be performed on a set of task signals ‚Äî sending data (can be done by any task) and reading data (and, therefore, clearing data, can only be done by the owner-task).  Nucleus RTOS and Nucleus SE provide two basic API calls for these operations, which will be described below. <br><br>  Since the signals are bits, they are best visualized as binary numbers.  Since standard C does not historically support the representation of binary constants (octal and hexadecimal only), Nucleus SE has a useful header file <b>nuse_binary.h</b> , which contains <b>#define</b> characters of the form <b>b01010101</b> for all 256 8-bit values.  The following is an excerpt from the <b>nuse_binary.h</b> file: <br><br><pre> <code class="hljs lisp">#define b00000000 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x00) #define b00000001 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x01) #define b00000010 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x02) #define b00000011 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x03) #define b00000100 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x04) #define b00000101 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x05)</code> </pre><br><h3>  Sending Signals </h3><br>  Any task can send signals to any other task in the application.  Sending signals involves setting one or more signal flags.  This is an OR operation (OR), which does not affect the previously set flags. <br><br>  <b><i>Call to send signals to the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>STATUS NU_Send_Signals (NU_TASK * task, UNSIGNED signals);</b> <br><br>  Options: <br><br>  <b>task</b> - a pointer to the task control block to which the set signal flags belong; <br>  <b>signals</b> - the value of the set signal flags. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_TASK</b> - incorrect pointer to the task; <br><br>  <b><i>Call to send signals to the Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS_NUSE_Signals_Send (NUSE_TASK task, U8 signals);</b> <br><br>  Options: <br><br>  <b>task</b> - an index (ID) of the task to which the signal flags are being set; <br>  <b>signals</b> - the value of the set signal flags. <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the service call was successfully completed; <br>  <b>NUSE_INVALID_TASK</b> - incorrect task index. <br><br>  <b><i>Implementing sending signals to the Nucleus SE</i></b> <br>  Below is the complete code for the NUSE_Signals_Send () function: <br><br><pre> <code class="hljs kotlin">STATUS NUSE_Signals_Send(NUSE_TASK task, U8 signals) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_API_PARAMETER_CHECKING <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task &gt;= NUSE_TASK_NUMBER) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_INVALID_TASK; } #endif NUSE_CS_Enter(); NUSE_Task_Signal_Flags[task] |= signals; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS; }</code> </pre><br>  The code is very simple.  After any verification of the parameters, the signal values ‚Äã‚Äãpass through the OR operation to the signal flags of the specified task.  Task blocking does not affect the signals. <br><br><h3>  Reception of signals </h3><br>  A task can only read its own set of signal flags.  In the process of reading the values ‚Äã‚Äãof the flags are reset. <br><br>  <b><i>Call to receive signals in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>UNSIGNED NU_Receive_Signals (VOID);</b> <br><br>  Parameters: none. <br><br>  Return value: <br>  Values ‚Äã‚Äãof signal flags. <br><br>  <b><i>Call to receive signals in the Nucleus SE</i></b> <br>  This API call supports Nucleus RTOS API key functionality. <br><br>  Service Call Prototype: <br>  <b>U8 NUSE_Signals_Receive (void);</b> <br><br>  Parameters: none. <br><br>  Return value: <br>  Values ‚Äã‚Äãof signal flags. <br><br>  <b><i>Implementing Nucleus SE Signal Acquisition</i></b> <br>  The following is the full code for the <b>NUSE_Signals_Receive ()</b> function: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">U8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NUSE_Signals_Receive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { U8 signals; NUSE_CS_Enter(); Signals = NUSE_Task_Signal_Flags[NUSE_Task_Active]; NUSE_Task_Signal_Flags[NUSE_Task_Active] = <span class="hljs-number"><span class="hljs-number">0</span></span>; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signals; }</code> </pre><br>  The code is very simple.  The value of the flags is copied, the initial value is reset, and the copy is returned by the API function.  Task blocking does not affect signals. <br><br><h2>  Data structures </h2><br>  Since signals are not separate objects, memory usage depends on the tasks to which they belong.  Below is some information for completeness.  Signals use one data structure (in RAM), which, like other Nucleus SE objects, is a table whose dimensions correspond to the number of tasks in the application.  This data structure is used only if signal support is enabled. <br><br>  I highly recommend that the application code does not directly access this data structure, but use the existing API functions.  This avoids incompatibility with future versions of the Nucleus SE, unwanted side effects, and also simplifies porting the application to the Nucleus RTOS.  The data structure is discussed in detail below to simplify understanding of the principles of work calls and debugging. <br><br><h3>  The structure of the data placed in the RAM </h3><br>  Data structure: <br>  <b>NUSE_Task_Signal_Flags []</b> is an array of type U8 with one entry for each configured task, signal flags are stored in this array. <br><br>  This data structure is initialized with zeros by the <b>NUSE_Init_Task ()</b> function when the Nucleus SE is loaded. <br><br><h3>  The structure of the data placed in the ROM </h3><br>  Signals do not have data structures in ROM. <br><br><h3>  The amount of memory for storing data signals </h3><br>  As with all Nucleus SE core objects, the amount of memory required for signals is predictable. <br><br>  The amount of data in the ROM for all signals in the application is 0. <br><br>  The amount of memory for storing data in RAM (in bytes) for all signals in the application is equal to the number of tasks configured ( <b>NUSE_TASK_NUMBER</b> ).  But in fact, this data belongs to the tasks and is described in the previous article about the tasks. <br><br><h2>  Unrealized API calls </h2><br>  Two signal calls to the API of signals from Nucleus RTOS are not implemented in Nucleus SE: <br><br><h3>  Signal Handler Registration </h3><br>  This API call sets the signal processing procedure (function) for the current task.  This is not necessary in Nucleus SE, since signal handlers are not supported. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Register_Signal_Handler (VOID (* signal_handler) (UNSIGNED));</b> <br><br>  Options: <br>  <b>signal_handler</b> - a function that should be called when receiving signals <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_POINTER</b> - null pointer to a signal handler ( <b>NULL</b> ) <br><br><h3>  Control (enable / disable) signals </h3><br>  This service activates and / or deactivates the signals for the current task.  For each task 32 signals are available.  Each signal is represented by a bit in <b>signal_enable_mask</b> .  Adding a bit to <b>signal_enable_mask</b> enables the corresponding signal, and deleting the bit disables it. <br><br>  Service Call Prototype: <br>  <b>UNSIGNED NU_Control_Signals (UNSIGNED enable_signal_mask);</b> <br><br>  Options: <br>  <b>enable_signal_mask</b> - a bit pattern representing the correct signals. <br><br>  Return value: <br>  Mask of activating / deactivating the previous signal. <br><br><h2>  Nucleus RTOS Compatibility </h2><br>  When developing the Nucleus SE, my goal was to maintain the maximum level of compatibility of code with the Nucleus RTOS.  Signals are no exception, and, from a developer‚Äôs point of view, they are implemented in much the same way as in the Nucleus RTOS.  There are some incompatibilities that I considered valid, given that the final code is much easier to understand and can use memory more efficiently.  Otherwise, the Nucleus RTOS API calls can be almost directly transferred to the Nucleus SE calls. <br><br><h3>  Signal handlers </h3><br>  In Nucleus SE, signal handlers are not implemented to simplify the overall structure. <br><br><h3>  Signal availability and quantity </h3><br>  Nucleus RTOS tasks can have 32 signal flags each.  In Nucleus SE, I decided to reduce their number to eight, since this will be enough for simpler applications and saves RAM resources.  If necessary, the signals can be completely turned off. <br><br><h3>  Unrealized API calls </h3><br>  Nucleus RTOS supports four signaling service calls.  Of these, two were not implemented in the Nucleus SE.  Their description can be found above in the section "Unrealized API calls". <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/427439/">https://habr.com/ru/post/427439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427429/index.html">GUI frameworks - on stream</a></li>
<li><a href="../427431/index.html">How Android works, part 4</a></li>
<li><a href="../427433/index.html">Balancing traffic in the operator‚Äôs IP networks</a></li>
<li><a href="../427435/index.html">STM32H7 - setting clocking without HAL</a></li>
<li><a href="../427437/index.html">Configuring linked servers: ms sql server and teradata</a></li>
<li><a href="../427441/index.html">Convergence with Kubernetes</a></li>
<li><a href="../427443/index.html">Vivisection success</a></li>
<li><a href="../427447/index.html">GNU Arm Embedded Toolchain appeared in PVS-Studio</a></li>
<li><a href="../427449/index.html">How to understand Tensorflow and not die, but even teach a car something</a></li>
<li><a href="../427451/index.html">Connect phpStorm tasks to Bitrix24</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>