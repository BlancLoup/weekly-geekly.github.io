<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TypeList and Tic Tac Toe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wanted, finally (!), To try out the variadic templates , as it is still tied to the 10th studio, where there is nothing like that. And in order not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TypeList and Tic Tac Toe</h1><div class="post__text post__text-html js-mediator-article"> I wanted, finally (!), To try out the <code>variadic templates</code> , as it is still tied to the 10th studio, where there is nothing like that.  And in order not to think for a long time, where it is useless to use the variadic templates, I got the idea to try what <a href="http://erdani.com/">Typelist</a> will look <a href="http://erdani.com/">like</a> .  For those who still do not know what it is, I will try to explain along the way, and for those who are bored - can immediately scroll down - we will try to write <code>Typelist</code> -tac-toe using <code>Typelist</code> . <br>  So, <code>TypeList</code> : <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Typelist</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> internal { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class"> {</span></span> }; } <span class="hljs-comment"><span class="hljs-comment">// internal template&lt;typename ...Args&gt; struct TypeList { typedef internal::Void Head; typedef internal::Void Tail; }; typedef TypeList&lt;&gt; EmptyTypeList; template&lt;typename H, typename ...T&gt; struct TypeList&lt;H, T...&gt; { typedef H Head; typedef TypeList&lt;T...&gt; Tail; };</span></span></code> </pre><br></div></div><br>  A typical <code>TypeList</code> is a ‚Äúhead‚Äù ( <code>Head</code> ) and a ‚Äútail‚Äù ( <code>Tail</code> ), which in turn is also a list of types.  Using: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; floating_point_types;</code> </pre><br>  Previously, without C ++ 11, it looked like this: <br><div class="spoiler">  <b class="spoiler_title">Old typelist</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">H</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typelist</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> H head; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T tail; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> typelist&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, typelist&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; &gt; floating_point_types;</code> </pre><br>  And macros to help: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPELIST_1(T1) typelist</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T1, null_typelist&gt; #define TYPELIST_2(T1, T2) typelist&lt;T1, TYPELIST_1(T2) &gt; #define TYPELIST_3(T1, T2, T3) typelist&lt;T1, TYPELIST_2(T2, T3) &gt; ... #define TYPELIST_50...</span></span></span></span></code> </pre><br></div></div><br>  But now, thanks to the <code>variadic templates</code> , you can get rid of both macros and the number of types in the list. <br>  As a matter of fact, it is interesting how to work with the list of types, how to define operations on it and what it ultimately gives (who is interested in a more detailed description and who hasn‚Äôt yet seen <a href="http://en.wikipedia.org/wiki/Modern_C%252B%252B_Design">Modern C ++ Design</a> - I advise you to read - it doesn‚Äôt matter that this is 2001! ). <br>  So, apparently, I defined the auxiliary type <code>internal::Void</code> , which will work as a signal flag and say that the list of types is empty (at least for the case when the user has not specified anything: <code>TypeList&lt;&gt;</code> , or when removed all items).  Start over: <br><h4>  IsEmpty </h4><br><div class="spoiler">  <b class="spoiler_title">IsEmpty</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::true_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-class">&lt;TypeList&lt;internal::Void, internal::Void&gt;&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::true_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-class">&lt;TypeList&lt;Args...&gt;&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head, internal::Void&gt;::value &amp;&amp; IsEmpty&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::value&gt; { };</code> </pre><br></div></div><br>  Here you can see almost everything we need to define other operations.  As you can see, first we define the ‚Äúbackbone‚Äù: the type <code>IsEmpty</code> parameterized by one type.  In essence, this is a ‚Äúfunction‚Äù that takes one argument.  Since the <code>TL</code> type means ‚Äúany type‚Äù, we do a full specialization of the template for the case with an empty list: <code>TypeList&lt;internal::Void, internal::Void&gt;</code> (one could just <code>TypeList&lt;&gt;</code> or, just for this, I defined the type of <code>EmptyTypeList</code> ) and the partial specialization that works - ‚Äúfor any type list‚Äù.  Thus, our ‚Äúfunction‚Äù is defined only for the type list.  In the new standard, such convenient things as <a href="http://en.cppreference.com/w/cpp/types/integral_constant">std :: integral_constant appeared</a> that greatly simplify life: in the case of <code>struct IsEmpty : std::true_type</code> , <code>IsEmpty</code> has a member of the <code>value</code> class, a number of <code>typedef</code> and a conversion operator to <code>bool</code> . <br>  How to use it?: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; TL1; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::boolalpha &lt;&lt; IsEmpty&lt;TL1&gt;::value &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; IsEmpty&lt;EmptyTypeList&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Whether the empty list we have defines the following expression: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head, internal::Void&gt;::value &amp;&amp; IsEmpty&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::value</code> </pre><br>  literally - ‚Äúthe list is empty if its head is an auxiliary type denoting <code>void</code> And if its tail is also an empty list‚Äù.  As you can see, it uses recursion, which, just stops, the full specialization of the template for an empty list. <br>  Farther: <br><h4>  Contains </h4><br><div class="spoiler">  <b class="spoiler_title">Contains</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contains</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contains</span></span></span><span class="hljs-class">&lt;internal::Void, Args...&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contains</span></span></span><span class="hljs-class">&lt;T, TypeList&lt;Args...&gt;&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head, T&gt;::value || Contains&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::value &gt; { };</code> </pre><br></div></div><br>  <code>Contains</code> determines if the specified type <code>T</code> inside the <code>TL</code> type list.  Using: <br><br>  Using: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::boolalpha &lt;&lt; Contains&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, TL&gt;::value &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; Contains&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Again: ‚Äúif the head of the list is our type <code>T</code> , then <code>T</code> is inside the list, otherwise it is to see if there is <code>T</code> in the tail of the list‚Äù. <br>  Partial specialization - a precautionary measure - what if someone takes advantage of our type <code>internal::Void</code> ? <br><h4>  Length </h4><br><div class="spoiler">  <b class="spoiler_title">Length</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class">&lt;TypeList&lt;Args...&gt;&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, IsEmpty&lt;TypeList&lt;Args...&gt;&gt;::value ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> + Length&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::value&gt; { };</code> </pre><br></div></div><br>  If the list is empty, the length is zero, otherwise it is one (because there is a ‚Äúhead‚Äù) + tail length: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; Length&lt;TL&gt;::value &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; Length&lt;EmptyTypeList&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><h4>  Typeat </h4><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeAt</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> internal::Void type; };</code> </pre><br>  - returns type by index, almost as an array.  Implementation - first run (change type <code>N</code> to <code>int</code> ): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//template&lt;int N, typename ...Args&gt; //struct TypeAt&lt;N, TypeList&lt;Args...&gt;&gt; //{ // typedef typename std::conditional&lt;N == 0, // typename TypeList&lt;Args...&gt;::Head, // typename TypeAt&lt;N - 1, typename TypeList&lt;Args...&gt;::Tail&gt;::type&gt;::type type; //};</span></span></code> </pre><br>  - everything will work fine, but!  - I would like to be warned if the index is too large.  It would be possible to get out with the current implementation, but here it is necessary to take into account that the template must be correctly instantiated for the case <code>N=-1</code> .  Therefore, we go another way: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeAt</span></span></span><span class="hljs-class">&lt;0, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeAt</span></span></span><span class="hljs-class">&lt;N, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(N &lt; Length&lt;TypeList&lt;Args...&gt;&gt;::value, <span class="hljs-string"><span class="hljs-string">"N is too big"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeAt&lt;N - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::type type; };</code> </pre><br>  - the head has a zero index, and for other cases - we will simultaneously reduce the index by one and ‚Äúeat‚Äù a piece of tail (we move from left to right) until we can take away - the index is zero, and the current head is the type we need!  Using: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; TL2; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;TypeAt&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, TL2&gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt;::value, <span class="hljs-string"><span class="hljs-string">"Something wrong!"</span></span>);</code> </pre><br><h4>  List output </h4><br><div class="spoiler">  <b class="spoiler_title">operator &lt;&lt;</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, EmptyTypeList) { ostr &lt;&lt; "{}"; return ostr; } template&lt;typename TL&gt; void PrintTypeListHelper(TL, std::ostream&amp; ostr) { } template&lt;typename T&gt; void PrintTypeListHead(T, std::ostream&amp; ostr) { ostr &lt;&lt; typeid(T).name(); } template&lt;typename ...Args&gt; void PrintTypeListHead(TypeList&lt;Args...&gt; tl, std::ostream&amp; ostr) { ostr &lt;&lt; tl; } template&lt;typename Head, typename ...Args&gt; void PrintTypeListHelper(TypeList&lt;Head, Args...&gt;, std::ostream&amp; ostr) { PrintTypeListHead(Head(), ostr); if(!IsEmpty&lt;TypeList&lt;Args...&gt;&gt;::value) { ostr &lt;&lt; ' '; PrintTypeListHelper&lt;Args...&gt;(TypeList&lt;Args...&gt;(), ostr); } } template&lt;typename ...Args&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, TypeList&lt;Args...&gt; tl) { ostr &lt;&lt; '{'; PrintTypeListHelper(tl, ostr); ostr &lt;&lt; '}'; return ostr; }</span></span></code> </pre><br></div></div><br>  These functions help to accurately display the usual type lists and nested ones, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;TL2, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, TL2&gt; TL10; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL10() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> <code>{double float float double int char char int char} <br></code> <br> <code>{{char short} double {char short}} <br></code> <br><br><h4>  Append and Add </h4><br><div class="spoiler">  <b class="spoiler_title">Append, Add</b> <div class="spoiler_text">  The functions of adding to the end of the list, with a small difference: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TOrTL2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class">&lt;T, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Args..., T&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args2&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class">&lt;TypeList&lt;Args1...&gt;, TypeList&lt;Args2...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Args2..., Args1...&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class">&lt;T, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Args..., T&gt; type; };</code> </pre><br></div></div><br>  When using <code>Append</code> with the list of types in the first argument, a ‚Äúdecomposition‚Äù into composite ones occurs.  Those.: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; TL1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; TL2; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL1() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; TL2() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; Add&lt;TL2, TL1&gt;::type() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; Append&lt;TL2, TL1&gt;::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> <code>{int}, {char short}</code> <br> <code>{int {char short}}, {int char short}</code> <br>  In the first case, the length of the result is 2, while in the second - 3, since the added list of types has ‚Äúdecomposed‚Äù into components. <br><h4>  RemoveAll </h4><br><div class="spoiler">  <b class="spoiler_title">Deleting items</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TOrTL2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveAll</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveAll</span></span></span><span class="hljs-class">&lt;T, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RemoveAll&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::type Removed; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head Head; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Head, T&gt;::value, Removed, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;Removed, TypeList&lt;Head&gt;&gt;::type &gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveAll</span></span></span><span class="hljs-class">&lt;T, TypeList&lt;Head&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Head, T&gt;::value, EmptyTypeList, TypeList&lt;Head&gt;&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveAll</span></span></span><span class="hljs-class">&lt;T, EmptyTypeList&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EmptyTypeList type; };</code> </pre><br></div></div><br>  Removal is done like this: <br><ul><li>  We can delete nothing from the empty list </li><li>  If we have a list with one element (head only), then return an empty list if the type of head is the same as the specified one or do not change anything otherwise </li><li>  For all other cases - remove items from the tail and if the head type does not match the specified type - add it before the removal result </li></ul><br>  It is important that, because when deleting from the tail we grouped the result into another type list, when we combine, we use <code>Append</code> , which ‚Äúspins up‚Äù the grouped type list back. <br>  Using: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; RemoveAll&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, TL&gt;::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> <code>{double float float double int char char int char}</code> <br> <code>{double float float double int int}</code> <br> <br>  You can write another version of <code>RemoveAll</code> , which will remove from the second list of types all those that are in the first.  But!  In this case, it cannot be used for lists that contain other lists: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">RemoveAll v2</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//template&lt;typename Head2, typename ...Args1&gt; //struct RemoveAll&lt;TypeList&lt;Head2&gt;, TypeList&lt;Args1...&gt;&gt; //{ // typedef typename RemoveAll&lt;Head2, TypeList&lt;Args1...&gt;&gt;::type type; //}; // //template&lt;typename ...Args1&gt; //struct RemoveAll&lt;EmptyTypeList, TypeList&lt;Args1...&gt;&gt; //{ // typedef TypeList&lt;Args1...&gt; type; //}; // //template&lt;typename ...Args2, typename ...Args1&gt; //struct RemoveAll&lt;TypeList&lt;Args2...&gt;, TypeList&lt;Args1...&gt;&gt; //{ //private: // typedef TypeList&lt;Args2...&gt; TL2; // typedef TypeList&lt;Args1...&gt; TL1; // // typedef typename RemoveAll&lt;typename TL2::Tail, TL1&gt;::type Removed; // typedef typename TL2::Head Head2; // //public: // typedef typename std::conditional&lt; // Contains&lt;Head2, Removed&gt;::value, // typename RemoveAll&lt;Head2, Removed&gt;::type, // TL1 // &gt;::type type; //};</span></span></code> </pre><br></div></div><br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; TL2; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; RemoveAll&lt;TL2, TL&gt;::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> <code>{double float float double int char char int char}</code> <br> <code>{float float int int}</code> <br> <h4>  RemoveDuplicates </h4><br><div class="spoiler">  <b class="spoiler_title">RemoveDuplicates</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveDuplicates</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveDuplicates</span></span></span><span class="hljs-class">&lt;EmptyTypeList&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EmptyTypeList type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoveDuplicates</span></span></span><span class="hljs-class">&lt;TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Args...&gt; TL; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RemoveAll&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL::Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL::Tail&gt;::type HeadRemovedFromTail; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RemoveDuplicates&lt;HeadRemovedFromTail&gt;::type TailWithoutDuplicates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;TailWithoutDuplicates, TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL::Head&gt;&gt;::type type; };</code> </pre><br></div></div><br>  Function that removes duplicates: <br><ul><li>  We can delete nothing from the empty list </li><li>  Remove the same elements as the head from the tail </li><li>  Recursively call a function for the tail. </li><li>  Combine the head with the result </li></ul><br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; TL() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; RemoveDuplicates&lt;TL&gt;::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> <code>{double float float double int char char int char}</code> <br> <code>{double float int char}</code> <br> <h4>  Find </h4><br><div class="spoiler">  <b class="spoiler_title">Position type in the list</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Constants</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, UINT_MAX&gt; npos; }; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> internal { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexFrom, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FindHelper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexFrom&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FindHelper</span></span></span><span class="hljs-class">&lt;T, IndexFrom, EmptyTypeList&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexFrom, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FindHelper</span></span></span><span class="hljs-class">&lt;T, IndexFrom, TypeList&lt;Args...&gt;&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Head, T&gt;::value ? IndexFrom : IndexFrom + <span class="hljs-number"><span class="hljs-number">1</span></span> + FindHelper&lt;T, IndexFrom, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeList&lt;Args...&gt;::Tail&gt;::value&gt; { }; } <span class="hljs-comment"><span class="hljs-comment">// internal template&lt;typename T, typename TL&gt; struct Find { }; template&lt;typename T&gt; struct Find&lt;T, EmptyTypeList&gt; : Constants::npos { }; template&lt;typename ...Args&gt; struct Find&lt;internal::Void, TypeList&lt;Args...&gt;&gt; : Constants::npos { }; template&lt;typename T, typename ...Args&gt; struct Find&lt;T, TypeList&lt;Args...&gt;&gt; : std::integral_constant&lt;unsigned int, Contains&lt;T, TypeList&lt;Args...&gt;&gt;::value ? internal::FindHelper&lt;T, 0, TypeList&lt;Args...&gt;&gt;::value : Constants::npos::value&gt; { };</span></span></code> </pre><br></div></div><br><br>  A few things: <br>  - <code>Constants</code> - for constants.  In our case, only for the constant, which says that the item was not found (constexp is not supported in my studio, therefore <code>UINT_MAX</code> ) <br>  - <code>internal::FindHelper</code> - strictly speaking, the ‚Äúthing‚Äù that searches for a type in the list that exactly (!) Contains this type (the additional parameter <code>IndexFrom</code> is the initial value of the counting, a completely unnecessary thing :) - designed for the case when ask where to start the search) <br><br>  Again - nothing intricate - if the specified type and type of the head of the list are the same - then the index is zero, otherwise it will move to the right by 1ts and do the same for the tail of the list. <br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; TL; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::boolalpha &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;TypeAt&lt;Find&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, TL&gt;::value, TL&gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h4>  Slice </h4><br><div class="spoiler">  <b class="spoiler_title">Slice</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> internal { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexBegin, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexEnd, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SliceHelper</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexBegin, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexEnd&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SliceHelper</span></span></span><span class="hljs-class">&lt;IndexBegin, IndexEnd, EmptyTypeList&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EmptyTypeList type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexBegin, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SliceHelper</span></span></span><span class="hljs-class">&lt;IndexBegin, IndexBegin, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeAt&lt;IndexBegin, TypeList&lt;Args...&gt;&gt;::type&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexBegin, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexEnd, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SliceHelper</span></span></span><span class="hljs-class">&lt;IndexBegin, IndexEnd, TypeList&lt;Args...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(IndexEnd &gt;= IndexBegin, <span class="hljs-string"><span class="hljs-string">"Invalid range"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Args...&gt; TL; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Add&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TypeAt&lt;IndexEnd, TL&gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SliceHelper&lt;IndexBegin, IndexEnd - <span class="hljs-number"><span class="hljs-number">1</span></span>, TL&gt;::type &gt;::type type; }; } <span class="hljs-comment"><span class="hljs-comment">// internal template&lt;unsigned int IndexBegin, unsigned int IndexAfterEnd, typename TL&gt; struct Slice { }; template&lt;unsigned int IndexBegin, unsigned int IndexEnd, typename ...Args&gt; struct Slice&lt;IndexBegin, IndexEnd, TypeList&lt;Args...&gt;&gt; { typedef typename internal::SliceHelper&lt;IndexBegin, IndexEnd, TypeList&lt;Args...&gt;&gt;::type type; }; template&lt;unsigned int Index, typename TL&gt; struct CutTo { }; template&lt;unsigned int Index, typename ...Args&gt; struct CutTo&lt;Index, TypeList&lt;Args...&gt;&gt; { typedef typename Slice&lt;0, Index, TypeList&lt;Args...&gt;&gt;::type type; }; template&lt;unsigned int Index, typename TL&gt; struct CutFrom { }; template&lt;unsigned int Index, typename ...Args&gt; struct CutFrom&lt;Index, TypeList&lt;Args...&gt;&gt; { private: typedef TypeList&lt;Args...&gt; TL; public: typedef typename Slice&lt;Index, Length&lt;TL&gt;::value - 1, TL&gt;::type type; };</span></span></code> </pre><br></div></div><br>  "Cuts" the specified part of the list: <br><ul><li>  From the empty list we can not take anything </li><li>  When the specified beginning ( <code>IndexBegin</code> ) and end ( <code>IndexEnd</code> ) are the same, it is similar to the <code>TypeAt</code> operation <code>TypeAt</code> <br>  Starting from the end of the specified range, take the element and add to the result of the recursive call (in which the end of the specified range is reduced by 1) <br></li><br><br>  Thanks for attention! </ul></div><p>Source: <a href="https://habr.com/ru/post/220217/">https://habr.com/ru/post/220217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220207/index.html">How we do Convead: from concept to implementation - part 1</a></li>
<li><a href="../22021/index.html">Google menu in South Korea</a></li>
<li><a href="../220211/index.html">Transition to PHP 5.5 and unit tests</a></li>
<li><a href="../220213/index.html">Welcome to Skyforge closed beta.</a></li>
<li><a href="../220215/index.html">We disassemble Sony Xperia Z2, the new flagship with an unusual cooling system</a></li>
<li><a href="../220219/index.html">We distribute 500K to the organization of circles of robotics</a></li>
<li><a href="../22022/index.html">Typical errors when creating an Internet startup. Experience of the project "I love cinema"</a></li>
<li><a href="../220225/index.html">HackDay City: from idea to prototype project for a city in 48 hours!</a></li>
<li><a href="../220227/index.html">What gets into deny ip any any?</a></li>
<li><a href="../220229/index.html">JSCS: JavaScript Code Style</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>