<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convenient data serialization with Variadic Templates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 During the development of my project, I needed to be able to write the contents of various data structures into binary files, and since the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convenient data serialization with Variadic Templates</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  During the development of my project, I needed to be able to write the contents of various data structures into binary files, and since they often contained lines, vectors and other data that change their size during execution, each such structure required an individual approach to organizing its translation in a sequence of bytes suitable for reverse reading, and using boost seemed to me cumbersome (and I don‚Äôt have it), and I wanted to solve this problem myself.  Because of this, I decided to make this process as less routine as possible and I decided to do this with the help of templates. <br><br>  The following data types are supported: <br>  - All fundamental types of C ++ <br>  - std :: string <br>  - std :: vector where T is anything from the same list <br>  - Any enumeration type <br><a name="habracut"></a><br><h4>  Release </h4><br>  I use Visual Studio 2013 as the development environment, but the solution code is cross-platform.  The class responsible for all the functionality I called AbstractSaveData.  It is used with the help of inheritance.  I decided not to make the class itself template, as this would make its use rather inconvenient, and the title still appears in the title.  Instead, only its methods will be template-based, and thus, using this class will never have to explicitly instantiate any template method. <br><br>  The class interface consists of the following methods: <br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializedSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanSerializedBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  The implementation of the first three methods should be in a descendant class. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The CleanSerializedBuffer method is used to clear the local buffer with serialized data.  There is nothing special about the implementation: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanSerializedBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] serializedBuf; serializedBuf = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  But this is only what concerns public methods.  The descendant class, whose data is to be serialized, will have to deal with the following protected-methods: <br><pre> <code class="hljs objectivec">template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...Ts&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Serialization(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;... objects); template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...Ts&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Deserialization(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buf, size_t size, Ts&amp;... objects); template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...Ts&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculateSize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;... objects)<span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* SerializedBuf()<span class="hljs-keyword"><span class="hljs-keyword">const</span></span>;</code> </pre><br>  The Serialization method is not hard to guess that it is serializing.  Method implementation: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serialization</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">objects</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serializedBuf) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] serializedBuf; m_size = CalculateSize(objects...); serializedBuf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[m_size]; ProcessSerialization(<span class="hljs-number"><span class="hljs-number">0</span></span>, objects...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_size; }</code> </pre><br>  First, the buffer size needed for the data is calculated and the corresponding amount of memory is allocated.  Then the data is immediately serialized. <br><br>  The implementation of the Deserialization method is similar in structure to the previous one: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Deserialization</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buf</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">objects</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read = CalculateSize(buf, objects...); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read != size) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ApproxException(<span class="hljs-string"><span class="hljs-string">L" "</span></span>); ProcessDeserialization(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(buf), objects...); } }</code> </pre><br>  Only here the size calculation is needed only for error control. <br><br>  Finally, the CalculateSize method, which calculates the space occupied by objects, has 2 options: <br><pre> <code class="hljs objectivec">template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculateSize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj)<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reqSize(obj); } template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...Ts&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculateSize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;... objects)<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reqSize(obj) + CalculateSize&lt;Ts...&gt;(objects...); }</code> </pre><br>  Here you can already observe recursion both at compile time and at run time.  Familiar with tuples in C ++ is not difficult to understand what is happening here.  It is worth mentioning that there are a total of 4 implementations of this method, the other two are in the private section and are not called directly from the inheriting class, but are called during deserialization. <br><br>  Well, the SerializedBuf method simply returns a pointer to the serialized data: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializedBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serializedBuf; }</code> </pre><br>  And finally, what they say "under the hood." <br><br>  Because of the number of methods, their simple listing and description will be too cumbersome and boring, so I will try to describe in general what will happen in the code below, and then actually present it. <br><br>  In total there are 3 groups of methods: <br><br>  First: recursive.  They provide the disclosure of the list of arguments, moving through the buffer and calling methods that produce processing objects in accordance with their type.  These are methods with the names CalculateSize, ProcessSerialization, ProcessDeserialization. <br><br>  The second: copying.  They perform serialization or deserialization at the level of an individual object and copy the resulting into the buffer or from it.  These are methods named CopyS and CopyD.  Methods named CopyS are used in the serialization process, and CopyD is used in deserialization. <br><br>  Third: auxiliary.  They calculate the space occupied at the level of an individual object.  These are methods named reqSize. <br>  In the code, explicit template specialization is actively used, as well as the standard type library tools std :: is_fundamental, std :: is_enum and std :: is_base_of, and with them std :: enable_if.  These tools allowed us to separate objects with a constant size from objects with a variable size.  For clarity and simplicity, I wrote my type-based type checking tool: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_simple</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Cat_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_fundamental&lt;T&gt;::value || <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value&gt; { };</code> </pre><br>  It simply combines many fundamental types and enumeration types, which is very convenient in our case, since in both cases the type of object can be used to unambiguously find out what size it is.  For convenience, we will call these types simple below. <br>  In general, the most common serialization is represented here - at the beginning of 4 bytes they store the size and then the data itself.  The exception is the simple types, they do not need a header, since information about their size corresponds to their type and is provided by the inheriting class during deserialization.  This reduces data redundancy. <br><br>  Special attention should be paid to arrays (vectors).  The array serialization method is selected based on the type of data it contains.  In this implementation, 2 options can occur: an array of simple types and an array of types derived from AbstractSaveData.  Regular structures are not supported, an attempt to use them will lead to a compilation error, but their implementation is not a problem, it is not required in my project, besides, their use removes the guarantee of successful serialization, since their contents are unknown and can be anything (pointers, same lines and vectors), and instead of them you can use the structure, with inheritance from AbstractSaveData. <br><br>  This is, perhaps, all that I could tell in theory.  Here is the code: <br><pre> <code class="hljs perl">template&lt;class T&gt; inline void ProcessDeserialization(const char* buf, T&amp; obj) { CopyD(buf, obj); } template&lt;class T, class ...Ts&gt; inline void ProcessDeserialization(const char* buf, T&amp; obj, Ts&amp;... objects) { ProcessDeserialization&lt;Ts...&gt;(buf + CopyD(buf, obj), objects...); } template&lt;class T&gt; inline void ProcessSerialization(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const T&amp; obj) { CopyS(<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, obj); } template&lt;class T, class ...Ts&gt; inline void ProcessSerialization(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const T&amp; obj, const Ts&amp;... objects) { <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> += CopyS(<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, obj); ProcessSerialization&lt;Ts...&gt;(<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, objects...); } //Copy Serialization methods begin template&lt;typename saveData&gt; inline typename std::enable_if&lt;std::is_base_of&lt;AbstractSaveData, saveData&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, saveData&amp; obj) { AbstractSaveData* data = dynamic_cast&lt;AbstractSaveData*&gt;(&amp;obj); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; auto ptr = data-&gt;Serialize(size); size += sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;size, sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), ptr, size - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); data-&gt;CleanSerializedBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } template&lt;typename T&gt; inline typename std::enable_if&lt;is_simple&lt;T&gt;::value,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const T&amp; obj) { memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;obj, sizeof(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sizeof(T); } inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const std::string&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = reqSize(obj); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;size, sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), obj.c_str(), size - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const std::pair&lt;const void*, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; obj) { memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;obj.second, sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), obj.first, obj.second); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.second + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;class T&gt; inline typename std::enable_if&lt;is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const std::vector&lt;T&gt;&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = reqSize(obj); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;size, sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), obj.data(), size - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } template&lt;class T&gt; inline typename std::enable_if&lt;!is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyS(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, const std::vector&lt;T&gt;&amp; objects) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = reqSize(objects); memcpy(serializedBuf + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, &amp;size, sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto obj : objects) { <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> += CopyS(<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } //Copy Serialization methods end //Copy Deserialization methods begin template&lt;class T&gt; inline typename std::enable_if&lt;is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyD(const void* buf, T&amp; obj) { memcpy(&amp;obj, buf, sizeof(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sizeof(T); } inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CopyD(const void* buf, std::string&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = *static_cast&lt;const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(buf) - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); obj.reserve(size); obj.assign(size, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); memcpy(&amp;obj[<span class="hljs-number"><span class="hljs-number">0</span></span>], static_cast&lt;const char*&gt;(buf)+sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;typename T&gt; inline typename std::enable_if&lt;is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyD(const void* buf, std::vector&lt;T&gt;&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = *static_cast&lt;const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(buf)-sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); obj.reserve(size / sizeof(T)); obj.assign(obj.capacity(), <span class="hljs-number"><span class="hljs-number">0</span></span>); memcpy(obj.data(), static_cast&lt;const char*&gt;(buf) + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) , size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;typename T&gt; inline typename std::enable_if&lt;!is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyD(const void* buf, std::vector&lt;T&gt;&amp; objects) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = *static_cast&lt;const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(buf); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remainedSize = size - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remainedSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { T obj; remainedSize -= CopyD(static_cast&lt;const char*&gt;(buf) + size - remainedSize, obj); objects.push_back(obj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainedSize &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) throw ApproxException(L<span class="hljs-string"><span class="hljs-string">"     ."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } template&lt;typename saveData&gt; inline typename std::enable_if&lt;std::is_base_of&lt;AbstractSaveData, saveData&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type CopyD(const void* buf, saveData&amp; obj) { AbstractSaveData* data = dynamic_cast&lt;AbstractSaveData*&gt;(&amp;obj); const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = *static_cast&lt;const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(buf); data-&gt;Deserialize(static_cast&lt;const char*&gt;(buf)+sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), size - sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } //Copy Deserialization methods end template&lt;typename simpleType&gt; inline typename std::enable_if&lt;is_simple&lt;simpleType&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(simpleType)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sizeof(simpleType); } template&lt;typename simpleType&gt; inline typename std::enable_if&lt;is_simple&lt;simpleType&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(const void*, simpleType)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sizeof(simpleType); } template&lt;typename saveData&gt; inline typename std::enable_if&lt;std::is_base_of&lt;AbstractSaveData, saveData&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(const saveData&amp; Data)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Data.SerializedSize() + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqSize(const std::string&amp; obj)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.size() + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;class T&gt; inline typename std::enable_if&lt;is_simple&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(const std::vector&lt;T&gt;&amp; obj)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.size() * sizeof(T) + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;class T&gt; inline typename std::enable_if&lt;!(is_simple&lt;T&gt;::value), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(const std::vector&lt;T&gt;&amp; objects)const { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto obj : objects) { res += reqSize(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqSize(const std::pair&lt;const void*, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; obj)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.second + sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } template&lt;typename notSimpleType&gt; inline typename std::enable_if&lt;!(is_simple&lt;notSimpleType&gt;::value), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type reqSize(const void* buf, const notSimpleType&amp;)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *static_cast&lt;const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(buf); } template&lt;class T&gt; inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculateSize(const void* buf, const T&amp; obj)const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reqSize(buf, obj); } template&lt;class T, class ...Ts&gt; inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculateSize(const void* buf, const T&amp; obj, const Ts&amp;... objects)const { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> = reqSize(buf, obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> + CalculateSize&lt;Ts...&gt;(static_cast&lt;const char*&gt;(buf) + <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, objects...); }</code> </pre><br><h2>  Usage example </h2><br>  And for what all this was?  So that you can write like this: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderPart</span></span></span><span class="hljs-class"> :</span></span> AbstractSaveData { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Str_code; Shader_Type Shader_Type = ST_NONE; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> EntryPoint; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;RuntimeBufferInfo&gt; BuffersInfo; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ParamsIDs; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; TextureSlots; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; size)</span></span></span><span class="hljs-function">override final </span></span>{ size = Serialization(Str_code, Shader_Type, EntryPoint, BuffersInfo, ParamsIDs, TextureSlots); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerializedBuf(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function">override final </span></span>{ Deserialization(buf, size, Str_code, Shader_Type, EntryPoint, BuffersInfo, ParamsIDs, TextureSlots); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializedSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CalculateSize(Str_code, Shader_Type, EntryPoint, BuffersInfo, ParamsIDs, TextureSlots); } };</code> </pre><br>  In principle, in order not to write the same variables in the methods and reduce the likelihood of inconsistency of the parameter lists (which will lead to very bad consequences), you can enter support for tuples and, instead of passing the argument list, pass one tuple to all methods. <br><br>  To all who took the time for my article - my gratitude, and for those who could endure to the end also respect. </div><p>Source: <a href="https://habr.com/ru/post/263599/">https://habr.com/ru/post/263599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263577/index.html">Competition of the user design from the Roketbank or how to order a bank card with the Habr logo</a></li>
<li><a href="../263581/index.html">Welcome to FPConf.ru</a></li>
<li><a href="../263591/index.html">Review and video of reports on information security from the conference SECR-2014</a></li>
<li><a href="../263595/index.html">When Chef and Puppet are not the solution. Part 1</a></li>
<li><a href="../263597/index.html">The finite element method on the example of the Poisson equation</a></li>
<li><a href="../263601/index.html">PHP Digest number 67 - interesting news, materials and tools (July 12 - 27, 2015)</a></li>
<li><a href="../263603/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ169 (July 19 - 25, 2015)</a></li>
<li><a href="../263605/index.html">Full guide to creating landing pages that sell</a></li>
<li><a href="../263607/index.html">Error in the Steam security system: password recovery without entering a verification code</a></li>
<li><a href="../263609/index.html">New warning about incorrect calculation of the size of the array in gcc 5.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>