<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Who is better or Walsh vs. Fourier</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the development of science and technology, the compression of information still remains one of the urgent problems, where video compression al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Who is better or Walsh vs. Fourier</h1><div class="post__text post__text-html js-mediator-article">  Despite the development of science and technology, the compression of information still remains one of the urgent problems, where video compression algorithms occupy a special place.  This publication will focus on the compression of static color images by JPEG-like algorithms. <br><br>  First I want to thank the author of the articles <a href="http://habrahabr.ru/post/102521/">"JPEG decoding for dummies"</a> and <a href="http://habrahabr.ru/post/206264/">"Inventing JPEG"</a> , which greatly helped me in my work on writing this publication.  When I took up the study of lossy image compression algorithms, then in part of the JPEG algorithm I was constantly tormented by the question: ‚ÄúWhy is the role of the basic transformation in the JPEG algorithm specifically for the special case of the Fourier transform?‚Äù.  <a href="http://habrahabr.ru/post/206264/">Here the</a> author gives an answer to this question, but I decided to approach it not from the point of view of a theory, mathematical models or software implementation, but from the point of view of circuit engineering. <br><br>  The JPEG image compression algorithm is a digital signal processing algorithm, which, in hardware, is usually implemented either on digital signal processors or on programmable logic integrated circuits.  In my case, the choice for the operation of a digital signal processor would mean coming to what I was trying to get away from - to a software implementation, so it was decided to stop at a programmable logic. <br><a name="habracut"></a><br>  In one of the online stores, I purchased a fairly simple <a href="http://www.starterkit.ru/html/index.php%3Fname%3Dshop%26op%3Dview%26id%3D61">debug board</a> , which contains Altera FPGA Cyclone 4 -EP4CE6E22 FPGA and SRAM 512Kx8 memory.  Since the FPGA was from Altera, it was decided to use the Quartus II Web Edition environment for development.  Development of individual functional blocks of the hardware codec was carried out in the <a href="https://ru.wikipedia.org/wiki/Verilog">Verilog language</a> , and assembly into a single scheme was carried out in the graphical editor of the Quartus II Web Edition environment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To communicate with a personal computer (receiving commands, receiving / transmitting the processed data), in Verilog I wrote a simple asynchronous <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2591%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA">UART</a> transceiver.  To connect to the COM-port ( <a href="https://ru.wikipedia.org/wiki/RS-232">RS-232</a> ) of the computer, based on the MAX3232WE chip and from what was at hand, hastily, the level converter was soldered.  In the end, here's what happened: <br><cut><br><img src="https://habrastorage.org/files/7f6/004/837/7f6004837f3b4269a54e2977dc249d0f.jpg" alt="image"><br><br>  For sending commands from a personal computer, as well as receiving and transmitting data, a trial version of the <a href="http://www.aggsoft.ru/serial-port-monitor.htm">ADVANCED SERIAL PORT MONITOR</a> program was used, which allows you to create not only individual parcels of data bytes, but also generate data streams from the file contents, and also record received data streams to a file, which allowed to send and receive files.  I do not use and control any protocols and checksums for receiving / transmitting data via UART (I was simply too lazy to envisage and implement all this); during the communication for receiving / transmitting, I used what is called ‚Äúraw data‚Äù. <br><br>  All arithmetic operations associated with fractional numbers in the codec are carried out in a <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D1%2581_%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B7%25D0%25B0%25D0%25BF%25D1%258F%25D1%2582%25D0%25BE%25D0%25B9">fixed-point</a> format, addition and subtraction operations are carried out in <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_(%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0)">an additional code</a> , in principle this is understandable.  How the bit depth of the processed data was determined will be described below. <br><br>  The compression operation is performed on the source images presented in the <a href="https://ru.wikipedia.org/wiki/BMP">.bmp</a> format with a color depth of 24 bits per pixel (8 bits for each of the color components). <br>  The memory available on the debug board was organized as follows: addresses from 00000h to 3FFFFh (in <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B5%25D1%2581%25D1%2582%25D0%25BD%25D0%25B0%25D0%25B4%25D1%2586%25D0%25B0%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">hexadecimal numbering system</a> ) were allocated for storing source data (picture in .bmp format for compression, or coded data for unpacking), totaling 256 KB, the remaining 256 KB space for recording received, as a result of data compression or decompression, these are addresses from 40000h to 7FFFFh.  I think it is obvious that the maximum size of compressible images is limited by the amount allocated for data storage, memory. <br><br>  The algorithm of the device operation is as follows: immediately after the power supply, the codec waits for a data stream via the UART, any data received, while the data is interpreted as an initial file for processing, if the pause between bytes is 10 ms, then this is interpreted as the end of the file and following the pause Bytes received by the UART are perceived by the device as a command.  Commands are specific byte values.  For example, after receiving a file after 10 ms, received by the UART codec, the value of byte AAh is interpreted by the device as a command that sends data from the memory chip to the computer via the UART, starting at address 40000h and ending with the value of the address at which the processed data was written i.e.  The results of compression / decompression are transmitted to the computer.  The value of EEh is interpreted as a command for compressing / decompressing an image, and also for debugging I provided a number of other commands. <br><br>  As for the structure of the file with the compressed image, then I decided not to bother, and, in contrast to the JPEG algorithm, the algorithm I implement is rather narrowly targeted and not designed for all occasions, therefore, the resulting data as a result of compression the stream is written to the allocated memory area.  The only thing that needs to be noted here is that in order not to implement the header generator for the .bmp file (it was also lazy), during compression, it is simply completely rewritten to the initial (from the address 40000h) memory area reserved for the final data, and then, starting with the offset from which pixel data is stored in the source .bmp file, compressed data is written.  This offset is stored in the header of the .bmp file at 0Ah relative to its beginning, and is typically 36h.  When unpacking, the same operation is performed accordingly. <br><br>  So, image compression of JPEG-like algorithms is performed in the following sequence: <br><ol><li>  color space conversion from <a href="https://ru.wikipedia.org/wiki/RGB">RGB</a> to <a href="https://ru.wikipedia.org/wiki/YCbCr">YCbCr</a> or <a href="https://ru.wikipedia.org/wiki/YUV">YUV</a> ; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2581%25D1%2583%25D0%25B1%25D0%25B4%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">color downsampling</a> ; </li><li>  base transform; </li><li>  quantization of coefficients obtained after the base transformation; </li><li>  zigzag scanning; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B4%25D0%25BB%25D0%25B8%25D0%25BD_%25D1%2581%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B9">run length coding</a> ; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D0%25B0%25D1%2584%25D1%2584%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Huffman</a> compression. </li></ol><br>  Unpacking is in reverse order. <br><br>  Of all the steps listed above, in the codec, I did not implement sub-sampling, as I considered it superfluous (maybe I‚Äôm wrong). <br><br>  Based on the above sequence of actions, I developed the following functional codec scheme: <br><br><img src="https://habrastorage.org/files/b60/dd4/6e6/b60dd46e65f549089b2ca86e7e68d9e3.jpg" alt="image"><br><br>  The codec operation process is controlled by a control device, which is a finite state machine, here the coding / decoding of run lengths is performed, as well as the generation of final data from Huffman codes during compression and the formation of the Huffman codes themselves from data received from the SRAM memory during unpacking.  The control unit also generates control signals for other operating units. <br><br>  Under the main circuit, there are diagrams of operating units, changing them in the main circuit, I changed the modes of operation of the device.  There was an attempt to collect everything into a single device and set the modes of operation of the codec, as well as methods of basic transformation using the commands on the UART, but the logical capacity of the FPGA was not enough.  Therefore, the operation modes of the device are changed by changing the corresponding operational blocks and the task of certain parameters in the control device (including the size of the compressible / unpacked image), after which the modified project is compiled and stitched into the FPGA. <br><br><h4>  Color Space Conversion </h4><br>  On the Internet you can find a lot of different information on the transformation of color spaces, so I will immediately begin with a description of the hardware implementation. <br><br>  The color space conversion block is a combinational logic, due to which the color components are transformed in one generator cycle.  The conversion of the RGB color space to YCbCr is performed by the following formulas: <br><br><img src="https://habrastorage.org/files/1c9/be0/03d/1c9be003d7c74feca11411a107ca0f45.png" alt="image"><br><br>  The calculation begins with the control device setting the starting address of the SRAM memory chip to the starting address from which the pixel data is stored in the .bmp file, as mentioned above, the starting address is 36h.  The .bmp files at this address store the value of the blue color component of the lowest right pixel of the image.  At address 37h, the value of the green color component, then red, then the blue component of the next pixel in the bottom line of the image again, etc. As you can see from the functional diagram, there is a register for each color component in the scheme.  After loading from memory all three color components into their registers, from the next clock of the generator recording of the results of calculations is carried out in memory.  So, the monochromatic red component ‚ÄúCr‚Äù is recorded at the address of the blue component ‚ÄúB‚Äù, the monochromatic blue component ‚ÄúCb‚Äù is recorded at the address of the green component ‚ÄúG‚Äù, and the component ‚ÄúY‚Äù is recorded at the address ‚ÄúR‚Äù.  As a result of this step, the same image in YCbCr format will appear in place of the original image in the SRAM memory in RGB format. <br><br>  For the hardware implementation of calculations of the brightness and monochromatic components, all fractional coefficients from the formulas were presented in the form of sixteen-bit words in a fixed-point format, where the upper eight bits contain an integer part, respectively, the lower eight bits have a fractional part.  For example, the coefficient 0.257 in binary representation with a fixed point looks like this: 0000000001000001 or in hexadecimal form 0041h.  The limited number of digits reduces the accuracy, so if the fractional binary number 0000000001000001 is converted to decimal form, we get: 2 ^ (- 2) + 2 ^ (- 8) = 0.25 + 0.00390625 = 0.25390625.  As you can see, the result differs from the value of 0.257 and in order to improve the accuracy of the presentation, the number of digits allocated for the fractional part should be increased.  But I decided to limit, as mentioned above, to eight digits. <br><br>  So, in the first stage of the conversion, the eight-bit values ‚Äã‚Äãof the RGB color components are converted to sixteen-bit in a fixed-point format by adding eight low-order bits filled with zero bits: <br><br><img src="https://habrastorage.org/files/b48/f72/7fa/b48f727faa4c4c90bcff8239ea27862a.png" alt="image"><br><br>  At the second stage, multiplication, addition and / or subtraction operations are carried out.  As a result, thirty-two-bit data is obtained, where the sixteen senior digits contain an integral part, and the sixteen low-order ones contain fractional part. <br>  In the third stage, eight-bit data is formed from the thirty-two-digit words obtained by selecting eight bits immediately before the comma (if the lowest-order bit is 0 and the oldest is 31, then these are bits 23 to 16): <br><br><img src="https://habrastorage.org/files/d8f/429/d94/d8f429d94fc14f1188be49d3ea21e2b1.png" alt="image"><br><br>  At the fourth stage, to the obtained eight-bit words, in accordance with the above-presented formulas, offsets are added (for component Y - 16, for components Cb, Cr - 128). <br><br>  Conversion from YCbCr to RGB is carried out according to the following formulas: <br><br><img src="https://habrastorage.org/files/339/09a/4f8/33909a4f8f784041afef9c3137979d8f.png" alt="image"><br><br>  Here there is such a feature that the results of calculations, in some cases, can acquire values ‚Äã‚Äãgreater than 255, which goes beyond one byte, or negative values, respectively, such situations need to be monitored. <br><br>  So, if an overflow occurs, the value of the resulting color component should be equal to 255; for this, we simply perform a bitwise logical OR operation of the result with an overflow bit.  And if the sign digit of the result is equal to one (i.e., the value is less than zero), then the value of the final color component should be 0, for this, we perform a bitwise logical operation ‚ÄúAND‚Äù of the result with the inverted value of the sign bit. <br><br>  So, at the first stage of converting the YCbCr color space into RGB, read from the SRAM memory chip, we translate the eight-bit values ‚Äã‚Äãof the luminance and monochromatic components into an additional ten-bit code, by adding two high-order zero bits (the sign bit and the overflow flag).  As a result, we get ten-bit words.  Further, in accordance with the formulas, we subtract from these values ‚Äã‚Äãof the offset (or add the negative values ‚Äã‚Äãof the offsets presented in the ten-bit additional code).  Then, we translate the result obtained from the additional code into the straight line, preserving the values ‚Äã‚Äãof the highest (sign) bit.  The remaining nine-bit words will be converted to eighteen-bit with a fixed point path, attributing the lower nine bits with zero bits: <br><br><img src="https://habrastorage.org/files/9e1/ea1/80e/9e1ea180e60c4363a0eea03933a7bd13.png" alt="image"><br><br>  Fractional coefficients appearing in the formulas are also represented in the form of an eighteen-bit code with a fixed point, where 9 bits are allocated for the integral and fractional parts.  As a result of multiplication operations, we get thirty-six-bit values ‚Äã‚Äãof products, in which 18 high-order bits - the whole part, 18 low-order bits - fractional.  Then we calculate the sign of the product by performing a logical operation ‚Äúaddition modulo 2‚Äù, a previously stored sign bit with a sign before the coefficient in the formula (if ‚Äú-‚Äù, then ‚Äú1‚Äù, if ‚Äú+‚Äù, then ‚Äú0‚Äù). <br><br>  It is also necessary to determine whether the result of the product is zero, if the result of multiplication is zero, then 0 must be written in the sign bit, regardless of the signs before the coefficients and the signs of the results obtained as a result of the offset of the components read from the memory.  To do this, apply the reduction operator (| product [35: 0]) to the product, which determines whether all the bits are equal to zero as a result of multiplication (if so, the result of the operation of this operator will be zero), and then perform a logical AND operation the result obtained with the result of the operation "addition modulo 2" sign digits. <br><br>  After all this, we translate the results of the multiplication into an additional thirty-seven-digit code, where the sign is stored in the most significant digit, and perform addition operations.  After the addition operations, obtained in the additional code, we translate the results into a direct code, and select eight bits immediately before the comma (if the number of the least significant bit 0 and the most significant one is 36, then these are bits 25 to 18).  Next, we check if there was an overflow; for this, as mentioned above, we perform a bitwise logical ‚ÄúOR‚Äù operation of eight bits allocated with an overflow sign, which is stored in the 26th digit.  And yet, we check whether a negative result is obtained, for which we perform a bitwise logical operation of the ‚ÄúAnd‚Äù of an inverted sign bit with the same eight bits: <br><br><img src="https://habrastorage.org/files/f62/fec/e5d/f62fece5d2f043658a9abcabe748682b.JPG" alt="image"><br><br>  The resulting, calculated by three formulas, and the converted eight-bit values ‚Äã‚Äãare the values ‚Äã‚Äãof the RGB color components. <br><br>  I decided to test the device using a 256 by 256 pixel photo of Lena Soderberg: <br><br><img src="https://habrastorage.org/files/73d/40b/bc2/73d40bbc21324e978917d6de667d9f39.jpg" alt="image"><br><br>  Everyone working in image processing works with this photo, and I decided not to be an exception. <br><br>  So, as a result of the conversion of the original photo loaded on the UART to the SRAM memory of the debug board, from the RGB color space to the YCbCr space, the following image was obtained: <br><br><img src="https://habrastorage.org/files/3eb/a20/738/3eba207389564899a42059b700933f05.jpg" alt="image"><br><br>  The picture below shows the original photo on the right, the photo on the left is the result of the inverse transformation from the YCbCr space into the RGB color space as described above: <br><br><img src="https://habrastorage.org/files/9ab/d43/846/9abd43846ff14217ae16f3c2fe2a786a.jpg" alt="image"><br><br>  When comparing the original and transformed photographs, you can see that the original photograph is brighter than the processed one, this is due to the loss of data that occurred during rounding (‚Äúgarbage‚Äù of the fractional part), as well as loss of accuracy, when representing fractional coefficients in binary form. <br><br><h4>  Basic transforms and quantization coefficients </h4><br><h5>  Discrete cosine transform </h5><br>  Information about what a discrete cosine transform (hereinafter referred to as DCT), on the Internet is present in sufficient quantity, so I‚Äôll dwell briefly on the theory. <br><br>  As mentioned in <a href="http://habrahabr.ru/post/206264/">this</a> publication, the essence of any basic transformation is reduced to multiplying the transformation matrix by the input data matrix, after which the result is again multiplied by the transposed matrix of the same transformation.  In the case of a discrete cosine transform, the coefficients of the transform matrix are calculated according to the following rule: <br><br><img src="https://habrastorage.org/files/284/141/1cc/2841411cc079419e81741e49b3743476.jpg" alt="image"><br><br>  Where: <br>  N is the dimension of the matrix; <br>  i, j - indices of matrix elements. <br><br>  In our case, N = 8, i.e.  the original image is divided into blocks of 8 by 8 pixels, while the values ‚Äã‚Äãof the indices i and j vary in the range from 0 to 7. <br><br>  As a result of applying this rule for N = 8, we obtain the following transformation matrix: <br><br><img src="https://habrastorage.org/files/348/501/950/34850195078d441d84213083b1687079.JPG" alt="image"><br><br>  In order not to carry out calculations with fractional numbers, we multiply each element of the matrix by 8‚àö8, and round the obtained values ‚Äã‚Äãof the elements of the matrix to integers, with the result that we get the matrix T: <br><br><img src="https://habrastorage.org/files/775/9bc/56e/7759bc56e54f4e9fa22f382b654a2196.JPG" alt="image"><br><br>  In this case, it will be necessary to divide the result of matrix multiplication, as in the case of direct discrete cosine transform when encoding, and in the case of the opposite when decoding, divided by 512. Given that 512 = 2 ^ (9), then division is done by shifting the dividend to the right by 9 positions. <br><br>  As a result of the direct discrete cosine transform, a matrix is ‚Äã‚Äãobtained of the so-called DCT coefficients, in which the element located in the zero row and the zero column is called the low-frequency coefficient and its value is always positive.  The remaining elements of the DCT matrix are high-frequency coefficients, the values ‚Äã‚Äãof which can be either positive or negative.  Considering this, and the fact that the elements of the resulting matrix must be eight-bit, for the low-frequency coefficient the range of values ‚Äã‚Äãwill be [0..255], and for high-frequency - [-127..127].  In order to meet these ranges, it is necessary to divide the results of the direct discrete cosine transform by 8, respectively, the results of the reverse are multiplied by 8. As a result, for the direct DCT we get the following formula: <br><br><img src="https://habrastorage.org/files/7a4/bff/a91/7a4bffa919e0446da7ac7c0a97d6614f.jpg" alt="image"><br><br>  Where: <br>  <i>C</i> - matrix of discrete cosine transform coefficients; <br>  <i>T</i> is the transformation matrix; <br>  <i>X</i> is a matrix of 8 by 8 brightness or monochromatic components (depending on which one, let's call it, the component plane Y, Cb or Cr is encoded). <br><br>  For the reverse DCT, we obtain the following formula: <br><br><img src="https://habrastorage.org/files/1d3/22b/3a3/1d322b3a3ebc4c64afecdd548bc19ce2.jpg" alt="image"><br><br>  The coefficients of the matrix T in the eight-bit format are stored in the ROM located on the FPGA chip in the direct code, while the most significant bit contains the sign. <br><br>  And so, at the first stage of the discrete cosine transform, from the SRAM memory to the operational block implementing the direct DCT, 64 bytes of one of the components are read (first the entire component plane Y is encoded, then Cb and Cr), forming part of the image, as was written earlier , 8 by 8 pixels in size (thus addresses for memory SRAM are generated in a special way): <br><br><img src="https://habrastorage.org/files/eb9/e4c/150/eb9e4c1500d34e0b9a7fb638cba58af5.jpg" alt="image"><br><br>  Computation operations in this block are carried out with twenty one-digit data: 12 low-order digits ‚Äî values ‚Äã‚Äãthat will be lost when divided by 4096 (2 ^ (12)), 8 digits ‚Äî the significant part and high-order is the sign, total: 12 + 8 + 1 = 21: <br><br><img src="https://habrastorage.org/files/5e0/8cf/355/5e08cf355bee42b0bf7ee0d5e3f3d69e.JPG" alt="image"><br><br>  Based on this, during loading, the eight-bit data in the operating unit is converted into twenty-one-bit words presented in the additional code by assigning the older thirteen bits filled with zero bits (the most significant bit is a sign), after which the resulting word is stored in the RAM buffer memory located Also, on the FPGA chip, into the address space from 00h to 3Fh (Quartus II did not allow creating RAM memory with the organization 128x21, so I had to use the memory with the organization 128x32). <br><br>  At the second stage, after 64 twenty-one-bit words are written into the buffer RAM (block 8 by 8), the matrix multiplication process is started.  ,   ROM      ,  ¬´¬ª   ,    ()  ,    ROM,   ()   .   ,      ,       ,     7 ‚Äì 19  : <br><br><img src="https://habrastorage.org/files/9db/960/f47/9db960f4761044c2b5d45604809955db.png" alt="image"><br><br> ,    RAM ,   ,   ,  ,            .    ,      : <br><br><img src="https://habrastorage.org/files/4ab/0ee/163/4ab0ee163b3841bf81ee8d0b8cbf4dc4.png" alt="image"><br><br>         ,  8  .     ( ,            ),         ,     RAM,     40h  7Fh.  ,    RAM,    40h ‚Äì 7Fh,    ,         ,     .    ROM,    , ,  ,      (   ,      ,      ). ,    ,       ,   ,         .      ,   ,        . <br><br>    .      ,  ,   ,       ROM   .       : <br><br><img src="https://habrastorage.org/files/13f/88e/0b2/13f88e0b2b364c6daaccd2ba6c7c6678.png" alt="image"><br><br>  Where: <br> <i>R</i> ‚Äì  ,           ; <br> <i>i, j</i> ‚Äì     ,     0  7. <br><br>    ,      Y, Cb, Cr      ,   R = 2 (   ,        ). <br><br>  ,     ,          : <br><br><img src="https://habrastorage.org/files/f1b/db6/353/f1bdb635392e4889a70c4a7c7bbc0c5e.png" alt="image"><br><br>  Where: <br> <i>a</i> ‚Äì  ,     ; <br> <i>b</i> ‚Äì    ,     ; <br> <i>c</i> ‚Äì  . <br><br> ,   ROM      -1 ( 1/b),      ,       8   ,       0. <br><br>       :          ,       , ,         ,   19  12        , 8    ,  ,   (  11  0    ,      4096). <br><br>     ,         0,        18  12  ,  8    , ,  .             1616,          ROM,      ,    -1. ,  8      ,   8  ‚Äì     ROM. <br><br> ,        ,   16   ‚Äì  ,  ,  8 ,     ,    (    ,    ‚Äì   ,      ). ,     ,     8,  7 ,    ,      ,      ,     : <br><br><img src="https://habrastorage.org/files/72b/986/2fb/72b9862fb0e94006afa1122b433e8e5a.JPG" alt="image"><br><br>   ,        RAM    00h ‚Äì 3Fh: <br><br><img src="https://habrastorage.org/files/ac8/e71/692/ac8e7169234e433d871d69aa48d9eb14.png" alt="image"><br><br>           - (  -   <a href="http://habrahabr.ru/post/206264/"></a> )       . <br><br>     .       : 6   ‚Äì ,      64, 8  ‚Äì  , 1  ‚Äì . : 6+8+1 = 15: <br><br><img src="https://habrastorage.org/files/eb8/af0/add/eb8af0addbc149f28bb981b25e150942.JPG" alt="image"><br><br>   ,    ,     ,     .  ,   ,       ,   ,   8    8    .     ,  7       7    ,   ,  ,       . <br><br>    15-       RAM    00h ‚Äì 3Fh     -.      RAM        8  8,      ,     .        RAM,     (  )      ,    ROM. <br><br>         ,     (  ,       -1).     ,    .        6   (  64)    ,      0,  8        Y, Cb  Cr (   ,    ).      1,   8    (..   0, ..       ). <br><br>          RAM, ,  ,   8  8.     ,        SRAM   ,  ,   ,     YCbCr. <br><br><h5>   </h5><br>  , -    ,    .   ‚Äì   ,      : <br><br><img src="https://habrastorage.org/files/438/3ca/c43/4383cac4361a4050b823029389291061.png" alt="image"><br><br>   ,    ,     , , ,           .      . <br><br> ,    ,           ,             .         1,  -1,        ,    .            8  8,          : <br><br><img src="https://habrastorage.org/files/a0b/f2c/611/a0bf2c611b2e42f8bad8e42998c89027.png" alt="image"><br><br>  Where: <br> p[0..7] ‚Äî    ; <br> x[0..7] ‚Äî    ,    8  8. <br><br>  ,          ,           : <br><br><img src="https://habrastorage.org/files/e26/f04/0bc/e26f040bc4da46a8b942fb0aab19470d.png" alt="image"><br><br>  Where: <br> y[0..7] ‚Äî    ; <br> p[0..7] ‚Äî    . <br><br>       ,     ,    ,     0,   63  ‚Äî  ,          0 (    ). <br><br> ,   ,       ,         ,      ,             ,   .   ,     ,         255,       64    6  . <br><br>          ,    ,      8  8      ,    . <br><br> ,         ,     ,    (6  ‚Äî        64, 8  ‚Äî  , 1  ‚Äî )      RAM.       8  8,       , ,       ,   .     RAM c  6415 (        12821),  Quartus II     RAM    6416,      (       11 ). <br><br>       ,    , ,          ,    ,         ,       RAM ,       -.      ,         RAM    -,       ,     . <br><br> ,   ,            : <br><br><img src="https://habrastorage.org/files/b65/140/da8/b65140da896b4c9ab7a9a49b356caa7e.png" alt="image"><br><br>    ,    ,    ,  ,    ,    RGB   YCbCr,         8  8       .     ,     .     ,   , ,  ,   ,   ,    . <br><br><h4>  Series Length Coding </h4><br>     , -,   ,    (RLE ‚Äì Run Length Encoding).         ,    (   ),     ,       , .. &lt; &gt;&lt;  ()&gt;. ,      ( ),     ,      . <br><br>  ,    ,      <a href="https://ru.wikipedia.org/wiki/PCX">.pcx</a> .    RLE   ,     -,       ,      .   ,         0h       .        C0h, (    ),     ,   ,   , ,       ,       1h.   ,    ,       ,  63=3Fh, ,     ,  ,      63,   ,   , ,    FFh (C0h( -)+3Fh( ) = FFh),     ,        . <br><br> ,      (        )    ,     RAM     -: ECh, C2h, 03h, 0Ah, 0Ah, D1h, D1h, 01h, 01h, 01h, 00h, 00h, 00h, 00h, 00h, 02h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h. ,    ,  RLE,    : C1h, ECh, C1h, C2h, 03h, C2h, 0Ah, C2h, D1h, C3h, 01h, C5h, 00h, 02h, F0h, 00h. <br><br> ,   ,    64 ,      16 ,        .     ,     ,  , ,    ,         ,      ,     . <br><br> ,    -        . <br><br>      ,     ,      ,       ,   ,     ,     , ,  ,    ,    ,       ,           ,         . <br><br>  ,   RLE              ,   RLE,           ( ,    ). <br><br><h4>     </h4><br>       ,    , ,    ,     .   ,      JPEG,    ,     ,  ,  . <br><br>    JPEG  ,   JPEG      ,    ,    ,    ROM     ,     ROM,         ,    .   JPEG        ,      ,   .           (  ) ,    ,        . <br><br>   :      ROM,    ( ,    RLE),  ,     ROM,    ,    ,          ROM.         ,      . <br><br> ,    ,      . ,    ,   ROM,   ,   4 ,       ‚Äì 11 ,  ‚Äì 3,   ‚Äì 4. ,  4+11+3+4 = 22, 22    8  2   6 ,   ,   ,    (      )   3  ,      , ..         . <br><br>       ,   AHDL (        ‚ÄúTABLE‚Äù, ,        Verilog    ‚Äúcase‚Äù,    ),      ,            . <br><br>   :    SRAM  ,      ,    ,          (  ),    ,   ,      . <br><br>    ,  , ,        ,   ,        ,        ,       RLE.     ,            ,         ,      .. <br><br><h4>      </h4><br>          ,       ,   .  ,   UART  ,     256  256      192 ,   ()       8,1 . <br><br>          ,       ,    .  ,      ()       43,8 . <br><br>          ,       ,   .  ,   UART  ,     256  256      192 ,   ()       8,17 . <br><br>          ,       ,    .  ,      ()       35,9 . <br><br>    ,  ,   . <br><br>  ,  ,     ,  ‚Äì ,    ,     ,  ‚Äì ,    ,     : <br><br><img src="https://habrastorage.org/files/2f0/5b8/533/2f05b85338e542fd98f892b3bec52ee9.png" alt="image"><br><br>          . ,         ,   ,       . <br><br>     ,     .      ,   ‚Äî  ,  ‚Äì ,      ,  ‚Äì   : <br><br><img src="https://habrastorage.org/files/635/4e7/ff8/6354e7ff89a04988a45229ec430a4527.png" alt="image"><br><br>   ,     ,    ,   ,   8  8, ,    ,     ,     ‚Äì  . ,         ,       . <br><br><h4>  Summarizing </h4><br>  ,   ,     ,    , ,  256  256     .bmp     (L.) 192 .     : 256√ó256 = 65536 ,        (1  ‚Äì  , 1  ‚Äì  , 1  ‚Äì  ),  65536√ó3 = 196608 ,   53  ‚Äì ,   196661   196661/1024 ‚âà 192   ¬´¬ª: <br><br><img src="https://habrastorage.org/files/4d4/786/0be/4d47860beb1447ff8834a4deff23a9dd.png" alt="image"><br><br>   ,        , , ,  ,      /.          ‚Äî . 1 ‚Äî 0    . <br><br>            ,   : <br><br><img src="https://habrastorage.org/files/5f2/fef/6af/5f2fef6afe3143f5ae3d3061aee1348d.JPG" alt="image"><br><br>    ,    ,    ,     .         . : 2 ‚Äî 0    . <br><br>  ,    ,        ,    ,  . <br><br>       ,     / , ,  ,   .      (  ,   )    /.     ,            ,    ,  (/) .  ,     / ‚Äî 24   ,     . <br><br>  ,   .  Thanks for attention! </cut></div><p>Source: <a href="https://habr.com/ru/post/264739/">https://habr.com/ru/post/264739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264725/index.html">ReactPHP speeds up PHPixie 8 times</a></li>
<li><a href="../264727/index.html">Security Week 33: Doors Without Locks, Microsoft Invulnerability, Disassembler and Pain</a></li>
<li><a href="../264731/index.html">Systemd logging control</a></li>
<li><a href="../264735/index.html">Five signs that you should hire this programmer right now</a></li>
<li><a href="../264737/index.html">Talking to FPConf speakers (part 2)</a></li>
<li><a href="../264741/index.html">How to become a cool designer for 365 days</a></li>
<li><a href="../264743/index.html">Fresh sections for the 2nd quarter of the popularity of CMS-systems, meters / systems analytics and online consultants</a></li>
<li><a href="../264747/index.html">Juniper Workshop: JunOS as a second language</a></li>
<li><a href="../264749/index.html">Huawei Enterprise Server Unit</a></li>
<li><a href="../264753/index.html">Cloud server in the Netherlands and the USA free of charge until October for registered users of habrahabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>