<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dataflow architecture. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, we looked at the main differences between the data flow architecture (dataflow) and the control flow architecture (c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dataflow architecture. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/7ca0db37/4240da0b/5e645562/729b6b83.png"><br>  In the <a href="http://habrahabr.ru/blogs/hi/122479/">first part of the</a> article, we looked at the main differences between the data flow architecture (dataflow) and the control flow architecture (controlflow), made a tour in the 1970s, when the first hardware dataflow machines appeared and compared the static and dynamic flow calculation models.  Today I will continue to introduce you to dataflow architectures.  Welcome under the cut! <br><br><a name="habracut"></a><br><h2>  In addition to the above: the implementation of cycles in dynamic flow systems </h2><br>  Consider in more detail the work of the context on the example of the organization of cycles.  I recall that the <em>context</em> is a field in the token structure that uniquely identifies an instance of the dataflow node.  In the case of loops, the context will be the iteration number. <br><br><h3>  Example 1. Fibonacci numbers </h3><br>  Calculating Fibonacci numbers is a classic example of a loop with data iteration dependency.  Nth number is equal to the sum of (N-1) -th and (N-2) -th: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fib [MAX_I]; fib [<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; fib [<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; MAX_I; i++) { fib [i] = fib [i<span class="hljs-number"><span class="hljs-number">-1</span></span>] + fib [i<span class="hljs-number"><span class="hljs-number">-2</span></span>]; }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Construct a flow calculation graph: <br><img src="http://habrastorage.org/storage1/11fee68c/d3b617dc/f1d89214/84c76ea5.png"><br><br>  It is easy to see that a graph consists of (MAX_I-2) identical nodes that differ only in the context values ‚Äã‚Äã(the numbers below the node image).  The logic of the node (in pseudocode) will look like this: <br><pre> <code class="sql hljs"> fib (:  A,  B)  i = _(A);  result = _(A) + _(B); _ (: result, : host, : i);  (i &lt; MAX_I-1) _ (: result, : fib, : i+1); _ (: result, : fib, : i+2);     fib</code> </pre><br><br>  To start the program, you need to send three tokens: <br><pre> <code class="sql hljs">_ (: 1, : fib, : 2); _ (: 1, : fib, : 2); _ (: 1, : fib, : 3);</code> </pre><br><br>  As a result of the execution of a streaming program, a set of tokens will be sent to the host, each of which will carry the number of the Fibonacci number in the context field, and the number itself in the data field.  Please note that another token (marked with a dotted line in the column) is sent ‚Äúto nowhere‚Äù, more precisely, it never starts the execution of the node due to the absence of a token paired with it.  You can get rid of it either by adding one more condition check (i &lt;MAX_I-2) in the node code, or by organizing a software or hardware ‚Äúgarbage collector‚Äù. <br><br><h3>  Example 2. Addition of matrices </h3><br>  We now consider an example where there is no dependence between iterations on data: the addition of matrices <nobr>C [i, j] = A [i, j] + B [i, j].</nobr> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A [MAX_I][MAX_J]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B [MAX_I][MAX_J]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C [MAX_I][MAX_J]; GetSomeData (A, B); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_I; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; MAX_J; j++) { C[i,j] = A[i,j] + B[i,j]; }</code> </pre><br><br>  All (MAX_I * MAX_J) iterations can be performed simultaneously.  Here is the graph of matrix additions: <br><img src="http://habrastorage.org/storage1/c6a1e9d2/69fe30ef/c7b53a9b/ff26ab13.png"><br><br>  The context in this case is a structure of two coordinates {i;  j}.  Given this, the graph node will look like this: <br><pre> <code class="sql hljs"> add (:  A,  B)  {i, j} = _(A);  result = _(A) + _(B); _ (: result, : host, : {i, j});   add</code> </pre><br><br>  Please note that there are no border checks here!  The number of iterations is automatically selected based on the dimension of the input data.  Input data, by the way, should come in this form: <br><pre> <code class="sql hljs">_ (: A[0, 0], : add, : {0, 0}); _ (: B[0, 0], : add, : {0, 0}); _ (: A[0, 1], : add, : {0, 1}); _ (: B[0, 1], : add, : {0, 1}); ... _ (: A[MAX_I-1, MAX_J-1], : add, : {MAX_I-1, MAX_J-1}); _ (: B[MAX_I-1, MAX_J-1], : add, : {MAX_I-1, MAX_J-1});</code> </pre><br><br>  Dataflow systems are very efficient for processing <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B5%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0">sparse</a> data, since only significant elements are actually sent and processed. <br><br><h1>  Hybrid Dataflow Architecture </h1><br>  ‚ÄúClean‚Äù streaming architectures like those described by the MIT Static Dataflow Machine and the Manchester Dataflow Machine unfortunately had many weak points: <br><ul><li>  Dataflow machines offered tremendous opportunities for concurrency execution.  The flip side of this advantage was that in successive areas of the computation graph, they showed a sharp drop in performance. </li><li>  Download actuators was far from the maximum possible.  Most of the machine time was spent searching for matching operands, fetching instructions, and the actuator was idle all that time, executing only one instruction for each pair of tokens. </li><li>  The design of matching devices was difficult.  Associative memory is more complicated, more expensive, slower, takes up more space and consumes more energy, compared with conventional RAM of the same amount. </li><li>  The principle of data flow control did not allow organizing an efficient pipeline.  Almost all devices worked asynchronously, buffers and queues in communication lines were required. </li><li>  Compared with the classical multiprocessor architecture, the dataflow machines have a much higher load on the switching network.  After all, in fact, each operation required the transfer of two tokens. </li></ul><br>  In an attempt to solve these problems, hybrid architectures began to appear, combining elements of both data flow architectures and control flow. <br><br><h2>  Threaded dataflow </h2><br>  This term has no adequate translation into Russian at all.  The essence of this approach is to replace successive sections of the computational graph, which cannot be parallelized, to be replaced <em>with</em> threads (threads) - sets of sequentially executed instructions.  ‚ÄúExtra‚Äù intermediate tokens disappear immediately, and the load on the actuators increases.  The principles of threaded dataflow were implemented ‚Äúin hardware‚Äù in the Epsilon processor <a href="https://habr.com/ru/post/122530/">[21]</a> in 1989. <br><br><h2>  Coarse Data Flow Architecture </h2><br>  The further development of threaded dataflow is the so-called <em>coarse-grained</em> streaming architecture (large-grain dataflow).  When it became clear that the parallelism of "pure" dataflow in many cases is redundant, the decision arose to build a flow graph not from individual operators, but from blocks.  Thus, in a coarse-grained architecture, each node is not a single instruction, but a classic sequential program.  The interaction between nodes is still based on the data flow principle.  One of the advantages of this approach was the ability to use conventional background Neumann processors as executive devices.  It should be noted that despite the name ‚Äúcoarse-grained‚Äù, the blocks into which the task is broken are still much smaller than, say, in cluster systems.  A typical block size is 10-100 instructions and 16-1K bytes of data. <br><br><h2>  Vector dataflow architecture </h2><br>  In vector streaming systems, a token contains not one value, but a set at once.  Accordingly, operations are performed not on pairs of operands, but on pairs of vectors.  An example of such a system is the SIGMA-1 (1988) <a href="https://habr.com/ru/post/122530/">[22]</a> .  Sometimes vector mode is supported only by a part of the system executive devices.  Often, hybrid architectures are also used that combine several approaches at once, for example, a coarse-grained architecture with the ability to perform vector operations. <br><br><h1>  Reconfigurable systems </h1><br>  The development of FPGA technologies has made possible a fundamentally new approach to the dataflow architecture.  What if you assemble a machine that is focused on solving one specific problem?  If you implement the necessary computational graph directly at the circuit level, you can achieve amazing results.  Instead of complex and slow mapping devices, you can use unconditional data redirection from one function module to another.  The actuators themselves can also be ‚Äúsharpened‚Äù for the desired task: choose the type of arithmetic, bit depth, the necessary set of supported operations. <br>  Of course, such a machine will be very highly specialized, but after all the advantage of the FPGA is precisely in the possibility of repeated reprogramming.  Thus, for each individual task is going to the desired architecture.  Some systems even allow you to reconfigure right in the process.  Reconfigurable systems based on FPGA chips are currently commercially available in a variety of formats - from the ‚Äúaccelerator‚Äù block for a PC to a system with a capacity of the order of several teraflops <a href="https://habr.com/ru/post/122530/">[31]</a> . <br>  Among the disadvantages of reconfigurable architectures are the following: <br><ul><li>  Principal mono-task.  To start a new task, you need to stop the system and reprogram the FPGAs that are part of it. </li><li>  The complexity of programming.  The programming of each task includes the synthesis of the entire computational architecture for this task. </li><li>  Excessive hardware complexity.  The downside of FPGA flexibility is the presence of a large percentage of elements on the chip, which are not directly involved in the calculations, but serve only for reconfiguration.  However, these elements consume energy and generate heat during operation, which impairs the system‚Äôs energy performance indicators (Gflops / W). </li></ul><br><br><h1>  Programming for dataflow architecture </h1><br>  Programming in the dataflow paradigm is significantly different from the usual structural, and closer rather to functional.  There are no variables, arrays and other named memory areas, no called procedures and functions in the usual sense of the word.  Stream programming uses the principle of <a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)">one-time assignment</a> .  Each data unit (as a rule, it is a token) is given a value only once, when created, and can only be read later.  This principle reflects the unidirectionality of the branches of the computational graph. <br>  In dataflow, unfortunately, no programming standard was developed.  Usually for each architecture developed its own language.  I'll tell you about some of the most famous. <br><br><h2>  Val </h2><br>  VAL (Value-oriented Algorithmic Language) <a href="https://habr.com/ru/post/122530/">[41]</a> was developed at the Massachusetts Institute of Technology (MIT) in 1979 specifically for the MIT Dataflow Machine.  Here‚Äôs how, for example, factorial calculation on VAL looks like: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Y:<span class="hljs-type"><span class="hljs-type">integer</span></span> := <span class="hljs-number"><span class="hljs-number">1</span></span>; P:<span class="hljs-type"><span class="hljs-type">integer</span></span> := N; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> P ~= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> iter Y := Y*P; P := P<span class="hljs-number"><span class="hljs-number">-1</span></span>; enditer; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Y endif endfor</code> </pre><br><br><h2>  Sisal </h2><br>  SISAL (Streams and Iteration in a Single Assignment Language) <a href="https://habr.com/ru/post/122530/">[42]</a> , which appeared in 1983, is a further development of VAL.  Unlike VAL, SISAL allows recursion. <br>  Calculation of factorial: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> factorial( n : <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n * factorial( n - <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre><br><br>  Option without recursion from <a href="http://habrahabr.ru/users/middle/" class="user_link">middle</a> habrauzer: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> factorial (n : <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, n <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> prod i <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre><br><br><h2>  Id </h2><br>  Id <a href="https://habr.com/ru/post/122530/">[43]</a> is a parallel general purpose language, created in the late 1970s - early 1980s at MIT.  Further work on the Id led to the development of the pH language - a parallel Haskell dialect. <br>  Factorial on Id: <br><pre> <code class="hljs matlab">( initial <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt;- n; k &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> do new <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt;- <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; new k &lt;- k * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k )</code> </pre><br>  A graph of calculations for this program will look like this: <br><img src="http://habrastorage.org/storage1/41cbeb58/5771696d/171fce25/0f2070a7.gif"><br><br><h2>  Lucid </h2><br>  The Lucid language <a href="https://habr.com/ru/post/122530/">[44]</a> <a href="https://habr.com/ru/post/122530/">[45] was</a> developed in 1976 by Bill Wadge and Ed Ashcroft.  Operates with the concepts of value streams (analogue of variables) and filters, or converters (analogue of functions). <br>  Factorial on Lucid: <br><pre> <code class="hljs pgsql">fac <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> fby (n + <span class="hljs-number"><span class="hljs-number">1</span></span>); fac = <span class="hljs-number"><span class="hljs-number">1</span></span> fby ( fac * (n + <span class="hljs-number"><span class="hljs-number">1</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h2>  Quil </h2><br>  Quil (2010) <a href="https://habr.com/ru/post/122530/">[46]</a> is a language based on Lucid, currently working on it.  There is an online interpreter on the language site, so I leave the factorial calculation on Quil as an independent task for the readers. <br><br><h1>  Conclusion </h1><br>  The ‚Äúboom‚Äù of streaming architectures fell on the 1970s ‚Äì 1980s, then the interest in dataflow gradually subsided.  Nowadays, elements of streaming computers can be found in the architecture of DSP (signal processors), network routers and graphics processors.  But gradually, an increasing number of specialists are again turning to the dataflow paradigm within high-performance computing.  This can probably be attributed to the fact that today the Von Neumann architecture is approaching its limit of scalability, and new approaches are required to further improve performance. <br>  Somewhat apart are reconfigurable architectures, in which the line between software and hardware is gradually erased.  What technology is the future behind?  The question remains open. <br><br>  <b>Bonus Game.</b>  To the most inquisitive readers, I suggest trying to determine which graphs of the algorithms are depicted in ‚Äúpictures to attract attention‚Äù in the title of each part of the article.  Good luck! <br><hr><br><h2>  Literature </h2><br>  The numbering of the sources continues from the first part. <br><br><h3>  Hybrid dataflow systems </h3><br><a name="ref-21"></a>  <a href="http://mprc.pku.cn/mentors/training/ISCAreading/1989/p36-grafe/p36-grafe.pdf">[21]</a> - The Epsilon dataflow processor, VG Grafe, GS Davidson and others. <br><a name="ref-22"></a>  <a href="http://portal.acm.org/citation.cfm%3Fid%3D63020%26dl%3DACM%26coll%3DDL%26CFID%3D30320823%26CFTOKEN%3D13257649">[22]</a> - Efficient vector processing of the supercomputer SIGMA-1, K. Hiraki, S. Sekiguchi, T. Shimada. <br><br><h3>  Reconfigurable systems </h3><br><a name="ref-31"></a>  <a href="http://fpga.parallel.ru/papers/dmitrenko.pdf">[31]</a> - Family of multiprocessor computing systems with dynamically tunable architecture, N.N.  Dmitrienko, I.A.  Kalyaev and others. <br><a name="ref-32"></a>  <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp%3Farnumber%3D4380734">[32]</a> - Dynamically Reconfigurable Multi-FPGA Platforms, Voigt, S.-O., Teufel, T. <br><br><h3>  Dataflow programming languages </h3><br><a name="ref-41"></a>  <a href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-218.pdf">[41]</a> - VAL - A Value-oriented Algorithmic Language <br><a name="ref-42"></a>  <a href="http://www2.cmp.uea.ac.uk/~jrwg/Sisal/00.Contents.html">[42]</a> - Sisal Language Tutorial <br><a name="ref-43"></a>  <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.18.4920%26rep%3Drep1%26type%3Dpdf">[43]</a> - ID Language Reference Manual, Rishiyur S. Nikhil, 1991 <br><a name="ref-44"></a>  [44] - LUCID, the dataflow programming language, Academic Press Professional, Inc.  San Diego, CA, USA 1985 ISBN: 0-12-729650-6 <br><a name="ref-45"></a>  <a href="http://www.artima.com/weblogs/viewpost.jsp%3Fthread%3D102839">[45]</a> - Fluid Programming in Lucid <br><a name="ref-46"></a>  <a href="http://sites.google.com/site/quilweb/home">[46]</a> - The Quil Language </div><p>Source: <a href="https://habr.com/ru/post/122530/">https://habr.com/ru/post/122530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122523/index.html">Using Access Control Service 2.0 for authorization in your applications</a></li>
<li><a href="../122524/index.html">Google AdSense or wood chopping - chips fly</a></li>
<li><a href="../122525/index.html">New model reader Lbook V60</a></li>
<li><a href="../122528/index.html">Auto-generating APK with various data from the command line using Ant</a></li>
<li><a href="../122529/index.html">MTBF - where does a million hours MTBF come from?</a></li>
<li><a href="../122531/index.html">Fast full-text search ElasticSearch</a></li>
<li><a href="../122533/index.html">Losing innocence: about the design of your first app</a></li>
<li><a href="../122535/index.html">NUMA and what does vSphere know about it?</a></li>
<li><a href="../122536/index.html">Volkswagen after Google showed cars with autopilot</a></li>
<li><a href="../122537/index.html">Secured data channel using self-signed SSL certificates and Stunnel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>