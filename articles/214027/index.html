<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Massively parallel image stabilization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Good day! Today I decided to share with you the secret - one of my favorite bikes. 

 I will start from afar - for quite a long time I work...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Massively parallel image stabilization</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/54f/ac1/fb3/54fac1fb35c674e4ebf88bbc7b680175.png" alt="image"><br><h5>  Foreword </h5><br>  Good day!  Today I decided to share with you the secret - one of my favorite bikes. <br><br>  I will start from afar - for quite a long time I worked at one radio factory in Chelyabinsk, and we had (in general, and now have, I‚Äôm just not there already) one mega-project: an optical-electronic module for the protection of physical objects.  This is such a healthy thing on a rotating installation, with three cameras for all occasions (color - day, B &amp; W photosensitive - for twilight, and a thermal imager - for night observation).  Such a module is taken, placed on a tower 50 meters in height - and it is possible, day and night, to keep under surveillance a territory within a radius of 4-5 kilometers.  Details I will not write, not about that post.  To whom it is interesting - they will find. <br><br>  Of course, there were many interesting image processing tasks.  On one of these, I want to tell.  Namely, how to use massive parallel computing to compensate for camera shake in real time, or why SURF is not always suitable.  Welcome under cat. <br><a name="habracut"></a><br><h5>  The essence of the problem </h5><br>  As I mentioned earlier - the modules are placed on rather high towers.  Because of the strong wind at such a height, they are constantly shaking small, and the smaller the viewing angle of the camera is, the more noticeable it is.  And the cameraman should observe the camera image, and for a rather long time (shift).  It is very hard, it may be banal to vomit.  That is why one of the main requirements for such systems is the presence of a mechanism to minimize the shaking of the picture.  Somewhere gyro-stabilized platforms are used for this, but far from everywhere.  The most commonly used software stabilization, and most often - it is SURF.  But it is suitable for this bad. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Why SURF and similar algorithms are bad for this </h5><br>  In order: <br><br>  1 - SURF is not intended for this.  The only thing we need to solve this problem is to find the offset of the new frame relative to the previous one, in pixels.  The camera does not rotate along the image plane, and does not move closer or further to the image.  SURF is more suitable for tracking moving objects in a video sequence, but not for finding the displacement of the entire image. <br><br>  2 - Speed.  I will not go into details, I will only say that the time limits are serious - the algorithm must find the offset between the last two frames in less than 13 milliseconds.  As less as possible.  From SURF we didn‚Äôt even get that close. <br><br>  3 - Interference.  The displacement of control points, but not the entire frame, is analyzed.  Due to mapping errors, there are problems with filtering out false matches, which are quite difficult to solve.  On a lively picture, this caused rare ‚Äújerks‚Äù of the image in one direction or another. <br><br><h5>  My bike </h5><br>  By the time I started to solve this problem, I already had some experience with <a href="http://www.nvidia.ru/object/cuda-parallel-computing-ru.html">nVidia CUDA</a> .  Rewrote a couple of video processing filters - brightness, contrast.  The increase in speed compared to processing on the CPU has made me incredibly pleased, it was from that time that I was carried away by massively parallel computing and GPGPU in particular. <br><br>  I decided to use massive-parallel computations for solving this problem.  At first I was looking for ready-made solutions, I tried.  I was looking for a SURF implementation on CUDA, but, as far as I remember, I did not find anything suitable.  And he decided to invent his own.  <a href="http://habrahabr.ru/users/bigobfuscator/" class="user_link">By the way</a> , I came <a href="http://habrahabr.ru/users/bigobfuscator/" class="user_link">across a</a> great <a href="http://habrahabr.ru/post/102919/">article by</a> Comrade <a href="http://habrahabr.ru/users/bigobfuscator/" class="user_link">BigObfuscator</a> , after which I realized which way I was going to dig. <br><br>  I called the algorithm "Ratel Deshake", and it consists of 3 stages: <br>  - preparation of the new frame <br>  - transfer of a frame to a segment-integral representation <br>  - search for the best match <br><br>  All three stages are quite well suited for massively-parallel processing.  I implemented it on CUDA, but, as far as I understand, all this can be implemented quite well on FPGA, for example. <br><br><h5>  Preparing a new frame </h5><br>  At this stage, you need to remove everything that does not interest us from the input data.  More precisely - the color, and, if possible, interference.  For this I used the transfer of the image in black and white and the selection of contours with a threshold.  If in the form of code, then something like this: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pixel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> R, G, B; } pixel Image[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GSImage[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> processedImage[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { GSImage[x, y] = Image[x, y].R + Image[x, y].G + Image[x, y].B; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>; y &lt; height; y++) { preprocessedImage[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GSImage[x, y] - GSImage[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y] &gt; threshold) preprocessedImage[x, y]++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GSImage[x, y] - GSImage[x, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; threshold) preprocessedImage[x, y]++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GSImage[x, y] - GSImage[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y] &gt; threshold) preprocessedImage[x, y]++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GSImage[x, y] - GSImage[x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; threshold) preprocessedImage[x, y]++; } }</code> </pre> <br><h5>  Frame transfer to the segment-integral representation </h5><br>  Perhaps the most interesting stage.  First you need to clarify some points. <br><br>  Firstly, what is the integral representation of the image.  This can be understood by reading here this <a href="http://habrahabr.ru/post/102919/">article</a> , if you have not done this on the link above.  In short, this is a two-dimensional (in our case) array, in which an element with X and Y coordinates is equal to the sum of all elements of the original array with coordinates [0..X, 0..Y]. <br><br>  Secondly, what I call the segment-integral representation.  Because of the features of my algorithm, we need a two-dimensional array in which an element with X and Y coordinates is equal to the sum of all elements of the original array with coordinates [(XN) .. X, (YM) .. Y], where N and M are arbitrary numbers affecting the speed / accuracy ratio of the algorithm.  For example, I used the values ‚Äã‚Äã15 and 15, i.e.  the element in the resulting array was a sum of 256 elements (a 16x16 square) of the original array.  Yes, in fact this is some kind of image blur. <br><br>  But back to the integral representation of the image.  Through some thought it can be understood that in one stream it can be optimally calculated as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Image[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> processedImage[width, height]; processedImage[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = Image[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x &lt; width; x++) { processedImage[x, <span class="hljs-number"><span class="hljs-number">0</span></span>] = Image[x, <span class="hljs-number"><span class="hljs-number">0</span></span>] + processedImage[x<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>; y &lt; height; y++) { processedImage[<span class="hljs-number"><span class="hljs-number">0</span></span>, y] = Image[<span class="hljs-number"><span class="hljs-number">0</span></span>, y] + processedImage[<span class="hljs-number"><span class="hljs-number">0</span></span>, y<span class="hljs-number"><span class="hljs-number">-1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>; y &lt; height; y++) { processedImage[x, y] = Image[x,y]+processedImage[x<span class="hljs-number"><span class="hljs-number">-1</span></span>,y]+processedImage[x,y<span class="hljs-number"><span class="hljs-number">-1</span></span>]-processedImage[x<span class="hljs-number"><span class="hljs-number">-1</span></span>,y<span class="hljs-number"><span class="hljs-number">-1</span></span>]; } }</code> </pre><br>  But there is one problem.  It is not possible to break this part of the algorithm into a large number of threads.  Or will it work out?  Of course.  It is enough to divide it into two separate stages - horizontally and vertically.  Then each of these stages is perfectly paralleled by the number of streams equal to the number of pixels horizontally and vertically, respectively.  Like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Image[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> horizontalImage[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> processedImage[width, height]; <span class="hljs-comment"><span class="hljs-comment">//  for (int y = 0; y &lt; height; y++) { horizontalImage[0, y] = Image[0, y]; for (int x = 1; x &lt; width; x++) { horizontalImage[x, y] = Image[x, y] + horizontalImage[x-1, y]; } } //  for (int x = 0; x &lt; width; x++) { processedImage[x, 0] = horizontalImage[x, 0]; for (int y = 1; y &lt; height; y++) { processedImage[x, y] =horizontalImage[x, y] + processedImage[x, y-1]; } }</span></span></code> </pre><br>  And now the same thing, but for the segment-integral representation with N = M = 15: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Image[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> horizontalImage[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> processedImage[width, height]; <span class="hljs-comment"><span class="hljs-comment">//  for (int y = 0; y &lt; height; y++) { horizontalImage[0, y] = Image[0, y]; for (int x = 1; x &lt; 16; x++) { horizontalImage[x, y] = Image[x, y] + horizontalImage[x-1, y]; } for (int x = 16; x &lt; width; x++) { horizontalImage[x, y] = Image[x, y] + horizontalImage[x-1, y] - Image[x-16, y]; } } //  for (int x = 0; x &lt; width; x++) { processedImage[x, 0] = horizontalImage[x, 0] for (int y = 1; y &lt; 16; y++) { processedImage[x, y] = horizontalImage[x, y] + processedImage[x, y-1]; } for (int y = 16; y &lt; height; y++) { processedImage[x, y] = horizontalImage[x, y] + processedImage[x, y-1] - horizontalImage[x, y-16]; } }</span></span></code> </pre><br>  Such a small witch.  In fact, you can parallelize even more if you divide the image into several separate parts, but these are already separate dances with a tambourine.  In any case, after all this, we have a segment-integral representation of the image.  At this stage, one more important thing needs to be done - besides the choice of N and M, it is necessary to choose how many ‚Äúblocks‚Äù will be compared. <br><br>  This point is also worth explaining in detail.  The fact is that when searching for the optimal match, it is the match between the previous frame and the new one that is sought, and not vice versa.  After the iteration of the algorithm has passed - for the next iteration, there is data on the previous frame, but not all, but only the values ‚Äã‚Äãof a certain number of blocks (in my case, having a size of 16x16).  This is another factor affecting the speed / accuracy ratio.  Less blocks - more speed, more blocks - more accuracy. <br><br>  Specifically, in my case, the image size was 704x576 pixels.  From the segment-integral representation of the <u>previous</u> frame, I left the values ‚Äã‚Äãof only 1,140 segments (38x30 blocks from the center of the image, not mutually overlapping, 4560 bytes).  It will be clearer in the form of a picture: <br><img src="http://habrastorage.org/files/e0a/d6c/f38/e0ad6cf387354c16958169d08487a4cf.png" alt="image"><br>  Here we have a hypothetical image of 256x256 pixels.  For convenience, it is divided into separate blocks of 16x16 pixels (although in the segment-integral representation of the blocks there are much more, and they overlap each other).  In the center, an array of blocks is allocated, 10 to 10 pieces.  It is the value of these blocks that must be remembered for use in the next iteration of the algorithm.  In the code, it will look something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegralImage[<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NextIteration[<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; y++) { NextIteration[x, y] = IntegralImage[(x+<span class="hljs-number"><span class="hljs-number">4</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>, (y+<span class="hljs-number"><span class="hljs-number">4</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>]; } }</code> </pre><br>  Why we need this array will become clear in the next step. <br><br><h5>  Search for the best match </h5><br>  Almost everything, final straight.  If only one frame was passed through the algorithm, this stage should be skipped (there is nothing to stabilize yet).  If this is not the first frame - from the previous iteration you should have an array of NextIteration.  Since it should remain from the <u>previous</u> iteration - at this stage it will be called PrevIteration, do not confuse. <br><br>  So, we have a segment-integral representation of the new frame and an array of control blocks from the previous one.  At this stage, all you need is to find a position in which the superposition of the blocks of the previous frame onto the segment-integral representation of the new frame will give the minimum difference. <br><br>  An important note is that there is not much point in checking all possible positions, it is better to set the maximum expected deviation in pixels by a constant.  For example - plus or minus 30 pixels in X and Y. <br><br>  First of all, we need an array that displays the difference at a particular offset.  An example in the code for a picture with squares: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegralImage[<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PrevIteration[<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Differences[<span class="hljs-number"><span class="hljs-number">61</span></span>, <span class="hljs-number"><span class="hljs-number">61</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X = <span class="hljs-number"><span class="hljs-number">0</span></span>; X &lt; <span class="hljs-number"><span class="hljs-number">61</span></span>; X++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; Y &lt; <span class="hljs-number"><span class="hljs-number">61</span></span>; Y++) { Differences[X, Y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">//     +-30      3721  for (int X = 0; X &lt; 61; X++) { for (int Y = 0; Y &lt; 61; Y++) { for (int x = 0; x &lt; 10; x++) { for (int y = 0; y &lt; 10; y++) { Differences[X, Y] += abs(PrevIteration[x,y]-IntegralImage[(x+4)*16-31+X,(y+4)*16-31+Y]; } } } }</span></span></code> </pre><br><br>  That's all.  It remains only to find the minimum element in the Differences array.  If it is [0, 30], then the new frame is shifted 30 pixels to the right.  If [60, 30] - then 30 pixels to the left. <br><br><h5>  Total </h5><br>  In this article, I did not say anything innovative or very obvious.  But this is a significant piece of my experience on this topic, and I sincerely hope that it will come in handy to anyone.  The article came out long and confusing, so surely there are obvious mistakes somewhere, or I haven‚Äôt clearly stated anything enough - I will be glad of reviews, constructive criticism and any other feedback.  Many thanks to those who mastered to the end. <br><br>  As for my implementation, I got a more or less working test software.  On the video card of the GeForce GTX560 level, it was possible to perform the assigned task - to process 75 frames per second in the size of 704x576.  And there was still a decent stock on time.  Of course, in the article I set forth only general principles - much can be optimized here.  Unfortunately, it was decided not to use CUDA in the project, so I have not touched him for more than a year. <br><br>  Once again I express my gratitude to comrade <a href="http://habrahabr.ru/users/bigobfuscator/" class="user_link">BigObfuscator</a> for the excellent article, without which I would hardly have thought up anything more confusing. <br><br><h5>  Raw </h5><br>  As I wrote above - for more than a year I have not dealt with the implementation of this algorithm.  The source is, but it is so unsightly that I am ashamed to post it in its current form.  If enough people are interested in it, I can shake the dust off the files, put everything in order and put it out. <br><br>  All good coding and good ideas! </div><p>Source: <a href="https://habr.com/ru/post/214027/">https://habr.com/ru/post/214027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214013/index.html">Develop Flappy Bird on Phaser</a></li>
<li><a href="../214015/index.html">Show Sound # 1-5 - Podcast about audio equipment, components, formats and technologies</a></li>
<li><a href="../214017/index.html">Business process simulator</a></li>
<li><a href="../214021/index.html">Why Intel will not leave the mobile market</a></li>
<li><a href="../214023/index.html">Voting and Information Security</a></li>
<li><a href="../214033/index.html">Is cross-platform development on Titanium a terrible end, or horror without end?</a></li>
<li><a href="../214035/index.html">Chrome Extension: Microsoft KB English Only</a></li>
<li><a href="../214039/index.html">Google introduced the online learning tool for oppia.</a></li>
<li><a href="../214041/index.html">Can a programmer become a factory director?</a></li>
<li><a href="../214043/index.html">Facebook SDK (iOS) integration into mobile free-to-play games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>