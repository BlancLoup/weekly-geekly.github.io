<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the development of non-paged keys based on passwords</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cryptographic protocols are the foundation of a secure network connection and confidential information exchange. Today there are a large number of var...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the development of non-paged keys based on passwords</h1><div class="post__text post__text-html js-mediator-article">  Cryptographic protocols are the foundation of a secure network connection and confidential information exchange.  Today there are a large number of various protocols for various purposes.  Many of these protocols (for example, TLS, Kerberos) are heard even among people who are not closely connected with cryptography.  They are ubiquitous and often have long been part of popular information systems. <br><br>  However, there is a type of protocols that has recently gained increasing popularity, but is still not widely known - shared key generation protocols with password-based authentication.  These protocols include the Russian protocol <a href="http://www.tc26.ru/methods/recommendation/TK26SESPAKE.pdf">SESPAKE</a> (Security Evaluated Standardized Password Authenticated Key Exchange), with the advent of which in Russia it became necessary to consider the features of protocols of this type.  The purpose of this article is rather not to give another formal description of the new protocol, but to help the reader grasp its main idea and features and understand why there are certain steps in it, why they are important, and how this protocol class differs from everything previously known. . <br><a name="habracut"></a><br><br><h1>  <font color="#306C8D">A bit of history</font> </h1><br>  In 1976, Whitfield Diffie and Martin Hellman proposed a simple but ingenious idea of ‚Äã‚Äãdeveloping a common secret key ‚Äî the well-known Diffie-Hellman protocol. <br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/2e6/cce/ccf/2e6cceccf55248dcafa065454d3c813a.png"></div><br>  Here <img src="https://tex.s2cms.ru/svg/E" alt="E">  - some finite <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D1%2583%25D0%25BF%25D0%25BF%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">multiplicative group</a> , <img src="https://tex.s2cms.ru/svg/q" alt="q">  - her order, <img src="https://tex.s2cms.ru/svg/g" alt="g">  - the generating element of this group.  Meanings <img src="https://tex.s2cms.ru/svg/M%20%3D%20g%5Ea" alt="M = g ^ a">  and <img src="https://tex.s2cms.ru/svg/N%20%3D%20g%5Eb" alt="N = g ^ b">  - public keys transmitted over an open communication channel, <img src="https://tex.s2cms.ru/svg/K%20%3D%20g%5E%7Bab%7D" alt="K = g ^ {ab}">  - key generated during the execution of the protocol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The durability of this protocol with respect to the passive adversary is based on the so-called <abbr title="Computational Diffie-Hellman">CDH</abbr> problem, which is considered computationally ‚Äúcomplex‚Äù (if we speak informally, then there are no effective solution algorithms for such a task).  The formulation of this problem is as follows: knowing the values <img src="https://tex.s2cms.ru/svg/g%5Ea" alt="g ^ a">  , <img src="https://tex.s2cms.ru/svg/g%5Eb" alt="g ^ b">  , calculate the value <img src="https://tex.s2cms.ru/svg/g%5E%7Bab%7D" alt="g ^ {ab}">  . <br><br>  Unfortunately, the Diffie-Hellman protocol has one fundamental flaw: it is not secure if there is an active opponent in the transmission channel (see the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE%25D1%2581%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0">‚ÄúMan in the Middle‚Äù</a> attack).  The reason for this vulnerability lies in the absence of an authentication mechanism, i.e.  during the protocol, the parties are not able to verify in any way that the shared key is developed together with the honest subscriber. <br><br>  To date, several solutions have been proposed for this problem, here are some of them: the use of certificates and <abbr title="certification centers">CAs</abbr> , the introduction of a third trusted participant in the protocol or the use of a previously agreed secret.  The latter approach is the simplest solution in terms of implementation.  However, if the protocol involves the use of a secret, which is a long bit string, which is difficult for a person to remember, then there is the problem of keeping this secret safe. <br><br>  The question arises, <i>can we use a short and easily remembered password as a secret</i> ?  As soon as the word ‚Äúpassword‚Äù appears, many people almost reflexively want to say that a priori cannot be achieved a priori, because  The password can be quickly recovered by simple brute force or dictionary.  It will be shown below that this is not always the case. <br><br>  To begin with, consider the following key generation scheme, in which an authentication stage is added to the Diffie-Hellman protocol using a secret value: <br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/1c2/e04/468/1c2e044680d54818af7296dbd0dc5c2f.png"></div><br>  Here <img src="https://tex.s2cms.ru/svg/H" alt="H">  - some hash function <img src="https://tex.s2cms.ru/svg/S" alt="S">  - secret pre-agreed value, <img src="https://tex.s2cms.ru/svg/T_A" alt="T_A">  , <img src="https://tex.s2cms.ru/svg/T_B" alt="T_b">  - information used for authentication.  It is easy to notice that the secret <img src="https://tex.s2cms.ru/svg/S" alt="S">  It is not used at all at the stage of generating a common key. <br><br>  Why is this example bad in the case when <img src="https://tex.s2cms.ru/svg/S" alt="S">  is a regular password?  As a rule, a password is a low-entropy value (that is, it consists of 4-6 characters, for example, a PIN), therefore, the enumeration of all possible values ‚Äã‚Äãof a password is quite an achievable task for the opponent.  Therefore, a fundamental requirement for protocols using a short password is resistance to the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B1%25D0%25BE%25D1%2580_%25D0%25BF%25D0%25BE_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D1%258E">offline dictionary attack</a> .  This property should be achieved due to the fact that the information that can be obtained by both the passive and active adversary during the execution of the protocol does not provide a criterion for rejecting incorrect passwords in offline mode, i.e.  For us, the ideal option is when an adversary cannot find a password by iterating through all possible values, the number of which is small, without user interaction.  Returning to the example, let us ask ourselves the question: <i>solving the problem of authentication, do not we give the enemy the criterion for rejecting the password</i> ?  To answer it, consider the following attack: <br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/67e/00c/55f/67e00c55fb8d49d89ea83a9969a5a60c.png"></div><br>  In this example, the opponent acts as follows: he replaces the side <img src="https://tex.s2cms.ru/svg/B" alt="B">  and interacts with the party <img src="https://tex.s2cms.ru/svg/A" alt="A">  honestly following the protocol.  Opponent generates common with <img src="https://tex.s2cms.ru/svg/A" alt="A">  key <img src="https://tex.s2cms.ru/svg/%5Cbar%7BK_A%7D" alt="\ bar {K_A}">  .  He then receives from the subject <img src="https://tex.s2cms.ru/svg/A" alt="A">  authentication information <img src="https://tex.s2cms.ru/svg/%5Cbar%7BT_A%7D%3DH(S%7C%7C%5Cbar%7BK_A%7D%7C%7C1)" alt="\ bar {T_A} = H (S || \ bar {K_A} || 1)">  , which depends on only one unknown parameter - low-entropy password <img src="https://tex.s2cms.ru/svg/S" alt="S">  .  Therefore, the adversary receives the criterion for rejecting the wrong passwords. <br><br>  However, if the use of a password were directly embedded in the generation of a key (which was an inseparable process from its development), the adversary would be able to receive a common <img src="https://tex.s2cms.ru/svg/A" alt="A">  key <img src="https://tex.s2cms.ru/svg/%5Cbar%7BK_A%7D" alt="\ bar {K_A}">  , just guessing the password during the interaction, then this attack would not be applicable, since he would have to go through not only the password, but also a long key. <br><br>  This idea formed the basis of a new approach, namely <b>the common key generation with password-based authentication</b> ( <abbr title="password authenticated key exchange">PAKE</abbr> ). <br><br><h1>  <font color="#306C8D">PAKE protocols</font> </h1><br>  The first protocol of the PAKE type was proposed back in 1992 by Stephen Bellinow and Michael Merritt.  This protocol assumed that to solve the authentication problem, subjects wishing to generate a common key use some easy-to-remember password known only to them.  The main difference between PAKE protocols and the example considered above is the fact that the password is already used during the generation of the shared key. <br><br>  In this case, the main requirements for such a protocol are: <br><ul><li>  providing authentication for protocol participants; <br></li><li>  the lack of the ability of the enemy to obtain a criterion for brute force <br></li></ul><br>  Let us try to understand whether it is difficult to build such a protocol and what features it should have.  To do this, consider the simplest example ‚Äî the prototype of the PAKE protocol: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/3a5/f71/41c/3a5f7141c11244d7ab39ff67ab963da5.png"></div><br>  The blue here highlights the differences from the Diffie-Hellman protocol, <img src="https://tex.s2cms.ru/svg/h" alt="h">  - one more generating element of the group <img src="https://tex.s2cms.ru/svg/E" alt="E">  . <br><br>  Let's see if such a scheme is vulnerable to an offline dictionary attack.  Values ‚Äã‚Äãare available to the passive adversary listening to the transmission channel <img src="https://tex.s2cms.ru/svg/M" alt="M">  and <img src="https://tex.s2cms.ru/svg/N" alt="N">  - Diffie-Hellman public keys disguised as <img src="https://tex.s2cms.ru/svg/h%5E%7BPW%7D" alt="h ^ {pw}">  and authentication information <img src="https://tex.s2cms.ru/svg/T_A" alt="T_A">  and <img src="https://tex.s2cms.ru/svg/T_B" alt="T_b">  .  Going through passwords, he can ‚Äúremove‚Äù masks from values <img src="https://tex.s2cms.ru/svg/M" alt="M">  and <img src="https://tex.s2cms.ru/svg/N" alt="N">  , while obtaining the estimated values <img src="https://tex.s2cms.ru/svg/g%5E%5Ctilde%7Ba%7D" alt="g ^ \ tilde {a}">  and <img src="https://tex.s2cms.ru/svg/g%5E%5Ctilde%7Bb%7D" alt="g ^ \ tilde {b}">  .  But an adversary can get a criterion for sorting passwords only if he can solve the computationally ‚Äúcomplex‚Äù CDH problem for unmasked values. <img src="https://tex.s2cms.ru/svg/M" alt="M">  and <img src="https://tex.s2cms.ru/svg/N" alt="N">  i.e. by values <img src="https://tex.s2cms.ru/svg/g%5E%5Ctilde%7Ba%7D" alt="g ^ \ tilde {a}">  and <img src="https://tex.s2cms.ru/svg/g%5E%5Ctilde%7Bb%7D" alt="g ^ \ tilde {b}">  get the key <img src="https://tex.s2cms.ru/svg/g%5E%7B%5Ctilde%20a%5Ctilde%20b%7D%20%3D%20%5Ctilde%7BK_A%7D" alt="g ^ {\ tilde a \ tilde b} = \ tilde {K_A}">  (the criterion of the correctness of the password is to obtain the correct authentication information <img src="http://https:https://tex.s2cms.ru/svg/T_A%3DH(K_A%7C%7C1)" alt="T_A = H (K_A || 1)">  on a test key <img src="https://tex.s2cms.ru/svg/%5Ctilde%7BK_A%7D" alt="\ tilde {K_A}">  ). <br><br>  In the case of an active enemy, this scheme still has certain vulnerabilities.  Consider the following attack on the scheme, where the discrete logarithms of one generating element relative to another are known.  For simplicity, consider the case when <img src="https://tex.s2cms.ru/svg/h%3Dg" alt="h = g">  . <br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/09a/f9c/691/09af9c691f1a4ce5ae0e497a32af9f09.png"></div><br>  As in the previous attack, here the enemy simply replaces the side <img src="https://tex.s2cms.ru/svg/B" alt="B">  .  Since he knows the key generation function, which depends only on one unknown parameter - a low-entropy password <img src="https://tex.s2cms.ru/svg/PW" alt="Pw">  , he gets the opportunity to find the password by brute force, substituting the test key in the function of generating authentication information <img src="https://tex.s2cms.ru/svg/T" alt="T">  . <br><br>  It is easy to see that a similar attack can be carried out even if the protocol uses different generating elements, but the discrete logarithm of one at the base of the other is known.  In this case, the value of this logarithm will appear in the chain of equalities simply as some constant. <br><br>  If we use different generating elements, such that the discrete logarithms of the one relative to the other are not known, we will not be able to get the key as a function only from an unknown password.  Really, <img src="https://tex.s2cms.ru/svg/K_A%20%3D(M*h%5E%7B-PW%7D)%5Ee%2F(h%5E%7BPW%7D)%5Ea" alt="K_A = (M * h ^ {- PW}) ^ e / (h ^ {PW}) ^ a">  where <img src="https://tex.s2cms.ru/svg/a" alt="a">  - high entropy unknown quantity. <br><br><h5>  <font color="#cc0000">Conclusion # 1: When generating an ephemeral public key and a password ‚Äúmask‚Äù, it is necessary to use different generating elements, and the discrete logarithms of one on the basis of the other should be unknown.</font> </h5><br>  To obtain such elements, it is necessary not only to generate them at random, but also to be able to convince everyone else that when they were generated, everything was purely random.  This can be achieved if we choose the generating elements according to the <a href="https://eprint.iacr.org/2014/832">principle of provable pseudo-randomness</a> .  So, for a multiplicative group of a finite field <img src="https://tex.s2cms.ru/svg/GF(p)" alt="GF (p)">  we can give the following algorithm for generating generators: <br><ol><li>  Generate random string <img src="https://tex.s2cms.ru/svg/s">  . <br></li><li>  Put <img src="https://tex.s2cms.ru/svg/g%3DH(s)%5C%20mod%5C%20p" alt="g = H (s) \ mod \ p">  . <br></li><li>  Check that <img src="https://tex.s2cms.ru/svg/g" alt="g">  - the generating element, otherwise return to step 1. <br></li></ol><br>  It would seem that now we have considered all potentially dangerous situations, however, when creating a protocol, it is necessary to take into account more complex issues.  Any specialist who develops a new protocol knows that one of the most important requirements for such protocols is to provide them with the so-called implicit authentication of the key generated. <br><div class="spoiler">  <b class="spoiler_title">Explicit and implicit key authentication</b> <div class="spoiler_text">  Implicit key authentication is a protocol property in which a protocol participant can be sure that no other party, except a specially identified (legitimate) protocol participant, can access the secret key generated in the protocol.  At the same time, there are no guarantees that the second party to the protocol did indeed gain access to the key, but it is certain that no one else but him could receive it. <br><br>  Explicit key authentication is a property that is performed when implicit key authentication takes place and the key is confirmed (the property by which one participant of the protocol makes sure that the other participant actually has the key generated in the protocol) at the same time.  In this case, it is known that the legitimate side, and no one else, really possesses the key that has been worked out. <br></div></div><br>  For us, this requirement means that the protocol we are designing must provide a cryptographically strong public key that meets the requirement of implicit authentication, even if we use the protocol without an explicit authentication stage.  Let us return to our prototype and see if it satisfies this property. <br><br>  Consider an attack in such an enemy model, where: <br><ul><li>  both parties are involved in the interaction; </li><li>  the enemy knows the keys <img src="https://tex.s2cms.ru/svg/K_A" alt="K_A">  and <img src="https://tex.s2cms.ru/svg/K_B" alt="K_B">  (for example, due to unauthorized access, using them in vulnerable cryptoalgorithms, etc.). </li></ul><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/3c0/00d/dde/3c000ddde9964c029bcbff5e4e326947.png"></div><br>  Despite the fact that we use different generating elements, if the enemy knows <img src="https://tex.s2cms.ru/svg/K_A" alt="K_A">  and <img src="https://tex.s2cms.ru/svg/K_B" alt="K_B">  then knowing <img src="https://tex.s2cms.ru/svg/N" alt="N">  and <img src="https://tex.s2cms.ru/svg/r" alt="r">  , he can find the password value <img src="https://tex.s2cms.ru/svg/PW" alt="Pw">  using the criterion <img src="https://tex.s2cms.ru/svg/(K_B%2FK_A)%5E%7B-r%7D%20%3DN%2Fh%5E%7BPW%7D" alt="(K_B / K_A) ^ {- r} = N / h ^ {PW}">  .  Thus, by intercepting and replacing the message, he will actually be able to get the criteria for finding the password. <br><br>  You can get rid of this vulnerability by using the hash function in the protocol: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/556/8dd/2ae/5568dd2ae86848a69efcbd5cc1589e4f.png"></div><br>  Indeed, since a hash function that satisfies the cryptographic requirements is considered an analog of a pseudo-random function, there are no simple dependencies between its output and input that can be efficiently exploited.  Thus, the opponent no longer has the criterion for finding the password and the attack ceases to be applicable. <br><br><h5>  <font color="#cc0000">Conclusion number 2: Hash key generated.</font> </h5><br>  So, we were able to build the simplest prototype of the generation of non-punctable keys protocol based on the passwords to be iterated.  Of course, consideration of specific attacks and the use of known methods of protection against them do not guarantee that the protocol being developed will be persistent, since it is not possible to take into account all existing, but unknown attacks.  In this case, methods of mathematical cryptography come to the rescue, which allow to obtain estimates of the strength of protocols in certain security models.  Informally speaking, for PAKE protocols, these assessments must strictly prove that testing the password is the best tactic for the adversary when trying to establish a connection, honestly following the protocol.  Similar <a href="http://eprint.iacr.org/2015/1237.pdf">estimates</a> were obtained for the SESPAKE protocol. <br><br>  As mentioned above, the password is of low entropy value, i.e.  unlike the long key, you cannot neglect the probability of just guessing this password.  Therefore, paying for the use of passwords as a general pre-agreed secret is the implementation of such technical measures as a limit on the number of attempts to establish a connection. <br><br><h1>  <font color="#306C8D">On practice</font> </h1><br>  So, we learned what properties the shared key generation protocol should have based on a password, followed by authentication.  We also got acquainted with an example of one of such protocols - the SESPAKE protocol.  Let us now try to figure out whether this protocol is really necessary in practice and whether it is impossible to manage with long-existing solutions. <br><br>  The protocols of this family provide ample opportunities for their use in a wide variety of information systems.  In order to "feel" the work of the protocol, let's turn to the most popular area of ‚Äã‚Äãits application and one of the most important issues for information security - the task of safekeeping of cryptographic keys. <br><br>  There are two main types of key carriers that use a password: passive storage and active token. <br><div style="text-align:center;"><img width="50%" height="50%" src="https://habrastorage.org/files/0cf/6f8/f85/0cf6f8f856b54c8cabe363c1dfaee382.png"></div><br>  Passive media can only store the key and transfer it to the application (usually the cryptographic provider) running in the operating system on the user's side, which already decides what to do with it.  The inherent property of passive storage is the <b>principal retrievability of the</b> key: all operations that depend on the key are performed by the application running on the user's machine, so the key is inevitably present in the RAM.  Of course, only the one who knows the password can extract the key. <br><br>  Active tokens, as well as storage media, also store the user's key within themselves, but the only thing that the user can receive from this carrier is the result of performing cryptographic operations using the stored key.  In such devices, the key does not go beyond the memory of the carrier, that is, is <b>non-removable</b> . <br><div class="spoiler">  <b class="spoiler_title">Key carrier operation scheme</b> <div class="spoiler_text">  Storage media: <br><div style="text-align:center;"><img width="50%" height="50%" src="https://habrastorage.org/files/cfe/a47/deb/cfea47deb1844505979a3c1838e506ad.png"></div><br><br>  Active Token: <br><div style="text-align:center;"><img width="50%" height="50%" src="https://habrastorage.org/files/46f/6cc/6c6/46f6cc6c67e3400f95e6a646bc2dbc6a.png"></div><br></div></div><br>  The properties of the key carriers of both types described above have rather strict conditions for their use, since both of these key carriers are unstable if the attacker is in the communication channel.  In the case of using a storage medium, the attacker simply sees the key, but in the case of the active carrier, he will not be able to access the key, but he will be able to find out the password, and therefore become a legitimate subject for the carrier - who knows the password is right!  In this case, if the device is stolen, the attacker can use the token to perform the necessary key operations.  In cryptography, such a threat is called selective fake: an attacker can sign the data he needs without knowing the key. <br><br><h1>  <font color="#306C8D">CIF or SESPAKE comes into play</font> </h1><br>  Thus, the problem arises of creating such type of key carriers that would be resistant to the enemy in the communication channel between the machine and the carrier and the threat of selective counterfeiting, that is, would actually solve the authentication problem.  And thanks to the advent of the PAKE family of protocols, we can create such a carrier. <br>  This type of tokens that meets these requirements, called <i>functional key carriers</i> (abbreviated as <i>FKN</i> ). <br><div class="spoiler">  <b class="spoiler_title">The scheme of the functional key carrier (PCF)</b> <div class="spoiler_text">  The general scheme of their work FKN looks like this: <br><div style="text-align:center;"><img width="50%" height="50%" src="https://habrastorage.org/files/554/190/717/55419071739148c1818835d488541417.png"></div><br></div></div><br>  These media, as well as the active media discussed above, provide the user with the opportunity to get only the result of calculations in which the key is involved.  However, their difference is that the password is not transmitted directly via the communication channel, but a secure connection is established using the PAKE protocol, that is, only those data are transmitted via the communication channel, which in practice cannot draw any conclusions about the password or information. the key. <br><br>  This is where the SESPAKE protocol comes on the scene, which, in essence, provides the possibility of such an interaction scenario.  Using this protocol allows you to mathematically strictly provide protection against the enemy in the channel.  Thus, an attacker who has the ability to read and replace messages in the channel will not be able to find out the password, or even be able to go through passwords non-interactively, that is, without control from the token. <br><br><h1>  <font color="#306C8D">SESPAKE protocol</font> </h1><br>  The SESPAKE protocol was developed with all the requirements described above.  Usually, the rationale for the strength of the PAKE protocol is given in the model, which takes into account the standard threat of the enemy evoking at least some information about the generated key.  However, this model is not entirely natural, as it is considered outside the context of the application of the protocol.  Indeed, the keys generated after the completion of the protocol will be further used to protect the data, which will immediately enable the violator to realize the threat.  Simply put, the robustness of these protocols is analyzed in some simplified model of their use, which often leads to situations where, after the introduction of extensions that allow using the protocol in specific cases in practice, it turns out to be unstable.  Therefore, the justification for the robustness of the SESPAKE protocol is given in the adversary model, which takes into account another stronger threat - the threat of false authentication. <br><br>  The development of the SESPAKE protocol does not originate from an abstract mathematical model, in which well-known mechanisms of substantiation of persistence exist for a long time, but is associated with a concrete practical case: the need to protect the channel between the key carrier and the provider.  Thus, the new model of the adversary introduced by its developers allowed both the protocol and its justification to take into account all the technical aspects important for the practice (for example, work with meters).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can </font><font style="vertical-align: inherit;">learn </font><font style="vertical-align: inherit;">more about its rationale in a separate </font></font><a href="http://eprint.iacr.org/2015/1237.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but we will try to understand the essence of the protocol‚Äôs work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the scheme of such a ‚Äúcombat‚Äù protocol is significantly more complicated than the examples we are considering, and the protocol itself is based on groups of points of </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptic curves</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which, with the same key length, allow us to achieve greater cryptographic strength in comparison with the final fields. </font><font style="vertical-align: inherit;">However, now even an inexperienced reader will be able to grasp its essence, because the basic principles on which it is based remain the same. </font></font><br><br><img width="80%" height="80%" src="https://habrastorage.org/files/6e5/c2f/299/6e5c2f2997934b8fbf8f154e60caf793.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above scheme of the protocol's operation, its key and moments already familiar to us, similar to those described in the prototype constructed above, are highlighted in three colors:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Values </font></font><img src="https://tex.s2cms.ru/svg/u_1" alt="u_1">  and <img src="https://tex.s2cms.ru/svg/u_2" alt="u_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are similar </font></font><img src="https://tex.s2cms.ru/svg/M" alt="M">  and <img src="https://tex.s2cms.ru/svg/N" alt="N">  , <img src="https://tex.s2cms.ru/svg/Q_%7BPW%7D" alt="Q_ {PW}">  and <img src="https://tex.s2cms.ru/svg/Q_%7BPW%7D%5E%7BA%7D" alt="Q_ {PW} ^ {A}">    ¬´¬ª ( <img src="https://tex.s2cms.ru/svg/h%5E%7BPW%7D" alt="h ^ {pw}"> ),  <img src="https://tex.s2cms.ru/svg/%5Calpha*P" alt="\ alpha * P">  , <img src="https://tex.s2cms.ru/svg/%5Cbeta*P" alt="\ beta * P">   <img src="https://tex.s2cms.ru/svg/g%5Ea" alt="g ^ a">  , <img src="https://tex.s2cms.ru/svg/g%5Eb" alt="g ^ b">  . </li><li>   SESPAKE   ‚Ññ2,     . </li><li>   ,     ,     :     .     <img src="https://tex.s2cms.ru/svg/H(K%7C%7C1)" alt="H (K || 1)">       <a href="https://ru.wikipedia.org/wiki/HMAC">  </a> <img src="https://tex.s2cms.ru/svg/HMAC" alt="HMAC">        <abbr title="concatenation of all the data that was sent earlier"></abbr> . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The requirement for the presence of different generating elements, formulated by us in conclusion 1, is also not bypassed here. </font><font style="vertical-align: inherit;">However, now it is formulated as follows: the multiplicity of any point from the set </font></font><img src="https://tex.s2cms.ru/svg/Q_1%2C...%2CQ_l" alt="Q_1, ..., Q_l"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(a set of points that can be used in the protocol to form a mask, the index ( </font></font><img src="https://tex.s2cms.ru/svg/ind" alt="ind"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) of which is selected before the start of the key generation stage) relative to the generator </font></font><img src="https://tex.s2cms.ru/svg/P" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and relative to each other is unknown. </font><font style="vertical-align: inherit;">Moreover, the task of calculating this multiplicity is not feasible in practice, i.e. </font><font style="vertical-align: inherit;">its laboriousness is comparable to the laboriousness of solving a complex discrete logarithm problem in a group of points of an elliptic curve used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The choice of a point of an elliptic curve, given in the Weierstrass form ( </font></font><img src="https://tex.s2cms.ru/svg/y%5E2%3Dx%5E3%2Bax%2Bb" alt="y ^ 2 = x ^ 3 + ax + b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), can be made as follows:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generate random string </font></font><img src="https://tex.s2cms.ru/svg/s" alt="s">  . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Put </font></font><img src="https://tex.s2cms.ru/svg/x%3DH(s)" alt="x = H (s)">  . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the value is </font></font><img src="https://tex.s2cms.ru/svg/x%5E3%2Bax%2Bb" alt="x ^ 3 + ax + b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not a quadratic modulo residue </font></font><img src="https://tex.s2cms.ru/svg/p" alt="p"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, go to step 1.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Put </font></font><img src="https://tex.s2cms.ru/svg/y%3D%5Csqrt%7Bx%5E3%2Bax%2Bb%7D%5C%20mod%5C%20p" alt="y = \ sqrt {x ^ 3 + ax + b} \ mod \ p">  . <br></li></ol><br>  Here <img src="https://tex.s2cms.ru/svg/p" alt="p"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the order of the field over which the group of points of the elliptic curve is built, and the </font></font><img src="https://tex.s2cms.ru/svg/H" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash function GOST R 34.11-2012 can be used as, for example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that the SESPAKE protocol is one of the most efficient, since it implies the minimum possible number of shipments between the parties.</font></font><br><br><h1>  <font color="#306C8D">Conclusion</font> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of 2015, the technical committee for standardization </font></font><a href="http://www.tc26.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TK26</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adopted a common-key protocol with password-based authentication, the SESPAKE protocol, as guidelines. At about the same time, the protocol began to be considered in the </font></font><a href="http://www.ietf.org/mail-archive/web/cfrg/current/maillist.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CFRG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cryptography research group </font><font style="vertical-align: inherit;">(Crypto Forum Research Group), which is part of the international standardization organization of the IETF / IRTF. Currently, CFRG is discussing the standardization of requirements for PAKE-type protocols, as well as the choice of protocol as an international recommendation for use. Among the three main candidates is the SESPAKE protocol, </font></font><a href="https://tools.ietf.org/html/draft-smyshlyaev-sespake"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draft RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which is now being actively developed by Russian specialists. </font><font style="vertical-align: inherit;">Acquainted with such protocols, now you can offer your ideas by participating in such discussions.</font></font></div><p>Source: <a href="https://habr.com/ru/post/282043/">https://habr.com/ru/post/282043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282033/index.html">April 23-24, from 12:00 to 12:00, we invite you to # 1 Global Chatbots Hackathon from Webinar.ru</a></li>
<li><a href="../282035/index.html">Weak [weak] links in the new version of Delphi</a></li>
<li><a href="../282037/index.html">We do multitasking</a></li>
<li><a href="../282039/index.html">Moscow Python Meetup ‚Ññ34 (April 27)</a></li>
<li><a href="../282041/index.html">JS Loader + template engine or history of another</a></li>
<li><a href="../282045/index.html">Scaling to 100 million: architecture defined by service level</a></li>
<li><a href="../282047/index.html">Evolution of viruses: from student fun to disruption of Iran‚Äôs nuclear program</a></li>
<li><a href="../282049/index.html">Preemptivity: how to take away the processor</a></li>
<li><a href="../282053/index.html">Andrei Ershov: ‚ÄúTwo Views of Programming‚Äù</a></li>
<li><a href="../282057/index.html">Xamarin Development Workshop: Technology Overview and Dive into Solution Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>