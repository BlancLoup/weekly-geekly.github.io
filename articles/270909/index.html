<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing of domains or more than analyzing boundary values</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All testers have at least heard about such test design techniques as equivalence classes and analysis of boundary values. It would seem that it could ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing of domains or more than analyzing boundary values</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d17/ccb/66d/d17ccb66d82597826fa61ed989d5f886.png" alt="image" align="right" width="25%"><br>  All testers have at least heard about such test design techniques as equivalence classes and analysis of boundary values.  It would seem that it could be simpler: select classes, take one value in each, check the class boundaries and values ‚Äã‚Äãto the left and right of the boundaries.  But is it always so simple?  What if, after partitioning into classes, it turns out that there is no problem with borders, they cannot be defined, since the data cannot be ordered?  What if the tested parameters are interconnected by some logic and depend on each other?  How many tests are enough?  Below will be considered the possibilities of the two main techniques of test design, exceeding those laid down in their direct definition. <br><a name="habracut"></a><br>  Domain - a mathematical term - a collection of all possible values ‚Äã‚Äãof a variable.  Testing of definition domains regards a program as a function of many variables, each of which takes a finite set of values.  Each such set can be divided into at least two equivalence classes - valid and non-valid values. <br><br>  Testing definition domains involves three steps: <br><ol><li>  the selection of subregions for each parameter, all elements of which presumably lead to the same program behavior (to reduce the number of tests); </li><li>  selection of specific values ‚Äã‚Äãfor testing inside each class (including for detecting errors related to the fact that the definition domain is set incorrectly); </li><li>  a combination of these values ‚Äã‚Äã(to increase test coverage and to detect errors depending on the interaction of several parameters). </li></ol><br>  Experienced (and not so) testers are now skeptical that the tasks above are solved by three test design techniques ‚Äî a division into equivalence classes, an analysis of boundary values ‚Äã‚Äãand a pair-wise search.  This is true, because then we will discuss some features of the use of these techniques, which will help to detect more errors and / or reduce testing time, while preserving the maximum level of test coverage, and, therefore, confidence in the quality of the program. <br><br><h4>  Equivalence classes </h4><br>  A few simple rules. <br><ol><li>  If the domain of definition of a parameter is a range, then it makes sense to distinguish three equivalence classes: to the left of the range (invalid values), the range itself (valid values) and to the right of the range (again invalid).  When allocating classes, it is necessary to use inclusive boundaries for the purpose of unambiguity and accuracy: the same value cannot belong to two classes simultaneously. </li><li>  If the domain of definition is a set of disordered data, then at least two classes can always be distinguished - valid and non-valid values.  The resulting partition can be "split" further.  For example, a set of Latin letters can be divided into two subsets: Latin in upper and lower case, respectively. </li></ol><br>  The example above uses the obvious way of splitting into subclasses, but it is not the only one.  Such a partition is not always advisable in the sense that it does not so often contain errors.  Here are some other tricks: <br><ul><li>  in terms of frequency of use by end users (for example, for parameters such as login and password, it may make sense to single out the character class ‚ÄúqwertyQWERTY1234567980‚Äù into a separate class); </li><li>  random subclasses of equal size (providing conditional test coverage if there are no other logical ways to subclass). </li></ul><br>  There are linear (ordered) and nonlinear (unordered) equivalence classes.  Obviously, it is impossible to apply the analysis of boundary values ‚Äã‚Äãto the latter, i.e.  There is no logical way to select elements that are more likely to result in an error.  An example of such a class would be a variety of special characters that can be entered from the keyboard.  For crushing such a class, a second method may be useful.  The input parameter for its application will be the number of subclasses that are planned to be used in testing: one will be taken from each one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Typical errors of this stage of testing domains: too many or too few classes, classes are allocated incorrectly (in relation to the functionality of the program). <br><br><h4>  Selection of values </h4><br>  After the division into equivalence classes is completed, it is necessary to select values ‚Äã‚Äãfrom each class that will be used in the tests.  The analysis of boundary values ‚Äã‚Äãis only one of the methods, and is suitable only for linear classes.  What to do in other cases? <br><ol><li>  Random selection.  It is highly desirable that with each subsequent test run, a different value from the class will be chosen at random.  In this case, you can use a random selection with a return (the value selected earlier can be selected again with the same probability) or without return (the value selected earlier can no longer be selected, thereby increasing the probability of selecting the values ‚Äã‚Äãremaining in the class). </li><li>  Proportional partitioning.  There are different algorithms whose main purpose is to reduce the risk of incorrect division into equivalence classes.  To do this, you can take several values ‚Äã‚Äãfrom each class (the number increases with the utility of a particular function of the program).  Another way is to take from each class not a fixed number of values, but a fixed part of the class.  Thus, for classes containing more elements, more tests will result. </li><li>  Analysis of boundary values.  It should be remembered that the main idea of ‚Äã‚Äãthis technique is the selection of values ‚Äã‚Äãthat lead to errors more likely than others.  This technique is not limited directly to the controls on the program screen.  In addition to numeric range boundaries, it is worth remembering time limits (for example, the period of free use of the program), cycle boundaries (number of incorrect password entries), type boundaries (even if according to the specification you can enter an integer number that is not limited from above, this number is or else it will be limited by the maximum value of the integer data type that the programmer chose in implementing this function).  There are other boundaries associated with non-functional types of testing - performance, configurations. </li><li>  Empirical knowledge.  Some values ‚Äã‚Äãmay be chosen more often than others or may be of particular use in terms of the business logic of the application.  The ideas of such tests can be prompted by a person who is well-versed in the subject area of ‚Äã‚Äãthe program. </li></ol><br>  When analyzing the boundary values ‚Äã‚Äãand allocating equivalence classes for numerical parameters, special attention should be paid to the result of the calculations.  Such a partitioning and selection of values ‚Äã‚Äãfor testing will help to find important errors.  What restrictions are imposed on the range of values, i.e.  the result of the calculations, and what values ‚Äã‚Äãshould the input parameters take?  What you need to set the input values ‚Äã‚Äãto go beyond this area?  For example, if the result of the calculation should be positive, it is worth to distinguish three equivalence classes and the corresponding boundary values: <br><ul><li>  input data for which the result is strictly positive (valid class); </li><li>  input data for which the result is zero (invalid class); </li><li>  input data for which the result is negative (invalid class). </li></ul><br>  It may be that the values ‚Äã‚Äãthat appeared during such a partition in non-valid classes are allowed for input according to the specification.  This may be an error in writing requirements that business analysts should point out. <br><br><h4>  Combinations of values </h4><br>  Defects that depend on the input data can be divided into those that occur with a specific value of one parameter, and those for the occurrence of which you need a combination of specific values ‚Äã‚Äãof more than one parameter.  For the detection of the latter, combinatorial testing techniques are used, one of which is pairwise testing (pairwise). <br><br>  Combinatorial techniques can be applied when equivalence classes are allocated for each parameter, and values ‚Äã‚Äãare chosen for which tests will be conducted for each parameter separately.  You can use several strategies for making combinations: <br><ul><li>  "Weak" vs.  ‚ÄúStrong‚Äù combination - a weak one will make it possible to compose a minimum of tests for the detection of all defects occurring on a specific value of one parameter; a strong one is intended to detect defects that occur at the ‚Äújunction‚Äù of parameter values; </li><li>  "Normal" vs.  ‚ÄúReliable‚Äù combination - normal uses only valid values ‚Äã‚Äãselected for testing, reliable - everything. </li></ul><br>  These are independent complementary characteristics, i.e., for example, a weak normal combination can be applied.  Such a strategy involves the compilation of tests in which all the valid values ‚Äã‚Äãof each parameter selected for testing are met at least once. <br><br>  Example: <br><ul><li>  the parameter A can take valid values ‚Äã‚Äãa1, a2, a3 and non-valid a_4, a_5; </li><li>  parameter B can take the valid value b1 and non-valid b_2, b_3, b_4; </li><li>  parameter C can take valid values ‚Äã‚Äãc1, c2, c3 and c4 and invalid c_1. </li></ul><br>  Weak normal combination will give the following tests: <br><ul><li>  a1, b1, c1 </li><li>  a2, b1, c2 </li><li>  a3, b1, c3 </li><li>  a1, b1, c4 </li></ul><br>  Strong normal combination - all possible combinations of valid values ‚Äã‚Äãof each of the parameters: <br><ul><li>  a1, b1, c1 </li><li>  a1, b1, c2 </li><li>  a1, b1, c3 </li><li>  a1, b1, c4 </li><li>  a2, b1, c1 </li><li>  a2, b1, c2 </li><li>  a2, b1, c3 </li><li>  a2, b1, c4 </li><li>  a3, b1, c1 </li><li>  a3, b1, c2 </li><li>  a3, b1, c3 </li><li>  a3, b1, c4 </li></ul><br>  Similarly, you can create test suites using the strategies of weak reliable and strong reliable combination (try this for the example above). <br><br>  Obviously, when using a strong and / or reliable combination, the number of tests will increase dramatically with an increase in the number of values ‚Äã‚Äãof any of the parameters and, of course, with an increase in the number of parameters themselves.  <a href="http://habrahabr.ru/company/infopulse/blog/261381/">The pairwise search technique (pairwise)</a> is one of the ways to reduce the number of tests, while trying to preserve the quality of testing, i.e.  minimize the number of undetected errors.  But using this technique, it is important to understand that errors at the junction of more than two parameter values ‚Äã‚Äãwill remain undiscovered. <br><br>  Another way to reduce the number of tests is to find out if there are dependencies between the input parameters, and take this into account in the tests.  This is probably not always: often testing the black box does not allow "to look inside."  In this case, you can try to identify dependencies empirically and take them into account in combinatorial tests.  However, there is a risk of making a mistake in identifying such patterns. <br><br>  Combinatorial tests can and should be compiled using appropriate tools to avoid the human factor. <br><br>  I sincerely hope that the above will help you design effective tests. </div><p>Source: <a href="https://habr.com/ru/post/270909/">https://habr.com/ru/post/270909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270891/index.html">Incorrectly used mobile interface patterns</a></li>
<li><a href="../270895/index.html">Analysis of price changes in Russian online stores</a></li>
<li><a href="../270897/index.html">IBM Corporation opens the Bluemix blog on Habrahabr</a></li>
<li><a href="../270901/index.html">The digest of events from the world D ‚Ññ2</a></li>
<li><a href="../270907/index.html">The pitfalls of backup and recovery of deduplicated data in a disaster recovery script</a></li>
<li><a href="../270913/index.html">Objective-C What is actually a method and self? + runtime</a></li>
<li><a href="../270917/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ185 (November 8 - 15, 2015)</a></li>
<li><a href="../270919/index.html">Let's encrypt: start of the public beta on December 3</a></li>
<li><a href="../270927/index.html">Quiz of 15 questions: do you know CSS well</a></li>
<li><a href="../270929/index.html">The most simple and reliable implementation of the Dispose design pattern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>