<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of PCI Express v3.0 x16 on FPGA Virtex 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Computers have long had a PCI Express v3.0 x16 bus; Tests of modern video adapters show a speed of about 12 GB / s on this bus. I would like to make a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of PCI Express v3.0 x16 on FPGA Virtex 7</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b70/6cc/1a7/b706cc1a7d9f4850a9c80499e73af770.png"><br><br>  Computers have long had a PCI Express v3.0 x16 bus;  Tests of modern video adapters show a speed of about 12 GB / s on this bus.  I would like to make a module on the FPGA that has the same speed.  However, the available FPGAs have a HARDWARE controller only for PCIe v3.0 x8;  There are SOFT IP Core implementations, but they are very expensive.  But there is a way out. <br><a name="habracut"></a><br>  FPGA Virtex 7 VX330T has two controllers PCI Express v3.0 x8;  The obvious solution is to place a switch that has an x16 connector on the side and two x8 buses that are connected to the FPGA.  It turns out this structure: <br><br><img src="https://habrastorage.org/files/d73/22a/839/d7322a839dbc4936a85e9d86e320ec4a.png"><br>  According to this scheme, the HighTechGlobal HTG-728 module was built. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another way is Alpha-Data.  The ADM-PCIE-KU3-X16 does not have a switch.  But the x16 connector displays two x8 tires.  In FPGA it is possible to implement two independent controllers.  To do this, two reset signals and two reference frequencies are set on the FPGA.  But this module will work only in special motherboards, where two x8 are also output to the x16 connector.  I did not meet such motherboards, but apparently they are. <br><br>  Our company made a decision on the implementation of the FMC122P module with an internal switch.  The main task was to check the maximum exchange rate.  Another equally important task is to achieve compatibility with existing software and FPGA components. <br><br>  The PCI Express controller for Virtex 7 is radically different from the controller for Virtex 6, Kintex 7. It has become more convenient, but it is different.  The figure shows the block diagram of the controller: <br><br><img src="https://habrastorage.org/files/fc4/e27/62c/fc4e2762c2604c9fac224c9604f06df4.png"><br><br>  The controller has two parts Completer and Requester, each of which has two AXI_Stream buses.  Through the node Completer come requests from the bus PCI Express.  These requests are sent to the m_axis_cq bus.  On the s_axis_cc bus, a response must come from the User‚Äôs component.  This is usually the access point to the internal registers of the FPGA. <br><br>  Through the Requester node, the DMA controller sends requests for the PCI Express bus over the s_axis_rq bus.  Answers come through the m_axis_rc bus. <br><br>  <b>Tire simulation</b> <br><br>  The IP Core includes an example project by which you can understand how it works.  The project is written in Verilog and, unfortunately, it can also serve as an example of how not to develop.  Let's look at the block diagram of the example. <br><br><img src="https://habrastorage.org/files/77f/c0e/470/77fc0e470a7648059002632aeaca5da8.png"><br><br>  This diagram is taken from the description of IP Core.  At first glance, everything is fine - this is a wonderful picture, it can be shown to managers, project managers, clients.  Problems begin in implementation.  In this system, there are a lot of places where Verilog features are used to access objects along the absolute path.  In my opinion, in this system it is justified only in one place - this is a bypass of GTP nodes for modeling at the PIPE level.  But to make the connection between userapp_tx and userapp_rx using absolute paths is completely unnecessary. <br><br>  In the project it looks like this: <br><br>  In the pci_exp_usrapp_tx component there is a <b>TSK_SYSTEM_INITIALIZATION</b> function which calls the function from pci_exp_userapp_cfg via an absolute path: <br><br>  <b>board.RP.cfg_usrapp.TSK_WRITE_CFG_DW</b> (hereinafter I call the function that in Verilog is described through the task).  We look at the pci_exp_userapp_cfg component that we see: cfg_ds_bus_number &lt;= board.RP.tx_usrapp.RP_BUS_DEV_FNS [15: 8]; <br><br>  We look at the pci_exp_userapp_rc component, the same there: <b>board.RP.com_usrapp.TSK_PARSE_FRAME (`RX_LOG);</b> <br><br>  This is not only not stylistically correct.  This makes it difficult to apply the model in your project.  Firstly, it is not at all necessary that the top-level file in your own project will be called board and the same hierarchy will remain there.  Secondly, there may be two components.  We have just happened both cases.  I had to work with Verilog, although I didn‚Äôt like it at all.  As it turned out, by a small permutation, the entire root_port component can be brought to a completely hierarchical form.  The result was the component files: <br><br><ul><li>  xilinx_pcie_3_0_7vx_rp_m2.v </li><li>  pci_exp_usrapp_tx_m2.v </li><li>  pci_exp_usrapp_cfg_m2.v </li></ul><br>  And files with functions: <br><br><ul><li>  task_bar.vh </li><li>  task_rd.vh </li><li>  task_s1.vh </li><li>  task_test.vh </li></ul><br>  This made it possible to include two root_port components in the model.  In the VHDL component, the inclusion of two root_port looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">root_port</b> <div class="spoiler_text"><pre><code class="hljs php">gen_rp0: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( is_rp0=<span class="hljs-number"><span class="hljs-number">1</span></span> ) generate rp0: xilinx_pcie_3_0_7vx_rp_m2 generic map( INST_NUM =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) port map( sys_clk_p =&gt; sys_clk_p, sys_clk_n =&gt; sys_clk_n, sys_rst_n =&gt; sys_rst_n, --   cmd_rw =&gt; cmd_rw, --  -: <span class="hljs-number"><span class="hljs-number">0</span></span> - , <span class="hljs-number"><span class="hljs-number">1</span></span> -  cmd_req =&gt; cmd_req, -- <span class="hljs-number"><span class="hljs-number">1</span></span> -   cmd_ack =&gt; cmd_ack, -- <span class="hljs-number"><span class="hljs-number">1</span></span> -   cmd_adr =&gt; cmd_adr, --    - cmd_data_i =&gt; cmd_data_i, --    cmd_data_o =&gt; cmd_data_o, --   cmd_init_done =&gt; cmd_init_done_0 -- <span class="hljs-number"><span class="hljs-number">1</span></span> -   ); end generate; gen_rp1: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( is_rp1=<span class="hljs-number"><span class="hljs-number">1</span></span> ) generate rp1: xilinx_pcie_3_0_7vx_rp_m2 generic map( INST_NUM =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) port map( sys_clk_p =&gt; sys_clk_p, sys_clk_n =&gt; sys_clk_n, sys_rst_n =&gt; sys_rst_n, cmd_init_done =&gt; cmd_init_done_1 -- <span class="hljs-number"><span class="hljs-number">1</span></span> -   ); end generate;</code> </pre> <br></div></div><br>  The rp0 component is used to write or read 32-bit words.  The rp1 component only performs initialization. <br><br>  Unfortunately, this has been modeled for a very long time, even if the modeling is done at the PIPE level.  A typical simulation session is about ten minutes (and maybe more, I don‚Äôt remember).  For operational work with DMA channel is not suitable.  In this situation, a completely natural decision was made to remove the PCI Express controller from the model.  Especially since it has already been studied. <br><br>  <b>Block diagram of the controller</b> <br><br>  The generalized diagram of the controller is shown in the figure. <br><br><img src="https://habrastorage.org/files/b13/840/765/b13840765c4d494a9355dc447851b3e8.png"><br><br>  Two identical core256_top_engine components provide access to two EP0, EP1 controllers.  core256_top_engine provides access to the registers from the side of PCI Express, for this purpose only EP0 and the reg_access component are used.  The dma_access component contains the main control logic of the controller.  Its block diagram is shown below: <br><br><img src="https://habrastorage.org/files/b01/f09/4e9/b01f094e998448c49e58ecfc01507b57.png"><br><br>  Everything is controlled by the ctrl_main node.  The ctrl_dsc node contains a block of descriptors.  The ctrl_adr node converts a descriptor into a sequence of addresses of four-kilobyte blocks.  Addresses are sent to the cmd0 and cmd1 nodes for exchange with the core256_top_engine nodes; <br><br>  From the user part of the FPGA there are two tires 512 bits wide.  But the data on these buses should be transmitted in blocks of 4 kilobytes and strictly in turn.  This is required for alternately filling the ram0, ram1 memory nodes.  Each memory node contains four blocks of 4 kilobytes.  On these nodes, the memory splits the source stream with a width of 512 bits into two streams of 256 bits each.  In the future, two streams of 256 bits are already completely independent.  The stream data will be found only in the computer‚Äôs RAM, where it will be located at the neighboring addresses. <br><br>  <b>Dma_access simulation</b> <br><br>  The dma_access node is the most complex part of the controller.  Accordingly, it must be modeled very carefully.  As I wrote above, modeling two PCI Express cores is very long.  For acceleration, a model has been developed which is connected instead of core256_top_engine.  For dma_access, the same interface remained, and the simulation speed increased by an order of magnitude.  In this project, as well as in the PROTEQ project, automatic start of tests through the tcl file is used. <br><br>  Here is a fragment of the tcl file: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">run_test</span></span> <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_8kb "</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-string"><span class="hljs-string">"50 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_16kb "</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-string"><span class="hljs-string">"100 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_49blk "</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">"150 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_8x4_cont "</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-string"><span class="hljs-string">"150 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_128x1_cont "</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-string"><span class="hljs-string">"200 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_16kbx2 "</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-string"><span class="hljs-string">"150 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_step "</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-string"><span class="hljs-string">"200 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_8kb_sg_eot "</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-string"><span class="hljs-string">"100 us"</span></span> run_test <span class="hljs-string"><span class="hljs-string">"stend_m4"</span></span> <span class="hljs-string"><span class="hljs-string">"test_read_64x1 "</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-string"><span class="hljs-string">"100 us"</span></span></code> </pre> <br>  This is an automatic launch of nine tests.  For example, here‚Äôs one test code: <br><br><div class="spoiler">  <b class="spoiler_title">test_read_4kb</b> <div class="spoiler_text"><pre> <code class="hljs rust">procedure test_read_4kb ( signal cmd: out bh_cmd; --!  signal ret: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bh_ret --!  ) is variable adr : std_logic_vector( <span class="hljs-number"><span class="hljs-number">31</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ); variable data : std_logic_vector( <span class="hljs-number"><span class="hljs-number">31</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ); variable <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> : line; variable L : line; variable error : integer:=<span class="hljs-number"><span class="hljs-number">0</span></span>; variable dma_complete : integer; variable data_expect : std_logic_vector( <span class="hljs-number"><span class="hljs-number">31</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ); begin write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"TEST_READ_4KB"</span></span> )); writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); ----    --- <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">127</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> adr:= x<span class="hljs-string"><span class="hljs-string">"00100000"</span></span>; adr:=adr + ii*<span class="hljs-number"><span class="hljs-number">4</span></span>; int_mem_write( cmd, ret, adr, x<span class="hljs-string"><span class="hljs-string">"00000000"</span></span> ); end <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"00100000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00008000"</span></span> ); int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"00100004"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000100"</span></span> ); -- int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"00100080"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00008000"</span></span> ); -- int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"00100084"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000100"</span></span> ); int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"001001F8"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000"</span></span> ); int_mem_write( cmd, ret, x<span class="hljs-string"><span class="hljs-string">"001001FC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"762C4953"</span></span> ); ----   DMA ---- block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000025"</span></span> ); -- DMA_MODE block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000010"</span></span> ); -- DMA_CTRL - RESET FIFO block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, x<span class="hljs-string"><span class="hljs-string">"00100000"</span></span> ); -- PCI_ADRL block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, x<span class="hljs-string"><span class="hljs-string">"00100000"</span></span> ); -- PCI_ADRH block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A400"</span></span> ); -- LOCAL_ADR block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000001"</span></span> ); -- DMA_CTRL - START wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> us; block_read( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, data ); -- STATUS write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"STATUS: "</span></span> )); hwrite( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, data( <span class="hljs-number"><span class="hljs-number">15</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( data( <span class="hljs-number"><span class="hljs-number">8</span></span> )=<span class="hljs-string"><span class="hljs-string">'1'</span></span> ) then write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">" -  "</span></span> )); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">" -   "</span></span> )); error := error + <span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error=<span class="hljs-number"><span class="hljs-number">0</span></span> ) then ----   DMA ---- dma_complete := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> block_read( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, data ); -- STATUS write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"STATUS: "</span></span> )); hwrite( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, data( <span class="hljs-number"><span class="hljs-number">15</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( data(<span class="hljs-number"><span class="hljs-number">5</span></span>)=<span class="hljs-string"><span class="hljs-string">'1'</span></span> ) then write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">" - DMA  "</span></span> )); dma_complete := <span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dma_complete=<span class="hljs-number"><span class="hljs-number">1</span></span> ) then exit; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> us; end <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dma_complete=<span class="hljs-number"><span class="hljs-number">0</span></span> ) then write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">" - DMA   "</span></span> )); writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); error:=error+<span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> block_read( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, data ); -- STATUS write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"STATUS: "</span></span> )); hwrite( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, data( <span class="hljs-number"><span class="hljs-number">15</span></span> downto <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> ns; end <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000"</span></span> ); -- DMA_CTRL - STOP write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">" : "</span></span> )); writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); data_expect := x<span class="hljs-string"><span class="hljs-string">"A0000000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">1023</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> adr:= x<span class="hljs-string"><span class="hljs-string">"00800000"</span></span>; adr:=adr + ii*<span class="hljs-number"><span class="hljs-number">4</span></span>; int_mem_read( cmd, ret, adr, data ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( data=data_expect ) then fprint( output, L, <span class="hljs-string"><span class="hljs-string">"%r : %r - Ok\n"</span></span>, fo(ii), fo(data)); fprint( log, L, <span class="hljs-string"><span class="hljs-string">"%r : %r - Ok\n"</span></span>, fo(ii), fo(data)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fprint( output, L, <span class="hljs-string"><span class="hljs-string">"%r : %r : %r - Error \n"</span></span>, fo(ii), fo(data), fo(data_expect)); fprint( log, L, <span class="hljs-string"><span class="hljs-string">"%r : %r : %r - Error \n"</span></span>, fo(ii), fo(data), fo(data_expect)); error:=error+<span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; data_expect := data_expect + <span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; -- block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000010"</span></span> ); -- DMA_CTRL - RESET FIFO -- block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000"</span></span> ); -- DMA_CTRL -- block_write( cmd, ret, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000001"</span></span> ); -- DMA_CTRL - START fprint( output, L, <span class="hljs-string"><span class="hljs-string">"\nTest time: %r \n"</span></span>, fo(now) ); fprint( log, L, <span class="hljs-string"><span class="hljs-string">"\nTest time: %r \n"</span></span>, fo(now) ); --    -- writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error=<span class="hljs-number"><span class="hljs-number">0</span></span> ) then write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"TEST finished successfully"</span></span> )); cnt_ok := cnt_ok + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"TEST finished with ERR"</span></span> )); cnt_error := cnt_error + <span class="hljs-number"><span class="hljs-number">1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); writeline( log, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); --    -- writeline( output, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error=<span class="hljs-number"><span class="hljs-number">0</span></span> ) then write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"TEST finished successfully"</span></span> )); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> write( <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, string'(<span class="hljs-string"><span class="hljs-string">"TEST finished with ERR"</span></span> )); end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; writeline( output, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); writeline( output, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ); end test_read_4kb</code> </pre><br></div></div><br>  The int_mem_write commands provide an entry in the computer's RAM HOST.  In this test a block of descriptors is written there.  The block_write and block_read commands provide access to the DMA registers of the controller.  The controller is programmed, started and completed the exchange.  After that, the int_mem_read commands read and check the received data.  The code of this test almost completely coincides with the test from the PCIe_DS_DMA controller, which I published as an open source project on opencores.org;  In comparison with the original, a check of the received data is added. <br><br>  <b>Logical controller organization</b> <br><br>  At the register level, the controller completely repeats our previous controllers for the FPGA Virtex 4, Virtex 5, Virtex 6, Kintex 7;  The organization can be found in the project PCIe_DS_DMA. <br>  A feature of all controllers is the integration of single descriptors into a block of descriptors.  This gives a dramatic increase in speed when using fragmented memory. <br><br>  <b>Connection to tetrad</b> <br><br>  For us it is important to connect this controller to our tetrad.  What is tetrad I wrote in a previous article: <a href="http://habrahabr.ru/post/309136/">"ADM Interface: What is a tetrad</a> . <a href="http://habrahabr.ru/post/309136/">"</a>  Working with a 512-bit bus required a change in approach.  To connect the tetrad I had to use an additional repacker node.  The structural diagram is shown in the figure. <br><br><img src="https://habrastorage.org/files/2ae/24e/5ef/2ae24e5ef4f043c7ade0dd5cfa6e38c4.png"><br><br>  The repacker solves two problems: <br><br><ul><li>  trace of the bus across the crystal, for this you can set the number of additional stages of the conveyor </li><li>  connection to tetradam with tires 64 and 128 bits </li></ul><br>  <b>Memory usage</b> <br><br>  The ultimate goal of developing a controller and connecting to tetrad is to obtain a continuous stream of data from the ADC to a computer.  And here we are faced with the fact that the PCI Express bus does not provide a stable speed.  There may be delays on the tire.  This is especially noticeable at high exchange rates.  Delays occur due to the operation of other devices.  The magnitude of the delay may be different, it may be 5 - 10 Œºs, and maybe more.  A delay of 10 ¬µs at a speed of 11 GB / s corresponds to a memory block of 110 kilobytes.  For internal memory, even modern FPGAs are very much.  But the delay may be more.  If the data stream cannot be paused, and this is exactly the case when ADCs are used, the only way out is buffering in external memory.  And the memory should be able to work at a speed of 22 GB / s.  We have two SODIMM DDR3-1600 installed on the module.  The memory runs at 800 MHz.  This corresponds to a continuous data stream of 8400 MB / s.  This figure is confirmed by experiment.  I want to note that the speed of 8400 MB / s exceeds the speed of data output from our fastest submodule in which two ADCs are installed at 1800 MHz. <br><br>  <b>Tracing</b> <br><br>  The screenshot shows the result of tracing in the PlanAhead program: <br><br><img src="https://habrastorage.org/files/7e4/a2a/8e2/7e4a2a8e2f63427e867db8ecbdccb581.png"><br><br>  The image shows two PCI Express controllers (highlighted in yellow and green) and two memory controllers (next to PCI Express). <br><br>  As it turned out, such a project is very difficult for Vivado, it copes with it very badly.  The project in Vivado divorces badly and often just does not work.  ISE shows much more stable results.  PCI Express nodes are divorced in accordance with the recommendations of Xilinx, while it turned out that they are spaced apart by crystal.  And this already creates a problem for sharing other multi-gigabit lines. <br><br>  <b>results</b> <br><br>  The module was tested on several computers.  The results are quite interesting. <br><table><tbody><tr><th>  Intel Core i7 4820K </th><th>  P9X79 WS </th><th>  DDR3-1866 </th><th>  11140 MB / s </th></tr><tr><th>  Intel Core i7 5820K </th><th>  X99-A </th><th>  DDR4-2400 </th><th>  11128 MB / s </th></tr><tr><th>  Intel Core i7 3820K </th><th>  P9X79 </th><th>  DDR3-1600 </th><th>  11120 MB / s </th></tr></tbody></table><br>  This is the data entry speed without verification.  The data is continuously entered into a 1 GB buffer allocated in the system memory area, i.e., continuous by physical addresses.  The average input rate is measured over an interval of at least 1 minute. <br><br>  On a computer with DDR3-1600 memory, when the scan is turned on, the speed drops to 8500 MB / s. <br><br>  On a computer with DDR3-1866, the speed with one module and the test enabled is not reduced. <br><br>  Two FMC122P modules in a computer with DDR3-1866 without verification also show a maximum speed of about 11,000 MB / s for each module.  But when you turn on the test speed drops. <br><br>  With these measurements, it is assumed that 1 MB is 1024 KB, and 1 KB is 1024 bytes. <br><br>  I would like to note that in this paper I present the result of the work of a large team.  Special thanks to Dmitry Avdeev, who did a great job in this project. <br><br>  <b>PS</b> While the development of Virtex 7 was outdated.  Kintex Ultrascale is more convenient to use.  And Kintex Ultrascale + already has a HARD PCI Express v3.0 x16 block - so this separation is no longer necessary. <br><br>  <b>PSS</b> But Kintex Ultrascale + also has a HARD PCI Express v4.0 x8 block - can separation still come in handy? </div><p>Source: <a href="https://habr.com/ru/post/317194/">https://habr.com/ru/post/317194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317180/index.html">About C language and performance</a></li>
<li><a href="../317182/index.html">Remote logging in journald or Still ‚Äúyou don't need this‚Äù?</a></li>
<li><a href="../317184/index.html">Why to achieve the goal is enough notebook</a></li>
<li><a href="../317188/index.html">Experience in building Infrastructure-as-Code in VMware. Part 1: Problem Identification</a></li>
<li><a href="../317192/index.html">Software patents must survive: American practice</a></li>
<li><a href="../317196/index.html">Berkeley Unified Parallel C (UPC). Debugging with the GNU gdb C debbuger. Call stack</a></li>
<li><a href="../317198/index.html">How to implement EDS and not screw it up</a></li>
<li><a href="../317200/index.html">How to make friends development stages with gitflow</a></li>
<li><a href="../317202/index.html">New models of radio bridges Siklu EtherHaul 2500 - transfer more, transfer further</a></li>
<li><a href="../317204/index.html">Friday format: What happens when Moore's law stops acting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>