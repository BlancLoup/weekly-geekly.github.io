<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Emacs Lisp Alternative</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever looked for an alternative to Emacs Lisp? Let's try to add another programming language to Emacs. 


 In this article: 


- The potential...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Emacs Lisp Alternative</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://github.com/Quasilyte/goism/blob/master/misc/logo.png?raw=true" alt="image"></p><br><p>  Have you ever looked for an alternative to Emacs Lisp?  Let's try to add another programming language to Emacs. </p><br><p>  In this article: </p><br><ul><li>  The potential benefits to be gained when you can extend Emacs to Go; </li><li>  Define how Go and Emacs Lisp interact; </li><li>  We will touch on some details of the implementation of the described transcompiler; </li></ul><br><p>  An article may be of interest to users of Emacs, as well as those who care about all these countless implementations of countless programming languages. </p><br><p>  At the very end of the article is a link to a work in progress project that allows you to convert Go to Emacs Lisp. </p><a name="habracut"></a><br><h1 id="vybiraem-emacs-go">  Choosing Emacs Go </h1><br><p>  Like any other programming language, Emacs Lisp has a number of "flaws", which we will politically correctly call "design tradeoffs".  It is rather difficult to say "better" or "worse" about certain properties of the programming language at the objective level, because there will almost always be defenders of opposite positions.  We, as users of programming languages, can try to choose the language whose compromises are easier for us to accept due to our tasks or personal preferences.  The key point is the choice. </p><br><p>  Suppose we chose Go.  How will you use Go to interact with the editor? <br>  Your options: </p><br><ol><li>  Use <a href="http://diobla.info/blog-archive/modules-tut.html">Emacs modules</a> to run Go functions.  Inspiration can be drawn from the project <a href="https://github.com/sigma/go-emacs">go-emacs</a> . </li><li>  Find (or write) the Go interpreter, embed it in Emacs by patching or the same <strong>C</strong> modules, and then call eval from the editor. </li><li>  Stream Go to Emacs Lisp bytecode. </li></ol><br><p>  There can be more ways, but none of them will be closer to the "native" list than (3).  It allows you to have the same virtual machine at the execution level as a regular Emacs Lisp. </p><br><p>  This, in turn, means that: </p><br><ul><li>  Emacs Lisp code will be able to call translated Go code; </li><li>  FFI is free.  Calling a function already defined in Emacs from Go is as efficient as possible; </li><li>  Easily distribute converted packages (native to Emacs format); </li></ul><br><p>  If this is your first time hearing about Emacs bytecode, read the <a href="http://nullprogram.com/blog/2014/01/04/">article by Chris Wellons</a> . </p><br><h2 id="pochemu-go">  Why go? </h2><br><p>  In place of Go, there could potentially be any other programming language. </p><br><p>  There are several reasons for which the choice made becomes more reasonable.  The main ones are: </p><br><ul><li>  Language compiler inside the standard library; </li><li>  Laconic specification; </li><li>  Modest runtime; </li><li>  Tooling; </li></ul><br><p>  There are also those properties that could be arguments in favor of choice, but specifically for me they were less significant: </p><br><ul><li>  Go is a fairly popular language with C-like syntax (i.e., this is not for you Scheme); </li><li>  Static typing; </li></ul><br><h4 id="kompilyator-yazyka-vnutri-standartnoy-biblioteki">  Language compiler inside the standard library </h4><br><p> <code>go/*</code> packages make it <strong>much</strong> easier to write Go tools. </p><br><p>  No need to write parser, typechecker, and other delights of the frontend compiler.  Over 20 lines of code we can get AST and type information for the whole package. </p><br><p>  Documentation is mostly good.  And for <code>go/types</code> in my opinion - <a href="https://github.com/golang/example/tree/master/gotypes">exemplary</a> . </p><br><p>  Initially for me it was a killer argument.  The task seemed to be 90% solved thanks to this secret weapon: "it remains only to convert AST to Emacs byte-code". </p><br><div class="spoiler">  <b class="spoiler_title">A spoon of tar</b> <div class="spoiler_text"><p>  In practice, there were difficulties with certain nuances. </p><br><p>  First of all, API entanglement and duplication of similar entities with different packages, and even under the same name.  Often the same can be done through <code>go/ast</code> and <code>go/types</code> ;  it is not uncommon for you to mix entities from both packages (yes, yes, including those with the same name). </p><br><p>  Surprisingly inconvenient was the work with imports and declarations (oh, this <code>ast.GenDecl</code> ). </p><br><p>  Many solutions with which you can solve these problems look like dirty hacks.  A detailed description of these hacks is perhaps the material for a separate article (especially since I did not check the abundance of information on this topic on the Internet, they probably all had time to chew and more than once). </p></div></div><br><h4 id="lakonichnaya-specifikaciya">  Laconic specification </h4><br><p>  Creating an implementation that is <em>more</em> (~ 80%) conforming to the specification is quite a feasible task for one person.  The Go specification is easy to read, it can be mastered in the evening. </p><br><p>  Specification Features: </p><br><ol><li>  Some points cast doubt on the unambiguous interpretation.  Short price; </li><li>  In addition to the <a href="https://golang.org/ref/spec">specification</a> there is also <a href="https://golang.org/doc/effective_go.html">Effective Go</a> .  Without it, white spots will remain in the specification; </li></ol><br><h4 id="skromnyy-runtime">  Modest runtime </h4><br><p>  The more features in the language that are implemented in the runtime library, the more difficult it will be to transcompile. </p><br><p>  If at least temporarily throwing overboard the gorutines and channels, then a compact core will remain, which can be fully realized in terms of Emacs Lisp without loss of performance. </p><br><h4 id="tooling">  Tooling </h4><br><p>  It is damn nice when many familiar features work in several of your favorite editors, moreover, uniformly. </p><br><p>  For Go, many of the functions that are usually re-inventoried for each IDE separately are implemented as separate utilities.  The simplest example known to every Go developer is <code>gofmt</code> .  To a large extent this is facilitated by the above <code>go/types</code> , <br>  <code>go/build</code> and other packages from the <code>go/*</code> group. </p><br><p>  Sublime text, Emacs, Visual Studio Code - choose any of them, install the plugin (s), and enjoy refactoring through <code>gorename</code> , a lot of linkers and automatic import'ami.  And auto-completion ... exceeds <code>company-elisp</code> in many aspects. </p><br><p>  Refactoring and maintaining a project on Emacs Lisp after 1000 lines of code is already uncomfortable for me personally.  Emacs is much more convenient to program on Go than on Emacs Lisp. </p><br><h1 id="kak-vyglyadit-emacs-go">  What does Emacs Go look like </h1><br><p>  Let's fantasize about what Go might look like for Emacs.  How comfortable and functional would it be? </p><br><h2 id="most-tipov">  Bridge types </h2><br><p>  Before talking directly about calling Lisp functions, you need to think about the bridge that connects two programming languages ‚Äã‚Äãthat work on the same computational model. </p><br><p>  With primitive types like <code>int</code> , <code>float64</code> , <code>string</code> and others, everything is more or less simple.  Both Go and Emacs Lisp have these types. </p><br><p>  Of interest are slices, symbolic types ( <code>symbol</code> ) and unsigned integer types of fixed width ( <code>uintX</code> ). </p><br><ul><li>  We implement slices in runtime (for example, on the same Emacs Lisp); </li><li>  Characters are represented as opaque type; </li><li>  Unsigned arithmetic with deterministic overflow - we emulate; </li></ul><br><p>  A type that can express an "arbitrary type object" that is returned by Emacs Lisp function is called <code>lisp.Object</code> .  Its definition is given under the spoiler <em>lisp.Object: implementation details</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Go slices</b> <div class="spoiler_text"><p>  For an analogy: the slices in Go in its ‚Äúinterface‚Äù are <code>std::vector</code> from C ++, but with the ability to take a full-fledged subslice without copying the elements. </p><br><p>  Let's start with the intuitive view <code>{data, len, cap}</code> . <br>  <strong>data</strong> will be a vector, <strong>len</strong> and <strong>cap</strong> numbers.  To store attributes, select the improper list, where we do not have the final nil, in order to save some memory: <br> <code>(cons data (cons len cap))</code> </p> <br><div class="spoiler">  <b class="spoiler_title">Why a list, not a vector?</b> <div class="spoiler_text"><p>  In short, then: the choice between the list and the vector is not particularly critical here, so one could take a vector. </p><br><p>  A more detailed answer to this question will help find a disassembler (or a <a href="https://www.emacswiki.org/emacs/ByteCodeEngineering">table of opcodes</a> ).  Access to lists of 2-3 items is very effective.  The closer to the head of the list, the more noticeable the difference.  The <strong>data</strong> attribute is used most often, so it is at the very beginning of the list. </p><br><p>  With N = 4, we can assume that the list begins to yield in efficiency in the case of reading the last element, but the other three attributes are still more efficient in accessing =&gt; even for objects from the four attributes, I tend to believe that the list is a better structure than vector. </p><br><p>  Disclaimer: this is all true for the Emacs virtual machine, its instruction set.  Out of context is not worth it. </p></div></div><br><p>  The <code>slice-get</code> / <code>slice-set</code> operations will be very efficient.  We will have the same <code>aset</code> / <code>aget</code> , but with one additional <code>car</code> instruction to extract the <strong>data</strong> attribute. </p><br><p>  But what happens when we need a subslice? </p><br><p>  In <strong>C,</strong> you could make <strong>data</strong> a pointer and shift it to the right place.  Addressing would be the same, 0-based.  In our case, this is not possible, which makes it necessary to store also the offset: <br> <code>(cons data (cons offset (cons len cap)))</code> </p> <br><p>  For each <code>slice-get</code> / <code>slice-set</code> now need to add an offset to the index. </p><br><p>  Compare the bytecode for the <code>slice-get</code> operation. </p><br><pre> <code class="hljs pgsql">;;   &lt;vector&gt; ;; [vector] &lt;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&gt; ;; [vector <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] aref ;; [elem] ;; <span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> (  subslice) &lt;<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>&gt; ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>] car ;; [data] &lt;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&gt; ;; [data <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] aref ;; [elem] ;; <span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>   subslice &lt;<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>&gt; ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>] dup ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>] (<span class="hljs-number"><span class="hljs-number">1</span></span>) car ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data] stack-<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>] cdr ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.cdr] car ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>] &lt;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&gt; ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] plus ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> data <span class="hljs-type"><span class="hljs-type">real</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] aref ;; [<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> elem] stack-<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ;; [elem] (<span class="hljs-number"><span class="hljs-number">2</span></span>) ;; (<span class="hljs-number"><span class="hljs-number">1</span></span>)  &lt;<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>&gt;    ,  ;;   . ;; (<span class="hljs-number"><span class="hljs-number">2</span></span>)        ;;  <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>  .</code> </pre> <br><p>  Using the <code>&lt;X&gt;</code> notation, expressions are selected that can be arbitrarily complex (from the usual <code>stack-ref</code> , to <code>call</code> with a variety of arguments).  The status of the data stack is displayed to the right of the code. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Opaque types</b> <div class="spoiler_text"><p>  Some types we do not want / can not express as Go structures.  These types include <code>lisp.Object</code> , <code>lisp.Symbol</code> and <code>lisp.Number</code> . </p><br><p>  The main purpose of the opaque type for us is to prohibit the arbitrary creation of objects through literals.  Interface types with a non-exportable method do a great job with this. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Symbol <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { symbol() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { object() <span class="hljs-comment"><span class="hljs-comment">//  ... } //       -. // Intern returns the canonical symbol with specified name. func Intern(name string) Symbol</span></span></code> </pre> <br><p>  The <code>Intern</code> function is processed in a special way by the compiler.  In other words, it is an intrinsic function. </p><br><p>  Now we can be sure that these special types have an API that we want to give them, and not something that is possible according to the laws of Go. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">lisp.Object</b> <div class="spoiler_text"><p>  If <code>lisp.Object</code> represents "any value", then why don't we use <code>interface{}</code> ? </p><br><p>  Recall what <code>interface{}</code> in Go is - a structure that stores the dynamic type of an object, plus the object itself - ‚Äúdata‚Äù. </p><br><p>  This is not exactly what I would like, because for Emacs, this ‚Äúanything‚Äù view is not effective.  <code>lisp.Object</code> needed to store unboxed Emacs Lisp values, <br>  which can be easily transferred to lisp functions and get as a result. </p><br><p>  In order to get the value of a particular type from <code>lisp.Object</code> , you can add additional methods to its interface. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { object() Int() <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Float() <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> String() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... etc. //     : IsInt() bool //     GetInt() (val int, ok bool) //  "comma, ok"-style  // ...    . }</span></span></code> </pre> <br><p>  Each call generates a type check.  If a value other than the requested type is stored inside <code>lisp.Object</code> , <code>panic</code> must be called.  Something like API <code>reflect.Value</code> , is not it? </p></div></div><br><h2 id="emacs-lisp-iz-go">  Emacs Lisp from Go </h2><br><p>  If the signature of the function is unknown, then the only thing that remains is to take a variable number of arguments of an arbitrary type, and return <code>lisp.Object</code> . </p><br><pre> <code class="go hljs">pair := lisp.Call(<span class="hljs-string"><span class="hljs-string">"cons"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>) a, b := lisp.Call(<span class="hljs-string"><span class="hljs-string">"car"</span></span>, pair), lisp.Call(<span class="hljs-string"><span class="hljs-string">"cdr"</span></span>, pair) lisp.Call(<span class="hljs-string"><span class="hljs-string">"insert"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, Emacs!"</span></span>) sum := lisp.Call(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).Int()</code> </pre> <br><p>  Manually annotated functions can be called in a more convenient way. </p><br><pre> <code class="go hljs">part := <span class="hljs-string"><span class="hljs-string">"c"</span></span> lisp.Insert(<span class="hljs-string"><span class="hljs-string">"Hello, Emacs!"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  void s := lisp.Concat("a", "b", part) //  string,  ...string</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">FFI DSL</b> <div class="spoiler_text"><p>  DSL to annotate functions can be written on macros. </p><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;;   ,   FFI. (ffi-declare (concat Concat (:string &amp;parts) :string) (message Message (:string format :any &amp;args) :string) (insert Insert (:any &amp;args) :void) (+ IntAdd (:int &amp;xs) :int)) ;;  , ,  Go .</span></span></code> </pre><br><p>  Such a macro should unfold in Go function signatures.  You need to leave a comment directive to preserve information about which Lisp function should be called. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// IntAdd - ... &lt;  +  Emacs&gt; //$GO-ffi:+ func IntAdd(xs ...int) int // ...  </span></span></code> </pre> <br><p>  Documentation can be pulled from Emacs using the <code>documentation</code> function.  We obtain functions with known arity and at the same time do not lose valuable docstrings. </p></div></div><br><h2 id="go-iz-emacs-lisp">  Go from Emacs Lisp </h2><br><p>  The result of the transcompilation is the Emacs Lisp package, in which all the characters from Go have a transformed look. </p><br><p>  An identifier mapping scheme can be, for example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> func <span class="hljs-string"><span class="hljs-string">"f"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$GO</span></span></span><span class="hljs-string">-foo.f"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> <span class="hljs-string"><span class="hljs-string">"foo/bar"</span></span> func <span class="hljs-string"><span class="hljs-string">"f"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$GO</span></span></span><span class="hljs-string">-foo/bar.g"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> func (typ) <span class="hljs-string"><span class="hljs-string">"m"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$GO</span></span></span><span class="hljs-string">-foo.typ.m"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-string"><span class="hljs-string">"v"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$GO</span></span></span><span class="hljs-string">-foo.v"</span></span></code> </pre> <br><p>  Accordingly, in order to call a function or use a variable, you need to know which Go package it belonged to (and its name, of course).  The <code>$GO</code> prefix avoids conflicts with names already defined in Emacs. </p><br><h1 id="tonkosti-transkompilyacii">  Transcompilation subtleties </h1><br><h2 id="bytecode-ili-lapcode">  Bytecode or lapcode? </h2><br><p>  As an output format, you can choose among three options: </p><br><ol><li>  Emacs Lisp code (source-to-source compilation) </li><li>  Bytecode </li><li>  Lapcode (Lisp Assembly Program) </li></ol><br><p>  The first option loses much to the other options, because it will not allow for the effective translation of the <code>return statement</code> , and it is also more difficult to implement the <code>goto</code> (which is in Go). </p><br><p>  The second and third options are almost equivalent in their capabilities. </p><br><ul><li>  Bytecode is an analogue of machine code, the lowest level; </li><li>  Lapcode is an assembly language for a virtual machine with a stack architecture; </li></ul><br><p>  The Emacs compiler can optimize at the source code level and lapcode views. <br>  If we choose lapcode, we can additionally apply low-level optimizations, <br>  implemented by emacs developers. </p><br><div class="spoiler">  <b class="spoiler_title">Disadvantages lapcode</b> <div class="spoiler_text"><p>  The Lisp assembly program is the internal format of the Emacs compiler (IR).  Documentation on it is even less than on byte code. </p><br><p>  Writing on this "assembler" on your own is almost impossible because of the features of the optimizer, which can break your code. </p><br><p>  I did not find an exact description of the format of instructions.  This is where the trial and error method helps, as well as reading the source code for the Emacs Lisp compiler (you will need steel nerves). </p></div></div><br><h2 id="proizvoditelnost-generiruemogo-koda">  Generated Code Performance </h2><br><p>  Go, which runs inside Emacs VM cannot be faster than Emacs Lisp. </p><br><p>  <em>Or maybe?</em> </p><br><p>  Emacs Lisp has dynamic scoping for variables.  If you look at <strong>"emacs / lisp / emacs-lisp / byte-opt.el"</strong> , you can find many references to this feature of the language;  because of it, some optimizations are either impossible or much more difficult. </p><br><p>  There are no constants in Emacs Lisp.  Names declared using <code>defconstant</code> less immutable than those defined by <code>defvar</code> .  In Go, constants are embedded in the place of use, which allows you to collapse more constant expressions. </p><br><p>  Optimizing Go code is easier, so you can expect at least performance that is not inferior to normal Emacs Lisp code.  Potentially, overtaking in terms of speed is real. </p><br><h2 id="trudnosti-realizacii">  Implementation difficulties </h2><br><p>  Even without Gorutin, there are Go features that do not have an obvious and / or optimal implementation within Emacs VM. </p><br><p>  The most interesting difficulty are pointers. </p><br><p>  In the context of the task, we can distinguish two categories of values ‚Äã‚Äãin Emacs Lisp: </p><br><ul><li>  Reference types ( <code>string</code> , <code>vector</code> , <code>list</code> / <code>cons</code> ) </li><li>  Value Types ( <code>integer</code> and <code>float</code> ) </li></ul><br><p>  For reference types, the problem is solved easier. <br>  Taking an address from an <code>int</code> or <code>float</code> variable requires processing <br>  more boundary cases. </p><br><p>  We should also remember that the operator <code>=</code> defined for pointers, <br>  therefore, the proposed solution must respect the identity of the addresses of the objects. </p><br><p>  Wrapping the <code>number</code> in <code>cons</code> , we fly by semantics, <br>  because the value from which the address was taken, <br>  will not change if the data stored in <code>cons</code> changes. </p><br><p>  If all numbers are initially created in boxed form (inside <code>cons</code> ), <br>  <strong>greatly</strong> increase the number of allocations. <br>  Unpacking will require additional <code>car</code> instructions every time a value is read. </p><br><p>  Implementing pointers through <code>cons</code> has a significant flaw: <code>&amp;x != &amp;x</code> , <br>  because <code>(eq (cons x nil) (cons x nil))</code> always false. </p><br><p>  Correct emulation of pointer semantics is an open question. <br>  I will be glad to hear your ideas for their implementation. </p><br><h1 id="seems-like-go-ism-inside-emacs">  Seems like go-ism inside emacs </h1><br><p>  The <a href="https://github.com/Quasilyte/goism">goism</a> project is a tool that allows you to get near-optimal Emacs Lisp bytecode from Go packets. </p><br><p>  The runtime library was originally written in Lisp, but more recently it has been completely rewritten to be broadcast in lapcode Go. <br>  <a href="https://github.com/Quasilyte/goism/tree/master/src/emacs/rt">emacs / rt</a> is currently one of the largest packages written with <strong>goism</strong> . </p><br><p>  At the moment, <strong>goism is</strong> not particularly friendly towards the end user, <br>  have to work with your hands to properly assemble and configure it <br>  ( <a href="">guick start guide</a> should simplify the task). </p><br><p>  Why is the article written right now, and not when a more stable version was released?  The answer is quite simple: there is no guarantee that this version will ever be ready, plus you can refine it for a very, very long time. </p><br><p>  I would like to know if this idea seems interesting and useful to members of the habr-community. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331134/">https://habr.com/ru/post/331134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331122/index.html">Android: dynamically load fragments from the network</a></li>
<li><a href="../331124/index.html">Terminology OneGet, NuGet, Chocolatey, PowerShellGet - we break it down</a></li>
<li><a href="../331128/index.html">Our recipe for a fail-safe Linux router</a></li>
<li><a href="../331130/index.html">Functional programming in Scala - is it necessary at all?</a></li>
<li><a href="../331132/index.html">It was 2017. Where is UDP fragmentation?</a></li>
<li><a href="../331136/index.html">What is the essence of design? I find the answer to the question considering the UI and UX, new terms in the field of web design</a></li>
<li><a href="../331138/index.html">Do not use return in Scala</a></li>
<li><a href="../331140/index.html">The history of creating one game, or Everything that does not kill us, makes us stronger</a></li>
<li><a href="../331142/index.html">Petrify Asynchronous Circuit Synthesis System: Problems and Solutions</a></li>
<li><a href="../331144/index.html">The list of domains in the zone ru / su / tatar / rf / kids is publicly available due to incorrect DNS settings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>