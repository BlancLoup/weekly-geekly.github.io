<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MySQL grammar on ANTLR 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Application-level firewall is designed to analyze and filter traffic for any application or class of applications, such as web applications or DBMS . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MySQL grammar on ANTLR 4</h1><div class="post__text post__text-html js-mediator-article"><p> <a href="https://habrahabr.ru/company/pt/blog/339336/"><img src="https://habrastorage.org/webt/59/d4/c9/59d4c94d20b25300224783.jpeg" alt="MySQL grammar on ANTLR 4"></a> </p><br><p>  <a href="https://en.wikipedia.org/wiki/Application_firewall">Application-level firewall is</a> designed to analyze and filter traffic for any application or class of applications, such as <a href="https://habrahabr.ru/company/pt/blog/269165/">web applications</a> or <a href="https://speakerdeck.com/dnkolegov/database-firewall-from-scratch">DBMS</a> .  When building it, it becomes necessary to <em>speak</em> the language of this application.  For a relational DBMS, this is the SQL dialect.  Suppose you need to build a firewall for the DBMS.  In this case, you will need to recognize and analyze SQL statements in order to make a decision about their compliance with a given security policy.  Depending on the tasks being solved (for example, detection of attacks like SQL injection, access control, correlation of SQL and HTTP requests), one or another depth of SQL analysis will be needed.  Either way, you need to perform lexical, syntactic and semantic analysis of SQL statements. </p><a name="habracut"></a><br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Introduction</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Formal grammar of the language</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Terminology used</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">MySQL language</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">ANTLR</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Lexer</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Where to begin</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Dot identifiers</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Strings</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Keywords</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">MySQL special comment type</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Register Independence</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Parser</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">MySQL text structure</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">MySQL sentence types</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">SELECT</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Expressions</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">UNION</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Grammar usage</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/339336/">Conclusion</a> </li></ul><br><h2 id="vvedenie">  Introduction </h2><br><h3 id="formalnaya-grammatika-yazyka">  Formal grammar of the language </h3><br><p>  In order to get a complete picture of the structure of the language and analyze it, you can use the formal grammar of this language.  With its help, it is possible both to generate sentences of a language, and, using <a href="https://habrahabr.ru/company/pt/blog/210772/">a parser</a> , to recognize sentences in it. </p><br><p>  According to the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25BE%25D0%25BC%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">Chomsky hierarchy</a> , there are four main types of languages ‚Äã‚Äãand, accordingly, four types of grammars.  Grammars differ in their generative possibilities.  MySQL is a context-sensitive language.  However, the list of language constructs that can only be generated by context-sensitive grammar is small.  As a rule, language constructions are used in practice, for generating which generation context-free grammar is sufficient.  This article describes the details of the development of context-free grammar for MySQL. </p><br><h3 id="ispolzuemaya-terminologiya">  Terminology used </h3><br><p> The language is determined on the basis of the alphabet - the set of characters.  The letters of the alphabet are combined into meaningful sequences called lexemes.  Tokens can be of different types (identifiers, strings, keywords, etc.).  A token is a tuple consisting of a token and a type name.  A phrase is a sequence of tokens arranged in a special order.  From sentences can be built sentences.  Further, a sentence is understood as a certain complete sequence of lexemes, which in the context of a given language has an independent meaning.  The concept of a <code></code> only makes sense in the applied field. </p><br><p>  Applications built on the basis of a language operate with sentences of this language, for example, they perform or interpret them.  Phrases, from the applied point of view, are incomplete constructions; they can form part of a sentence.  But when building a grammar it is convenient to use phrases.  In fact, phrases and sentences do not differ in terms of grammar - they correspond to some of its rules, on the right side of which there are non-terminal symbols. </p><br><p>  The use of language involves the construction or recognition of sentences.  The recognition task assumes that the sequence of tokens is input, and the output gives an answer to the question <em>whether this sequence is a set of correct sentences in this language</em> . </p><br><h3 id="yazyk-mysql">  MySQL language </h3><br><p>  The MySQL language is a dialect of the SQL language for writing queries to the MySQL DBMS.  By SQL language is meant a standard or, formally, a <a href="https://en.wikipedia.org/wiki/ISO/IEC_9075">series of ISO / IEC 9075 standards ‚ÄúInformation technology - Database languages ‚Äã‚Äã- SQL‚Äù</a> . </p><br><p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/compatibility.html">The MySQL dialect</a> is a concrete implementation of the standard with some limitations and additions.  Most MySQL sentences can be described by context-free grammar, but there are some sentences that need context-sensitive grammar rules to describe.  In simple terms, if the lexeme influences the further recognition of phrases, such a phrase is described by a context-dependent grammar rule. </p><br><p>  MySQL has some expressions based on this principle.  For example: </p><br><pre> <code class="sql hljs">DELIMITER SOME_LITERAL</code> </pre> <br><p>  In this case, you need to remember <code>SOME_LITERAL</code> , because in future sentences the literal <code>SOME_LITERAL</code> should be used as a symbol of their completion, and not <code>;</code>  . </p><br><p>  In a procedural extension, loop operators and block clauses can be labeled.  Their structure is as follows: </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">label</span></span> somephrases <span class="hljs-built_in"><span class="hljs-built_in">label</span></span></code> </pre> <br><p>  In this case, tag IDs must be the same.  You can display such a sentence only in context-sensitive grammar. </p><br><h2 id="antlr">  ANTLR </h2><br><p>  <a href="http://www.antlr.org/">ANTLR</a> parser generator was chosen for the development of the MySQL parser.  The main advantages of this generator: </p><br><ul><li>  <a href="http://www.antlr.org/license.html">free BSD license</a> ; </li><li>  <a href="">support for several target languages ‚Äã‚Äã(runtimes)</a> ; </li><li>  <a href="https://github.com/antlr/antlr4/tree/master/doc">good documentation</a> . </li></ul><br><p>  ANTLR involves a two-step algorithm for generating a recognition code.  First, the lexical structure of the language is described, <em>that</em> is, it is determined <em>what</em> are tokens.  The following describes the syntactic structure of the language, that is, the recognized tokens are grouped into sentences.  The lexical and syntactic structures in ANTLR are described using rules.  The lexical structure is determined by the type (token handle) and value.  To describe the value, a language with elements of regular expressions is used, but with support for recursion.  The syntactic structure rule is made up of token descriptors based on the sentence construction rules in ANTLR 4, which allow determining the structure of the location of lexemes in a sentence or phrase within a sentence. </p><br><p>  When constructing rules, one should take into account the basic principle of lexical analysis, which is also implemented in ANTLR.  Lexer first tries to recognize the longest sequence of characters from the input stream, suitable for any lexical rule.  If there are several such rules, then the first in the order of definition will be activated. </p><br><p>  Without the use of semantic predicates in ANTLR, only context-free grammar can be constructed.  The advantage is that in this case the resulting grammar will be independent of the execution environment.  The proposed grammar for the MySQL dialect is built without the use of semantic predicates. </p><br><h2 id="lekser">  Lexer </h2><br><h3 id="s-chego-nachat">  Where to begin </h3><br><p>  When developing a grammar, the first thing to do is to determine the list of types of tokens found in the language.  When recognizing tokens, the characters of the alphabet of the language will be input to the recognizer's input, from which it is necessary to make lexemes;  however, characters that are not involved in the construction of tokens can be filtered.  Such characters are whitespace and comments.  After filtering, only meaningful lexemes of the language will be included in the further analysis.  You can filter whitespace and comments like this: </p><br><pre> <code class="hljs coffeescript">SPACE: [ \t\r\n]+ -&gt; channel(HIDDEN); COMMENT_INPUT: <span class="hljs-string"><span class="hljs-string">'/*'</span></span> .*? <span class="hljs-string"><span class="hljs-string">'*/'</span></span> -&gt; channel(HIDDEN); LINE_COMMENT: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'-- '</span></span></span></span><span class="hljs-function"><span class="hljs-params"> | </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'#'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ~[\r\n]* </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\r'</span></span></span></span><span class="hljs-function"><span class="hljs-params">? </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\n'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> | EOF)</span></span></span><span class="hljs-function"> -&gt;</span></span> channel(HIDDEN);</code> </pre> <br><p>  You can also immediately take into account potential lexical errors and skip unknown characters: </p><br><pre> <code class="hljs erlang-repl">ERROR_RECONGNIGION: . -&gt; channel(ERRORCHANNEL);</code> </pre> <br><p>  If any characters are not recognized by any lexical rule, they are recognized by the <code>ERROR_RECONGNIGION</code> rule.  It is placed at the end of the grammar, since the last rule has the lowest priority. </p><br><p>  Now you can proceed to the selection of tokens.  As a rule, the following types of tokens can be distinguished: </p><br><ul><li>  keywords; </li><li>  identifiers; </li><li>  literals; </li><li>  Special symbols. </li></ul><br><p>  If there is no explicit (or implicit) intersection of these types of lexemes in the language, there are no problems and it is required to simply describe all the lexemes.  However, if intersections occur somewhere, they must be resolved.  The situation is complicated by the fact that <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">regular grammar is</a> used to recognize individual lexemes.  In MySQL, this problem occurs with " <a href="https://en.wikipedia.org/wiki/Fully_qualified_name">fully qualified name</a> " and with keywords that can be identifiers. </p><br><h3 id="identifikatory-s-tochkoy">  Dot identifiers </h3><br><p>  When recognizing MySQL tokens, such as <a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html">identifiers that begin with numbers</a> , there are some problems: the "."  can occur both in full column names and in real literals: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> table_name.column_name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> full_column_name ...</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>e <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> real_number ...</code> </pre> <br><p>  Thus, it is necessary to correctly recognize the full column name in the first case and the real literal in the second.  Intersection arises from the fact that identifiers in MySQL can begin with numbers. </p><br><p>  From the point of view of the MySQL language, the phrase: </p><br><pre> <code class="sql hljs">someTableName.1SomeColumn</code> </pre> <br><p>  is a sequence of three tokens: </p><br><pre> <code class="hljs">(someTableName, ), (. , -), (1SomeColumn, )</code> </pre> <br><p>  To do this, it is natural to use the rules: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">DOT</span></span>: .; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ID_LITERAL</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[0-9]</span></span>*<span class="hljs-selector-attr"><span class="hljs-selector-attr">[a-zA-Z_$]</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[a-zA-Z_$0-9]</span></span>*;</code> </pre> <br><p>  And for numbers like this: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">DECIMAL_LITERAL</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[0-9]</span></span>+;</code> </pre> <br><p>  After tokenization, a sequence of four tokens is obtained: </p><br><pre> <code class="hljs 1c">(someTableName, ), (. , -), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in"></span></span>), (SomeColumn, )</code> </pre> <br><p>  In order to avoid the ambiguity problem, you can introduce an auxiliary construction for identifying identifiers: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">fragment</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ID_LITERAL</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[0-9]</span></span>*<span class="hljs-selector-attr"><span class="hljs-selector-attr">[a-zA-Z_$]</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[a-zA-Z_$0-9]</span></span>*;</code> </pre> <br><p>  and determine the rules, sorted by priority: </p><br><pre> <code class="hljs objectivec">DOT_ID: <span class="hljs-string"><span class="hljs-string">'.'</span></span> ID_LITERAL; ... ID: ID_LITERAL; ... DOT: <span class="hljs-string"><span class="hljs-string">'.'</span></span></code> </pre> <br><p>  Since ANTLR recognizes sequences of maximum length, you can not be afraid of the "."  will be recognized as a separate character. </p><br><h3 id="stroki">  Strings </h3><br><p>  Using the example of strings, one more rule of lexical analysis, implemented in ANTLR, can be given.  A string in MySQL is a sequence of almost any characters enclosed in single or double quotes.  Single quotation strings cannot contain a single backslash or quotation mark, because the lexer does not determine where the string ends.  If you still need to use such signs, then <em>shielding</em> is used, which consists in replacing one quote with two consecutive quotes.  In addition, the escape character within a string cannot occur by itself, it must escape something.  Therefore, the individual appearances of this symbol must also be prohibited.  The result is the following fragment of the lexical rule: </p><br><pre> <code class="hljs pgsql">fragment SQUOTA_STRING: <span class="hljs-string"><span class="hljs-string">'\'' ('</span></span>\\<span class="hljs-string"><span class="hljs-string">'. | '</span></span>\<span class="hljs-string"><span class="hljs-string">'\'' | ~('</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">'\\'</span></span>))* <span class="hljs-string"><span class="hljs-string">'\'';</span></span></code> </pre> <br><ul><li> <code>'\\'.</code>  - allows backslash and the character that it escapes; </li><li>  <code>'\'\''</code> - allows a sequence of two single quotes; </li><li>  <code>~('\'' | '\\')</code> - prohibits the appearance of a single single quote or a single screen character. </li></ul><br><h3 id="klyuchevye-slova">  Keywords </h3><br><p>  The ANTLR lexer, unlike the parser, uses rules in order of priority.  Rules defined earlier have a higher priority than those described later.  This gives an obvious instruction on how to sort the rules: first, there are specific rules that define keywords and special characters, and then general rules that define literals, variables, identifiers, etc. </p><br><h3 id="specialnyy-tip-kommentariya-v-mysql">  MySQL special comment type </h3><br><p>  MySQL uses a multi-line <a href="https://dev.mysql.com/doc/refman/5.7/en/comments.html">comment of a special kind</a> .  Such comments allow you to create queries compatible with other DBMSs, isolating the specifics of MySQL.  MySQL when analyzing the query will analyze the text from such comments.  To recognize special MySQL comments, you can use the rule: </p><br><pre> <code class="hljs erlang-repl">SPEC_MYSQL_COMMENT: <span class="hljs-string"><span class="hljs-string">'/*!'</span></span> .+? <span class="hljs-string"><span class="hljs-string">'*/'</span></span> -&gt; channel(MYSQLCOMMENT);</code> </pre> <br><p>  However, it alone is not enough for the correct parsing of requests. </p><br><p>  Suppose that a request comes in as follows: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, info <span class="hljs-comment"><span class="hljs-comment">/*!, secret_info */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  When using such a rule, we get the following sequence of tokens: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">SELECT</span></span>, 'select') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'name') (<span class="hljs-name"><span class="hljs-name">COMMA</span></span>, ',') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'info') (<span class="hljs-name"><span class="hljs-name">SPEC_MYSQL_COMMENT</span></span>, '/*!, secret_info */') (FROM, 'from') (ID, 'users') (SEMI, ';')</code> </pre> <br><p>  At the same time, the standard MySQL lexer recognizes several other tokens: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">SELECT</span></span>, 'select') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'name') (<span class="hljs-name"><span class="hljs-name">COMMA</span></span>, ',') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'info') (<span class="hljs-name"><span class="hljs-name">COMMA</span></span>, ',') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'secret_info') (<span class="hljs-name"><span class="hljs-name">FROM</span></span>, 'from') (<span class="hljs-name"><span class="hljs-name">ID</span></span>, 'users') (<span class="hljs-name"><span class="hljs-name">SEMI</span></span>, '<span class="hljs-comment"><span class="hljs-comment">;')</span></span></code> </pre> <br><p>  Therefore, for correct recognition of a special type of comment in MySQL, additional processing is required: </p><br><ol><li>  The source text is recognized by a special pre-processing lexer. </li><li>  <code>SPEC_MYSQL_COMMENT</code> are extracted from the <code>SPEC_MYSQL_COMMENT</code> tokens and a new text is generated, which will be processed only by the MySQL server. </li><li>  Processing of the newly constructed text is performed using the usual parser and lexer. </li></ol><br><p>  A preprocessing lexer breaks the input stream into phrases related to: </p><br><ul><li>  to a special comment ( <code>SPEC_MYSQL_COMMENT</code> ); </li><li>  basic query ( <code>TEXT</code> ); </li></ul><br><p>  and can be built as follows: </p><br><pre> <code class="hljs pgsql">lexer grammar mysqlPreprocessorLexer; channels { MYSQLCOMMENT } <span class="hljs-type"><span class="hljs-type">TEXT</span></span>: ~<span class="hljs-string"><span class="hljs-string">'/'</span></span>+; SPEC_MYSQL_COMMENT: <span class="hljs-string"><span class="hljs-string">'/*!'</span></span> .+? <span class="hljs-string"><span class="hljs-string">'*/'</span></span>; //-&gt; channel(MYSQLCOMMENT); SLASH: <span class="hljs-string"><span class="hljs-string">'/'</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>(<span class="hljs-type"><span class="hljs-type">TEXT</span></span>);</code> </pre> <br><p>  As a result of the work of the <em>pre-lexer,</em> the request code is split into a sequence of <code>SPEC_MYSQL_COMMENT</code> and <code>TEXT</code> tokens.  If the MySQL dialect sentence is being processed, values ‚Äã‚Äãare combined from the <code>SPEC_MYSQL_COMMENT</code> tokens, which are combined with the values ‚Äã‚Äãof the <code>TEXT</code> tokens.  After that, the usual MySQL lexer is started for the resulting text.  In the case of another SQL dialect, the <code>SPEC_MYSQL_COMMENT</code> tokens <code>SPEC_MYSQL_COMMENT</code> simply deleted or placed in an isolated channel. </p><br><h3 id="registronezavisimost">  Register Independence </h3><br><p>  Almost all the lexemes in MySQL are case-insensitive, which means that the two following queries are identical: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">SelECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">fROm</span></span> t;</code> </pre> <br><p>  Unfortunately, in ANTLR there is no support for case-insensitive tokens, and for tokens one has to use the following entry using <em>fragment tokens</em> , which are used to build real tokens: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>; fragment S: [sS]; fragment E: [eE];</code> </pre> <br><p>  This reduces grammar readability.  Moreover, for each character, the lecturer has to choose from two options ‚Äî a character in upper or lower case ‚Äî which negatively affects performance. </p><br><p>  In order for the lexer code to be cleaner and the performance higher, the input stream of characters needs to be normalized, that is, lead to upper or lower case.  ANTLR supports a special stream, which does not consider the register during lexical analysis, but retains the register of the original token values.  These tokens can be used during tree traversal. </p><br><p>  The implementation of such a stream for different runtimes was proposed by <a href="https://habrahabr.ru/users/kvanttt/" class="user_link">KvanTTT</a> .  It can be found in the <a href="https://github.com/KvanTTT/DAGE/tree/master/AntlrGrammarEditor/Runtimes">DAGE</a> project, the cross-platform editor of grammars ANTLR 4. </p><br><p>  As a result, all tokens are written either in lower or upper case.  Since SQL keywords in queries are usually written in upper case, it was decided to use it also for grammar: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>: "SELECT"; <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>: "FROM";</code> </pre> <br><h2 id="parser">  Parser </h2><br><p>  To describe the syntactic structure of a language, it is necessary to determine the writing order: </p><br><ul><li>  sentences in the text; </li><li>  phrases in the sentence; </li><li>  tokens and phrases in more general phrases. </li></ul><br><h3 id="struktura-teksta-na-yazyke-mysql">  MySQL text structure </h3><br><p>  For MySQL, there is an excellent <a href="https://dev.mysql.com/doc/refman/5.7/en/">grammar description</a> , albeit distributed throughout the reference manual.  The structure of the location of sentences in the text is in the description section of the messaging protocol between the server and the MySQL client.  You can see that all offers, except perhaps the last, use a separator <code>;</code>  .  In addition, there is a nuance concerning a <a href="https://dev.mysql.com/doc/refman/5.7/en/ansi-diff-comments.html">line comment</a> : the last sentence in the text can end with such a comment.  As a result, it turns out that any correct sequence of MySQL statements should be presented as: </p><br><pre> <code class="hljs swift">root : sqlStatements? <span class="hljs-type"><span class="hljs-type">MINUSMINUS?</span></span> <span class="hljs-type"><span class="hljs-type">EOF</span></span> ; sqlStatements : (sqlStatement <span class="hljs-type"><span class="hljs-type">MINUSMINUS?</span></span> <span class="hljs-type"><span class="hljs-type">SEMI</span></span> | emptyStatement)* (sqlStatement (<span class="hljs-type"><span class="hljs-type">MINUSMINUS?</span></span> <span class="hljs-type"><span class="hljs-type">SEMI</span></span>)? | emptyStatement) ; ... <span class="hljs-type"><span class="hljs-type">MINUSMINUS</span></span>: '--';</code> </pre> <br><p>  The power of context-free grammar is not enough to fully support these rules, since the MySQL client can use <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-commands.html">the DELIMITER command</a> , with which you can set the current delimiter.  In this case, you need to remember and use the separator in other rules.  Thus, if this directive is used, correctly written SQL statements using the grammar in question will not be recognized. </p><br><h3 id="tipy-predlozheniy-v-mysql">  MySQL sentence types </h3><br><p>  MySQL sentences are of the <a href="https://dev.mysql.com/doc/refman/5.7/en/sql-syntax.html">following types</a> : </p><br><ul><li>  DDL; </li><li>  DML; </li><li>  transaction management offers; </li><li>  cluster management suggestions; </li><li>  Dynamic query creation suggestions </li><li>  server administration suggestions; </li><li>  offers of performance of service actions; </li><li>  proposals for procedural extensions. </li></ul><br><p>  After translating the documentation into the ANTLR 4 grammar, the root sentence will be as follows: </p><br><pre> <code class="hljs smalltalk">sqlStatement : ddlStatement | dmlStatement | transactionStatement | replicationStatement | preparedStatement | administrationStatement | utilityStatement</code> </pre> <br><p>  There is also an empty sentence consisting of one semicolon: </p><br><pre> <code class="hljs objectivec">empty_statement : SEMI ; SEMI: <span class="hljs-string"><span class="hljs-string">';'</span></span>;</code> </pre> <br><p>  Subsequent paragraphs of official documentation are transformed into ANTLR rules in a similar way. </p><br><h3 id="select">  SELECT </h3><br><p>  Perhaps the most interesting and extensive sentence in SQL in general and in MySQL in particular is the SELECT statement.  When writing grammar, the main attention was paid to the following parts: </p><br><ul><li>  the definition of tables; </li><li>  definition of expressions; </li><li>  combining using <code>UNION</code> . </li></ul><br><p>  Let's start with the definition of the tables.  In MySQL, there is quite a <a href="https://dev.mysql.com/doc/refman/5.7/en/join.html">serious description</a> of what can be used in the FROM field of a SELECT query (hereinafter, we will call this ‚Äútable links‚Äù).  After careful study and testing on existing versions, it becomes clear that the "table links" are a construction of the form: </p><br><pre> <code class="hljs">  1,   2, ‚Ä¶,   N</code> </pre> <br><p>  in which the "Tabular Object" is one of four constructs: </p><br><ul><li>  separate table; </li><li>  join tables; </li><li>  subquery; </li><li>  table references enclosed in brackets. </li></ul><br><p>  If we start from the less general, then we find that the table object is inductively defined as a table or as a table-based construction.  The latter may be: </p><br><ul><li>  join tables; </li><li>  subquery; </li><li>  a sequence of table objects enclosed in brackets. </li></ul><br><p>  Next, we find that the FROM field simply defines a sequence of table objects consisting of at least one table object.  Of course, the grammar defines additional constructions like "join conditions", references to partitions (PARTITION), etc., but the general structure is as follows: </p><br><pre> <code class="hljs pgsql">tableSources : tableSource (<span class="hljs-string"><span class="hljs-string">','</span></span> tableSource)* ; tableSource : tableSourceItem joinPart* | <span class="hljs-string"><span class="hljs-string">'('</span></span> tableSourceItem joinPart* <span class="hljs-string"><span class="hljs-string">')'</span></span> ; tableSourceItem : tableName (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> uidList <span class="hljs-string"><span class="hljs-string">')'</span></span> )? (<span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid)? (indexHint (<span class="hljs-string"><span class="hljs-string">','</span></span> indexHint)* )? #atomTableItem | (subquery | <span class="hljs-string"><span class="hljs-string">'('</span></span> parenthesisSubquery=subquery <span class="hljs-string"><span class="hljs-string">')'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid #subqueryTableItem | <span class="hljs-string"><span class="hljs-string">'('</span></span> tableSources <span class="hljs-string"><span class="hljs-string">')'</span></span> #tableSourcesItem ;</code> </pre> <br><h3 id="vyrazheniya">  Expressions </h3><br><p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/expressions.html">Expressions</a> are used everywhere in MySQL, wherever there is a need to compute a value (value vector).  An inductive expression can be defined as follows: </p><br><ul><li>  An expression is any type token: <br><ul><li>  constant (literal) value; </li><li>  variable; </li><li>  object identifier. </li></ul></li><li>  An expression is a superposition of expressions united by any transformations. </li></ul><br><p>  Transformations include operations, operators (including set-theoretic, comparison operators), functions, queries, parentheses. </p><br><h3 id="union">  UNION </h3><br><p>  Unlike other dialects, there are only two set-theoretic operations on tables in MySQL.  The first - JOIN - has already been reviewed.  Experimentally, it was found that the <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html">description of UNION</a> in official documentation is somewhat incomplete.  We have added it as follows: </p><br><pre> <code class="hljs erlang">selectStatement : <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Specification lockClause? #simpleSelect | <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Expression lockClause? #parenthesisSelect | <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>SpecificationNointo unionStatement+ ( UNION (ALL | DISTINCT)? (<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Specification | <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Expression) )? orderByClause? limitClause? lockClause? #unionSelect | <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>ExpressionNointo unionParenthesis+ ( UNION (ALL | DISTINCT)? <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Expression )? orderByClause? limitClause? lockClause? #unionParenthesisSelect ;</code> </pre> <br><p>  When using <code>UNION</code> individual queries can be enclosed in parentheses.  The requirement to use them is not mandatory, except when <code>ORDER BY</code> and <code>LIMIT</code> are used in queries.  However, if the first query in <code>UNION</code> enclosed in parentheses, all subsequent queries must be enclosed in them. </p><br><p>  Mistake: </p><br><pre> <code class="sql hljs">(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><p>  Right: </p><br><pre> <code class="sql hljs">(((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>); (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><h3 id="ispolzovanie-grammatiki">  Grammar usage </h3><br><p>  Grammar is written to solve problems of syntactic and lexical analysis.  On the one hand, it is necessary that the recognition be carried out as quickly as possible, and on the other, that the code of the generated lexer and parser can be safely used in own applications without affecting the capabilities and speed. </p><br><p>  An application that uses the parser is likely to use one of two design patterns ‚Äî <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Visitor</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Observer</a> .  Each of them involves the analysis of a specific subset of the nodes <a href="https://en.wikipedia.org/wiki/Parse_tree">of the parse tree</a> .  The nodes of the parse tree that are not leaves correspond to any syntactic rules of grammar.  When analyzing the nodes of the parse tree, you need to refer to the child nodes corresponding to the fragments of the original rule.  And you can apply to both individual nodes and groups of nodes. </p><br><p>          ""     .  ""           ,     .    ANTLR     <a href="https://habrahabr.ru/company/pt/blog/210060/">   </a> .          ,      Visitor,       . ,    MySQL    : </p><br><pre> <code class="hljs pgsql">tableSourceItem : tableName (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> uidList <span class="hljs-string"><span class="hljs-string">')'</span></span> )? (<span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid)? (indexHint (<span class="hljs-string"><span class="hljs-string">','</span></span> indexHint)* )? | (subquery | <span class="hljs-string"><span class="hljs-string">'('</span></span> parenthesisSubquery=subquery <span class="hljs-string"><span class="hljs-string">')'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid | <span class="hljs-string"><span class="hljs-string">'('</span></span> tableSources <span class="hljs-string"><span class="hljs-string">')'</span></span> ;</code> </pre> <br><p>  ,          : </p><br><ul><li> ; </li><li> ; </li><li>   ,   . </li></ul><br><p>       <em> </em>         : </p><br><pre> <code class="hljs pgsql">tableSourceItem : tableName (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> uidList <span class="hljs-string"><span class="hljs-string">')'</span></span> )? (<span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid)? (indexHint (<span class="hljs-string"><span class="hljs-string">','</span></span> indexHint)* )? #atomTableItem | (subquery | <span class="hljs-string"><span class="hljs-string">'('</span></span> parenthesisSubquery=subquery <span class="hljs-string"><span class="hljs-string">')'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>=uid #subqueryTableItem | <span class="hljs-string"><span class="hljs-string">'('</span></span> tableSources <span class="hljs-string"><span class="hljs-string">')'</span></span> #tableSourcesItem ;</code> </pre> <br><p> <em> </em>      .             .  ,   ()            .        .    ,    . </p><br><p> ,  : </p><br><pre> <code class="hljs sql">loadXmlStatement : <span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">LOW_PRIORITY</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENT</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">LOCAL</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">INFILE</span></span> STRING_LITERAL (<span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tableName (<span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> charsetName)? (<span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTIFIED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> STRING_LITERAL <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>)? ( <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> decimalLiteral (<span class="hljs-keyword"><span class="hljs-keyword">LINES</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span>) )? ( <span class="hljs-string"><span class="hljs-string">'('</span></span> assignmentField (<span class="hljs-string"><span class="hljs-string">','</span></span> assignmentField)* <span class="hljs-string"><span class="hljs-string">')'</span></span> )? (<span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> updatedElement (<span class="hljs-string"><span class="hljs-string">','</span></span> updatedElement)*)? ;</code> </pre> <br><p>     ,   ,   <code>LOAD XML</code> .     ,        <code>LOAD XML</code> : </p><br><ul><li>      -    ,  ; </li><li>       ; </li><li>               . </li></ul><br><p>      ,       ,    : </p><br><pre> <code class="hljs sql">loadXmlStatement : <span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">priority</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">LOW_PRIORITY</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENT</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">LOCAL</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">INFILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>=STRING_LITERAL violation=(<span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tableName (<span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> charsetName)? (<span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTIFIED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> tag=STRING_LITERAL <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>)? ( <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> decimalLiteral linesFormat=(<span class="hljs-keyword"><span class="hljs-keyword">LINES</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span>) )? ( <span class="hljs-string"><span class="hljs-string">'('</span></span> assignmentField (<span class="hljs-string"><span class="hljs-string">','</span></span> assignmentField)* <span class="hljs-string"><span class="hljs-string">')'</span></span> )? (<span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> updatedElement (<span class="hljs-string"><span class="hljs-string">','</span></span> updatedElement)*)? ;</code> </pre> <br><p>         ,       . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>    SQL- ,    ,     , , - .  ,    MySQL      ,  ,        ,    ,       MySQL  .     MySQL   ,   WordPress  Bitrix,    ,       - .        <a href="https://github.com/antlr/grammars-v4/tree/master/mysql">grammars-v4</a>   MIT. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339336/">https://habr.com/ru/post/339336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339322/index.html">Many, fast, distributed: how to choose an in-memory data grid solution</a></li>
<li><a href="../339324/index.html">Welcome Habrozhiteley</a></li>
<li><a href="../339330/index.html">Brain monitoring</a></li>
<li><a href="../339332/index.html">Digitizing and approximating graphs of functions using Wolfram Mathematica and Graph Digitizer</a></li>
<li><a href="../339334/index.html">Online quest from MBLTdev. Prizes from JetBrains</a></li>
<li><a href="../339338/index.html">Salesman bad luck and red october</a></li>
<li><a href="../339340/index.html">Fetish LaTeX (or Do not write in LaTeX! It is only for layout)</a></li>
<li><a href="../339342/index.html">Math Game 2048</a></li>
<li><a href="../339346/index.html">Happy Teacher's Day! Especially if you teach in IT</a></li>
<li><a href="../339348/index.html">We collect the first-aid kit information security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>