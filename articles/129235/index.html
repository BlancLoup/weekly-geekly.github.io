<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell in the real world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This blog has already written a lot about the Haskell language itself, and there have been several articles about its practical application. Now I‚Äôm i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell in the real world</h1><div class="post__text post__text-html js-mediator-article">  This blog has already written a lot about the <font color="blue">Haskell</font> language itself, and there have been several articles about its practical application.  Now I‚Äôm inspired to talk about one more real use of language in production. <br><a name="habracut"></a><br><h4>  Data description </h4><br>  I work in telecoms: fixed telephony, Internet, IP-telephony.  Tasks include processing of traffic from PBX, from IP-telephony servers, support of current billing, writing software and administering networks, domain (yes, "a programmer).  Recently, in my organization, new equipment was installed, operating on completely different principles, and traffic, respectively, has also changed.  Now it comes in two versions: from old stations and from new ones.  New traffic is duplicated in binary and text formats.  Binaries do not suit us at all (although some people unknowingly said: "Why are you there? You take them, and they drop by billing themselves!"), The text one takes an order of magnitude more space, but it is with it that you can do something.  The traffic from the old equipment is still on, and we and his partner are thrown with the help of proven schemes using the services of a local DBMS.  It would be possible to configure the same services for traffic from new stations, but several features were discovered.  Traffic at new stations is written into separate files every 15 minutes;  In total, there are about 3000 such files per month (ideally 2976 in 31 days and 2880 in 30 days).  You will not import each file separately, for insanity.  They can be merged into one and even necessary, since they are all text-based, and the call records are arranged line by line.  Manual merging looks like this: select files only for the last month and add them to the simplest merge script on the command line.  The file name format is fixed, therefore, the merge can be automated, only you have to parse the year and month.  Linuksoidy would use any <font color="blue">Bash</font> , <font color="blue">Perl</font> or <font color="blue">Python</font> , cheap and cheerful, but you can‚Äôt install them on a Windows machine for the sake of a single operation, the same goes for <font color="blue">PowerShell</font> .  And <font color="blue">cmd</font> is a perversion, as we well know.  ;) Finally, there were also surprises in the traffic itself, due to which, even after the merger and import using the means of the DBMS, a lot of manual SQL work was required.  In general, the factors somehow well formed into the task for <font color="blue">Haskell</font> , which I began to study at that time (April-May 2011). <br><br>  So, ~ 3000 15 minute files per month.  On the equipment, you can change the interval and set not 15 minutes, but any other value: 5, 10, 30, 45 ... The number of files and their sizes, respectively, will change.  Example of the file name (for 05/09/2011 09:30:00): <br><br><blockquote><pre>  999992011050909300081.txt
 99999 - identifier sewn into the equipment (for obvious reasons, I replaced it with nines)
      2011
          05 - month
            09 - day
              09 - hours
                30 minutes
                  00 - seconds
                    81 is a random number, possibly tenths of seconds. </pre></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are more subscribers, and each file is growing steadily in size.  We now have an average of 240 lines per file, but there was a seasonal summer subsidence, people left for holidays and called less.  For September, we are waiting for an increase in activity of one and a half to two times. <br><br>  Call records are varied.  There are several different record types that have a different number of fields.  R210 entries are very rare, and we didn‚Äôt find out what they mean (hereinafter the traffic data is replaced with random ones): <br><br><blockquote><pre>  | R210 | 2011-06-24 21: 43: 53 | 2011-06-24 01: 43: 52 | 1 | </pre></blockquote><br><br>  As you can easily see, there are only 4 fields here: the record type identifier, the start date, the end date (ISO 8601 / SQL format) and, for some reason, one.  The fields are separated by a vertical bar, which should stand at the beginning of the record and at the end, so it‚Äôs really 1 more fields, that is, 5. It‚Äôs convenient to assume that the field with the index 0 is empty is in front of the first vertical line.  Then the countdown of significant fields will go with 1. <br><br>  Regular calls are recorded in R200 records.  There are already 152 fields there, and this can be reconfigured on the equipment: some fields should be added, some should be removed, while others can be changed. <br><br><blockquote><pre>  | R200 | 99999 | 111111 | CR, CS, AM | 1 | 1 | 3022 | 222222 | 333333 ||| 2011-06-23 11: 33: 58 | C | 2011-06-23 11: 34: 22 | S | 0 | 16 | 1 |||||| 1 | 1 |||||| 3 | 162 | 17 | 1 | 12 | 24 |||||||||| 16 | 0 |||| || 192.168.1.172 || 192.168.1.12 ||||| 8 | 8 | 20 | 20 | 64 | 64 | 20 | 0 | 0 | OS | 7777 | 8888 | 555555 | 666666 | 0 | 8 | 9 | ||| OS | 19 ||| 30 | 10 | 42 | 43 ||||||||||| 1 |||||| 1 | 1 | 0 | 3 || 222222 ||||| || 2 | 1 || 333333 ||||||||||||||||||||||||||||||| </pre></blockquote><br><br>  We are interested in fields with indices <font color="blue">[7, 8, 9, 12, 14, 36, 112, 122]</font> , and in the final result I would like to filter everything that is unnecessary, so as not to import the excess into the DBMS.  Selecting from the raw data only the necessary, we get the line: <br><br><blockquote><pre>  Record: 3022 | 222222 | 333333 | 2011-06-23 11: 33: 58 | 2011-06-23 11: 34: 22 | 24 | 222222 | 333333
 Indices: 7 | 8 | 9 | 12 | 14 | 36 | 112 | 122

 Indices |  Explanation
 ---------------------------
 7 |  Cheat city code
 8, 112 |  outgoing number
 9, 122 |  incoming number
 12 |  date and time to start a conversation
 14 |  end date and time
 36 |  conversation duration in seconds </pre></blockquote><br><br>  All other fields are not particularly needed.  Some, as you can see, are generally empty, and the meaning of the others is unknown.  Is that the IP-addresses (changed) belong to two cards in the infrastructure of the telephone network, between which the RTP traffic will go.  Having imported these fields, one could study the load on the boards.  Perhaps in the future come in handy. <br><br>  Traffic records go tight, line by line.  Perhaps there are some other types of records, but they are not interesting to us.  For billing only R200 type entries are sufficient.  However, during a visual study of traffic, another interesting fact emerged.  Sometimes there were calls from the same number that started at the same time, but their duration was different.  At first, in the context of incomplete information, I thought it was some kind of glitch, because a person cannot call in parallel from the same number.  Then a pattern began to be seen, and finally, I understood what was the matter.  Here is an example of such entries for one phone number, I have thrown out all the extra fields for clarity: <br><br><blockquote><pre>  | 7 | 8 | 9 | 12 | 14 | 36 |
 | 3022 | 222222 | 333333 | 2011-05-23 13: 07: 54 | 2011-05-23 13: 37: 54 | 1800 |
 | 3022 | 222222 | 333333 | 2011-05-23 13: 07: 54 | 2011-05-23 13: 59: 40 | 3106 |

 | 3022 | 444444 | 555555 | 2011-05-23 14: 53: 52 | 2011-05-23 15: 23: 52 | 1800 |
 | 3022 | 444444 | 555555 | 2011-05-23 14: 53: 52 | 2011-05-23 15: 53: 52 | 3600 |
 | 3022 | 444444 | 555555 | 2011-05-23 14: 53: 52 | 2011-05-23 16: 00: 50 | 4018 |

 | 3022 | 666666 | 777777 | 2011-05-23 19: 15: 55 | 2011-05-23 19: 45: 54 | 1800 |
 | 3022 | 666666 | 777777 | 2011-05-23 19: 15: 55 | 2011-05-23 20: 15: 54 | 3600 |
 | 3022 | 666666 | 777777 | 2011-05-23 19: 15: 55 | 2011-05-23 20: 45: 54 | 5400 |
 | 3022 | 666666 | 777777 | 2011-05-23 19: 15: 55 | 2011-05-23 20: 47: 17 | 5483 | </pre></blockquote><br><br>  You can see now what the salt is, and then these records among thousands of them like me, among a heap of extra fields, letters and numbers, were not easy to find.  In general, it was either luck, or intuition, or magic.  :) And the solution is simple: the equipment every half hour (1800 seconds) marks a "milestone in the conversation" in case something happens.  Even if the last 29 minutes of the conversation were somehow lost, the entire previous three-hour discourse was recorded many times - for greater reliability.  The last entry will be current data.  Perhaps, on equipment, the duration of the milestones can be somehow changed, but for now their series looks like this: <font color="blue">[1800, 3600, 5400, 7200, 9000, over 9000 ..]</font> It is also noteworthy that the recording milestone differs in several "unimportant" fields from the record-result.  It may be worthwhile to take this into account in the future in order to better filter out the unnecessary, but for now I have decided to just throw out all entries with a duration from this series.  Theoretically, here a small percentage of normal calls will be lost, but for this you need a person to talk for half an hour to exactly one second.  The probability of this is very, very small, and our volumes are not so significant that the law of large numbers somehow influences the sample.  We called this phenomenon creatively: "The problem is 1800 seconds." <br><br><h4>  Briefly about the programs </h4><br>  In total, I created four programs that merged necessary files and filtered useful information.  Originally it was parser and merger - two programs, written separately and combined into a third one, also called merger.  They all worked extremely slowly and consumed a lot of memory, although they coped with tasks.  Data of one month (3000 files with 240 lines = 720000 lines) they could process for at least 10 minutes with 500 MB of memory (or even more, because the swap worked).  Very, very scary result.  And although the task had to be done once a month, my partner contemptuously wrinkled <font color="blue">Haskell's</font> nose.  True, <font color="blue">Haskell has</font> nothing to do with it;  I made this in the programs a number of typical mistakes of a novice functionary, because of which the curves algorithms worked very badly.  But worked!  Even more: the program (and the largest of them takes only 150 useful lines) could be configured from the command line.  Here are the features available: <br><br>  1. Work in the mode without parameters.  Fields are taken by default, files of the last month are taken. <br>  2. Work in the mode with parameters: <br>  - Fields [&lt;list of field indices&gt;] - which fields to take (parser Fields [1, 24, 55]); <br>  - (yyyy, mm) - what month to process (merger (2011, 5)); <br>  -W - do not close the console window after processing (from the word "wait"). <br>  3. It turned out three files: <br>  - yyyy.mm.txt - all files with raw traffic for this month were merged into it; <br>  - processed.txt - file with only the required fields for this month; <br>  - yyyy.mm.txt.log - a log file that lists the raw files involved and summarizes information (the number of lines, files, the date range). <br>  4. Programs display statistics and examples of processed traffic. <br><br>  A couple of times we used what it was, but then I, of course, rewrote the program from scratch.  Very much in the old code there was a lot of curved code, unnecessary bicycles, stupid algorithms and strange solutions.  As a result, the fourth program, NgnParser, with the same functionality and the same data set does not work 10 minutes, but 10 seconds, consuming only 10 MB of memory.  In terms of speed, the difference is almost two orders of magnitude and at least one is from memory!  What could such a thing be to slow down the program?  I suppose there are people who stepped on the same rake as I, who believed in the inhibition of the language rather than in their crooked hands - it‚Äôs not for nothing that there are so many screams on the Internet on the Internet ... <font color="blue">Haskell</font> is a wonderful language.  It was easy for me to write these programs.  For each, I spent no more than two working days.  And every time I received a lot of pleasure.  I can not imagine how much torture it would be if I did the same thing in <font color="blue">C.</font> <br><br><h4>  First program </h4><br>  I started the first program with a simple one.  For the time being I merged the necessary files into one (merged.txt) using the command line, and the task of parser was to parse the traffic and filter out the necessary entries with the identifier R200.  To process a large amount of text, it is more expedient to use a special type of string <font color="blue">ByteString</font> .  But working with it is not as convenient as with the usual type of <font color="blue">String</font> .  If <font color="blue">ByteString</font> is an optimized implementation of the string itself, then <font color="blue">String</font> is a list of characters, that is, <font color="blue">[Char]</font> .  <font color="blue">String</font> , due to its nature, is very convenient, but on large data, the performance of any lists drops sharply.  In the first versions of the program, it was <font color="blue">String</font> and a few stupid decisions that caused strong brakes and a big devouring of memory.  However, I was then worried about the speed of development, and not productivity.  I wrote the prototype of the program very quickly.  Here is what it looks like (revision 2): <br><br><blockquote>  replaceChars <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <br>  replaceChars whatC withC c <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> c <font color="#339933">==</font> whatC <font color="#06c">then</font> withC <font color="#06c">else</font> c <br><br>  interestFields <font color="#66cc66"><b>::</b></font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <br>  interestFields s takeWhat <font color="#66cc66"><b>=</b></font> <font>undefined</font> <font color="#5d478b">- Stub</font> <br><br>  isR200 <font color="#66cc66"><b>::</b></font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  isR200 s <font color="#66cc66"><b>=</b></font> <font>(</font> <font>head</font> s <font>)</font> <font color="#339933">==</font> <font>"R200"</font> <br><br>  processLine <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  processLine s <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> isR200 sInWords <font color="#06c">then</font> <font>unwords</font> <font>(</font> interestFields sInWords <font>[</font> <font color="red">1</font> <font color="#339933">,</font> <font color="red">2</font> <font color="#339933">,</font> <font color="red">3</font> <font>]</font> <font>)</font> <font color="#06c">else</font> <font>[</font> <font>]</font> <font color="#5d478b">- [1,2,3] - test fields</font> <br>  <font color="#06c">where</font> sInWords <font color="#66cc66"><b>=</b></font> <font>words</font> <font>(</font> <font>map</font> <font>(</font> replaceChars ' <font color="#339933">|</font> ' '' <font>)</font> s <font>)</font> <br><br>  processString <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <br>  processString s <font color="#66cc66"><b>=</b></font> <font>map</font> processLine <font>(</font> <font>lines</font> <font color="#339933">$</font> s <font>)</font> <br><br>  main <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  main <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  str <font color="#339933">&lt;-</font> <font>readFile</font> <font>"merged.txt"</font> <br>  <font>putStrLn</font> <font>(</font> intercalate <font>" <font>\ r</font> <font>\ n</font> "</font> <font>(</font> processString <font color="#339933">$</font> str <font>)</font> <font>)</font> </blockquote><br><br>  You can immediately notice the strange function <font color="blue">replaceChars</font> with type <font color="blue">Char -&gt; Char -&gt; Char -&gt; Char</font> .  The idea was this: take a string-record, replace the vertical line '|'  space and use the <font color="blue">words</font> function to split the string into words: <br><br><blockquote>  sInWords <font color="#66cc66"><b>=</b></font> <font>words</font> <font>(</font> <font>map</font> <font>(</font> replaceChars ' <font color="#339933">|</font> ' '' <font>)</font> s <font>)</font> </blockquote><br><br>  <font color="blue">Running sInWords</font> will result in the following conversion: <br><br><blockquote>  <font>"| R200 | 99999 | 111111 | CR, CS, AM | 1 | 1 | 3022 | 222222 | 333333 ||| 2011-06-23 11: 33: 58 |"</font>  <font color="#339933">-&gt;</font> <br>  <font>"R200 99999 111111 CR, CS, AM 1 1 3022 222222 333333 2011-06-23 11:33:58"</font> <font color="#339933">-&gt;</font> <br>  <font>[</font> <font>"R200"</font> <font color="#339933">,</font> <font>"99999"</font> <font color="#339933">,</font> <font>"111111"</font> <font color="#339933">,</font> <font>"CR, CS, AM"</font> <font color="#339933">,</font> <font>"1"</font> <font color="#339933">,</font> <font>"1"</font> <font color="#339933">,</font> <font>"3022"</font> <font color="#339933">,</font> <font>"222222"</font> <font color="#339933">,</font> <font>"333333"</font> <font color="#339933">,</font> <font>"2011-06-23"</font> <font color="#339933">,</font> <font>" 11:33:58 "</font> <font>]</font> </blockquote><br><br>  Unfortunately, the field with date-time will also be divided into two separate fields.  Later, in order to avoid this, I complicated the construction even more, initially replacing the space in this field with an asterisk and then returning it.  As a result, the string-record went through more transformations: <br><br>  Replacing '' -&gt; '*'; <br>  Replace '|'  -&gt; ''; <br>  Word splitting by the function <font color="blue">words</font> ; <br>  Processing the list of fields, getting the fields with the desired index; <br>  Merge fields with <font color="blue">unwords</font> function; <br>  Replacing '' -&gt; '|' <br>  Replacing '*' -&gt; '' <br><br>  In addition, after these terrible transformations, the number of fields received did not coincide with the number of initial ones, because empty fields eventually disappeared altogether (see the example of the transformation above).  It is good that in all the records the empty / filled fields were on the same places, but not that I would get unpleasant artifacts.  The code, as you see, is not only redundant, but also ugly.  I do not even dare to estimate its asymptotic complexity;  I think she far exceeded O (n ^ 2).  Moreover, closer to revision 12, I realized that something must be done with the fields that are lost due to double vertical lines.  And added another transformation: <br><br><blockquote>  <font color="#5d478b">- To empty fields, designated as "||", were processed correctly, a space is inserted between them.</font> <br>  refieldDoubles <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  refieldDoubles <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  refieldDoubles <font>(</font> ' <font color="#339933">|</font> ': <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>"|"</font> <br>  refieldDoubles <font>(</font> ' <font color="#339933">|</font> ': ' <font color="#339933">|</font> ': ss <font>)</font> <font color="#66cc66"><b>=</b></font> <font>"| |"</font>  <font color="#339933">++</font> <font>(</font> refieldDoubles <font>(</font> ' <font color="#339933">|</font> ': ss <font>)</font> <font>)</font> <br>  refieldDoubles <font>(</font> s: <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>[</font> s <font>]</font> <br>  refieldDoubles <font>(</font> s: ss <font>)</font> <font color="#66cc66"><b>=</b></font> s: <font>(</font> refieldDoubles ss <font>)</font> </blockquote><br><br>  Thereby added another full pass for each row!  That's really the truth - monkey work.  But it was necessary to do quite a bit: instead of all this, use the <font color="blue">split</font> function from the <font color="blue">Data.String.Utils</font> module, or write your own version.  Then, in just one pass through the record line, I would get the correct splitting into fields: <br><br><blockquote>  split <font>"|"</font>  <font>"| R200 | 99999 | 111111 | CR, CS, AM | 1 | 1 | 3022 | 222222 | 333333 ||| 2011-06-23 11: 33: 58 |"</font>  <font color="#339933">-&gt;</font> <br>  <font>[</font> <font>""</font> <font color="#339933">,</font> <font>"R200"</font> <font color="#339933">,</font> <font>"99999"</font> <font color="#339933">,</font> <font>"111111"</font> <font color="#339933">,</font> <font>"CR, CS, AM"</font> <font color="#339933">,</font> <font>"1"</font> <font color="#339933">,</font> <font>"1"</font> <font color="#339933">,</font> <font>"3022"</font> <font color="#339933">,</font> <font>"222222"</font> <font color="#339933">,</font> <font>"333333"</font> <font color="#339933">,</font> <font>""</font> <font color="#339933">,</font> <font>""</font> <font color="#339933">,</font> <font>"2011-06-23 11:33:58"</font> <font color="#339933">,</font> <font>""</font> <font>]</font> </blockquote><br>  What to say ... <s>facepalm</s> No, some emotions. <br><br><h4>  What improvements are possible </h4><br>  Experienced Haskellists have already noticed that the code does not use the pointless style (I have not yet felt it at the time), and there are almost no case constructions, pattern matching, or there any security expressions.  As a result, even such a simple code is difficult to read in some places.  Here is how it would be better to write several functions: <br><br><blockquote>  replaceSymbols s <font color="#66cc66"><b>=</b></font> <font>map</font> <font>(</font> replaceChar ' <font color="#339933">|</font> ' '' <font>)</font> <font>(</font> <font>map</font> <font>(</font> replaceChar '' ' <font color="#339933">*</font> ' <font>)</font> s <font>)</font> <br>  <font color="#5d478b">- -&gt;</font> <br>  replaceSymbols <font color="#66cc66"><b>=</b></font> <font>map</font> <font>(</font> replaceChar ' <font color="#339933">|</font> ' '' <font color="#339933">.</font> replaceChar '' ' <font color="#339933">*</font> ' <font>)</font> <br><br><br>  isR200 s <font color="#66cc66"><b>=</b></font> <font>(</font> <font>head</font> s <font>)</font> <font color="#339933">==</font> <font>"R200"</font> <br>  <font color="#5d478b">- -&gt;</font> <br>  isR200 <font>(</font> <font>"R200"</font> : <font color="#339933">_</font> <font>)</font> <font color="#66cc66"><b>=</b></font> True <br>  isR200 <font color="#339933">_</font> <font color="#66cc66"><b>=</b></font> False <br><br><br>  replaceChars whatC withC c <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> c <font color="#339933">==</font> whatC <font color="#06c">then</font> withC <font color="#06c">else</font> c <br>  <font color="#5d478b">- -&gt;</font> <br>  replaceChars whatC withC c <font color="#339933">|</font>  c <font color="#339933">==</font> whatC <font color="#66cc66"><b>=</b></font> withC <br>  <font color="#339933">|</font>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66"><b>=</b></font> c <br><br><br>  processLine s <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> isR200 sInWords <font color="#06c">then</font> <font>unwords</font> <font>(</font> interestFields sInWords <font>[</font> <font color="red">1</font> <font color="#339933">,</font> <font color="red">2</font> <font color="#339933">,</font> <font color="red">3</font> <font>]</font> <font>)</font> <font color="#06c">else</font> <font>[</font> <font>]</font> <br>  <font color="#06c">where</font> sInWords <font color="#66cc66"><b>=</b></font> <font>words</font> <font>(</font> <font>map</font> <font>(</font> replaceChars ' <font color="#339933">|</font> ' '' <font>)</font> s <font>)</font> <br>  <font color="#5d478b">- -&gt;</font> <br>  processLine s <font color="#339933">|</font>  isR200 sInWords <font color="#66cc66"><b>=</b></font> <font>unwords</font> <font>(</font> interestFields sInWords <font>[</font> <font color="red">1</font> <font color="#339933">,</font> <font color="red">2</font> <font color="#339933">,</font> <font color="red">3</font> <font>]</font> <font>)</font> <br>  <font color="#339933">|</font>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font color="#06c">where</font> sInWords <font color="#66cc66"><b>=</b></font> <font>words</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> replaceChars ' <font color="#339933">|</font> ' '' <font>)</font> <font color="#339933">$</font> s <br><br><br>  processString s <font color="#66cc66"><b>=</b></font> <font>map</font> processLine <font>(</font> <font>lines</font> <font color="#339933">$</font> s <font>)</font> <br>  <font color="#5d478b">- -&gt;</font> <br>  processString <font color="#66cc66"><b>=</b></font> <font>map</font> processLine <font color="#339933">.</font>  <font>lines</font> </blockquote><br><br>  The <font color="blue">intercalate</font> function <font color="blue">"\ r \ n"</font> generally needed to be replaced with <font color="blue">unlines</font> .  It would be both shorter and clearer, and even in tests, <font color="blue">unlines</font> showed great performance - at least 30%: <br><br><blockquote><pre>  ItemsCnt testUnlines (ns) testIntercalate (ns) Percent
 10 23.84 34.05 29.9
 100 22.70 34.62 34.4
 1000 23.28 35.48 34.3
 10000 22.17 35.48 37.5
 50000 22.13 33.26 33.4
 100000 21.06 35.47 40.6
 200000 22.70 34.05 33.3 </pre></blockquote><br><br>  But being still inexperienced, I didn‚Äôt know standard functions well even from the <font color="blue">Prelude</font> module, which is why I was bogging unnecessary bikes.  Although, even now I don‚Äôt really understand how to select the elements with the necessary indexes from the list of elements with minimal effort.  Compare the code from the old and the new program: <br><br><blockquote>  <font color="#5d478b">- Old code:</font> <br>  <font color="#5d478b">- Argument 1 - list of raw foods</font> <br>  <font color="#5d478b">- Argument 2 - list of required indices</font> <br>  takeInterest <font color="#66cc66"><b>::</b></font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <br>  takeInterest <font color="#339933">_</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  takeInterest ss <font>(</font> n: ns <font>)</font> <font color="#66cc66"><b>=</b></font> <font>[</font> ss <font color="#339933">!!</font>  n <font>]</font> <font color="#339933">++</font> takeInterest ss ns <br><br>  <font color="#5d478b">- New code:</font> <br>  <font color="#5d478b">- Argument 1 - Battery</font> <br>  <font color="#5d478b">- Argument 2 - list of required indices</font> <br>  <font color="#5d478b">- Argument 3 - list of raw fields</font> <br>  collectFields <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <br>  collectFields <font color="#339933">_</font> <font color="#339933">_</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  collectFields idx fis <font>(</font> s: ss <font>)</font> <font color="#339933">|</font>  idx ` <font>elem`</font> fis <font color="#66cc66"><b>=</b></font> s: collectFields <font>(</font> idx <font color="#339933">+</font> <font color="red">1</font> <font>)</font> fis ss <br>  collectFields idx fis <font>(</font> s: ss <font>)</font> <font color="#339933">|</font>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66"><b>=</b></font> collectFields <font>(</font> idx <font color="#339933">+</font> <font color="red">1</font> <font>)</font> fis ss </blockquote><br><br>  In the first case, we iterate the index list and pull out the item using an insecure function <font color="blue">!!</font>  .  In the second case, we use the battery at the same time as we iterate through the list of fields, and if the battery is in the list of indices, we take the current field with the battery index into the collection.  And there, and there - tail recursion.  Although, according to tests, the new code was 40% slower.  Perhaps, in this case, it is worth returning the old code - to speed up the new program even more. <br><br><blockquote><pre>  ItemsCnt takeInterest (ns) collectFields (ns) Percent
 10 17.33 36.84 52.9
 100 20.58 36.84 44.1
 1000 21.67 37.92 42.8
 10000 21.13 36.84 42.6
 50000 21.67 37.92 42.8 </pre></blockquote><br><br><h4>  Go ahead </h4><br>  The next program, merger, was supposed to merge all text files from the previous month into one.  (I didn‚Äôt want to do it every time manually, but laziness, as we know, is a mover of progress.) The question arose: how can we find out what our last month will be like?  Yes, in general, it is simple: we take the current date and subtract one month.  The program was to be used exclusively in the first days of the month, so there were no problems foreseen.  The current date and date-time operations in general are in the <font color="blue">Time</font> module.  Operations with the file system structure are in the <font color="blue">System.Directory</font> module.  Both functions and other functions mainly work in the <font color="blue">IO</font> monad, and at that time I still couldn‚Äôt even brush the monad code, as a result it looks creepy (merger, revision 14): <br><br><blockquote>  main <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  main <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  args <font color="#339933">&lt;-</font> getArgs <br>  curDir <font color="#339933">&lt;-</font> getCurrentDirectory <br>  dirContents <font color="#339933">&lt;-</font> getDirectoryContents curDir <br>  curTime <font color="#339933">&lt;-</font> T.  getClockTime <br>  monthAgoTime <font color="#339933">&lt;-</font> <font>return</font> <font color="#339933">$</font> T.  addToClockTime <font>(</font> T. TimeDiff <font color="red">0</font> <font>(</font> <font color="#339933">-</font> <font color="red">1</font> <font>)</font> <font color="red">0</font> <font color="red">0</font> <font color="red">0</font> <font color="red">0</font> <font color="red">0</font> <font>)</font> curTime <br>  calendarMonthAgoTime <font color="#339933">&lt;-</font> T.  toCalendarTime monthAgoTime <br>  <font color="#06c">let</font> maybeDateRange <font color="#66cc66"><b>=</b></font> <font color="#06c">case</font> args <font color="#06c">of</font> <br>  <font>(</font> a: b: <font color="#339933">_</font> <font>)</font> <font color="#339933">-&gt;</font> readDateRange <font>(</font> <font>unwords</font> <font>[</font> a <font color="#339933">,</font> b <font>]</font> <font>)</font> <br>  <font color="#339933">_</font> <font color="#339933">-&gt;</font> Just <font color="#339933">$</font> defaultDateRange calendarMonthAgoTime <br>  <font color="#06c">case</font> maybeDateRange <font color="#06c">of</font> <br>  Just dr <font color="#339933">-&gt;</font> <font color="#06c">do</font> <br>  <font color="#06c">let</font> fsToMerge <font color="#66cc66"><b>=</b></font> filesToMerge dirContents dr <br>  <font color="#06c">let</font> fsToMergeCountStr <font color="#66cc66"><b>=</b></font> <font>show</font> <font color="#339933">$</font> <font>length</font> fsToMerge <br>  <font color="#06c">let</font> mergeLog <font color="#66cc66"><b>=</b></font> <font>(</font> newFileName dr <font color="#339933">++</font> <font>".log"</font> <font>)</font> <br>  <font color="#06c">let</font> dateRangeMsg <font color="#66cc66"><b>=</b></font> <font>"DateRange:"</font> <font color="#339933">++</font> <font>show</font> dr <br>  fsContents <font color="#339933">&lt;-</font> merge fsToMerge <br>  <font>writeFile</font> <font>(</font> newFileName dr <font>)</font> <font>(</font> <font>unlines</font> fsContents <font>)</font> <br>  <font>writeFile</font> mergeLog <font>(</font> <font>unlines</font> fsToMerge <font color="#339933">++</font> printf <font>" <font>\ n</font> % s <font>\ n</font> Total files:% s"</font> dateRangeMsg fsToMergeCountStr <font>)</font> <br>  <font>putStrLn</font> <font>(</font> <font>unlines</font> fsContents <font>)</font> <br>  <font>putStrLn</font> dateRangeMsg <br>  <font color="#5d478b">--putStrLn ("Files to merge:" ++ unlines fsToMerge)</font> <br>  <font>putStrLn</font> <font>(</font> printf <font>"Count of files:% s. See% s for file list."</font> fsToMergeCountStr mergeLog <font>)</font> <br>  Nothing <font color="#339933">-&gt;</font> <font>putStrLn</font> <font>(</font> <font>"Invalid date range."</font> <font>)</font> </blockquote><br><br>  What this code is doing is not even recommending to delve into ... But it was here that the germ of a huge future error crept in, due to which the latest version of the old program devoured a huge amount of memory.  Consider the <font color="blue">merge</font> function, which is called from this code: <br><br><blockquote>  merge <font color="#66cc66"><b>::</b></font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font>]</font> <br>  merge fsToMerge <font color="#66cc66"><b>=</b></font> <font>mapM</font> <font>readFile</font> fsToMerge </blockquote><br><br>  It accepts the list of files to be merged, reads them and returns a list of their contents.  There are two lines in the code: <br><br><blockquote>  <font color="#06c">do</font> <br>  <font color="#339933">...</font> <br>  fsContents <font color="#339933">&lt;-</font> merge fsToMerge <br>  <font>writeFile</font> <font>(</font> newFileName dr <font>)</font> <font>(</font> <font>unlines</font> fsContents <font>)</font> <br>  <font color="#339933">...</font> </blockquote><br><br>  The key point is <font color="blue">unlines fsContents</font> .  That is, all the raw contents of all files were combined in one sitting and pushed into the result file.  Later, when parser and merger were combined, it was this huge amount of data that was transferred to parser-part processing, where, you remember, there is a whole bunch of replacements, passes, and other overheads.  Here is what this part of the code looks like in the old program built from parser and merger: <br><br><blockquote>  <font color="#06c">do</font> <br>  <font color="#339933">...</font> <br>  fsContents <font color="#339933">&lt;-</font> readFilesToMerge fsToMerge <br>  <font color="#06c">let</font> mergedContents <font color="#66cc66"><b>=</b></font> <font>unlines</font> fsContents <br>  <font>writeFile</font> <font>(</font> newFileName dr <font>)</font> mergedContents <br>  <font color="#06c">let</font> processedContentStr <font color="#66cc66"><b>=</b></font> <font>unlines</font> <font color="#339933">$</font> processData nedeedFields mergedContents <br>  <font color="#339933">...</font> </blockquote><br><br>  And this is not just <s>facepalm</s> bad, it is a gross violation of the dataflow concept.  It should be like this: <br><br><blockquote><pre>  Scheme 1
        _____ _____ _____ 
       |  |  |  |  |  |
 A1 -&gt; | F (A1) |  -&gt; B1 -&gt; | G (B1) |  -&gt; C1 -&gt; | H (C1) |  -&gt; RESULT 1 -&gt; SAVE
       | _____ |  | _____ |  | _____ |

        _____ _____ _____
       |  |  |  |  |  |
 A2 -&gt; | F (A2) |  -&gt; B2 -&gt; | G (B2) |  -&gt; C2 -&gt; | H (C2) |  -&gt; RESULT 2 -&gt; SAVE
       | _____ |  | _____ |  | _____ |

        _____ _____ _____ 
       |  |  |  |  |  |
 A3 -&gt; | F (A3) |  -&gt; B3 -&gt; | G (B3) |  -&gt; C3 -&gt; | H (C3) |  -&gt; RESULT 3 -&gt; SAVE
       | _____ |  | _____ |  | _____ |


 ...-&gt; ... -&gt; ... -&gt; ... -&gt; ... -&gt; ... -&gt; RESULT n -&gt; SAVE </pre></blockquote><br><br>  And it turned out like this: <br><br><blockquote><pre>  Scheme 2
     ____________________ ____________________ ____________________
    |  |  |  |  |  |
    |  |  |  |  |  |
    |  |  |  |  |  |
 A-&gt; |  F (A) | -&gt; B-&gt; |  G (B) | -&gt; -&gt; |  H (C) | -&gt; RESULT-&gt; SAVE
    |  |  |  |  |  |
    |  |  |  |  |  |
    | ____________________ |  | ____________________ |  | ____________________ | </pre></blockquote><br><br>  I felt the difference between sequential processing of parts and processing of everything at once.  Now I know: it‚Äôs not worth taking the whole amount of work right away, it‚Äôs better to create a mechanism that issues data in chunks - it will be as efficient from memory as well as speed better.  And, among other things, the program made according to the second scheme cannot be parallelized.  Horror, in one word ... <br><br>  Later I tried to optimize the old program - I replaced <font color="blue">String</font> with <font color="blue">ByteString</font> almost everywhere.  The winnings, of course, were small, but you couldn‚Äôt disperse the fan. <br><br>  Need I say that the new program, NgnTraffic, I did, having already a normal stock of knowledge?  It is observed a lot.  The program is divided into modules: <font color="blue">Main</font> , <font color="blue">Constants</font> , <font color="blue">DataProcess</font> , <font color="blue">FileListProces</font> , <font color="blue">Options</font> , <font color="blue">Tools</font> , <font color="blue">Types</font> .  <font color="blue">Of</font> course, scheme 1 is used. Instead of <font color="blue">String</font> , the type <font color="blue">ByteString</font> (Strict-variant) is initially taken.  The code is more coiffed, even without a point style available.  And, most importantly, the principle of action has changed.  First, a list of files to be processed is compiled - this part is similar to the one from the old program.  Then, however, the files are not read all at once into one large variable, but each is read separately.  Its contents are immediately processed, the lines are parsed, the records are filtered, the necessary fields are pulled out.  The result is added to the resulting file.  As a result, we have the cycle "Reading from disk ( <font color="blue">F (An)</font> ) - Processing lines ( <font color="blue">G (Bn)</font> ) - Writing the result to disk ( <font color="blue">H (Cn)</font> )" - and so many times by the number of files.  Plus, of course, there is no substitution of one character for another, but there is a simple <font color="blue">split</font> function from the <font color="blue">Data.ByteString.Char8</font> module, which in one pass breaks a string-record into fields and by itself wins a monstrous share of performance.  Here are the functions that satisfy the scheme 1: <br><br><blockquote>  process' <font color="#66cc66"><b>::</b></font> ResFilePath <font color="#339933">-&gt;</font> FieldIndexes <font color="#339933">-&gt;</font> FilePath <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  process' resFile fis targetFile <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  fileContents <font color="#339933">&lt;-</font> C.  <font>readFile</font> targetFile <br>  <font color="#06c">let</font> processResult <font color="#66cc66"><b>=</b></font> processData fis predicates fileContents <br>  C.  <font>appendFile</font> resFile processResult <br><br>  process <font color="#66cc66"><b>::</b></font> ResFilePath <font color="#339933">-&gt;</font> <font>[</font> FilePath <font>]</font> <font color="#339933">-&gt;</font> FieldIndexes <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  process <font color="#339933">_</font> <font>[</font> <font>]</font> <font color="#339933">_</font> <font color="#66cc66"><b>=</b></font> <font>return</font> <font>"No files to process."</font> <br>  process resFile fs fieldIndexes <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  C.  <font>writeFile</font> resFile c <font color="#339933">.</font>  empty <br>  <font>mapM_</font> <font>(</font> process' resFile fieldIndexes <font>)</font> fs <br>  <font>return</font> <font>"All ok."</font> </blockquote><br><br>  Here process takes the name of the result file, the list of files to process, and the indices of the required fields.  Indexes can come from the command line, so they are derived as an argument to this function.  process takes the name of each file in turn and applies the <font color="blue">process '</font> function to it (in the line <font color="blue">mapM_ (process' resFile fieldIndexes) fs</font> ).  She is already engaged in the main work with files.  The <font color="blue">processData</font> function takes care of the file contents.  It is interesting that, in addition to filtering the R200 records, a predicate mechanism was created in the new program: you can check any record by the available predicate, and the predicates themselves can be easily supplemented.  So far two have been done: the field with the index x belongs to the list of fields and does not belong to it.  This is the type of predicate: <br><br><blockquote>  <font color="#06c">data</font> Predicate <font color="#66cc66"><b>=</b></font> NotInList <font>[</font> C.  ByteString <font>]</font> <br>  <font color="#339933">|</font>  InList <font>[</font> C.  ByteString <font>]</font> <br>  <font color="#06c">type</font> PredicateMap <font color="#66cc66"><b>=</b></font> <font>[</font> <font>(</font> FieldIndex <font color="#339933">,</font> Predicate <font>)</font> <font>]</font> </blockquote><br><br>  And these are given predicate constants: <br><br><blockquote>  predicates <font color="#66cc66"><b>::</b></font> PredicateMap <br>  predicates <font color="#66cc66"><b>=</b></font> <font>[</font> <font>(</font> <font color="red">1</font> <font color="#339933">,</font> InList <font>[</font> C. pack <font>"R200"</font> <font>]</font> <font>)</font> <font color="#339933">,</font> <br>  <font>(</font> <font color="red">36</font> <font color="#339933">,</font> NotInList <font>(</font> <font>map</font> C. pack <font>[</font> <font>"1800"</font> <font color="#339933">,</font> <font>"3600"</font> <font color="#339933">,</font> <font>"5400"</font> <font color="#339933">,</font> <font>"7200"</font> <font color="#339933">,</font> <font>"9000"</font> <font color="#339933">,</font> <font>"10800"</font> <font color="#339933">,</font> <font>"12600"</font> <font color="#339933">,</font> <font>"14400"</font> <font color="#339933">,</font> <font>"16200"</font> <font color="#339933">,</font> <font>"18000"</font> <font color="#339933">,</font> <font>"19800"</font> <font color="#339933">,</font> <font>"21600"</font> <font color="#339933">,</font> <font>"23400"</font> <font>]</font> <font>)</font> <font>)</font> <font>]</font> </blockquote><br><br>  It is not difficult to guess that only those records whose field 1 is equal to ‚ÄúR200‚Äù will satisfy the predicates, and field 36 is not in the ‚ÄúProblems of 1800 seconds‚Äù list.  Filtering occurs in the <font color="blue">checkPredicate</font> and <font color="blue">examineFields functions</font> : <br><br><blockquote>  checkPredicate <font color="#66cc66"><b>::</b></font> Predicate <font color="#339933">-&gt;</font> C.  ByteString <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  checkPredicate <font>(</font> NotInList l <font>)</font> str <font color="#66cc66"><b>=</b></font> <font>(</font> <font>not</font> <font color="#339933">.</font> <font>elem</font> str <font>)</font> l <br>  checkPredicate <font>(</font> InList l <font>)</font> str <font color="#66cc66"><b>=</b></font> <font>elem</font> str l <br><br>  examineFields <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> PredicateMap <font color="#339933">-&gt;</font> Fields <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  examineFields <font color="#339933">_</font> <font color="#339933">_</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> True <br>  examineFields idx preds <font>(</font> s: ss <font>)</font> <font color="#66cc66"><b>=</b></font> <font color="#06c">case</font> L.  <font>lookup</font> idx preds <font color="#06c">of</font> <br>  Just <font>pred</font> <font color="#339933">-&gt;</font> <font>(</font> checkPredicate <font>pred</font> s <font>)</font> <font color="#339933">&amp;&amp;</font> <font>(</font> examineFields <font>(</font> idx <font color="#339933">+</font> <font color="red">1</font> <font>)</font> preds ss <font>)</font> <br>  Nothing <font color="#339933">-&gt;</font> examineFields <font>(</font> idx <font color="#339933">+</font> <font color="red">1</font> <font>)</font> preds ss </blockquote><br><br>  Now I see that the <font color="blue">examineFields</font> function could have been done through <font color="blue">foldr</font> , but this is so, little things. <br><br>  In general, I am pleased with the work done.  This rarely happens - but I like the NgnTraffic code.  And I especially like the progress that has become visible on the example of the same program, written at different times and with different knowledge.  And ‚Äúeven more special‚Äù is the fact that this is a real <font color="blue">Haskell</font> program used in real production. <br><br>  No matter what anyone says, <font color="blue">Haskell</font> is a terrific language, the best one I've ever worked with. <br><br>  Source code parser for revisions: <a href="">[2]</a> , <a href="">[6]</a> , <a href="">[12]</a> <br>  Merger sources (including merger merged program): <a href="">[13]</a> , <a href="">[14]</a> , <a href="">[16]</a> , <a href="">[23]</a> <br>  <a href="https://github.com/graninas/Haskell-Algorithms/tree/master/Programs/NgnTraffic">NgnTraffic Sources</a> <br><br>  PS Translation of the next part of Yet Another Monad Tutorial too soon. <br>  PPS Corrected links to the program, thanks to <a href="http://habrahabr.ru/users/steck/" class="user_link">my</a> friend <a href="http://habrahabr.ru/users/steck/" class="user_link">steck</a> . <br>  <a href="http://habrahabr.ru/users/goder/" class="user_link">PPPS Fixed a</a> couple of errors, thanks <a href="http://habrahabr.ru/users/goder/" class="user_link">goad</a> and <a href="http://habrahabr.ru/users/jack128/" class="user_link">jack128 comrades</a> . </div><p>Source: <a href="https://habr.com/ru/post/129235/">https://habr.com/ru/post/129235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129229/index.html">Prices for PlayBook tablets reduced by 100-200 dollars</a></li>
<li><a href="../129231/index.html">3D technologies of the future: Sony's Personal 3D Viewer HMZ-T1</a></li>
<li><a href="../129232/index.html">The unique scheme of hacking mobile phones in Russia - how it worked</a></li>
<li><a href="../129233/index.html">We write a bot, or "The Tale of the Good Bot"</a></li>
<li><a href="../129234/index.html">We write a simple application using GoogleMap and pumped SimpleCursorAdapter</a></li>
<li><a href="../129236/index.html">Interfaces: Simplify the search engine (or why we don‚Äôt)</a></li>
<li><a href="../129237/index.html">Dojo-do-it-yourself widget</a></li>
<li><a href="../129239/index.html">Start Motivate Clock: ‚ÄúDo not think about seconds down‚Äù</a></li>
<li><a href="../129240/index.html">Tuning for the Public folder in Dropbox</a></li>
<li><a href="../129241/index.html">Development of RvaToRaw and RawToRva features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>