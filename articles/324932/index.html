<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about stack traces and hip dumps. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Practice has shown that hardcore transcripts from our reports come in well, so we decided to continue. Today we have a mix of approaches to searching ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about stack traces and hip dumps. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Practice has shown that hardcore transcripts from our reports come in well, so we decided to continue.  Today we have a mix of approaches to searching and analyzing errors and crashes in the menu, seasoned with a pinch of useful tools, prepared on the basis of a report by Andrey Pangin aka <a href="https://habrahabr.ru/users/apangin/" class="user_link">apangin</a> from Odnoklassniki on one of the JUGs (this was a finished version of his report from JPoint 2016).  In the seven-minute, two-hour report, Andrew talks in detail about stack traces and hip dumps. <br><br>  The post turned out just huge, so we broke it into two parts.  Now you are reading the first part, the second part is <a href="https://habr.ru/p/325064/">here</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0pyZERLBZvQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today I will talk about stack-traces and hip-dumps - a theme, on the one hand, known to everyone, on the other - allowing you to constantly open something new (I even found the bug in the JVM while I was preparing this topic). <br><br>  When I did a training run of this report in our office, one of my colleagues asked: ‚ÄúIs this all very interesting, but in practice is it useful for anyone?‚Äù After this conversation, I added a page with questions on the topic to my presentation in my first presentation. Stackoverflow.  So this is relevant. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/0da/f23/8b8/0daf238b834797ff3a37bc9c73a8a36b.png"><br><br>  I myself work as a lead programmer at Odnoklassniki.  And it so happened that often I have to work with the guts of Java - tyunit it, look for bugs, pull something through system classes (sometimes not in completely legal ways).  From there I gathered most of the information I wanted to present to you today.  Of course, my previous experience helped me a lot with this: I worked for 6 years at Sun Microsystems, was directly involved in developing a Java virtual machine.  So now I know this topic from the inside of the JVM, as well as from the part of the user developer. <br><br><h2>  Stack traces </h2><br><h4>  Stack traces exception </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/a55/412/c74/a55412c74e84bcf962b0ea50aabf9349.png"><br><br>  When a novice developer writes his ‚ÄúHello world!‚Äù, He jumps out with an exception and shows him the stack-trace where this error occurred.  So the majority have some ideas about stack-traces. <br><br>  Let's go straight to the examples. <br><br>  I wrote a small program that, in a cycle 100 million times, performs such an experiment: it creates an array of 10 random elements of type long and checks whether it is sorted or not. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo1; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ThreadLocalRandom; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProbabilityExperiment</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] &gt; array[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) {                <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;            }        }        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;    }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> experiments, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sorted = <span class="hljs-number"><span class="hljs-number">0</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; experiments; i++) {            <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {                <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] array = ThreadLocalRandom.current().longs(length).toArray();                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isSorted(array)) {                    sorted++;                }            } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) {                e.printStackTrace();            }        }        System.out.printf(<span class="hljs-string"><span class="hljs-string">"%d of %d arrays are sorted\n"</span></span>, sorted, experiments);    }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProbabilityExperiment().run(<span class="hljs-number"><span class="hljs-number">100_000_000</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);    } }</code> </pre> <br>  In fact, he considers the probability of obtaining a sorted array, which is approximately equal to <code>1/n!</code>  .  As is often the case, in the program were wrong on one: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; array.<span class="hljs-built_in"><span class="hljs-built_in">length</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++)</code> </pre> <br>  What will happen?  Exception, out of bounds array. <br>  Let's figure out what's wrong.  Our console displays: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span></span></code> </pre> <br>  but there is no stack of traces.  Where are you? <br><br>  In HotSpot JVM there is such an optimization: execs that are thrown by the JVM itself from a hot code, and in this case the code is hot - it jerks 100 million times, stack-traces are not generated. <br>  This can be fixed with the help of a special key: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-XX</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-OmitStackTraceInFastThrow</span></span></code> </pre> <br>  Now let's try to run an example.  We get all the same, only all stack traces are in place. <br><br>  This optimization works for all implicit exceptions that are thrown by the JVM: going beyond the bounds of the array, dereferencing the null pointer, etc. <br><br><img src="https://lh5.googleusercontent.com/2UhbWIToemwYVSEJwixGRMDgHeCJy-oOmscgXnMqruFMbY1SuoJD2UDyemxbVNCEHiBPJX3wt7ijanZItAOqGJk8y5iEVj84f5ASjI1SPA9Qt3Ikyr3q8OCeKsGXVTqE_Fua3EdJ"><br><br>  Once the optimization was invented, then it is for some reason needed?  It is clear that it is more convenient for a programmer when there are stack-traces. <br><br>  Let's measure how much "costs" we have to create an exception (compare with some simple Java object, like Date). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">date</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exception</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(); }</code> </pre><br>  With the help of JMH, we write a simple benchmark and measure how many nanoseconds both operations take. <br><br><img src="https://lh4.googleusercontent.com/GzW0KZpdeZ-sfJ5Y4jgPFlRDxri8_LysgvnuI5iYqj7Fgg0zLmYrR2G6Yymark5yaEgzuNWuNHWG6Fy4A_BAmU7-amlhyA3NcIUzjGmydVdq_qCt0lVE-TEJd0mGltT2b72dSadB"><br><br>  It turns out that creating an event is 150 times more expensive than a regular object. <br>  And here is not so simple.  For a virtual machine, the event is no different from any other object, but the answer lies in the fact that almost all the constructors are somehow reduced to calling the fillInStackTrace method, which fills the stack trace of this event.  Filling a stack trail takes time. <br><br><img src="https://lh4.googleusercontent.com/0NAXHkzh5rzPipzSf8VENmQYH-fG7rS2R_AjxY9dW6cCno6AQvLTqI1hmzW_L8cyvFHTESrU9jn5FahCmgUB6fBfJ6dAapdgfZsKYPxZ7DYuHejmMvjxymWVMSWmx4olv3FW6xQG"><br><br>  This method, in turn, is native, it drops into the VM runtime and there it walks along the stack, gathers all the frames. <br><br>  The fillInStackTrace method is public, not final.  Let's just redefine it: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exceptionNoStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Throwable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillInStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; }</code> </pre> <br>  Now the creation of a regular object and an escape without a stack trace takes the same time. <br><br><img src="https://lh3.googleusercontent.com/A7DfNHsJoUgQPXxkanCoxnn3iT0ky7K9J-o9OvJdy5WumTcZCNx2AAVQUpWqkpW91xdGS-O5YMOdAizCh5nXiu9pFJ50xNFZflfBYjGAjYtNrcDolxsT-0hfQ9SM0PMx53FYxBvh"><br><br>  There is another way to create an exception without a stack trace.  Starting with Java 7, Throwable and Exception have a protected constructor with the additional parameter writableStackTrace: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exception</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Throwable cause, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> enableSuppression, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> writableStackTrace)</span></span></span></span>;</code> </pre> <br>  If you pass false there, the stack trace will not be generated, and the creation of the exception will be very fast. <br><br>  Why do we need exceptions without stack-traces?  For example, if the event is used in the code as a way to quickly get out of the loop.  Of course, it‚Äôs better not to do that, but there are times when it really gives a performance boost. <br><br>  And how much does it cost to throw an eksepshn <br><br>  Consider different cases: when he rushes and is caught in the same method, as well as situations with different stack depths. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Param</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth; <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwCatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> recursive(depth); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; } }</code> </pre><br>  This is what measurements give: <br><br><img src="https://lh3.googleusercontent.com/qFnz1uhWNJwGc2xFiZY0X01SZxW2cD3GkeFaKBIMnjJb6L--8z7MqdBXczlzs8MuvlNIjbSNG3BByyZYpfszb0fhLOsoqvtEmGn-Q1q-QKlK14G4K2vfImgogXiHKDdRjgU-HhIj"><br><br>  Those.  if we have a small depth (the exception is caught in the same frame or frame higher - the depth is 0 or 1), the exception is worth nothing.  But as soon as the stack depth becomes large, the costs are of a completely different order.  At the same time, there is a clear linear relationship: the ‚Äúcost‚Äù of the exclusion almost linearly depends on the stack depth. <br><br>  Not only is getting the stack trace expensive, but also further manipulations ‚Äî printing, sending over the network, writing ‚Äî everything that is used by the getStackTrace method, which translates the saved stack trace into Java objects. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillInStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception().getStackTrace(); }</code> </pre><br>  It can be seen that the conversion of the stack-trace is 10 times "more expensive" to obtain it: <br><br><img src="https://lh4.googleusercontent.com/1COpUiMParmrpxuevT6J8X_zgW7ms3b_naJEghmc42ixrf1cePPWimPrgz0ovECB1PdTGPfcKQ3AKdm9dE405fYmwKxQcjxn__C0KnME-5ZVJ-WO-RngRPG3ZlWczDG9ABtuDSHl"><br><br>  Why is this happening? <br><br>  Here is the getStackTrace method in the JDK sources: <br><br><img src="https://lh6.googleusercontent.com/zpsVmLmMHQhqR5sVXPlC9b8uND2xZu4A62bXwkIVoyxFKqM1c8fzl6kulmu044zD45ZaTSVZ0Bex74Ah1wOySMQNHGK-CwlcgtCJ3KbNU8gIKWL3Zenr84i1lIboQFjG7Mkuv8N5"><br><br>  First, by calling the native method, we learn the stack depth, then, in a loop to this depth, we call the native method to get the next frame and convert it into a StackTraceElement object (this is a normal Java object with a bunch of fields).  Not only is it a long time, the procedure takes a lot of memory. <br><br>  Moreover, in Java 9 this object is supplemented with new fields (in connection with the well-known project of modularization) - now each frame is assigned a mark about which module it is from. <br><br><img src="https://lh4.googleusercontent.com/IdgBieV1bDxJjujSotW1zUkJdxeZp9F8MgQfdI8eYLqonOf2R8x3UubA96AFwh-10-xg3dH1wYAUafsjLNBrPrfvNWYMPryfTDhvBM5jHBPmdjoD4zAui6pJUzykx_hfZC43pxEw"><br><br>  Hello to those who parse exepsy using regular expressions.  Get ready for surprises in Java 9 - there will be more modules. <br><br><h5>  Let's summarize </h5><br><ul><li>  the creation of the object itself is cheap; <br><br></li><li>  it takes time to get his stack trace; <br><br></li><li>  even more expensive is the conversion of this internal stack trace to a Java object in StackTraceElement.  The complexity of this case is directly proportional to the depth of the stack. <br><br></li><li>  throwing an escape is quick, it costs almost nothing (almost like an unconditional transition), <br><br></li><li>  but only if the event is caught in the same frame.  Here it is necessary to add that JIT can inline methods, so one compiled frame can include several Java methods that are inline with each other.  But if an exception is caught somewhere deeper in a stack, its high cost is proportional to the depth of the stack. <br></li></ul><br><h5>  A couple of tips: </h5><br><ul><li>  disable optimization on production, perhaps it will save a lot of debugging time: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-XX</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-OmitStackTraceInFastThrow</span></span></code> </pre> <br></li></ul><br><ul><li>  Do not use exceptions to control the flow of a program;  this is considered not very good practice; <br><br></li><li>  but if you still resort to this method, make sure that exams are fast and do not create stack-traces once again. <br></li></ul><br><h4>  Stack traces in thread dumps </h4><br>  To find out what the program does, the easiest way is to take a thread dump, for example, with the jstack utility. <br><br>  Fragments of the output of this utility: <br><br><img src="https://lh4.googleusercontent.com/WQ9Ml1e9e15m-ROM2SXcmJm-ZOFEa2Np8ZvAqOY66FmDNt2Ih4oROgZCbAa3jl-KcyW0tuLTYaSynXK-xM5Jfd3TyPxGoIOjw1e4wEGUrk_kAbwO4gH4xNntmlGcycB8Bur1j7QZ"><br><br>  What is seen here?  What are the threads, the state in which they are and their current stack. <br><br>  Moreover, if the threads captured some locks, expect to enter a synchronized section or take a ReentrantLock, this will also be reflected in the stack trace. <br><br>  Sometimes a little-known identifier is useful: <br><br><img src="https://lh6.googleusercontent.com/H894tpZ6quZYptgRCel3FAH-33-b1RsmNyunuqQsRlT-VjaaYlvM6FOzVnK8aAZ6zBGkUjnJqjvv8XYFvOnwJYYspqzwbsNWRCCNgi0bShO1YnlzTvD--OUBKTCRXZWmLOsnqjoR"><br><br>  It is directly related to the thread ID in the operating system.  For example, if you watch the top program in Linux, which threads you have the most CPU eat, the pid of the stream is the very nid that is shown in the thread dump.  You can immediately find which Java stream it corresponds to. <br><br>  In the case of monitors (with synchronized objects), it will be written directly in the thread dump which thread and which monitors are holding, who is trying to capture them. <br><br>  In the case of ReentrantLock, this is unfortunately not the case.  Here you can see how Thread 1 is trying to capture some ReentrantLock, but at the same time it is not visible who is holding this lock.  In this case, the VM has an option: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-XX</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:+PrintConcurrentLocks</span></span></code> </pre> <br>  If we run the same with PrintConcurrentLocks, we will see ReentrantLock in the thread dump. <br><br><img src="https://lh4.googleusercontent.com/qIqPjW8rXhnK1FPx9zyw41-mbWCpXBtXSQTDwkDmUKi9zLuoGPyJiPhsfq4ExctmgrqVbKGd5f7eQqGKeeBDS9ezl-GRSggZE4RbAT9GLHyn6kO6w6VPu9Hu6UzzdMlzVvd8xNbR"><br><br>  Here is the id of the lock.  It can be seen that it captured Thread 2. <br><br>  If the option is so good, why not make it "default"? <br><br>  She, too, is worth something.  To print information about which stream keeps ReentrantLock'i, the JVM runs through the entire Java heap, searches all ReentrantLock'i, compares them with threads, and only then displays this information (the thread has no information about which locks it has captured; information is only in the opposite direction - which lock is associated with which thread). <br><br>  In this example, the names of threads (Thread 1 / Thread 2) do not understand what they refer to.  My advice from practice: if you have a long operation, for example, the server handles client requests or, conversely, the client goes to several servers, set a clear name for the thread (as in the case below, directly the IP of the server to which the client now is coming).  And then in the stream dump you will immediately see the answer from which server it is waiting for. <br><br><img src="https://lh3.googleusercontent.com/xfgwD71RVPfbI0bgWRPKax7qNRNDRj8AlPV_cE51B1fpSDxNlXOg7SZDvxOxMiG3QWp96sQV6ekxSTDMtRZMYkGv3vM40bpzbHvFDBPQMzjXPL-S5nSnQfabMSha2w81XZNPYPrX"><br><br>  Enough theory.  Let's go to practice again.  I have already cited this example more than once. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.IntStream; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallelSum</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SUM = IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>).parallel().reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (x, y) -&gt; x + y);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{       System.out.println(SUM);   } }</code> </pre> <br>  Run the program 3 times in a row.  2 times it displays the sum of numbers from 0 to 100 (not including 100), the third one does not want.  Let's watch the thread dumps: <br><br><img src="https://lh5.googleusercontent.com/gzVCunYyWrjY7s_9IkFdhn-71Ay-ZqPSedNtDz1Zs6dW73pCL7VE7fO588IpGD-cAd5EVcgzEf9l7uEzwAMhkUGgWiXOXmP_u7XW_Y1wc94r5994Mv825hKBt2yRojo3YWD6IVA6"><br><br>  The first thread is RUNNABLE, our reduce executes.  But look, what an interesting point: Thread.State seems to be like RUNNABLE, but it says that the flow is in Object.wait (). <br><br><img src="https://lh4.googleusercontent.com/ZpJP_D36-lwVkU1d9MljJeMESYSjaxWuVC130F6E2xuqAVz_LiWtrNkrnIksVytuWeBIrHL-F1L7_nuTMheromZ4FVlaKEnRxiJsptr1wezYYWWr4AgaenaHfmiOUd3kCwA3Rc4G"><br><br>  I, too, it was not clear.  I even wanted to report a bug, but it turns out that such a bug was introduced many years ago and closed with the wording: ‚Äúnot an issue, will not fix‚Äù. <br>  In this program there really is a deadlock.  Its reason is <a href="https://habrahabr.ru/company/odnoklassniki/blog/255067/">class initialization</a> . <br><br>  The expression is executed in the static initializer of the ParallelSum class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SUM = IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>).parallel().reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (x, y) -&gt; x + y);</code> </pre> <br>  But since the stream is parallel, execution occurs in separate threads of the ForkJoinPool, from which the lambda body is called: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">x</span></span>, y) -&gt; x + y</code> </pre> <br>  The lambda code is written by the Java compiler directly into the ParallelSum class as a private method.  It turns out that from ForkJoinPool we are trying to refer to the ParallelSum class, which is currently at the initialization stage.  Therefore, the threads begin to wait for the class to initialize, but it cannot end, because it is waiting for the computation of this convolution itself.  Dedlock. <br><br>  Why at first was the sum counted?  It was just luck.  We have a small number of elements summed up, and sometimes everything is executed in one stream (another stream just does not have time). <br><br>  But why then is the thread in the stack trace RUNNABLE?  If you read the documentation for Thread.State, it becomes clear that there can be no other state here.  There cannot be a BLOCKED state, because the stream is not blocked on the Java monitor, there is no synchronized section, and there can be no WAITING state, because there are no Object.wait () calls here.  Synchronization occurs on the internal object of the virtual machine, which, generally speaking, does not even have to be a Java object. <br><br><h4>  Stack trace when logging </h4><br>  Imagine a situation: in a heap of places in our application something is logged.  It would be useful to know from which place one or another line appeared. <br><br><img src="https://lh5.googleusercontent.com/vmhUGT1vni9iBVB5P461AupXBCL61HngL9IF0x2XraHxJYRxE_XwjzhgFbGHF3Jwgl5YojN3zh8THuEiognaK3LLumjssjTwPPpRaRAcc4vWX6cJOarcYMfRhLgsA6kaHdJKKN9l"><br><br>  In Java, there is no preprocessor, so there is no possibility to use macros __ FILE__, __LINE__, as in C (these macros are converted at the compilation stage to the current file name and string).  Therefore, there are no other ways to supplement the output with the file name and line number of the code from where it was printed, except through stack-traces. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception().getStackTrace()[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + s.getLineNumber(); }</code> </pre><br>  We generate an exception, we get a stack-trace from it, in this case we take the second frame (the null one is the getLocation method, and the first one calls the warning method). <br><br>  As we know, getting a stack-trace and, especially, converting it to stack-trace elements is very expensive.  And we need one frame.  Is it possible to do something easier (without an exception)? <br><br>  In addition to getStackTrace, the exception has a Thread object's getStackTrace method. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.current</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.getStackTrace</span></span>()</code> </pre> <br>  Will it be faster? <br><br><img src="https://lh3.googleusercontent.com/RQAELLyu8F6o6uIYLjewo3KlCRNaZ8bowv02Vjf5hKlLuGIn_l2W949FTorcLo8CCMJpX38Rqek7fvm05h0EKpzz-RSxb2M-IQAV8LDBZBm6ddYi8H3-F7ftd61qGs2-n9GCAQNx"><br><br>  Not.  JVM does not do any magic, here everything will work through the same escape with exactly the same stack-trace. <br><br>  But the tricky way is still there: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement s = sun.misc.SharedSecrets.getJavaLangAccess() .getStackTraceElement(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(), <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + s.getLineNumber(); }</code> </pre><br>  I love all kinds of private things: Unsafe, SharedSecrets, etc. <br><br>  There is an accessor that allows you to get a StackTraceElement of a specific frame (without the need to convert the entire stack-trace into Java objects).  It will work faster.  But there is bad news: it won't work in Java 9.  A lot of work has been done there on refactoring everything related to stack-traces, and now there are simply no such methods. <br><br>  A design that allows one frame to be obtained may be useful in the so-called Caller-sensitive methods - methods whose result may depend on who calls them.  In application programs, such methods are rarely encountered, but there are quite a few such examples in the JDK itself: <br><br><img src="https://lh6.googleusercontent.com/ail_YHVqgr1UfD3lQQhB9Lt-NY8dgLpPJwvIQgE_E98VXUn6-aIovqKZqLgzOviad5FcPc74SKPhi282WGEVBnntNVr5xMRWWla58vOeRURrIyWYgZ-NngfPIguZCBedDziGz8r-"><br><br>  Depending on who calls Class.forName, the class will be searched for in the corresponding loader class (the class that called this method);  similarly, with obtaining a ResourceBundle and loading the System.loadLibrary library.  Information about who calls is also useful when using various methods that check permissions (does this code have the right to call this method).  For this case, the getCallerClass method is provided in the ‚Äúsecret‚Äù API, which is actually a JVM-intrinsic and costs almost nothing. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">sun</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Reflection</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getCallerClass</span></span></code> </pre> <br>  As it has been said many times, the private API is an evil that is not recommended to use (you yourself run the risk of running into problems similar to those that Unsafe previously caused).  Therefore, JDK developers thought about the fact that once they use it, we need a legal alternative - a new API for bypassing threads.  Basic requirements for this API: <br><br><ul><li>  so that you can bypass only a part of the frames (if we need literally several upper frames); <br><br></li><li>  the ability to filter frames (do not show unnecessary frames related to the framework or system classes); <br><br></li><li>  so that these frames are constructed in a lazy way (lazy) - if we do not need to receive information about which file it is associated with, this information is not retrieved prematurely; <br><br></li><li>  as in the case of getCallerClass - we need not the name of the class, but the java.lang.Class instance itself. <br></li></ul><br>  It is known that in the public release of Java 9 will be java.lang.StackWalker. <br>  To get an instance of it is very simple - using the getInstance method.  It has several options - the default StackWalker or slightly configurable options: <br><br><img src="https://lh3.googleusercontent.com/YXTuqHR-g3-5WAPiNz_f5XCY41KBcB5nSit8pQxHJSq79pILUUwpxvrQlxCJ8BHD5ocZgolN1c2bTY0_lA3jXWOzL6jrG-1ByYxw1tQiqlgvJ8Q2w0uZXN7jgLm-jzH9jhxDJcpY"><br><br><ul><li>  The option RETAIN_CLASS_REFERENCE means that you do not need class names, but instances; <br><br></li><li>  Other options allow you to show frames related to system classes and reflection classes in the stack trace (by default, they will not be shown in the stack trace). <br></li></ul><br>  Also, for optimization, you can set the approximate depth that is needed (so that the JVM can optimize the receipt of stack frames in batch). <br><br>  The simplest example of how to use it: <br><br><pre> <code class="java hljs">StackWalker sw = StackWalker.getInstance(); sw.forEach(System.out::println);</code> </pre> <br>  Take the StackWalker and call the forEach method so that it goes around all the frames.  As a result, we get such a simple stack-trace: <br><br><img src="https://lh4.googleusercontent.com/2lwL6gZ6e3eGQ5LJm-3ERUQRcdlsNFp8mPlqMdP5bsyTkcpHxksOy4OlV4owGn7fRR_TTad6EEsFO0h8g2vnxxNzJo_M7V7HgEQC8LvwKyEdgjcYPzwkvoGYaBWEliE1KG9EJCN3"><br><br>  The same with the SHOW_REFLECT_FRAMES option: <br><br><pre> <code class="java hljs">StackWalker sw = StackWalker.getInstance(StackWalker.Option.SHOW_REFLECT_FRAMES); sw.forEach(System.out::println);</code> </pre> <br>  In this case, methods related to the call through reflex will be added: <br><br><img src="https://lh4.googleusercontent.com/x-79BO51H9m58UIwRcpZQ6qzDZyTrgaZ9T8ga6VvH_FrrxQQExUZsFr9TKbQqDojTigcfI69YCwlAgf8QUwx2FwqfPm377Ix1U6RRvOpgsPaRRKUuZmdn0aehKF3Yi5E0Co6yvUX"><br><br>  If you add the SHOW_HIDDEN_FRAMES option (by the way, it includes SHOW_REFLECT_FRAMES, that is, reflection frames will also be shown): <br><br><pre> <code class="java hljs">StackWalker sw = StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES); sw.forEach(System.out::println);</code> </pre> <br>  The methods of dynamically generated lambda classes will appear in the stack trace: <br><br><img src="https://lh6.googleusercontent.com/CY0YrTlPV4IkSsumwysC6piPfWBhn1K2flc4RHEEUPW6AcpggUdlQtEzGxyg8WKqgOO8gw94Eiz2EhudM-0XEC2oAH6ttjDy4_afELq-7zeOE7Pm7KCL4nhOpuY6EKAzQo4Uvudr"><br><br>  And now the most important method that is in the StackWalker API is the walk method with such a sly incomprehensible signature with a bunch of generics: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Stream&lt;StackFrame&gt;, ? extends T&gt; function)</span></span></span></span></code> </pre> <br>  The walk method takes a function from a stack frame. <br><br>  His work is easier to show by example. <br><br>  Despite the fact that all this looks scary, how to use it is obvious.  Stream is passed to the function, and all the usual operations can be performed over the stream.  For example, the getCallerFrame method would look like this, which only gets the second frame: the first 2 are skipped, then findFirst is called: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StackFrame </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCallerFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance() .walk(stream -&gt; stream.skip(<span class="hljs-number"><span class="hljs-number">2</span></span>).findFirst()) .orElseThrow(NoSuchElementException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); }</code> </pre><br>  The walk method returns the result that this stream function returns.  It's simple. <br>  For this particular case (when you just need to get the Caller class) there is a special shortcut method: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance(RETAIN_CLASS_REFERENCE).getCallerClass();</code> </pre> <br>  Another example is more complicated. <br><br>  We go around all the frames, leaving only those that belong to the org.apache package, and display the first 10 in the list. <br><br><pre> <code class="java hljs">StackWalker sw = StackWalker.getInstance(); List&lt;StackFrame&gt; frames = sw.walk(stream -&gt; stream.filter(sf -&gt; sf.getClassName().startsWith(<span class="hljs-string"><span class="hljs-string">"org.apache."</span></span>)) .limit(<span class="hljs-number"><span class="hljs-number">10</span></span>) .collect(Collectors.toList()));</code> </pre><br>  An interesting question: why such a long signature with a bunch of generics?  Why not just make a method on StackWalker that returns a stream? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Stream&lt;StackFrame&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  If you give an API that returns a stream, the JDK loses control over what is being done on this stream.  It is possible to continue this stream somewhere, give it to another thread, try to use it 2 hours after it was received (the stack that we tried to bypass is long lost, and the thread can be killed long ago).  Thus, it will be impossible to provide ‚Äúlazy‚Äù Stack Walker API. <br><br>  The main point of the Stack Walker API is: while you are inside the walk, you have a stack state fixed, so all operations on this stack can be done lazy. <br><br>  For dessert, a little more interesting. <br><br>  As always, the JDK developers are hiding a bunch of treasures from us.  And besides the usual stack frames, for some of their needs they made live stack frames that differ from the usual ones in that they have additional methods that allow not only to get information about the method and class, but also about local variables, captured monitors and values ‚Äã‚Äãof expres-stack of the given stack frame. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* package-private */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiveStackFrame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] getMonitors(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] getLocals(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] getStack(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StackWalker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStackWalker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  The protection here is not so hot: the class was simply made non-public.  But who prevents us from taking reflexion and trying it?  (Note: in current builds of JDK 9, access to a non-public API through reflexion is prohibited. To enable it, you must add the JVM option <code>--add-opens=java.base/java.lang=ALL-UNNAMED</code> ) <br><br>  We try on such an example.  There is a program that is recursively looking for a way out of the maze.  We have a square field size x size.  There is a visit method with current coordinates.  We are trying to go left / right / up / down from the current cell (if they are not busy).  If we‚Äôve got from the right-bottom cell to the left-top one, we think that we‚Äôve found a way out and we print out the stack. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo3; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Labyrinth</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> FREE = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> OCCUPIED = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> VISITED = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[][] field;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Labyrinth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{       Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(<span class="hljs-number"><span class="hljs-number">0</span></span>);       field = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size][size];       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size; x++) {           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size; y++) {               <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (random.nextInt(<span class="hljs-number"><span class="hljs-number">10</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">7</span></span>) {                   field[x][y] = OCCUPIED;               }           }       }       field[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = field[size - <span class="hljs-number"><span class="hljs-number">1</span></span>][size - <span class="hljs-number"><span class="hljs-number">1</span></span>] = FREE;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field.length;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y == <span class="hljs-number"><span class="hljs-number">0</span></span>) {           StackTrace.dump();           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= size() || y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || y &gt;= size() || field[x][y] != FREE) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;       }       field[x][y] = VISITED;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visit(x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y) || visit(x, y - <span class="hljs-number"><span class="hljs-number">1</span></span>) || visit(x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y) || visit(x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>);   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Labyrinth"</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{       Labyrinth lab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Labyrinth(<span class="hljs-number"><span class="hljs-number">10</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> exitFound = lab.visit(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);       System.out.println(exitFound);   } }</code> </pre> <br>  Run: <br><br><img src="https://lh5.googleusercontent.com/L7E49gUvR2mplSXu53hICr34H2U6sW0M5qSyZ20ntRMX9wggNvnmT7OhfTGL4F9nFKug843B9L_po1iRI-_SWa3_XOqqwseRiHSThovj0QYR3EpHycJtkayCjc0_UCgM9bhW8Bpv"><br><br>  If I do the usual dumpStack, which was still in Java 8, we get the usual stack-trace, from which nothing is clear.  Obviously, the recursive method calls itself, but it is interesting at what step (and with what coordinate values) each method is called. <br><br>  Let's replace the standard dumpStack with our StackTrace.dump, which uses live stack frames through reflection: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo3; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackTrace</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String methodName, Object instance)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {           Class&lt;?&gt; liveStackFrame = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.lang.LiveStackFrame"</span></span>);           Method m = liveStackFrame.getMethod(methodName);           m.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.invoke(instance);       } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ReflectiveOperationException e) {           <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssertionError(<span class="hljs-string"><span class="hljs-string">"Should not happen"</span></span>, e);       }   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       StackWalker sw = (StackWalker) invoke(<span class="hljs-string"><span class="hljs-string">"getStackWalker"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);       sw.forEach(frame -&gt; {           Object[] locals = (Object[]) invoke(<span class="hljs-string"><span class="hljs-string">"getLocals"</span></span>, frame);           System.out.println(<span class="hljs-string"><span class="hljs-string">" at "</span></span> + frame + <span class="hljs-string"><span class="hljs-string">"  "</span></span> + Arrays.toString(locals));       });   } }</code> </pre> <br>       StackWalker,   getStackWalker.  ,     getStackWalker,       -,     ,  , getLocals    . <br><br>  We start.    ,             : <br><br><img src="https://lh6.googleusercontent.com/U89R8zkn0bAT7IPJYcytHp5SQYxBrXzZC5FxfAMApdLVfHigCLCNiM29PcwP36hwOwOlb9ls7t8rUFL3ZumsPbuypgkASK8apow_S_hX7Cwr7ybC4YOGdwF7_ToUXw2Xz8gmisIM"><br><br><hr><br> <i>      .   <a href="https://habr.ru/p/325064/"></a> . <br><br>            ‚Äî 7-8   <a href="https://jpoint.ru/">JPoint 2017</a> .        ¬´ <a href="https://jpoint.ru/talks/the-art-of-jvm-profiling/">JVM-   </a> ¬ª,   ,       ,     .   ¬´¬ª ,              ! <br><br>  ,  JPoint           Java ‚Äî      <a href="https://habrahabr.ru/company/jugru/blog/323040/">  </a> ,        <a href="https://jpoint.ru/"></a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/324932/">https://habr.com/ru/post/324932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324920/index.html">How the CIA caused the rain: using Rain Maker to gather information from closed objects</a></li>
<li><a href="../324922/index.html">Threat Horizon 2017-2019 by the International Security Forum (executive executive)</a></li>
<li><a href="../324924/index.html">Cook ML Boot Camp III: Starter Kit</a></li>
<li><a href="../324926/index.html">We are friends of Angular with Google (Angular Universal)</a></li>
<li><a href="../324930/index.html">WhatsApp messages may be available to outsiders: a serious vulnerability allows access to your correspondence</a></li>
<li><a href="../324934/index.html">Getting ready for a PHP interview: Everything about iteration and a little about the ‚Äúiterable‚Äù pseudotype</a></li>
<li><a href="../324936/index.html">SQL or NoSQL - that is the question</a></li>
<li><a href="../324940/index.html">A selection of useful tools with Product Hunt for March</a></li>
<li><a href="../324942/index.html">Solving problems with the memory occupied by the IntelliMemory module in Diskeeper and SSDkeeper</a></li>
<li><a href="../324944/index.html">Web typography</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>