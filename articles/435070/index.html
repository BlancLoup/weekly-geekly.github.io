<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Layer 3 Firewall MikroTik</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Firewall (or packet filter) is a large and complex topic, both theoretically and practically. A packet filter in different operating systems may have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Layer 3 Firewall MikroTik</h1><div class="post__text post__text-html js-mediator-article"><p>  Firewall (or packet filter) is a large and complex topic, both theoretically and practically.  A packet filter in different operating systems may have its advantages and disadvantages compared to other implementations.  In this article, I will consider the exceptionally firewall in RouterOS with an eye on its iptables progenitor. </p><a name="habracut"></a><br><h3 id="predislovie">  Foreword </h3><br><h4 id="dlya-kogo-eta-statya">  Who is this article for? </h4><br><p>  If you know how to work with iptables, then dare and configure the firewall, for you in this article will not be anything new (well, except that the NAT table uses chains with different names).  If you first see the firewall in RouterOS and want to get a ready-made script for configuration, then you will not find it here.  The material is aimed at those who want to get a <strong>basic</strong> idea of ‚Äã‚Äãhow the firewall works and what happens with the ip package at different stages of its processing.  A deeper understanding will come with experience and solving everyday and unusual tasks using a packet filter. </p><br><h3 id="teoreticheskaya-chast">  Theoretical part </h3><br><h4 id="chto-takoe-layer3-firewall">  What is a Layer3 Firewall </h4><br><p><img src="https://habrastorage.org/webt/ai/xt/od/aixtod5yvn-bvirxxdvwmnm2m30.png"></p><br><p>  Suppose you have a router with Internet access and two bridge interfaces: bridge-lan (ether2-ether5) and bridge-dmz (ether6-ether10). </p><br><p>  Within the Bridge interface interface, devices independently find neighbors from their subnet and exchange packets, the router acts as a switch and does not track such traffic at the network level (of course, you can force it to do this, but let's talk about Layer2 Firewall another time). </p><br><p>  If you need to communicate with a device connected to another bridge interface or a device located in the global network, send packets to the router, which determines the route and processes them at the network (Layer 3) level. </p><br><h4 id="packet-flow-diagram">  Packet flow diagram </h4><br><p>  The full traffic path is described in the Packet Flow Diagram, there are several official (v5, <a href="https://wiki.mikrotik.com/wiki/Manual:Packet_Flow">v6</a> ) versions, they need to be known and used in everyday work, but to understand how the packet filter works, they are overloaded, so I will explain in a lightweight version. </p><br><p><img src="https://habrastorage.org/webt/cb/fr/uu/cbfruui7ydb8lqm19myzozfotbo.png"></p><br><p>  The Input / Output Interface is any (physical or virtual) Layer 3 router interface.  The packet that goes from the local network to the Internet goes to the input interface, and goes to the output interface.  The packet from the Internet to the local network also goes to the input interface, and leaves the output interface.  Packet Flow is always read in one direction input -&gt; output. </p><br><h4 id="osobennosti-terminologii">  Terminology features </h4><br><p>  Studying the packet flow for iptables, you can find descriptions through "chains in tables" or "tables in chains".  The diagram shows tables in chains, when adding rules to a firewall, everything will be the other way around. </p><br><p>  But in fact, the packet is moved between the blocks [chain + tables], for example, if you make accept in the [prerouting + mangle] block, the transit packet will still be processed in [forward + mangle].  This is important to remember in complex configurations with pbr and queues. </p><br><p>  The iptables documentation has more precise definitions, but in simple terms: <br>  <strong>The chains</strong> are responsible for the place where the packet is processed and the sequence of rules. <br>  <strong>Tables</strong> define the actions that can be performed on a package. </p><br><h4 id="bazovye-varianty-sledovaniya-paketa">  Basic package sequence options </h4><br><p><img src="https://habrastorage.org/webt/1d/tm/6j/1dtm6j1wiiolczrm215gcz_imss.png"></p><br><p>  <strong>Transit</strong> </p><br><p><img src="https://habrastorage.org/webt/rj/9z/_w/rj9z_w8s9pc4valiwixtkrwpdke.png"></p><br><ol><li>  A packet from the network comes to one of the interfaces of the router </li><li>  In the PREROUTING chain, the administrator can influence the route of the packet: determine the output interface (Policy base routing) or redirect to another address (dst-nat). </li><li>  The outgoing interface is determined according to the routing table for a packet. </li><li>  FORWARD chain is the main place for filtering passing traffic. </li><li>  The last item before going online is the POSTROUTING chain, in which you can change the sender's address (src-nat). </li><li>  The package went to the network. </li></ol><br><p>  <strong>Incoming</strong> </p><br><p><img src="https://habrastorage.org/webt/qn/l8/gd/qnl8gdad6vpxhgdjnhvhpzngcau.png"></p><br><ol><li>  A packet from the network came to one of the interfaces of the router </li><li>  Got into the PREROUTING chain. </li><li>  In accordance with the routing table, the packet was sent for processing to a local process. </li><li>  In the INPUT chain, incoming traffic is filtered by the administrator. </li><li>  The package is left for local process processing. </li></ol><br><p>  <strong>Outgoing</strong> </p><br><p><img src="https://habrastorage.org/webt/jh/qr/sd/jhqrsd8rq3lt8x1s3jzjuup_m-8.png"></p><br><ol><li>  One of the processes of the router generated the ip packet (new or return - it does not matter). </li><li>  The output interface is defined according to the routing table for the packet. </li><li>  The administrator can filter outgoing traffic, or change the route in the OUTPUT chain. </li><li>  For the packet, the final decision is made on the output interface. </li><li>  The packet gets into POSTROUTING, as well as <em>passing</em> traffic. </li><li>  The package went to the network. </li></ol><br><h4 id="connection-tracker">  Connection tracker </h4><br><p>  First you need to understand what the stateful and stateless packet filters are. </p><br><p><img src="https://habrastorage.org/webt/8c/lg/7z/8clg7zcfasexwuw3e3utjyhypl8.png"></p><br><p>  Example.  Computer 192.168.100.10 opens the tcp connection with the server 192.0.2.10.  On the client side, the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582">dynamic port</a> 49149 is used, on the server side 80. Even before receiving the content, the client and the server must exchange packets for setting up the tcp session. </p><br><p>  In <em>stateless, you</em> will need to open traffic from the local network to the Internet and from the Internet to the local network (at least for a range of dynamic ports).  What is generally a hole. </p><br><p>  In a <em>stateful</em> router, it analyzes the packets and, having received tcp syn from 192.168.100.10:491414 for 192.0.2.10:80, considers this the beginning of a new (new) connection.  All further packets (in any direction) between 192.168.100.10:49141414 and 192.0.2.10:80 will be considered part of the established connection until the tcp session is closed or the timers expire. </p><br><p>  For UDP / ICMP and other types of traffic, where the beginning and end of the connection cannot be clearly distinguished, the new packet is the first, the others are considered part of the established connection and update the timers, the router forgets about such connections after the timers expire. </p><br><p>  Connection tracker divides packages into several types: </p><br><p><img src="https://habrastorage.org/webt/j2/do/3f/j2do3fsdj1-t-hq7p2wnf0pnqte.png"></p><br><p>  <em>new</em> - a packet opening a connection, for example, <em>syn</em> for tcp or the first packet in the udp stream. <br>  <em>Established</em> is a package related to a known connection. <br>  <em>related</em> - packet related to the additional connection in the multiprotocol (sip, pptp, ftp, ...). <br>  <em>invalid</em> - packet from unknown connection. <br>  <em>untracked</em> - package not monitored connection tracker. </p><br><p>  <strong>Connection tracker configuration</strong> <br>  enabled = yes - enabled. <br>  enabled = no - disabled. <br>  enabed = auto - disabled until a rule using the conntrack capabilities appears in the firewall.  Used by default. </p><br><p><img src="https://habrastorage.org/webt/a9/2b/tl/a92btlt5yfxh9fhf7-wmpgrohbu.png"></p><br><p>  The remaining parameters are different timers and usually do not require tuning. </p><br><p>  The administrator can view and delete connections, for example, this is how a NAT connection looks like: </p><br><p><img src="https://habrastorage.org/webt/mb/i7/7x/mbi77x9oinpcys1ohb516glu4mc.png"></p><br><p>  Using conntrack affects the performance and resource consumption (especially with a large number of connections), but disable it in most configurations will not work, because  you will have a stateless firewall without NAT. </p><br><div class="spoiler">  <b class="spoiler_title">List of connection tracker dependent functions</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/la/td/kz/latdkzskcwi9cx2o4lkdwtehps8.png"></p></div></div><br><h4 id="ttl">  TTL </h4><br><p>  Time To Live - a field in the IP packet header that defines the number of routers through which a packet can pass before being destroyed, protects against infinite packet forwarding at routing loops. </p><br><p><img src="https://habrastorage.org/webt/gp/qi/js/gpqijsw0wgsu2yqrkcamd3z0mhk.png"></p><br><p>  When forwarding, the router decreases the TTL value by 1 drops, if TTL = 0.  In this case, a packet with TTL = 1 will fall into the local process of the router. </p><br><p>  Some communication operators use TTL tricks to prevent the use of routers.  All these restrictions are well worth the increase in ttl values ‚Äã‚Äãin the mangle table. </p><br><h4 id="nat">  NAT </h4><br><p>  Network Address Translation - technology change addresses in the header of the ip package.  As with linux, NAT is part of a packet filter.  NAT works on the basis of connection tracker. </p><br><p>  Initially, NAT was designed as a quick solution to the problem of the exhaustion of IPv4 addresses; for local networks, it was proposed to use a subnet from the following ranges: 10.0.0.0/8;  172.16.0.0/12;  192.168.0.0/16 and broadcast them to one (or several) routable addresses.  In fact, there are still several service subnets that can be used in private networks and the router is basically all the same as NAT'it, but it is recommended to follow the standards. </p><br><p>  NAT processes only: tcp, udp, icmp and some multiprotocol from [IP] -&gt; [Firewall] -&gt; [Service Port].  Only the first (connection-state = new) packet in the connection is processed, the rest are processed automatically without the participation of the NAT table.  This can be tracked by changing the counters in the rules. </p><br><p>  The packet header contains Source and Destination addresses, respectively, and NAT is divided into Source and Destination NAT. </p><br><p>  <strong>Source NAT</strong> - the substitution of the sender's address, is present on the vast majority of home and corporate routers in the world. </p><br><p><img src="https://habrastorage.org/webt/2s/ej/or/2sejor290wkc26agkonobacposa.png"></p><br><p>  Allows multiple devices with gray addresses on the local network to communicate with the Internet using one (or several) real addresses. </p><br><p><img src="https://habrastorage.org/webt/hh/hi/du/hhhidurhkrsiiuflmg6dakupph8.png"></p><br><p>  Returning to Packet Flow, we see that SRC-NAT is in Postrouting, after making a decision on packet routing. </p><br><p>  The response packet passes <em>an implicit</em> DST-NAT in which the recipient address is changed to local. </p><br><p>  <strong>Destination NAT</strong> - substitution of the address of the recipient. </p><br><p><img src="https://habrastorage.org/webt/id/rb/l9/idrbl9jdlfgfvbftjkgwoorszae.png"></p><br><p>  It is used if necessary to forward a packet to another address, usually used for port forwarding from the external network to the local network. </p><br><p><img src="https://habrastorage.org/webt/ju/uv/ly/juuvlyxr74gi8qykxx80vzhyvg4.png"></p><br><p>  According to Packet Flow, DST-NAT operation takes place before making a routing decision in Prerouting, <em>implicit</em> SRC-NAT is present for response traffic. </p><br><p>  NAT is a fairly powerful traffic management tool, but it is the last thing to use (when other tools cannot help). </p><br><h4 id="cepochkichains-bazovye-i-polzovatelskie">  Chains (chains) basic and custom </h4><br><p>  Chains are made up of rules and force the processing logic of a package. <br>  There are several basic chains mapped to packet flow: <br>  <strong>Prerouting (dstnat)</strong> - packet processing before making a routing decision <br>  <strong>Input</strong> - processing packets destined to the local processes of the router <br>  <strong>Output</strong> - packet processing of packets generated by local processes of the router <br>  <strong>Forward</strong> - Processing of passing traffic <br>  <strong>Postrouting (srcnat)</strong> - Handling traffic ready for transmission to the interface </p><br><p>  <em>Everything is as in iptables, but the chains in nat are renamed.</em>  <em>What is the reason for this (most likely with hotspot or hardware unloading nat) is unknown to me, but fundamentally changes nothing.</em> </p><br><p>  A packet passes the rules in a chain sequentially; if it matches all the conditions, then an action is applied to the packet.  If the action is terminating and does not drop the packet, then it is transmitted to the next packet flow block. </p><br><p>  All of the basic chains have a default action (if the package did not match any of the rules) - <em>accept</em> . </p><br><p>  Custom chains are needed to reduce the number of rules that each packet passes and to build complex traffic processing rules.  All user chains have a default action, <em>return</em> . </p><br><p><img src="https://habrastorage.org/webt/bk/rg/sk/bkrgskh5wudzzf54mueqiy9oehk.png"></p><br><p>  Within the table, you can send the rules from several different basic (and user) chains to the user, but the package will return to the chain from which it came. </p><br><p><img src="https://habrastorage.org/webt/_8/kw/oi/_8kwoirut9mtd67elbejqkzdsek.png"></p><br><h4 id="usloviya-v-pravilah">  Terms in the rules </h4><br><p>  Chains consist of rules, each rule consists of conditions and actions.  There are a lot of conditions, but not all of you will use in real configurations.  Most conditions can be prefixed with "not" (the "!" Sign).  To match the rule, the package must fit all the specified conditions. </p><br><p><img src="https://habrastorage.org/webt/la/dh/or/ladhorisauzv81cnmffmkjo6_hi.png"></p><br><div class="spoiler">  <b class="spoiler_title">Some of the conditions</b> <div class="spoiler_text"><table><thead><tr><th>  Condition </th><th>  Description </th></tr></thead><tbody><tr><td>  src-address </td><td>  Source address </td></tr><tr><td>  dst-address </td><td>  Address of the recipient </td></tr><tr><td>  src-address-list </td><td>  The source address is listed. </td></tr><tr><td>  dst-address-list </td><td>  Recipient's address is on the list </td></tr><tr><td>  protocol </td><td>  Transport Protocol </td></tr><tr><td>  src-port </td><td>  Source port </td></tr><tr><td>  dst-port </td><td>  Receiver port </td></tr><tr><td>  port </td><td>  Source or destination port </td></tr><tr><td>  in-interface </td><td>  Interface to which the packet came </td></tr><tr><td>  out-interface </td><td>  Interface from which the package will be sent to the network </td></tr><tr><td>  in-interface-list </td><td>  Interface to which the package came to is listed </td></tr><tr><td>  out-interface-list </td><td>  The interface from which the package will be sent to the network is listed </td></tr><tr><td>  layer7-protocol </td><td>  Analyzing the contents of the first 10 packets in the mix. </td></tr><tr><td>  content </td><td>  Search for a given string in the package </td></tr><tr><td>  tls-host </td><td>  Search host in tls header </td></tr><tr><td>  ipsec-policy </td><td>  Check whether the packet is subject to ipsec policy or not </td></tr><tr><td>  packet-size </td><td>  packet size in bytes </td></tr><tr><td>  src-mac-address </td><td>  mac source address of the packet </td></tr><tr><td>  connection-mark </td><td>  Connection label </td></tr><tr><td>  packet-mark </td><td>  Package label </td></tr><tr><td>  routing-mark </td><td>  Package route label </td></tr><tr><td>  connection-state </td><td>  Package status in connection </td></tr><tr><td>  tcp-flags </td><td>  Package tcp flags </td></tr><tr><td>  icmp-options </td><td>  Package icmp options </td></tr><tr><td>  random </td><td>  The rule is triggered (if other conditions coincide) with a given probability </td></tr><tr><td>  time </td><td>  You can specify the working time of the rules, unfortunately without the date </td></tr><tr><td>  ttl </td><td>  The value of the ttl field in the packet </td></tr><tr><td>  dscp </td><td>  The value of the DSCP (ToS) field in the packet </td></tr><tr><td>  - // - </td><td>  - // - </td></tr><tr><td>  place-before </td><td>  The console option (not a condition) allows you to add a rule before the specified </td></tr><tr><td>  disabled </td><td>  The console option (not a condition) allows you to disable the rule </td></tr></tbody></table><br><p>  <strong>Notes</strong> <br>  As src. (Dst.) Address you can specify: a single ip, a range of addresses through a hyphen, or a subnet. <br>  Address lists are needed to merge several unrelated ips under the same name.  Unlike ipset in netfilter, entries in MikroTik lists can be deleted after a specified period of time.  View lists and make changes in [IP] -&gt; [Firewall] -&gt; [Address Lists]. <br>  As a port number (port, src-port, dst-port), you can specify a single port, several ports separated by commas, or a range of ports through a hyphen. </p></div></div><br><p>  At the last MUM in the MSC, there was a good presentation on the effect of various conditions on the processing speed of packets (there you will also learn how to use the raw table to reduce the load on the router) who is interested: <a href="https://www.youtube.com/watch%3Fv%3DILznDI2Zgg8">recording</a> and <a href="https://mum.mikrotik.com/presentations/RU18M/presentation_5685_1538369737.pdf">presentation</a> . </p><br><h4 id="deystviya-v-tablicah">  Actions in tables </h4><br><p>  The set of available actions on a package depends on the table in which it is processed. <br><img src="https://habrastorage.org/webt/i3/ba/xj/i3baxjyyz-fnswxpanh_qek5kq8.png"><br>  <strong>Filter</strong> is a traffic filtering table, one of two places where a packet can be dropped. </p><br><p>  <strong>NAT</strong> - the table of ip address and port modification (tpc, udp) in the ip header of the packet. </p><br><p>  <strong>Mangle</strong> is a table for modifying other fields of the ip package and setting various labels. </p><br><p><img src="https://habrastorage.org/webt/w0/dc/n3/w0dcn3uinajpugbflfjha0pt5jy.png"></p><br><p>  There are three types of internal packet labels: connection, packet, route.  Tags exist only within the router and do not go to the network.  A packet can have one label of each type, with the successive passing of several mark- * rules, the labels are overwritten. <br>  Route labels can be set only in chains prerouting and output, the rest in any chains. </p><br><p>  A good practice is to first mark the connection (connection), and then the packet (packet) or route (route).  Checking for a label is faster than packet fields.  In practice, this is not always the case and in complex queues or pbr the additional marking of the connection is not useful. </p><br><p>  <strong>RAW</strong> is a table that allows packets to bypass the connection tracker.  It is used to counteract DoS and reduce the load on cpu (for example, excluding multicast traffic).  Allows you to drop a packet. </p><br><p>  The terminating actions complete the processing of the packet in the chain and transfer it to the next block in the packet flow, or discard it. </p><br><div class="spoiler">  <b class="spoiler_title">Actions</b> <div class="spoiler_text"><table><thead><tr><th>  Table </th><th>  Act </th><th>  Description </th><th>  Terminating? </th></tr></thead><tbody><tr><td>  Everything </td><td>  accept </td><td>  Stop batch processing and transfer to the next block Pakcet flow </td><td>  Yes </td></tr><tr><td>  Everything </td><td>  log </td><td>  Write package information to the log. In modern versions, you can add a log to any other action. </td><td>  Not </td></tr><tr><td>  Everything </td><td>  passtrough </td><td>  Count the number of packages.  Used for debugging </td><td>  Not </td></tr><tr><td>  Everything </td><td>  add src to address list and add dst to address list </td><td>  Add source (destination) address from the package to the specified list </td><td>  Not </td></tr><tr><td>  Everything </td><td>  jump </td><td>  Go to custom chain </td><td>  Yes </td></tr><tr><td>  Everything </td><td>  return </td><td>  Return to the parent chain.  In basic chains, it works like accept </td><td>  Yes </td></tr><tr><td>  Filter and Raw </td><td>  drop </td><td>  Stop packet movement on packet flow and drop </td><td>  Yes </td></tr><tr><td>  Filter and Prerouting </td><td>  fasttrack </td><td>  Mark packet for fast passing packet flow </td><td>  Yes </td></tr><tr><td>  Filter </td><td>  reject </td><td>  Similar to drop, but a notification (tcp or icmp) about the dropped packet is sent to the packet sender. </td><td>  Yes </td></tr><tr><td>  Filter </td><td>  trapit </td><td>  Emulate the presence of an open port.  Used to protect against DoS, confusing and (sometimes) debugging </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  src-nat </td><td>  Substitution of the address of the sender to the specified </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  masquerade </td><td>  A special case of src-nat, replaces the sender's address with one of the addresses from the interface, is used on dynamic (dhcp, vpn) interfaces.  Not recommended when there are several ip on the interface </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  same </td><td>  A special case of src-nat.  Replaces the sender's address to the address of the specified range </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  dst-nat </td><td>  Replaces the address of the recipient to the specified </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  redirect </td><td>  A special case of dst-nat, replaces the recipient's address with the address of the router interface to which the packet came </td><td>  Yes </td></tr><tr><td>  NAT </td><td>  netmap </td><td>  Not a replacement for dst-nat.  Used when translating network-to-network, see examples </td><td>  Yes </td></tr><tr><td>  Mangle </td><td>  mark connection </td><td>  Connection label </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  mark packet </td><td>  Package label applied in queues </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  mark routing </td><td>  Route label used in policy base routing </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  change ttl </td><td>  Change ttl </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  change dcsp (tos) </td><td>  Change dcsp, in decimal </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  change mss </td><td>  Change mss to tcp syn </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  clear df </td><td>  Clear flag do not fragmet </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  strip ipv4 options </td><td>  Clear ipv4 advanced options </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  set priority </td><td>  Set CoS Priority </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  route </td><td>  Set the gateway for the packet.  Simple PBR version </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  sniff tzsp </td><td>  Encapsulate packets in udp and send to the specified ip </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  sniff pc </td><td>  Analogue tzsp, but with a different type of encapsulation.  In the wiki if use cases with calea </td><td>  Not </td></tr><tr><td>  Mangle </td><td>  passtrough </td><td>  By default, most rules in mangle do not stop the passage of a packet, you can change this behavior by setting passtrough = no </td><td>  Not </td></tr><tr><td>  Raw </td><td>  notrack </td><td>  Do not track the package in the connection tracker </td><td>  Yes </td></tr></tbody></table><br><p>  <em>If you are willing, I can write more about FastTrack and FastPath, but you should not expect miracles from these technologies.</em> </p></div></div><br><h4 id="para-slov-pro-dpi">  A couple of words about DPI </h4><br><p>  There are several possibilities to look into the package a little deeper than the header of the transport layer: <br>  <em>content</em> - searches for the specified string in the package. <br>  <em>layer7-protocol</em> - buffers the first 10 packets (or 2KiB) from the connection and searches by regexp in the buffered data.  A large number of layer7 rules significantly affect performance. <br>  <em>tls-host</em> is the hostname address in the TLS / SNI header of the HTTPS connection. </p><br><h3 id="primery">  Examples </h3><br><p>  Do not copy the examples mindlessly, better take the device and try to write the configuration yourself (or rewrite the examples, but understand what each of the rules does).  If you do not know how to supplement the rules: in the default and minimal home configurations there is no access to the router with the wan interface, add it with filtering by address list. </p><br><h4 id="defoltnyy-firewall-routeros">  Default Firewall RouterOS </h4><br><p>  A fairly secure configuration, but in some places very confused: </p><br><pre><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'en', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><code class="plaintext hljs">/ip firewall filter #     (established, related)   (untracked)  add action=accept chain=input connection-state=established,related,untracked #    (invalid)  add action=drop chain=input connection-state=invalid #  icmp  add action=accept chain=input protocol=icmp #          add action=drop chain=input in-interface-list=!LAN #   ipsec    add action=accept chain=forward ipsec-policy=in,ipsec add action=accept chain=forward ipsec-policy=out,ipsec #          add action=fasttrack-connection chain=forward connection-state=established,related #       add action=accept chain=forward connection-state=established,related,untracked #    add action=drop chain=forward connection-state=invalid #     wan ,     dstnat (,      src-nat   dst-nat) add action=drop chain=forward connection-nat-state=!dstnat connection-state=new in-interface-list=WAN /ip firewall nat #Source NAT      ipsec,      WAN add action=masquerade chain=srcnat ipsec-policy=out,none out-interface-list=WAN</code> </pre> <br><p>  I have never used the default config, but before that the default firewall was much worse. </p><br><h4 id="minimalnyy-domashniy-firewall">  Minimal Home Firewall </h4><br><p>  The easiest thing to come up with.  Yes, it does not allow untracked traffic (but you don‚Äôt need it anyway at the stage of basic firewall learning) and there will be problems with tunnel ipsec (again, if you know how to configure ipsec, then you know what needs to be done). </p><br><pre> <code class="plaintext hljs">/ip firewall filter #     (established, related)  add chain=input connection-state=established,related action=accept #  icmp  add chain=input connection-state=new protocol=icmp action=accept #      add chain=input connection-state=new in-interface-list=LAN action=accept #     add chain=input action=drop #       add chain=forward connection-state=established,related action=accept #         add chain=forward connection-state=new in-interface-list=LAN action=accept #     add chain=forward action=drop /ip firewall nat #Source NAT        WAN add chain=srcnat out-interface-list=WAN action=masquerade</code> </pre> <br><h4 id="primer-s-dmz">  DMZ example </h4><br><p>  On home routers, the abbreviation DMZ likes to call the computer on a local subnet for which all ports from the external network are forwarded. </p><br><p>  In fact, this is not the case, and one of the variants of the DMZ is the separation of the resource for which you need to provide access from the Internet and a successful attack can be carried out (a web server with cms in which holes are constantly found is a good target for a hacker).  In the case of hacking, the attacker will not be able to affect the participants of the local network. </p><br><p><img src="https://habrastorage.org/webt/bb/pp/9g/bbpp9gbe7k4owuef7hxuzisrurg.png"></p><br><pre> <code class="plaintext hljs">#  /ip firewall nat add chain=dstnat dst-port=80,443 action=dst-nat to-address=192.168.200.2 /ip firewall filter #   icmp   add chain=input connection-state=established,related action=accept add chain=input protocol=icmp connection-state=new action=accept #      add chain=input in-interface=ether2-lan action=accept #    add chain=input action=drop #    add chain=forward connection-state=established,related action=accept #        add chain=forward in-interface=ether2-lan connection-state=new action=accept #    web  add chain=forward out-interface=ether3-dmz dst-address=192.168.200.2 dst-port=80,443 connection-state=new action=accept #   add chain=forward action=drop</code> </pre> <br><h4 id="hairpin-nat">  HairPin NAT </h4><br><p><img src="https://habrastorage.org/webt/r5/ms/wv/r5mswv8kwtp0m3amzpl--bd5fn0.png"></p><br><pre> <code class="plaintext hljs">/ip firewall nat add chain=dstnat dst-port=80 action=dst-nat to-address=192.168.100.2</code> </pre> <br><p>  A typical situation is when you do port forwarding to a server on the local network and everything is working from the outside, but the server is not accessible inside the local network by an external address. </p><br><p>  Let's look at what is happening: </p><br><ol><li>  Computer 192.168.100.10 sends a request for 192.0.2.100 </li><li>  On the router it runs DST-NAT and the packet is forwarded to 192.168.100.2 </li><li>  The server sees that a packet from 192.168.100.10 has arrived at 192.168.100.2 and responds from the local address </li><li>  The computer receives an unexpected packet from 192.168.100.2 and discards it. </li></ol><br><p>  The solution is to add an additional rule that changes the source address to the address of the router, so the server will return the packet to the router, which will send it to the computer initializer. </p><br><pre> <code class="plaintext hljs">/ip firewall nat #  add chain=dstnat dst-port=80 action=dst-nat to-address=192.168.100.2 # ,      add chain=srcnat src-address=192.168.100.0/24 dst-address=192.168.100.2 action=masquerade</code> </pre> <br><p>  In practice, this scheme is not often used, but as an example of debugging a firewall, I really like it. </p><br><h4 id="pravilnoe-ispolzovanie-netmap">  Proper use of netmap </h4><br><p><img src="https://habrastorage.org/webt/l9/xa/ox/l9xaoxkyat1phpmy6tnnhau6nls.png"><br>  Netmap is a technology for translating addresses from one subnet to another subnet. <br>  The IP address (in the masked entry) consists of two parts: the network (the number of bits specified in the subnet mask) and the host (the remaining bits).  Netmap changes the network part of the address, but does not touch the host. </p><br><p><img src="https://habrastorage.org/webt/jy/eh/xh/jyehxh3hok1l5-wfw6c8n4czdlu.png"></p><br><p>  There are two routers connected by a VPN channel.  Routers serve subnets with the same addressing.  It is necessary to make access between subnets. </p><br><p>  Without additional addressing is not enough. </p><br><p>  Users from the left subnet will knock on the right through the subnet 192.168.102.0/24 <br>  Users from the right subnet will knock on the left via the subnet 192.168.101.0/24 </p><br><p>  Configuration on MikroTik 1. </p><br><pre> <code class="plaintext hljs">#     /ip route add distance=1 dst-address=192.168.102.0/24 gateway /ip firewall nat #       add action=netmap chain=srcnat dst-address=192.168.102.0/24 out-interface=ipip src-address=192.168.100.0/24 to-address=192.168.101.0/24 #       add action=netmap chain=dstnat dst-address=192.168.101.0/24 in-interface=ipip src-address=192.168.102.0/24 to-address=192.168.100.0/24</code> </pre> <br><p>  The MikroTik2 configuration is almost the same: </p><br><pre> <code class="plaintext hljs">/ip route add distance=1 dst-address=192.168.101.0/24 gateway=10.10.10.1 /ip firewall nat add action=netmap chain=srcnat dst-address=192.168.101.0/24 out-interface=ipip src-address=192.168.100.0/24 to-address=192.168.102.0/24 add action=netmap chain=dstnat dst-address=192.168.102.0/24 in-interface=ipip src-address=192.168.101.0/24 to-address=192.168.100.0/24</code> </pre> <br><p>  There are more complex configurations using netmap, for example, if you have many connections to remote points with intersecting subnets and you cannot change the settings on remote equipment, but this is advanced routing. </p><br><p>  If you do not understand (about netmap), then you don‚Äôt need it and just don‚Äôt use this action when port forwarding. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435070/">https://habr.com/ru/post/435070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435056/index.html">Samsung SSD 860 QVO 1 TB and 4 TB: the first consumer SATA QLC (part 3)</a></li>
<li><a href="../435058/index.html">Analysis of the mistakes of last year's bot</a></li>
<li><a href="../435060/index.html">2018 was the year of the scooter. What's next?</a></li>
<li><a href="../435062/index.html">Guide: Thymeleaf + Spring. Part 1</a></li>
<li><a href="../435064/index.html">Ride on Xiaomi Vacuum Cleaner</a></li>
<li><a href="../435072/index.html">8-bit analog memory for working with neural networks</a></li>
<li><a href="../435074/index.html">Vulnerabilities of Kyivstar: 1) analysis of the previous post about passwords + 2) info about purchases passing through the services of Kyivstar</a></li>
<li><a href="../435076/index.html">How marketers working with Google monetize our discomfort</a></li>
<li><a href="../435078/index.html">What if artificial intelligence makes actors immortal?</a></li>
<li><a href="../435080/index.html">Guide: Thymeleaf + Spring. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>