<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We simulate device control with actor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The roots of the SObjectizer originate in the topic of automated process control systems (APCS). But we used SObjectizer in areas far from ASUTP. Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We simulate device control with actor</h1><div class="post__text post__text-html js-mediator-article"><p>  The roots of the <a href="https://habrahabr.ru/post/304386/">SObjectizer</a> originate in the topic of automated process control systems (APCS).  But we used SObjectizer in areas far from ASUTP.  Therefore, sometimes there is nostalgia from the category ‚Äúoh, I haven‚Äôt taken checkers for a long time ...‚Äù One day because of this, one of the most voluminous examples appeared in SObjectizer - <a href="">machine_control</a> .  At that time, I really wanted to ‚Äúshake the old days‚Äù, to simulate the task of controlling the equipment in modern SObjectizer.  Well, under the guise of stuffing different tasty SObjectizer features like delivery filters, template agents and a dispatcher with priority support as an example.  Today we will try to tell and show how this all works. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3fb/ccd/378/3fbccd3782d46b6c8cfac121fd515ac1.jpg" alt="The Engine Room - Steel Stacks, Bethlehem, PA"><br>  Photo <a href="https://www.flickr.com/photos/memoriesbymike/30346870663/">by Mike Boening</a> </p><br><a name="habracut"></a><h1>  What do we model? </h1><br><p>  Suppose that we are dealing with a machine or a machine at a factory that has an engine inside.  Well, let's say a conveyor belt drive.  Or is it a pump that pumps water?  It does not matter.  The important thing is that when the engine is running, it heats up.  And when it heats up, it needs to be cooled.  Therefore, a cooling fan is installed near the engine.  This fan must be turned on if the engine warms up over 70 degrees.  The fan should be turned off if the engine has cooled down to 50 degrees as a result of cooling.  If, despite cooling, the engine continues to heat up and its temperature reaches 95 degrees, then the engine must be turned off and wait until it cools down to 50 degrees. </p><br><p>  Naturally, we would like to see how all this happens in dynamics.  We need to see if the engine is working now, what is the temperature of the engine, whether the cooling fan is on.  To do this, in the implementation of machine_control, we use a simple periodic print of all this information on the console. </p><br><p>  Well, in order to make it more interesting for us, we will do the work not with one engine, but with several.  They all work the same way, but their properties are different.  Some of them heat up faster, some slower.  Therefore, if you observe the work of, say, four engines, it will seem that each of them lives its own life. </p><br><h1>  Go! </h1><br><h2>  A couple of general words about the chosen solution. </h2><br><p>  It is clear that any problem can be solved in several ways.  The method described below is just one of the possible.  He was chosen not so much because of considerations of simplicity and practicality, but because of the opportunity to demonstrate different features of SObjectizer.  Therefore, it is better to treat the following text as a demonstration.  Moreover, in production everything will be much more serious and terrible;) </p><br><h2>  How exactly does the example work? </h2><br><p>  There are several agents-machines, there is a special shared mailbox.  The agent agents from time to time send messages about their current status to this shared mailbox. </p><br><p><img src="https://habrastorage.org/web/c75/07d/4d9/c7507d4d96144338a15497a34cb28cb6.jpg"></p><br><p>  From the general mailbox, messages about the status of the agent-machine come to two completely different agents.  The first of these, total_status_dashboard, collects information about the statuses of agent machines and periodically displays information about what is happening on the standard output stream.  Due to this, by running the example we see something like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bf1/53a/70a/bf153a70a9426f21168b9656fe27ef65.gif"></p><br><p>  The second agent is statuses_analyser.  It receives status information in order to control what is happening with the machines and determine the moments when some of the machines need external influence.  When impact is required, the statuses_analyser agent sends another message to the same shared mailbox.  The machine_controller agents respond to this message.  They already decide what kind of control action should be applied to a particular machine and send the corresponding message directly to the corresponding agent machine. </p><br><p>  That's all.  We will try to consider the rest of the moments in detail below. </p><br><h2>  Agent a_machine_t </h2><br><p>  Let's start the analysis of the implementation of our example ‚Äúfrom the stove‚Äù, i.e.  from the machine itself with the engine and cooling fan.  In real life, we would have some kind of real hardware to which some sensors and controllers would be connected.  And with all of this kitchen would have to work from the program through a particular interface, and maybe through several different interfaces. </p><br><p>  But we have a fictional example, so we don‚Äôt need to poll any ports and read data from real equipment.  We need something pretending to be a working machine.  For this we have an agent a_machine_t who: </p><br><ul><li>  periodically gives out to the outside world information about its state, such as: whether the engine is running, whether the fan is working, what the current temperature of the engine is; </li><li>  accepts commands to turn on / off the engine and executes them; </li><li>  accepts commands to turn on / off the fan and executes them. </li></ul><br><p>  Despite the fact that this agent is engaged in imitation, in due time, it was possible to use similar logic in APCS tasks.  The timer event agent accessed the equipment through some interface and collected information from the sensors.  After that, he transformed the captured information into the desired form and sent it to those who could properly process this information. </p><br><p>  Let's look at what this a_machine_t agent looks like, but first we introduce a few definitions that we will need in the implementation of a_machine_t: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      . enum class engine_state_t { on, off }; //      . enum class cooler_state_t { on, off }; //  -     . struct turn_engine_on : public so_5::signal_t {}; struct turn_engine_off : public so_5::signal_t {}; //  -     . struct turn_cooler_on : public so_5::signal_t {}; struct turn_cooler_off : public so_5::signal_t {}; //    . struct machine_status { //  -  . //   ,      . const std::string m_id; //   . const engine_state_t m_engine_status; //   . const cooler_state_t m_cooler_status; //   . const float m_engine_temperature; };</span></span></code> </pre> <br><p>  Accordingly, our agent a_machine_t will receive control commands in the form of turn_engine_on / turn_engine_off message signals and turn_cooler_on / turn_cooler_off, and will notify of its status by sending a machine_status message. </p><br><p>  Now you can proceed to the consideration of the agent a_machine_t.  Let's start with the giblets: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a_machine_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        //    . struct update_status : public so_5::signal_t {}; // -     : // ,   , const state_t st_engine_on{ this, "on" }; // ,   . const state_t st_engine_off{ this, "off" }; //  -  . const std::string m_id; //        machine_status. const so_5::mbox_t m_status_distrib_mbox; //    : //  , const float m_initial_temperature; //       , const float m_engine_heating_step; //       . const float m_cooler_impact_step; //   . float m_engine_temperature; //     . engine_state_t m_engine_status = engine_state_t::off; cooler_state_t m_cooler_status = cooler_state_t::off; // ID     update_status. //  SO-5    ID    //     ,    //   . so_5::timer_id_t m_update_status_timer;</span></span></code> </pre> <br><p>  The a_machine_t agent is a very simple state machine with two states: ‚Äúengine on‚Äù and ‚Äúengine off‚Äù.  In each of them, he responds to some messages differently.  In order to represent the agent as a finite state machine in a SObjectizer, we needed two separate attributes, st_engine_on and st_engine_off. </p><br><p>  At its start, the agent initiates a periodic update_status message.  Each time he receives this message, the agent recalculates the value of m_engine_temperature according to whether the engine and the fan are working or not.  After that, the machine_status message with the current readings is sent to the m_status_distrib_mbox mailbox. </p><br><p>  <a href="">The agent's constructor</a> looks bulky due to the abundance of initial parameters, but in fact it is trivial, so we will not consider it. </p><br><p>  But further more interesting.  First, it is the special method so_define_agent (), which is used so that the agent can configure itself to work inside the SObjectizer.  Our a_machine_t needs to go to its initial state and subscribe to the messages it needs.  Here's what it looks like: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_engine_off; st_engine_on .event&lt; turn_engine_off &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_engine_off ) .event&lt; turn_cooler_on &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_cooler_on ) .event&lt; turn_cooler_off &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_cooler_off ) .event&lt; update_status &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_update_status_when_engine_on ); st_engine_off .event&lt; turn_engine_on &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_engine_on ) .event&lt; turn_cooler_on &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_cooler_on ) .event&lt; turn_cooler_off &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_cooler_off ) .event&lt; update_status &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_update_status_when_engine_off ); }</code> </pre> <br><p>  It can be noted that the agent in different states responds to the update_status signal with different handlers.  You can also see that in the st_engine_on state, the turn_engine_on signal is ignored, since there is no point in switching on an already running engine.  Similarly, turn_engine_off is in st_engine_off state. </p><br><p>  Regarding the so_define_agent () method, it is impossible not to make a small lyrical digression: at first glance, this method looks redundant and it seems that one could do without it.  After all, you can perform all agent settings directly in the constructor. </p><br><p>  Indeed, it is possible.  In the simplest cases, this is done.  But if inheritance is used for agents, then setting an agent in so_define_agent () is more convenient than in the constructor.  Classes inheritors receive a simple and convenient way to interfere with the base class settings (for example, you can simply not call so_define_agent () for the base class, then all settings will be made by the derived class). </p><br><p>  In addition, in our experience, a separate method so_define_agent () begins to justify itself in large projects written by different people: you open someone else's code, you immediately look at someone else's so_define_agent () and see everything in one place.  Greatly saves time and effort. </p><br><p>  The next important method is so_evt_start ().  The SObjectizer automatically calls it on all agents that start working inside the SObjectizer.  Our a_machine_t uses so_evt_start () to start sending a periodic update_status message: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     update_status   // ID ,       , //   . m_update_status_timer = so_5::send_periodic&lt; update_status &gt;( //      . *this, //        . std::chrono::milliseconds(0), //      200ms. std::chrono::milliseconds(200) ); }</span></span></code> </pre> <br><p>  Next come the a_machine_t agent event handlers.  An event handler is a method that SObjectizer will call when the agent receives the corresponding incident message.  The correspondence between the incident message and the handler is set when subscribing to the message.  So, subscription of the form: </p><br><pre> <code class="cpp hljs">st_engine_on .event&lt; turn_engine_off &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_machine_t</span></span>::evt_turn_engine_off )</code> </pre> <br><p>  tells SObjectizer that when an agent receives a message like turn_engine_off, then the agent should call the method evt_turn_engine_off (). </p><br><p>  The a_machine_t agent has four simple handlers whose work does not make sense to explain: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_turn_engine_off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . this &gt;&gt;= st_engine_off; //   . m_engine_status = engine_state_t::off; } void evt_turn_engine_on() { this &gt;&gt;= st_engine_on; m_engine_status = engine_state_t::on; } void evt_turn_cooler_off() { //     . //     . m_cooler_status = cooler_state_t::off; } void evt_turn_cooler_on() { m_cooler_status = cooler_state_t::on; }</span></span></code> </pre> <br><p>  But on the reactions to the periodic update_status message, you will need to give a few explanations.  First look at the reaction to update_status when the engine is running: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_update_status_when_engine_on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_engine_temperature += m_engine_heating_step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">cooler_state_t</span></span>::on == m_cooler_status ) m_engine_temperature -= m_cooler_impact_step; distribute_status(); }</code> </pre> <br><p>  Since the engine is working for us, and therefore it is heating up, we must increase the current temperature.  However, if the cooling fan is on, the temperature needs to be adjusted to the effect of cooling. </p><br><p>  When the update_status signal is processed to the st_engine_off state, i.e.  when the engine is off, we only need to consider the effect of cooling, if it is now on: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_update_status_when_engine_off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">cooler_state_t</span></span>::on == m_cooler_status ) { m_engine_temperature -= m_cooler_impact_step; <span class="hljs-comment"><span class="hljs-comment">//         //   . if( m_engine_temperature &lt; m_initial_temperature ) m_engine_temperature = m_initial_temperature; } distribute_status(); }</span></span></code> </pre> <br><p>  Well, the auxiliary method distribute_status () has a completely trivial implementation, since  its only task is to send the machine_status message to the mailbox specifically designed for this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distribute_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  send-    machine_status, //      send. //          // m_status_distrib_mbox. so_5::send&lt; machine_status &gt;( //   . m_status_distrib_mbox, //       //   machine_status. m_id, m_engine_status, m_cooler_status, m_engine_temperature ); }</span></span></code> </pre> <br><h3>  Where do machine_status messages fly to? </h3><br><p>  Perhaps someone from the readers had a question: why does a_machine_t not decide on switching the fan and the engine on / off?  Why, instead of independently analyzing what is happening and taking appropriate actions, does a_machine_t only periodically send somewhere messages about its current state? </p><br><p>  This is because decomposition :) </p><br><p>  When we design a system based on an object-oriented approach, we strive to ensure that each object is responsible for its task and the effect we need would be achieved by combining them.  Similarly, the same happens when designing a system based on actors (agents): let each actor be responsible for his task, and we will form a solution by combining them. </p><br><p>  Therefore, the a_machine_t agent solves only one task: implements the interface with the equipment (in our example, it simulates this interface).  In a real task, a_machine_t would be engaged in setting / resetting bitics, reading and writing bytes to some communication port with checks for successful I / O operations, monitoring data transfer speeds, timeouts, and so on. Low-level things. </p><br><p>  So the task of a_machine_t is to get meaningful information from the device, suitable for further processing, to give this information to someone up, to take the command for the device from above, to convert this command into a sequence of actions understood by the device.  What a_machine_t to the best of the limitations of a specific imitation does. </p><br><h2>  Agent a_total_status_dashboard_t </h2><br><p>  The a_total_status_dashboard_t agent should collect machine_status messages, aggregate the information from these messages, and periodically map the aggregated information to the standard output stream. </p><br><p>  To do its job, a_total_status_dashboard_t subscribes to two messages: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe( m_status_distrib_mbox ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_total_status_dashboard_t</span></span>::evt_machine_status ); so_subscribe_self().event&lt; show_dashboard &gt;( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_total_status_dashboard_t</span></span>::evt_show_dashboard ); }</code> </pre> <br><p>  The first message, machine_status, is waited for by the agent from a special mailbox to which a_machine_t agents send their machine_status messages.  And the second message, show_dashboard, agent a_total_status_dashboard_t sends itself in the form of a periodic message: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      //    . const auto period = std::chrono::milliseconds( 1500 ); m_show_timer = so_5::send_periodic&lt; show_dashboard &gt;( *this, period, period ); }</span></span></code> </pre> <br><p>  Here a_total_status_dashboard_t uses the same approach as the a_machine_t agent - initiates a periodic message in its so_evt_start () method, which the SObjectizer automatically calls at the very beginning of a_total_status_dashboard_t. </p><br><p>  Processing machine_status is very simple: you just need to save the next piece of information in an associative container: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_machine_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_status &amp; status )</span></span></span><span class="hljs-function"> </span></span>{ m_machine_statuses[ status.m_id ] = <span class="hljs-keyword"><span class="hljs-keyword">one_machine_status_t</span></span>{ status.m_engine_status, status.m_cooler_status, status.m_engine_temperature }; }</code> </pre> <br><p>  And the show_dashboard handler does not contain anything complicated: just an iteration of the contents of the associative container with printing to the standard output stream: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_show_dashboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> old_precision = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision( <span class="hljs-number"><span class="hljs-number">5</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"=== The current status ==="</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; m : m_machine_statuses ) { show_one_status( m ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"=========================="</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision( old_precision ); }</code> </pre> <br><p>  Since the a_total_status_dashboard_t agent is not of great interest and its implementation is very simple, we will not go further into its implementation.  Who cares, the full source code a_total_status_dashboard_t can be seen <a href="">here</a> . </p><br><h2>  Agents a_statuses_analyser_t and a_machine_controller_t </h2><br><p>  In this implementation of the machine_control example, a bundle of several agents deals with the analysis of information from the a_machine_t agents and the issuance of control commands to the agent machines. </p><br><p>  First, it is the a_statuses_analyser_t agent that receives the machine_status messages, analyzes them, and determines that a specific a_machine_t needs some kind of impact. </p><br><p>  Secondly, there is a group of a_machine_controller_t type template agents that react to signals from a_statuses_analyser_t and give out this or that effect on a specific machine.  So, one agent a_machine_controlle_t responds to the situation when the cooling fan should be turned on and sends the turn_cooler_on message to the corresponding agent a_machine_t.  Another agent a_machine_controller_t responds to the situation when the engine should be turned off and sends the message turn_engine_off.  Etc. </p><br><p>  Generally speaking, such a division into a_statuses_analyser_t and a_machine_controller_t is a clear complication of our example.  It would be entirely possible to do with just one agent a_statuses_analyser_t, who himself could analyze the information and send the control commands.  Although, most likely, the agent a_statuses_analyser_t would greatly increase in volume at the same time. </p><br><p>  Initially, in machaine_control, I wanted to show various SObjectizer features, in particular, the use of template agents and agent priorities, so we decided to divide the logic between a_statuses_analyser_t and a_machine_controller_t. </p><br><p>  So, the essence of the interaction a_machine_t, a_statuses_analyser_t and a_machine_controller_t is as follows: </p><br><ul><li>  a_machine_t periodically sends information about itself as a machine_status message; </li><li>  a_statuses_analyser_t collects information from machine_status and determines whether any impact is needed on a specific a_machine_t.  If an impact is needed, a_status_analyser_t sends a machine_needs_attention message with information about which machine needs which effect; </li><li>  a_machine_controller_t agents respond to machine_needs_attention messages and generate turn_engine_on / turn_engine_off and / or turn_cooler_on / turn_cooler_off messages for a specific a_machine_t agent. </li></ul><br><p><img src="https://habrastorage.org/web/0af/4ce/f95/0af4cef95a954889aeebaa6258de85b0.jpg"></p><br><p>  The machine_needs_attention message has the following form: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      . enum class attention_t { none, engine_cooling_done, engine_cooling_needed, engine_overheat_detected }; //   ,     - . struct machine_needs_attention { //  - . const std::string m_id; //   . const attention_t m_attention; //      (/). const engine_state_t m_engine_status; //     (/). const cooler_state_t m_cooler_status; };</span></span></code> </pre> <br><p>  The a_statuses_analyser_t agent stores past information about each machine and compares it with new information coming in with the machine_status message.  If it is found that the engine requires cooling, or that the engine has overheated, or that the engine has reached a safe temperature, then a_statuses_analyser_t generates a machine_needs_attention message.  This message is picked up by the appropriate a_machine_controller_t and the right team will be sent to the appropriate a_machine_t agent. </p><br><h3>  Learn more about the a_statuses_analyser_t agent </h3><br><p>  <a href="">Offal from agent a_statuses_analyser_t is quite voluminous</a> .  But most of them relate to storing and analyzing the current state of the agents-machines.  We will not analyze this part in details (if there are any questions, I will answer them in the comments), we will just explain in two words: </p><br><ul><li>  agent a_statuses_analyser_t stores an associative container with information about the last known status of each agent machine.  The key in this container is the unique name-id of the machine; </li><li>  when receiving the next machine_status message, the agent checks the latest information so that it has been saved previously.  If situations are found that require an impact on the agent machine, then a machine_needs_attention message is generated; </li><li>  whereupon the a_statuses_analyser_t agent updates the data in its associative container. </li></ul><br><p>  In the code, all this takes a decent amount of lines, but there is nothing complicated there. </p><br><p>  But that part of the a_statuses_analyser_t agent, which is related to the interaction with SObjectizer, is generally minimal: just a subscription to one single message in so_define_agent () and one single event for this message: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe( m_status_distrib_mbox ).event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_statuses_analyzer_t</span></span>::evt_machine_status ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_machine_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_status &amp; status )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = m_last_infos.find( status.m_id ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_last_infos.end() ) <span class="hljs-comment"><span class="hljs-comment">//        . //     . it = m_last_infos.insert( last_info_map_t::value_type { status.m_id, last_machine_info_t { attention_t::none, status.m_engine_temperature } } ).first; handle_new_status( status, it-&gt;second ); }</span></span></code> </pre> <br><p>  Where the handle_new_status () method, which is called inside evt_machine_status (), is already part of the application logic for monitoring the status of an agent-machine, which we briefly described earlier. </p><br><h3>  More about a_machine_controller_t agents </h3><br><h4>  What is the meaning of a_machine_controller_t? </h4><br><p>  The presence of several instances of the a_machine_controller_t agents has the following meaning: when the a_statuses_analyser_t agent determines, for example, that the engine of a car has cooled to a safe temperature, then we may need to do several different actions.  First, turn off the cooling fan.  Secondly, it may be that the engine was previously disabled and we need to turn it on again. </p><br><p>  If we put all this logic inside a_statuses_analyser_t, then its code would grow and it would be more difficult to understand it.  Instead, we simply made a_statuses_analyser_t announce what exactly should be noted in the work of the agent machine.  And the agents of a_machine_controller_t will already respond to this ad.  And each a_machine_controller_t itself determines whether it needs to react or not.  If necessary, a_machine_contoller_t receives the machine_needs_attention message and initiates the appropriate command to the agent machine.  If not needed, a_machine_controller_t simply ignores the machine_needs_attention message. </p><br><h4>  Agent a_machine_controller_t </h4><br><p>  The code of the a_machine_controller_t template agent is small, so for ease of working with it, we‚Äôll give the full code for this agent in its entirety: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LOGIC</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a_machine_controller_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">a_machine_controller_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, so_5::<span class="hljs-keyword"><span class="hljs-keyword">priority_t</span></span> priority, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> status_distrib_mbox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">machine_dictionary_t</span></span> &amp; machines ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx + priority ) , m_status_distrib_mbox( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( status_distrib_mbox ) ) , m_machines( machines ) , m_logic() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_set_delivery_filter( m_status_distrib_mbox, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> machine_needs_attention &amp; msg ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_logic.filter( msg ); } ); so_subscribe( m_status_distrib_mbox ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> machine_needs_attention &amp; evt ) { m_logic.action( m_machines, evt ); } ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_status_distrib_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">machine_dictionary_t</span></span> &amp; m_machines; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LOGIC m_logic; };</code> </pre> <br><p>  So, this is a template class that is parameterized by one parameter: the type of application logic that a_machine_controller_t should have.  This type of LOGIC must be of the following type with two methods: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LOGIC</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">machine_dictionary_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; machines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; evt )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br><p>  If there were concepts in C ++ 11, then it would be possible to declare the corresponding concept in order to make it easier to determine which type can be a parameter for the a_machine_controller_t template, and which one can not.  But, since  in C ++ 11 the concepts were not delivered, then you have to rely on duck typing. </p><br><p>  The a_machine_controller_t agent creates an instance of the LOGIC type inside itself and delegates all its actions to this instance.  And this instance is nothing more than a controller that provides control actions to the agent machine. </p><br><p>  The controller has only two actions: </p><br><p>  First, you need to filter messages that are not interesting to a particular controller.   a_machine_controller_t    : </p><br><pre> <code class="cpp hljs">so_set_delivery_filter( m_status_distrib_mbox, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> machine_needs_attention &amp; msg ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_logic.filter( msg ); } );</code> </pre> <br><p>   ‚Äî    SObjectizer-.    ,        T    M,        T,   ,      . </p><br><p>        so_set_delivery_filter()  , -,    M     ,       T.    true,           .     false,      ,       ,    . </p><br><p><img src="https://habrastorage.org/web/b37/1ce/fa4/b371cefa4d164802bda0f884a66ca87d.jpg"><br> <i><font>    .  Subscriber-1           mbox-.    Subscriber-2        ,    .</font></i> </p><br><p>   LOGIC::filter()      ,      machine_needs_attention,   . </p><br><p> -,   -     machine_needs_attention,      ,   . </p><br><p>     LOGIC::action().  a_machine_controller_t       machine_needs_attention: </p><br><pre> <code class="cpp hljs">so_subscribe( m_status_distrib_mbox ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> machine_needs_attention &amp; evt ) { m_logic.action( m_machines, evt ); } );</code> </pre> <br><h4>   controller- </h4><br><p>    ,   ,     a_machine_controller_t,    .   ,      turn_engine_off,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">engine_stopper_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> msg.m_attention == <span class="hljs-keyword"><span class="hljs-keyword">attention_t</span></span>::engine_overheat_detected; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">machine_dictionary_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; machines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; evt )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ so_5::send&lt; turn_engine_off &gt;( machines.find_mbox( evt.m_id ) ); } };</code> </pre> <br><p>  Those.     machine_needs_attention,     .     ,   -   turn_engine_off. </p><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cooler_starter_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (msg.m_attention == <span class="hljs-keyword"><span class="hljs-keyword">attention_t</span></span>::engine_overheat_detected || msg.m_attention == <span class="hljs-keyword"><span class="hljs-keyword">attention_t</span></span>::engine_cooling_needed) &amp;&amp; msg.m_cooler_status == <span class="hljs-keyword"><span class="hljs-keyword">cooler_state_t</span></span>::off; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">machine_dictionary_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; machines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> machine_needs_attention &amp; evt )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ so_5::send&lt; turn_cooler_on &gt;( machines.find_mbox( evt.m_id ) ); } };</code> </pre> <br><p>      .           ,       ,   . </p><br><p>      : </p><br><ul><li> engine_stopper_t    ; </li><li> engine_starter_t    ; </li><li> cooler_starter_t    ; </li><li> cooler_stopper_t    . </li></ul><br><p>  ,    a_machine_controller_t   ‚Äî      . </p><br><h4>    a_machine_controller_t </h4><br><p>    machine_control   ,       machine_needs_attention    . ,   machine_needs_attention  attention_t::engine_overheat_detected  cooler_status_t::off,       :   engine_stopper_t,   cooler_starter_t. </p><br><p>    ,       .  ,    engine_overheat_detected     turn_engine_off,     turn_cooler_on.      - ,   .        ,     .     ,        . </p><br><p>     SObjectizer-     ? </p><br><p>   .  ,           .   ,              .     . ,            ,   . </p><br><p>  SObjectizer    :            ,                .   so_5::disp::prio_one_thread::strictly_ordered.      a_machine_controller_t   . </p><br><p>     -   : </p><br><ul><li>         engine_stopper_t, ..         ; </li><li>       cooler_starter_t,     ‚Äî     ; </li><li>       engine_starter_t; </li><li>           cooler_stopper_t. </li></ul><br><p>  ,      a_machine_controller_t    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">a_machine_controller_t</span></span>( ..., so_5::<span class="hljs-keyword"><span class="hljs-keyword">priority_t</span></span> priority, ... ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx + priority ) , ... {}</code> </pre> <br><p>      : </p><br><pre> <code class="cpp hljs">coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_machine_controller_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">engine_stopper_t</span></span> &gt; &gt;( disp-&gt;binder(), so_5::prio::p4, status_distrib_mbox, machines ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_machine_controller_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">cooler_starter_t</span></span> &gt; &gt;( disp-&gt;binder(), so_5::prio::p3, status_distrib_mbox, machines );</code> </pre> <br><p>   so_5::prio::p4  so_5::prio::p3 ‚Äî     . </p><br><h2> - </h2><br><p>    ,   a_machine_t      st_engine_off, ..   .     ,       .    ,   a_machine_t,  a_machine_controller_t        ? </p><br><p>  ,   -     -,       turn_engine_on  -. </p><br><p>    ,         C++ ,       a_machine_t, a_total_status_dashboard_t, a_statuses_analyser_t  a_machine_controller_t.      ,  ad-hoc .  Those. ,       -.   machine_control    : </p><br><pre> <code class="cpp hljs">coop.define_agent().on_start( [&amp;dict] { dict.for_each( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &amp; mbox ) { so_5::send&lt; turn_engine_on &gt;( mbox ); } ); } );</code> </pre> <br><p>  define_agent()   ad-hoc ,      .          ad-hoc   SObjectizer-:       turn_engine_on. </p><br><h2>     </h2><br><p>      SObjectizer-,     ,               . </p><br><p>       .      -  .  SObjectizer     .            ,      . </p><br><p>   machine_control   ,         : </p><br><ul><li>  -      ,          one_thread; </li><li>  a_total_status_dashboard_t      (     one_thread); </li><li>  a_statuses_analyser_t      (     one_thread); </li><li>   a_machine_controller_t         prio_one_thread::strictly_ordered,       ; </li><li> -        . </li></ul><br><p><img src="https://habrastorage.org/web/168/f70/544/168f70544a3e4508ab46369547799e85.jpg"></p><br><h2>    ¬´ ¬ª? </h2><br><p>           , , ,        :  <a href="">machine_dictionary</a> .   ,       - -     . </p><br><p>     ,    - (    machine_status  machine_needs_attention)       .    SObjectizer    , ,  ,   turn_engine_on,      .     machine_dictionary. </p><br><h1>         ? </h1><br><p>  ,      ,        ,      . </p><br><p>   ,      ,  ,    ,   a_machine_t  a_machine_controller_t,      . </p><br><p>    SObjectizer-,         ad-hoc     ‚Äî       .  ,    ,    -    SObjectizer,    ,    ,     ,                ¬´ ¬ª.  -,   ,       <a href="">ping-pong</a> ,      ,     .          ,  SObjectizer. </p><br><p> ,       ,   .     ,  ,   Actor Model  Publish/Subscribe       . </p><br><h2>     </h2><br><p>      machine_control  ,    (.. )            . </p><br><p> ,  a_machine_t    machine_status        ,     ,           .   a_machine_t    (   )        . ,     . </p><br><p>     a_machine_t    ( turn_engine_on),   ,      .  a_machine_t     ,     .        ,       ‚Äî    a_machine_t    . </p><br><p>  ,  -    turn_engine_on   a_machine_t,       Actor Model,      1:1. </p><br><p>       machine_status  machine_needs_attention      Actor Model, ..     1:N.      Publish/Subscribe.   ,     machine_status  machine_needs_attention,   .      ‚Äî  -  Publish.          Subscribe, , ,  a_total_status_dashboard_t, a_statuses_analyser_t  a_machine_controller_t     so_define_agent(). </p><br><p>        ,    SObjectizer:            .      ,   SObjectizer  multi-producer/multi-consumer  ,         1:N. </p><br><p> ,  machine_status, ,      ,           .  a_total_status_dashboard_t  machine_status        .   a_statuses_analyser_t  machine_status     a_machine_t. </p><br><p>     .        ,             .          a_total_status_dashboard_t  a_statuses_analyser_t.       a_total_status_dashboard_t  - a_gui_status_dashboard_t,         std::cout,    .  ,  ,       ,     machine_status. </p><br><p>      SObjectizer ‚Äî     ,        ,      .     SObjectizer       ,     (   CSP- ). </p><br><p>         SObjectizer   ,       ,         .         (..     ),        . </p><br><p>       ,      .   ‚Äî    .  ,        .     -,    -   ,      so_5::signal_t,     .      ,     -      ,     -  .   ,      ,  -      -  . </p><br><h1>  Instead of conclusion </h1><br><p>          ,  ,      . </p><br><p>    ,   SObjectizer-    <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%2520Documentation/">so_5_extra</a> ,        SObjectizer.   ,   SObjectizer     ,      ,      .   so_5_extra        ,     .     -    SObjectizer,    .         SObjectizer,       so_5_extra. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332166/">https://habr.com/ru/post/332166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332144/index.html">LibGDX + Scene2d (we program on Kotlin). Part 0</a></li>
<li><a href="../332146/index.html">Redux business logic</a></li>
<li><a href="../332160/index.html">Docker 17.06 and Kubernetes 1.7: key innovations</a></li>
<li><a href="../332162/index.html">FinWin-2017: competition fintech projects and the latest trends in the banking sector</a></li>
<li><a href="../332164/index.html">Introduction to procedural animation</a></li>
<li><a href="../332168/index.html">Three years of successful provision of public rental services of virtual machines with Apache CloudStack</a></li>
<li><a href="../332172/index.html">5 free assets for Unity3D, which will facilitate the development process</a></li>
<li><a href="../332174/index.html">Updating document.title in the background tab</a></li>
<li><a href="../332176/index.html">Programming Contest: JSDash</a></li>
<li><a href="../332178/index.html">How computer pros crack hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>