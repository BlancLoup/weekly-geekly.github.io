<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Eliminate Where Expressions Duplication in an Application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suppose you have products and categories. At some point, the client reports that for categories with a rating of> 50, it is necessary to use other bus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Eliminate Where Expressions Duplication in an Application</h1><div class="post__text post__text-html js-mediator-article">  Suppose you have products and categories.  At some point, the client reports that for categories with a rating of&gt; 50, it is necessary to use other business processes.  You have enough experience and you understand that where today is 50 tomorrow will be 127.37 and you want to avoid the appearance of magic numbers in the code, so do this: <br><br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Category</span></span></span><span class="hljs-class"> :</span></span> HasIdBase&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Expression&lt;Func&lt;Category, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; NiceRating = x =&gt; x.Rating &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } var niceCategories = db.Query&lt;Category&gt;.Where(Category.NiceRating);</span></span></code> </pre> <br>  Unfortunately, this number will not work if you want to select products from the respective categories, because NiceRating is of type <code>Expression&lt;Func&lt;Category, bool&gt;&gt;</code> , and in the case of Product we will need <code>Expression&lt;Func&lt;Product, bool&gt;&gt;</code> .  That is, it is necessary to perform the conversion <code>Expression&lt;Func&lt;Category, bool&gt;&gt; =&gt; Expression&lt;Func&lt;Product, bool&gt;&gt;</code> . <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasIdBase</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">int</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual Category Category { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... } var niceProductsCompilationError = db.Query&lt;Product&gt;.Where(Category.NiceRating); //  !</span></span></code> </pre><br>  Fortunately, it's pretty easy to do! <br><a name="habracut"></a><br><pre> <code class="hljs pgsql"> //     , //    ,     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;TIn, TOut&gt;&gt; Compose&lt;TIn, TInOut, TOut&gt;( this Expression&lt;Func&lt;TIn, TInOut&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, Expression&lt;Func&lt;TInOut, TOut&gt;&gt; inOutOut) { //   x =&gt; blah-blah.     <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> var param = Expression.Parameter(typeof(TIn), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); //  ,     var invoke = Expression.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, param); //   "       " var res = Expression.Invoke(inOutOut, invoke); //     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;TIn, TOut&gt;&gt;(res, param); } //  ""  <span class="hljs-keyword"><span class="hljs-keyword">Where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static IQueryable&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>&lt;T, TParam&gt;(this IQueryable&lt;T&gt; queryable, Expression&lt;Func&lt;T, TParam&gt;&gt; prop, Expression&lt;Func&lt;TParam, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryable.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(prop.Compose(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>)); } //  [Fact] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> AdvancedWhere_Works() { var product = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Product(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Category() {Rating = <span class="hljs-number"><span class="hljs-number">700</span></span>}, "Some Product", <span class="hljs-number"><span class="hljs-number">100500</span></span>); var q = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>[] {product}.AsQueryable(); var <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> = q.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x.Category, Category.NiceRating).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal(<span class="hljs-number"><span class="hljs-number">700</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].Category.Rating); }</code> </pre><br>  This is how the composition of expressions in <a href="http://www.albahari.com/nutshell/linqkit.aspx">LinqKit is implemented</a> .  However, the Entity Framework is not friendly with <code>InvokeExpression</code> and throws a <code>NotSupportedException</code> .  Did you know that <a href="http://blog.ploeh.dk/2013/07/20/linq-versus-the-lsp/">LINQ is leaking</a> ?  To get around this limitation, LinqKit uses the <s>hack</s> <code>AsExpandable</code> extension <code>AsExpandable</code> .  This problem was described by Pete Montgomery in <a href="https://petemontgomery.wordpress.com/2011/02/10/a-universal-predicatebuilder/">his blog</a> .  Its version of Predicate Builder does not require special street magic and works for both <code>IEnumerable&lt;T&gt;</code> and <code>IQueryable&lt;T&gt;</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I give the code as is. <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PredicateBuilder { /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Creates a predicate that evaluates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>&lt;T&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Creates a predicate that evaluates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>&lt;T&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Creates a predicate expression <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the specified lambda expression. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>&lt;T&gt;(Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; predicate) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> predicate; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Combines the first predicate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the second <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> the logical "and". /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>&lt;T&gt;(this Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; first, Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; second) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.Compose(second, Expression.AndAlso); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Combines the first predicate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the second <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> the logical "or". /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">Or</span></span>&lt;T&gt;(this Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; first, Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; second) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.Compose(second, Expression.OrElse); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Negates the predicate. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>&lt;T&gt;(this Expression&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; expression) { var negated = Expression.<span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>(expression.Body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;T, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt;(negated, expression.Parameters); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Combines the first expression <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the second <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> the specified merge <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static Expression&lt;T&gt; Compose&lt;T&gt;(this Expression&lt;T&gt; first, Expression&lt;T&gt; second, Func&lt;Expression, Expression, Expression&gt; merge) { // zip parameters (map <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> parameters <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> second <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameters <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> first) var map = first.Parameters .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>((f, i) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { f, s = second.Parameters[i] }) .ToDictionary(p =&gt; ps, p =&gt; pf); // replace parameters <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the second lambda expression <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the parameters <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the first var secondBody = ParameterRebinder.ReplaceParameters(map, second.Body); // <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> a merged lambda expression <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> parameters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the first expression <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;T&gt;(merge(first.Body, secondBody), first.Parameters); } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ParameterRebinder : ExpressionVisitor { readonly <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;ParameterExpression, ParameterExpression&gt; map; ParameterRebinder(<span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;ParameterExpression, ParameterExpression&gt; map) { this.map = map ?? <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;ParameterExpression, ParameterExpression&gt;(); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Expression ReplaceParameters(<span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;ParameterExpression, ParameterExpression&gt; map, Expression exp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ParameterRebinder(map).Visit(exp); } protected override Expression VisitParameter(ParameterExpression p) { ParameterExpression replacement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map.TryGetValue(p, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> replacement)) { p = replacement; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.VisitParameter(p); } } }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/313394/">https://habr.com/ru/post/313394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313382/index.html">Virtual server with video card</a></li>
<li><a href="../313384/index.html">Dribbble review number 2 - the most interesting interface designs for the last 2 weeks</a></li>
<li><a href="../313386/index.html">The digest of interesting materials for the mobile developer # 176 (October 17-23)</a></li>
<li><a href="../313390/index.html">Interview with MapR's VP of Technology Strategy</a></li>
<li><a href="../313392/index.html">Pattern Strategy JavaScript</a></li>
<li><a href="../313396/index.html">Why is it too late to "make money" in business literature</a></li>
<li><a href="../313398/index.html">10 arguments against email migration to Microsoft cloud</a></li>
<li><a href="../313400/index.html">Hacker dossier: Boris Florikik aka Tron, creator of the first Cryptophone</a></li>
<li><a href="../313402/index.html">The digest of fresh materials from the world of the frontend for the last week No. 233 (October 17‚Äì23, 2016)</a></li>
<li><a href="../313410/index.html">How to explain to granny what Agile is in 15 minutes with pictures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>