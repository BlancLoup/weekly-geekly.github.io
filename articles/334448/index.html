<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse side of spring</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Week Spring on Habr√©, apparently, is open. I would like to say thanks to the translator and commentators of the article ‚ÄúWhy I hate Spring‚Äù , which, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse side of spring</h1><div class="post__text post__text-html js-mediator-article"><p>  Week Spring on Habr√©, apparently, is open.  I would like to say thanks to the translator and commentators of the article <a href="https://habrahabr.ru/post/334118/">‚ÄúWhy I hate Spring‚Äù</a> , which, despite the strong negative message in the title, caused a number of interesting discussions, as well as those who responded to my previous article <a href="https://habrahabr.ru/post/333756/">How to write for Spring in 2017</a> .  Thanks largely to the comments on the previous article, this one appeared. </p><br><p>  This time we will plunge into the depths of the Spring framework, expose its magic, see how the basic web application looks from the inside, and figure out what the same task and how Spring Boot solves. </p><a name="habracut"></a><br><p>  In the comments to the previous article, several people very rightly pointed out that the example of Hello World on Spring is still not very revealing.  Spring, especially with the use of Spring Boot, gives a feeling of simplicity and omnipotence, but misunderstanding of the basics and insides of the framework leads to a great danger of getting a trace on the log.  Well, in order to dispel a little the feeling of the full magic of what is happening, today we will take the application from the previous article and analyze how and what happens inside the framework and what problems we are protected from by the Boot.  The target audience is still novice developers, but with some experience and basic knowledge of Java and Spring.  Although, perhaps, Spring experienced users will also find it interesting to refresh their knowledge of what is going on under the hood. </p><br><h1 id="klyuchevye-ponyatiya">  Key Concepts </h1><br><h2 id="biny">  Bins </h2><br><p>  Let's begin to tear the covers from the most basic concepts of Spring.  <strong>A bean</strong> is nothing but the most common object.  The only difference is that it is accepted to call the objects that are controlled by Spring and live inside its DI container as bins.  Bin is almost everything in Spring - services, controllers, repositories, in fact, the entire application consists of a set of beans.  They can be registered, received as dependencies, proxied, mock, etc. </p><br><h2 id="di-konteyner">  DI container </h2><br><p>  The key and fundamental mechanism of Spring.  It looks very simple, but inside it provides a lot of mechanisms for fine-tuning dependencies.  In fact, any Spring application is a collection of bins connected together via a DI container. </p><br><p> Very often, when discussing Spring, the argument sounds that you can easily replace it with any lightweight DI container (Guice, for example) and get the same, but easier and simpler.  And here it is very important to understand - the value of Spring DI is not in the very fact of its existence, but in its fundamental nature.  All the libraries in the Spring ecosystem, in fact, simply register their bins in this container (including Spring itself) - and application developers will be able to get the necessary components through dependency injection.  A simple example: when using <strong>Spring Security OAuth,</strong> if you configure the OAuth parameters in <code>application.properties</code> , then Spring Security will provide an <code>OAuth2RestTemplate</code> bin which we can simply inject into our code.  And when you access the external API, this bin will know where and how to go to get the OAuth token, how to update it, where to add it to the request, etc.  So the value of DI here is that it is just a mechanism for communication between our code and Spring Security.  And by simply replacing the DI implementation with Guice, you cannot ensure that Spring Security also starts using it.  And if in this new DI there is no integration with all the libraries of Spring, then its value drops dramatically. </p><br><p>  Another very important point that many miss when discussing a DI container is that the use of dependency injection does not imply the creation of interfaces for <strong>each</strong> component.  This is a very simple idea, but I have seen many times that because of its simplicity, it is not always obvious.  Moreover, the creation of an interface, if it has only one implementation, is considered bad practice.  Those.  classes themselves may well be DI objects.  Moreover, the lack of an interface does not even prevent them from getting wet in the tests, since  Mockito, for example, is quite able to mock classes. </p><br><h2 id="kontekst">  Context </h2><br><p>  Presented by the <code>ApplicationContext</code> interface.  In essence, it is the Spring application itself.  The context also provides the ability to respond to various events that occur within the application, to manage the life cycle of the beans (create as a singleton or for each request, for example). </p><br><h2 id="konfiguraciya">  Configuration </h2><br><p>  So, if an application is a set of beans, in order for it to work, we need to describe this set. </p><br><p>  <strong>A configuration</strong> is simply a description of the available bins.  Spring provides several options for describing the set of beans that will form an application.  The historical option is through a set of <strong>xml files</strong> .  Nowadays, <strong>Java annotations</strong> have replaced it.  Spring Boot is built on annotations a little more than completely, and most modern libraries in principle can also be configured via annotations.  In its third generation, the configuration of the beans came to the functional registration approach ( <strong>functional bean registration</strong> ), which will become one of the important new features of the upcoming Spring 5. </p><br><p>  A typical configuration class might look like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentsServiceConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PaymentProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PayPalPaymentProvider(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PaymentService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaymentProvider paymentProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PaymentService(paymentProvider); } }</code> </pre> <br><p>  This configuration defines two bins, and the second depends on the first.  And here Spring will come into play - when we ask for the <code>PaymentProvider</code> instance - Spring will find it in context and provide it to us. </p><br><p>  The configuration does not necessarily describe in one huge file, you can split it into several and combine them using <code>@Import</code> annotations. </p><br><h2 id="skanirovanie-komponentov">  Component scan </h2><br><p>  An important component of the Spring Framework, another approach to simplifying application configuration.  The idea is very simple - if we know that our <code>MyCoolComponent</code> class should register a bean with the name <code>myCoolComponent</code> , why write <code>@Bean MyCoolComponent myCoolComponent(dependencies...) { return new MyCoolComponent(dependencies...); }</code> every time <code>@Bean MyCoolComponent myCoolComponent(dependencies...) { return new MyCoolComponent(dependencies...); }</code>  <code>@Bean MyCoolComponent myCoolComponent(dependencies...) { return new MyCoolComponent(dependencies...); }</code> ?  Why not just give Spring ‚Äì y the machine to register and create a bin based on the desired class?  This task is solved by scanning the components.  Those.  if we declare our class as </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCoolComponent</span></span></span><span class="hljs-class"> </span></span>{ MyCoolComponent(dependencies...) { } }</code> </pre> <br><p>  and allow scanning of components - then Spring will create and register a bin with the name <code>myCoolComponent</code> , using the class constructor and injecting all dependencies there. </p><br><blockquote>  Be careful when scanning components.  in fact, it implicitly changes the context of the application.  For example, if we have an interface and two implementations - and <code>@Component</code> is specified on each, then when trying to inject a dependency on the interface, Spring will throw an exception that there are two bins that satisfy the query. </blockquote><br><h2 id="rezyume">  Summary </h2><br><p>  So, the things you need to remember: the Spring application, described by the <code>ApplicationContext</code> interface, is a set of objects ( <em>bins</em> ) managed by the DI container.  Configuration of a set of beans is done using configuration classes (annotation <code>@Configuration</code> ), which can be combined using imports (annotation <code>@Import</code> ). </p><br><h1 id="spring-boot">  Spring boot </h1><br><p>  Now go to the next part.  Suppose we need to configure a connection to a MySQL database.  If we want to use <strong>Spring Data JPA</strong> with <strong>Hibernate</strong> as a provider, we will need to configure several bins - <code>EntityManagerFactory</code> (main JPA class), <code>DataSource</code> to connect directly to the database via the JDBC driver, etc.  But on the other hand, if we do it every time and, in fact, do the same thing - why not automate it?  Let's say if we specified the connection string to the database and added a dependency on the MySQL driver - why not automatically create all the necessary bins for working with MySQL?  This is what <strong>Spring Boot</strong> does.  In essence, <strong>Spring Boot</strong> is just a set of configuration classes that create the necessary beans in the context.  Similarly, they can be created by hand, just Boot automates it. </p><br><h2 id="avtokonfiguraciya">  Autoconfiguration </h2><br><p>  The important concept of <strong>Spring Boot</strong> is autoconfiguration.  In essence, this is just a set of configuration classes that create and register specific beans in an application.  By and large, even the <strong>Embedded Servlet Container itself</strong> is just another bin that can be configured!  A couple of important points that are important to know about autoconfiguration: </p><br><ul><li>  <code>@EnableAutoConfiguration</code> annotation </li><li>  Works <em>last</em> , after registering custom beans </li><li>  Make configuration decisions based on the classes available in the classpath, properties in the <code>application.properties</code> and so on. </li><li>  You can turn on and off various aspects of auto-configuration, and apply it in part (for example, only MySQL + JPA, but not the web) </li><li>  Always gives priority to user bins.  If your code has already registered a <code>DataSource</code> bin, the autoconfiguration will not overlap it </li></ul><br><h2 id="usloviya-i-poryadok-registracii-binov">  Conditions and procedure for registering bins </h2><br><p>  The logic for registering beans is controlled by a set of <code>@ConditionalOn*</code> annotations.  You can specify that a bean is created if there is a class in the classpath ( <code>@ConditionalOnClass</code> ), an existing bin ( <code>@ConditionalOnBean</code> ), no bin ( <code>@ConditionalOnMissingBean</code> ), etc. </p><br><p>  <strong>Spring Boot</strong> makes extensive use of these annotations in order to remain as inconspicuous as possible and not override user configurations. </p><br><h1 id="pogruzhenie-v-hello-world">  Hello World Immersion </h1><br><p>  Now, having in stock the basic theoretical knowledge, let's look at what happens when you start the application. </p><br><p>  So, our application includes such code: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(DemoApplication.class, args); } }</code> </pre> <br><p>  Let's look at what happens here in steps. </p><br><h2 id="klass-demoapplication">  <code>DemoApplication</code> class </h2><br><p>  This class is marked with the <code>@SpringBootApplication</code> annotation, which is a <strong>meta annotation</strong> , i.e.  in fact, it is an alias for several annotations: </p><br><ul><li> <code>@SpringBootConfiguration</code> </li> <li> <code>@EnableAutoConfiguration</code> </li> <li>  <code>@ComponentScan</code> . </li></ul><br><p>  Those.  the presence of <code>@SpringBootApplication</code> includes scanning components, autoconfiguration, and shows various Spring components (for example, integration tests) that this is a <strong>Spring Boot</strong> application </p><br><h2 id="springapplicationrun">  SpringApplication.run () </h2><br><p>  This is just a helper that does a couple of things ‚Äî using the list of provided configurations (and the <code>DemoApplication</code> class itself is a configuration, see above) creates an <code>ApplicationContext</code> , configures it, displays a banner in the console, and notes the start time of the application, etc.  It can be replaced with manual creation of the context: <code>new AnnotationConfigApplicationContext(DemoApplication.class)</code> .  As the name implies, this is an application context that is configured using annotations.  However, this context does not know anything about the embedded servlet container, and it definitely does not know how to launch itself.  His successor, already from <strong>Spring Boot</strong> - <code>AnnotationConfigEmbeddedWebApplicationContext</code> is fully capable of doing this, and if we write in the <code>main</code> method simply </p><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnnotationConfigEmbeddedWebApplicationContext(DemoApplication.class); } }</code> </pre> <br><p>  Then we get exactly the same running application, because  The <code>AnnotationConfigEmbeddedWebApplicationContext</code> class will find an <code>EmbeddedServletContainerFactory</code> bin in the context and create and run the embedded container through it.  Please note that all this works within the framework of a common DI container, that is, you can implement this class yourself. </p><br><h2 id="enableautoconfiguration">  @EnableAutoConfiguration </h2><br><p>  This annotation includes autoconfiguration.  And here, perhaps, the key moment in dispelling Spring magic.  Here is how this annotation is declared: </p><br><pre> <code class="java hljs">... <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>(EnableAutoConfigurationImportSelector.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EnableAutoConfiguration { ... }</code> </pre> <br><p>  Those.  This is the most common configuration <em>import</em> , which we talked about above.  The class <code>EnableAutoConfigurationImportSelector</code> (and its successor in Spring Boot 1.5+ - <code>AutoConfigurationImportSelector</code> ) is just a configuration that adds several beans to the context.  However, this class has one subtlety - it does not declare the bins itself, but uses the so-called <em>factories</em> . </p><br><p>  The class <code>EnableAutoConfigurationImportSelector</code> looks into the <code>spring.factories</code> file and loads from there a list of values ‚Äã‚Äãthat are the <em>names of the (auto) configuration classes that Spring Boot imports</em> . </p><br><p>  A piece of the <code>spring.factories</code> file (it is in the <code>META-INF</code> folder inside <code>spring-boot-autoconfigure.&lt;version&gt;.jar</code> ), which we now need is this: </p><br><pre> <code class="hljs tex">org.springframework.boot.autoconfigure.EnableAutoConfiguration=<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>... (100 lines) org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</code> </pre> <br><p>  Those.  The <code>@EnableAutoConfiguration</code> annotation simply imports all of the listed configurations to provide the required beans to the application context. </p><br><p>  In fact, it can be replaced with manual import of the desired configurations: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Import</span></span>({ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration.class, org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.class, ...}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoApplication</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  However, the peculiarity is that Spring Boot tries to apply <strong>all</strong> configurations (there are about a hundred of them).  I think the attentive reader already has a couple of questions that should be clarified. </p><br><ul><li><p>  "But this is slow!"  Both yes and no - there are no exact numbers at hand, but the autoconfiguration process itself is very fast (on the order of hundreds of milliseconds on an abstract machine in a vacuum) </p><br></li><li>  "But this is unnecessary, why should I configure Rabbit ( <code>RabbitAutoConfiguration</code> ) if I do not use it?".  The presence of autoconfiguration does not mean that a bin will be created.  Autoconfigurational classes actively use <code>@ConditionalOnClass</code> annotations, and in most cases the configuration will not do anything and will not create (see "Conditions and procedure for registering bins" above). </li></ul><br><h2 id="kratkoe-rezyume">  Brief summary </h2><br><p>  At the heart of the ‚Äúmagic‚Äù of Spring Boot there is nothing magical, it uses completely basic concepts from the Spring Framework.  In short, the process can be described as: </p><br><ol><li>  Annotation <code>@SpringBootApplication</code> includes scanning components and auto-configuration via the <code>@EnableAutoConfiguration</code> annotation </li><li>  <code>@EnableAutoConfiguration</code> imports the class <code>EnableAutoConfigurationImportSelector</code> </li><li>  <code>EnableAutoConfigurationImportSelector</code> loads the configuration list from the <code>META-INF/spring.factories</code> </li><li>  Each configuration tries to configure various aspects of the application (web, JPA, AMQP etc), registering the required bins and using different conditions (presence / absence of the bin, settings, class, etc.) </li><li>  The resulting <code>AnnotationConfigEmbeddedWebApplicationContext</code> searches in the same DI container for the factory to run the embedded servlet container </li><li>  Servlet container starts, the application is ready to go! </li></ol><br><p>  It may look difficult, but for the most part, application developers do not need to get into the interior of an autoconfiguration unless it is about supporting auto-configuration for their library. </p><br><h1 id="diagnostika">  Diagnostics </h1><br><h2 id="auto-configuration-report">  Auto-configuration report </h2><br><p>  In the case where something goes wrong, Spring Boot allows you to run the autoconfiguration diagnostics and see which bins were created.  To see this information, you need to run the application with the key - <code>--debug</code> . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">java</span></span> -jar my-app.jar --<span class="hljs-literal"><span class="hljs-literal">debug</span></span></code> </pre> <br><p>  In response, Spring will issue a detailed <em>Auto-configuration report</em> : </p><br><pre> <code class="hljs scala">========================= <span class="hljs-type"><span class="hljs-type">AUTO</span></span>-<span class="hljs-type"><span class="hljs-type">CONFIGURATION</span></span> <span class="hljs-type"><span class="hljs-type">REPORT</span></span> ========================= <span class="hljs-type"><span class="hljs-type">Positive</span></span> matches: ----------------- <span class="hljs-type"><span class="hljs-type">DataSourceAutoConfiguration</span></span> matched: - <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> found required classes <span class="hljs-symbol"><span class="hljs-symbol">'javax</span></span>.sql.<span class="hljs-type"><span class="hljs-type">DataSource</span></span>', <span class="hljs-symbol"><span class="hljs-symbol">'org</span></span>.springframework.jdbc.datasource.embedded.<span class="hljs-type"><span class="hljs-type">EmbeddedDatabaseType</span></span>'; <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingClass</span></span> did not find unwanted <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">OnClassCondition</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSourceAutoConfiguration#dataSourceInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matched</span></span></span></span>: - <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> (types: org.springframework.boot.autoconfigure.jdbc.<span class="hljs-type"><span class="hljs-type">DataSourceInitializer</span></span>; <span class="hljs-type"><span class="hljs-type">SearchStrategy</span></span>: all) did not find any beans (<span class="hljs-type"><span class="hljs-type">OnBeanCondition</span></span>) ... <span class="hljs-type"><span class="hljs-type">Negative</span></span> matches: ----------------- <span class="hljs-type"><span class="hljs-type">ActiveMQAutoConfiguration</span></span>: <span class="hljs-type"><span class="hljs-type">Did</span></span> not <span class="hljs-keyword"><span class="hljs-keyword">match</span></span>: - <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> did not find required classes <span class="hljs-symbol"><span class="hljs-symbol">'javax</span></span>.jms.<span class="hljs-type"><span class="hljs-type">ConnectionFactory</span></span>', <span class="hljs-symbol"><span class="hljs-symbol">'org</span></span>.apache.activemq.<span class="hljs-type"><span class="hljs-type">ActiveMQConnectionFactory</span></span>' (<span class="hljs-type"><span class="hljs-type">OnClassCondition</span></span>) ...</code> </pre> <br><p>  The line in Positive / Negative matches will be <em>for each autoconfiguration applied</em> , moreover, Boot will tell you why a particular bin has been created (that is, it will indicate which of the registration conditions have been met). </p><br><h2 id="actuator">  Actuator </h2><br><p>  Spring Boot Actuator is a powerful diagnostic tool for a running application that can provide a lot of useful analytics (moreover, a set of these metrics can be easily expanded from within the application). </p><br><p>  After adding Actuator to the project, <strong>Spring Boot</strong> publishes a list of available bins via the URL <code>http://localhost:8080/beans</code> .  This list is also available via JMX (Java Management Extensions), and the latest version of Intellij IDEA can display all application beans directly from the launch window. </p><br><h1 id="rezyume-1">  Summary </h1><br><p>  Spring still remains large and not the easiest framework, but this is the price of high-level abstractions that it provides.  And although it‚Äôs not necessary to know all the subtleties of the framework‚Äôs work in daily development, knowing how it works from the inside is still useful.  I hope that this article helped to understand the importance and value of Spring precisely as an ecosystem and removed a bit of "magic" in what is happening, especially when using Spring Boot.  My advice - do not be afraid to go deeper into the framework of the framework, read the source code and documentation, since they are almost reference in Spring ‚Äî in my opinion. </p><br><p>  It is also worth noting that in <strong>Spring 5</strong> , which is being prepared for release in September, there will be several new concepts aimed at creating simple applications and lowering the level of "magic" (although, as we found out, there is not much magic there).  One of the concepts is <strong>Functional Bean Registration</strong> , which allows you to register bins in context using functions, or even using quite good DSL on Kotlin (and Spring 5 will add a lot of good to support Kotlin).  The next, but even more important thing, is the combination of the <strong>Functional Web Framework</strong> and the <strong>WebFlux (reactive web framework)</strong> , which allows you to create web applications at all without dependencies on Spring MVC and run them without servlet containers.  An application can work without context of applications and DI, and is described simply as a set of <code>request -&gt; response</code> functions.  About this you can read a little more <a href="http://blog.alexnesterov.com/post/spring-your-next-microframework/">here</a> (in English). </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334448/">https://habr.com/ru/post/334448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334436/index.html">The digest of interesting materials for the mobile # 214 developer (July 24 - 30)</a></li>
<li><a href="../334440/index.html">GlusterFS snapshots</a></li>
<li><a href="../334442/index.html">Interviews, labor market and other in the city of Moscow arr. summer 7525</a></li>
<li><a href="../334444/index.html">PostgreSQL Evangelist Memo: Expropriate Expropriators</a></li>
<li><a href="../334446/index.html">Gentlemen's Doctrine 2 for Symfony 3.3.6: Creating Entities, Associations, and Recursive Links</a></li>
<li><a href="../334450/index.html">Camp game "Mafia" for 50+ people</a></li>
<li><a href="../334458/index.html">Team web studio: growth system, certification and motivation</a></li>
<li><a href="../334460/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ273 (July 24 - 30, 2017)</a></li>
<li><a href="../334462/index.html">PHP Digest number 113 - the latest news, materials and tools (July 16 - 30, 2017)</a></li>
<li><a href="../334466/index.html">How to start the implementation of ERP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>