<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some ideas of writing an artificial intellect for chess</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, there are no better algorithms for chess than the search for so many positions. True, the brute force order (and not one) is optimized,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some ideas of writing an artificial intellect for chess</h1><div class="post__text post__text-html js-mediator-article">  Unfortunately, there are no better algorithms for chess than the search for so many positions.  True, the brute force order (and not one) is optimized, but still it is a big brute force.  To search for a reciprocal move, a tree is built with the initial move at the root, the edges are constructed with moves-answers and nodes - with new positions. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e09/2f4/9c6/e092f49c6a1b8dac2b245450f979a891.png" alt="image"><br><br>  As in the elementary algorithms, the next move is chosen to be explained simply.  On your turn, you choose such a move (in your opinion) that will bring the greatest benefit (maximizes your benefit), and the opponent in her next move tries to choose the move that will bring him the most benefit (maximizes his benefit and minimizes yours).  An algorithm with this principle is called minimax.  At each stage, you assign each position in the tree an assessment of the position (more on this later) and maximize it during your move, and minimize it during the opponent‚Äôs move.  The algorithm during operation must go through all the nodes of the tree (that is, all possible gaming positions in the game), that is, it is completely unsuitable in time. <br>  His next improvement is alpha-beta pruning (branch and bound method). <br><a name="habracut"></a><br>  From the name it follows that the algorithm is cut off by some two parameters - alpha and beta.  The main idea of ‚Äã‚Äãthe cut-off is that now we will keep the cut-off interval (lower and upper bounds - alpha and beta, respectively - your KO) and estimates of all nodes that do not fall into the interval from below, we will not consider (since they are not affect the result - it's just the worst moves than the one already found), and the interval itself will be narrowed as the best moves are found.  Although the alpha-beta cut-off is much better than the minix, yet its running time is also very large.  If we assume that there are approximately 40 different moves in the middle of a game, then the algorithm time can be estimated as O (40 ^ P), where P is the depth of the move tree.  Of course, with a minimax there can be such a sequence of consideration of moves, when we will not do any clippings, then the alpha-beta pruning will simply turn into a minimax.  At best, using the alpha-beta cut-off, you can avoid checking the root from among all the moves in the minimax.  In order to avoid a long time of work (with such an O-great complexity of the algorithm), a search in the tree is done for some fixed value and a node is evaluated there.  This assessment is a very great approximation to the actual assessment of the node (that is, going through the end of the tree, and there the result is ‚Äúwon, lost, draw‚Äù).  As for the evaluation of a node, there is just a pile of various methods (you can read in the links at the end of the article).  In short, naturally, I count the player‚Äôs material (according to one system - whole numbers, pawn - 100, knight and bishop - 300, rook - 500, queen - 900; according to another system - valid in parts from one) + position on the board player  As for the position, here one of the nightmares of writing chess begins, since the speed of the program will mainly depend on the evaluation function and, more precisely, on the assessment of the position.  There is already someone in that much.  For a paired tour to player +, for covering the king with his pawns +, for a pawn near the other end of the board +, etc., and hanging position, the open king, etc., minus the position.  etc.  - Factors can write a bunch.  Here, to assess the position in the game, an assessment of the position of the player is made, which makes a move, and the assessment of the corresponding position of the opponent is subtracted from it.  As they say, one photo is sometimes better than a thousand words, and maybe a piece of code in pseudo C # will also be better than an explanation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurentPlayer {Me, Opponent}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaBetaPruning</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, CurrentPlayer currentPlayer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// value of current node int value; // count current node ++nodesSearched; // get opposite to currentPlayer CurrentPlayer opponentPlayer = GetOppositePlayerTo(currentPlayer); // generates all moves for player, which turn is to make move / /moves, generated by this method, are free of moves // after making which current player would be in check List&lt;Move&gt; moves = GenerateAllMovesForPlayer(currentPlayer); // loop through the moves foreach move in moves { MakeMove(move); ++ply; // If depth is still, continue to search deeper if (depth &gt; 1) value = -AlphaBetaPruning (-beta, -alpha, depth - 1, opponentPlayer); else // If no depth left (leaf node), evalute that position value = EvaluatePlayerPosition(currentPlayer) - EvaluatePlayerPosition(opponentPlayer); RollBackLastMove(); --ply; if (value &gt; alpha) { // This move is so good that caused a cutoff of rest tree if (value &gt;= beta) return beta; alpha = value; } } if (moves.Count == 0) { // if no moves, than position is checkmate or if (IsInCheck(currentPlayer)) return (-MateValue + ply); else return 0; } return alpha; }</span></span></code> </pre> <br><br>  I think some explanations about the code will not be superfluous: <br><ul><li>  GetOppositePlayerTo () simply changes CurrentPlayer.Me to CurrentPlayer.Opponent and vice versa </li><li>  MakeMove () makes the next move from the list of moves. </li><li>  ply - a global variable (part of the class), which keeps in itself the number of half-moves made at a given depth </li></ul><br>  An example of using the method: <br><br><pre> <code class="cs hljs">{ ply = <span class="hljs-number"><span class="hljs-number">0</span></span>; nodesSearched = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> score = AlphaBetaPruning (-MateValue, MateValue, max_depth, CurrentPlayer.Me); }</code> </pre><br>  where MateValue is quite a large number. <br>  The max_depth parameter is the maximum depth to which the algorithm will go down in the tree.  It should be borne in mind that pseudocode is purely demonstrative, but quite working. <br><br>  Instead of coming up with a new algorithm, people promoting alpha-beta clipping came up with many different heuristics.  A heuristic is just a small hack that sometimes makes a very big speed gain.  There is a lot of heuristics for chess, you can‚Äôt count them all.  I will give only the main ones, the rest can be found in the links at the end of the article. <br><br>  First, a very well-known <b>‚Äúzero move‚Äù</b> heuristic is applied.  In a quiet position, the opponent is given two turns instead of one, and after that they look at the tree to a depth (depth-2), and not (depth-1).  If, after evaluating such a subtree, it turns out that the current player still has an advantage, then it makes no sense to consider the subtree further, since after his next move the player will only make his position better.  Since brute force polynomial, the gain in speed is palpable.  Sometimes it happens that the enemy aligns his advantage, then we must consider the entire subtree to the end.  It‚Äôs not necessary to make an empty move (for example, when one of the kings is under a check, in zugzwang or endgame). <br><br>  Further, the idea is used first to make a move in which there will be a capture of the opponent‚Äôs piece that made the last move.  Since almost all the moves during the brute force search are not very reasonable, such an idea would greatly narrow the search box at the beginning, thereby cutting off many unnecessary moves. <br><br>  Also known is the <b>heuristics of history</b> or the <b>service of the best moves</b> .  During the search, the best moves at this level of the tree are preserved, and when considering a position, you can first try to make such a move for a given depth (based on the idea that at equal depths in the tree very often the same best moves are made). <br>  It is known that this kind of caching of moves improved the performance of the Soviet program Kaiss by 10 times. <br><br>  There are also some ideas about generating moves.  First consider winning takes, that is, such a take, when a figure with a lower score beats a figure with a higher score.  Then promotions are considered (when the pawn on the other end of the board can be replaced with a stronger piece), then equal takes and then moves from the history heuristics cache.  The remaining moves can be sorted for control of the board or some other criterion. <br><br>  Everything would be fine if alpha-beta pruning guaranteed would give the best answer.  Even considering a long time to bust.  But it was not there.  The problem is that after a search for a fixed value, the position is assessed and that‚Äôs it, and as it turned out, in some game positions the search cannot be stopped.  After many attempts, it turned out that the search can only be stopped in calm positions.  Therefore, in the main search, an additional search was added, in which only captures, promotions and shahs (called <b>forced search</b> ) are considered.  We also noticed that some positions with exchanges in the middle should also be considered deeper.  So there were ideas about <b>extensions</b> and <b>reductions</b> , that is, recesses and shortenings of the search tree.  For ditches, the most suitable positions are the type of endgame with pawns, departure from the shah, exchange of a piece in the middle of a brute force, etc.  ‚ÄúAbsolutely calm‚Äù positions are suitable for shortening.  In the Soviet program of Kaiss, the forced search was a bit special ‚Äî there, immediately after taking, during the search, the forced search began and its depth was not limited (since after a while it would exhaust itself in a calm position). <br><br>  In the words of <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25BE%25D0%25B0%25D1%2580,_%25D0%25A7%25D0%25B0%25D1%2580%25D0%25BB%25D1%258C%25D0%25B7_%25D0%25AD%25D0%25BD%25D1%2582%25D0%25BE%25D0%25BD%25D0%25B8_%25D0%25A0%25D0%25B8%25D1%2587%25D0%25B0%25D1%2580%25D0%25B4">Anthony Hoar</a> : " <i>Premature of evil in programming.</i> " (Note: for those who believe that this quote belongs to Knut, there are interesting discussions <a href="http://alenacpp.blogspot.com/2006/08/blog-post.html">here</a> and <a href="http://sergeyteplyakov.blogspot.com/2009/12/blog-post_08.html">here</a> ).  In chess, where there will be a relatively large depth of recursion, it is necessary to think about optimizations, but very carefully. <br>  There are some general ideas here too: <br><ul><li>  <i>debut library</i> (debut theory in chess is very advanced - <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25BE%25D0%25BF%25D0%25B5%25D0%25B4%25D0%25B8%25D1%258F_%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B4%25D0%25B5%25D0%25B1%25D1%258E%25D1%2582%25D0%25BE%25D0%25B2">Wiki</a> + <a href="http://www.maskeret.com/mecca/openings.htm">Database</a> ) </li><li>  <i>endgame library</i> (likewise there are many <i>endgame</i> databases) </li><li>  <i>iterative deepening + caching</i> : the idea is to do a search first to a depth of 1, then 2, 3, and so on.  At the same time maintain this position, its best course, depth, or something else in some kind of hash table.  The whole essence of iterative grooves is that the result of unfinished iteration cannot be used (then it is better to do an incomplete exhaustion to a shallower depth) and when iterating to a greater depth, you can use the results of a exhaustive search to a shallower depth.  It even turns out that brute force to a depth of 1 to 6 is performed faster than brute force immediately to a depth of 6. </li></ul><br><br>  The article used information from some resources: <br><ul><li>  <a href="http://www.top-5000.nl/authors/rebel/chess840.htm">Rebel - Programmer Stuff</a> - an article about the Rebel program (very valuable ideas and solutions) </li><li>  <a href="http://immortal223.borda.ru/%3F1-3-0-00000035-000-0-0-1228602022">Chess Tree Search</a> - General Chess Programming Ideas </li><li>  <a href="http://forum.ixbt.com/topic.cgi%3Fid%3D40:1864">Forum about the search for an algorithm for chess by one person</a> </li><li>  <a href="http://aigroup.narod.ru/texts.htm">Site of the working group on artificial intelligence</a> </li><li>  <a href="http://habrahabr.ru/blogs/artificial_intelligence/51076/">How computers play chess</a> - an article in Habr√© </li><li>  <a href="http://chess.verhelst.org/1997/03/09/sources/">Chess Program Sources</a> - available sources of many chess programs </li></ul><br><br>  PS The whole theory was used by me in practice and for some time there was a simple PHP rest-web service for online chess + C # program (used .NET Remoting for a network game), but now the site is not working and when I have time I want to transfer to RubyOnRails. <br><br>  PPS Who <a href="http://code.google.com/p/queem/">cares</a> - the project now lives on <a href="http://code.google.com/p/queem/">Google code</a> and upgrade when I have time.  Who wants the code of the previous version - I can send. </div><p>Source: <a href="https://habr.com/ru/post/111210/">https://habr.com/ru/post/111210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111203/index.html">MODx - Accounting visitors and schedule visits</a></li>
<li><a href="../111204/index.html">Using HDAPS in ThinkPad Linux Laptops when needed</a></li>
<li><a href="../111205/index.html">Drupal module for working with Yandex.Mail</a></li>
<li><a href="../111207/index.html">Track Changes in SQL Server 2008</a></li>
<li><a href="../111208/index.html">Review of an inexpensive dual-core netbook, Packard Bell DOT SE W-301RU</a></li>
<li><a href="../111211/index.html">Drupal 7 released</a></li>
<li><a href="../111213/index.html">Vulnerability in php 5.3. * 32bit - float</a></li>
<li><a href="../111214/index.html">Software visualization of the local network</a></li>
<li><a href="../111215/index.html">The option of remote access to the corporate network of the enterprise through a VPN with access control to internal resources and authentication in AD</a></li>
<li><a href="../111217/index.html">We collected virtualka with phpdaemon'n on Ubuntu 10.10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>