<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing graphs and trees in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to publish the most interesting chapters from the book Magnus Lie Hetland ‚ÄúPython Algorithms‚Äù. The previous article is located at habrahab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing graphs and trees in Python</h1><div class="post__text post__text-html js-mediator-article">  We continue to publish the most interesting chapters from the book Magnus Lie Hetland ‚ÄúPython Algorithms‚Äù.  The previous article is located at <a href="http://habrahabr.ru/blogs/algorithm/111858/">habrahabr.ru/blogs/algorithm/111858</a> .  Today we will discuss the effective work with graphs and trees and the features of their implementation in Python.  The basic terminology of graph theory has already been discussed (for example, here: <a href="http://habrahabr.ru/blogs/algorithm/65367/">habrahabr.ru/blogs/algorithm/65367</a> ), so I did not include part of the chapter on terms in this article. <br><br><h4>  Implementing graphs and trees </h4><br>  Many tasks, for example, the problem of traversing points along the shortest route, can be solved with the help of one of the most powerful tools - with the help of <em>graphs</em> .  Often, if you can determine that you are solving a graph problem, you are at least halfway to a solution.  And if your data can somehow be presented as <em>trees</em> , you have every chance to build a truly <em>effective</em> solution. <a name="habracut"></a><br>  Any structure or system can be represented as graphs, from the transport network to the data transmission network and from the interaction of proteins in the cell nucleus to connections between people on the Internet. <br><br>  Your graphs can become even more useful if you add additional data such as <em>weights</em> or <em>distances</em> , which will give an opportunity to describe such various problems as playing chess or determining suitable work for a person according to his abilities. <br>  Trees are just a special kind of graph, so most of the algorithms and graph representations will work for them. <br>  However, due to their special properties (connectedness and absence of cycles), special (and very simple) versions of algorithms and representations can be applied. <br>  In practice, in some cases there are structures (such as XML documents or a directory hierarchy) that can be represented as trees (taking into account the IDREF attributes and symbolic links, XML documents and the directory hierarchy become graphs themselves).  In fact, these "some" cases are quite common. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The description of the problem in terms of graphs is rather abstract, so if you need to implement a solution, you must provide the graphs in the form of some data structures.  (This will have to be done even when designing the algorithm, and only because you need to know how long various operations will be performed on the graph representation).  In some cases, the graph will already be compiled in code or data, so a separate structure is not required.  For example, if you write a web crawler that collects information about sites by links, the network itself will be the graph.  If you have the <em>Person</em> class with the <em>friends</em> attribute, which is a list of other objects of type <em>Person</em> , then your object model will already be a graph on which you can use various algorithms.  However, there are special ways to represent graphs. <br><br>  In general terms, we are looking for a way to implement the adjacency function, <em>N (v)</em> , so that <em>N [v] is</em> some set (or in some cases just an iterator) adjacent to <em>v</em> vertices.  As in many other books, we will focus on the two most well-known concepts: <em>adjacency lists</em> and <em>adjacency matrices</em> , because they are most useful and generalized.  Alternative views are described in the last section below. <br><br><h6>  "Black Box": dictionaries and sets </h6><pre><code class="tex hljs"> ,       ,      Python,  ‚Äî &lt;em&gt;&lt;/em&gt;.      (   ),    .      , ,     (  ,      ).     Python   hash: &gt;&gt;&gt; hash(42) 42 &gt;&gt;&gt; hash("Hello, world!") -1886531940     ,     -.     .    ,           (    -,       ).     ,           Œò(1). (     Œò(n),            -.    ,     ).    ,      dict  set    ,                .</code> </pre> <br><br><h4>  Connectivity lists and the like </h4><br>  One of the most obvious ways of representing graphs is adjacency lists.  Their meaning is that for each vertex there is a list (or a set, or another container or an iterator) of adjacent vertices.  Let us analyze the simplest way to implement such a list, assuming that there are <em>n</em> vertices numbered <em>0 ... n-1</em> . <br><br><pre> <code class="tex hljs"> ,            .       0‚Ä¶ n-1     ,           .</code> </pre><br><br>  Thus, each adjacency list is a list of such numbers, and these lists themselves are assembled into a main list of size <em>n</em> , indexed by vertex numbers.  Typically, the sorting of such lists is random, so it really is about using lists to implement adjacency <em>sets</em> .  The term <em>list is</em> just historically settled.  Python, fortunately, has a separate type for sets, which in many cases is convenient to use. <br><br>  The approximate graph for which different representations will be shown is shown in fig.  1. To begin with, we assume that all vertices are numbered ( <em>a = 0, b = 1, ...</em> ).  With this in mind, the graph can be presented in an obvious way, as shown in the following listing.  To make it more convenient, I assigned the numbers of the vertices to variables named according to the vertex marks in the figure.  But you can work directly with numbers.  Which vertex which list belongs to is indicated in the comments.  If you want, take a few minutes to make sure that the presentation matches the picture. <br><br><pre> <code class="python hljs">a, b, c, d, e, f, g, h = range(<span class="hljs-number"><span class="hljs-number">8</span></span>) N = [ {b, c, d, e, f}, <span class="hljs-comment"><span class="hljs-comment"># a {c, e}, # b {d}, # c {e}, # d {f}, # e {c, g, h}, # f {f, h}, # g {f, g} # h ]</span></span></code> </pre><br><br><pre> <code class="tex hljs">  Python  2.7 ( 3.0)     set([1, 2, 3])  {1, 2, 3}.       -   set(),   {}   .</code> </pre><br><br><img src="https://habrastorage.org/storage/107409b2/1e276dc0/8816a7ae/7599c3ea.png"><br>  Fig.  1. Approximate graph for the demonstration of different types of presentation <br><br>  The name <em>N</em> from the listing is associated with the function <em>N</em> described above.  In graph theory, <em>N (v)</em> represents a set of vertices adjacent to <em>v</em> .  Similarly, in our code, <em>N [v]</em> is a set of vertices adjacent to <em>v</em> .  Assuming that <em>N is</em> defined as in the example above, you can study this presentation in interactive Python mode: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> N[a] <span class="hljs-comment"><span class="hljs-comment"># ? True &gt;&gt;&gt; len(N[f]) #  3</span></span></code> </pre><br><br><pre> <code class="tex hljs">:        , ,     ,         ,    ,    python   -i,  : python -i listing_2_1.py          ,      ,     ,       .</code> </pre><br><br>  Another possible representation, which in some cases gives less overhead, is the adjacency <em>list itself</em> .  An example of such a list is shown in the listing below.  All the same operations are available, but the vertex adjacency check is performed with <em>Œò (n)</em> .  This gives a serious reduction in speed, but if you really need this presentation, then this is his only problem.  (If all that your algorithm does is to traverse neighboring vertices, then using objects of the set type is not just pointless: overhead can worsen the constant factors in the asymptotics of your implementation). <br><br><pre> <code class="python hljs">a, b, c, d, e, f, g, h = range(<span class="hljs-number"><span class="hljs-number">8</span></span>) N = [ [b, c, d, e, f], <span class="hljs-comment"><span class="hljs-comment"># a [c, e], # b [d], # c [e], # d [f], # e [c, g, h], # f [f, h], # g [f, g] # h ]</span></span></code> </pre><br><br>  It can be argued that this view is in fact a collection of <em>adjacency arrays</em> , not classical adjacency <em>lists</em> , since  type list in Python is actually a dynamic array.  If you want, you can implement the type of the linked list and use it instead of the type <em>list</em> from Python.  This can be done cheaper in terms of performance by arbitrary insertions into the list, but you probably will not need such an operation, because you can just as well add new vertices to the end of the list.  The advantage of using the built-in <em>list</em> is that it is a very fast and well-established structure (unlike any list structures that can be implemented in pure Python). <br><br>  When working with graphs, the idea constantly emerges that the best presentation depends on what exactly needs to be done with the graph.  For example, using lists (or arrays) adjacencies can keep the overheads small and provide an efficient <em>N (v)</em> traversal for any vertex <em>v</em> .  However, checking whether <em>u</em> and <em>v are</em> contiguous will take time <em>Œò (N (v))</em> , which can be a problem if the graph is dense (i.e., with a large number of edges).  In these cases, come to the aid of many adjacency. <br><br>  Tip: <br>  It is known that removing objects from the middle of the list in Python is quite expensive.  Deletion from the end in this case takes place in constant time.  If you do not care about the order of the vertices, you can delete a random vertex for a constant time by overwriting it with the one at the end of the adjacency list, and then calling the pop method. <br><br>  A small variation on the theme of this view can be called sorted lists of adjacent vertices.  If the lists change infrequently, they can be kept sorted and use bisection to check the vertex adjacency, which will lead to a slightly lower overhead (in terms of memory usage and iteration time), but will increase the complexity of the check to <em>(log <sub>2</sub> k)</em> , where <em>k</em> is the number adjacent to this vertex.  (This is still a very small value. In practice, however, the use of the built-in type <em>set</em> delivers much less trouble). <br><br>  <em>Another</em> minor improvement is the use of dictionaries instead of sets or lists.  Adjacent vertices can be dictionary keys, and you can use any additional data as a value, for example, the edge weight.  How this looks can be seen in the listing below (weights are chosen randomly). <br><br><pre> <code class="python hljs">a, b, c, d, e, f, g, h = range(<span class="hljs-number"><span class="hljs-number">8</span></span>) N = [ {b:<span class="hljs-number"><span class="hljs-number">2</span></span>, c:<span class="hljs-number"><span class="hljs-number">1</span></span>, d:<span class="hljs-number"><span class="hljs-number">3</span></span>, e:<span class="hljs-number"><span class="hljs-number">9</span></span>, f:<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-comment"><span class="hljs-comment"># a {c:4, e:3}, # b {d:8}, # c {e:7}, # d {f:5}, # e {c:2, g:2, h:2}, # f {f:1, h:6}, # g {f:9, g:8} # h ]</span></span></code> </pre><br><br>  The adjacency dictionary can be used in the same way as other views, taking into account additional information about weights: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> N[a] <span class="hljs-comment"><span class="hljs-comment">#  True &gt;&gt;&gt; len(N[f]) #  3 &gt;&gt;&gt; N[a][b] #  (a, b) 2</span></span></code> </pre><br><br>  If you want, you can use adjacency dictionaries even if you <em>don't have</em> useful data like edge weights (using <em>None</em> or some other value instead of data).  This will give you all the advantages of adjacency sets, but it will work with (very, very) old versions of Python that do not have support for the type <em>set</em> (sets were introduced in Python 2.3 as a <em>sets</em> module. The built-in type <em>set</em> is available from Python 2.4). <br><br>  Up to this point, the entity storing the adjacency structures ‚Äî lists, sets, or dictionaries ‚Äî was a list indexed by vertex numbers.  A more flexible option (allowing the use of arbitrary, hashable, vertex names) is built on the basis of the dictionary as the main structure (such dictionaries with adjacency lists Guido van Rossum used in his article ‚ÄúPython Patterns - Implementing Graphs‚Äù posted at <a href="http://www.python.org/doc/essays/graphs.html">www.python.org /doc/essays/graphs.html</a> ).  The listing below shows an example of a dictionary containing adjacency sets.  Notice that the vertices in it are indicated by symbols. <br><br><pre> <code class="python hljs">N = { <span class="hljs-string"><span class="hljs-string">'a'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'bcdef'</span></span>), <span class="hljs-string"><span class="hljs-string">'b'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'ce'</span></span>), <span class="hljs-string"><span class="hljs-string">'c'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'d'</span></span>), <span class="hljs-string"><span class="hljs-string">'d'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'e'</span></span>), <span class="hljs-string"><span class="hljs-string">'e'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'f'</span></span>), <span class="hljs-string"><span class="hljs-string">'f'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'cgh'</span></span>), <span class="hljs-string"><span class="hljs-string">'g'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'fh'</span></span>), <span class="hljs-string"><span class="hljs-string">'h'</span></span>: set(<span class="hljs-string"><span class="hljs-string">'fg'</span></span>) }</code> </pre><br><br>  If we omit the set constructor from the listing above, then the adjacency lines will remain, which will work as adjacency lists (immutable) of characters (with slightly less overhead).  It would seem that this is not a better idea, but, as mentioned above, it all depends on your program.  Where do you get the data for the graph?  (Maybe they are already in text form?) How are you going to use them? <br><br><h4>  Adjacency matrices </h4><br>  Another common form of graph representation is adjacency matrices.  Their main difference is the following: instead of listing all adjacent vertices, we write one series of values ‚Äã‚Äã(an array), each of which corresponds to a possible adjacent vertex (there is at least one such for each vertex of the graph), and save the value (in the form of <em>True</em> or <em>False</em> ), indicating whether or not the vertex is adjacent.  Again, the simplest implementation can be obtained using nested lists, as can be seen from the listing below.  Note that this also requires the vertices to be numbered from <em>0</em> to <em>V-1</em> .  Truth values ‚Äã‚Äãare 1 and 0 (instead of <em>True</em> and <em>False</em> ) to make the matrix readable. <br><pre> <code class="python hljs">a, b, c, d, e, f, g, h = range(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment"># abcdefgh N = [[0,1,1,1,1,1,0,0], # a [0,0,1,0,1,0,0,0], # b [0,0,0,1,0,0,0,0], # c [0,0,0,0,1,0,0,0], # d [0,0,0,0,0,1,0,0], # e [0,0,1,0,0,0,1,1], # f [0,0,0,0,0,1,0,1], # g [0,0,0,0,0,1,1,0]] # h</span></span></code> </pre><br><br>  The way to use adjacency matrices is slightly different from lists and adjacency sets.  Instead of checking whether <em>b</em> enters <em>N [a]</em> , you will check whether the value of the cell of the matrix <em>N [a] [b] is</em> true.  In addition, <em>len (N [a])</em> can no longer be used to get the number of adjacent vertices, because all rows are of the same length.  Instead, you can use the <em>sum</em> function: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>N[a][b] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; sum(N[f]) <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br>  The adjacency matrices have a number of useful properties that are worth knowing about.  First, since we do not consider graphs with loops (that is, we do not work with pseudographs), all values ‚Äã‚Äãon the diagonal are false.  Also, undirected graphs are usually described by pairs of edges in both directions.  This means that the adjacency matrix for an undirected graph will be symmetric. <br><br>  Expanding the adjacency matrix to use weights is trivial: instead of saving logical values, save weights.  In the case of the edge <em>(u, v),</em> <em>N [u] [v]</em> is the weight of the edge <em>w (u, v)</em> instead of <em>True</em> .  Often, for practical purposes, non-existent ribs are assigned infinite weights.  (This ensures that they will not be included, for example, in the shortest paths, since we are looking for a path along the existing edges).  It is not always obvious how to imagine infinity, but there are definitely several different options. <br><br>  One of them is to use a value that is incorrect for the weight, such as <em>None</em> or <em>-1</em> , if it is known that all weights are non-negative.  It may be useful in some cases to use really large numbers.  For integer weights, <em>sys.maxint</em> can be used, although this value is not necessarily the largest (long integers can be larger).  There is a value entered to reflect infinity: <em>inf</em> .  It is not available in Python directly by name and is expressed as <em>float ('inf')</em> (guaranteed to work for Python 2.6 and later. In earlier versions, these special values ‚Äã‚Äãwere platform-dependent, although <em>float ('inf')</em> or <em>float (' Inf ')</em> should work on most platforms). <br><br>  The listing below shows how the weights matrix looks like implemented by nested lists.  The same weights are used as in the listing above. <br><br><pre> <code class="python hljs">a, b, c, d, e, f, g, h = range(<span class="hljs-number"><span class="hljs-number">8</span></span>) _ = float(<span class="hljs-string"><span class="hljs-string">'inf'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># abcdefgh W = [[0,2,1,3,9,4,_,_], # a [_,0,4,_,3,_,_,_], # b [_,_,0,8,_,_,_,_], # c [_,_,_,0,7,_,_,_], # d [_,_,_,_,0,5,_,_], # e [_,_,2,_,_,0,2,2], # f [_,_,_,_,_,1,0,6], # g [_,_,_,_,_,9,8,0]] # h</span></span></code> </pre><br><br>  The infinite value is indicated by the underscore ( <em>_</em> ), because it is short and visually distinct.  Naturally, you can use any name you prefer.  Note that the values ‚Äã‚Äãon the diagonal are still zero, because even without loops, weights are often interpreted as distances, and the distance from the vertex to itself is zero. <br><br>  Of course, the weights matrixes make it very easy to get the weights of the edges, but, for example, checking the adjacency and determining the degree of a vertex, or bypassing all adjacent vertices, is done differently.  Here you need to use an infinite value, something like this (for greater clarity, we define <em>inf = float ('inf')</em> ): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>W[a][b] &lt; inf <span class="hljs-comment"><span class="hljs-comment">#  True &gt;&gt;&gt; W[c][e] &lt; inf #  False &gt;&gt;&gt; sum(1 for w in W[a] if w &lt; inf) - 1 #  5</span></span></code> </pre><br><br>  Note that <em>1</em> is subtracted from the degree obtained, because we do not count the values ‚Äã‚Äãon the diagonal.  The complexity of calculating the degree here is <em>Œò (n)</em> , while in another representation both adjacency and the degree of a vertex can be determined in constant time.  So you should always understand <em>exactly how</em> you are going to use your graph and choose the appropriate presentation for it. <br><br><h6>  NumPy special purpose arrays </h6><pre> <code class="tex hljs"> NumPy   ,    .        ,    NumPy  , ,      .           n ,  : &gt;&gt;&gt; N = [[0]*10 for i in range(10)]  NumPy    zeros: &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; N = np.zeros([10,10])     ,  : A[u,v].      ,   : A[u].  NumPy     http://numpy.scipy.org.  ,      NumPy,       Python.    NumPy     Python,   ,           .         (,     Subversion): svn co http://svn.scipy.org/svn/numpy/trunk numpy    ,     NumPy,      ,     .</code> </pre><br><br><h4>  Implementation of trees </h4><br>  Any graph representation can naturally be used to represent trees, because trees are a special kind of graph.  However, trees play a big role in algorithms, and many corresponding structures and methods have been developed for them.  Most algorithms on trees (for example, search in trees) can be viewed in terms of graph theory, but special data structures make them easier to implement. <br>  The easiest way to describe the representation of the tree with the root, in which the edges go down from the root.  Such trees often display hierarchical data branching, where the root displays all objects (which may be stored in the leaves), and each internal node shows the objects contained in the tree whose root is this node.  This description can be used by presenting each subtree with a list containing all its descendant subtrees.  Consider a simple tree shown in the figure.  2 <br>  We can present this tree as a list of lists: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>T = [[<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>], [<span class="hljs-string"><span class="hljs-string">"c"</span></span>], [<span class="hljs-string"><span class="hljs-string">"d"</span></span>, [<span class="hljs-string"><span class="hljs-string">"e"</span></span>, <span class="hljs-string"><span class="hljs-string">"f"</span></span>]]] &gt;&gt;&gt; T[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-string"><span class="hljs-string">'b'</span></span> &gt;&gt;&gt; T[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-string"><span class="hljs-string">'e'</span></span></code> </pre><br><br>  Each list is essentially a list of descendants of each of the internal nodes.  In the second example, we refer to the third descendant of the root, then its second descendant, and finally the first descendant of the previous node (this path is marked in the figure). <br><br><img src="http://habrastorage.org/storage/1818dba2/aad63c7c/9ce2d273/99669604.png"><br>  Fig.  2. An example of a tree with a marked path from root to leaf <br><br>  In some cases it is possible to pre-determine the maximum number of descendants of each node.  (For example, each node of a <em>binary tree</em> can have up to two children).  Therefore, you can use other representations, for example, objects with a separate attribute for each of the descendants as in the listing below. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, left, right)</span></span></span><span class="hljs-function">:</span></span> self.left = left self.right = right &gt;&gt;&gt; t = Tree(Tree(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>), Tree(<span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-string"><span class="hljs-string">"d"</span></span>)) &gt;&gt;&gt; t.right.left <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre><br><br>  You can use <em>None</em> to indicate missing descendants (if the node has only one descendant).  Of course, you can combine different methods (for example, using lists or sets of descendants for each node). <br><br>  A common way to implement trees, especially in languages ‚Äã‚Äãthat do not have built-in support for lists, is the so-called ‚Äúfirst descendant, next brother‚Äù representation.  In it, each node has two ‚Äúpointers‚Äù or attributes pointing to other nodes, as in a binary tree.  However, the first of these attributes refers to the first descendant of the node, and the second to its next brother (i.e., a node that has the same parent but is to the right, <i>approx. Transl</i> .).  In other words, each tree node has a pointer to a linked list of its descendants, and each of these descendants refers to its own similar list.  Thus, a small modification of the binary tree will give us the multipath tree shown in the listing below. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, kids, next=None)</span></span></span><span class="hljs-function">:</span></span> self.kids = self.val = kids self.next = next</code> </pre><br>  A separate attribute <em>val</em> is introduced here simply to get a clear conclusion when specifying a value (for example, ‚Äúc‚Äù) instead of a link to a node.  Naturally, all this can be changed.  Here is an example of how to handle this structure: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>t = Tree(Tree(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, Tree(<span class="hljs-string"><span class="hljs-string">"b"</span></span>, Tree(<span class="hljs-string"><span class="hljs-string">"c"</span></span>, Tree(<span class="hljs-string"><span class="hljs-string">"d"</span></span>))))) &gt;&gt;&gt; t.kids.next.next.val <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre><br><br>  This is how the tree looks like: <br><img src="http://habrastorage.org/storage/67b3d2ac/a60ba219/3d5ebecf/cc6045af.png"><br><br>  The attributes <em>kids</em> and <em>next</em> are shown with dashed lines, and the edges of the tree themselves are solid.  I cheated a little and did not show separate nodes for the lines ‚Äúa‚Äù, ‚Äúb‚Äù, etc.  Instead, I treat them as tags on the respective parent nodes.  In a more complex tree, instead of using a single attribute to store the value of a node and to reference a list of descendants, you might need separate attributes for both purposes.  Typically, a more complex code (including loops and recursion) is used to bypass the tree than is given here with a fixed path. <br><br><h6>  Set Design Pattern </h6><pre> <code class="tex hljs">  (  )          ,      .       ¬´¬ª (     ¬´Python Cookbook¬ª).     ,      : class Bunch(dict): def __init__(self, *args, **kwds): super(Bunch, self).__init__(*args, **kwds) self.__dict__ = self      . -,       ,       : &gt;&gt;&gt; x = Bunch(name="Jayne Cobb", position="PR") &gt;&gt;&gt; x.name 'Jayne Cobb' -,   dict    ,      ()     .  : &gt;&gt;&gt; T = Bunch &gt;&gt;&gt; t = T(left=T(left="a", right="b"), right=T(left="c")) &gt;&gt;&gt; t.left {'right': 'b', 'left': 'a'} &gt;&gt;&gt; t.left.right 'b' &gt;&gt;&gt; t['left']['right'] 'b' &gt;&gt;&gt; "left" in t.right True &gt;&gt;&gt; "right" in t.right False           .     ,    ,      .</code> </pre><br><br><h4>  Many different views </h4><br>  Despite the fact that there are many representations of graphs, most study and use only two types (with modifications) already described in this chapter.  Jeremy Spinred writes in his book ‚ÄúEffective Graph Representation‚Äù that he, as a researcher of computer representation of graphs, is ‚Äúparticularly annoyed‚Äù by most introductory articles.  The descriptions in them of well-known representations (lists and adjacency matrices) are usually adequate, but more general explanations are often erroneous.          ,        : <br> <em>¬´      :    .     ,     ,   ,         ,   ,     ¬ª (. 9).</em> <br><br>  ,       . -,  <em></em>    ,    . ,  <em> </em> ( <em> </em> ),         (  -),  <em> </em> , ,      (  ).        ,   ( )    (  ).   ,     ,    - . <br><br> -,           :  ,       ,    ,          <em></em> ,  . <br><br>  ,  ,      ,  ,      .  , ,    ,   . ,   <em>(u, v)</em>      <em>Œò(1)</em> ,     <em>v</em>  ‚Äî  <em>Œò(n)</em> ,             <em>Œò(d(v))</em> , ..        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the asymptotic complexity of your algorithm does not depend on the type of representation, you can conduct any empirical tests described earlier in this chapter. Or, as often happens, you can choose a view that fits better with your code and is easier to maintain.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important way to use graphs, which has not yet been affected, does not concern their presentation. The fact is that in many problems the data already has a graph structure, or even a tree, and we can use appropriate algorithms for them for graphs and trees without creating special representations. In some cases this happens if the graph representation is made outside of our program. For example, when parsing XML documents or traversing file system directories, a tree structure has already been created and there are certain APIs for it. In other words, we </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implicitly</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> define a graph. For example, to find the most effective solution for a given configuration of the Rubik's cube, you can determine the state of the cube and methods for changing it. But even if you do not explicitly describe and save each configuration,</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possible states</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will form an implicit graph (or a set of vertices) with edges - state change operators. Next, you can use algorithms such as A * or Dijkstra's bidirectional algorithm to find the shortest path to the solution state. In such cases, the function of obtaining neighboring vertices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N (v)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will work on the fly, probably returning adjacent vertices as a collection or other form of an iterator object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the last type of graphs, which I will touch on in this chapter, is called a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtask graph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a deep concept, to which I will repeatedly refer to, describing various techniques for constructing algorithms. In short, most tasks can be decomposed into </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtasks.</font></font></em> :  ,    .     ,    (..     )  .           (     ),       ¬´  ¬ª   . <br><br><h6>    </h6><br>    ,    ,         ,    . ,  ,       ,        .   ,             C,       .     ,         .           ,    : <br> NetworkX: <a href="http://networkx.lanl.gov/">http://networkx.lanl.gov</a> <br> python-graph: <a href="http://code.google.com/p/python-graph">http://code.google.com/p/python-graph</a> <br> Graphine: <a href="http://gitorious.org/projects/graphine/pages/Home">http://gitorious.org/projects/graphine/pages/Home</a> <br><br>  ,  Pygr,    ( <a href="http://bioinfo.mbi.ucla.edu/pygr">http://bioinfo.mbi.ucla.edu/pygr</a> ), Gato,      ( <a href="http://gato.sourceforge.net/">http://gato.sourceforge.net</a> )  PADS,     ( <a href="http://www.ics.uci.edu/~eppstein/PADS">http://www.ics.uci.edu/~eppstein/PADS</a> ). </div><p>Source: <a href="https://habr.com/ru/post/112421/">https://habr.com/ru/post/112421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112412/index.html">Iran has launched an online police unit</a></li>
<li><a href="../112413/index.html">Base GeoIP - countries and cities, January 2011</a></li>
<li><a href="../112414/index.html">Give me the iron! Part 1</a></li>
<li><a href="../112417/index.html">[Webinar] Representation of hierarchical structures in relational databases</a></li>
<li><a href="../112418/index.html">Estimated service Activepay</a></li>
<li><a href="../112422/index.html">Prospects for the developer: creating an application that works with Evernote</a></li>
<li><a href="../112423/index.html">TeeWorlds Tournament</a></li>
<li><a href="../112426/index.html">How Facebook protected Tunisian accounts</a></li>
<li><a href="../112429/index.html">Electrowetting technology</a></li>
<li><a href="../112430/index.html">Introduction to WebGL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>