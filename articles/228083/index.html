<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LED controller for aircraft model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I came across an article on how to make gates for an aeromodel . Actually, I didn‚Äôt really like to get involved in electronics, but the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LED controller for aircraft model</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I came across an article on <a href="http://rc-aviation.ru/mtech/46-avtech/1460-bano">how to make gates for an aeromodel</a> .  Actually, I didn‚Äôt really like to get involved in electronics, but the idea of ‚Äã‚Äãputting different tiles on the model had me hooked on for some reason.  Some do not see the point - it is better to stick around the model with LED ribbons from top to bottom, and beautiful and visible from afar.  But I prefer copy models, which means all light bulbs, gates, lights and other lights should turn on and off just like the original. <br><br>  For several reasons, the proposed option did not fit me.  In this article, I described my version of a controller for blinking and non-blinking LEDs for an aircraft model. <br><br>  The controller is made on the basis of ATTiny13A, so  The article will also be useful to those who understand the AVR microcontrollers.  I tried to chew everything and sort it out on the shelves, so the article will be interesting first of all for beginners. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Abilities of the piece of iron can be estimated from this video: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/LkDnAoEUP4g%3Ffeature%3Doembed&amp;xid=17259,15700002,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjYW-lLBdIOp4wvXzEdrkT6Y-XrCQ" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  When I began to pick this question and even soldered the board offered in that article, it turned out that this was not at all what I needed.  First, there are only two channels that can blink only in turns.  You can adjust the timings, but the algorithm is wired in the firmware.  Secondly, there are already 3 buttons on the board that add extra grams.  I'm not going to rearrange the blinker from model to model and reprogram the LEDs after each flight, which means I don‚Äôt need these buttons.  I agree once to solder the wires directly to the controller and program the algorithm that is needed.  And finally, thirdly, the firmware is only in binary form, without source codes, which means that it is impossible to modify anything. <br><br>  Conceiving another model, I immediately figured out how many LEDs I need and how they will blink.  As a result of the "census", it turned out that I need 4 channels (in each channel there are 2-3 LEDs): <br><ul><li>  BANO (Airborne Navigation Lights - green and red lights at the ends of the wings) - these things are always included </li><li>  Landing lights - will turn on and off with the remote, i.e.  the circuit must respond to the PWM signal from the receiver </li><li>  Gates - white lights that blink from time to time with short and bright flashes. </li><li>  Flashing lights are red lights that turn on and off smoothly, resembling a spinning lamp old school flashing light. </li></ul><br><br>  The model is big, flying far.  So, what would the LEDs be seen, they must be powerful.  On the previous model, I did a BANO on one-watt LEDs - they are perfectly visible from a distance of 50m even on a bright sunny <s>day in the</s> evening.  So this is my size. <br><br>  That's just it turned out that powering the powerful LEDs is not so easy.  Onboard there is only power from the linear stabilizer (on the engine regulator board).  This means connecting there even one powerful LED (through a resistor, of course), we get very large losses in heat.  Large so that the heat shrinkage of the regulator melts to holes.  More details with calculations <a href="http://rc-aviation.ru/mtech/735-remont/1518-istochnik-pitaniya-bano">here.</a> <br><br>  Pulse voltage stabilizer is better, but as it turned out, the LEDs need to stabilize not the voltage, but the current.  Fortunately mikruha was found, which it does very well.  This was the second part of the training that I described <a href="http://rc-aviation.ru/mtech/735-remont/1524-bano-2">here</a> . <br><br><h4>  Electronics </h4><br>  Dealt with the requirements.  It's time to take on the soldering iron. <br><br>  I am in electronics, in general, a beginner.  And so I creatively reworked the scheme from <a href="http://rc-aviation.ru/mtech/46-avtech/1460-bano">Acinonyx</a> (which, in turn, borrowed it from the <a href="http://umat.ru/2013/03/05/ledstrob/">VETERAN ROLL</a> ).  I needed to change the following: <br><ul><li>  Throw out buttons </li><li>  Get PWM input from receiver </li><li>  ATTiny 3 legs define how the outputs and connect LED drivers to them </li><li>  Add a fourth driver, which will always be included (for BANO) </li></ul><br><br>  In general, little remains of the original. <br><br>  As a driver, the ZXLD1350 microcircuit successfully approached, which is precisely designed to power single-watt LEDs (current up to 350 mA).  Moreover, in each channel you can put any LEDs in sequence, so that all together they collectively invested in the supply voltage.  Those.  If I feed the circuit from a 3S battery (11.1V), I can put up to 3 LEDs on each channel, each of which drops 3.2V. <br><br>  The microcontroller I powered separately from the receiver, the same wire as the PWM input. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/a3a/f0c/626a3af0c38884e4f15593ae64d8e741.png" alt="image"><br><br>  Scheme.  Each channel is built according to a datasheet scheme.  There are 4 such channels on the board (I drew only one).  I drew 3 LEDs, but, as I said, you can put any number of LEDs on each channel.  You can even put the LEDs of different colors (they drop a different voltage), the main thing that they were designed for the same current.  The driver will select such a voltage, so that the current through the diodes does not exceed 350mA. <br><br>  The ADJ input of three of the channels is connected to the controller output via a transistor.  The ZXLD1350 driver has a special mechanism with which you can turn on and off the LED from the controller.  Moreover, you can smoothly adjust the brightness by changing the voltage at the input or using PWM.  That's just the operating voltage of the input from 0.3V to 2.5V, and from the controller gives 5V.  Fortunately datasheet recommends the solution in the form of a transistor.  It is only necessary to take into account that this transistor inverts the logical state - the zero on the foot of the controller will turn on the LED, and the unit will turn off.  However, this is not a problem to fix programmatically. <br><br>  In order to save weight, I decided to try to make a two-way fee.  I never became friends with LUT, but with photoresist everything came out the first time.  I tried to play around with the solder mask, but I broke the technology and the mask lay down poorly (and some of which fell off altogether).  Errors are taken into account for the future, and I will leave this attempt as it is.  For the first time, it still rolls. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/564/4d6/e43/5644d6e437fb98cb68682abab651dcd2.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7f/0c3/5b9/a7f0c35b929f36b0a687c9242bf7bd1e.png" alt="image"><br><br>  PCB layout  Crosses on the edges are docking marks.  I cut out the textolite a bit with a margin, then in the places of the crosses I drilled holes through which I then combined masks.  Metalization of the holes did not, managed the jumpers.  Well, the capacitor legs also work as a jumper between the sides. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e9/1c9/ccd/2e91c9ccd0c5b5f1ac513060782c80cc.jpg" alt="image"><br><br>  Ready product.  Excess textolite cut by the frame.  It turned out a scarf 27h22mm and weighing 4g.  Well, another 2g on the wires and connectors turned out.  The device is connected to the receiver via a standard three-pin JR connector.  LED drivers take power from the battery balancing connector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32b/ac6/ceb/32bac6ceb5df4fa5c0566f081df67718.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad8/d96/2ff/ad8d962ffa683ceadd230e39c147a97c.jpg" alt="image"><br><br>  To whom 1W can not look at the ZXLD1360 chip a little.  It is designed to supply 3W of LEDs (current 750mA).  The wiring and pinout are the same, so that the wiring board is suitable.  Only the nominal values ‚Äã‚Äãof some parts need to change, smoke datasheet. <br><br>  For those who have not pumped more in the etching of double-sided boards, I also post several options for one-way - for 2, 3 and 4 channels. <br><br>  LEDs bought from the Chinese <a href="http://www.ebay.com/itm/120985892447">on ebee</a> .  I bought specially without a radiator, which does not fit everywhere.  As the radiator used pieces of aluminum strip.  The LED can be fixed with a special thermally conductive tape or glue.  This is how it looks in the test version (here the radiator is small, it is heated) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/a98/643/5f0a986438c97e358bb8e337723fe0bc.jpg" alt="image"><br><br>  And so on the previous model. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5d/3ef/0d0/d5d3ef0d0d26b52360387f0bb6113e90.jpg" alt="image"><br><br><h4>  Firmware </h4><br>  Now you need to breathe life into this piece of iron.  Since the source code of the firmware from the <a href="http://umat.ru/2013/03/05/ledstrob/">VETERAN SCREEN</a> was not found in the internet, I had to do everything myself.  No, I, of course, disassembled its firmware to see what was inside, but it was much more useful to just read the specification for ATTiny13. <br><br>  Despite the fact that the microcontroller only 1Kb flash, I decided to write in C. It is more convenient and clearer.  Arduino sketches, of course, they will be easier in some way, but everything that I have in mind will not fit into the controller's memory.  Therefore I had to go down to a lower level and program the registers directly.  To my surprise, the compiler (gcc 3.4.2 from Atmel Studio 6) generated pretty good code.  There were, however, a couple of places where the compiler acted suboptimally, but these places were corrected. <br><br>  The architectural problem of the firmware is that I needed to do several conceptually different actions at the same time - then blink, do not blink, <s>then wrap the fish</s> , listen to the PWM input, then generate the PWM output. <br><br>  I will give a classic example.  What if we need to blink one LED?  Well, then our program will look something like this: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { led1(on); delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); led1(off); delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }</code> </pre> <br><br>  But what if we need to blink two LEDs, and even with different frequencies?  Well, you can, of course, pervert and write something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { led1(on); delay(<span class="hljs-number"><span class="hljs-number">300</span></span>); led2(on); delay(<span class="hljs-number"><span class="hljs-number">200</span></span>); led1(off); delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); led2(off); delay(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre><br><br>  But most likely it will be very difficult to choose the timings and the sequence of on-off.  If it works, of course (which I doubt).  And if you need three blinking diodes?  And four? <br><br>  The correct solution is to use timers.  But there is a problem: the timer in the microcontroller is only 1, and that eight-bit one. <br><br>  In fact, where there is one timer, you can make arbitrarily many software timers.  It looks like this: the hardware timer ticks with great frequency.  For each timer triggering, the handler checks whether the specified time for the program timer has passed.  If it does, call the handler. <br><br>  Let's see how it will look like in code. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Pointer to a timer handler typedef void (*eventHandler)(); // Software timers list typedef struct timer_t { uint16_t timeout; eventHandler handler; } timer_t; #define TIMERS_LIST_SIZE 5 timer_t timersList[TIMERS_LIST_SIZE];</span></span></code> </pre><br><br>  A program timer is a counter how many times the main (iron) timer should scroll before calling the handler.  A pointer to the handler is attached.  For my tasks, three such entries are quite enough, but just in case I made a list of programmed timers with a size of 5 items. <br><br>  I will describe the issue of setting the microcontroller timer a bit later.  And now about the implementation of software timers.  The initialization function looks simple - reset the list of timers. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupEventQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Clear timers list memset(timersList, 0, sizeof(timersList)); }</span></span></code> </pre><br><br>  In order to add a program timer, we simply look for an empty slot and enter timeout values ‚Äã‚Äãin it plus a pointer to the handler.  Error checking is absent in order to save space in the controller. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(eventHandler handler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Search through the timers list to find empty slot for(timer_t * timer = timersList; timer &lt; timersList + TIMERS_LIST_SIZE; timer++) { if(timer-&gt;handler != NULL) continue; // Add the timer to the list timer-&gt;handler = handler; timer-&gt;timeout = timeout; break; } }</span></span></code> </pre><br><br>  The main loop is as follows. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runEventLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ runTimer(); <span class="hljs-comment"><span class="hljs-comment">// Set up sleep mode set_sleep_mode(SLEEP_MODE_IDLE); while(1) // Main event loop { wdt_reset(); // Sleep until the timer event occurs sleep_enable(); sleep_cpu(); sleep_disable(); //Iterate over timers for(timer_t * timer = timersList; timer &lt; timersList + TIMERS_LIST_SIZE; timer++) { // Skip inactive timers if(timer-&gt;handler == NULL) continue; if(timer-&gt;timeout) // Decrement timeout value { timer-&gt;timeout--; } else // If it is already zero - execute handler { timer-&gt;handler(); timer-&gt;handler = NULL; } } } }</span></span></code> </pre><br><br>  First, we start the timer (more on this below, everything is not so trivial there).  Instead of active waiting, I use sleep.  At the beginning of each cycle, the processor goes into Idle mode.  This means that the CPU will fall asleep, but all the timers (ok, all, he alone!) Will continue to work.  When the timer counts to the end and resets to zero, an interrupt occurs that wakes up the processor and the program goes on.  Just what we need. <br><br>  Yes, in the LED blinker a lot of electricity can not be saved, but in the future the same frame can be used in other applications where falling asleep to the processor can be very useful. <br><br>  If we woke up it means that it's time to go through the list of programmed timers.  In each record we reduce the value of the counter.  If you have already reached zero, then we call the handler, after which we delete the timer from the list (by writing NULL to the pointer to the handler). <br><br>  Since everything happens in one thread, no mutexes and locks are required. <br><br>  To blink the LED with a fixed frequency, the handler will look like this: invert the state of the LED, ask the system to call the same handler again after a while. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_A_PIN PORTB0 void toggleLedATask() { PORTB ^= (1 &lt;&lt; LED_A_PIN); addTimer(toggleLedATask, TIMEOUT_MS(300)); }</span></span></code> </pre><br><br>  To make it all work, you need the handler to somehow volunteer for the first time.  To do this, before starting the main loop, just put a message in the queue that it‚Äôs time to call the handler with a delay of 0 ms (that is, immediately at the first opportunity). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Set up ports PORTB = 1 &lt;&lt; LED_A_PIN; // LEDs switched off DDRB = 1 &lt;&lt; LED_A_PIN; // output mode for LED pins setupEventQueue(); addTimer(toggleLedATask, TIMEOUT_MS(0)); sei(); runEventLoop(); }</span></span></code> </pre><br><br>  Initially, the pin is adjusted to the output.  I remind you that the LEDs are connected through an inverter.  So in order to turn off the default LED, you need to write a unit to the port. <br><br>  Well, blinking back and forth is not interesting.  Is there anything more abruptly?  For example, blink once, then after a pause, blink twice, then thrice, repeat, shake, not stir.  Well, this is also not difficult. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_B_PIN PORTB1 uint8_t delayIndex = 0; const uint16_t delays[] = { TIMEOUT_MS(100), </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//on TIMEOUT_MS(700), //off TIMEOUT_MS(100), //on TIMEOUT_MS(200), //off TIMEOUT_MS(100), //on TIMEOUT_MS(700), //off TIMEOUT_MS(100), //on TIMEOUT_MS(200), //off TIMEOUT_MS(100), //on TIMEOUT_MS(200), //off TIMEOUT_MS(100), //on TIMEOUT_MS(1200), //off }; void complexLedTask() { PORTB ^= (1 &lt;&lt; LED_B_PIN); uint16_t delay = delays[delayIndex]; delayIndex ++; if(delayIndex &gt;= sizeof(delays)/sizeof(uint16_t)) //dim(delays) delayIndex = 0; addTimer(complexLedTask, delay); }</span></span></span></span></code> </pre><br><br>  Just make a table with timings.  The handler each time changes the state of the LED and waits for the time specified in the table. <br><br>  In order to blink several LEDs simultaneously and independently, simply add several similar handlers, not forgetting to configure the port and add handlers to the list. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Set up ports PORTB = 1 &lt;&lt; LED_A_PIN | 1 &lt;&lt; LED_B_PIN | 1 &lt;&lt; LED_C_PIN; // LEDs switched off DDRB = 1 &lt;&lt; LED_A_PIN | 1 &lt;&lt; LED_B_PIN | 1 &lt;&lt; LED_C_PIN; // output mode for LED pins setupEventQueue(); addTimer(toggleLedATask, TIMEOUT_MS(0)); addTimer(complexLedTask, TIMEOUT_MS(0)); addTimer(blinkLedCTask, TIMEOUT_MS(0)); sei(); runEventLoop(); }</span></span></code> </pre><br><br>  Of course, you still need to get used to this style of programming, but in general the approach works well.  Remember, if we are writing a multi-threaded application for a large computer, usually each thread has an eternal loop and maybe some kind of sleep or wait.  Consider that the above handlers are the body of that same eternal loop, and the addTimer () call is the same sleep. <br><br>  How often should the main timer tick?  If it rarely ticks, it will reduce the accuracy of the measured time intervals.  On the other hand, for each timer cycle you will need to do a certain number of useful actions.  And these actions need to have time to finish before the next timer cycle.  So the timer should tick and not very often as well. <br><br>  Those.  not often and not rarely.  But how exactly?  Ok, for the previous task the range of possible values ‚Äã‚Äãis quite large.  But you also need to remember the task ‚Äúlisten to PWM input‚Äù.  More specifically, there are pulses with a duration of 800-2200 Œºs and we will have to measure this length.  For our task to turn on / off the LED on the command from the remote, we will read as follows: if the pulse is shorter than 1500¬µs, the LED is off, if it is longer, it is on. <br><br>  Translated into the language of microcontrollers and timers, we will count how many timer ticks fit in the measured time interval.  The problem occurs when the pulse duration is approximately equal to the threshold.  Then false alarms are possible and the LED will blink as the pulse length changes.  To reduce the chance of blinking, we need to more accurately measure the length of the pulse.  I think the resolution of the timer should be in the region of 1-2 Œºs - such a resolution will ensure sufficient accuracy of measurements. <br><br>  If we are talking about specific numbers you need to understand the frequency of the microcontroller.  The controller can be clocked from the internal and from the external generator.  The external generator is more accurate, but these are additional details and weight.  Yes, and we do not need accuracy especially.  Of the internal oscillators, 128 kHz, 4.8 MHz and 9.6 MHz are available.  128kHz is not enough, we will choose between the other two options. <br><br>  The timer, in turn, can have the same frequency as the microcontroller, and it can activate the frequency divider by 8, 64, 256 or 1024. The timer itself counts from 0 to 255 and then resets to 0. If the divider does not use one tick the timer corresponds to one processor tick, which in most cases corresponds to a single command.  We were going to do useful work every full timer cycle.  But if we need to do this work every 256 teams, then we simply will not have time to do this work (or there should be very very little of it). <br><br>  So, you need to choose between the frequency 4.8 MHz and 9.6 MHz, and the dividers 8, 64 and 256. As for me, the 4.8 MHz option with the divider 8 is quite successful.  The timer will tick at 4.8 MHz / 8 = 600 kHz.  This means that one tick will take 1.666 Œºs.  Just fit in the desired 1-2mks.  The full cycle of the timer will take 1,666 * 256 = 426.66 Œºs.  As a program timer, we use a 16-bit variable, which means we are able to measure time intervals of 65536 * 426.66 Œºs = 27.96 s (with the accuracy of the same 426.66 Œºs) <br><br>  Timer start code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Reset timer counter TCNT0 = 0; // Run timer at 4.8MHz/8 = 600 kHz // This gives 1.667 uSec timer tick, 426.667 uSec timer interval // Almost 28 seconds with additional 16bit SW timer value TCCR0A = 0; // Normal mode TCCR0B = 0 &lt;&lt; CS02 | 1 &lt;&lt; CS01 | 0 &lt;&lt; CS00; // run timer with prescailer f/8 }</span></span></code> </pre><br><br>  In the code above, I used the mysterious TIMEOUT_MS macro.  It's time to decipher it. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMEOUT_MS(t) ((uint32_t)t * 600 / 256) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//4.8MHz / (8 prescailer * 256 full timer cycle * 1000 since we are counting in ms)</span></span></span></span></code> </pre><br><br>  This macro determines the number of cycles at 426.6 ¬µs required to measure a specified number of milliseconds.  Unfortunately, when I banged the full formula (the one in the commentary), then the compiler started generating terrible problems that I could not cope with.  I had to recount the formula to the incomprehensible now 600/256. <br><br>  But back to hearing PWM input.  To be a little clearer, I will tell you again how everything works, but in other words.  The main 8-bit timer ticks from 0 to 255. Each full cycle of the timer, we process a list of software timers and start handlers, if needed.  In addition, the value of the 8-bit timer itself is used in the measurement of the pulse length at the input.  This is done very simply: if the impulse has begun, we remember the value of the timer.  While the pulse goes the timer keeps ticking.  By the time the impulse ends, the timer is docked to some new value.  Accordingly, by the difference of values, we can calculate the pulse length simply by multiplying by the time of one tick (1.666 Œºs) <br><br>  Stop!  The timer is 8bit and that means that only pulses up to 256 * 1.66 = 426.66¬µs can be measured in this way, while incoming pulses up to 2200¬µs long.  No problem!  You can artificially extend the timer counter by adding as many high bytes as needed.  The usual binary mathematics operates - when the low byte overflows we increment the high bytes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Additional high byte for 8bit timer value volatile uint8_t tcnth; void runTimer() { // Reset timer counters tcnth = 0; TCNT0 = 0; // Run timer at 4.8MHz/8 = 600 kHz // This gives 1.667 uSec timer tick, 426.667 uSec timer interval // Almost 28 seconds with additional 16bit SW timer value TCCR0A = 0; // Normal mode TCCR0B = 0 &lt;&lt; CS02 | 1 &lt;&lt; CS01 | 0 &lt;&lt; CS00; // run timer with prescailer f/8 TIMSK0 = 1 &lt;&lt; TOIE0; }</span></span></code> </pre><br><br>  Almost all the same.  Only the variable tcnth was added - the ‚Äúhigh‚Äù byte in addition to the low byte inside the timer.  The last line is also important - it includes the timer overflow interrupt.  This interrupt will increment the high byte: <br><br><pre> <code class="cpp hljs">ISR(TIM0_OVF_vect) { <span class="hljs-comment"><span class="hljs-comment">// Increment high byte of the HW counter tcnth++; }</span></span></code> </pre><br><br>  Notice that the tcnth variable is declared volatile.  Without this keyword, the compiler in another part of the program might think that the variable does not change and optimize too much.  He does not know that the variable changes in the interrupt (in fact in another thread). <br><br>  In order to catch the beginning and end of the pulse, you can use a specially designed for this pin change interrupt - an interrupt that will be triggered just when the value changes at the input.  So  you do not need to constantly poll the input - the microcontroller will do all the work.  We just have to write an interrupt handler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pwmPulseStartTime; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_THRESHOLD 900 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// number of pulses in 1500 uS at 4.8MHz with /8 prescailer = 1500 * 4.8 / 8 = 900 // Pin Change interrupt ISR(PCINT0_vect) { /* // Get the current time stamp uint16_t curTime = (tcnth &lt;&lt; 8) + TCNT0; Unfortunately gcc generates plenty of code when constructing 16 bit value from 2 bytes. Let's do it ourselves */ union { struct { uint8_t l; uint8_t h; }; uint16_t val; } curTime; // Get the current time stamp curTime.h = tcnth; curTime.l = TCNT0; // It may happen that Pin Change Interrupt occurs at the same time as timer overflow // Since timer overflow interrupt has lower priority let's do its work here (increment tcnth) if(TIFR0 &amp; (1 &lt;&lt; TOV0)) { curTime.h = tcnth+1; curTime.l = TCNT0; } if(PINB &amp; (1 &lt;&lt; PWM_INPUT_PIN)) // On raising edge just capture current timer value { pwmPulseStartTime = curTime.val; } else // On failing edge calculate pulse length and turn on/off LED depending on time { uint16_t pulseLen = curTime.val - pwmPulseStartTime; if(pulseLen &gt;= PWM_THRESHOLD) PORTB |= (1 &lt;&lt; LED_C_PIN); else PORTB &amp;= ~(1 &lt;&lt; LED_C_PIN); } }</span></span></span></span></code> </pre><br><br>  The first part of the handler is devoted to pulling out the value of the timer counter (extended by an additional external byte).  Unfortunately, subtracting the value in the forehead did not work - from time to time the LED blinked spontaneously.  This happened because 2 interrupts occurred approximately simultaneously.  And since the timer interrupt has a lower priority, the handler was sometimes not called when it followed.  As a result, the high byte was not increased, which means the total value turned out to be 256 units less.  This is significant. <br><br>  The solution is quite simple - to check whether the overflow of the timer occurred and, if it does, do the same job as the handler for this overflow - to do +1 for the high byte. <br><br>  At this point, I came across a non-optimal code generated by a vile.  The code (tcnth &lt;&lt; 8) + TCNT0 compiled like this, with shifts and additions.  And this is despite the included optimization (-O1).  I, in this place, need only 2 bytes to interpret as a 16-bit number.  I had to make a fuss with unions. <br><br>  The second part of the handler does the actual useful work.  If we caught the beginning of the impulse - just remember the time stamp in the variable pwmPulseStartTime.  If we caught the end of the pulse, we consider the difference in time marks and turn on / off the LED depending on the value.  Threshold is 1500ms, or 900 timer ticks of 1.66¬µs each. <br><br>  What is missing here is the initialization of the pin change interrupt itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_INPUT_PIN PCINT3 void setupPWMInput() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Initialize the timestamp value pwmPulseStartTime = 0; // Set up pin configuration PORTB |= 1 &lt;&lt; PWM_INPUT_PIN; // pull-up for PCINT3 DDRB &amp;= ~(1 &lt;&lt; PWM_INPUT_PIN); // output mode for LED pins, input mode for PCINT3 pin // Use PCINT3 pin as input PCMSK = 1 &lt;&lt; PWM_INPUT_PIN; // Enable Pin Change interrupt GIMSK |= 1 &lt;&lt; PCIE; }</span></span></span></span></code> </pre><br><br>  Almost everything is ready.  Of the requirements are not implemented only smooth blinking.  In fact, the controller can only turn on and off the LED.  There are no intermediate values.  But if you quickly quickly turn on and off with a given duty cycle (the ratio of time when the LED lights up to the time when it is off), then the person thinks that the LED still shines smoothly, only with lower brightness.  Well, if you gradually change the duty cycle, it will seem that the brightness of the LED changes smoothly. <br><br>  You can write code that will turn the LED on and off.  The benefit of timers can now be done as you want.  But why, if PWM generation is already built into the controller?  Moreover, it is possible to independently control as many as two generation channels - on the legs of OC0A and OC0B (they are PB0 and PB1). <br><br>  It works like this.  A single timer rotates as usual with a given speed.  At the beginning of the cycle, a unit is set at the leg, and when a certain specific value is reached (specified by registers OCR0A and OCR0B), a zero is set at the leg.  Then the cycle repeats.  The larger the register value, the greater the duty cycle and the brighter the diode.  This is called Non-Inverting mode.  Since the LEDs are connected via an inverter, Inverting mode is more suitable for us - we turn on by value in the register, turn off when the timer reaches the end and resets. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Current PWM value volatile uint8_t pwmAValue = 1; volatile uint8_t pwmBValue = 1; void runTimer() { // Reset counter counters tcnth = 0; TCNT0 = 0; OCR0A = pwmAValue; OCR0B = pwmBValue; // Run timer at 4.8MHz/8 = 600 kHz // This gives 1.667 uSec timer tick, 426.667 uSec timer interval // Almost 28 seconds with additional 16bit SW timer value //TCCR0A = 1 &lt;&lt; COM0A1 | 1 &lt;&lt; COM0A0 | 1 &lt;&lt; COM0B1 | 1 &lt;&lt; COM0B0 | 1 &lt;&lt; WGM01 | 1 &lt;&lt; WGM00; // Fast PWM on OC0A and OC0B pins, inverting mode TCCR0A = 1 &lt;&lt; COM0A1 | 1 &lt;&lt; COM0A0 | 1 &lt;&lt; WGM01 | 1 &lt;&lt; WGM00; // Fast PWM on OC0A pin, inverting mode TCCR0B = 0 &lt;&lt; CS02 | 1 &lt;&lt; CS01 | 0 &lt;&lt; CS00; // run timer with prescailer f/8 TIMSK0 = 1 &lt;&lt; TOIE0; }</span></span></code> </pre><br><br>  I had to slightly adjust the timer initialization.  Bits WGM00 and WGM01 include Fast-PWM generation mode.  Bits COM0A0, COM0A1, COM0B0, and COM0B1 include Inverting mode in channels A and B. More precisely, the entered line includes in both, the unclaimed line only for OC0A. <br><br>  Since the values ‚Äã‚Äãin the variables pwmAValue change from time to time, you need to somehow let you know about this timer.  This is best done in the overflow handler. <br><br><pre> <code class="cpp hljs">ISR(TIM0_OVF_vect) { <span class="hljs-comment"><span class="hljs-comment">// Update the PWM values OCR0A = pwmAValue; OCR0B = pwmBValue; // Increment high byte of the HW counter tcnth++; }</span></span></code> </pre><br><br>  You can, of course, directly and directly push the values ‚Äã‚Äãinto the OCR0A and OCR0B registers, but this is not recommended by the datasheet.  This can lead to a ‚Äúskipping‚Äù when the value of a pin changes sooner or later than it should.  Visually, this would manifest itself in an undesirable sharp and short-term change in brightness. <br><br>  The brightness itself can be changed in the already familiar program timers.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> directionA = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pwmLedATask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(directionA) <span class="hljs-comment"><span class="hljs-comment">// Incrementing { pwmAValue += 2; if(pwmAValue == 255) directionA = 0; } else //decrementing { pwmAValue -= 2; if(pwmAValue == 1) directionA = 1; } addTimer(pwmLedATask, TIMEOUT_MS(2)); }</span></span></code> </pre><br><br>  Just gradually increase or decrease the value of the variable pwmAValue, which will then be entered into the corresponding register.  Although to emulate a real flashing light, you will have to come up with something more beautiful.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">complexPWM</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> step; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxValue; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> delay; } complexPWM; complexPWM pwmItems[] = { {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TIMEOUT_MS(<span class="hljs-number"><span class="hljs-number">1000</span></span>)}, {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">127</span></span>, TIMEOUT_MS(<span class="hljs-number"><span class="hljs-number">2</span></span>)}, {<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, TIMEOUT_MS(<span class="hljs-number"><span class="hljs-number">2</span></span>)}, {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, TIMEOUT_MS(<span class="hljs-number"><span class="hljs-number">2</span></span>)}, {<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TIMEOUT_MS(<span class="hljs-number"><span class="hljs-number">2</span></span>)} }; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pwmTableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complexPWMTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ complexPWM * curItem = pwmItems + pwmTableIndex; pwmAValue += curItem-&gt;step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curItem-&gt;maxValue == pwmAValue) pwmTableIndex++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pwmTableIndex == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pwmItems)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(complexPWM)) <span class="hljs-comment"><span class="hljs-comment">//dim(pwmItems) pwmTableIndex = 0; addTimer(complexPWMTask, curItem-&gt;delay); }</span></span></code> </pre><br><br>  I'm not sure that this looks like a flashing beacon, but in this piece of code a pre-flash is made to brightness 127, then we reduce the brightness to 33 and make a full flash (to 255). <br><br>  On this, probably, on the firmware and that's it.  With all the giblets and morgulkas everything is 500-600 bytes - there is even a reserve.  It remains to highlight one important point - Fuse bits.  They are equal to hfuse = 0xff, lfuse = 0x79.  For decoding, I will ask for a datasheet.  In a nutshell, a couple of bits in these bytes make the controller operate at 4.8 MHz.  The remaining bits are left in the default state. <br><br>  How it looks in reality can be estimated by the video in the header of the article. <br><br><h4>  Conclusion </h4><br>  In this article, I described my version of the controller for different aircraft-made light bulbs - BANO, landing lights and strobes.  All that remains is a bit of crafting the firmware and your copy models will look like real ones. <br><br>  Moreover, a similar blinker can be put on the car.  And you can, for example, highlight the advertising sign.  All in your hands. <br><br>  But not single planes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition to the blinking light bulbs, I covered in the article a few other points related to the programming of weak controllers: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to emulate multiple timers on one timer </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to choose timer parameters </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to set the timer in PWM generation mode </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to listen to PWM input and do useful work based on read values </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we abstract away from the task of blinking with LEDs, then we get a pretty good frame for ‚Äúmultitasking‚Äù (‚Äúmultithreaded‚Äù?) Applications on the microcontroller. Of course, this is not RTOS, but it already eliminates a whole heap of routine operations. In the firmware, I made this framework into a separate module EventQueue.c / .h. Use nasdorove. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's nice that we got 3 completely independent tasks (counting long periods of time, measuring the duration of the pulses at the input and generating PWM at the output) managed to be hung up on a single 8-bit timer. Well, on the added software timers, you can still do a lot of useful things.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code, however, turned out not very structured. Different tasks are solved in the same functions, with each task being spread in several places. But this is a fee for a compact size. As well as the lack of buttons and other means of entering information. But, I repeat, I didn‚Äôt get soldered once by soldering the programmer wires directly to the controller, configuring the necessary blinking option in the code and pouring it all in the form of firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article is not a reference book - all the same, you will have to go to the datasheet for clarification of certain bits and registers. This is just a kind of example, how can you use some meager hardware by using the means of a junior controller in the AVR line?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, I did not plan to attach to the article the final compiled hex file. </font><font style="vertical-align: inherit;">The fact is that all models are different. </font><font style="vertical-align: inherit;">Somewhere you need another number of channels, somewhere you need to blink differently, you may need to add a couple of inputs, or do something else. </font><font style="vertical-align: inherit;">Instead, I would suggest that you try changing the firmware yourself so that you fully fit your idea. </font><font style="vertical-align: inherit;">Everything is simple there!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, not all model airplanes are friends with the compiler. </font><font style="vertical-align: inherit;">So I nevertheless compiled a certain average variant: one channel blinks once every 2 seconds (strobe), the PWM channel flashes a little more often with double flashes, the third channel is turned on by a command from the console, the fourth, as before, always shines. </font><font style="vertical-align: inherit;">This firmware will be a certain starting point for the subsequent dopilivaniya. </font><font style="vertical-align: inherit;">The examples presented in the article, I also left in the code, only calls zakommentaril.</font></font><br><br>  Successes! <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources of firmware and wiring boards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/228083/">https://habr.com/ru/post/228083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228067/index.html">PyCon Russia 2014 - two days of python-happiness</a></li>
<li><a href="../228069/index.html">Yii 1.1.15 (security fix)</a></li>
<li><a href="../228071/index.html">Robotics direction in summer programming school from Yandex and ABBYY</a></li>
<li><a href="../228077/index.html">42 yoctonewton</a></li>
<li><a href="../228079/index.html">Function Pointer - forgotten implementation of the Singleton pattern</a></li>
<li><a href="../228085/index.html">How I screwed the speedometer to the tanks</a></li>
<li><a href="../228093/index.html">Beeline TV via Mikrotik in the province</a></li>
<li><a href="../228095/index.html">Zabbix 2.2: Monitoring the temperature of the Windows processor of the machine</a></li>
<li><a href="../228099/index.html">Inventing a bike or finding a missing ID value in a MySQL table</a></li>
<li><a href="../228101/index.html">Problems and prospects of ensuring the safety of civil aviation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>