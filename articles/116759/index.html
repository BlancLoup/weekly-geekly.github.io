<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Adding Input Method to Arduino</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are a large number of different master whales for various microcontrollers. However, in the Arduino came up with a model of the master whale wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Adding Input Method to Arduino</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/habraeffect/9a/92/9a92b5c908a2bb7b82a1b46c97dadc78.jpg" align="left" alt="image">  There are a large number of different master whales for various microcontrollers.  However, in the Arduino came up with a model of the master whale with an almost zero threshold of entry.  It is enough to enter three lines of code and you already blink the LED or control the engine.  But as far as the breadboard model grows, with all sorts of sensors, a display and buttons you begin to understand that there is a lack of a more advanced input method - a keyboard.  Not expensive and mobile version is described under the cut. <br><a name="habracut"></a><br><br><h4>  Part One - Theoretical </h4><br>  There are many methods for connecting the keyboard to the Arduino: <br><ul><li>  ordinary matrix keyboards that cling directly to ports ( <a href="http://arduino.cc/playground/Main/KeypadTutorial">Keypad Tutorial</a> ).  The disadvantage is that it takes a lot of I / O ports, few buttons. </li><li>  matrix keyboards connected via I2C ( <a href="http://arduino.cc/playground/Main/I2CPortExpanderAndKeypads">I2C Port expander and Keypads</a> ).  Advantages - takes only two outputs, allows you to use multiple devices on the same bus.  Disadvantages - you need to include in the project a library for working with I2C, few buttons </li><li>  ordinary PS / 2 keyboard ( <a href="http://arduino.cc/playground/Main/PS2Keyboard">PS2 Keyboard</a> ).  Advantages - a large hardware base, a bunch of buttons for every taste, it takes few conclusions.  Disadvantages - need a library to convert scan codes, size - PS / 2 keyboards do not differ in mobile size </li></ul><br>  Having rejected all these methods due to the small number of buttons or a large size, I remembered that I had a miniature keyboard for a cell phone on my anthresals for ten years now - Ericsson Chatboard: <br><img src="https://habrastorage.org/storage/habraeffect/13/1d/131d6f56bf28df56e5f3c7b06ea85e35.png" alt="image"><br>  Specifically, this model CHA-01 is rated at 5 volts and seems to be a telephone ... a modem! <br>  There is also the CHA-10 model, which is used with newer (if it can be said about devices of the age of five or seven years old) telephones and operates from 3.3 volts.  Both models are not difficult to purchase on EBay for ~ $ 12 with delivery. <br><br>  You can limit the unmodified version of the keyboard.  Search for the connector from the old phone to connect.  Develop a library that will parse input from the keyboard, and enjoy life. <br>  However, it will not take long to rejoice - a large <a href="http://www.ipsec.info/~www/agenda/chatboard.txt">protocol</a> overhead (pressing the 0 key causes, for example, 'AT * EKSE = 0', and www - 'AT * EAPP = 0.5, ‚ÄúWWW:‚Äù, ‚ÄúWWW‚Äù') and switching on the input only after pressing the SMS button do not give ease of use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The way out is to make something different on the basis of this keyboard, which will work as it is necessary for us and with the ability to change the behavior if necessary. <br><br><h4>  Part Two - Practical </h4><br>  A search on the Internet has given the next <a href="http://www.myplace.nu/avr/avrchatboard/index.htm">page</a> , which I used as the basis for my rework.  The most valuable information from there was that the microcontroller in the keyboard and the Atmel Mega162 match the conclusions and the latter can be replaced by the built-in one. <br><img src="https://habrastorage.org/storage/habraeffect/1c/23/1c237f6bec5e437822c5e9f2777d9146.png" alt="image"><br>  Inside the keyboard is a standard matrix size of 7x7 and occupies 14 pins of the microcontroller.  Outside information is issued via UART. <br><br>  Taking the given information as a basis, we build a plan for reincarnation: <br>  - replace the microcontroller with mega162 ($ 3 on the market) <br>  - replace the connector with ‚Äúcommon‚Äù <br>  - add the ability to change the software whenever you want (the benefit is realizable through the bootloader) <br>  - set up a normal IDE to work with AVR / Arduino (to get rid of unnecessary here C ++ / libraries) <br>  - write a simple software to test the performance (check IDE settings and familiarization with C for AVR) <br><br>  Armed with a soldering station, we remove unnecessary components: <br><img src="https://habrastorage.org/storage/habraeffect/96/ae/96ae43d0c2b7afb1bcbdc071f95a59ad.png" alt="image"><br><br>  Pinout of the original connector for CHA-01 can be found <a href="http://www.brolinembedded.se/projects/keyboard/">here</a> : <br><img src="https://habrastorage.org/storage/habraeffect/3b/d2/3bd20f3a17b9956f4dd21abdf206021d.gif" align="left" alt="image"><br><br>  1, 5 - Vcc +5 Volt <br>  2 - Chatboard serial out <br>  3 - GND <br>  4 - Chatboard serial in <br><br>  Solder our spare parts: <br><img src="https://habrastorage.org/storage/habraeffect/95/1e/951e36f098fc277a33ff3de358395252.png" alt="image"><br><br>  Unlike the author of the above article, I chose the standard PBS-08 line as the connector - it fits perfectly into the case without a file and even lays down the right places on the board.  And I decided not to switch to an external resonator. <br>  RX, TX, GND, Vcc, MOSI, MISO, SCK and RST were brought to the connector.  Thus, we will be able to reprogram the device in the future without removing it from the case. <br>  It seems that everything is ready and can be connected to the programmer (I used to use USBASP, but you can also use arduin to program other AVRs - <a href="http://arduino.cc/en/Tutorial/ArduinoISP">ArduinoISP</a> ) <br><img src="https://habrastorage.org/storage/habraeffect/a6/0b/a60b896b2f53ecc4372b74e413c4c49e.png" alt="image"><br>  But avrdude completely refuses to see the microcontroller.  As before, I had no experience of such alterations - I had to turn to more experienced comrades for diagnostics.  The heavy artillery with the oscillograph and the generator undertook the business.  After a short fight, I was sent ... RTFM. <br>  It turns out USBASP works with fast microcontrollers (more than 4 MHz), and mega162 by default includes a ‚Äúdivider by 8‚Äù and operates from an internal generator at a frequency of 1 MHz.  Since the frequency of 1 MHz for the keyboard is more than enough (and the consumption is less), I decided not to change it and look for ways out of the situation.  The way out was found very quickly - USBASP has a jumper that lowers the ‚Äúfrequency of communication‚Äù with the microcontroller (or the av option of -B for avrdude, which does it programmatically, helped me -B 3). <br><br>  Now, when avrdude sees the crystal, it would seem, it is necessary to reflash and forget :) But the experience of the first RTFM cooled me a little and I decided to drive the software on the emulator first (as it turned out for good reason).  To do this, on Proteus experienced comrades, was assembled keyboard layout.  And the firmware was written, which interrogated the keyboard and output the required character in the UART.  And so, everything is compiled, loaded into the emulator, the parameters of the virtual terminal are set to 9600,8n1.  But for some reason, the terminal shows garbage when you press a key.  Debug USART mode in the emulator showed that the exchange rate is set at 10200 and not at 9600 ... Again RTFM - Baud rate depends on the chip frequency and at 1 MHz, the standard setting allows you to reach the speed of 4800 (with an error of 0.2%), while at 9600 the error is 7%!  The datasheet also contains an error table for various Baudrate / MHz - from where it can be seen that at a frequency of 1 MHz, an error of 0.2% can be achieved only by setting Double-rate USART.  In C, it looks like this: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 1000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BAUD_RATE 9600UL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Init serial UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*8L)-1); UBRR0H = ((F_CPU/(BAUD_RATE*8L)-1) &gt;&gt; 8); UCSR0A = _BV(U2X0); // Set double-speed, for low freq cpu UCSR0B = _BV(TXEN0)|_BV(RXEN0); // Enable TX, Enable RX UCSR0C = _BV(URSEL0)|_BV(UCSZ00)|_BV(UCSZ01); // 8n1 async</span></span></span></span></code> </pre> <br>  Hurray, our code works fine in the emulator - shows all keystrokes, works out pressing Shift and so on. <br><br>  Go to the fill software in the keyboard.  The bootloader took from the first link ( <a href="">stk500boot.zip</a> ).  Since it also works through USART, it has changed initialization and speed in source code to 9600. <br>  Bootloader via USBASP is flooded with the following command: <br> <code>avrdude -c usbasp -p m162 -B 3 -U flash:w:stk500boot.hex:i -U hfuse:w:0x98:m <br></code> <br>  Changing hfuse is necessary to change the reset-vector - so that the microcontroller download starts from the bootloader. <br>  Further communication with the keyboard can be done through the UART, and we will not need USBASP. <br>  I chose a USB-UART (Serial) converter based on FTDI - since the Arduin itself is built on the same chip, so I already have drivers in the system. <br><br>  By coincidence, the converter connector and my keyboard perfectly matched each other, so I connected it directly: <br><img src="https://habrastorage.org/storage/habraeffect/53/6f/536fdf91222ab1be3449aaabd32d8dee.png" alt="image"><br><br>  Despite the statement that this STK500 bootloader is compatible - avrdude did not want to work with it through the type of programmer stk500v1 - cursed that the wrong device ID.  From the source it was clear that the bootloader can read and give the device ID, so I found by the brute force method that it works great if I specify the type of arduino. <br>  The command for uploading firmware via UART: <br> <code>avrdude -c arduino -p m162 -b 9600 -P /dev/tty.usbserial-00001004 -U flash:w:chatboard.hex:i <br></code> <br><br>  Checking through the terminal showed that not all buttons are pressed, and the main feature of the bootloader, switching to software update mode by pressing the Yes button, also does not work.  It was impossible to flash the keyboard through the UART.  A more detailed study showed that three columns of buttons from a 7x7 matrix did not work.  Everything again came up against RTFM ... the three pins we used to poll the keyboard also have an alternative function (JTAG) enabled by default.  Turning off JTAG (rewrite hfuse to 0xD8) we get a fully functional keyboard: <br><img src="https://habrastorage.org/storage/habraeffect/20/74/20744ba38da0238448bbf3b283d734ed.png" alt="image"><br><br><img src="https://habrastorage.org/storage/habraeffect/8e/87/8e876d9b9c0016c8befe3a1469453a7a.png" align="right" alt="image">  Time to connect to the Arduino.  As an interface connector, I chose a non-standard miniUSB, so as not to accidentally plug something inappropriate.  The donor for the wire was the old mouse (from where it is still possible to remove the encoder).  Connecting to the keyboard is a standard male connector. <br>  The miniUSB - UART adapter was assembled to pinout the UART onto the SensorShield (there is no standardized output for the UART on my breadboard). <br><img src="https://habrastorage.org/storage/habraeffect/14/f3/14f388a2cf7f0c50f294cad733be2025.png" alt="image"><br><br><h4>  Results </h4><br><ul><li>  The keyboard is small enough to carry it with you in your pocket. </li><li>  Keyboard polling via UART allows you to work with it without any external libraries (it saves space in the flash) </li><li>  Using UART will allow you to further connect the keyboard wirelessly via Bluetooth serial or XBee serial </li></ul><br>  Ps.  The size of the Eclipse + avr-gcc-compatible firmware is only 600 bytes.  While the binarica is less than 3k I did not see in the Arduino IDE. <br>  Pps.  Sources and firmware can be found here: <a href="">chatboard.tar.gz</a> </div><p>Source: <a href="https://habr.com/ru/post/116759/">https://habr.com/ru/post/116759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116748/index.html">Motorola Milestone 2 Review</a></li>
<li><a href="../116749/index.html">Microcomputer BK 0010-01</a></li>
<li><a href="../116752/index.html">Draw widgets in the title bar</a></li>
<li><a href="../116753/index.html">IT in medicine: the way of the USA</a></li>
<li><a href="../116754/index.html">Pop-up flash message from the depths of background tasks</a></li>
<li><a href="../116760/index.html">Haskell Tutorial on the other hand</a></li>
<li><a href="../116761/index.html">Encrypt files in black and white images.</a></li>
<li><a href="../116767/index.html">Repent of your sins and be happy. Or how small usability flaws spoil the whole result.</a></li>
<li><a href="../116768/index.html">Making your Gmail Motion</a></li>
<li><a href="../116769/index.html">We protect the VPS-server based on Windows 2008 R2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>