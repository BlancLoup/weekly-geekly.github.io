<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Joint editing. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! We recently started a series of articles on collaborative editing. In the first article I talked about the task of non-blocking editing and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Joint editing. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/504/fbc/914/504fbc914d19480e9f016ae92cf8c56d.jpg"><br><br>  Good day!  We recently started a series of articles on collaborative editing.  In the <a href="http://habrahabr.ru/company/ncloudtech/blog/264923/">first article</a> I talked about the task of non-blocking editing and possible approaches to its implementation.  I recall that in the end we chose Operation Transformation (OT) as the algorithm.  A story about its client-server version was also announced, and today I will cover the details of his work.  In addition, you will find out why the cancellation in OT works differently and how it faces a collision with harsh reality. <br><br>  Next you will find a lot of algorithms and diagrams.  I think you will be interested. <br><a name="habracut"></a><br><h1>  Client-server model </h1><br>  At the end of the previous article I noted that the difficulties in implementing the OT approach can be circumvented at the expense of the central server.  Unlike the peer-to-peer algorithm, using a server allows you to enter a general order of operations ‚Äî the order of operations on the server.  Accordingly, at any moment in time the status of the document on the server is characterized by one number - revision. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/776/bed/cb4/776bedcb4780469a8d739e245d83f4ec.jpg"><br><br>  In this case, the status of the document at any of the clients at any time can be represented as a certain revision on the server and a certain number of local operations that are still not coordinated with the server. <br><br><img src="https://habrastorage.org/files/1ca/551/5d7/1ca5515d770b42aaaacbe81ee2442bd7.jpg"><br><br><h3>  From server to client </h3><br>  To begin with, let's look at what happens when a new operation comes from the server to the client.  In this situation, everything is quite clear.  It is assumed that all operations come to us in the order in which they are applied on the server.  For this reason, the audit of the operation is known to us (audit on the client + 1). <br><br><img src="https://habrastorage.org/files/b59/7c9/673/b597c967395e4e3ca202dc92e74955a6.jpg"><br><br>  Revision 1 is the most recent overall document state for the server and this client.  Recall the transformations that we covered in the previous article.  With their help, we can "reduce" various ways of document modifications: <br><br><img src="https://habrastorage.org/files/d20/c7e/942/d20c7e942c614cd6a75c416c4055c546.jpg"><br><br>  For clarity, in this and the following diagrams I will use abbreviations, where Operation3 is Op3, Local operation 1 is LOp1, and so on.  The right shoulder is the actions that are performed on the server.  And the left - on the client.  We use the transformation property described in the <a href="">diagram</a> in the last article: <br><br><img src="https://habrastorage.org/files/3b7/cd9/f6b/3b7cd9f6b63c4e2aaedf7d6e1324da9a.jpg"><br><br>  Repeat this action again: <br><br><img src="https://habrastorage.org/files/6b5/3f8/af9/6b53f8af9702406b904593d777e932da.jpg"><br><br>  Then we can act in two directions: <br><ol><li>  Apply the operation Op3 '' on the client, increment the revision and replace the local operations (LOp1, LOp2) with (LOp1 ', LOp2' '). </li><li>  Roll back local operations and consistently apply Op3, LOp1 ', LOp2' '. </li></ol><br>  Whichever option we choose, the result is the client‚Äôs state: <br><br><img src="https://habrastorage.org/files/8cb/60b/a75/8cb60ba75b554c75a3b1e53cc90cf291.jpg"><br><br>  Based on all the considerations given at the moment, everything looks like that the results in both variants will be similar.  And the first one is preferable for performance reasons.  But we use exactly the second method.  I will tell you why this is due in one of the following articles.  In the meantime, take it as it is and continue. <br><br><h3>  From client to server </h3><br>  After we have disassembled sending data from the server towards the client, consider the operations in the opposite direction.  Let's return to the same state as in the example above: <br><br><img src="https://habrastorage.org/files/8de/b83/1a5/8deb831a51164b48963f6b2deac91fca.jpg"><br><br>  As you can see, along with the operation itself, the client sends a revision that is common to the client and the server at the moment.  This eliminates the need for the server to restore the revision on which the sent operation was based.  Reapply the transformation: <br><br><img src="https://habrastorage.org/files/60e/af9/526/60eaf95266b048f3a9f07aba85511456.jpg"><br><br>  Here we can see that on the server it is necessary to apply the operation LOp1 ‚Ä≤ ‚Ä≤ and, accordingly, to increase the audit.  In addition, the transformed operation, we must send to the rest of the clients who work with the document: <br><br><img src="https://habrastorage.org/files/2b3/3fa/17b/2b33fa17bd994bb08d98bb129a419891.jpg"><br><br>  Please note that the client status has not changed.  In order for him to be able to increase the audit, the server needs to send him a confirmation.  This implies that the communication channel keeps the order of message delivery, which means that all operations with a revision smaller than that of LOp1 ‚Ä≤ will be sent to the client beforehand. <br><br>  In this case, the procedure for the client to receive operations from the server ensures that after all transformations the first of the local operations will have the value LOp1 ‚Ä≤, the same as the corresponding operation on the server. <br><br><img src="https://habrastorage.org/files/b1d/21f/791/b1d21f79193744f19c6926b20380d6e6.jpg"><br><br>  After receiving a confirmation message, the client increases the value of the revision.  The value of this revision will be equal to the revision on the server that corresponds to the sent operation.  We also remove LOp1 ‚Ä≤ from the list of local client operations, as it is now on the server. <br><br><img src="https://habrastorage.org/files/e9b/cf6/208/e9bcf62081cc408e9982b0056a8a1ebf.jpg"><br><br><h3>  And what happens next with Local Operation 2? </h3><br>  ‚ÄúWhat happens next with Local Operation 2?‚Äù You ask.  Everything described above works for the first local operation.  Let's see what will happen to the second.  Imagine that as soon as a client has added Local Operation 2, we immediately send it to the server.  At the same time, it is quite possible that operations between other clients can ‚Äúwedge in‚Äù between these operations on the server: <br><br><img src="https://habrastorage.org/files/126/51f/1b4/12651f1b4c3042f9889ad3289bb758a2.jpg"><br><br>  Now, to understand what operation to apply on the server, you need to resolve the following task: <br><br><img src="https://habrastorage.org/files/2db/f00/d55/2dbf00d553464ea78e18656e641e28fd.jpg"><br><br>  From the point of view of theory, nothing prevents us from doing this.  It is enough to apply the transformations mentioned many times to get the necessary operation: <br><br><img src="https://habrastorage.org/files/442/e05/b7f/442e05b7f1ac4ab285d842f5ce4ba481.jpg"><br><br>  I did not designate all the transformations, otherwise the scheme would be very cumbersome.  But It is worth noting that the operations corresponding to the red arrows are empty (identical).  This means that the operation LOp2 ‚Ä≤ - these are the changes that we should apply on the server. <br><br>  Let's look at these calculations from a practical point of view.  To perform the transformation data, the server needs to: <br><ol><li>  Know the revision with which the chart starts.  There is no difficulty in this, since together with the operation we can send a basic revision. </li><li>  Have information about previous local operations of this client.  In the diagram above, this is LOp1, but in general, there can be any number of them.  Moreover, it is important to have the status of these operations at the time of sending LOp2, since it was shown above that when the operation comes from the server, local operations will be transformed, which may lead to their change. </li></ol><br>  The condition ‚ÄúTo have information about previous local client operations‚Äù means that we need to either send all previous local operations together with LOp2, or restore them using transformations on the server.  It is impossible to simply use operations from this client in the history on the server, since they have already undergone transformations.  In the first case, network traffic greatly increases, and in the second case, the load on the server increases. <br><br>  The algorithm, which uses Google Docs and Wave, uses a simple but effective solution that allows you to choose between two evils.  The idea is to not send the next local operation until you have received confirmation that the previous one was successfully applied to the server.  In our case, this means that LOp2 will be sent only after we received from the server an acknowledgment message related to LOp1: <br><br><img src="https://habrastorage.org/files/b48/470/3d2/b484703d21ff4206a662d94e2f362547.jpg"><br><br>  The same approach is used by us. <br><br><h3>  Total </h3><br>  How these rules work ‚Äúlive‚Äù can be seen on the slides. <br><br><div class="spoiler">  <b class="spoiler_title">Client-Server OT in action</b> <div class="spoiler_text"><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=http://www.slideshare.net/slideshow/embed_code/52383974&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgNv3eAwSR-wTDRd6WUIAJx1FtkdQ" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></div></div><br><br><h1>  Undo Editing </h1><br>  The possibility of joint editing makes such an ordinary function, as the cancellation of user actions, very specific.  Look at how this should look like from the user. <br><br>  Suppose we have two people who edit different parts of a document.  One of them did not like the last change, and he presses the cancel button.  If the system does as the local text editors do ‚Äî it rolls back the latest change from the history of all edits, then this may well lead to the cancellation of another user‚Äôs operation.  In this case, both will be confused: <br><ul><li>  The one who initiated the cancellation will not see the expected result. </li><li>  His colleague will suddenly delete the newly entered text.  Well, or appears deleted. </li></ul><br>  This means that it is appropriate to cancel not the last operation, but the last operation of the user who initiates the cancellation.  In this case, the effect will be more expected and close to the usual, which we can observe when editing local documents.  Accordingly, each user has its own undo-redo stack. <br><br>  However, in the history of client operations, the latter may be an operation from another user that he received from the server.  Because of this, it becomes impossible to apply the approach to undo-redo, which is used when editing local documents: if you cancel from the stack of operations, the top one gets and rolls back.  In our case, we would have to somehow extract the operation from the ‚Äúmiddle‚Äù of the story and transform all the following: <br><br><img src="https://habrastorage.org/files/18a/6a7/082/18a6a708285f48608ad95714841f14fe.jpg"><br><br>  In the algorithm used by us, an important property is that operations that are already coordinated with the server do not change.  And if this property is violated, the algorithm will no longer work.  So, this principle of cancellation does not suit us. <br><br>  We need to roll back the operation, which has already plunged into the abyss of history (document operations stack).  For this we have only one way: to create a new operation, which will cancel the effect of the original one.  We assume that for each operation you can generate the inverse.  It is important that the inverse operation can be correctly applied only to the state of the document that occurs immediately after the execution of the original operation. <br><br><img src="https://habrastorage.org/files/1a8/a5b/989/1a8a5b98903b4138b9e28dbbe959ad6e.jpg"><br><br>  With the help of transformations, we can ‚Äútransfer‚Äù the inverse operation to the current state of the document on the client, as we did before with the corrections: <br><br><img src="https://habrastorage.org/files/ccc/db0/177/cccdb0177a274ae3939b7b9b8eeb4b4c.jpg"><br><br>  In the diagram (Op <sup>-1</sup> ) ‚Ä≤, this is just the desired operation.  No more changes to the existing algorithm are required: the operation is applied locally and sent to the server like any other.  Neither the server nor the other clients can distinguish the undo-operation from the usual one.  The information that this was a undo operation is saved only with the user who created it, since it is needed for redo to work correctly. <br><br><h1>  Practice </h1><br>  <i>In theory, there is no difference between theory and practice.</i> <i><br></i>  <i>But, in practice, there is.</i> <i><br></i>  <i>Johannes lambertus adriana van de snepscheut</i> <br><br>  At the moment, we already have an algorithm that allows for non-blocking simultaneous editing with the possibility of canceling operations.  At this stage, for the most part theoretical articles it is assumed that the task of constructing an algorithm has been solved.  As a ‚Äútest polygon,‚Äù an example is used with editing a single line, where there are only two editing operations: inserting and deleting a character.  Sometimes they give an example where a symbol has some property and, accordingly, a third operation appears to change its value.  I do not just mention the total number of operations, because we need to be able to transform any of the operations relative to any other, which means for N operations we need to implement N <sup>2</sup> transformations.  When there are two or three operations, this is not a problem. <br><br>  To date, the core interface of our product contains more than fifty functions for editing a document.  If we represent each of them as a separate operation, then we will have to implement and test more than 2500 transformations, which is simply physically impossible.  In addition, we are constantly adding new functionality, so this number continues to grow. <br><br>  The natural solution in this case is the rejection of a one-to-one correspondence between user actions and operations.  The set of operations should be minimal, but so that with the help of a sequence of operations it would be possible to describe any user action.  Moreover, if we want to limit the number of operations as much as possible, the operations themselves should be universal.  The point is that from the point of view of transformations there is no difference between the operations of setting the font color or its size.  Just as there is no difference between inserting a character or inserting a paragraph ‚Äî everything is inserted into a one-dimensional collection.  As a result, it turns out that there will be three fundamentally different operations: inserting an element, deleting and setting an object property. <br><br>  Products such as <a href="http://www.researchgate.net/publication/220879645_Leveraging_single-user_applications_for_multi-user_collaboration_the_coword_approach">CoWord</a> , represent the entire document as a sequential list of different types of elements: letters, carriage translations, pictures, and so on.  And for such a model of the document the three proposed operations are enough.  But the problem is that this model does not allow to fully present an office document with styles, headers, footers and tables. <br><br><h3>  Document as a tree </h3><br>  Instead of a list, it is natural to present the document as a tree, reflecting its hierarchical structure.  Simply put, the document in this model looks like this: <br><br><img src="https://habrastorage.org/files/39a/321/992/39a3219925a446719452f6ee310ac5e0.jpg"><br><br>  I have deliberately reduced the number of element types to simplify the scheme, but the meaning has been preserved.  The document is presented in the form of a tree with two types of nodes: <br><ol><li>  Nodes with a fixed structure are marked in green.  As an example, you can take the root element.  Any document within this model will always have two child nodes: a list of blocks and a set of properties. </li><li>  Collection nodes that may contain a variable number of child nodes are marked in purple.  For example, there may be a different number of blocks (paragraphs or tables) in a document.  Similarly, with the letters in the paragraph and the rows and columns in the table. </li></ol><br>  Having such a document model, you can use the same three primitive operations: insert, delete, and set a property.  At the same time, the address of the node in the document tree on which it is executed is added to each operation.  For insert or delete operations, this must be the address of the collection; for setting a property, the address of the node for which we want to change this property. <br><br><h3>  Transformations of tree operations </h3><br>  Addresses of operations help us with transformations.  Suppose we have two operations - (Operation1, address1) and (Operation2, address2).  We define the effect of the relative position of the nodes on which they are held on the Inc value ((Operation1, address1), (Operation2, address2)).  In total there can be four different cases: <br><br>  1. Nodes are the same, address1 = address2. <br><br><img src="https://habrastorage.org/files/0fa/f8d/a7b/0faf8da7b3b64e4a838d440d23163188.jpg"><br>  . <br>  In this case, the transformation takes place as if we had a flat document.  The address remains the same: <br><br>  <i>Inc ((Operation1, address1), (Operation2, address2)) = (Inc (Operation1, Operation2), address1)</i> <br><br>  2. Operation2 operates on the ancestor of the node Operation1, address2 is the prefix of address1. <br><br><img src="https://habrastorage.org/files/5ec/6f8/c7c/5ec6f8c7cfd94bd98fc4811e70d9cc7a.jpg"><br><br>  If Operation2 removes the ancestor of the Operation1 node, then as a result we will get an empty operation.  If it does not delete, Operation1 itself will not change, but its address may change if Operation2 changes the collection.  For example, if Operation1 is the insertion of a character in the second paragraph, and Operation2 is the deletion of the first paragraph, then the result is the insertion of a character with the same index, but in the first paragraph: <br><br>  <i>Inc ((Operation1, address1), (Operation2, address2)) = (Operation1, Inc (address1, Operation2))</i> <br><br>  3. Operation1 acts on the ancestor of the node Operation2, address1 is the prefix of address2. <br><br><img src="https://habrastorage.org/files/9b1/e6d/f9d/9b1e6df9d75a416fa23f0fc962e208fb.jpg"><br><br>  In this case, Operation2 does not affect Operation1: <br><br>  <i>Inc ((Operation1, address1), (Operation2, address2)) = (Operation1, address1)</i> <br><br>  4. Operation1 and Operation2 operate on different nodes, none of which is the ancestor of the other. <br><br><img src="https://habrastorage.org/files/47b/34f/fcf/47b34ffcf6d349e9bba65f718caecc30.jpg"><br><br>  Here, too, the transformation is identical: <br><br>  <i>Inc ((Operation1, address1), (Operation2, address2)) = (Operation1, address1)</i> <br><br>  These rules allow us to obtain a transformation for any pair of operations.  In addition, operations on various parts of the document will not be transformed, which has a positive effect on performance. <br><br><h3>  2D collections </h3><br>  Separately worth mentioning the tables.  I have seen several publications where authors look at OT above a hierarchical document.  However, lists have always been used as collection nodes.  When it came to tables, it was said that they can always be defined as a list of rows or columns, which in turn are a list of cells.  This approach is fundamentally wrong, since it does not allow for mutually correct transformation of operations on rows and operations on columns.  And now I will tell you why. <br><br>  Imagine that we are storing a 2 by 2 table in the form of a list of rows: <br><br><img src="https://habrastorage.org/files/08a/b79/97f/08ab7997f0764898bb49714e696130af.jpg"><br><br>  Suppose one user inserts a row at the end of the table, and the second one deletes the right column in parallel.  For the first user, its action is described by a single operation: insert (Table, 3, {Cell31, Cell32}).  The second will need two operations: remove (Row1, 2), remove (Row2, 2).  If we apply all the transformation rules described above, then as a result we will get the following table state: <br><br><img src="https://habrastorage.org/files/478/edd/c0d/478eddc0dc0a485eb1a62546e86a5000.jpg"><br><br>  Either we allow not quite rectangular tables, or we find another approach.  We chose the second option.  Or rather, they presented the tables as a separate, two-dimensional type of collections.  Unlike the list, there may be not two but four operations on them: inserting and deleting columns, and similar for rows.  And the address of the child element - the cell - is not a single numerical index, but a pair.  This approach allows to correctly represent and transform the operations on rows and columns and prevent situations with the wrong structure of the table. <br><br><h1>  Conclusion </h1><br>  On this I would like to exhale and write that this is all.  For OT, the phrase ‚Äúthe devil is in the details‚Äù is incredibly accurate, since the mere trifles turn into the need to solve fundamental problems and complicate the algorithm.  Therefore, in the real algorithm of operations on lists, we have not two, but four.  And one of them is never satisfied.  And the operation can change not only during transformations, but also at the time of execution. <br><br>  To cover all the nuances in this article is simply not possible, and we will leave them to continue, and we will end the second article. <br><br>  See you! </div><p>Source: <a href="https://habr.com/ru/post/266429/">https://habr.com/ru/post/266429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266417/index.html">Release it! Software design and design for those who care</a></li>
<li><a href="../266419/index.html">Organization of monitoring the work of employees in a small office</a></li>
<li><a href="../266421/index.html">How a month to get a lot of pumping in Data Science</a></li>
<li><a href="../266425/index.html">Magnetic core memory module in an IBM 1401 vintage mainframe</a></li>
<li><a href="../266427/index.html">Implementation of multi-threaded game engine architecture</a></li>
<li><a href="../266431/index.html">Extortionist Android / Lockerpin.A attacks US users</a></li>
<li><a href="../266433/index.html">Developing a metamodel using the Eclipse Modeling Framework (and a little about data modeling)</a></li>
<li><a href="../266435/index.html">How to learn to make games: useful resources</a></li>
<li><a href="../266437/index.html">Says Gartner: Overheated IoT and Practical Clouds</a></li>
<li><a href="../266441/index.html">Assistant program for mastering blind typing on a keyboard in Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>