<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is faster: 0 or NULL?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are three aggregate functions that are most often used in practice: COUNT , SUM and AVG . 

 And if the first has already been discussed earlier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is faster: 0 or NULL?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a80/686/6ba/a806866bac4a4449bc615f9c45a7744f.png" align="left">  There are three aggregate functions that are most often used in practice: <i>COUNT</i> , <i>SUM</i> and <i>AVG</i> . <br><br>  And if the first has already been discussed <a href="http://habrahabr.ru/post/271797/">earlier</a> , then there are interesting nuances with performance with the rest.  But let's get everything in order ... <br><br>  When using aggregate functions on the execution plan, depending on the input stream, there can be two operators: <i>Stream Aggregate</i> and <i>Hash Match</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first one may require a pre-sorted input set of values, and the <i>Stream Aggregate</i> does not block the execution of subsequent statements. <br><br>  In turn, <i>Hash Match</i> is a blocking operator (with rare <a href="http://sqlblog.com/blogs/paul_white/archive/2011/12/04/is-distinct-aggregation-still-considered-harmful.aspx">exceptions</a> ) and does not require sorting the input stream.  For <i>Hash Match</i> , a hash table is used that is created in memory and if the expected number of rows is not correctly estimated, the operator can merge the results into <i>tempdb</i> . <br><a name="habracut"></a><br>  In summary, it turns out that <i>Stream Aggregate</i> works well on small sorted data sets, and <i>Hash Match</i> does well with large, non-sorted sets and lends itself well to parallel processing. <br><br>  Now that we have overcome the theory we will start to see how the aggregate functions work. <br><br>  Suppose we need to calculate the average price among all products: <br><br><pre><code class="1c hljs">SELECT AVG(Price) FROM dbo.Price</code> </pre> <br>  According to the table with a fairly simple structure: <br><br><pre> <code class="1c hljs">CREATE TABLE dbo.Price ( ProductID INT PRIMARY KEY, LastUpdate DATE NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Price SMALLMONEY <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Qty INT )</code> </pre><br>  As we have scalar aggregation, we expect to see <i>Stream Aggregate</i> on the execution plan: <br><br><img src="https://habrastorage.org/files/a1c/468/21a/a1c46821acbd425bac16037496a5d3f6.png"><br><br>  Internally, this operator performs two aggregation operations <i>COUNT_BIG</i> and <i>SUM</i> (although this is performed as a single operation on the physical level) on the Price column: <br><br><img src="https://habrastorage.org/files/a8a/c40/5ab/a8ac405aba744f7ea4c672844d3fa510.png"><br><br>  Do not forget that the average is calculated only for <i>NOT NULL</i> , since the <i>COUNT_BIG</i> operation goes through the column, not with an asterisk.  Accordingly, such a request: <br><br><pre> <code class="1c hljs">SELECT AVG(v) FROM ( VALUES (<span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">9</span></span>), (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) ) t(v)</code> </pre><br>  will return as a result not 4, but 6. <br><br>  Now let's take a look at <i>Compute Scalar</i> , inside of which there is an interesting expression for checking division by zero: <br><br><pre> <code class="1c hljs">Expr1003 = CASE WHEN [Expr1004]=(<span class="hljs-number"><span class="hljs-number">0</span></span>) THEN <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ELSE [Expr1005]/CONVERT_IMPLICIT(money,[Expr1004],<span class="hljs-number"><span class="hljs-number">0</span></span>) END</code> </pre><br>  Let's try to calculate the total amount: <br><br><pre> <code class="1c hljs">SELECT SUM(Price) FROM dbo.Price</code> </pre><br>  The execution plan will remain the same: <br><br><img src="https://habrastorage.org/files/117/c78/985/117c78985a9e4179bc492120142fda6c.png"><br><br>  But if you look at the operations that <i>Stream Aggregate</i> performs ... <br><br><img src="https://habrastorage.org/files/a51/325/460/a51325460e8346c6bc3d001498a1f7f7.png"><br><br>  You can be a bit surprised.  Why does <i>SQL Server</i> count the amount if I only need the amount?  The answer lies in <i>Compute Scalar</i> : <br><br><pre> <code class="1c hljs">[Expr1003] = Scalar Operator(CASE WHEN [Expr1004]=(<span class="hljs-number"><span class="hljs-number">0</span></span>) THEN <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ELSE [Expr1005] END)</code> </pre><br>  If <i>COUNT is</i> not taken into account, then according to the semantics of the <i>T-SQL language</i> , when there are no rows in the input stream, then we should return <i>NULL</i> , not <i>0</i> .  This behavior works for both scalar and vector aggregation: <br><br><pre> <code class="1c hljs">SELECT LastUpdate, SUM(Price) FROM dbo.Price GROUP BY LastUpdate OPTION(MAXDOP <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><pre> <code class="1c hljs">Expr1003 = Scalar Operator(CASE WHEN [Expr1008]=(<span class="hljs-number"><span class="hljs-number">0</span></span>) THEN <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ELSE [Expr1009] END)</code> </pre><br>  Moreover, such a check is done for both <i>NULL</i> and <i>NOT NULL</i> columns.  Now we will consider examples in which the features of <i>SUM</i> and <i>AVG</i> described above will be useful. <br><br>  If we want to calculate the average, then you do not need to use <i>COUNT + SUM</i> : <br><br><pre> <code class="1c hljs">SELECT SUM(Price) / COUNT(Price) FROM dbo.Price</code> </pre><br>  Because such a request would be less efficient than using <i>AVG</i> explicitly. <br><br>  Further ... Explicitly transferring <i>NULL</i> to an aggregate function is not necessary: <br><br><pre> <code class="1c hljs">SELECT SUM(CASE WHEN Price &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty ELSE <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> END), SUM(CASE WHEN Price &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty ELSE <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> END) FROM dbo.Price</code> </pre><br>  Since in this design: <br><br><pre> <code class="1c hljs">SELECT SUM(CASE WHEN Price &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty END), SUM(CASE WHEN Price &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty END) FROM dbo.Price</code> </pre><br>  Optimizer does substitution automatically: <br><br><img src="https://habrastorage.org/files/a09/247/74a/a0924774add04d848d4ac86117545dee.png"><br><br>  But what if I want to get 0 in the results instead of <i>NULL</i> ?  Very often use <i>ELSE</i> and do not think: <br><br><pre> <code class="1c hljs">SELECT SUM(CASE WHEN Price &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END), SUM(CASE WHEN Price &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END) FROM dbo.Price</code> </pre><br>  Obviously, in this case, we will achieve the desired ... and even one warning will cease to call the eyes: <br><br><pre> <code class="1c hljs">Warning: <span class="hljs-literal"><span class="hljs-literal">Null</span></span> value is eliminated by an aggregate or other SET operation.</code> </pre><br>  Although it is best to write a query like this: <br><br><pre> <code class="1c hljs">SELECT ISNULL(SUM(CASE WHEN Price &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty END), <span class="hljs-number"><span class="hljs-number">0</span></span>), ISNULL(SUM(CASE WHEN Price &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> THEN Qty END), <span class="hljs-number"><span class="hljs-number">0</span></span>) FROM dbo.Price</code> </pre><br>  And this is good not because the <i>CASE</i> operator will work faster.  We already know that the optimizer inserts <i>ELSE NULL there</i> automatically ... So what are the advantages of the latter option? <br><br>  As it turned out, aggregation operations in which <i>NULL</i> values ‚Äã‚Äãprevail are processed faster. <br><br><pre> <code class="1c hljs">SET STATISTICS TIME ON DECLARE @i INT = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ;WITH E1(N) AS ( SELECT * FROM ( VALUES (@i),(@i),(@i),(@i),(@i), (@i),(@i),(@i),(@i),(@i) ) t(N) ), E2(N) AS (SELECT @i FROM E1 a, E1 b), E4(N) AS (SELECT @i FROM E2 a, E2 b), E8(N) AS (SELECT @i FROM E4 a, E4 b) SELECT SUM(N) -- <span class="hljs-number"><span class="hljs-number">100.000</span></span>.<span class="hljs-number"><span class="hljs-number">000</span></span> FROM E8 OPTION (MAXDOP <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  The execution took me: <br><br><pre> <code class="1c hljs">SQL Server Execution Times: CPU time = <span class="hljs-number"><span class="hljs-number">5985</span></span> ms, elapsed time = <span class="hljs-number"><span class="hljs-number">5989</span></span> ms.</code> </pre><br>  Now we change: <br><br><pre> <code class="1c hljs">DECLARE @i INT = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  And re-perform: <br><br><pre> <code class="1c hljs">SQL Server Execution Times: CPU time = <span class="hljs-number"><span class="hljs-number">6437</span></span> ms, elapsed time = <span class="hljs-number"><span class="hljs-number">6451</span></span> ms.</code> </pre><br>  Not so significant, but the reason for optimization nevertheless it gives in certain situations. <br><br>  The end of the play and the curtain?  Not.  That's not all‚Ä¶ <br><br>  As one of my friends said: <i>‚ÄúThere is neither black nor white ... The world is multicolored‚Äù</i> and therefore, finally, I will give an interesting example when <i>NULL</i> can harm. <br><br>  Create a slow function and test table: <br><br><pre> <code class="1c hljs">USE tempdb GO IF OBJECT_ID('dbo.udf') IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> DROP FUNCTION dbo.udf GO CREATE FUNCTION dbo.udf (@a INT) RETURNS VARCHAR(MAX) AS BEGIN DECLARE @i INT = <span class="hljs-number"><span class="hljs-number">1000</span></span> WHILE @i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> SET @i -= <span class="hljs-number"><span class="hljs-number">1</span></span> RETURN REPLICATE('A', @a) END GO IF OBJECT_ID('tempdb.dbo.#temp') IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> DROP TABLE <span class="hljs-meta"><span class="hljs-meta">#temp GO ;WITH E1(N) AS ( SELECT * FROM ( VALUES (1),(1),(1),(1),(1), (1),(1),(1),(1),(1) ) t(N) ), E2(N) AS (SELECT 1 FROM E1 a, E1 b), E4(N) AS (SELECT 1 FROM E2 a, E2 b) SELECT * INTO #temp FROM E4</span></span></code> </pre><br>  And execute the query: <br><br><pre> <code class="1c hljs">SET STATISTICS TIME ON SELECT SUM(LEN(dbo.udf(N))) FROM <span class="hljs-meta"><span class="hljs-meta">#temp</span></span></code> </pre><br><pre> <code class="1c hljs">SQL Server Execution Times: CPU time = <span class="hljs-number"><span class="hljs-number">9109</span></span> ms, elapsed time = <span class="hljs-number"><span class="hljs-number">11603</span></span> ms.</code> </pre><br>  Now let's try the result of the expression, which is transmitted in <i>SUM</i> , to wrap in <i>ISNULL</i> : <br><br><pre> <code class="1c hljs">SELECT SUM(ISNULL(LEN(dbo.udf(N)), <span class="hljs-number"><span class="hljs-number">0</span></span>)) FROM <span class="hljs-meta"><span class="hljs-meta">#temp</span></span></code> </pre><br><pre> <code class="1c hljs">SQL Server Execution Times: CPU time = <span class="hljs-number"><span class="hljs-number">4562</span></span> ms, elapsed time = <span class="hljs-number"><span class="hljs-number">5719</span></span> ms.</code> </pre><br>  The speed of execution has decreased by 2 times.  I‚Äôll say right away that this is not magic ... But a <a href="https://connect.microsoft.com/SQLServer/feedback/details/636382/scalar-expression-evaluated-twice-with-sum-aggregate">bug in the</a> <i>SQL Server</i> <a href="https://connect.microsoft.com/SQLServer/feedback/details/636382/scalar-expression-evaluated-twice-with-sum-aggregate">engine</a> , which <i>Microsoft</i> has already ‚Äúsort of‚Äù fixed in <i>SQL Server 2012 CTP</i> . <br><br>  The essence of the problem is as follows: the result of an expression inside the <i>SUM</i> or <i>AVG</i> functions can be executed twice if the optimizer considers that it can return <i>NULL</i> . <br><br>  Everything was tested on <i>Microsoft SQL Server 2012 (SP3) (KB3072779) - 11.0.6020.0 (X64)</i> . <br><br>  If you want to share this article with an English-speaking audience: <br>  <a href="http://blog.devart.com/what-is-faster-inside-stream-aggregate-hash-match.html">What is faster inside SUM &amp; AVG: 0 or NULL?</a> </div><p>Source: <a href="https://habr.com/ru/post/275069/">https://habr.com/ru/post/275069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275045/index.html">Iosevka - another font for coding</a></li>
<li><a href="../275047/index.html">Email from your server: pitfalls</a></li>
<li><a href="../275053/index.html">Cross-platform IDE for .NET / C # from JetBrains</a></li>
<li><a href="../275063/index.html">Where the Pixie Unicorn lives. Indie storytelling</a></li>
<li><a href="../275065/index.html">Yii 1.1.17</a></li>
<li><a href="../275071/index.html">How students become advanced programmers</a></li>
<li><a href="../275073/index.html">Problems with Sandbox when installing Vivaldi in a non-standard directory</a></li>
<li><a href="../275075/index.html">Attack on Linux users or how to build a botnet by admins</a></li>
<li><a href="../275081/index.html">What's going on in the development of corporate mobile applications</a></li>
<li><a href="../275083/index.html">Building and using Mosquitto MQTT on Intel Edison</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>