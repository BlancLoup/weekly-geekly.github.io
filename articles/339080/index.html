<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dive into Ethereum development. Part 3: user application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles ( part 1 and part 2 ) we described how to use decentralized applications on smart contracts, if you yourself do not mind being a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dive into Ethereum development. Part 3: user application</h1><div class="post__text post__text-html js-mediator-article">  In previous articles ( <a href="https://habrahabr.ru/post/336132/">part 1</a> and <a href="https://habrahabr.ru/post/336770/">part 2</a> ) we described how to use decentralized applications on smart contracts, if you yourself do not mind being a node.  But the less a user is forced to perform additional actions, the better.  To work with smart contracts, it is necessary to sign transactions with a private key, therefore, unfortunately, one cannot do without additional actions.  In this article we will look at two approaches: the first is a full-fledged decentralized application (DApp) in javascript using the Web3 library and the MetaMask plugin, the second is a similar application, but using the Ruby on Rails API and the Ethereum.rb gem to access the blockchain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d0/c5/59d0c59526d39057008845.png"></div><br><a name="habracut"></a><br>  To demonstrate the work of this DApp consider an application inspired by the <a href="https://www.ethereum.org/dao">official example</a> .  Instead of Democracy, with voting and performing arbitrary transactions, we will make a simplified Charity contract, in which anyone creates a proposal for the distribution of money (broadcast), participants vote, and after the deadline the proposal is either executed or not, depending on the result of the vote. <br>  The logic of the smart contract in this case is not very important, our goal is to demonstrate the options for user interaction with the blockchain. <br>  Consider what tools we will use a little more and then go directly to the application. <br><br><h2>  Means used </h2><br><h4>  1. MetaMask </h4><br>  This is such a plugin for the Chrome browser, the developers write that they plan for Firefox, but so far only chrome.  Download <a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn">here</a> .  The plugin does two things: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  It provides a connection to the desired Ethereum network through its remote node, thanks to which the user does not need to deploy the node at himself. </li><li>  Allows you to create new or import existing accounts to work with the blockchain.  This makes it possible to sign transactions with a private key that is stored locally with the user. </li></ul><br>  Read more about how to use the plugin can be found on the <a href="https://metamask.io/">official page</a> or <div class="spoiler">  <b class="spoiler_title">under the spoiler</b> <div class="spoiler_text">  In the plugin, you can connect to the real and test networks by clicking on the name of the network above. <br><br><img src="https://habrastorage.org/webt/59/d0/d1/59d0d19b28f56645213105.png"><br><br>  If necessary, you can import an existing key, but it is more convenient to simply create a new one. <br><br><img src="https://habrastorage.org/webt/59/d0/d1/59d0d1f97678d123222621.png"><br><br>  If you want to import a key created in Geth or Mist, select the JSON File when importing and find the file with the desired address in the ~ / .ethereum / &lt;network&gt; / keystore directories.  It should be noted that at least on Ubuntu at the time of publication of the article there is a bug with the opening of the JSON file: after selecting the file, the MetaMask window closes and no key is imported.  In this case, try opening MetaMask in a separate tab using the chrome-extension extension address: //nkbihfbeogaeaoehlefnkodbefgpgknn/popup.html <br>  By the way, by selecting the test network and pressing BUY, you can get links to resources that distribute the test broadcast.  Even for Ropsten (just press request 1 ether from faucet): <br><br><img src="https://habrastorage.org/webt/59/d0/d2/59d0d2853f639846944386.png"><br></div></div><br><h4>  2. Using the Web3.js library with the MetaMask plugin </h4><br>  Web3.js is a JavaScript library, the same one we used in Geth in the <a href="https://habrahabr.ru/post/336770/">previous article</a> .  MetaMask embeds Web3.js into every open page, so you can test simple commands directly in the javascript console in Chrome Developer Tools.  It is important to note that at the time of this writing, the current version of Web3.js is 0.20.1.  Documentation for version 0.xx is available by <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">reference</a> , not to be confused with documentation for version 1.0 ( <a href="https://web3js.readthedocs.io/en/1.0/">link</a> ). <br>  We will execute two commands, one to receive data, for example, account balance, and the second to change, for example, setting the string in the smart contract StringHolder from the <a href="https://habrahabr.ru/post/336770/">previous article</a> .  Do not forget to create an account in MetaMask, connect to the desired network (in this case, Ropsten Test Network) and go to the Developer Tools console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d0/d4/59d0d42d5b1b5955977731.png"></div><br><pre><code class="javascript hljs">&gt; web3.eth.getBalance(web3.eth.accounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(web3.fromWei(result.toNumber())); } )</code> </pre> <br>  Do not forget when calling the contract methods to pass a callback function as the last argument.  It is possible so: <br><br><pre> <code class="javascript hljs">&gt; web3.eth.getBalance(web3.eth.accounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-literal"><span class="hljs-literal">null</span></span> e {<span class="hljs-attr"><span class="hljs-attr">s</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">e</span></span>: <span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)} c:(<span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">78950</span></span>, <span class="hljs-number"><span class="hljs-number">84540000000000</span></span>] e:<span class="hljs-number"><span class="hljs-number">18</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span> __proto__:<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  Web3.js uses the <a href="">BigNumber</a> library for numeric values.  In the example above, the answer is displayed without conversion. <br>  Read commands are executed immediately, and if you want to perform a function that modifies the data in the smart contract (not marked as <code>constant</code> ), MetaMask will display a transaction signature window.  Let us demonstrate this by opening the StringHolder contract from the <a href="https://habrahabr.ru/post/336770/">previous article</a> and invoking the string setting method in it: <br><br><pre> <code class="javascript hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address = <span class="hljs-string"><span class="hljs-string">"0x65cA73D13a2cc1dB6B92fd04eb4EBE4cEB70c5eC"</span></span>; &gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> abi = [ { <span class="hljs-string"><span class="hljs-string">"constant"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"inputs"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"newString"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"setString"</span></span>, <span class="hljs-string"><span class="hljs-string">"outputs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"payable"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"function"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"constant"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"inputs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"getString"</span></span>, <span class="hljs-string"><span class="hljs-string">"outputs"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"payable"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"function"</span></span> } ]; &gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contract = web3.eth.contract(abi); &gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringHolder = contract.at(address) &gt; stringHolder.getString(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-string"><span class="hljs-string">"Hello Dolly!!! 22"</span></span> &gt; stringHolder.setString(<span class="hljs-string"><span class="hljs-string">"Hello from the other side!"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d0/d5/59d0d5fb7b125171962541.png"></div><br>  After calling the setString method, a window is displayed asking you to confirm the transaction and information on the estimated costs of gas and air.  Click Submit.  In the console you will see the transaction hash. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d0/d6/59d0d6cac8d50604188180.png"></div><br>  After some time, check that the string has changed: <br><br><pre> <code class="javascript hljs">&gt; stringHolder.setString(<span class="hljs-string"><span class="hljs-string">"Hello from the other side!"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-string"><span class="hljs-string">"0x4252c00ff25b690846ec8ad3b4266047a75a1708153bcac24066da9cb01e6db5"</span></span> &gt; stringHolder.getString(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-string"><span class="hljs-string">"Hello from the other side!"</span></span></code> </pre> <br>  Everything works as it should. <br><br><h4>  3. Ethereum.rb </h4><br>  This is a library for working with the Ruby blockchain Ethereum ( <a href="">link to github</a> ) - currently it is most actively supported. <br>  Let's try to open a StringHolder contract from the irb console: <br><br><pre> <code class="ruby hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> ‚Äúethereum.rb‚Äù &gt; abi = <span class="hljs-string"><span class="hljs-string">'[ { "constant": false, "inputs": [ { "name": "newString", "type": "string" } ], "name": "setString", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "getString", "outputs": [ { "name": "", "type": "string", "value": "Hello World!" } ], "payable": false, "type": "function" } ]'</span></span> &gt; address = <span class="hljs-string"><span class="hljs-string">"0x65cA73D13a2cc1dB6B92fd04eb4EBE4cEB70c5eC"</span></span> &gt; contract = Ethereum::Contract.create(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">"StringHolder"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">address:</span></span> address, <span class="hljs-symbol"><span class="hljs-symbol">abi:</span></span> abi) &gt; contract.call.get_string() ‚ÄúHello from the other side!‚Äù</code> </pre> <br>  <i>Note the camel case (getString) is automatically converted to snake case (get_string)</i> <br><br>  The peculiarity of calling methods here is that via <code>call</code> , only getters are called, where you just need to get data.  To perform transactions, you will need <code>transact_and_wait</code> for a synchronous call or <code>transact</code> for an asynchronous call. <br>  Let's try to call the <code>set_string</code> function for which the transaction will be created.  There are two ways: unlockAccount (deprecated) and sign transaction (more on that later). <br><br><pre> <code class="ruby hljs">&gt; Ethereum::IpcClient.new.personal_unlock_account(Ethereum::IpcClient.new.eth_coinbase[<span class="hljs-string"><span class="hljs-string">"result"</span></span>], <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>)</code> </pre> <br>  It is necessary to designate from whom the transaction is sent (the same person we have now unblocked): <br><br><pre> <code class="ruby hljs">&gt; contract.sender = Ethereum::IpcClient.new.eth_coinbase[<span class="hljs-string"><span class="hljs-string">"result"</span></span>]</code> </pre> <br>  Then you can call the setter instead of <code>call</code> substituting either <code>transact_and_wait</code> or <code>transact</code> : <br><br><pre> <code class="ruby hljs">&gt; contract.transact_and_wait.set_string(‚ÄúHello darkness, my old friend‚Äù)</code> </pre> <br>  We are waiting for the end, we call <br><br><pre> <code class="ruby hljs">&gt; contract.call.get_string()</code> </pre> <br>  We see our changes - everything works. <br><br><h2>  What should our DApp do </h2><br>  We formulate the problem.  We must have a contract, which is a charitable organization with an account.  This organization can be registered users who can act as both recipients of donations and as a vote for the proposals.  We need a way to create an offer to transfer money (air) from the organization‚Äôs account to one of the registered accounts.  To avoid the temptation to pick up the entire broadcast at a time, we introduce a restriction - you can offer no more than 1 ether.  Next comes the vote (you can vote ‚Äúfor‚Äù or ‚Äúagainst‚Äù), which cannot be completed before a certain deadline (5 minutes from the moment the proposal is created).  After the deadline, the votes continue to be received, but it should be possible to complete the vote, and if it ended with more ‚Äúfor‚Äù than ‚Äúagainst‚Äù - transfer the air from the organization's account to the recipient's account.  If more votes are ‚Äúagainst‚Äù - do nothing. <br>  In general, the application scheme is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d0/d9/59d0d9965657b978969631.png"></div><br>  Two js modules - Blockchain.js and BlockchainApi.js - are responsible for working with the blockchain.  They do the same thing, only the first one works with Web3.js and through the MetaMask node it directly accesses the blockchain, the second one makes ajax requests to the Rails API, where interaction with the blockchain via the ethereum.rb gem already occurs.  The client application itself is written in React and does not depend on which js module of the two is used. <br><br><h2>  Main Charity Contract </h2><br>  The contract is in the form of a single file, so we will not use special means for deployment, this can be done in any way, even <a href="https://habrahabr.ru/post/336132/">through Mist</a> , even <a href="https://habrahabr.ru/post/336770/">using the Geth command line</a> .  You can use our code <a href="https://github.com/rubyruby/charity-contracts">from here</a> .  In general, its scheme can be represented as: <br><br><img src="https://habrastorage.org/webt/59/d0/db/59d0db65f25d9552271350.png"><br><br>  Consider the contract code Charity.sol for logical blocks.  First comes the description of all the variables we need: <br><br><pre> <code class="hljs pgsql"> uint <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> debatingPeriodInMinutes; //    Proposal[] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> proposals; //   ,    uint <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> numProposals; //     proposals uint <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> numMembers; //    members <span class="hljs-keyword"><span class="hljs-keyword">mapping</span></span> (address =&gt; uint) <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> memberId; //        members address[] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> members; //   </code> </pre> <br>  Mapping allows the user to get his index in the array.  If a user with such an address does not exist, then the index 0 will be returned. A function will then be based on this that determines whether the user is registered with the given address.  But this introduces a requirement for an array: users must be stored in an array starting at index 1. The code responsible for this logic will be discussed further.  For now there is a structure for storage of the sentence. <br><br><pre> <code class="hljs ruby"> struct Proposal { address recipient; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  uint amount; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   string description; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   uint votingDeadline; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  bool executed; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       bool proposalPassed; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,     uint numberOfVotes; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   int currentResult; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  , ‚Äú‚Äú = +<span class="hljs-number"><span class="hljs-number">1</span></span>, ‚Äú‚Äù = -<span class="hljs-number"><span class="hljs-number">1</span></span> Vote[] votes; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         ,    mapping (address =&gt; bool) voted; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,     -  }</code> </pre> <br>  The structure of the votes, is formed into an array for each sentence <br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vote</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inSupport; <span class="hljs-comment"><span class="hljs-comment">//   address voter; //     }</span></span></code> </pre> <br>  Consider a modifier that allows us to control that the execution of the methods to which it will be added is possible only if the user is registered.  The verification code, as already mentioned, is based on the fact that non-existent mapping elements give an index of <code>0</code> , and we will keep users from index <code>1</code> : <br><br><pre> <code class="hljs ruby"> modifier onlyMembers { <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> (memberId[msg.sender] != <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-number"><span class="hljs-number">_</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }</code> </pre> <br>  <code>msg</code> is a structure by which you can get information about the caller.  In this case, <code>msg.sender</code> is the address of the account that called the method with this modifier. <br><br>  We describe the constructor of our contract, which will be executed during the deployment.  All that is required is to set the time that is allocated for voting for each proposal.  In addition, we increase the size of the members array, because we will add users based on the size, and the zero element remains reserved. <br><br><pre> <code class="hljs actionscript"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Charity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint _minutesForDebate )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// payable ,       ,       debatingPeriodInMinutes = _minutesForDebate; members.length++; }</span></span></code> </pre> <br>  Function to add user: <br><br><pre> <code class="hljs matlab"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMember</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _targetMember)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(memberId[_targetMember] == 0)</span></span></span><span class="hljs-function"> { // 0  ,     </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memberId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[_targetMember]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">members</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function">; //       ,     </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">members</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function">++; //       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">members</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[id]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_targetMember</span></span></span><span class="hljs-function">; //     } }</span></span></code> </pre> <br>  Notice the <code>require</code> function - it replaced the <code>throw</code> in older versions of solidity.  The <code>require</code> is <code>true</code> or <code>false</code> , if it is <code>false</code> , then a similar <code>throw</code> handler is triggered ‚Äî the entire transaction is rolled back. <br>  To be able to check whether the address is in the list of users, we use the following function: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> isMember( address _targetMember ) <span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> ( <span class="hljs-type"><span class="hljs-type">bool</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( memberId[_targetMember] != <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  The next function - to create a proposal, takes the address of the recipient of the donation, the amount of air in wei and a string with a description.  The onlyMembers modifier is applied to this function, which means that before the execution of the whole code, it will be verified that the calling account is registered.  Here you will see such conversions as <code>1 ether</code> and <code>1 minutes</code> .  A full list of such suffixes can be found <a href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html">here</a> , they are made for convenience and can only be applied to values, but not to variables.  But to apply to a variable, simply add 1 to the suffix, which is done in our case for conversion to seconds. <br><br><pre> <code class="hljs xml"> function newProposal( address _beneficiary, //   uint _weiAmount, //    wei string _description //   ) onlyMembers returns (uint proposalID) { require( _weiAmount <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">=</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ether</span></span></span><span class="hljs-tag">) ); //    </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">  </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">proposalID</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">proposals.length++;</span></span></span><span class="hljs-tag"> //     </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Proposal</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">storage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">proposals[proposalID];</span></span></span><span class="hljs-tag"> //      </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.recipient</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">_beneficiary;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.amount</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">_weiAmount;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.description</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">_description;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.votingDeadline</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">now</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">debatingPeriodInMinutes</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">minutes</span></span></span><span class="hljs-tag">; //          </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.executed</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">false;</span></span></span><span class="hljs-tag"> //     </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.proposalPassed</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">false;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">p.numberOfVotes</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">numProposals</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">proposalID</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">; //    </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">proposalID</span></span></span><span class="hljs-tag">; }</span></span></code> </pre> <br>  Notice here the <code>now</code> keyword is the current time, not at the time the transaction was called, but at the time the block was created.  Therefore, the deadline will be counted from the moment when the offer is already created on the blockchain. <br><br>  Despite the fact that the <code>proposals</code> are <code>public</code> , we can only receive in this way the simplest fields as an array.  That is, by calling the method, for example, <code>proposals(1)</code> in the contract, we will receive a proposal with index <code>1</code> as an array <code>{ recipient, amount, description, votingDeadline, executed, proposalPassed, numberOfVotes, currentResult }</code> , and the <code>votes</code> and <code>voted</code> arrays within the structure will not return.  But we need information about whether the user has voted for a specific proposal in order to display his vote or give an opportunity to vote.  And it is desirable to do this in one call, so we get this information when we read the structure of Proposal for display in our application using the special function <code>getProposal</code> , which accepts an account for which you need voice status and offer identifier. <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProposal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> address _member, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _proposalNumber </span></span></span><span class="hljs-function">) constant </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> address, //      </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { Proposal memory proposal = proposals[ _proposalNumber ]; <span class="hljs-comment"><span class="hljs-comment">//     int vote = getVoted( _member, _proposalNumber ); //    ( )        return ( proposal.recipient, proposal.amount, proposal.description, proposal.votingDeadline, proposal.executed, proposal.proposalPassed, proposal.numberOfVotes, proposal.currentResult, vote ); //        }</span></span></code> </pre> <br>  And this is a helper function that searches for how a particular user has voted for a particular proposal.  Returns will be: <code>0</code> - if the user has not voted, <code>1</code> - if the user has voted ‚Äúfor‚Äù, <code>-1</code> - if he has voted ‚Äúagainst‚Äù. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getVoted(address _member, uint _proposalNumber) <span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span>) { Proposal <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> p = proposals[_proposalNumber]; <span class="hljs-type"><span class="hljs-type">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> true_int = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> false_int = <span class="hljs-number"><span class="hljs-number">-1</span></span>; //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p.numberOfVotes; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.votes[i].voter == _member) //     { result = p.votes[i].inSupport ? true_int : false_int; break; //       } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Voting: for a proposal with a specific number, give a vote true (for) or false (against). <br><br><pre> <code class="hljs ruby"> function vote( uint _proposalNumber, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     bool _supportsProposal /<span class="hljs-regexp"><span class="hljs-regexp">/  ) onlyMembers returns (uint voteID) { Proposal storage p = proposals[_proposalNumber]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        require (p.voted[msg.sender] != true); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       p.voted[msg.sender] = true; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     p.numberOfVotes++; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      if (_supportsProposal) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ‚Äú‚Äù p.currentResult++; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    1 } else { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   p.currentResult--; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    1 } voteID = p.votes.length++; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       p.votes[voteID] = Vote({inSupport: _supportsProposal, voter: msg.sender}); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return p.numberOfVotes; }</span></span></code> </pre> <br>  And the last function <code>executeProposal</code> serves to complete the vote and send (or not send) the air to the recipient's address. <br><br><pre> <code class="hljs ruby"> function executeProposal(uint _proposalNumber) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      Proposal storage p = proposals[_proposalNumber]; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> ( !(now &lt; p.votingDeadline <span class="hljs-params"><span class="hljs-params">||</span></span> p.executed) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">1</span></span>)  , <span class="hljs-number"><span class="hljs-number">2</span></span>)     p.executed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.currentResult &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ‚Äú‚Äù <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> ( p.recipient.send(p.amount) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    p.proposalPassed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ‚Äú‚Äù    p.proposalPassed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        } }</code> </pre> <br>  At the end there is an empty function with the payable modifier. <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> {}</span></span></code> </pre> <br>  This is necessary so that the broadcast can be sent to the address of the contract.  In general, an empty function is a function that receives and processes all messages that are not a function call.  All we need is to make it payable, then the shipped gas will simply be credited to the contract without any additional actions.  But note that there is no other modifier on this function, so in our case you cannot send air, for example, with a call to <code>addMember</code> . <br><br><h2>  Application variation using Web3.js </h2><br>  The main application script: <br><br><ol><li>  User connects to Ropsten network via MetaMask </li><li>  If there is no air on your account, then no transaction will be possible.  We have added the function of receiving the air, which becomes available when the account balance is less than 0.1 air.  This is implemented through a third-party service to which an ajax request is made with the address to which you want to broadcast. </li><li>  Basic actions with a smart contract are available only after the user becomes a member of the organization.  To do this, call the addMember method in the smart contract. </li><li>  A member of the organization can create a proposal to transfer funds (hereinafter referred to as Proposal), or vote for an existing one. </li><li>  When the time for Proposal expires (creation time + 5 minutes), it is possible to complete it, as a result of which, depending on the distribution of votes, the broadcast will be transferred to the specified address or not. </li></ol><br>  Application demo is available by the <a href="https://rubyruby.github.io/charity/">link</a> - MetaMask version. <br>  The source code is <a href="https://github.com/rubyruby/charity">here</a> . <br><br>  Once again we draw your attention to the fact that the current version of Web3.js is 0.20.1.  But version 1.0 is already preparing for release, in which the changes are quite substantial.  As we said above, MetaMask embeds web3 into a page, and you can immediately use it.  But given that the library is actively developing, and we need to ensure that the application works for the user, you need to use your locked version, and redefine the web3 object that MetaMask embeds.  We do this <a href="">here</a> in the following method: <br><br><pre> <code class="javascript hljs"> initializeWeb3() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> web3 !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  MetaMask   const defaultAccount = web3.eth.defaultAccount; //    window.web3 = new Web3(web3.currentProvider); //    window.web3.eth.defaultAccount = defaultAccount; //    } }</span></span></code> </pre> <br>  This should be done after the <code>window.onload</code> event. <br>  One unobvious problem that is solved in this code is that if you simply make <code>window.web3 = new Web3(web3.currentProvider)</code> as suggested in the official documentation, then the default account is not picked up. <br>  Even in MetaMask, as already mentioned, you can select a network from the list.  We use the addresses of contracts in the network Ropsten, if you try to connect to these addresses in other networks - the result will be unpredictable.  Therefore, before providing access to the application, you need to check whether the user is in the network.  You can get the network ID using the command: <br><br><pre> <code class="javascript hljs">web3.version.getNetwork(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, netId</span></span></span><span class="hljs-function">) </span></span>{});</code> </pre> <br>  We do this check <a href="">here</a> and compare the result with the id for the Ropsten network - this is 3. <br><br>  A list of all network id's can be seen for example <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">here</a> in the description of net_version. <br><br>  All the logic of working with the blockchain is in the file <a href="">blockchain.js</a> . <br><br>  There are two types of functions - functions for getting data from the blockchain and functions that change data in the blockchain.  Most of the methods from web3.js are executed asynchronously and take a callback as the last parameter.  Since it is often necessary to call several methods to get data, and calling some of them depends on the result of the work of others ‚Äî it is convenient to use promises.  In version 1.0 of web3.js, asynchronous methods return promises by default. <br><br>  Let's give one example of getting information from the blockchain: <br>  The <code>getCurrentAccountInfo</code> function returns the address of the current account, the balance and the flag of whether this account is a member of the organization. <br><br><pre> <code class="javascript hljs">Blockchain.prototype.getCurrentAccountInfo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({}); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> balancePromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ web3.eth.getBalance(address, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ err ? reject(err) : resolve(web3.fromWei(res).toNumber()); }); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorizedPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contractInstance.isMember(address, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ err ? reject(err) : resolve(res); }); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([balancePromise, authorizedPromise]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ resolve({ <span class="hljs-attr"><span class="hljs-attr">address</span></span>: address, <span class="hljs-attr"><span class="hljs-attr">balance</span></span>: data[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-attr"><span class="hljs-attr">isMember</span></span>: data[<span class="hljs-number"><span class="hljs-number">1</span></span>] }); }); }); };</code> </pre> <br>  We now consider the function of changing data in the blockchain, for example, the function of adding an organization member. <br><br><pre> <code class="javascript hljs">Blockchain.prototype.becomeMember = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contractInstance.addMember(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ err ? reject(err) : resolve(res); }); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); };</code> </pre> <br>  As you can see, the syntax is no different from the previous example, only the execution of this function will result in the creation of a transaction to change the data in the blockchain. <br>  When calling any function of the smart contract, as a result of which a transaction is created, MetaMask prompts the user to confirm this transaction or reject it.  If the user confirms the transaction, the function returns the transaction hash. <br>  One non-obvious point is how to know if the transaction was successful or not. <br>  Determine the status of the transaction can be based on the amount of gas that was used.  If the maximum available amount of gas is used, then either an error occurred during execution, or there was not enough gas to complete the transaction.  We check the status as follows. <br><br><pre> <code class="javascript hljs">Blockchain.prototype.checkTransaction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transaction</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> txPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ web3.eth.getTransaction(transaction.transactionHash, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ err ? reject(err) : resolve(res); }); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> txReceiptPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ web3.eth.getTransactionReceipt(transaction.transactionHash, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ err ? reject(err) : resolve(res); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([txPromise, txReceiptPromise]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tx = res[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> txReceipt = res[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> succeeded = txReceipt &amp;&amp; txReceipt.blockNumber &amp;&amp; txReceipt.gasUsed &lt; tx.gas; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> failed = txReceipt &amp;&amp; txReceipt.blockNumber &amp;&amp; txReceipt.gasUsed == tx.gas; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = transactionStates.STATE_PENDING; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (succeeded) { state = transactionStates.STATE_SUCCEEDED; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failed) { state = transactionStates.STATE_FAILED; } resolve(state); }); }); };</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating a new transaction, we add it to localStorage and periodically poll its status until we know that it has completed successfully or not. </font><font style="vertical-align: inherit;">The transaction monitoring logic is in the file - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transactions-storage.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application variant using Ruby on Rails and ethereum.rb heme </font></font></h2><br> -     ,  .       ,     .   ,       ,  ,        .   -         ,            .                .   ,  web3.js,        ,          .     Ruby on Rails,      ethereum.rb,     ,   web3.js. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demonstration of the application is available by </font></font><a href="https://rubyruby.github.io/charity/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Rails API version. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code is </font></font><a href="https://github.com/rubyruby/charity-api"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To demonstrate the work with ethereum.rb, we made a similar set of functions described in blockchain.js. The code for working with the blockchain can be viewed </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we will describe the main points and, possibly, the differences. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is that now we do not have access to the user account, so we need to do some authorization process and create an account for each user in the blockchain. The authorization process in this example is simplified as much as possible; we simply generate a token that is stored in the browser's LocalStorage, and which is used to authorize requests to the API. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the account management scheme is as follows:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The user clicks the Create Account button, a user with a unique token for authorization is created on the server in the database, an account is created for connecting to the blockchain and a private key for the account is stored in the database, the token is returned to the user for further authorization. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The user makes requests to the API using auth token for authorization. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The user's private key from the database is used to sign transactions. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the js version, there are two types of methods - those that take data from the blockchain, and those that change them. </font><font style="vertical-align: inherit;">The first ones are quite simple and how they work is clear from the example.</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proposals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> count = @contract_instance.call.num_proposals to = count - <span class="hljs-number"><span class="hljs-number">1</span></span> from = count &gt; PROPOSALS_LIMIT ? count - PROPOSALS_LIMIT : <span class="hljs-number"><span class="hljs-number">0</span></span> res = (from..to).map <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|idx|</span></span> proposal = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address @contract_instance.call.get_proposal(address, idx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> @contract_instance.call.proposals(idx) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Proposal.new(proposal, idx) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> res.sort_by(&amp;<span class="hljs-symbol"><span class="hljs-symbol">:index</span></span>).reverse <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methods that change the data in the blockchain - create a transaction that must be signed with a private key. For working with private keys, </font></font><a href="https://github.com/se3000/ruby-eth"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heme Eth is used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Below is the process of creating a new account for the blockchain and signing the transaction with a private key.</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_account</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_key</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eth</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Key</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_key</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downcase</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_key</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">private_hex</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_transactions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(private_key_hex)</span></span></span></span> key = Eth::Key.new <span class="hljs-symbol"><span class="hljs-symbol">priv:</span></span> private_key_hex <span class="hljs-comment"><span class="hljs-comment">#     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@contract</span></span></span><span class="hljs-comment">_instance.key = key #         res = yield(</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@contract</span></span></span><span class="hljs-comment">_instance) #    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@contract</span></span></span><span class="hljs-comment">_instance.key = nil #      res end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the method </font></font><code>signed_transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it takes a private key and a block of code that we want to execute using this key. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the database, the key is stored in a binary form, from which the key object is created using the heme Eth. </font><font style="vertical-align: inherit;">Next, this key is assigned to the field of the </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contract instance. </font><font style="vertical-align: inherit;">The signature of transactions occurs automatically in the ethereum.rb geme if the </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key is specified </font><font style="vertical-align: inherit;">in the </font><font style="vertical-align: inherit;">contract </font><font style="vertical-align: inherit;">field </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">After calling the desired method, or several methods, reset the key in order not to accidentally send more transactions from the same account. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an example of use, </font></font><code>signed_transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consider the completion method Proposal, which calls the method </font></font><code>executeProposal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the smart contract:</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_proposal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proposal_index, options={})</span></span></span></span> tx = signed_transactions(options[<span class="hljs-symbol"><span class="hljs-symbol">:private_key</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|contract_instance|</span></span> contract_instance.transact.execute_proposal(proposal_index) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tx.id <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method returns the transaction hash. </font><font style="vertical-align: inherit;">The logic of checking the status of a transaction is similar to the one we used in the js version.</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transaction_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx_hash)</span></span></span></span> tx = @client.eth_get_transaction_by_hash(tx_hash)[<span class="hljs-string"><span class="hljs-string">'result'</span></span>] tx_receipt = @client.eth_get_transaction_receipt(tx_hash)[<span class="hljs-string"><span class="hljs-string">'result'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx_receipt block_number = tx_receipt[<span class="hljs-string"><span class="hljs-string">'blockNumber'</span></span>] gas_used = tx_receipt[<span class="hljs-string"><span class="hljs-string">'gasUsed'</span></span>].to_i(<span class="hljs-number"><span class="hljs-number">16</span></span>) gas = tx[<span class="hljs-string"><span class="hljs-string">'gas'</span></span>].to_i(<span class="hljs-number"><span class="hljs-number">16</span></span>) { <span class="hljs-symbol"><span class="hljs-symbol">succeeded:</span></span> block_number &amp;&amp; gas_used &lt; gas, <span class="hljs-symbol"><span class="hljs-symbol">failed:</span></span> block_number &amp;&amp; gas_used == gas } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> See how it works </font></font></h2><br>     <a href="https://rubyruby.github.io/charity/"></a> . <br>       - ,           ‚Äî    <code>0xe79d8738f0769ec69f09cef4cd497c9cc477733e</code> ‚Äî  Ropsten. <br><br><h2>  What is the result? </h2><br>         ,    .       Ruby        MetaMask  . ,      ,      ,            javascript  ruby.      . <br>              .      ! <br><br>     Ethereum: <br> <a href="https://habrahabr.ru/post/336132/"> 1: </a> <br>  <a href="https://habrahabr.ru/post/336770/">Part 2: Web3.js and gas</a> </div><p>Source: <a href="https://habr.com/ru/post/339080/">https://habr.com/ru/post/339080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339066/index.html">Information security in process control systems: attack vector interface converters</a></li>
<li><a href="../339070/index.html">Winning the nomination ‚ÄúThe best startup with the prospect of entering the American market‚Äù, Spb Startup Day 2017 and thoughts about pitches</a></li>
<li><a href="../339072/index.html">Affixing a project to a partner and new 3CX call center reports</a></li>
<li><a href="../339074/index.html">How to legalize the sale of game items</a></li>
<li><a href="../339078/index.html">Periods of sidereal days in radioactive decay</a></li>
<li><a href="../339082/index.html">The digest of interesting materials for the mobile developer # 223 (September 25 - October 1)</a></li>
<li><a href="../339084/index.html">Liquibase: an example of an automated roll forward of changes to a relational database</a></li>
<li><a href="../339086/index.html">Rethinking drag & drop</a></li>
<li><a href="../339090/index.html">ggplot2: how to easily combine multiple graphs in one, part 3</a></li>
<li><a href="../339092/index.html">Classic 2D quest or how our two years of development went. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>