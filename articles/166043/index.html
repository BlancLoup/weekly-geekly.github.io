<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>jsiedit: idea and creation of a convenient WYSIWYM plug-in editor with an example for Habrahabr</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 The article describes an approach to creating a convenient Javascript tool for online text editing. As an example, created a prototype ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>jsiedit: idea and creation of a convenient WYSIWYM plug-in editor with an example for Habrahabr</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  The article describes an approach to creating a convenient Javascript tool for online text editing.  As an example, created a prototype for editing articles on Habr√© ( <a href="http://habrahabr.ru/sandbox/add/jsiedit_bookmarklet/">described below</a> ).  With it, now and make changes to this article. <br><br>  I was faced with the task of choosing an online editor for texts on the site.  The most obvious solution would be one of the WYSIWYG editors.  But I did not like this option for several reasons.  First, many vulnerabilities of popular CMS systems are associated with WYSIWYG editors.  Secondly, after publication, the text will often differ from what was in the editor.  Thirdly, such editors are difficult to expand to support new tags and elements.  Therefore, I stopped at the WYSIWYM editor. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Simultaneously with the choice of the WYSIWYM editor, a question arose with the choice of a markup language.  Should I use Wiki or Markdown syntax, maybe TeX-like language or even HTML directly, and for some tasks, bbCode may be enough?  After some reflection, I came to the conclusion that data can be stored in any format, but with the obligatory clear separation of content and attributes.  This will ensure that even a change in the display algorithms does not distort the information.  As for editing, the user can be given the opportunity to change the data in a convenient way. <br><br><h4>  Problem </h4><br>  I have a huge complaint about existing implementations of online editors.  They are inconvenient because the view is separate from the code.  Of course, it‚Äôs worth arguing that this is the basis of WYSIWYM.  That's right, but let's consider a specific situation. <br><br>  Suppose that you write an article on Habr√© or the answer to the forum.  The syntax of the corresponding tags is familiar, therefore there are no problems with entering text.  If you need to insert an image or otherwise select an element, you can select the appropriate tag on the toolbar or enter it manually.  The first version of the text is ready, but to check the formatting before sending you will need to click the "Preview" button.  And only here appears not only the source code with all the tags, but also its specific presentation. <br><br>  In the course of viewing the already formatted text, find a typo or want to correct and supplement something.  There is a problem.  An erroneous place has already been found in the preview area, but to correct it, it is necessary to return to the editor, where among the set of tags to find the fragment that is to be corrected. <br><br>  This problem is well seen in the wiki or with the CMS pages, when, when you try to slightly correct a sentence, you have to edit the entire document.  And the larger the document, the harder the user.  He has already found a place that should be corrected in a visual representation, but he needs to re-go through this entire search path, but already in the source code. <br><br><h4>  Decision </h4><br>  The ability to dynamically connect an editor for a fragment selected by a user looks natural.  Found and looked at the following implementations: <a href="http://www.appelsiini.net/projects/jeditable/custom.html">Jeditable</a> , <a href="http://code.google.com/p/jquery-in-place-editor/">jquery-in-place-editor</a> , <a href="http://www.codenothing.com/archives/2009/inline-text-edit/">jQuery Plugin: In-Line Text Edit</a> , <a href="http://madrobby.github.com/scriptaculous/ajax-inplaceeditor/">Ajax.InPlaceEditor</a> , <a href="http://www.editablegrid.net/">EditableGrid</a> , <a href="http://dev.justinmaier.com/inlineEdit3/">InlineEdit 3</a> .  The disadvantage of all is the same: they allow you to load the editor only for a single element, because they do not support formats.  Therefore, it was decided to make the editor himself and "reinvent the wheel." <br><br>  So <a href="https://github.com/praestans/jsiedit"><b>jsiedit</b></a> appeared. <br><br>  During the writing of the article I came across <a href="http://imperavi.com/redactor/examples/click-to-edit/">Redactor</a> , which allows you to turn on the editor for the whole text, but there again the block is set in advance, and this is also the WYSIWYG editor.  <a href="http://imperavi.com/redactor/examples/air/">Closest</a> to my idea is <a href="http://imperavi.com/redactor/examples/air/">Redactor Air mode</a> , but this is only formatting. <br><br><h5>  Jsiedit goals and objectives </h5><br>  At the initial stage of implementation, the following key requirements were identified: <br><ul><li>  The user should be able to edit the formatted text; </li><li>  The volume of the edited block should be determined by the user. </li></ul><br><br><h5>  Implementation </h5><br>  So, it was necessary to solve two problems.  Let's start with the ability to edit formatted text.  Take any set of tags, for example, bbCode.  Suppose that initially the document was created in this format and the text is stored on the server with bbCode tags.  When the page is displayed to the user on the server, bbCode tags are converted to the corresponding HTML constructs. <br>  Now the user wants to edit part of the already formatted text.  It turns out that we need to get the original bbCode tags for the selected fragment.  There may be two approaches.  First, you can dynamically (on the client) convert the HTML code into the corresponding bbCode text.  Secondly, you can save bbCode tag information in HTML attribute tags in advance: <br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> ,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-bbCode</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"b"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> .<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  You can also consider the option when bbCode is dynamically requested from the server for specific elements, but this will require more serious work on the server side. <br>  When designing, I did not choose one of these three options, but decided to use the callback function so that the developer himself decided how the HTML presentation should be converted to the required format.  In the examples I used dynamic HTML conversion. <br><br>  After completing the input, you must perform the reverse transformation and save the changes to the server.  In this case, it was again decided to use the callback function and allow the developer to decide for himself what to do. <br><br>  <b>Text selection</b> <br><br>  Now consider the second task - providing the user the opportunity to choose which piece of text he wants to edit.  There is a good article <a href="http://habrahabr.ru/post/55922/">Range, TextRange and Selection</a> about mouse <a href="http://habrahabr.ru/post/55922/">selection</a> , so I‚Äôll not describe the objects and Javascript functions. <br><br>  The question remains convenience by the user.  Imagine that I selected a few words in the sentence with the mouse and launched the editor.  What exactly did I want to edit: only these two words, the whole sentence or the whole paragraph?  And if I selected words not completely, but only several letters?  In this case, I think that it should be possible to edit the entire paragraph, that is, the enclosing tag.  But the next ambient tag may not be &lt;p&gt;, but another, for example, &lt;b&gt;: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> (!) <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  If we select "(!)", Then the editor should be displayed only for "internal (!) Selection" or for the whole paragraph?  I believe that here the user needs to be given the opportunity to edit the entire paragraph, but for flexibility it was decided to enable the callback function, which for each DOM element will indicate whether activation of the editor is possible.  A similar function can be implemented like this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_fn_sample_tag_check</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elem</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (elem.tagName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'P'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DIV'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'SPAN'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><br>  The result is the following algorithm for determining the selected range: <br><pre> <code class="javascript hljs">elem = range.commonAncestorContainer; <span class="hljs-comment"><span class="hljs-comment">//     while (elem &amp;&amp; !fn_is_valid_for_edit(elem)) //  callback  { elem = elem.parentNode; //    }</span></span></code> </pre> <br><br>  All right, but here we can wait for a trap.  Let's consider the following example: <pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>...     ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>      , , .  ,<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>  .<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>       .<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> ...       ...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  If we just take <i>commonAncestorContainer</i> , we will get a &lt;div&gt; and give the user all the text for editing.  On the other hand, the user most likely wants to edit only the two highlighted paragraphs.  In this case, we need to expand each selection to full coverage of the tags &lt;p&gt; and stop. <br>  The Range object has suitable properties: <i>startContainer</i> and <i>endContainer</i> .  But here it is necessary to align the containers to one level, so that they were brothers.  The result is the following code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prnt = rng.commonAncestorContainer; <span class="hljs-comment"><span class="hljs-comment">//     var sc = rng.startContainer; //  ""  var ec = rng.endContainer; //  ""  if ((sc == prnt) || (ec == prnt)) //          { sc = prnt; ec = prnt; } else //       { while (sc.parentNode != prnt) { sc = sc.parentNode; } while (ec.parentNode != prnt) { ec = ec.parentNode; } }</span></span></code> </pre><br>  To this code, you must add the previous code to check the possibility of editing a particular block.  Use the <i>setStartBefore</i> and <i>setEndAfter methods</i> to create a range: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rng_new = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createRange(); rng_new.setStartBefore(sc); rng_new.setEndAfter(ec);</code> </pre> <br><br>  This completes the task of determining the selected block. <br><br>  <b>Editor Display</b> <br><br>  The next step was to display the editor.  It can be displayed in a separate window, be fixed on the initial page, but I was interested in the option when the editor appears in the place of the edited text itself.  Initially, the task seemed quite simple and the following code was written: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tarea = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"textarea"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     tarea.value = fn_get_text_for_range(rng_new); //     tarea.style.width = rng_new.startContainer.clientWidth; //    rng_new.startContainer.parentNode.insertBefore(tarea, rng_new.startContainer); //       rng_new.deleteContents(); //     </span></span></code> </pre><br>  When executing this code, the reality was very different from the predicted result.  The reason was that the <i>startContainer</i> attribute <i>turned</i> out to be the ‚Äúancestor‚Äù for my selection.  I can explain this by saying that the new range starts before the selected block.  As a result, I decided to use the previously calculated variables <i>sc</i> and <i>ec</i> . <br>  The next surprise was associated with an attempt to add an object to the range.  In practice, it turned out that the added object fell into the range and was destroyed by the next line.  To avoid this, the editing area began to be created after the range.  Additionally, I decided to approximately determine the height for the editor.  The result is the following code: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tarea = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"textarea"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     tarea.value = fn_get_text_for_range(rng_new); //     tarea.style.width = ec.clientWidth + 'px'; //    if (sc == ec) { tarea.style.height = Math.min(document.body.clientHeight / 2, sc.clientHeight) + 'px'; //    } else { tarea.style.height = Math.min(document.body.clientHeight / 2, sc.clientHeight + ec.clientHeight) + 'px'; //    } ec.parentNode.insertBefore(tarea, ec.nextSibling); //     rng_new.deleteContents(); //     </span></span></code> </pre><br>  A pair of buttons has been added to the textarea for the ability to save results and cancel editing. <br><br>  The last question was the challenge to the editor.  The editor can be activated, for example, by pressing a certain button on the page, from the context menu, automatically when you select the text while pressing Alt, etc.  I decided to add the simplest method - displaying the button next to the place where the selection was stopped. <br><br>  This required adding a <i>mouseup</i> event <i>handler</i> .  The position for the output button determined by the attributes <i>pageX</i> and <i>pageY</i> .  It turned out about the following: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_mouseup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> btn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"input"</span></span>); btn.type = <span class="hljs-string"><span class="hljs-string">"button"</span></span>; btn.value = <span class="hljs-string"><span class="hljs-string">"Edit"</span></span>; btn.style.position = <span class="hljs-string"><span class="hljs-string">'absolute'</span></span>; btn.style.top = event.pageY + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; btn.style.left = event.pageX + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; btn.onclick = fn_start_editor; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(btn); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_onload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.addEventListener(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>, jsiedit_mouseup, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"DOMContentLoaded"</span></span>, jsiedit_onload, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  This code does not work correctly, because it creates a new ‚ÄúEdit‚Äù button each time the mouse button is released.  To correct, it is enough to save the current state in a global variable and change it depending on user actions. <br><br>  At this first version of jsiedit was ready. <br><br><a name="jsiedit_habr"></a><h5>  Editor for Habrahabr </h5><br>  As a demonstration of possibilities, it was decided to create a prototype for Habr.  I felt the need for such an editor when writing the first article, because it turned out to be great, and without a preview it was difficult and inconvenient to look for errors.  The situation was aggravated by the prohibition on resizing the input form.  As a result, the original text was written in notepad.  <a href="http://habrahabr.ru/sandbox/add/jsiedit_bookmarklet/">Here</a> you can read about running an example to try it yourself. <br><br>  The created editor should allow editing any text in the preview area, and after saving, edit both the edited text and its source in the input field.  It was supposed to use a bookmarklet as a launch.  Actually, this is how it all works. <br><br>  Consider the problems encountered during the creation of the editor. <br><br>  <b>No paragraphs</b> <br><br>  The first difficulty was the fact that there are no paragraphs in the Habr texts.  Instead, when saving, just line breaks are used &lt;br /&gt;.  As a result, the edited block should be limited to some tag-boundaries.  Let's look at the following generated HTML code: <br><pre> <code class="html hljs xml">  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h4</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h4</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>   ,       "P".<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>  ,    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">i</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">i</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>.     "BR"<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>    .<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>  </code> </pre><br>  All text is in one DIV, so the previous algorithm will return all text for editing.  In this case, we need to ‚Äúcut out‚Äù the block between the two nearest BR tags.  To do this, we can move on the properties of <i>previousSibling</i> and <i>nextSibling</i> . <br><br>  The most difficult at this stage was the choice of approach to the definition of functions for checking nodes.  As a result, it was decided that the function would produce an array of logical properties for this node: <br><ol><li>  This node can be independently selected. </li><li>  The node itself must be included in the selection. </li><li>  This node can be a common ancestor to choose from. </li><li>  This node can be a limiting node when choosing brothers. </li></ol><br>  The result was the following check function: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_fn_sample_check_node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (node.tagName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'BR'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'P'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DIV'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'SPAN'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><br>  If we take into account the specifics of the preview on Habr√©, then we get the following function: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_fn_sample_habr_check_node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (node.tagName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'BR'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DIV'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.className == <span class="hljs-string"><span class="hljs-string">'content html_format'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><br>  Taking into account the new function, the block for determining the boundaries of the selected data was rewritten: <br><div class="spoiler">  <b class="spoiler_title">function jsiedit_get_bounds</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsiedit_get_bounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn_check_node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sel = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.getSelection(); <span class="hljs-comment"><span class="hljs-comment">//    if (!(typeof sel === 'undefined')) // ,  -   { if (sel.rangeCount == 1) //      { var rng = sel.getRangeAt(0); //  range   var prnt = rng.commonAncestorContainer; //     var sc = rng.startContainer; //  ""  var ec = rng.endContainer; //  ""  if ((prnt.tagName == 'DIV') || (prnt.tagName == 'SPAN')) { if (prnt == sc) sc = prnt.childNodes.item(rng.startOffset); if (prnt == ec) ec = prnt.childNodes.item(rng.endOffset); } var chk = fn_check_node(prnt); var include_bounds = [true, true]; //     if (chk &amp;&amp; chk[2] &amp;&amp; (sc != prnt) &amp;&amp; (ec != prnt)) //      ,       { while (sc.parentNode != prnt) { sc = sc.parentNode; } while (ec.parentNode != prnt) { ec = ec.parentNode; } } else if (chk &amp;&amp; chk[0]) //     ,  { return [prnt, chk[1]]; } else //   ,    { while (prnt.parentNode) { chk = fn_check_node(prnt.parentNode); if (chk &amp;&amp; chk[2]) { sc = prnt; ec = prnt; prnt = prnt.parentNode; break; } else if (chk &amp;&amp; chk[0]) { return [prnt.parentNode, chk[1]]; } prnt = prnt.parentNode; if (!prnt.parentNode) return false; } } chk = fn_check_node(sc); if (chk &amp;&amp; chk[0]) //      { } else { while (sc.previousSibling) //  ""  { sc = sc.previousSibling; chk = fn_check_node(sc); if (chk &amp;&amp; chk[3]) { include_bounds[0] = chk[1]; //      break; } } } chk = fn_check_node(ec); if (chk &amp;&amp; chk[0]) //      { } else { while (ec.nextSibling) //  ""  { ec = ec.nextSibling; chk = fn_check_node(ec); if (chk &amp;&amp; chk[3]) { include_bounds[1] = chk[1]; //      break; } } } return [sc, ec, include_bounds[0], include_bounds[1]]; } } return false; }</span></span></code> </pre> <br></div></div>  During the verification of the first version of jsiedit, sometimes instead of the selected fragment in the editor appeared all the text.  The reason for this turned out to be that at the beginning of selection on a void, the system returned the ancestor as <i>startContainer</i> , and in <i>startOffset</i> the child element was saved from which the selection was coming.  The situation is similar with the ending.  So I had to use the following code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((prnt.tagName == <span class="hljs-string"><span class="hljs-string">'DIV'</span></span>) || (prnt.tagName == <span class="hljs-string"><span class="hljs-string">'SPAN'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prnt == sc) sc = prnt.childNodes.item(rng.startOffset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prnt == ec) ec = prnt.childNodes.item(rng.endOffset); }</code> </pre> <br>  It is possible that it would be more correct to perform a check by the type of tag, but for the prototype I was also satisfied with this check. <br><br>  <b>Text conversion</b> <br><br>  The work of the editor required two conversion functions.  The first is to create a code in the Habra markup language from the fragment selected on the page.  This is a fairly simple part, since you can do a DOM traversal and convert the tags separately. <br><br>  The inverse transformation can be performed using the preview mechanism already existing on the Habrahabr - send the corrected text to the server and get the HTML code back.  But I decided to do this conversion on the client side.  Originally tried to find a ready-made HTML parser on Javascript.  Unfortunately, the found implementations did not suit me.  Then I realized that I would need to write a parser from scratch and reinvent the next bike.  Since this is not a quick deal, it was decided to postpone the parser for individual articles, and for the prototype to find at least a temporary solution.  As the simplest approach, it was decided to simply add a transformation for non-standard tags.  The result was the following function: <br><pre> <code class="javascript hljs">jsiedit_fn_sample_habr_produce = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rep = [ [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;source\s+lang=/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pre&gt;&lt;code class='</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;\/source&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;/code&gt;&lt;/pre&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/\n/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;hh\s+user=['"]([^'"]+)['"]\s*\/&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;a href="http://habrahabr.ru/users/$1/" class="user_link"&gt;$1&lt;/a&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;spoiler\s+title=['"]([^'"]+)['"]&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;div class="spoiler"&gt;&lt;b class="spoiler_title"&gt;$1&lt;\/b&gt;&lt;div class="spoiler_text"&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;\/spoiler&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;/div&gt;&lt;/div&gt;'</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = src; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rep.length; i++ ) { str = str.replace(rep[i][<span class="hljs-number"><span class="hljs-number">0</span></span>], rep[i][<span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; };</code> </pre> <br>  But then I had to deal with this function in detail.  There was a problem with the program codes - tag <i>&lt;source&gt;</i> .  All tags included in it should not be interpreted, but they should be interpreted outside these blocks.  Because of this, the formatting began to ‚Äúbreak‚Äù. <br>  One of the working solutions was to automatically replace all the characters "&lt;" with "&amp; lt;"  when receiving the code.  Although it worked, the resulting code in the editor was too ugly.  As a result, proceeded to refine the function.  The algorithm chose the following: find all the pieces of code that include the code, and then replace all the critical characters inside them.  The result is the following conversion: <br><pre> <code class="javascript hljs">jsiedit_fn_sample_habr_produce = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn_source = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = s.match(<span class="hljs-regexp"><span class="hljs-regexp">/^&lt;source\s+lang=([^&gt;]*)&gt;([\s\S]*)&lt;\/source&gt;$/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;pre&gt;&lt;code class='</span></span> + res[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span> + res[<span class="hljs-number"><span class="hljs-number">2</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/&gt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>) + <span class="hljs-string"><span class="hljs-string">'&lt;/code&gt;&lt;/pre&gt;'</span></span>; res = s.match(<span class="hljs-regexp"><span class="hljs-regexp">/^&lt;source&gt;([\s\S]*)&lt;\/source&gt;$/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;pre&gt;&lt;code&gt;'</span></span> + res[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/&gt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>) + <span class="hljs-string"><span class="hljs-string">'&lt;/code&gt;&lt;/pre&gt;'</span></span>; res = s.match(<span class="hljs-regexp"><span class="hljs-regexp">/^&lt;pre&gt;([\s\S]*)&lt;\/pre&gt;$/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;pre&gt;'</span></span> + res[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/&gt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>) + <span class="hljs-string"><span class="hljs-string">'&lt;/pre&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/&gt;/g</span></span>,<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rep = [ [<span class="hljs-regexp"><span class="hljs-regexp">/(&lt;source\s([\s\S])*?&lt;\/source&gt;)|(&lt;source&gt;([\s\S])*?&lt;\/source&gt;)|(&lt;pre&gt;([\s\S])*?&lt;\/pre&gt;)/gi</span></span>, fn_source], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;anchor&gt;([^&lt;]*)&lt;\/anchor&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;a name="$1"&gt;&lt;/a&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/\n/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;hh\s+user=['"]([^'"]+)['"]\s*\/&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;a href="http://habrahabr.ru/users/$1/" class="user_link"&gt;$1&lt;/a&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;spoiler\s+title=['"]([^'"]+)['"]&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;div class="spoiler"&gt;&lt;b class="spoiler_title"&gt;$1&lt;\/b&gt;&lt;div class="spoiler_text"&gt;'</span></span>], [<span class="hljs-regexp"><span class="hljs-regexp">/&lt;\/spoiler&gt;/gi</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;/div&gt;&lt;/div&gt;'</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = src; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rep.length; i++ ) { str = str.replace(rep[i][<span class="hljs-number"><span class="hljs-number">0</span></span>], rep[i][<span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; };</code> </pre><br>  It is likely that this code can be made much nicer, but now the editor for Habr was created only as a prototype - the rationale for the idea.  As needed, functionality can be improved and additional tags added.  I think that regular expressions will be enough.  The idea of ‚Äã‚Äãimplementing the parser has lowered the priority. <br><br><h4>  Conclusion </h4><br>  Summing up, I want to emphasize that the purpose of this article was to describe the idea of ‚Äã‚Äãcreating a javascript in-place WYSIWYM editor and a specific approach to implementation.  I would be glad if such an editor would interest someone else.  Please write your opinion.  Maybe there are already more interesting solutions? <br><br><h5>  Questions and answers </h5><br>  <b>Q1:</b> Why is xxxxxxx not used?  Why aren't all errors processed?  Why does the code not work in the yyyyyyy browser? <br>  <b>A1:</b> I tried to explain the idea of ‚Äã‚Äãan in-place WYSIWYM editor.  The prototype is a proof of concept that works in FF18, where now I write these lines.  While I was the only interested consumer.  If you are interested in the development of this library, then write.  The information provided is sufficient to ensure the work in the required browsers, to connect the necessary library or framework. <br>  <b>Addition:</b> The script is adjusted to work in browsers based on WebKit. <br><br>  <b>Q2:</b> Why the bookmarklet for Habr does not highlight the syntax when saving?  Why aren't all tags supported? <br>  <b>O2:</b> If there is interest, then all this can be realized.  Of the remaining tags, first of all I would implement &lt;video&gt;. <br><br>  <b>Q3:</b> What are your next plans? <br>  <b>A3:</b> It will depend very much on your reaction.  <strike>First, we need to add support for editing articles (now I can not check), and not just the creation of new ones.</strike>  (already added) Secondly, the elimination of known errors and the expansion of the list of supported tags.  Then, most likely, I'll start with Add-On for FF to get rid of the bookmarklet. <br><br>  <b>Q4:</b> Where can I find the source code? <br>  <b>O4:</b> Everything is on the project page on github: <a href="http://praestans.github.com/jsiedit/">http://praestans.github.com/jsiedit/</a> . <br><br><a name="jsiedit_bookmark"></a>  <b>Q5:</b> How to use jsiedit for Habrahabr? <br>  <b>O5: It is</b> easiest to start as a bookmarklet ( <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D0%25BA%25D0%25BC%25D0%25B0%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B5%25D1%2582">what is it</a> ).  When creating a new theme, you need to make a preview, after which an editor will be activated in the preview area when the mouse is selected.  When you save all the data from the preview area will be transferred to the input window. <br><br>  <a href="">Here is an image with detailed instructions.</a> <br><br>  This is a link to a bookmarklet (it should be bookmarked).  Here is the self-formatted text of a bookmarklet: <br><pre> <code class="javascript hljs">javascript: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>); a.type = <span class="hljs-string"><span class="hljs-string">'text/javascript'</span></span>; a.src = <span class="hljs-string"><span class="hljs-string">'http://praestans.github.com/jsiedit/lib/habr_bmk.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'head'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].appendChild(a); })();</code> </pre><br><br>  <b>Warning:</b> only the following tags are supported: A, ANCHOR, B, BLOCKQUOTE, BR, EM, H1, H2, H3, H4, H5, H6, HABRACUT, HH, HR, I, IMG, LI, OL, SOURCE, STRIKE, STRONG, SUB, SUP, TABLE, TD, TH, TR, U, UL.  When using the next (new for yourself) tag using the preview, check that the tag is interpreted correctly.  For some use cases, incorrect formatting may be obtained, and the text of the corresponding element will disappear. <br><br>  <b>Q6:</b> What else do you need to know? <br>  <b>A6:</b> At the moment there are several errors and features of work known to me: <br>  1. When saving lists between add there is &lt;br&gt; &lt;br&gt; between &lt;li&gt; blocks, so the list starts to ‚Äúdisperse‚Äù.  If the new &lt;li&gt; tag is on the end line of the previous one, there will not be any extra gaps. <br>  2. After saving the last paragraph, sometimes, it changes places with the last but one.  I suppose you need to understand the functions of working with ranges and inserts in the DOM. <br>  3. If you select a large block of text, this block will be hidden, and the editor will be at the very beginning of the block and you will need to scroll up.  It is necessary to add a function that would ensure the editor‚Äôs visibility on the screen at the start of editing. <br>  4. One of the features of the implementation is that the program itself generates the source text markup based on HTML text preview.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the original author's code is not available, all tags are presented in the same way, in the current version - in capital letters. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. As a result of the fact that the program performs the conversion of the entered text into html, and then back into the habrabra code, with conversion errors, it is impossible to return the text back to correct even minimal errors. If &lt;source&gt; blocks are in the ‚Äúcorrupted‚Äù code, the angle brackets "&lt;" and "&gt;" will be replaced by "&amp; lt;" and "&amp; gt;" But after fixing them for the &lt;source&gt; and &lt;/ source&gt; tags, everything should be correct again. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. When editing an article, the text of the &lt;habracut&gt; tag disappears, since it is not in the preview. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition 1:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Added the ability to edit existing articles, and not just create new ones.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also fixed a bug due to which the script did not work in WebKit based browsers. </font><font style="vertical-align: inherit;">Thanks </font></font><a href="https://habrahabr.ru/users/leksat/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leksat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://habrahabr.ru/users/tkf/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tkf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The reason was that it was natural for me to set the default value for the function parameter. </font><font style="vertical-align: inherit;">Firefox accepted everything, but chrome does not understand the following construction:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param1, param2=default_value</span></span></span><span class="hljs-function">)</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/166043/">https://habr.com/ru/post/166043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166021/index.html">Closet music or how we organized music in an office toilet</a></li>
<li><a href="../166031/index.html">How do you transfer logins / passwords to clients?</a></li>
<li><a href="../166037/index.html">Aruba OS 6.1 and Split Tunnel on RAP 5</a></li>
<li><a href="../166039/index.html">11 important things you need to know about DevOps - part one</a></li>
<li><a href="../166041/index.html">From the airport in Mallorca to the House of Rock in Los Angeles: where software is used for smart homes iRidium</a></li>
<li><a href="../166045/index.html">Introduction to NikaFramework (NKF). Part 1</a></li>
<li><a href="../166047/index.html">Developing iOS Ruby Applications</a></li>
<li><a href="../166049/index.html">Navigation in the new version of the Moscow metro scheme for people with impaired color perception</a></li>
<li><a href="../166051/index.html">AnnotatedSQL: schema + content provider</a></li>
<li><a href="../166053/index.html">Localization and globalization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>