<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to invent a bike and get to know FRP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I had the chance to work on a web application for interacting with an interactive whiteboard (!) For mobile devices (!!) on any technology s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to invent a bike and get to know FRP</h1><div class="post__text post__text-html js-mediator-article">  Recently, I had the chance to work on a web application for interacting with an interactive whiteboard (!) For mobile devices (!!) on any technology stack, both server and client (!!!).  At the prototype stage, the task was a simple graphic editor.  The customer expressed a desire to be able to draw broken lines in some way, circles, segments, arbitrary curves and add text.  Everything seems to be simple, however, taught by the bitter experience of GoF, Fowler and other apologists of all sorts of patterns, I immediately realized that the customer was cunning and that within a week or a month after the prototype he would need to draw ellipses, rectangles and heaps of other nishtyakov.  And all this will definitely have to be done in different ways.  At least for desktop and mobile. <br><br>  Actually, you can do everything in the forehead (for a prototype), but the weekend fell, a pause in the tasks of the current project, and I decided to do everything in an amicable way.  And on the first evening - <b>callback hell</b> . <br><br>  And then‚Ä¶ <br><img src="https://habrastorage.org/files/baf/f7f/526/baff7f526d994fbb8da8a8d7bddac06d.png" alt="Because at work there is nothing else to do.">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  The picture above was made, of course, on the basis of that very editor. <br><br><h4>  About the sense of beauty </h4><br>  Immediately in my head I had an idea to describe drawing tools in such a way that the code most closely resembled a potential technical task.  Let's say <br><br>  TK: <blockquote>  As a user, I want to be able to draw segments <br>  1. Pressing the left mouse button marks the beginning of the segment. <br>  2. Mouse movement after clicking with the left mouse button draws an intermediate result. <br>  3. After the button is released, the end of the segment is marked. <br>  4. Data is sent to the server. </blockquote><br><br>  Spherical code in vacuum: <br><pre><code class="javascript hljs">myDrawingBoard .once(‚Äúmousedown‚Äù, setStartingPoint) .any(‚Äúmousemove‚Äù, drawLine) .once(‚Äúmouseup‚Äù, setEndingPoint) .atLast(saveFigure)</code> </pre> <br><br>  At least that was the code in my head.  Something similar I saw on jQuery Russia this spring, where the implementation was strung on Rx.js.  Alas, I didn‚Äôt have the opportunity to watch a video or chat with the speaker, and therefore I had to reinvent the wheel myself. <br><br>  Having chatted with colleagues, I came to the conclusion that the task itself is a finite state machine.  And my code requires a little witchcraft over this very automaton, since events need to be tracked over some regularly existing nodes, but not all these events should be intercepted, but only those that are needed in the current state of the automaton. <br>  Actually, by briefly meditating on a notebook, I built just such a scheme and called it ‚ÄúFlat Event Chain‚Äù - a flat chain of events. <br><br><img src="https://habrastorage.org/files/4f5/b13/272/4f5b132721f1470d8768e8990d31df0c.png" alt="Flat event chain"><br><br>  Each state is a so-called MetaEvent - a small chain of events consisting of a set of recurring events (such as ‚Äúany‚Äù) and a closing single event (such as once).  If there are no recurring events in MetaEvent, then the closing one must be present, otherwise we can never tell when to get out of this state. <br><br><img src="https://habrastorage.org/files/051/723/454/051723454d004270bcfa0f05cb542390.png" alt="Meta event"><br><br>  In this model, collisions are possible when repeated events are of a common type.  To do this, each element of the chain is assigned a unique name and at the level of the meta-event a check is made on which handler to use.  As soon as we decide which of the elements will be responsible for handling this event, all previous handlers are destroyed.  When a closing single event is intercepted, the MetaEvent is considered executed and the machine is transferred to the next state. <br><br><h4>  About implementation </h4><br>  Each element of the chain is such a module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BaseEvent = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, element, callback, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = element; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callback = callback; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = GuidFactory.create(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"me_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._codes = type[key] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> ? type[key] : [type[key]]; type = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type = type; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._uniqueType = type + <span class="hljs-string"><span class="hljs-string">"."</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._handlers = []; }; BaseEvent.prototype = { <span class="hljs-attr"><span class="hljs-attr">on</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._handlers.push({<span class="hljs-attr"><span class="hljs-attr">callback</span></span>: callback, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: context || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">trigger</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._handlers.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._handlers[i]; obj.callback.apply(obj.context, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } }, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.on(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._uniqueType, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_this._codes || _this._codes.indexOf(evt.keyCode) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { _this.trigger(evt); } }) }, <span class="hljs-attr"><span class="hljs-attr">dispose</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.off(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._uniqueType); } };</code> </pre><br><br>  BaseEvent assumes the possibility of its initialization (activation of the subscription to a client event) through the init method, and the release of resources through dispose.  As you can see, events are provided with a notation in both the ‚ÄúeventType‚Äù style and the {‚ÄúeventType‚Äù style: [keyCode]} - the latter option will intercept only those events in which the required keyCode was transmitted (if you need only one, do not write an array). <br><br>  Thus the chain is described: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MetaEvent = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._closingEvent = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentEvent = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.closed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = GuidFactory.create(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"me_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; }; MetaEvent.prototype = { <span class="hljs-attr"><span class="hljs-attr">push</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.closed) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot push event to closed MetaEvent"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events.push(evt); }, <span class="hljs-attr"><span class="hljs-attr">close</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.closed) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot close already closed MetaEvent"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._closingEvent = evt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.closed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stateMachine</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._createEventIndex(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._stateMachine = stateMachine; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._initEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[id]); } }, <span class="hljs-attr"><span class="hljs-attr">dispose</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[id].dispose(); } }, <span class="hljs-attr"><span class="hljs-attr">_initEvent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; evt.init(); evt.on(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id === _this._closingEvent.id &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callback.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element, [evt]) !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { _this._stateMachine[_this.name](); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id === _this._currentEvent.id) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callback.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element, [evt]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type !== _this._currentEvent.type &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callback.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element, [evt]) !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { _this._disposePreviousEvents(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id); _this._currentEvent = _this._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id]; } }); }, <span class="hljs-attr"><span class="hljs-attr">_createEventIndex</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evt = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events[i]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[evt.id] = evt; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._closingEvent.id] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._closingEvent; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentEvent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._closingEvent; }, <span class="hljs-attr"><span class="hljs-attr">_disposePreviousEvents</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eventId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evt = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._events[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (evt.id !== eventId) { evt.dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre><br><br>  MetaEvent assumes the possibility of adding repetitive events via push and adding a closing event through close, as well as the same init and dispose as in BaseEvent.  Here you can pay attention to the fact that if the callback returns false, the machine will not change its state.  This is not very beautiful, but evt.preventDefault would be equally bad.  At least, return false in this context will not affect the default event handler and its bubbling. <br><br>  Actually, it remains only to screw it all around the State Machine.  As this, I used the open source solution <a href="https://github.com/jakesgordon/javascript-state-machine">from here</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EventChain = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._element = $(element); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._atLast = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }; EventChain.prototype = { <span class="hljs-attr"><span class="hljs-attr">_lastEvent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents.length - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">_createEventIndex</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evt = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents[i]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[evt.id] = evt; } }, <span class="hljs-attr"><span class="hljs-attr">_createEvents</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt, index, metaEvents</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: evt.name, <span class="hljs-attr"><span class="hljs-attr">from</span></span>: evt.id, <span class="hljs-attr"><span class="hljs-attr">to</span></span>: index + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; metaEvents.length ? metaEvents[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].id : <span class="hljs-string"><span class="hljs-string">"atLast"</span></span> } }); }, <span class="hljs-attr"><span class="hljs-attr">_createCallbacks</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = {}, _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex) { result[<span class="hljs-string"><span class="hljs-string">"onenter"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[i].id] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt, from, to, data</span></span></span><span class="hljs-function">) </span></span>{ _this._eventIndex[to].init(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } result[<span class="hljs-string"><span class="hljs-string">"onleave"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._eventIndex[i].id] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt, from, to, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_this._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>]) { _this._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>].dispose(); } } } result[<span class="hljs-string"><span class="hljs-string">"onatLast"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt, from, to</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_this._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>]) { _this._eventIndex[<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>].dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_this._atLastCallback) { _this._atLastCallback.apply( _this._atLastContext || _this._element, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }, <span class="hljs-comment"><span class="hljs-comment">// add event that will be handled only once once: function (type, element, callback, context) { if (element instanceof Function) { context = callback; callback = element; element = this._element; } var lastEvent = this._lastEvent(); if (lastEvent &amp;&amp; !lastEvent.closed) { lastEvent.close(new BaseEvent(type, element, callback, context)); } else { var evt = new MetaEvent(); evt.close(new BaseEvent(type, element, callback, context)); this._metaEvents.push(evt); } return this; }, // add event that will be handled twice twice: function (type, element, callback, context) { return this .once(type, element, callback, context) .once(type, element, callback, context); }, // add event that will be repeated any times any: function (type, element, callback, context) { if (element instanceof Function) { context = callback; callback = element; element = this._element; } var lastEvent = this._lastEvent(); if (lastEvent &amp;&amp; !lastEvent.closed) { lastEvent.push(new BaseEvent(type, element, callback, context)); } else { var evt = new MetaEvent(); evt.push(new BaseEvent(type, element, callback, context)); this._metaEvents.push(evt); } return this; }, // add event that will be repeated at least once onceAndMore: function (type, element, callback, context) { return this .once(type, element, callback, context) .any(type, element, callback, context); }, // set function that will be called after queue is done atLast: function (callback, context) { this._atLastCallback = callback; this._atLastContext = context; return this; }, // set event that will cancel queue immediately cancel: function (type, element, callback, context) { var _this = this; if (element instanceof Function) { context = callback; callback = element; element = this._element; } new BaseEvent(type, element, callback, context) .on("caught", function (evt) { if (this.callback.apply(this.context || this.element, [evt]) !== false) { _this.dispose(); } }) .init(); return this; }, // initialize state machine init: function () { this._createEventIndex(); var callbacks = this._createCallbacks(), events = this._createEvents(), stateMachine = StateMachine.create({ initial: this._metaEvents[0].id, final: "atLast", events: events, callbacks: callbacks }); return this; }, dispose: function () { for (var i = 0; i &lt; this._metaEvents.length; ++i) { this._metaEvents[i].dispose(); } } };</span></span></code> </pre><br><br>  The chain from MetaEvents is initially sharpened on a specific DOM element, which is passed through a tiny extension for jQuery: <br><br><pre> <code class="javascript hljs">jQuery.fn.eventChain = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventChain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre><br><br>  As for the drawing tools, I immediately put on all sorts of patterns, but this is because in the prototype I needed a bunch of these tools.  Without extra code, this is how a direct line drawing tool looks. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LineDrawer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (ConcreteDrawer.extend({ <span class="hljs-attr"><span class="hljs-attr">__type</span></span>: <span class="hljs-string"><span class="hljs-string">"line"</span></span>, <span class="hljs-attr"><span class="hljs-attr">__draw</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SmartPath(data).draw(); }, <span class="hljs-attr"><span class="hljs-attr">__startDrawing</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Board.EventLayer.eventChain() .once(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placeStartPoint, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .any(<span class="hljs-string"><span class="hljs-string">"mousemove"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__drawTemporaryFigure, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .once(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placeEndPoint, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .cancel({<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>: <span class="hljs-number"><span class="hljs-number">27</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancelDrawing, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .atLast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__saveFigure, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .init(); }, <span class="hljs-attr"><span class="hljs-attr">_placeStartPoint</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__figureData.x1 = Board.EventLayer.pageX(evt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__figureData.y1 = Board.EventLayer.pageY(evt); }, <span class="hljs-attr"><span class="hljs-attr">__drawTemporaryFigure</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placeEndPoint(evt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.base(); }, <span class="hljs-attr"><span class="hljs-attr">_placeEndPoint</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__figureData.x2 = Board.EventLayer.pageX(evt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__figureData.y2 = Board.EventLayer.pageY(evt); } }))();</code> </pre><br><br>  Actually, as it is easy to guess, LineDrawer can initialize the drawing process, for example, as a reaction to the desired client event (click on the line icon in the toolbar).  I have written for this a small chain of responsibility, thus creating a new drawing tool costs ten lines. <br><br>  After the prototype was ready, I suddenly faced a terrible assumption - what if the customer wants to repeat not a separate event, but whole patterns, subchains of events.  Let's say a fairly trivial task: <br><br>  Fantastic TK "Polygon": <br><blockquote>  As a user, I want to be able to draw broken lines. <br>  1. Pressing the left mouse button marks the beginning of the segment. <br>  2. The movement of the mouse shows an intermediate result. <br>  3. Pressing the space bar marks the top of the polyline. <br>  4. Repeat steps 2 and 3 until the user releases the mouse button, then save the last intermediate result. </blockquote><br><br>  In the concept implemented above, such a task is no longer feasible - at least, only a certain number of chain links can be described in it, and not an arbitrary one. <br>  The inner sense of beauty demanded this style: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Board.EventLayer.eventChain() .once(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placeStartPoint, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .any(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> chain .any(<span class="hljs-string"><span class="hljs-string">"mousemove"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__drawTemporaryFigure, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .once({<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placePolygonePoint, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .once(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._placePolygonePoint, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .cancel({<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>: <span class="hljs-number"><span class="hljs-number">27</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancelDrawing, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .atLast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__saveFigure, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .init();</code> </pre><br><br>  In this style, the wing is already a ready-made solution, which required adding a slightly more complex CycleEvent to the usual BaseEvent. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CycleEvent = Base.extend({ <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cycle, element, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycle = cycle; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._element = element; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._context = context; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = GuidFactory.create(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"me_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type = <span class="hljs-string"><span class="hljs-string">"cycle_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; }, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycleChain = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycle .apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._context || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._element.eventChain()]) .atLast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._restartCycle, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycleChain.init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycleChain; }, <span class="hljs-attr"><span class="hljs-attr">dispose</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycleChain.dispose(); }, <span class="hljs-attr"><span class="hljs-attr">_restartCycle</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.trigger(<span class="hljs-string"><span class="hljs-string">"caught"</span></span>); } });</code> </pre><br><br>  The external contract completely coincides with BaseEvent, and therefore it is enough just to slightly patch the any method in the EventQueue so that it can work with such data. <br><br><pre> <code class="javascript hljs">any: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, element, callback, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cycle(type, element) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) { context = callback; callback = element; element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._element; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastEvent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._lastEvent(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastEvent &amp;&amp; !lastEvent.closed) { lastEvent.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseEvent(type, element, callback, context)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaEvent(); evt.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseEvent(type, element, callback, context)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._metaEvents.push(evt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }, <span class="hljs-comment"><span class="hljs-comment">// add cycle of events with same syntax _cycle: function (cycle, context) { var lastEvent = this._lastEvent(); if (lastEvent &amp;&amp; !lastEvent.closed) { lastEvent.push(new CycleEvent(cycle, this._element, context)); } else { var evt = new MetaEvent(); evt.push(new CycleEvent(cycle, this._element, context)); this._metaEvents.push(evt); } return this; }</span></span></code> </pre> <br><br><h4>  About the result and where does the FRP </h4><br>  Here, of course, is a moot point, is there any FRP in all this?  If we present a set of data about a graphic primitive as a set, then, in essence, the code that we write after eventChain () is a description of operations on this set and their composition.  The ability to add recurring events and event patterns adds flexibility to all of this, but in general for some kind of FRP, once-events would suffice. <br>  The value of this code is an even more controversial issue.  However, in the context of the task, he definitely copes with his duties ideally.  Obviously, there is room to expand it: for example, if you add support for promises, you can beautifully describe complex animations, and if you add the concept of equivalent events (it is still implemented in half, allowing you to track keystrokes equally well), you can create simple games. <br><br><h5>  References: </h5><br>  <a href="https://preview.c9.io/quilin/eventchain/">Cloud9 code</a> <br>  <a href="https://preview.c9.io/quilin/eventchain/EventChain/demo/index.htm">Cloud9 demo</a> <br>  <a href="https://github.com/jakesgordon/javascript-state-machine">State Machine</a> <br>  <a href="http://raphaeljs.com/">Rapha√´l.js</a> </div><p>Source: <a href="https://habr.com/ru/post/245269/">https://habr.com/ru/post/245269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245255/index.html">Bypassing github.com blocking in Windows using DNSCrypt</a></li>
<li><a href="../245257/index.html">The greenest technopark in the world, or why start an IT business in India?</a></li>
<li><a href="../245259/index.html">Welcome to GDG DevFest Omsk 2014</a></li>
<li><a href="../245263/index.html">GSON. Add a little rigor to it and solve the problem of memory overflow when processing large JSON files.</a></li>
<li><a href="../245267/index.html">Functional Modeling</a></li>
<li><a href="../245271/index.html">Asterisk. Sending and receiving faxes</a></li>
<li><a href="../245277/index.html">Professional development managers. Kaizen practice training on internship in Japan</a></li>
<li><a href="../245279/index.html">Toaster. Enhanced tag subscription: Receive instant email notifications of all new issues for any tag.</a></li>
<li><a href="../245281/index.html">Interview with Chalz Dahigg: how strength of habit can help you achieve your goals</a></li>
<li><a href="../245285/index.html">Wintering cacti with online temperature control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>