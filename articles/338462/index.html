<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript scope and closures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This publication is a translation of the material ‚ÄúJavaScript Scope and Closures‚Äù by Zell Liew, posted here . 



 Scopes and closures are important i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript scope and closures</h1><div class="post__text post__text-html js-mediator-article">  <i>This publication is a translation of the material ‚ÄúJavaScript Scope and Closures‚Äù by Zell Liew, posted <a href="https://css-tricks.com/javascript-scope-closures/">here</a> .</i> <br><br><p>  Scopes and closures are important in JavaScript, but they confused me when I first started learning them.  The following are explanations of these terms that will help you understand them. </p><br><p>  <i>Let's start with scopes</i> </p><br><h2>  Area of ‚Äã‚Äãvisibility </h2><br><p>  JavaScript scope determines which variables are available to you.  There are two types of scopes: <b>global</b> and <b>local</b> . </p><br><a name="habracut"></a><br><h3>  Global scope </h3><br><p> If a variable is declared outside of all functions or curly braces ( <code>{}</code> ), then it is considered that it is defined in the <b>global scope</b> . </p><br><p>  <b>Note:</b> this is only true for javascript in web browsers.  In Node.js, global variables are declared differently, but we will not touch Node.js in this article. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> globalVariable = <span class="hljs-string"><span class="hljs-string">'some value'</span></span>;</code> </pre><br><p>  As soon as a global variable is declared, this variable can be used everywhere in the code, even in functions. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hello = <span class="hljs-string"><span class="hljs-string">'Hello CSS-Tricks Reader!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hello); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hello); <span class="hljs-comment"><span class="hljs-comment">// 'Hello CSS-Tricks Reader!' sayHello(); // 'Hello CSS-Tricks Reader!'</span></span></code> </pre><br><p>  Although it is possible to declare variables in the global scope, it is not recommended to do this.  This is due to the fact that there is a chance that names will intersect when two or more variables are given the same name.  If variables are declared via <code>const</code> or <code>let</code> , then each time the intersection of names occurs, an error message will be displayed.  This behavior is undesirable. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! let thing = 'something'; let thing = 'something else'; // , thing   </span></span></code> </pre><br><p>  If you declare variables through <code>var</code> , then the second variable after the declaration will overwrite the first.  This behavior is also undesirable, since  code is complicated in debugging. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! var thing = 'something'; var thing = 'something else'; //  -        console.log(thing); // 'something else'</span></span></code> </pre><br><p>  So, you should always declare local variables, not global ones. </p><br><h3>  Local scope </h3><br><p>  Variables that are used only in a certain part of the code are considered to be placed in the local scope.  Such variables are called <b>local</b> . </p><br><p>  In JavaScript, there are two types of local scopes: </p><br><ul><li>  <b>function scope</b> </li><li>  <b>and block scope</b> . </li></ul><br><p>  <i>First consider the <b>function scope</b></i> </p><br><h4>  Function scope </h4><br><p>  A variable declared inside a function is available only inside a function.  The code outside the function does not have access to it. </p><br><p>  In the example below, the <code>hello</code> variable is inside the scope of the <code>sayHello</code> function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hello = <span class="hljs-string"><span class="hljs-string">'Hello CSS-Tricks Reader!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hello); } sayHello(); <span class="hljs-comment"><span class="hljs-comment">// 'Hello CSS-Tricks Reader!' console.log(hello); // , hello  </span></span></code> </pre><br><h4>  Block scope </h4><br><p>  A variable declared inside curly braces <code>{}</code> via <code>const</code> or <code>let</code> is available only inside curly brackets. </p><br><p>  In the example below, you can see that the <code>hello</code> variable is inside the scope of the curly braces: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hello = <span class="hljs-string"><span class="hljs-string">'Hello CSS-Tricks Reader!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hello); <span class="hljs-comment"><span class="hljs-comment">// 'Hello CSS-Tricks Reader!' } console.log(hello); // , hello  </span></span></code> </pre><br><p>  <b>Block scope</b> is a special case of <b>function scope</b> , since  Functions are declared with curly brackets (except when using pointer functions with an implicit return value). </p><br><h3>  Raising visibility function </h3><br><p>  Functions declared as ‚Äú <b>function declarations</b> ‚Äù always rise to the current scope.  So, the two examples below are equivalent: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    sayHello(); function sayHello () { console.log('Hello CSS-Tricks Reader!'); } //  ,    function sayHello () { console.log('Hello CSS-Tricks Reader!'); } sayHello();</span></span></code> </pre><br><p>  If the function is declared as a ‚Äú <b>function</b> <b>expression</b> ‚Äù (functional expression) (note: function of the form <b><code>var f = function () {...}</code></b> ), then such a function does not rise in the current scope. </p><br><pre> <code class="javascript hljs">sayHello(); <span class="hljs-comment"><span class="hljs-comment">// , sayHello   const sayHello = function () { console.log(aFunction); }</span></span></code> </pre><br><p>  Because of these two possible options, raising the function can potentially be confusing, so it is not recommended to be used in practice.  Always declare functions first before using them. </p><br><h3>  Functions do not have access to the scope of other functions. </h3><br><p>  Functions do not have access to the scope of other functions when they are declared separately, even if one function is used in another. </p><br><p>  In the example below, the <code>second</code> function does not have access to the variable <code>firstFunctionVariable</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstFunctionVariable = <span class="hljs-string"><span class="hljs-string">`I'm part of first`</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(firstFunctionVariable); <span class="hljs-comment"><span class="hljs-comment">// , firstFunctionVariable  . }</span></span></code> </pre><br><h3>  Nested scopes </h3><br><p>  When a function is declared in another function, the internal function has access to the variables of the external function.  This behavior is called delineation of <b>lexical scopes</b> . </p><br><p>  At the same time, the external function does not have access to the internal function variables. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outerFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outer = <span class="hljs-string"><span class="hljs-string">`I'm the outer function!`</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inner = <span class="hljs-string"><span class="hljs-string">`I'm the inner function!`</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(outer); <span class="hljs-comment"><span class="hljs-comment">// I'm the outer function! } console.log(inner); // , inner   }</span></span></code> </pre><br><p>  To visualize how visibility areas work, you can imagine a one-way mirror.  You can see those who are on the other side, but those who are on the other side (the mirror side) cannot see you. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/699/f7a/dca/699f7adca91587e6a3641d3b4b1b62ff.png"><br><p>  If some scopes are embedded in others, then this can be represented as a set of glass surfaces with the principle of operation described above. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/70f/359/bbd/70f359bbdb9bf36fba6adc4e8719550d.png"><br><p>  If you understand everything about scope, then we can say that you are ready to deal with the fact that such a circuit. </p><br><h2>  Closures </h2><br><p>  Whenever you call a function inside another function, you create a closure.  It is said that the internal function is a closure.  The result of the closure is usually that the variables of the external function become available later. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outerFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outer = <span class="hljs-string"><span class="hljs-string">`I see the outer variable!`</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(outer); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerFunction; } outerFunction()(); <span class="hljs-comment"><span class="hljs-comment">// I see the outer variable!</span></span></code> </pre><br><p>  Since the inner function is the return value of the outer function, the code can be slightly reduced by combining the return value with the function declaration. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outerFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outer = <span class="hljs-string"><span class="hljs-string">`I see the outer variable!`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(outer); } } outerFunction()(); <span class="hljs-comment"><span class="hljs-comment">// I see the outer variable!</span></span></code> </pre><br><p>  Thanks to the closures, access to the external function appears, so they are usually used for two purposes: </p><br><ol><li>  control side effects; </li><li>  create private variables. </li></ol><br><h3>  Side effects control with closures </h3><br><p>  Side effects occur when some additional actions are performed besides returning the value after the function is called.  Many things can be a side effect, such as an Ajax request, a timer, or even console.log: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'A console.log is a side effect!'</span></span>); }</code> </pre><br><p>  When closures are used to control side effects, they tend to pay attention to side effects that may confuse the code (for example, Ajax requests or timers). </p><br><p>  <i>For clarification, consider an example.</i> </p><br><p>  Let's say you want to make your friend's birthday cake.  Cooking a cake will take a second, since the written function displays ‚Äúbaked cake‚Äù after a second. </p><br><p>  <b>Note:</b> for brevity and simplicity, the arrow functions from ES6 are used below. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Made a cake`</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  As you can see, this feature has a side effect in the form of a timer. </p><br><p>  Next, let's say your friend needs to choose the taste of the cake.  To do this, add "add taste" to the function <code>makeCake</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flavor</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Made a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${flavor}</span></span></span><span class="hljs-string"> cake!`</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  After calling the function, the cake will be baked in exactly one second. </p><br><pre> <code class="javascript hljs">makeCake(<span class="hljs-string"><span class="hljs-string">'banana'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Made a banana cake!</span></span></code> </pre><br><p>  The problem is that, let's say, it is not necessary that the cake be baked immediately after the refinement of the taste, but it is necessary that the cake be baked later when it is needed. </p><br><p>  To solve this problem, you can write the function <code>prepareCake</code> , which will store the taste of the cake.  Then pass the closure to <code>makeCakeLater</code> via <code>prepareCake</code> . </p><br><p>  From this point on, the returned function can be called at any time when it is required, and the cake will be cooked in a second. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareCake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flavor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Made a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${flavor}</span></span></span><span class="hljs-string"> cake!`</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeCakeLater = prepareCake(<span class="hljs-string"><span class="hljs-string">'banana'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ... makeCakeLater(); // Made a banana cake!</span></span></code> </pre><br><p>  So closures are used to reduce side effects ‚Äî a function is called that activates an internal closure according to your desire. </p><br><h3>  Private variables with closures </h3><br><p>  As you now know, variables created inside a function cannot be accessed outside.  Due to the fact that they are not available, they are also called <b>private variables</b> . </p><br><p>  However, access to such a private variable is sometimes required, and closures are used for this. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secret</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secretCode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { saySecretCode () { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(secretCode); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theSecret = secret(<span class="hljs-string"><span class="hljs-string">'CSS Tricks is amazing'</span></span>); theSecret.saySecretCode(); <span class="hljs-comment"><span class="hljs-comment">// 'CSS Tricks is amazing'</span></span></code> </pre><br><p>  In the example above, <code>saySecretCode</code> is the only function (closure) that outputs the <code>secretCode</code> outside the original secret function.  For this reason, this feature is called <b>privileged</b> . </p><br><h2>  Debugging Scopes with DevTools </h2><br><p>  Developer Tools (DevTools) Chrome and Firefox make it easy to debug variables in the current scope.  There are two ways to use this functionality. </p><br><p>  <b>The first way</b> is to add the <code>debugger</code> keyword to the code in order to stop the execution of JavaScript code in browsers for further debugging. </p><br><p>  Below is an example with <code>prepareCake</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareCake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flavor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  debugger debugger return function () { setTimeout(_ =&gt; console.log(`Made a ${flavor} cake!`), 1000); } } const makeCakeLater = prepareCake('banana');</span></span></code> </pre><br><p>  If you open DevTools and go to the Sources tab in Chrome (or the Debugger tab in Firefox), you can see the available variables. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fdf/5d0/d93/fdf5d0d93d30b9ca0735fb6b5b77cc80.png"></p><br><p>  You can also move the debugger inside the circuit.  Notice how the scope variables change this time: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareCake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flavor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  debugger debugger setTimeout(_ =&gt; console.log(`Made a ${flavor} cake!`), 1000); } } const makeCakeLater = prepareCake('banana');</span></span></code> </pre><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6bc/5d1/8f0/6bc5d18f0621988ca9b469a31e655b57.png"></p><br><p>  <b>The second way is to</b> add breakpoint directly to the code in the Sources (or Debugger) tab by clicking on the line number. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7bb/21a/016/7bb21a016fef46b129c42bdf619d1993.png"></p><br><p>  <b>Findings:</b> </p><br><ul><li>  Visibility and closures are not as difficult to understand as they seem.  They are fairly simple, if we consider them through the principle of a one-way mirror. </li><li>  After a variable is declared in a function, it can be accessed only inside the function.  Such variables are called defined in the context of this function. </li><li>  If you declare any internal function inside another function, then the internal function is called a closure, since  this function retains access to external function variables. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338462/">https://habr.com/ru/post/338462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338444/index.html">VEDO. External electronic document management what it is and how to choose</a></li>
<li><a href="../338450/index.html">How to run your project on Product Hunt: Administration Guide</a></li>
<li><a href="../338452/index.html">Broadcast from the gamedev conference 4C in St. Petersburg. The first day</a></li>
<li><a href="../338454/index.html">The book "ASP.NET Core. Application Development"</a></li>
<li><a href="../338460/index.html">Automate penetration testing with apt2</a></li>
<li><a href="../338468/index.html">Do you need financial data?</a></li>
<li><a href="../338470/index.html">Recommendations on Avito</a></li>
<li><a href="../338472/index.html">How we transferred 400 stores to electronic cash registers</a></li>
<li><a href="../338478/index.html">"Invisible design": we design together with cars</a></li>
<li><a href="../338480/index.html">Kali Linux: filtering traffic using netfilter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>