<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elegant JavaScript error handling with the Either monad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's talk a little about how we handle errors. In JavaScript, we have a built-in language function for dealing with exceptions. We enclose the proble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elegant JavaScript error handling with the Either monad</h1><div class="post__text post__text-html js-mediator-article"> Let's talk a little about how we handle errors.  In JavaScript, we have a built-in language function for dealing with exceptions.  We enclose the problem code in a <code>try...catch</code> construct.  This allows you to register a normal execution path in the <code>try</code> section, and then deal with all the exceptions in the <code>catch</code> section.  Not a bad option.  This allows you to focus on the current task, without thinking about every possible error.  Definitely better than littering the code with endless if. <br><br>  Without <code>try...catch</code> it is difficult to check the results of each function call for unexpected values.  This is a useful design.  But she has some problems.  And this is not the only way to handle errors.  In the article we will discuss the use of the <b>Either monad</b> as an alternative to <code>try...catch</code> . <br><br>  Before continuing, I will note a couple of points.  The article assumes that you already know about the composition of functions and currying.  And a warning.  If you haven't experienced monads before, they may seem really ... strange.  Working with such tools requires a change in thinking.  At first it is hard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Do not worry if you are immediately confused.  All so.  At the end of the article I have listed several links that may help.  Do not give up.  These things are intoxicating as they penetrate the brain. <br><a name="habracut"></a><br><h1>  Example problem </h1><br>  Before discussing the problems of exceptions, let's talk about why they exist at all and why <code>try...catch</code> blocks have appeared.  To do this, look at the problem that I tried to make at least partly realistic.  Imagine that we are writing a function to display a list of notifications.  We have already managed (somehow) to return data from the server.  But for some reason, the backend engineers decided to send it in CSV format, not JSON.  Raw data may look something like this: <br><br><pre>  timestamp, content, viewed, href
 2018-10-27T05: 33: 34 + 00: 00, @ madhatter, https: //example.com/invite/tea/3801
 2018-10-26T13: 47: 12 + 00: 00, @ queenofhearts mentioned in the Croquet Tournament 'discussion, viewed, https: //example.com/discussions/croquet/1168
 2018-10-25T03: 50: 08 + 00: 00, @ cheshirecat sent you a grin, unread, https: //example.com/interactions/grin/88 </pre><br>  We want to display it in HTML.  It might look something like this: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MessageList"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/invite/tea/3801"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@madhatter invited you to tea<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-27T05:33:34+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>27 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/discussions/croquet/1168"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@queenofhearts mentioned you in 'Croquet Tournament' discussion<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-26T13:47:12+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>26 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/interactions/grin/88"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@cheshirecat sent you a grin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-25T03:50:08+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>25 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  To simplify the task, for now let's just focus on processing each row of CSV data.  Let's start with a few simple functions for handling strings.  The first divides the text string into the fields: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> row.split(<span class="hljs-string"><span class="hljs-string">'","'</span></span>); }</code> </pre> <br>  Here the function is simplified, because it is educational material.  We deal with error handling, not CSV analysis.  If one of the messages gets a comma, it will all be terribly wrong.  Please never use such code to analyze real CSV data.  If you have ever had to analyze CSV data, use a <a href="https://github.com/sindresorhus/neat-csv">well-tested CSV parsing library</a> . <br><br>  After splitting the data, we want to create an object.  And so that each property name matches the CSV headers.  Suppose we have somehow analyzed the header line (more on that later).  We have reached a point where something can go wrong.  We got an error to handle.  We give an error if the length of the string does not match the header line.  ( <code>_.zipObject</code> is <a href="">a lodash function</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (headerFields.length !== fieldData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.zipObject(headerFields, fieldData); }</code> </pre> <br>  After that, add a human-readable date to the object to display it in our template.  It turned out a bit verbose, as in JavaScript there is no ideal built-in support for formatting dates.  And again we face potential problems.  If an invalid date is encountered, our function gives an error. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {datestr, ...messageObj}; }</code> </pre> <br>  Finally, we take an object and pass it through <a href="">the template function</a> to get an HTML string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowToMessage = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Message Message--&lt;%= viewed %&gt;"&gt; &lt;a href="&lt;%= href %&gt;" class="Message-link"&gt;&lt;%= content %&gt;&lt;/a&gt; &lt;time datetime="&lt;%= datestamp %&gt;"&gt;&lt;%= datestr %&gt;&lt;/time&gt; &lt;li&gt;`</span></span>);</code> </pre> <br>  It would also be nice to print an error if it met: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showError = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Error"&gt;&lt;%= message %&gt;&lt;/li&gt;`</span></span>);</code> </pre> <br>  When everything is in place, you can assemble a function to handle each line. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(e); } }</code> </pre> <br>  So, the function is ready.  Let's take a closer look at how it manages exceptions. <br><br><h1>  Exceptions: the good part </h1><br>  So, what's good about <code>try...catch</code> ?  It should be noted that in the example above, any of the steps in the <code>try</code> block may cause an error.  In <code>zipRow()</code> and <code>addDateStr()</code> we intentionally throw errors.  And if a problem occurs, just catch the error and show any message on the page.  Without this mechanism, the code becomes really ugly.  Here is how it might look.  Suppose that functions do not throw errors, but return <code>null</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowWithoutExceptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Encountered a row with an unexpected number of items'</span></span>)); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unable to parse date in row object'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  As you can see, a large number of template <code>if</code> expressions appeared.  The code is more verbose.  And it is difficult to follow the basic logic.  In addition, the <code>null</code> value doesn't tell us much.  We do not really know why the previous function call failed.  We have to guess.  We create an error message and call <code>showError()</code> .  This code is dirtier and more confusing. <br><br>  Look again at the exception handling version.  It clearly separates the successful path of the program and the exception handling code.  The <code>try</code> branch is a successful path, and <code>catch</code> is an error.  All exception handling occurs in one place.  And individual functions may report why they failed.  Overall, this seems pretty sweet.  I think that most consider the first example quite appropriate.  Why another approach? <br><br><h1>  Problems with exception handling try ... catch </h1><br>  This approach allows you to ignore these annoying errors.  Unfortunately, <code>try...catch</code> does its job too well.  You simply throw an exception and move on.  We can catch it later.  And everyone intends to always put such blocks, really.  But it is not always obvious where the error goes further.  And the block is too easy to forget.  And before you understand it, your application crashes. <br><br>  In addition, exceptions pollute the code.  We will not discuss functional purity in detail here.  But let's consider one small aspect of functional purity: referential transparency.  A reference-transparent function always returns the same result for a particular input.  But for functions with exceptions, we cannot say that.  At any time, they can throw an exception instead of returning a value.  This complicates the logic.  But what if finding a win-win option is a clean way to handle errors? <br><br><h1>  We come up with an alternative </h1><br>  Pure functions always return a value (even if that value is missing).  Therefore, our error handling code must assume that we always return a value.  So, as a first attempt, what to do if, in the event of a failure, we returned an Error object?  That is, wherever we get an error, we return such an object.  It might look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowReturningErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObj); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObjWithDate); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  This is not a special improvement version without exceptions.  But this is better.  We have moved responsibility for error reporting back to individual functions.  But we still have all these ifs.  It would be nice to somehow encapsulate the template.  In other words, if we know that we have a mistake, do not worry about executing the rest of the code. <br><br><h1>  Polymorphism </h1><br>  How to do it?  This is a difficult problem.  But it can be solved with the help of the magic of <i>polymorphism</i> .  If you have not experienced polymorphism before, do not worry.  In essence, this is ‚Äúproviding a single interface for entities of different types‚Äù (Straustrup, B. ‚ÄúGlossary of C ++ by Bj√∂rn Straustrup‚Äù).  In JavaScript, this means that we create objects with equally named methods and signatures.  But different behavior.  A classic example is application logging.  We can send our magazines to different places depending on the environment in which we are located.  What if we create two logger objects, for example? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> consoleLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'This is the console logger, logging:'</span></span>, msg); } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ajaxLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'https://example.com/logger'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: msg}); } };</code> </pre> <br>  Both objects define a log function that expects one string parameter.  But they behave differently.  The beauty is that we can write code that calls <code>.log()</code> , no matter which object it uses.  This can be <code>consoleLogger</code> or <code>ajaxLogger</code> .  Everything works anyway.  For example, the code below will work equally well with any object: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger, message</span></span></span><span class="hljs-function">) </span></span>{ logger.log(message); }</code> </pre> <br>  Another example is the <code>.toString()</code> method for all JS objects.  We can write a <code>.toString()</code> method for any class that we create.  Next, you can create two classes that implement the <code>.toString()</code> method differently.  Let's call them <code>Left</code> and <code>Right</code> (I'll explain the names a little later). <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Left(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Now create a function that calls <code>.toString()</code> on these two objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } trace(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚¶ò Left(Hello world) trace(new Right('Hello world')); // ‚¶ò Right(Hello world);</span></span></code> </pre> <br>  Not outstanding code, I know.  But the fact is that we have two different types of behavior that use the same interface.  This is polymorphism.  But pay attention to something interesting.  How many if statements have we used?  Zero.  No one.  We created two different types of behavior without a single if-operator.  Perhaps something like this can be used for error handling ... <br><br><h1>  Left and Right </h1><br>  Returning to our problem.  It is necessary to define a successful and unsuccessful way for our code.  On a successful journey, we simply continue to quietly run the code until an error occurs or we finish.  If we find ourselves on the wrong path, we will no longer try to run the code.  We could call these paths Happy and Sad, but try to follow the naming conventions that other programming languages ‚Äã‚Äãand libraries use.  So, let's call the unsuccessful path Left, and the successful one - Right. <br><br>  Create a method that runs a function if we are on a successful path, but ignore it on an unsuccessful one: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path. Do nothing } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); leftHello.runFunctionOnlyOnHappyPath(trace); <span class="hljs-comment"><span class="hljs-comment">// does nothing rightHello.runFunctionOnlyOnHappyPath(trace); // ‚¶ò Hello world // Ôø© "Hello world"</span></span></code> </pre> <br><h4>  Broadcast </h4><br>  We are approaching something useful, but not quite yet.  Our <code>.runFunctionOnlyOnHappyPath()</code> method returns the <code>_val</code> property.  Everything is fine, but too inconvenient if we want to run more than one function.  Why?  Because we no longer know, we are on a successful or unsuccessful path.  The information disappears as soon as we take the value beyond Left and Right.  So what we can do is return the Left or Right path with the new <code>_val</code> inside.  And we will shorten the name, since we are here.  What we do is the translation of a function from the world of simple values ‚Äã‚Äãinto the world of Left and Right.  Therefore, we call the <code>map()</code> method: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  We insert this method and use Left or Right in the free syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloToGreetings = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Hello/</span></span>, <span class="hljs-string"><span class="hljs-string">'Greetings,'</span></span>); leftHello.map(helloToGreetings).map(trace); <span class="hljs-comment"><span class="hljs-comment">// Doesn't print any thing to the console // Ôø© Left(Hello world) rightHello.map(helloToGreetings).map(trace); // ‚¶ò Greetings, world // Ôø© Right(Greetings, world)</span></span></code> </pre> <br>  We have created two paths of execution.  We can put the data on a successful path by calling <code>new Right()</code> , or on a bad one by calling <code>new Left()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36a/2ee/cf6/36a2eecf61c554e388c5723b0b5cbd02.svg"><br>  <i><font color="gray">Each class represents a path: successful or unsuccessful.</font></i>  <i><font color="gray">I stole this railway metaphor from <a href="https://fsharpforfunandprofit.com/rop/">Scott Vlaschina</a></font></i> <br><br>  If the <code>map</code> worked on a successful path, go through it and process the data.  If we find ourselves unsuccessful, nothing will happen.  Just keep passing the value on.  If we, for example, put Error on this unfortunate path, we would have something very similar to <code>try‚Ä¶catch</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17c/3e6/09d/17c3e609d306efc1bee111077456b9ab.svg"><br>  <i><font color="gray">Use <code>.map()</code> to move along the path.</font></i> <br><br>  As the path progresses, it becomes a bit difficult all the time to write Left or Right, so we will call this combination simply Either ("or").  Either left or right. <br><br><h4>  Labels for creating Either objects </h4><br>  So the next step is to rewrite our examples of functions so that they return to Either.  Left for error or Right for value.  But before we do this, let's have some fun.  Let's write a couple of tags.  The first is a static method called <code>.of()</code> .  It only returns the new Left or Right.  The code might look like this: <br><br><pre> <code class="javascript hljs">Left.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(x); }; Right.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(x); };</code> </pre> <br>  Honestly, even <code>Left.of()</code> and <code>Right.of()</code> tiring to write.  Therefore, I tend to shorter labels <code>left()</code> and <code>right()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Left.of(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Right.of(x); }</code> </pre> <br>  With these tags, let's start rewriting the functions of the application: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right({datestr, ...messageObj}); }</code> </pre> <br>  Modified functions are not so different from the old ones.  We simply wrap the return value in either Left or Right, depending on whether there is an error. <br><br>  After that we can start processing the main function that processes one line.  Let's start by placing the line in Either with <code>right()</code> , and then broadcast <code>splitFields</code> to split it: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ }</span></span></code> </pre> <br>  It works just fine, but trouble happens if you try to do the same with <code>zipRow()</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow <span class="hljs-comment"><span class="hljs-comment">/* wait. this isn't right */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  The fact is that <code>zipRow()</code> expects two parameters.  But the functions that we pass to <code>.map()</code> get only one value from the <code>._val</code> property.  The situation can be corrected with the help of the <code>zipRow()</code> version.  It might look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRowWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); }; }</code> </pre> <br>  This small change simplifies the <code>zipRow</code> conversion, so it will work well with <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)); <span class="hljs-comment"><span class="hljs-comment">// ... But now we have another problem ... }</span></span></code> </pre> <br><h4>  Join </h4><br>  Using <code>.map()</code> to run <code>splitFields()</code> is fine, as <code>.splitFields()</code> does not return Either.  But when you have to run <code>zipRow()</code> , a problem arises because it returns Either.  So when using <code>.map()</code> we end up sticking to Either inside Either.  If we go further, we'll get stuck until we run <code>.map()</code> inside <code>.map()</code> .  That won't work either.  We need some way to combine these nested eithers.  So let's write a new method, which we call <code>.join()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Now we can ‚Äúunpack‚Äù our assets: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)).join(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.map(addDateStr).join(); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Chain </h4><br>  We are far advanced.  But you have to remember all the time to call <code>.join()</code> , which is annoying.  However, we have a common sequential call pattern <code>.map()</code> and <code>.join()</code> , so let's create a quick access method for it.  Let's call it <code>chain()</code> (chain), because it links together functions that return Left or Right. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } chain() { // Boring sad path, // do nothing. return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } chain(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Returning to the railroad analogy <code>.chain()</code> switches the rails if we encounter an error.  However, it is easier to show on the chart. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bc/279/530/1bc2795304c211004070da858179fcfc.svg"><br>  <i><font color="gray">When an error occurs, the .chain () method allows you to switch to the left path.</font></i>  <i><font color="gray">Note that the switches only work in one direction.</font></i> <br><br>  The code has become a bit cleaner: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Do something with values </h4><br>  The <code>processRow()</code> function <code>processRow()</code> almost complete.  But what happens when we return the value?  In the end, we want to take different actions depending on what the situation is: Left or Right.  Therefore, we will write a function that will take appropriate measures: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leftFunc, rightFunc, e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) ? leftFunc(e._val) : rightFunc(e._val); }</code> </pre> <br>  I fooled and used the internal values ‚Äã‚Äãof the Left or Right objects.  But pretend you didn't notice.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we can complete our function: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And if we feel particularly clever, then we can again use the free syntax: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = right(row) .map(splitFields) .chain(zipRow(headerFields)) .chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both versions are pretty pretty. </font><font style="vertical-align: inherit;">No designs </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And there are no if statements in the top level function. </font><font style="vertical-align: inherit;">If there is a problem with any particular string, we simply display an error message at the end. </font><font style="vertical-align: inherit;">And note that </font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we mention Left or Right only once at the very beginning when we call </font></font><code>right()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The rest are only used methods </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>.chain()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for use the next function.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ap and lift </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks good, but it remains to consider one last scenario. </font><font style="vertical-align: inherit;">By sticking to our example, let's see how you can process all CSV data, and not just each row separately. </font><font style="vertical-align: inherit;">We will need an auxiliary function (helper) or three:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitCSVToRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// There should always be a header row... so if there's no // newline character, something is wrong. return (csvData.indexOf('\n') &lt; 0) ? left('No header row found in CSV data') : right(csvData.split('\n')); } function processRows(headerFields, dataRows) { // Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); } function showMessages(messages) { return `&lt;ul class="Messages"&gt;${messages.join('\n')}&lt;/ul&gt;`; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have a helper who breaks CSV into lines. </font><font style="vertical-align: inherit;">And we return to the option with Either. </font><font style="vertical-align: inherit;">Now you can use </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some lodash functions to extract the header row from the data rows. </font><font style="vertical-align: inherit;">But we find ourselves in an interesting situation ...</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// What's next? }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have header fields and data lines ready for display with </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrapped in Either. </font><font style="vertical-align: inherit;">We need some way to convert </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to a function that works with Either. </font><font style="vertical-align: inherit;">To begin, we will curry </font></font><code>processRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowsWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dataRows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); }; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now everything is ready for the experiment. </font><font style="vertical-align: inherit;">We have </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is Either, wrapped around an array. </font><font style="vertical-align: inherit;">What will happen if we take </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and call on it </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// How will we pass headerFields and dataRows to // processRows() ? const funcInEither = headerFields.map(processRows); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With .map (), the external function is called here </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not the internal one. </font><font style="vertical-align: inherit;">In other words, it </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns a function. </font><font style="vertical-align: inherit;">And since it is </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we still get back Either. </font><font style="vertical-align: inherit;">Thus, the result is a function inside Either, which is called </font></font><code>funcInEither</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It takes an array of strings and returns an array of other strings. </font><font style="vertical-align: inherit;">We need to somehow take this function and call it with the value inside </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To do this, add another method to our classes Left and Right. </font><font style="vertical-align: inherit;">Call it </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">according to the </font></font><a href="https://github.com/fantasyland/fantasy-land"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As usual, the method does nothing on the Left track:</font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Left (the sad path) ap() { return this; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And for the Right class, we expect another Either with a function: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Right (the happy path) ap(otherEither) { const functionToRun = otherEither._val; return this.map(functionToRun); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we can complete our main function: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> funcInEither = headerFields.map(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = dataRows.ap(funcInEither); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the method is </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately understood a little (the Fantasy Land specifications confusedly describe it, and in most other languages ‚Äã‚Äãthe method is used the other way around). If it is easier to describe, then you say: ‚ÄúI have a function that usually takes two simple values. I want to turn it into a function that accepts two Either. ‚Äù If available, </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can write a function that will do exactly that. Call it </font></font><code>liftA2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, again according to the standard name. It takes a simple function that waits for two arguments, and ‚Äúlifts‚Äù (lift) it to work with ‚Äúapplicatives‚Äù. (these are objects that contain both a method </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a method </font></font><code>.of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Thus, liftA2 is an abbreviation for "lift lift, two parameters". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the function </font></font><code>liftA2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">might look something like this:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runApplicativeFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.ap(a.map(func)); }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Our top-level function will use it as follows: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processRowsA = liftA2(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = processRowsA(headerFields, dataRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br> <a href="https://codepen.io/jrsinclair/pen/GYbJaW"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code on CodePen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  True?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It's all? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You ask, what is better than simple exceptions? </font><font style="vertical-align: inherit;">Do not I think that this is too complicated a way to solve a simple problem? </font><font style="vertical-align: inherit;">Let's first think about why we like exceptions. </font><font style="vertical-align: inherit;">If there were no exceptions, I would have to write many if-statements everywhere. </font><font style="vertical-align: inherit;">We will forever write code according to the principle ‚Äúif the latter works, continue, otherwise handle the error‚Äù. </font><font style="vertical-align: inherit;">And we have to handle these errors in the whole code. </font><font style="vertical-align: inherit;">This makes it difficult to understand what is happening. </font><font style="vertical-align: inherit;">Exceptions allow you to exit the program if something went wrong. </font><font style="vertical-align: inherit;">Therefore, it is not necessary to write all these ifs. </font><font style="vertical-align: inherit;">You can focus on a successful execution path.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is one snag. Exceptions hide too much. When you create an exception, you transfer the error handling problem to some other function. It is too easy to ignore the exception that will pop up to the top level. Either's nice side is that it allows you to jump out of the main program stream, as if with an exception. And it works honestly. You get either Right or Left. You cannot pretend that the Left option is not possible. In the end, you have to pull out the value of a call like </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know it sounds like some complexity. But take a look at the code we wrote (not the classes, but the functions that use them). There is not much exception handling code. It is almost none, except for the call </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end </font></font><code>csvToMessages()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That's the whole point. With Either, you have pure error handling that you can't accidentally forget. Without Either, you stamp through the code and add indents everywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This does not mean that you can never use </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sometimes this is the right tool, and that's fine. But this is not the only tool. Either gives some advantages that are not </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. So give a chance to this monad. Even if it is difficult at first, I think you will like it. But please do not use the implementation from this article. Try one of the famous libraries such as </font></font><a href="https://evilsoft.github.io/crocks/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://sanctuary.js.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sanctuary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://folktale.origamitower.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folktale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://monet.github.io/monet.js/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . They are better served. And here, for simplicity, I missed something.</font></font><br><br><blockquote><h1>  Additional resources </h1><br><ul><li> ¬´ <a href="https://github.com/MostlyAdequate/mostly-adequate-guide">       </a> ¬ª, <a href="https://twitter.com/drboolean"> </a> ( .) <br></li><li> <a href="https://github.com/fantasyland/fantasy-land"> Fantasy Land</a> <br></li><li> ¬´ <a href="https://tech.evojam.com/2016/03/21/practical-intro-to-monads-in-javascript-either/">    JavaScript: Either</a> ¬ª, <a href="https://twitter.com/ulfryk"> </a> <br></li><li> ¬´ <a href="https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">  JavaScript: </a> ¬ª, <a href="https://twitter.com/jrsinclair">  </a> </li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/457098/">https://habr.com/ru/post/457098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457084/index.html">How to live with professional lighting. Videos from Badoo Techleads Meetup # 4</a></li>
<li><a href="../457086/index.html">Architectural template "Builder" in the universe "Swift" and "iOS" / "macOS"</a></li>
<li><a href="../457090/index.html">Security Cheat Sheets: JWT</a></li>
<li><a href="../457092/index.html">We study MITER ATT & CK. Mobile Matrices: Device Access. Part 5</a></li>
<li><a href="../457096/index.html">We free our hands to several analysts: API Livy to automate typical banking tasks</a></li>
<li><a href="../4571/index.html">"Soup" suffers from bad PR</a></li>
<li><a href="../457100/index.html">AWS Lambda - theory, familiarity</a></li>
<li><a href="../457102/index.html">QVD files - what's inside, part 3</a></li>
<li><a href="../457106/index.html">The war with robo calls in the USA - who wins and why</a></li>
<li><a href="../457108/index.html">WWDC19: Getting Started with Test Plan for XCTest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>