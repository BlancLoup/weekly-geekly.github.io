<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Riot vs. Virtual Machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I bring to your attention the translation of the article Rage Against the Virtual Machine . 

 Anti-virus companies, mobile application stores and sec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Riot vs. Virtual Machine</h1><div class="post__text post__text-html js-mediator-article">  <i>I bring to your attention the translation of the article <a href="http://dl.acm.org/citation.cfm%3Fid%3D2592796">Rage Against the Virtual Machine</a> .</i> <br><br>  Anti-virus companies, mobile application stores and security researchers use techniques based on dynamic code analysis to detect and analyze mobile malicious applications.  This article presents a wide range of counter-analysis techniques that can be used by malicious applications to bypass dynamic analysis in emulated Android platform environments. <br><br>  The detection heuristics presented in this article cover three different categories based on (i) static properties, (ii) dynamic information from sensors, and (iii) the intricacies of the Android emulator on virtual machines.  To assess the effectiveness of the presented methods, they were included in samples of real malicious applications and sent to publicly available dynamic analysis systems, after which alarming results were obtained.  It was found that all the tools and services are vulnerable to most of our techniques evading analysis.  Even trivial techniques, such as checking the IMEI value, are sufficient to bypass some of the existing dynamic analysis environments.  Possible countermeasures have also been proposed to improve the sustainability of current dynamic analysis tools against attempts to evade analysis. <br><a name="habracut"></a><br><h4>  1. Introduction </h4><br>  The popularity of the Android OS, combined with the openness of this platform, made it an attractive target for attackers [13].  Antivirus vendors and researchers have responded to this growing security concern with services and tools for analyzing malicious applications.  Google also created Bouncer [1], a service for automatically scanning and checking malicious applications.  Scanning of an application to detect its potentially hidden malicious actions can be based on static [22, 25] and dynamic analysis [14, 17, 19, 28].  Unfortunately, both static and dynamic approaches can be circumvented.  With regard to static analysis, researchers have demonstrated a series of techniques that can bypass the current available static analysis tools [30].  As will be shown in this paper, dynamic analysis using emulation to study malicious Android applications is also not perfect.  A malicious program can infer whether it is running in an emulated environment, and therefore avoid detection by suspending all malicious activity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In more detail, this article discusses how Android applications can infer that they are running on an emulated ARM processor or on a real device.  First, a systematization of possible ways is created to determine the features of the runtime environment using heuristics sets.  The heuristics presented in this article cover a wide range of complexity.  Most of them are simple and can be prevented by simple changes in the emulated heuristics fraud environment, such as realistic values ‚Äã‚Äãfor static properties, such as the device serial number (IMEI).  Others are more reliable because the emulated environment must provide realistic data from mobile sensors, such as an accelerometer.  Ultimately, a set of heuristics is presented here, to counteract which requires a number of significant changes in the design of the emulated environment. <br><br>  To assess the importance of the conclusions made in this article, a set of relevant images of malicious applications was repackaged.  Developed heuristics were added to these images and sent to online analysis tools.  Oddly enough, all of the tested analysis tools can be circumvented using some of the presented heuristics.  Not a single malware analysis service was found that could cope with all of the heuristics tested.  In addition, at least 5 of the 12 analysis tools we tested can be circumvented using simple heuristics such as checking the IMEI value.  More sophisticated heuristics based on the intricacies of virtual machines could bypass all the tested services except 4. These 4 services do not support the execution of machine code, and thus cannot be used to run our subset of Android applications.  Finally, all tested services are vulnerable to heuristics based on information from sensors (sensors). <br><br>  It is worth noting that existing methods of analyzing malicious applications are easily circumvented by demonstrating the fact that current malicious applications can hide malicious functionality from publicly available services for analyzing malicious applications.  A set of countermeasures was proposed in order to make the analysis of Android applications in an emulated environment more resilient to attempts to bypass it. <br><br><h4>  2. Techniques of counteracting analysis </h4><br>  The counter-analysis techniques that can be used in Android applications to circumvent detection can be divided into three categories: (a) static heuristics based on static information, which always initializes fixed values ‚Äã‚Äãin emulated environments, (b) dynamic heuristics based on observing the unrealistic behavior of various sensors, and (c) Geurvisor's heuristics, based on incomplete emulation of real equipment.  Table 1 provides a brief description of all categories, along with some typical examples. <br><br><img src="https://habrastorage.org/files/42b/a1d/d0e/42ba1dd0e9d641a8b4e5add2a8b880f4.png"><br>  <i>Table 1. A brief description of the main types of heuristics detection of virtual machines that can be used by mobile malicious applications, along with typical examples</i> <br><br><h4>  <i>2.1.</i>  <i>Static Heuristics</i> </h4><br>  The static set includes heuristics that can be used to detect the emulated environment using presence checks or contained values ‚Äã‚Äãin unique device identifiers, such as the serial number (device ID), current build version, values ‚Äã‚Äãin the routing table. <br><br>  <b>Serial number of the device (device ID).</b>  Each smartphone contains an IMEI (International Identifier of Mobile Station Equipment), which is a unique number identifying it in GSM networks.  IMEI has already been used by malicious applications in order to prevent analysis using malware detection tools running in emulators [2].  The other mobile identifier is the IMSI (International Mobile Subscriber Identity), which is associated with the SIM card found in the phone.  Simple evasion heuristics are based on checking these identifiers, for example, is IMEI equal to null, which is true for the default Android emulator configuration.  For reference to this type of heuristics, the abbreviation <b>idH</b> will be used. <br><br>  <b>Build number.</b>  Another way to identify the emulated environment is to check the information associated with the current assembly, extracted from the properties of the system.  For example, the Android SDK provides a public Build class that provides information about fields such as PRODUCT, MODEL, and HARDWARE, which can be viewed in order to find out that the application is running in the emulator.  For example, the standard Android image in the emulator has the PRODUCT and MODEL field values ‚Äã‚Äãof google_sdk, and the HARDWARE field value of goldfish.  Several heuristics were identified based on such checks, which will be referred to later using the abbreviation <b>buildH</b> . <br><br>  <b>Routing table</b>  Emulated Android devices run by default behind a virtual router with an address space of 10.0.0.2/24, isolated from the network of the target machine.  The emulated network interface is configured with an IP address 10.0.2.15.  The default gateway and DNS server configurations also contain fixed values.  In this paper, network parameters are used as another of the detection heuristics.  In particular, the heuristics checks for listening to sockets and establishing a connection (via / proc / net / tcp), and trying to find the port number associated with the addresses 10.0.2.15 and 0.0.0.0. As an indicator of the emulated environment.  The reference to this heuristic is abbreviated as <b>netH</b> . <br><br><h4>  <i>2.2.</i>  <i>Dynamic Heuristics</i> </h4><br>  Mobile phones are equipped with various sensors, such as an accelerometer, gyroscope, GPS, gravity sensor, etc.  In fact, the output values ‚Äã‚Äãof these sensors are based on information collected from the environment, and, therefore, realistic emulation is a difficult task.  The existence of sensors is the main difference between smartphones and traditional computing systems.  The increasing number of sensors on smartphones provides new opportunities for identifying actual mobile devices, and, therefore, identifying differences and finding emulators.  For example, there are studies focused on the distinctive features of smartphones based on the flaws and imperfections of sensors [3, 20].  These approaches, based on distinctive features, can be used to detect emulated media. <br><br>  By default, the Android emulator does not support emulation of device movements in space;  This can be achieved through additional sensor simulators [4].  The current Android emulator builds also support the simulation of other types of sensors only partially or not at all.  When testing available simulated sensors, it was found that the emulator generates the same values ‚Äã‚Äãat equal time intervals of 0.8 seconds on average with a slight standard deviation (0.003043 seconds).  The distribution function of time intervals between accelerometer events, observed when the Android emulator is running for two minutes, is shown in Figure 1. It was found that this function for the other sensors follows the same pattern.  Sensor-based heuristics were implemented using the SensorManager class [5] of the Android API.  An Android Activity (application screen) was developed that attempts to register a sensor listener to track its output values ‚Äã‚Äãusing the following approach. <br><br>  First, the sensor listener is registered.  If registration fails, then most likely the execution occurs in an emulated environment (except for the case when the actual device does not support a specific sensor).  Otherwise, if the sensor registration was successful, the values ‚Äã‚Äãof the onSensorChanged callback method are checked, which is called when the sensor values ‚Äã‚Äãchange.  If the values ‚Äã‚Äãof the sensors or the observed time intervals do not change with successive calls to this method, then the application is considered to be running in an emulated environment and the registration of the sensor listener is canceled.  Heuristics based on sensors for accelerometer ( <b>accelH</b> ), magnetic field ( <b>magnFH</b> ), rotation ( <b>rotVecH</b> ), approximation ( <b>proximH</b> ) and gyroscope ( <b>gyrosH</b> ) were <b>implemented</b> . <br><br><img src="https://habrastorage.org/files/8d8/23c/291/8d823c2915c9477a9659663481a9f768.png"><br>  <i>Figure 1. The FRV intervals between accelerometer events observed in a running Android emulator for a few minutes</i> <br><br><h4>  <i>2.3.</i>  <i>Hypervisor Heuristics</i> </h4><br>  <b>Switching definitions context QEMU.</b>  This heuristic is related to the context switching mechanism in QEMU [26] and the fact that QEMU does not update the value of the <i>virtual command counter (virtual PC)</i> during the execution of each instruction due to performance reasons.  Since translated instructions are executed on the target machine, additional instruction is needed to increase the <i>virtual command counter</i> , so it is sufficient and quick to update the virtual command counter only when an instruction that violates linear execution, such as a jump instruction, is executed.  This means that if a context switch occurs during the execution of the base unit, it will be impossible to calculate the value of the virtual program counter.  Because of this, context switching in the QEMU environment occurs only after the execution of the base unit, and never during its execution. <br><br>  The proof of this concept has already developed a detection technique <b>QEMU BT</b> , based on the histogram of address flow planning [26].  In non-emulated environments, a wide range of time intervals can be observed when a context switch occurs, because switching can occur at any time, whereas in an emulated environment, a context switch always takes place at a certain time, first of the base unit, since context switching can occur only when complete base unit is complete.  This technique was implemented and used in the experiments as another heuristics with the abbreviation <b>BTdetectH</b> .  In fig.  Figure 2 shows the differences in the context switching time when this heuristic is executed in the Android emulator and on the real device. <br><br><img src="https://habrastorage.org/files/1a7/aaa/c8e/1a7aaac8e2c84bdd92de4c2819ccdf66.png"><br>  <i>Figure 2. To optimize, QEMU does not update the value of the virtual command counter after each instruction is executed, so many of the context switching events that may have occurred are not observed in the emulated environment.</i> <br><br>  <b>Defining a QEMU by executing self-modifying code.</b>  As a second heuristic, a new QEMU detection technique (called <b>xFlowH</b> ) was implemented, based on the fact that QEMU does not track the modification of code pages.  The technique is based on the differences in execution threads arising from the execution of the self-modifying code in the emulator and on the real device. <br><br>  ARM processors contain two different caches, one for accessing instructions (I-Cache) and one for accessing data (D-cache).  Harvard architectures (such as ARM) do not provide coherence between data caches and instructions.  Therefore, the processor can execute the old (possibly invalid) section of the code after the new one has already been recorded in the main memory.  This situation can be resolved by maintaining consistency between these two caches, which can be achieved using two operations: 1) cleaning the main memory, so that the new code in the data cache is mixed into the main memory 2) invalidation of the instruction cache, so that it can now be filled with new data from main memory.  In native Android code, this can be done by calling the <b>cacheflush</b> function, which performs the above operations through a system call. <br><br>  An example of self-modifying (machine) code was implemented, which uses a memory segment with rights to execute and write, which is overwritten several times in a loop with the contents of two different functions <b>f1</b> and <b>f2,</b> respectively.  After each change of the code, the code of this segment is launched, which in turn starts either <b>f1</b> or <b>f2</b> .  These are two simple functions that both add their name to the end of the global variable string, so that we can conclude about the sequence of function calls.  To achieve an alternating sequence of calls, you need to synchronize the caches using the <b>cacheflush</b> call, as described earlier. <br><br>  This code, together with additional calls for synchronization after each change, was launched on the mobile device and on the emulator with the same results - each launch produced a sequential launch of functions, as defined in the loop.  Then, the same experiment was performed, but this time the <b>cacheflash</b> call was <b>excluded</b> .  As expected, a random sequence of calls was observed on the mobile device after each launch.  Since the caches are not synchronized before each call, the instruction cache may contain outdated instructions, since it was clearly not recognized as invalid (invalid).  Interestingly, it was found that this behavior is not observed in the emulator.  Instead, the sequence of calls was exactly the same as in the first case, when the caches were matched before each function call.  This behavior is expected, since QEMU discards the translated base unit for the previous version of the code, and forwards the new generated code as it tracks changes in the code pages and ensures that the generated code always matches the target instructions in memory [16]. <br><br><h4>  3. Implementation </h4><br>  The heuristics described in Section 2 were implemented using the Android SDK.  For BTDetecH and xFlowH, Java Native Interface (JNI) was used to run machine code that implements the functionality of each heuristic.  A simple Android application (test application) was developed, which performs the proposed heuristics in the background and for each of them collects information about its effectiveness.  The collected information is sent to the HTTP server for storage in a local database.  In addition, the developed heuristics were included in the set of known malicious Android applications.  To do this, we used Smali / Backsmali [7] along with Aptktool [8], which we used to disassemble and reassemble (repacking applications).  The inclusion of heuristics in malware was done by inserting Smali Dalvik bytecode generated using a disassembler for each heuristic that was previously extracted from the developed test applications.  Each malicious application was modified to contain one of the implemented heuristics, as indicated in Table 2. <br><br>  First, each original sample was launched in the emulator and on a real device, and its behavior was observed with the help of the logcat command (Android logging system) when launching the main Activiti (application screens), as well as services.  Subsequently, changes were made to these components of the application by one of the developed heuristics, which, depending on the results of the heuristics, decided to stop the execution of the component or not. <br><br><img src="https://habrastorage.org/files/d0e/413/651/d0e4136518d846af8ab6a0f348169b50.png"><br>  <i>Table 2. Samples of malicious applications used in the study</i> <br><br>  The repackaged applications were tested in the simulator and on real devices in order to make sure that malicious behavior occurs only on a real device.  It is worth noting that in addition to the above changes in the resulting code of malicious applications, no other additional changes are required in any other parts of the APK files, except for the following cases.  The idH heuristic requires the permission READ_PHONE_STATE explicitly declared in the Android manifest file in order to be able to read the status of the phone.  For the heuristics BTDetectH and xFlowH, you must create the lib directory in the application root directory containing the required machine code as shared libraries. <br><br><h4>  4. Experimental evaluation </h4><br>  This section presents the results of our assessment of the effectiveness of heuristics presented in section 2. Each heuristics was added to a real malicious application and analyzed using various services and dynamic analysis tools.  For each case, there was a record of information about which heuristics managed to detect the emulator and which did not.  First, the set of malicious programs and dynamic analysis services used in the work is described, followed by a brief overview of our methodology, and at the end, the findings are presented and discussed. <br><br><h4>  <i>4.1.</i>  <i>Data and tools</i> </h4><br>  <b>Samples of malicious applications.</b>  The detection technique code, using the process described in section 3, has been added to several widely known malicious Android applications.  Were used 10 samples from different families of malicious applications with different capabilities, including privilege escalation exploits, confidential information leaks, SMS trojans, and so on.  All tested samples are publicly available and are part of the Contagio Minidump [9].  Table 2 summarizes the patterns of malicious applications used along with the heuristics used in each case. <br><br>  <b>Services dynamic analysis.</b>  The services and tools of dynamic analysis used in the assessment are shown in Table 3. Both standalone analysis tools available for download and local use were used, as well as online services that analyze submitted samples online. <br><br>  Three popular tools for analyzing Android applications were used: DroidBox [10], DroidScope [35], and TaintDroid [21].  All three tools execute an Android application in a virtual environment and produce analysis reports.  DroidBox provides information on incoming / outgoing traffic, read / write operations, called services, application permissions bypasses, SMS sent, phone calls made, etc.  DroidScope performs profiling of Android applications at the level of OS calls and APIs, and gives an idea of ‚Äã‚Äãinformation leaks.  TaintDroid is able to efficiently perform system-wide tracking of the flow of data from multiple sources of sensitive data. <br><br><img src="https://habrastorage.org/files/542/3e8/754/5423e8754baf4bf281f3e0060a6f14d9.png"><br>  <i>Table 3. Tools and services for analyzing malicious Android applications used in our assessment</i> <br><br>  In addition to stand-alone tools, publicly available online services were also used that can perform dynamic analysis of Android applications, briefly described below.  Andrudis [14] performs both static and dynamic analysis of unwanted Android applications.  SandDroid analyzes the permissions / components of the application, as well as the detection / classification of its malicious actions.  ApkScan provides information including file access, network connections, phone calls, SMS sent, information leaks, and cryptographic activity.  VisualThreat provides information covering a wide range of activities, ranging from network activity and data leakage, and ending with the detection of malicious application families with correlated API calls.  TraceDroid emulates some actions when analyzing an application, such as user interaction, incoming calls, SMS messages that can detect malicious intentions.  CopperDroid [31] is based on QEMU and out of the box can perform dynamic analysis of Android applications (both at the OS level and API).  APK Analyzer, ForeSafe and Mobile Sandbox [33] are also dynamic analysis services that investigate mobile malicious applications, following the approaches mentioned in the above mentioned tools. <br><br><h4>  <i>4.2.</i>  <i>Methodology</i> </h4><br>  To assess the effectiveness of the presented heuristics, two different approaches were used.  In the first approach, we sent a copy of the application containing all the heuristics described in section 3 to each online service from our set.  During the analysis, the application checks the performance of the heuristics, applying them sequentially to determine whether execution is performed in an emulated environment or not.  For each checked heuristic, the application sends the result to an HTTP server.  After that, you can determine which of the heuristics were effective in identifying a virtualized environment, and which were not. <br><br>  In order to perform a more realistic analysis and demonstrate how such heuristics can complicate the work of various dynamic analysis tools and not allow them to draw wrong conclusions, consider a different approach.  To do this, the existing malicious applications are modified in such a way that they include one heuristic described in section 3 and sent both the original sample and the repackaged into each service.  Then, generated reports are collected and compared to find differences in the observed behaviors. <br><br><img src="https://habrastorage.org/files/729/983/fa4/729983fa436840c2829abde5623021d9.png"><br>  <i>Table 4. The stability of dynamic analysis tools against evasion techniques from virtual machines.</i>  <i>‚Äú‚úì‚Äù indicates resistance to them, ‚Äú‚úó‚Äù indicates vulnerability to them, and ‚ÄúJNI NS‚Äù indicates a lack of support for JNI (calling machine functions from Java applications)</i> <br><br><h4>  <i>4.3.</i>  <i>Dodge results</i> </h4><br>  The results of the effectiveness evaluation are shown in Table 4. The first three lines refer to the offline analysis tools, and the rest to the online analysis services.  The following describes the main conclusions based on the collected results. <br><br>  <b>Conclusion 1.</b> <i>All the studied tools and dynamic analysis services are vulnerable to 5 or more heuristics.</i>  As you can see in Table 4, all tested tools can be easily circumvented using only one of the suggested heuristics.  In particular, only 6 out of 12 tools are resistant to idH simple static heuristics, which checks the IMEI value of the device.  Also, only one analysis service was found, Apk Analyzer, resistant to all presented static heuristics.  In addition, all services are vulnerable to dynamic heuristics based on the use of device sensors, as well as hypervisor heuristics that take advantage of the knowledge of the subtleties of the QEMU code generation algorithms.  Please note that 4 tools (DroidBox, TaintDroid, ApkScan, Apk Analyzer) do not support the execution of machine code at all, which means that it is impossible to test the effectiveness of hypervisor heuristics on them.  This conclusion was made after receiving the exception message when trying a test application to load machine code via JNI.  All these messages were included in http requests containing results. <br><br>  <b>Conclusion 2.</b> <i>All analysis tools failed to draw the correct conclusion about the malicious behavior of repackaged malware samples.</i>  A comparison was made of all the reports prepared by hand when studying analysis tools (both offline and online), following our second approach for evaluation, and the observed results are consistent with those related to the first method.  ,  ,   ,           ,         .    -      ,   -    . <br><br> <b> 3.</b> <i>  -    ,       .</i>             -  (CopperDroid, Visual Threat  APK Analyzer)    .   ,          .   ,  ,         ,           .  ,    ,            ,   ,       . ,    ,        ,    ,        . <br><br> <b> 4.</b> <i>            .</i>     ,     ,   Apk Analyzer        ,        (,    ¬´,     ,   ¬ª).  ,        ,  . ,   ,   idH  buildH,      ,   ,       .  ,  netH      ,  IP-        Android     10.0.2.15   192.168.0.24.   ,    netH   ,         IP-  0.0.0.0,     ADB   /proc/net/tcp. <br><br> , Apk Analyzer      ,      . ,  ,      ,  accelH,           Apk Analyzer'a.  ,  ,     ,   , Apk Analyzer    ,      . <br><br><h4> 5.  </h4><br>            ,              ,     .  , Google Bouncer,    ,   ,    ,      Google Play,    ,      Android   QEMU. Google Bouncer       [11].      ,         Android       . <br><br> <b> .</b>  Android      ,       .   ,   IMEI  IMSI,     idH,      Android.         ¬´Telephony Manager¬ª   Android,   ,     ,     QEMU [12].   IMEI  IMSI     ,     .  buildH,      ,   ,   ,    Android.      build.prop    Android. ,      Android        netH,      Apk Analyzer. <br><br> <b>    .</b>   ,  ,    ,   .   ,  Android        ,     ,   ,     .    (accelH, magnFH, rotVacH, proximH  gyroH)    .            .   ,                ,     ,       .   ,     - [4]      [23]  ,            Android. <br><br> <b>  .</b>   ,   QEMU,     BTdetectH,      Android,      ARM     x86  ,          x86.  BTdetectH,     2,      Android,    .      ,     QEMU     ,    .  ,        ,  ,     .  ,           QEMU.   ,         ,   QEMU,     Android,   (,        ,      ). <br><br> <b>  .</b>             ,     ,      ,           . ,      ARM [15]   ,          .    (QEMU)  ,  BTdetecH  xFlowH,       ,  . <br><br> <b>  .</b>  ,              ,   .   (BTdetecH  xFlowH)       .             ,      .  , -         Android,    ,  ;        ,    ,        . <br><br><h4> 6.   </h4><br>    [30]             Android .    ,         .        .    ,              Android.    [32] ,                Android,       TaintDroid,      ,      .       TaintDroid     . <br><br>   ,        .    [29]       .     ,     ,  MSR,   ,      .    [34]        ,          .             (,        ,     ,    ),         xFlowH. <br><br>    [27]     ¬´ ¬ª,  ,         .       ,       ¬´ ¬ª,     ,    : QEMU  BOCHS.    [24]  DISARM,        .        ,  ,     ,   ,         .     ,           x86.        ,         ,  ,     Android (     ARM). <br><br><h4> 7.  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article explored how to get around dynamic analysis using malicious applications aimed at the Android platform. Heuristics of increasing complexity were implemented and tested by including them in samples of real malicious applications that try to hide their presence when analyzed in an emulated environment. All repackaged malware samples were tested in stand-alone analysis tools and publicly available scanning services, and their behavior was examined. Not a single service or tool was found that cannot be ignored by at least a few of the presented heuristics. The work carried out raises important questions about the effectiveness of existing analysis systems for malicious Android applications.For this reason, a number of possible countermeasures have been proposed to improve the resilience of dynamic analysis tools for malicious Android applications against detection of virtual machines.</font></font><br><br><h4>    </h4><br> [1] <a href="http://googlemobile.blogspot.com/2012/02/">googlemobile.blogspot.com/2012/02</a> <br> android-and-security.html. <br> [2] <a href="http://vrt-blog.snort.org/2013/04/changingimei-provider-model-and-phone.html">vrt-blog.snort.org/2013/04/changingimei-provider-model-and-phone.html</a> . <br> [3] <a href="http://blog.sfgate.com/techchron/2013/10/10/">blog.sfgate.com/techchron/2013/10/10</a> <br> stanford-researchers-discover-alarmingmethod-for-phone-tracking-fingerprintingthrough-sensor-flaws/. <br> [4] <a href="http://code.google.com/p/openintents/wiki/">code.google.com/p/openintents/wiki</a> <br> SensorSimulator. <br> [5] <a href="http://developer.android.com/reference/">developer.android.com/reference</a> <br> android/hardware/SensorManager.html. <br> [6] <a href="https://bluebox.com/corporate-blog/androidemulator-detection/">bluebox.com/corporate-blog/androidemulator-detection</a> . <br> [7] <a href="http://code.google.com/p/smali/">code.google.com/p/smali</a> . <br> [8] <a href="http://code.google.com/p/android-apktool/">code.google.com/p/android-apktool</a> . <br> [9] <a href="http://contagiominidump.blogspot.com/">contagiominidump.blogspot.com</a> . <br> [10] <a href="http://code.google.com/p/droidbox/">code.google.com/p/droidbox</a> . <br> [11] <a href="https://www.duosecurity.com/blog/dissectingandroids-bouncer">www.duosecurity.com/blog/dissectingandroids-bouncer</a> . <br> [12] <a href="https://codepainters.wordpress.com/2009/12/11/">codepainters.wordpress.com/2009/12/11</a> <br> android-imei-number-and-the-emulator/. <br> [13] 99% of all mobile threats target Android devices. <a href="http://www/">www</a> . <br> kaspersky.com/about/news/virus/2013/99_of_all_ <br> mobile_threats_target_Android_devices. <br> [14] Anubis/Andrubis: Analyzing Unknown Binaries.  http: // <br> anubis.iseclab.org/. <br> [15] Arm: Virtualization extensions. <a href="http://www.arm.com/">www.arm.com</a> <br> products/processors/technologies/ <br> virtualization-extensions.php. <br> [16] QEMU Internals. <a href="http://ellcc.org/ellcc/share/doc/">ellcc.org/ellcc/share/doc</a> <br> qemu/qemu-tech.html. <br> [17] T. Bl√§sing, A.-D. Schmidt, L. Batyuk, SA Camtepe, and <br> S. Albayrak. An android application sandbox system for suspicious <br> software detection. In MALWARE, 2010. <br> [18] Bramley Jacob. Caches and Self-Modifying Code.  http: // <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">community.arm.com/groups/processors/blog/2010/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">02/17/caches-and-self-modifying-code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[19] J. Calvet, JM Fernandez, and J.-Y. Marion. Aligot: cryptographic </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binary programs. In CCS, 2012. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20] S. Dey, N. Roy, W. Xu, and S. Nelakuditi. Acm hotmobile 2013 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poster: Leveraging </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smartphones </font><font style="vertical-align: inherit;">for fingerprinting </font><font style="vertical-align: inherit;">. SIGMOBILE Mob. Comput. Commun. Rev., 17 (3), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nov. 2013. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[21] W. Enck, P. Gilbert, B.-G. Chun, LP Cox, J. Jung, P. McDaniel, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and AN Sheth. Taintdroid: real-time </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privacy monitoring </font><font style="vertical-align: inherit;">system </font><font style="vertical-align: inherit;">for smartphones. In OSDI, 2010. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[22] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A study of</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">android application security. In USENIX Security ,, 2011. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[23] L. Gomez, I. Neamtiu, T. Azim, and T. Millstein. Reran: Timingand touch-sensitive record and replay for android. In ICSE, 2013. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[24] M. Lindorfer, C. Kolbitsch, and P. Milani Comparetti. Detecting </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">environment-sensitive malware. In RAID, 2011. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[25] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. CHEX: Statically Vetting </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android apps for Component Hijacking Vulnerabilities. In CCS, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2012. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[26] F. Matenaar and P. Schulz. Detecting Android Sandboxes.</font></font> http: // <br> <a href="http://www.dexlabs.org/blog/btdetect">www.dexlabs.org/blog/btdetect</a> . <br> [27] R. Paleari, L. Martignoni, GF Roglia, and D. Bruschi. A fistful of <br> red-pills: how to automatically generate procedures to detect cpu <br> emulators. In WOOT, 2009. <br> [28] TH Project. Android Reverse Engineering (ARE) Virtual <br> Machine. <a href="http://www.honeynet.org/node/783">www.honeynet.org/node/783</a> . <br> [29] T. Raffetseder, C. Kruegel, and E. Kirda. Detecting system <br> emulators. In ISC, 2007. <br> [30] V. Rastogi, Y. Chen, and X. Jiang. Droidchameleon: evaluating <br> android anti-malware against transformation attacks. In ASIA CCS, <br> 2013. <br> [31] A. Reina, A. Fattori, and L. Cavallaro. A system call-centric analysis <br> and stimulation technique to automatically reconstruct android <br> malware behaviors. In EUROSEC, 2013. <br> [32] G. Sarwar, O. Mehani, R. Boreli, and D. Kaafar. On the effectiveness <br> of dynamic taint analysis for protecting against private information <br> leaks on android-based devices. In SECRYPT, 2013. <br> [33] M. Spreitzenbarth, F. Freiling, F. Echtler, T. Schreck, and <br> J. Hoffmann. Mobile-sandbox: Having a deeper look into android <br> applications. In SAC, 2013. <br> [34] C. Willems, R. Hund, A. Fobian, D. Felsch, T. Holz, and <br> A. Vasudevan. Down to the bare metal: Using processor features for <br> binary analysis. In ACSAC '12, 2012. <br> [35] LK Yan and H. Yin. DroidScope: Seamlessly reconstructing the <br> OS and Dalvik semantic views for dynamic Android malware <br> analysis. In USENIX Security, 2012 </div><p>Source: <a href="https://habr.com/ru/post/269999/">https://habr.com/ru/post/269999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269989/index.html">Solving the problem of installing GitHub for Windows with Amazon Web Services S3</a></li>
<li><a href="../269991/index.html">Practical application of Fourier transform for signal analysis. Introduction for beginners</a></li>
<li><a href="../269993/index.html">JSON for fans of braces</a></li>
<li><a href="../269995/index.html">Cloud for development companies: BadgeKeeper Achievement System Designer - Developer Service</a></li>
<li><a href="../269997/index.html">October 31, 2015 - EOL applications for Kerio Control 7 for Windows (Post # 3 - free webinar (November 13, 2015)</a></li>
<li><a href="../270001/index.html">Do good code: 8 good code rules</a></li>
<li><a href="../270003/index.html">JetBrains Toolbox came out with all updated desktop products</a></li>
<li><a href="../270005/index.html">Service Locator breaks encapsulation</a></li>
<li><a href="../270009/index.html">Memory Management: A View from the Inside</a></li>
<li><a href="../270011/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ183 (October 26 - November 1, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>