<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The data structure of the project OpenStreetMap, look under the skirt service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 

 The project OpenStreetMap (OSM) of open geographic information data under the free license CC-BY-SA (and soon under the Open Database Lice...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The data structure of the project OpenStreetMap, look under the skirt service</h1><div class="post__text post__text-html js-mediator-article"><h2>  Prologue </h2><br><br>  The project OpenStreetMap (OSM) of open geographic information data under the free license CC-BY-SA (and soon under the Open Database License) is widely known not to waste time on its detailed presentation.  The main feature of the project and its main advantage compared to any other analogues was the principle of fully open geographic data, which can be used by anyone and in any way (under the CC-BY-SA license) and can be freely supplemented and refined by any project participant.  Like any other data, geographic data is also subject to structuring during storage and processing.  In this article I will try to describe the main parts of the OSM data structure, focusing more on the adopted data types and their representation in spatial form.  Working constantly with the data of the OSM project it is often necessary to clarify or clarify some basic aspects, so it became necessary to briefly present them in the form of one text. <br><a name="habracut"></a><br>  In general, the entire data structure can be represented schematically in the following figure: <br><img src="https://habrastorage.org/getpro/habr/post_images/81b/a5e/4fc/81ba5e4fc616b384c7e2850544234cbc.png" alt="Figure 1. OpenStreetMap data structure"><br>  Figure 1. OpenStreetMap data structure. <br><br>  All data can be divided into three main groups: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  data types that describe in the form of a hierarchical relationship the object itself, as a kind of spatial entity, having its own final result - the known coordinates of all parts of the object; </li><li>  the informational part is a descriptive characteristic of an object that does not have a direct relationship to the spatial geographical structure of the object (its name, physical, logical, and other properties); </li><li>  object service attributes necessary to organize the process of storing and processing information in the form of a data set, such as a unique identifier, the state of an object in the database, the time of the last editing of an object in the database, etc. </li></ol><br><br>  I will not dwell on the service attributes of objects, I will only note that any independent object in OSM and their characteristics have them, and the specific version of the project‚Äôs API defines the binding nature of certain attributes.  Currently, this is API version 0.6. <br><br><h2>  Part 1. Basic types of geographic data in OpenStreetMap </h2><br><br>  There are basically three basic types: point ( <b>node</b> ), line ( <b>way</b> ), and relation ( <b>relation</b> ).  In this case, I am not using the translation of the data types themselves, but their actual property.  The types node, way, and relation are called so, because that is how they were originally invented.  One and all objects in OSM are described by these three types of data, after which information is filled with combinations of tags.  The data model in OSM is built on a hierarchical reference structure, which means that any subsequent data type does not contain the information contained in the previous types, but forms a new entity, referring to some set of objects of the previous type.  It should also be mentioned that any object in the OSM data structure has its own identifier (ID), unique within this type of object.  It is by this identifier that the link to the object itself occurs.  Consider the structure of the basic types in order. <br><br>  <b>The first type: a point (node)</b> is a minimum data set that contains information about a pair of coordinates: latitude, longitude (lat, lon) and is basic in the hierarchical model.  This is the only data type that stores geographic information itself - coordinates, in the form of latitude and longitude.  The OSM data model operates exclusively on two-dimensional data within the WGS84 projection.  In the future, we will assume that the coordinates are not the information component of the object of a point, but an integral part of its structure.  In XML notation, an object of this type will look like this: <br><br><pre>  &lt;node id = '19 'lat = '58 .888047127548994' lon = '49 .747870758186764 '/&gt; </pre><br><br>  One point with a unique id of 19 and a pair of coordinates.  Coordinates in OSM are used in decimal notation, as it is much easier to process than coordinate formats with minutes and seconds.  By itself, a point can be an independent object, describing a point object (geometric primitive) or not having its own information component at all, but being part of another object (line or relationship).  At the same time, running a little ahead, I note that the point at the same time can be an independent object, carrying unique information and be part of another object. <br><br>  <b>The second data type: line (way)</b> is a collection of pointers to objects of the type point (node).  At a minimum, the line consists of a single point, i.e.  must contain at least one link to an already existing object of type point.  A line from one point does not contradict the OSM data structure, but contradicts the concepts of elementary geometry and causes fainting and panic in some too vulnerable data processing algorithms, therefore the correct line always contains at least references to two existing objects of the type of point. <br><br>  The correct XML notation of the line type object will consist in the description of all necessary points, followed by the record itself about the line that lists all its points.  In its simplest form, it will look like this: <br><br><pre>  &lt;node id = '23 'lat = '58 .875047918145675' lon = '49 .785240674006126 '/&gt;
 &lt;node id = '22 'lat = '58 .86687448573524' lon = '49 .737090974777324 '/&gt;<font></font>
<font></font>
 &lt;way id = '24 '&gt;
   &lt;nd ref = '22 '/&gt;
   &lt;nd ref = '23 '/&gt;
 &lt;/ way&gt; </pre><br><br>  The order of listing points in a line is important; it characterizes the sequence of points in a line and the direction of the line itself, i.e.  a line always has a beginning and an end, even if it is closed (in this case they simply coincide).  In this example, we first described two points, specifying their coordinates, and then describing a line, referring to the id of these points.  One point can enter any number of line objects, and it should be described only once, i.e.  the point may be common to two lines, in which case the link to it is contained in both lines.  Thus, an integral graph of objects is built (most often a road graph for calculating routing), which is a collection of objects (lines) that are connected through their common members (points). <br><br>  If we want to create another line from the already existing points 19 and 23, then we describe it as follows: <br><br><pre>  &lt;way id = '48 '&gt;
   &lt;nd ref = '19 '/&gt;
   &lt;nd ref = '23 '/&gt;
 &lt;/ way&gt; </pre><br><br>  In our case, points 19 and 23 have already been described above, and point 23 has become part of two lines 24 and 48 and has become common to them. <br><br>  Our lines 24 and 48 can be represented graphically in the projection of the mercartor as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2c/adb/72a/a2cadb72a0f79e5d876412c476d6f884.png" alt="Figure 2. Two lines"><br>  Figure 2. Two lines <br><br>  Captions in the figure are object id: red for dots, black for lines;  the arrow indicates the direction of the line, i.e.  both lines end at point 23. <br><br>  <b>The next data type is relation</b> .  In fact, all objects except the point are already relations, but the lines are separated into a separate data type as the most common, describing the main geometric primitives: lines, polylines and polygons.  For all more complex geometric objects, as well as for objects that are not purely geometric, but logical (collections, lists, hierarchies of interrelations), a universal data type is intended - relations. <br><br>  In general, the description of a relationship differs from a line in that a line is always a collection of points, and a relationship is a collection of any objects, such as points and lines, and other relations.  Therefore, in a relationship, not only the object id is indicated, but also its type.  In the most minimal variant the relation can contain the reference only to one object.  Using the objects described in the examples above, you can write a relation: <br><br><pre>  <font color="#000099">&lt;relation id = '31 '&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;member type = 'way' ref = '24 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;member type = 'node' ref = '19 '/&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ relation&gt;</font> </pre><br><br>  This is a fictitious abstract relation describing that it contains two objects (members of the relation) - point 24 and line 19 and no longer carrying any other information.  In the real case, the relationship must specify the type as a tag (informational component) of the relation object itself, and the members of the relationship must specify the roles in the references to the objects. <br><br>  Below is an example of the most common multipolygon type relationship, which describes one closed outer polygon of three points with a closed polygon cut from it, also from three smaller points.  The geometric primitives (closed and non-closed polygons) and object tags will be discussed further, but for now you should pay attention to the role parameters of the relation objects and the presence of a tag describing the type. <br><br><pre>  <font color="#000099">&lt;node id = '1218' lat = '58 .870941122729505 'lon = '49 .758021019729554' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '1216' lat = '58 .8704000725183 'lon = '49 .74703196841415' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '1215' lat = '58 .879055860772034 'lon = '49 .74964840920353' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '1209' lat = '58 .86471853452049 'lon = '49 .780522410518245' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '1207' lat = '58 .863365649894774 'lon = '49 .72453057762546' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '1206' lat = '58 .892035483174 'lon = '49 .74755525657201' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;way id = '1217'&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1215' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1216' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1218' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1215' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ way&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;way id = '1208'&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1206' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1207' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1209' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '1206' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ way&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;relation id = '1221'&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;member type = 'way' ref = '1208' role = 'outer' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;member type = 'way' ref = '1217' role = 'inner' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'type' v = 'multipolygon' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ relation&gt;</font> </pre><br><br>  The outer role indicates that this object will be the outer contour of the graphic object, and the inner role indicates that the space inside this object should be excluded from the area of ‚Äã‚Äãthe resulting object.  Graphically, our multipolygon will look like this: <br><br><a name="multipolygon"></a><img src="https://habrastorage.org/getpro/habr/post_images/fad/746/0fc/fad7460fcb0afa32642de45a177639ca.png" alt="Figure 3. Multipolygon"><br>  Figure 3. Multipolygon <br><br>  As with the line, for a relationship, the order of enumeration of members plays a role and is taken into account when using this relationship.  For example, a relation may not be a geometric figure, but a route of public transport (logical scheme), then it includes successive sections of roads along which the bus will move and a list of points ‚Äî stops at which it stops; therefore, the order of switching on the roads shows the sequence of the route and the order of stops is the sequence of their visits. <br><br>  The relation object can be a member of another relation, while the nesting level and the hierarchy upwards is not limited by anything.  The structural constraint is that the relation object cannot be a member of itself, i.e.  contain links to yourself.  Recursion in the structure of data types in OSM is unacceptable, although of course nothing prevents to create such an object and even quite successfully insert it into the database. <br><br>  Having defined three basic types of objects, it is necessary to introduce the notion of initial and final objects.  <b><i>The initial</i></b> object is any object that is part of any other object, i.e.  It is a child of at least one object, but it itself does not include any other object.  In the case of OSM this is always the point.  Or its other definition - the initial object carries in its structure (not in the information part!) Only geographical coordinates and does not contain references to other objects. <br><br>  <b><i>The final</i></b> object is the hierarchy-maximum parent object, which is not a child with respect to any other object, i.e.  not part of any other object.  It can be any of the three types listed: points, lines, relations.  A separate point object, not entering anywhere, consisting of a single object of type point, is not the initial object, because it is not the beginning of a hierarchy of objects, but it is the final object, because the spatial description of the object ends on it. <br><br><h2>  Part 2. Information scheme of objects </h2><br><br>  An object type describes the geographical (spatial) properties of an object, but says nothing about the properties of the object itself, its characteristics, purpose, and so on.  For this there is an informational part of the OSM data structure based on the principles of tagging objects, i.e.  assigning them certain labels and specifying the properties of these labels.  Tags are specified as key = value pairs, which in XML notation for our line 24 looks like this: <br><br><pre>  <font color="#000099">&lt;way id = '24 '&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '22 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '23 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'highway' v = 'primary' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ way&gt;</font> </pre><br><br>  In this case, we added the property of our line, namely, we specified the highway tag with the primary value, which in the accepted tagging scheme means that our line is the main road (the class road is lower than the main road, but higher than the secondary one).  Any object can have any number of tags, which allows you to set all its basic properties and describe all the minor parameters, as well as add any information to the object in an arbitrary form.  The tagging scheme itself in OSM is at the same time its most important architectural advantage, since it allows one to describe virtually any properties of an object, since  no one really restricts you in choosing new tags for new properties of objects;  and at the same time the most painful of its place, because any freedom in choosing the means of designation always gives rise to religious wars of various groups of users who have not concurred how to designate one or another controversial object. <br><br>  If we slightly expand the informational description of our two lines 24 and 48 from the first part, we can get something like: <br><br><pre>  <font color="#000099">&lt;node id = '23 'lat = '58 .87753645355202' lon = '49 .79290110146539 '&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'highway' v = 'traffic_signals' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ node&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '22 'lat = '58 .87456113991739' lon = '49 .73690926857261 '/&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;node id = '19 'lat = '58 .89362576054878' lon = '49 .7492065402827 '/&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;way id = '48 '&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '19 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '23 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'embankment' v = 'yes' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'highway' v = 'secondary' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'incline' v = 'up' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'lanes' v = '2' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'maxspeed' v = '60 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'name' v ‚Äã‚Äã= 'Pozharsky street' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ way&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;way id = '24 '&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '22 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;nd ref = '23 '/&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'highway' v = 'primary' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'lanes' v = '6' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'lit' v = 'yes' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'name' v ‚Äã‚Äã= 'Minin Avenue' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'oneway' v = 'yes' /&gt;</font> <font color="#000099">
  </font>  <font color="#000099">&lt;tag k = 'ref' v = 'M84' /&gt;</font> <font color="#000099">
</font>  <font color="#000099">&lt;/ way&gt;</font> </pre><br><br>  Line 48 here has become ‚ÄúPozharsky Street‚Äù, with a speed limit of 60 km / h, a number of lanes equal to two, with a positive gradient of slope away from point 19 to point 23, which is a secondary road and raised relative to the ground level on the embankment.  And line 24 is our main road (class higher than secondary) with 6 lanes of traffic, having stationary lighting and one-way traffic permitted in the direction from point 22 towards point 23, is called Minin Avenue and is part of the federal highway M84.  Both roads have a common point of 23, which is a crossroads with traffic lights. <br><br>  Writing in detail the current agreements on tagging is not the task of one article; for this, there is a separate draft wiki documentation for fixing the accepted agreements <a href="https://habr.com/ru/post/146503/">[1]</a> .  Let us dwell only on the basic principles of tagging. <br><br><ul><li>  On any final object must be tags, no matter how long the hierarchy.  Any geographical (spatial) description of the object must end with at least one information property of the object.  The ‚Äútype = (multipolygon | *)‚Äù tag for relational objects is an exception, it is not informational, it is part of the structure of which relations are described, i.e.  besides it there must be at least one more tag.  We gave the definition of the final object in the first part. </li><li>  Tags can be perfect on any type of object.  The presence or absence of tags on one object as part of another object does not affect the necessity or prohibition of the presence of tags on another object, unless they of course do not contradict each other logically and are not redundant.  For example, a line may have a tag that it is a road, and at points that are part of this road there may be tags describing point objects at these points - traffic lights, speed bumps, etc., i.e.  the point is not being a final object (part of the road), however, it can independently describe any object. </li><li>  Tags of a single object must be unique, i.e.  An object cannot contain two identical tags with different values, for example, highway = primary and highway = secondary within the same object is not allowed.  Some software can use enumerated value types, for example highway = primary; secondary can be interpreted as highway = primary and highway = secondary at the same time, but most software interprets as "highway" = "primary; secondary", where "primary; secondary" will not be match neither primary nor secondary. </li><li>  Tags describing the properties of an object should be only on the object itself.  It sounds so logical that even a little silly, but it really delivers a lot of trouble when processing data.  The point is that no object properties should be duplicated on the members of this object or on the parent objects.  If we take, for example, the ‚Äúforest‚Äù object, described as a closed polygon with the natural = wood property, then this property should not be entered into each point from which the polygon is built clearly even for a small child, but things are much more complicated with relationships and multipolygons.  Let us consider the variant with the same forest, but already executed not as a polygon, but as a multipolygon, i.e.  in the form of a relation consisting of at least two closed polygons: the outer (the outer role) and the inner (the inner role).  In this case, the natural = wood property should not be on the polygon with the outer role, but on the relation itself.  If the relationship includes several objects with the same properties as with different, then all the properties common to all members should be described in the relation itself, i.e.  in their parent object, and unique properties on each object whose properties they describe.  Returning to the same forest, let's say we have several members with the outer role and how many (or not, that is also possible) inner members.  At the same time, all outer members are a forest, but each of them has its own name, so the natural = wood tag must be on the relation itself, and the unique name tags on each of the outer polygons have their own. </li></ul><br><br><h2>  Part 3. Geometric primitives </h2><br><br>  The main or at least the most common task for any geographic spatial data is to obtain a graphical representation of the objects described by this data.  Simply put, the rendering of the maps, schemes, plans themselves.  The algorithms, rules, styles, and methods of rendering maps are already the task of application software, but it all comes down to drawing the basic geometric primitives, which are obtained from the objects of the three data types listed in the first part. <br><br>  <i>Further I will refer to data types in the form of their notation in OSM, i.e.</i>  <i>node, way, and relation, so as not to be confused with geometrical objects by points, lines, polylines, etc., therefore, below the line I will not mean the geographical spatial data type way in OSM, but the geometric figure - the line that is the shortest distance between two points on the plane.</i> <br><br>  So, what are the basic geometric primitives. <br><br>  <b>A point</b> is a single object of type node.  Its position in a given projection on the map corresponds to its spatial position in geographic coordinates.  One pair of lat / lon coordinates is translated into x / y coordinates of the map, taking into account the projection. <br><br><h5>  line features </h5><br><br>  <b>The line (line)</b> is, as we have said, the shortest distance between two points corresponds to an object of type way, containing two node objects.  Any two nodes, since we operate with a flat space, and therefore the distance between any two points will always be a straight line. <br><br>  <b>A polyline</b> is a connected sequence of segments, where each segment is one line, connected by its end with the beginning of the next segment.  The whole sequence is a single whole object.  Corresponds to a way object containing three or more nodes.  A polyline can be a relation object containing successively included way objects, where each next way object begins with a node object that ended the previous way.  A polyline can be either a way object containing a node, or a relation containing a way, i.e.  cannot be a relation containing both way and node at the same time, however, it can be a relation object containing both a way and other relational containing only way objects. <br><br>  Types of polylines: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8fa/a9e/415/8faa9e415de296709fd2724b860e5f26.png" alt="Figure 4. Polyline"><br>  Figure 4. polyline = way (node1, node2, node3, node4) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e44/1af/eae/e441afeaeae53c4ee4d52f6ee50a723c.png" alt="Figure 5. Polyline"><br>  figure 5. polyline = relation (way1 (node1, node2), way2 (node2, node3), way3 (node3, node4)) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/988/d81/d57/988d81d57b516a7f7d734a916e1dc327.png" alt="Figure 6. Polyline"><br>  figure 6. polyline = relation2 (way1 (node1, node2), relation1 (way2 (node2, node3), way3 (node3, node4))) <br><br><h5>  areal objects </h5><br><br>  <b>A polygon</b> is a closed polyline whose last point is the same as the first.  In OSM data types, there is a way object with several (three or more) node objects, and the number of members of the way object is always one more, since  The first node object is repeated twice: at the beginning and at the end of the list.  A polygon can also be assembled in the form of a relation, in which the successively included way, forming a jointly closed contour, i.e.  the beginning of each way object corresponds to the end of one other way object.  Unlike a polygon in a way, a polygon in a relation does not duplicate the last object in the enumeration from the first, since it is necessary for the way due to the fact that it refers to node objects and only by the fact of duplicating node as the first and last element of the list of members can be judged about the fact that this is a closed polygon, and not a linear polyline object.  In a polygon assembled as a relation, the last node object of the last included way object or the relation containing the way corresponds to the first node object of the first included way. <br><br>  In the case of a polygon described in the form of a relation, the type = multipolygon tag must be indicated on the relation object itself.  Thus, we determine that we are talking about an areal geometric, and not a linear object. <br><br>  Types of polygons: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/ea1/437/fdbea1437650468a5cfa35a695bca078.png" alt="figure 7. polygon"><br>  figure 7. polygon = way (node1, node2, node3, node4, node1) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf3/0bb/b9a/bf30bbb9ad225c4fc018cff596d79296.png" alt="figure 8. polygon"><br>  figure 8. polygon = relation (way1 (node1, node2, node3), way2 (node3, node4), way3 (node4, node1)) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da9/a55/c16/da9a55c16aefaf5eb9372cf5aa6f139d.png" alt="figure 9. polygon"><br>  figure 9. polygon = relation3 (relation1 (way1 (node1, node2, node3), way2 (node3, node4), way3 (node4, node5), way4 (node5, node6, node7)), relation2 (way5 (node7, node8) , way6 (node8, node1))) <br><br><h5>  composite objects </h5><br><br>  Composite objects are objects that cannot be described by a single primitive way, always built on the basis of relational objects whose type = multipolygon.  Polygons and polylines described as a relation can always be simplified to a single way object, while a composite object in the most simplified case gives at least two way objects.  For example, this is a square figure (polygon) from which another figure is mathematically subtracted (a smaller polygon).  An example of a multipolygon, which is a composite object, with an illustration was <a href="https://habr.com/ru/post/146503/">given in the first part</a> , in the description of relation objects. <br><br>  Multiple polygons for composite objects, as well as polygons and polylines, can be assembled from a simple way or from another relation consisting of any number of ways.  For such a multipolygon it is necessary to indicate the role for each incoming member, be it a way or a relation.  There must be at least one member with the outer role.  It is an object or objects with this role that define the main (external) geometric contour of the resulting object.  Objects with the inner role may not be in the particular case, but then such a multipolygon is an ordinary polygon, simply described redundantly.  Objects with the inner role indicate which areas inside the outer contour are not part of the resulting shape.  For example, it is a clearing in the forest or a courtyard of the house, bounded on all sides by the walls of this house. <br><br>  All objects with one role in one multipolygon should be collected in one or several closed contours that do not intersect at the boundaries. <br><br><h2>  Restrictions and agreements on the use of graphic primitives described as a relation </h2><br><br>  Despite the simplicity, consistency and scalability of the construction of data objects of the relation in the real world of OSM, they have a huge number of limitations associated primarily with the limitations of the current software data processing algorithms.  Therefore, there are a number of agreements on the use of relation objects in certain situations.  All of them can be reduced to the following main points: <br><br><ol><li>  All areal objects described by a relation are multipolygons, i.e.  have type = multipolygon and a mandatory indication of the role for members of outer | inner, thus  the polygons in figures 8 and 9 are always only multipolygons; </li><li>  There are only two linear generally accepted objects described by relation: type = boundary for administrative boundaries and type = route for public transport routes, all other types or relation without types are simply collections or lists of objects and are not treated as geometric objects;      5  6         ,    ,       relation,        ; </li><li>    relation,  type = multipolygon|boundary|route ‚Äî    ,         -   ,            . </li></ol><br><br><h2>  4.  ,   ? </h2><br><br>         OSM,            .            OSM    ,    . <br><br>        ,  OSM       .  ,    .     relation  ,    way      ,            ,    ,     way          ,   ,   .       ,     ,        ,   ,    .              .          ,           ,    () ,      . <br><br>      ,      ,       ,                 .       ,  OSM        ,       area=yes    ,      area=no.    ,   ,        ,                    area=yes.       ,        ,     , ,        ,       . <br><br>      ,    ,        .         (     type=multipolygon       ),   -            ,    .         ‚Äî          . <br><br>  ,    OSM            ,         node.   , <b>area</b> ,                ,        .         way        ,    .        relation   ,       ,          .      OSM      relation. <br><br>    area,                 .     relation  ,     ,        ,    type,   type=polyline    multipolygon,    ,    ,      ,     area. <br><br> ,             OpenStreetMap. <br><br><a name="1"></a> [1] ‚Äî      OSM, : <a href="http://wiki.openstreetmap.org/wiki/Map_Features">http://wiki.openstreetmap.org/wiki/Map_Features</a>  : <a href="http://wiki.openstreetmap.org/wiki/RU:Map_Features">http://wiki.openstreetmap.org/wiki/RU:Map_Features</a> </div><p>Source: <a href="https://habr.com/ru/post/146503/">https://habr.com/ru/post/146503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146497/index.html">Infographics - the danger of wireless networks in terms of security</a></li>
<li><a href="../146499/index.html">How to grow an IT manager in high school?</a></li>
<li><a href="../146500/index.html">What happens on the Internet in 1 minute? (infographics)</a></li>
<li><a href="../146501/index.html">Speech Recognition on STM32F4-Discovery</a></li>
<li><a href="../146502/index.html">Nikon Hand Strap II wrist strap as alternative to neck strap</a></li>
<li><a href="../146504/index.html">Windows 8: Interface Design</a></li>
<li><a href="../146505/index.html">Video review of Asus N46 / N56 / N76 laptops</a></li>
<li><a href="../146506/index.html">Larry Page lost his voice</a></li>
<li><a href="../146507/index.html">Helping KeePassX to work with Indicator Applet Complete in the latest Ubuntu versions</a></li>
<li><a href="../146508/index.html">Game 15</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>