<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interpolation + (linear | logarithmic) scale + –° ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It took me somehow to make an interface for loading into the microcontroller a graph of the function ‚Äúresistance -> temperature‚Äù (they decided to set ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interpolation + (linear | logarithmic) scale + –° ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/cde/305/ecd/cde305ecd6e70db71f3206a2f7a60739.png" align="left">  It took me somehow to make an interface for loading into the microcontroller a graph of the function ‚Äúresistance -&gt; temperature‚Äù (they decided to set the graph by several points, and then interpolate them).  Along the way, it turned out that the schedule would be very non-linear (180 ohms -&gt; 100 <sup>o</sup> , 6 000 ohms -&gt; 0 <sup>o</sup> , 30 000 ohms -&gt; -30 <sup>o</sup> ).  So I had to immerse myself in the subject of <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B0%25D1%2580%25D0%25B8%25D1%2584%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2588%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B0">logarithmic scales</a> ... and immediately emerge, since I did not find what I needed.  And all I needed was to understand mathematics (and the implementation in C ++) of such cases.  Wonderful - like this is a necessary topic, but not painted!  Well, okay - the brains squeaked and remembered the highest mathematics from the university, and the program was written.  I decided to describe my ordeal here - maybe someone will come in handy. <br><br>  In this article I will write out the theory (as well as the basic virtual classes), next I will take up concrete implementations using Qt tools. <br><br>  <i>Caution: there are a lot of graphics in the text!</i> <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Where the legs grow from the task </h4><br>  In general, <a href="http://we.easyelectronics.ru/Theory/pid-regulyatory--dlya-chaynikov-praktikov.html">I need to make an idling regulator</a> - such a thing for a car that, when idling, depending on the temperature of the engine, must maintain certain revolutions.  It supports them by adjusting the damper with a stepper motor. <br><br>  In general, I need to know the current temperature.  It was decided to measure it by standard means - with a thermistor.  We measure the voltage drop on it - we get resistance.  Further from the table (since it is a microcontroller) we get the required speed. <br><br>  This table must be set (for this program is written by means of Qt).  I have a few ‚Äúresistance =&gt; temperature‚Äù points.  I need for each ADC code (for a number of values ‚Äã‚Äãof proportions) to obtain the appropriate temperature.  Since different cars may have different values, it‚Äôs necessary to specify several points on the curve on the screen, referring to the table. <br><br>  Along the way, it turned out that this graph will be clearly on a logarithmic scale.  So you need to display it on the screen.  How to do it - read on. <br><br><h4>  Formulation of the problem </h4><br><br>  Let's describe in more detail what we need: <br><br><ol><li>  <i>setting the function</i> - it is necessary to set several points on which the graph is built.  In general, we recall the <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">interpolation</a> ; </li><li>  <i>plotting a function</i> - yes, yes, I know about <a href="http://qwt.sourceforge.net/">Qwt</a> .  Maybe not very well, I know him, because I have not found the following opportunity in him: </li><li>  <i>Interactive task of the function</i> - I need to move the points on which the function is built, directly on the screen, in the current screen coordinates of the scale, which are translated into real value; </li><li>  <i>linear / logarithmic scale</i> - since the values ‚Äã‚Äãare what I wrote, I had to lay the possibility of changing the scale.  And both one and both at once. </li></ol><br><br>  Here is the TK ... Well, nothing, I managed!  Let me help you too. <br><br>  Yes, until dived - thanks <a href="http://codecogs.izyba.com/latex/about.php">to CodeCogs Equation Editor</a> !  With their help, I famously built all the mathematical formulas without any Microsoft Equation Editor, which then still need to be exported to graphics with an insert here.  By the way, there is a <a href="http://codecogs.izyba.com/products/eqneditor/editor.php%3Flang%3Dru-ru">Russian editor</a> .  In general, I recommend! <br><br>  Well, if instead of formulas you see empty squares, this is also a ‚Äúthank you‚Äù Equation Editor ... <br><br><h4>  Attached Excel file </h4><br>  In the course of writing this article, I built all the calculations and checked it in the Excel spreadsheet with formulas.  It turned out very convenient.  And I decided to post it for public use.  There are listed at the bottom of the page sections.  On each page, the parameters that can be changed are marked as cells with a yellow background.  It is better not to touch the remaining cells.  However, all formulas can be easily viewed.  <a href="http://www.onlinedisk.ru/file/982155/">Download the file</a> and try on health!  If problems with the file - write, send. <br><br><h4>  Functional dependence </h4><br>  So, we have some dependency - we denote it as <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png" alt="image">  .  Here we have <img src="https://habrastorage.org/getpro/habr/post_images/aa2/902/59f/aa290259f2ca8aee797426f3507249d5.png" alt="image">  - horizontal axis of the graph, <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png" alt="image">  - vertical.  In my case <img src="https://habrastorage.org/getpro/habr/post_images/aa2/902/59f/aa290259f2ca8aee797426f3507249d5.png" alt="image">  was the value of resistance <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png" alt="image">  - temperature. <br><br>  Why not <img src="https://habrastorage.org/getpro/habr/post_images/3d7/5db/980/3d75db9800dd420da9df86ebaac7989d.png" alt="image">  ?  After all, it seems to be so?  That's the way it is, but <s>only at school</s> in the simplest case. <br><br><img src="https://habrastorage.org/storage2/2c0/1bc/088/2c01bc088bf2a0aa3cb4329fb406d3e8.jpg" align="left"><img src="https://habrastorage.org/getpro/habr/post_images/e61/c83/2dc/e61c832dcc91b3f91cc508551ea32107.png" alt="image">  - This is the coordinates of a point on the plane.  For simplicity, we define the use of the <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582">Cartesian coordinate system</a> : <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y" alt="image">  sets the vertical offset of the horizontal axis relative to zero, <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;x" alt="image">  sets the horizontal offset of the vertical axis relative to zero. <br><br><img src="https://habrastorage.org/storage2/fdb/212/932/fdb212932dc197c0ef10c7aaa2136b40.jpg" align="right">  Everything is good when we draw this very coordinate system on paper and put dots in it.  There really - they chose the center, put the ruler here, then there.  But when plotting a chart in some program, subtleties begin - what should be considered zero?  What is considered a "+", and what is a "-"?  I draw graphics for this article in CorelDRAW - there the center is considered from the bottom left (you can move it where necessary). <br><br><img src="https://habrastorage.org/storage2/612/062/f35/612062f35dc84f6ef4aba7befd9f75bc.jpg" align="left">  Yes, and in what units of the schedule?  In centimeters?  And why?  I will have the next stage of implementation in C ++ using Qt tools, so there I will make a QWidget window, which, by default, has a zero - is the top left;  units of measurement - screen pixels. <br><br>  Well, do not forget that all these beautiful arguments are valid for the linear scale so far, and here we have logarithmic looming over the horizon.  There the devil knows what will happen! <br><br>  But this is only a point.  And we will have some kind of line, more precisely - many lines.  What will be there for the transformation? <br><br>  That is precisely why we must, from the very beginning, clearly separate the <i>functional dependence</i> and <i>coordinate transformations</i> . <br><br>  So, let's agree on the following: <b>we have some abstract process, which is described by functional dependence</b> <b><img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png" alt="image"></b>  <b>.</b>  <b>When displayed on the screen is used to convert to coordinates</b> <b><img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;(t,f(t))\Rightarrow(X,Y)" alt="image"></b>  <b>where</b> <b><img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;X=X(t)" alt="image"></b>  <b>,</b> <b><img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;Y=Y(f(t))" alt="image"></b>  .  The next steps are to clarify these <img src="https://habrastorage.org/getpro/habr/post_images/e63/1e0/22a/e631e022a7dd29374736df0cf5c46997.png" alt="image">  and <img src="https://habrastorage.org/getpro/habr/post_images/442/ba1/a70/442ba1a70d0ad84ad38f0077c3fed8b1.png" alt="image">  . <br><br>  But let's put the coordinates aside for the time being - do we need to somehow define our function (remember the TK)?  And set in those very abstract coordinates <img src="https://habrastorage.org/getpro/habr/post_images/d89/1ec/389/d891ec3897af257a334e0ceef8b5ba35.png" alt="image">  .  And this will do. <br><br><h4>  Interpolation </h4><br>  In my case, a number of points were known. <img src="https://habrastorage.org/getpro/habr/post_images/d89/1ec/389/d891ec3897af257a334e0ceef8b5ba35.png" alt="image">  : <br><br><table><tbody><tr><th><img src="https://habrastorage.org/getpro/habr/post_images/aa2/902/59f/aa290259f2ca8aee797426f3507249d5.png" alt="image">  Œ© </th><th><img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png" alt="image">  Àö </th></tr><tr><td>  180 </td><td>  100 </td></tr><tr><td>  6,000 </td><td>  0 </td></tr><tr><td>  30,000 </td><td>  -thirty </td></tr></tbody></table><br><br>  Not so hot, and a large table, but there‚Äôs obviously a lot of empty places.  And what resistance corresponds to 60Àö, -40Àö, ...?  In general, you need to put the missing points.  And <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">interpolation</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BF%25D0%25BF%25D1%2580%25D0%25BE%25D0%25BA%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">approximation</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">extrapolation</a> will help us in this.  However, do not worry - one interpolation is enough for the eyes. <br><br> <a href="http://commons.wikimedia.org/w/index.php%3Ftitle%3DFile:Lagrange_polynomial.svg%26page%3D1%26uselang%3Dru"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/f84/8bc/3a8f848bc8626499cd2b224074b5b5e6.png" alt="image" align="left"></a>  There are many interpolation methods, I will not consider everything here.  Personally, I liked at the beginning <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE%25D1%2587%25D0%25BB%25D0%25B5%25D0%25BD_%25D0%259B%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B6%25D0%25B0">the Lagrange interpolation polynomial</a> .  It is very simple in the calculation and implementation, as well as in customization.  There it is assumed that a set of <img src="https://habrastorage.org/getpro/habr/post_images/3de/0fe/dd5/3de0fedd5b7a096d44423b4c69589ada.png" alt="image">  view points <img src="https://habrastorage.org/getpro/habr/post_images/980/ada/eea/980adaeea1e325dc19fe6b559fa8f4db.gif" alt="image">  (here we will for a while return to the assignment of points in the form <img src="https://habrastorage.org/getpro/habr/post_images/bea/0e6/b42/bea0e6b42e87d6a7ee84715f060b987b.png" alt="image">  - so it is accepted in mathematics). <br><br>  The polynomial is calculated as <img src="https://habrastorage.org/getpro/habr/post_images/368/822/8ac/3688228ac0d2cbc5c43b9f7975a52bce.gif" alt="image">  where <img src="https://habrastorage.org/getpro/habr/post_images/b1b/710/646/b1b710646c59d87b79333ddaea81757b.gif" alt="image">  . <br><br>  Math scared?  Hmm ... Ok, I'll write in C ++: <br><br><pre><code class="hljs matlab">typedef qreal Real; Real Lagranj (Real X) { static const int n = <span class="hljs-number"><span class="hljs-number">3</span></span>; static Real y[n] = {<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-30</span></span>}; static Real x[n] = {<span class="hljs-number"><span class="hljs-number">180</span></span>, <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-number"><span class="hljs-number">30000</span></span>}; Real L, l; int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>; L = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; n; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { l = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; n; ++<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> != <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) l *= (X - x[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) / (x[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] - x[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]); L += y[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] * l; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; } int main (int argc, char *argv[]) { Real y; y = Lagranj (<span class="hljs-number"><span class="hljs-number">180</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">500</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">1000</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">6000</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">10000</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">30000</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">0</span></span>); y = Lagranj (<span class="hljs-number"><span class="hljs-number">100000</span></span>); }</code> </pre> <br><br>  As you can see, everything is rather trivial (how trivial polynomials can be). <br><br>  Another big advantage of Lagrange polynomials is that they can be easily modeled in an Excel spreadsheet, which I did. <br><br>  Then, however, everything became a bit sad, since these polynomials, like any others, have vibrations on the graph.  That is, they can not give straight lines - constant values.  In my case, I could not set them up properly - they were bent into clearly unacceptable numbers.  So I had to give them up ... <br><br> <a href="http://commons.wikimedia.org/w/index.php%3Ftitle%3DFile:Bezier_curve.svg%26page%3D1%26uselang%3Dru"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Bezier_curve.svg/300px-Bezier_curve.svg.png" alt="image" align="right"></a>  Working in Corel, I was intimately familiar with <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D1%258B%25D0%25B5_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">Bezier curves</a> ‚Äî also a fairly convenient and simple representation of tabular data.  Very easy to implement in programming.  However, this is no longer an interpolation, but rather an approximation, since here one has to adjust the curve to the desired form. <br><br> <a href=""><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Lin_interp_w-legend.png/220px-Lin_interp_w-legend.png" alt="image" align="left"></a>  As a result, after carefully looking at my function, I realized that I would rather have a <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">piecewise linear interpolation</a> ‚Äî straight segments between the given lines.  Not that it‚Äôs really feng shui, but it‚Äôs easily realizable and conveniently customizable. <br><br>  In the language of mathematics, we are between the points <img src="http://1450827010362761852852" alt="image">  and <img src="http://1450827010362761852852+1" alt="image">  draw straight lines of sight <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;y=y_{i}+\frac{y_{i+1}-y_{i}}{x_{i+1}-x_{i}}(x-x_{i})=k_{i}*x+b_{i}" alt="image">  . <br><br>  Again, in C ++ it will look like this: <br><br><pre> <code class="hljs pgsql">typedef qreal <span class="hljs-type"><span class="hljs-type">Real</span></span>; <span class="hljs-type"><span class="hljs-type">Real</span></span> Linear (<span class="hljs-type"><span class="hljs-type">Real</span></span> X) { static const <span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">3</span></span>; static <span class="hljs-type"><span class="hljs-type">Real</span></span> y[n] = {<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-30</span></span>}; static <span class="hljs-type"><span class="hljs-type">Real</span></span> x[n] = {<span class="hljs-number"><span class="hljs-number">180</span></span>, <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-number"><span class="hljs-number">30000</span></span>}; static <span class="hljs-type"><span class="hljs-type">Real</span></span> k[n] = { (y[<span class="hljs-number"><span class="hljs-number">1</span></span>] - y[<span class="hljs-number"><span class="hljs-number">0</span></span>]) / (x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - x[<span class="hljs-number"><span class="hljs-number">0</span></span>]), (y[<span class="hljs-number"><span class="hljs-number">2</span></span>] - y[<span class="hljs-number"><span class="hljs-number">1</span></span>]) / (x[<span class="hljs-number"><span class="hljs-number">2</span></span>] - x[<span class="hljs-number"><span class="hljs-number">1</span></span>]), (y[<span class="hljs-number"><span class="hljs-number">3</span></span>] - y[<span class="hljs-number"><span class="hljs-number">2</span></span>]) / (x[<span class="hljs-number"><span class="hljs-number">3</span></span>] - x[<span class="hljs-number"><span class="hljs-number">2</span></span>])}; static <span class="hljs-type"><span class="hljs-type">Real</span></span> b[n] = { y[<span class="hljs-number"><span class="hljs-number">0</span></span>] - k[<span class="hljs-number"><span class="hljs-number">0</span></span>] * x[<span class="hljs-number"><span class="hljs-number">0</span></span>], y[<span class="hljs-number"><span class="hljs-number">1</span></span>] - k[<span class="hljs-number"><span class="hljs-number">1</span></span>] * x[<span class="hljs-number"><span class="hljs-number">1</span></span>], y[<span class="hljs-number"><span class="hljs-number">2</span></span>] - k[<span class="hljs-number"><span class="hljs-number">2</span></span>] * x[<span class="hljs-number"><span class="hljs-number">2</span></span>]}; <span class="hljs-type"><span class="hljs-type">int</span></span> i; // .   ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X &lt;= x[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X &gt;= x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[n<span class="hljs-number"><span class="hljs-number">-1</span></span>]; // .  ? <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n<span class="hljs-number"><span class="hljs-number">-1</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X == x[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[i]; // .  ? <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n<span class="hljs-number"><span class="hljs-number">-1</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X &gt;= x[i] &amp;&amp; X &lt;= x[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k[i] * X + b[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; //  -      !!! } <span class="hljs-type"><span class="hljs-type">int</span></span> main (<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> *argv[]) { <span class="hljs-type"><span class="hljs-type">Real</span></span> y; y = Linear (<span class="hljs-number"><span class="hljs-number">180</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">500</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">1000</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">6000</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">10000</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">30000</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">0</span></span>); y = Linear (<span class="hljs-number"><span class="hljs-number">100000</span></span>); }</code> </pre><br><br>  Also nothing revolutionary, is it? <br><br>  There is one significant difference between the Lagrange polynomial and linear interpolation: for the first one, you cannot explicitly specify values ‚Äã‚Äãoutside the points - they are calculated, for the second one you can control this matter.  That's why I ended up settling on the linear version.  Moreover, on the logarithmic scale I was aiming for, linear segments give me a more suitable option. <br><br>  However, we will not bother now on interpolation methods.  Let's better make a base class from which we will inherit implementations of various <s>$ # * @!</s>  polatsii. <br><br><h5>  Base class for setting / calculating a function </h5><br><br>  What should this class be able to do?  It seems to me that such a class should: <br><br><ul><li>  <i>give the value of the function depending on the argument</i> - in fact, for the sake of which we and his city; </li><li>  <i>react (move and recalculate) to change interpolation points</i> - the fact of pressing / releasing in a certain coordinate is input to the input, as a result of which parameters are recalculated; </li><li>  <i>to distinguish between single and double mouse clicks</i> - a single press, as for me, indicates the movement of a point;  double creates a new point; </li><li>  <i>to draw interpolation points both during their movement and without it, since</i> different interpolation methods will have different intuitive meaning of interpolation points, then the derived class should derive them (for example, in interpolation the point is part of the graph; in approximation, the point is not necessarily lies on the graph; in the Bezier curves, part of the points lies on the graph, some set the shape); </li><li>  <i>give the coordinates of the current moving point</i> - this is necessary to display the text coordinates of this point; </li><li>  <i>give service information</i> - for example, ‚Äúis a function defined?‚Äù, ‚Äúhow many points are used for interpolation?‚Äù, ‚Äúget coordinates of points‚Äù, etc. This data will allow you to save current settings; </li><li>  <i>to make settings</i> - ‚Äúdistribute so many points‚Äù, ‚Äúset coordinates of a point‚Äù - this will allow us to restore saved settings. </li></ul><br><br>  Any more thoughts?  If will be - write in comments, we will add! <br><br>  It turns out such a class: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FunctorBase { protected: virtual QPointF &amp;get_point (const <span class="hljs-type"><span class="hljs-type">int</span></span> Pos) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    virtual QPointF get_point (const <span class="hljs-type"><span class="hljs-type">int</span></span> Pos) const = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: // .  virtual <span class="hljs-type"><span class="hljs-type">void</span></span> MouseClicked (const QPointF &amp;Pt) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //       Pt virtual <span class="hljs-type"><span class="hljs-type">void</span></span> MouseDblClicked (const QPointF &amp;Pt) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //        Pt virtual <span class="hljs-type"><span class="hljs-type">void</span></span> MouseReleased (<span class="hljs-type"><span class="hljs-type">void</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    virtual <span class="hljs-type"><span class="hljs-type">void</span></span> MouseMove (const QPointF &amp;Pt) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //   (   ),   Pt virtual <span class="hljs-type"><span class="hljs-type">void</span></span> DrawPoints (QPainter &amp;p, const ScaleBase &amp;X, const ScaleBase &amp;Y, const <span class="hljs-type"><span class="hljs-type">int</span></span> ptRadius, QPen &amp;pnCircle, QBrush &amp;brCircle) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    ,   virtual <span class="hljs-type"><span class="hljs-type">void</span></span> DrawCurPoint (QPainter &amp;p, const ScaleBase &amp;X, const ScaleBase &amp;Y, const <span class="hljs-type"><span class="hljs-type">int</span></span> ptRadius, QPen &amp;pnCircle, QBrush &amp;brCircle) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     (   ,  ) // .  virtual qreal f (const qreal t) const = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     virtual QPointF *<span class="hljs-type"><span class="hljs-type">point</span></span> (<span class="hljs-type"><span class="hljs-type">void</span></span>) const = <span class="hljs-number"><span class="hljs-number">0</span></span>; //   ;    -  <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> is_specified (<span class="hljs-type"><span class="hljs-type">void</span></span>) const = <span class="hljs-number"><span class="hljs-number">0</span></span>; //   virtual <span class="hljs-type"><span class="hljs-type">int</span></span> num_points (<span class="hljs-type"><span class="hljs-type">void</span></span>) const = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     QPointF <span class="hljs-type"><span class="hljs-type">point</span></span> (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) const; //      // .  virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> set_points (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) = <span class="hljs-number"><span class="hljs-number">0</span></span>; //   ;    QPointF &amp;<span class="hljs-type"><span class="hljs-type">point</span></span> (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num); //      <span class="hljs-type"><span class="hljs-type">void</span></span> set_point (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num, const QPointF &amp;Pt); //       // .   qreal <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>() (const qreal t) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(t); } //     <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> (<span class="hljs-type"><span class="hljs-type">void</span></span>) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_specified (); } //   QPointF &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> (Num); } //      QPointF <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> (Num); } //      }; // <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FunctorBase <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> QPointF &amp;FunctorBase::<span class="hljs-type"><span class="hljs-type">point</span></span> (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) { Q_ASSERT_X (Num &lt; num_points (), "receiving points", (QString ("incorrect point index %1 for array size %2 is used"). arg (Num). arg (num_points())).toAscii().constData()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_point (Num); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> QPointF FunctorBase::<span class="hljs-type"><span class="hljs-type">point</span></span> (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num) const { Q_ASSERT_X (Num &lt; num_points (), "receiving points", (QString ("incorrect point index %1 for array size %2 is used"). arg (Num). arg (num_points())).toAscii().constData()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_point (Num); } <span class="hljs-type"><span class="hljs-type">void</span></span> FunctorBase::set_point (const <span class="hljs-type"><span class="hljs-type">int</span></span> Num, const QPointF &amp;Pt) { <span class="hljs-type"><span class="hljs-type">point</span></span> (Num) = Pt; }</code> </pre><br><br>  <i>(Those who are dissatisfied with my style and structure - offer objectively better!)</i> <br>  <i>(For those who find errors in the code - thanks!)</i> <br><br>  I think everything is obvious here. <br><br>  For coordinates, the point representation in the form of <a href="http://qt-project.org/doc/qt-4.8/qpointf.html">QPointF is used</a> (a pair of numbers in the form of qreal, qreal. "On all platforms except ARM, a double is used" - this <a href="http://qt-project.org/doc/qt-4.8/qtglobal.html">is written for Qt 4.8</a> ). <br><br>  Mouse button presses are implemented by the <code>MouseClicked</code> , <code>MouseDblClicked</code> , <code>MouseReleased</code> and <code>MouseMove</code> functions.  It is assumed that in specific implementations will be the appropriate reactions. <br><br>  Draw points by using <code>DrawPoints</code> and <code>DrawCurPoint</code> .  If the coordinates are used for all methods except these, the abstract ones are used, then we need the most screen ones.  Therefore, two <code>ScaleBase</code> for transformation are passed here.  This class is also virtual.  His ancestors implement the transformation from abstract coordinates to the current screen.  This class itself will be described below. <br><br>  The current value of the function is returned by the <code>f (const qreal)</code> method and the overloaded operator function <code>operator() (const qreal)</code> . <br><br>  To set the structure, the <code>set_points (Num)</code> functions are used - setting the number of points, <code>point (Num)</code> , <code>set_point (Num)</code> , <code>get_point (Num)</code> - setting the coordinates of a specific point.  <code>num_points () const</code> - returns the number of points, <code>point (Num) const</code> , <code>get_point (Num) const</code> returns the coordinates of the point.  <code>is_specified () const</code> returns <code>true</code> if the structure of the function is specified. <br><br>  In the next article we will write a couple of options for implementing this class. <br><br><h4>  Transform function for vertical / horizontal scale </h4><br><br>  There are linear and logarithmic scales.  Given that the vertical scale can be made in one format, and the horizontal scale in another, we get four options for the graph: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/8ec/77b/34a/8ec77b34a1ac800ef22f8edcc83e775d.jpg"></div><br><br>  Option one - both scales are linear.  Option two - both logarithmic.  Options for the third and fourth - mixed graphics.  By the way, in my case, it was a mixed case that eventually came up, since horizontally I needed a logarithmic scale, vertically - linear. <br><br>  Consequently, the mapping problem must be solved separately for both axes. <br><br>  Recall that when displaying on the screen is used to convert to coordinates <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;(t,f(t))\Rightarrow(X,Y)" alt="image">  where <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;X=X(t)" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;Y=Y(f(t))" alt="image">  .  Our further task is to construct these functions for the linear and logarithmic cases. <br><br>  What are these features?  At the entrance they get the coordinate in abstract (for the computer subroutine mapping on the screen) coordinates, the output is given in the screen (the "screen" coordinates will be different for different operating systems "). To calculate, they need to know the following: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/d70/949/9f5/d709499f59b63a6f15474916f87ba410.jpg"></div><br><br><ul><li>  <i>the limits of abstract coordinates</i> are the limiting values ‚Äã‚Äãof the argument and function that we are interested in.  It will be <img src="https://habrastorage.org/getpro/habr/post_images/aa2/902/59f/aa290259f2ca8aee797426f3507249d5.png_{min}" alt="image">  , <img src="https://habrastorage.org/getpro/habr/post_images/aa2/902/59f/aa290259f2ca8aee797426f3507249d5.png_{max}" alt="image">  for the horizontal axis and <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png_{min}" alt="image">  , <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png_{max}" alt="image">  for vertical.  No need to make a classic mistake: <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png_{min}=t_{min}" alt="image">  , <img src="https://habrastorage.org/getpro/habr/post_images/25b/37f/dd7/25b37fdd771aaebd2eb33ed6ac432aaa.png_{max}=t_{max}" alt="image">  !  In the example above, this is illustrated; </li><li>  <i>The screen coordinates</i> are the borders of the picture in which the graph is drawn.  Naturally, in the current screen coordinates.  On the chart this <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;x_{min}" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;x_{max}" alt="image">  for the horizontal axis and <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y_{min}" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y_{max}" alt="image">  for vertical; </li><li>  <i>screen coordinate pitch</i> - current pixel pitch <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;x_{step}" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y_{step}" alt="image">  .  In the simplest case, it will be one.  But in Qt, vertical zero is the top of the window.  Consequently, <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y_{step}=-1" alt="image">  .  And any other transformations can be applied, and the step will be far from single. </li></ul><br><br>  Please note - for the conversion task it does not matter whether the axis is vertical or not!  It (the task) operates on the boundary values ‚Äã‚Äãof the input, output, and output parameter steps.  Therefore, the task can be generalized: <b>it is necessary to convert the parameter</b> <b><img src="http://1450827010308583637374" alt="image"></b>  <b>based on its limits</b> <b><img src="http://1450827010308583637374_{min}" alt="image"></b>  <b>,</b> <b><img src="http://1450827010308583637374_{max}" alt="image"></b>  <b>output value</b> <b><img src="http://1450827010805670627696" alt="image"></b>  <b>given its limits</b> <b><img src="http://1450827010805670627696_{min}" alt="image"></b>  <b>,</b> <b><img src="http://1450827010805670627696_{max}" alt="image"></b>  <b>and step</b> <b><img src="http://1450827010805670627696_{step}" alt="image"></b>  .  There are intentionally introduced notation. <img src="http://1450827010308583637374" alt="image">  , <img src="http://1450827010805670627696" alt="image">  instead of the usual <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;x" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y" alt="image">  , because otherwise there will be confusion.  One significant addition: <img src="http://1450827010308583637374_{max}&gt;val_{min}" alt="image">  . <br><br><h5>  Base class for scale conversions </h5><br><br>  Let's formulate the desired functionality of the virtual class of transformations for the scale, from which the implementation of the scales will be inherited: <br><br><ul><li>  <i>transformations from screen coordinates to abstract and vice versa</i> - it is logical, for the sake of it we do it; </li><li>  <i>conversion setting</i> is also logical; </li><li>  <i>properties</i> - current properties of the transformation (minimum / maximum values, step for different values); </li><li>  <i>information on the grid</i> - positions for large and small grid, the caption under the scale. </li></ul><br><br>  The implementation might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScaleBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// .  virtual qreal scr (const qreal Val) const = 0; //       virtual qreal val (const qreal Scr) const = 0; //       // .  virtual const QVector&lt;qreal&gt; &amp;scr_values (void) const = 0; //   ,  [  (    )] int num_scr_values (void) const; virtual const QVector&lt;int&gt; &amp;scr_min_grid (void) const = 0; //      int num_scr_min_grid (void) const; virtual const QVector&lt;int&gt; &amp;scr_maj_grid (void) const = 0; //      int num_scr_maj_grid (void) const; virtual const QVector&lt;int&gt; &amp;scr_text_pos (void) const = 0; //       int num_scr_text_pos (void) const; virtual const QVector&lt;QString&gt; &amp;scr_text_str (void) const = 0; //       int num_scr_text_str (void) const; // .  virtual qreal val_min (void) const = 0; //     ,    virtual qreal val_max (void) const = 0; //     ,    virtual qreal scr_min (void) const = 0; //      virtual qreal scr_max (void) const = 0; //      virtual bool is_specified (void) const = 0; //   // .  virtual void set_val_min (const qreal Val) = 0; //     ,    virtual void set_val_max (const qreal Val) = 0; //     ,    virtual void set_scr_min (const qreal Src) = 0; //      virtual void set_scr_max (const qreal Src) = 0; //      virtual void set_scr_point (const qreal Src) = 0; //     () // .  void Resized (const qreal Size) = 0; //    // .   operator bool (void) const { return is_specified (); } //   }; // class ScaleBase int ScaleBase::num_scr_values (void) const { return scr_values().size(); } int ScaleBase::num_scr_min_grid (void) const { return scr_min_grid().size(); } int ScaleBase::num_scr_max_grid (void) const { return scr_max_grid().size(); } int ScaleBase::num_scr_text_str (void) const { return scr_text_str().size(); } int ScaleBase::num_scr_text_pos (void) const { return scr_text_pos().size(); } virtual qreal ScaleBase::scr_step (const int Num) const { Q_ASSERT_X (Num &lt; num_scr_values (), "receiving step", (QString ("incorrect step index %1 for array size %2 is used"). arg (Num). arg (num_scr_values())).toAscii().constData()); return scr_values()[Num + 1] - scr_values()[Num]; }</span></span></code> </pre><br><br>  Scale adjustment is performed with the <code>set_... (Val)</code> functions.  Recalculation of the necessary values ‚Äã‚Äãshould be made in the same functions.  When the window is <code>Resized (Size)</code> method is <code>Resized (Size)</code> . <br><br>  To improve performance, you can once calculate the compliance point on the screen and its value in the original, abstract coordinates.  This array is returned by the <code>scr_values () const</code> method.  Further, to build a large and small grid, arrays are calculated (return them, respectively, to the functions <code>scr_maj_grid ()</code> and <code>scr_min_grid ()</code> ).  The length of the array corresponds to the number of these lines, the value - the offset relative to the beginning of the scale on the screen (i.e. the index of the first array).  Also, two arrays are pre-calculated - the text of the caption to the scale (the <code>scr_text_str ()</code> function) and the offset of these signatures relative to the beginning (the <code>scr_text_pos ()</code> function). <br><br>  Finally, the direct conversion ‚Äî from abstract to screen coordinates ‚Äî is performed by the <code>scr (Val)</code> function, and the reverse, by the val function <code>(Scr)</code> . <br><br><h4>  Linear transform </h4><br><br>  Let us consider separately the linear transformation for the horizontal and vertical axis. <br><br><img src="http://habrastorage.org/storage2/262/b1c/416/262b1c4166abf24c1ce56bcde13ca656.jpg" align="left"><img src="http://habrastorage.org/storage2/9b8/a27/d73/9b8a27d738232a5a83ca97ea6d31dd69.jpg" align="right"><br><br>  We have a certain function - a curve in one representation.  For another, we had to narrow it down and shift it to the right (the window on the screen was reduced and shifted to the right).  For another view, we had to shift it to the left (the window was shifted to the left).  How is it described mathematically?  Simple enough: <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y=f(k*t+b)" alt="image">  .  In the first case, it seems <img src="http://1450827010635793744853" alt="image">  in the second <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;b&lt;0" alt="image">  . <br><br>  In another case, we had to narrow the vertical representation of the curve and move it upwards.  And then in general - to turn.  Both of these transformations are described as <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;y=k*f(t)+b" alt="image">  .  In the first case <img src="http://1450827010635793744853" alt="image">  , <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;b&gt;0" alt="image">  .  In the second case <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;k=-1" alt="image">  . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/03f/9e2/986/03f9e29861d2992bdaa26f08cfaed44d.jpg"></div><br><br>  Both transformations have the same mathematical description: <img src="http://1450827010805670627696=k*val+b" alt="image">  .  In this description there are two constants that define the transformation - <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;k" alt="image">  and <img src="http://latex.codecogs.com/png.download?\dpi{120}&amp;space;b" alt="image">  .  The first determines the angle of inclination, the second - the offset relative to zero. <br><br>  The calculation of these constants is quite simple - this is a solution to a system of two equations: <br><br><div style="text-align:center;"><img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;\left\{\begin{matrix}scr_{min}=k*val_{min}+b;&amp;space;\\scr_{max}=k*val_{max}+b;&amp;space;\end{matrix}\right.&amp;space;\Rightarrow&amp;space;\left\{\begin{matrix}k=\frac{scr_{min}-scr_{max}}{val_{min}-val_{max}};&amp;space;\\b=scr_{max}-k*val_{max};&amp;space;\end{matrix}\right." alt="image"></div>  . <br><br>  It is also important to be able to do the inverse transformation ‚Äî for example, translate the coordinates of the mouse pointer into abstract coordinates.  Also, nothing complicated: <br><br><div style="text-align:center;"><img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;val=\frac{scr-b}{k}" alt="image"></div>  . <br><br>  Step <img src="http://1450827010725075443228" alt="image">  in this case it is not used for the calculation, but then it will be useful to us in the implementation in C ++ for the calculation of the displacement. <br><br>  How will this be used in practice?  Yes, everything is simple!  Horizontal transformation: <img src="http://1450827010843275596910" alt="image">  - border image graphics corresponding <img src="http://1450827010593268871578" alt="image">  (usually left) <img src="http://1450827010868326146897" alt="image">  - <img src="http://1450827010593268871578" alt="image">  (usually to the right) <img src="http://1450827010725075443228" alt="image">  - horizontal image output step.  Vertical transformation is the same, but vertically (in Qt <img src="http://1450827010843275596910" alt="image">  will be the lower border of the picture <img src="http://1450827010868326146897" alt="image">  - top, and <img src="http://1450827010843275596910&gt;scr_{max}" alt="image">  ). <br><br><h4>  Logarithmic transformation </h4><br>  And now we will plunge there for the sake of what all this has started to turn: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/4d2/c79/7ea/4d2c797ea670f3dbc2349dd9cd56cc46.jpg"></div><br>  <i>(the graph does not draw a logarithm, but something similar to it. It was done on purpose, since the logarithm will not be very obvious here)</i> <br><br>  If a <img src="http://1450827010725075443228" alt="image">  same on the whole scale then <img src="http://1450827010792653104291" alt="image">  will be different everywhere!  What law does it change?  That's right - logarithmic!  Let's first learn to identify this very <img src="http://1450827010792653104291" alt="image">  . <br><br>  Total points we will have <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;num=\left | \frac{scr_{max}-scr_{min}}{scr_{step}} \right |+1" alt="image">  (eg, <img src="http://1450827010843275596910=-1" alt="image">  , <img src="http://1450827010868326146897=1" alt="image">  , <img src="http://1450827010725075443228=1" alt="image">  ;  then we will have 3 points).  This corresponds to the input range. <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;diap_{val}=val_{max}-val_{min}" alt="image">  .  Value <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_{0}=scr_{min}" alt="image">  corresponds to <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;val_{0}=val_{min}" alt="image">  , <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_{n}=scr_{max}" alt="image">  corresponds to <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;val_{n}=val_{max}" alt="image">  .  The last point has an index <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;n=num-1" alt="image">  .  What corresponds to <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_{i}" alt="image">  ? <br><br>  For linear scale <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_{i}\equiv val_{min}+base*i" alt="image">  where <img src="http://1450827010644099438049" alt="image">  determined by the range of input values.  Here you can do the same, but instead of multiplication there will be a raising to a power: <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_i\equiv val_{min}+base^i" alt="image">  (remember that <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;0\leqslant i\leqslant n" alt="image">  ).  There is one, however, nuance: <img src="http://1450827010362761852852=0" alt="image">  we have <img src="http://1450827010644099438049^i\neq 0" alt="image">  , and should.  This is solved simply - subtract one: <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_i\equiv val_{min}+base^i-1" alt="image">  .  And then for the zero case, everything converges.  How to calculate <img src="http://1450827010644099438049" alt="image">  in this case?  There are different options.  I prefer to do this as follows. <br><br>  We know that <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_n\equiv val_{max}" alt="image">  .  At the same time, we now know that <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_n\equiv val_{min}+base^n-1" alt="image">  .  It turns out the equation: <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;val_{max}=val_{min}+base^n-1" alt="image">  .  Solve it for <img src="http://1450827010644099438049" alt="image">  : <img src="http://1450827010644099438049^n=val_{max}-val_{min}+1;base=\sqrt[n]{val_{max}-val_{min}+1}" alt="image">  .  Remembering what is <img src="http://1450827010821243338902" alt="image">  and replacing the root with exponentiation, we obtain an acceptable form for a computer: <img src="http://1450827010644099438049=(val_{max}-val_{min}+1)^{\tfrac{1}{num-1}}" alt="image">  (recall that <img src="http://1450827010308583637374_{max}&gt;val_{min}" alt="image">  ).  Fine, the base value is received! <br><br>  In fact, we obtained an algorithm for converting from screen to abstract coordinates ‚Äî the inverse problem.  Now the mode of the direct task is the transformation from an abstract coordinate to a screen one.  The problem is solved easily.  In fact, you need to find <img src="http://1450827010362761852852" alt="image">  and it's easy for him <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_i" alt="image">  . <br><br>  To find <img src="http://1450827010362761852852" alt="image">  need to solve the equation <img src="http://1450827010593268871578+base^i-1=val_i" alt="image">  regarding <img src="http://1450827010644099438049^i" alt="image">  : <img src="http://1450827010644099438049^i=val_i-val_{min}+1" alt="image">  .  Well, then from the properties of the logarithm we get that <img src="http://1450827010362761852852=\frac{\log (val_i-val_{min}+1)}{\log base}" alt="image">  .  Well and further, considering the screen coordinates as a line with a slope, we get that <img src="http://latex.codecogs.com/gif.download?\dpi{120}&amp;space;scr_i=\frac{scr_{max}-scr_{min}}{n}*i+scr_{min}" alt="image">  (for more beauty you need more <img src="http://1450827010821243338902" alt="image">  replaced by <img src="http://1450827010821243338902um-1" alt="image">  ). <br><br>  It seems to be considered basic math.  Found errors or inaccuracies - write in the comments, I will be grateful! <br><br>  Over time, I will write the following article - the implementation of this mathematics using Qt in C ++. </div><p>Source: <a href="https://habr.com/ru/post/157407/">https://habr.com/ru/post/157407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157393/index.html">Custom Themes for Custom Widgets</a></li>
<li><a href="../157395/index.html">RIM's PlayBook 3G Now Available</a></li>
<li><a href="../157397/index.html">[LAVKA] Love shop at the Ostankino television tower</a></li>
<li><a href="../157401/index.html">Combined load balancing online channels</a></li>
<li><a href="../157405/index.html">Mysterious textures in the Takla Makan desert on Google Earth got an explanation</a></li>
<li><a href="../157409/index.html">Productive use of PHPStorm</a></li>
<li><a href="../157411/index.html">Amazon and Google are undermining the prices of mobile devices and it can hit all</a></li>
<li><a href="../157413/index.html">NASA has announced a service to help monitor the position of the ISS</a></li>
<li><a href="../157415/index.html">Panoramic video from the cab of a Formula 1 car</a></li>
<li><a href="../157419/index.html">AWS: New SDK for PHP 2.0.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>