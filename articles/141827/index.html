<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The simplest compression algorithms: RLE and LZ77</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A long time ago, when I was still a naive schoolboy, I suddenly became terribly curious: how magically do the data in the archives take up less space?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The simplest compression algorithms: RLE and LZ77</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/628/443/5eb628443e59b147c4a63802e5fcd523.png" align="left">  A long time ago, when I was still a naive schoolboy, I suddenly became terribly curious: how magically do the data in the archives take up less space?  Riding my loyal dialup, I began to surf the Internet in search of an answer, and found many articles with a rather detailed description of the information I was interested in.  But none of them then seemed easy to understand - the code listings seemed like a Chinese script, and attempts to understand unusual terminology and various formulas were not crowned with success. <br><br>  Therefore, the purpose of this article is to give an idea of ‚Äã‚Äãthe simplest compression algorithms for those who do not yet have the knowledge and experience to understand more professional literature, or whose profile is far from similar subjects.  Those.  I will tell you ‚Äúon the fingers‚Äù about one of the simplest algorithms and give examples of their implementation without kilometer code listings. <br><a name="habracut"></a><br>  Immediately I warn you that I will not consider the details of the implementation of the coding process and such nuances as an effective search for line entries.  The article will concern only the algorithms themselves and the ways of presenting the result of their work. <br><br><a name="RLE"></a><h1>  RLE - compactness of uniformity </h1><br>  The <abbr title="Run-Length Encoding">RLE</abbr> algorithm is probably the simplest of all: its essence lies in coding repeats.  In other words, we take sequences of identical elements, and ‚Äúcollapse‚Äù them into ‚Äúquantity / value‚Äù pairs.  For example, a string like ‚ÄúAAAAAAAABCCCC‚Äù can be converted to an entry like ‚Äú8 √ó A, B, 4 √ó C‚Äù.  That, in general, is all you need to know about the algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Implementation example </h4><br>  Suppose we have a set of certain integer coefficients, which can take values ‚Äã‚Äãfrom 0 to 255. In a logical way, we came to the conclusion that it is reasonable to store this set as an array of bytes: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br><br>  For many, it will be much more common to see this data as a hex dump: <br> <code>0000: 00 00 00 00 00 00 04 02 00 04 04 04 04 04 04 04</code> <br> <code>0010: 50 50 50 50 00 02 02 02 02 FF FF FF FF FF 00 00</code> <br> <br>  Thinking, we decided that it would be good to save space somehow compress such sets.  To do this, we analyzed them and revealed a pattern: very often come across subsequences consisting of identical elements.  Of course, RLE is the perfect fit for this! <br><br>  We will encode our data using the newly acquired knowledge: 6 √ó 0, 4, 2, 0, 7 √ó 4, 4 √ó 80, 0, 4 √ó 2, 5 √ó 255, 2 √ó 0. <br><br>  It's time to somehow present our result in a form understandable to a computer.  For this, in the data stream, we must somehow separate the single bytes from the encoded chains.  Since the entire range of byte values ‚Äã‚Äãis used by our data, then it will not be possible to simply select any ranges of values ‚Äã‚Äãfor our goals. <br><br>  There are at least two ways out of this situation: <br><ol><li>  As an indicator of a compressed chain, select one value of a byte, and in case of a collision with real data, shield them.  For example, if we use the value 255 for ‚Äúofficial‚Äù purposes, then when meeting this value in the input data we will have to write ‚Äú255, 255‚Äù and after the indicator use a maximum of 254. <br></li><li>  To structure the coded data, indicating the number of not only repeated, but subsequent subsequent single elements.  Then we will know in advance where the data is. <br></li></ol><br>  The first method in our case does not seem effective, therefore, perhaps, we will resort to the second. <br><br>  So, now we have two types of sequences: chains of single elements (like "4, 2, 0") and chains of identical elements (like "0, 0, 0, 0, 0, 0").  Let us single out one bit in the "service" bytes for the sequence type: 0 - single elements, 1 - the same.  Take for this, say, the high bit of a byte. <br><br>  In the remaining 7 bits, we will store the lengths of the sequences, i.e.  The maximum length of the encoded sequence is 127 bytes.  We could allocate for service needs, say, two bytes, but in our case such long sequences are extremely rare, so it‚Äôs easier and more economical to just break them up into shorter ones. <br><br>  It turns out that we will write to the output stream first the length of the sequence, and then either one repeated value or a chain of non-repeatable elements of the specified length. <br><br>  The first thing that should be evident - in this situation, we have a couple of unused values.  There can be no sequences with zero length, so we can increase the maximum length to 128 bytes, subtracting one from the length when encoding and adding to decoding.  Thus, we can encode lengths from 1 to 128 instead of lengths from 0 to 127. <br><br>  The second thing to notice is that there are no sequences of identical elements of unit length.  Therefore, we will subtract one more from the value of the length of such sequences, thereby increasing their maximum length to 129 (the maximum length of the chain of single elements is still equal to 128).  Those.  chains of identical elements can have length from 2 to 129. <br><br>  We will encode our data again, but now in a form understandable for a computer.  We will write service bytes as [T | L], where T is the type of the sequence, and L is the length.  We will immediately take into account that we write the lengths in a modified form: at T = 0 we subtract one from L, at T = 1 - two. <br><br>  <font color="blue">[1 | 4]</font> , 0, <font color="blue">[0 | 2]</font> , 4, 2, 0, <font color="blue">[1 | 5]</font> , 4, <font color="blue">[1 | 2]</font> , 80, <font color="blue">[0 | 0]</font> , 0, <font color="blue">[1 | 2]</font> , 2, <font color="blue">[1 | 3]</font> , 255, <font color="blue">[1 | 0]</font> , 0 <br><br>  Let's try to decode our result: <br><ul><li>  <font color="blue">[1 | 4]</font> .  T = 1, then the next byte will be repeated L + 2 (4 + 2) times: 0, 0, 0, 0, 0, 0. </li><li>  <font color="blue">[0 | 2]</font> .  T = 0, then just read L + 1 (2 + 1) bytes: 4, 2, 0. </li><li>  <font color="blue">[1 | 5]</font> .  T = 1, repeat the next byte 5 + 2 times: 4, 4, 4, 4, 4, 4, 4. </li><li>  <font color="blue">[1 | 2]</font> .  T = 1, repeat the next byte 2 + 2 times: 80, 80, 80, 80. </li><li>  <font color="blue">[0 | 0]</font> .  T = 0, read 0 + 1 byte: 0. </li><li>  <font color="blue">[1 | 2]</font> .  T = 1, we repeat byte 2 + 2 times: 2, 2, 2, 2. </li><li>  <font color="blue">[1 | 3]</font> .  T = 1, we repeat byte 3 + 2 times: 255, 255, 255, 255, 255. </li><li>  <font color="blue">[1 | 0]</font> .  T = 1, repeat byte 0 + 2 times: 0, 0. </li></ul><br><br>  And now the last step: save the result as an array of bytes.  For example, a pair <font color="blue">[1 | 4]</font> packed in byte will look like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/db1/41d/d1a/db141dd1a3b6e4c232229f17e0559b6a.png"><br><br>  As a result, we obtain the following: <br>  0000: <font color="blue">84</font> 00 <font color="blue">02</font> 04 02 00 <font color="blue">85</font> 04 <font color="blue">82</font> 80 <font color="blue">00</font> 00 <font color="blue">82</font> 02 <font color="blue">83</font> FF <br>  0010: <font color="blue">80</font> 00 <br><br>  So in this simple example of input data, we received from 32 bytes 18. Not a bad result, especially considering that it can be much better on longer chains. <br><br><h4>  Possible improvements </h4><br>  The efficiency of the algorithm depends not only on the algorithm itself, but also on the method of its implementation.  Therefore, for different data it is possible to develop different variations of the coding and presentation of the encoded data.  For example, when encoding images, you can make chains of variable length: select one bit for the indication of a long chain, and if it is set to one, then store the length in the next byte too.  So we sacrifice the length of short chains (65 elements instead of 129), but we give the possibility to encode chains up to 16385 elements (2 <sup>14</sup> + 2) in just three bytes! <br><br>  Additional efficiency can be achieved by using heuristic coding methods.  For example, we encode the following chain in our way: ‚ÄúABBA‚Äù.  We get ‚Äú <font color="blue">[0 | 0]</font> , A, <font color="blue">[1 | 0]</font> , B, <font color="blue">[0 | 0]</font> , A‚Äù - i.e.  4 bytes we turned into 6, inflated the original data as much as half as much!  And the more such short alternating heterogeneous sequences, the more redundant data.  If we take this into account, we could encode the result as ‚Äú <font color="blue">[0 | 3]</font> , A, B, B, A‚Äù - we would spend only one extra byte. <br><br><a name="LZ77"></a><h1>  LZ77 - short in repetition </h1><br>  LZ77 is one of the most simple and well-known algorithms in the LZ family.  Named in honor of its creators: Abraham Lempel (Abraham <b>L</b> empel) and Jacob Ziv (Jacob <b>Z</b> iv).  Figures 77 in the title indicate the year 1977, in which an article was published describing this algorithm. <br><br>  The basic idea is to encode the same sequence of elements.  That is, if in the input data some chain of elements occurs more than once, then all its subsequent entries can be replaced by ‚Äúlinks‚Äù to its first instance. <br><br>  Like the rest of the algorithms of this family of families, LZ77 uses a dictionary in which sequences previously encountered are stored.  For this, he applies the principle of so-called.  ‚ÄúSliding window‚Äù: an area always in front of the current coding position within which we can address links.  This window is a dynamic dictionary for this algorithm - each element in it corresponds to two attributes: position in the window and length.  Although in the physical sense, this is just a section of memory that we have already encoded. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/375/afa/03d/375afa03d6220ad958755931071b86b2.png"><br><br><h4>  Implementation example </h4><br>  Now let's try to code something.  Let's generate for this some suitable line (I apologize in advance for its absurdity): <br><br>  ‚ÄúThe compression and the decompression leave an impression.  Hahahahaha! ‚Äù <br><br>  Here is what it will look like in memory (ANSI encoding): <br> <code>0000: 54 68 65 20 63 6F 6D 70 72 65 73 73 69 6F 6E 20   The compression</code> <br> <code>0010: 61 6E 64 20 74 68 65 20 64 65 63 6F 6D 70 72 65   and the decompre</code> <br> <code>0020: 73 73 69 6F 6E 20 6C 65 61 76 65 20 61 6E 20 69   ssion leave an i</code> <br> <code>0030: 6D 70 72 65 73 73 69 6F 6E 2E 20 48 61 68 61 68   mpression. Hahah</code> <br> <code>0040: 61 68 61 68 61 21                                 ahaha!</code> <br> <br>  We have not yet decided on the size of the window, but we agree that it is larger than the size of the encoded string.  Let's try to find all duplicate chains of characters.  Chain will be considered a sequence of characters longer than one.  If the chain is part of a longer repeating chain, we will ignore it. <br><br>  ‚ÄúThe compression and t <font color="blue">[he]</font> de <font color="blue">[compression]</font> leave <font color="blue">[an]</font> i <font color="blue">[mpression]</font> .  Hah <font color="blue">[ahahaha]</font> ! ‚Äù <br><br>  For the sake of clarity, let‚Äôs look at the scheme where the correspondences of the repeated sequences and their first occurrences are visible: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/de1/201/e01de1201b3150bf6153d230ec46ec47.png"><br><br>  Perhaps the only obscure point here is the sequence ‚ÄúHahahahaha!‚Äù, Because the short string ‚Äúah‚Äù corresponds to the string of characters ‚Äúahahaha‚Äù.  But there is nothing unusual here, we used some technique that allows the algorithm to sometimes work like the RLE described earlier. <br><br>  The fact is that when unpacking, we will read the specified number of characters from the dictionary.  And since the entire sequence is periodic, i.e.  the data in it is repeated with a certain period, and the characters of the first period will be directly in front of the unpacking position, then we can recreate the entire chain by simply copying the characters of the previous period into the next one. <br><img src="https://habrastorage.org/getpro/habr/post_images/560/1c1/32d/5601c132dac0d3c8d76381453df79494.png"><br><br>  With this sorted out.  Now let's replace the found repetitions with links in the dictionary.  We will write the link in the format [P | L], where P is the position of the first occurrence of the string in the string, L is its length. <br><br>  ‚ÄúThe compression and t <font color="blue">[22 | 3]</font> de <font color="blue">[5 | 12]</font> leave <font color="blue">[16 | 3]</font> i <font color="blue">[8 | 7]</font> .  Hah <font color="blue">[61 | 7]</font> ! ‚Äù <br><br>  But do not forget that we are dealing with a sliding window.  For a greater understanding that the links do not depend on the window size, let's replace the absolute positions by the difference between them and the current coding position. <br><br>  ‚ÄúThe compression and t <font color="blue">[20 | 3]</font> de <font color="blue">[22 | 12]</font> leave <font color="blue">[28 | 3]</font> i <font color="blue">[42 | 7]</font> .  Hah <font color="blue">[2 | 7]</font> ! ‚Äù <br><br>  Now we just need to take away P from the current coding position to get the absolute position in the string. <br><br>  It's time to determine the size of the window and the maximum length of the coded phrase.  Since we are dealing with text, it is rare when it will contain particularly long repeating sequences.  So we will single out under their length, say, 4 bits - the limit of 15 characters at a time is enough for us. <br><br>  But on the size of the window it already depends how deeply we will look for identical chains.  Since we are dealing with small texts, it will be just right to supplement the number of bits we use to two bytes: we will address links in the range of 4096 bytes using 12 bits for this. <br><br>  We know from experience with RLE that not all values ‚Äã‚Äãcan be used.  Obviously, a link can have a minimum value of 1, therefore, in order to address back in the range of 1..4096, we have to take one from the link when encoding, and add it back when decoding.  The same with the lengths of the sequences: instead of 0..15 we will use the range of 2..17, since we do not work with zero lengths, and individual characters are not sequences. <br><br>  So, we will present our coded text taking into account these amendments: <br><br>  ‚ÄúThe compression and t <font color="blue">[19 | 1]</font> de <font color="blue">[21 | 10]</font> leave <font color="blue">[27 | 1]</font> i <font color="blue">[41 | 5]</font> .  Hah <font color="blue">[1 | 5]</font> ! ‚Äù <br><br>  Now, again, we need to somehow separate the compressed chains from the rest of the data.  The most common way is to reuse the structure and directly indicate where the compressed data is and where not.  To do this, we divide the coded data into groups of eight elements (symbols or links), and before each of these groups we will insert a byte, where each bit corresponds to the type of element: 0 for a symbol and 1 for a link. <br><br>  We divide into groups: <br><ul><li>  "The comp" </li><li>  "Ression" </li><li>  "And t <font color="blue">[19 | 1]</font> de" </li><li>  ‚Äú <font color="blue">[21 | 10]</font> leave <font color="blue">[27 | 1]</font> ‚Äù </li><li>  ‚ÄúI <font color="blue">[41 | 5]</font> .  Hah <font color="blue">[2 | 5]</font> ¬ª </li><li>  "!" </li></ul><br>  We compose the groups: <br><br>  " <font color="red">{0,0,0,0,0,0,0,0}</font> The comp <font color="red">{0,0,0,0,0,0,0,0,0}</font> ression <font color="red">{0,0,0,0,0,1 , 0,0}</font> and t <font color="blue">[19 | 1]</font> de <font color="red">{1,0,0,0,0,0,1,0}</font> <font color="blue">[21 | 10]</font> leave <font color="blue">[27 | 1]</font> <font color="red">{0,1,0,0, 0,0,0,1}</font> i <font color="blue">[41 | 5]</font> .  Hah <font color="blue">[1 | 5]</font> <font color="red">{0}</font> ! ‚Äù <br><br>  Thus, if, while unpacking, we meet bit 0, then we simply read the character into the output stream, if bit 1, we read the link, and follow the link to read the sequence from the dictionary. <br><br>  Now we just have to group the result into an array of bytes.  We agree that we use bits and bytes in order from highest to lowest.  Let's look at how links are packed into bytes in the example <font color="blue">[19 | 1]</font> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00b/312/bf7/00b312bf73cdba196f5775e96e7e5c52.png"><br><br>  As a result, our compressed stream will look like this: <br><br>  0000: <font color="red">00</font> 54 68 65 20 63 6f 6d 70 <font color="red">00</font> 72 65 73 73 69 6f #The comp # ressio <br>  0010: 6e 20 <font color="red">04</font> 61 6e 64 20 74 <font color="blue">01 31</font> 64 65 <font color="red">82</font> <font color="blue">01 5a</font> 6c n #and t ## de ### l <br>  0020: 65 61 76 65 <font color="blue">01 b1</font> 20 <font color="red">41</font> 69 <font color="blue">02 97</font> 2e 20 48 61 68 eave ## # i ##.  Hah <br>  0030: <font color="blue">00 15</font> <font color="red">00</font> 21 <font color="white">00 00 00 00 00 00 00 00 00 00 00 00</font> ###! <br><br><h4>  Possible improvements </h4><br>  In principle, everything that has been described for RLE will be correct here.  In particular, to demonstrate the benefits of the heuristic approach to encoding, consider the following example: <br><br>  ‚ÄúThe long goooooong.  The loooooower bound. <br><br>  Find sequences only for the word "loooooower": <br><br>  ‚ÄúThe long goooooong.  The <font color="blue">[lo] [ooooo]</font> wer bound. " <br><br>  To encode such a result, we need four bytes per link.  However, it would be more economical to do this: <br><br>  ‚ÄúThe long goooooong.  The l <font color="blue">[oooooo]</font> wer bound. " <br><br>  Then we would spend one byte less. <br><br><h1>  Instead of conclusion </h1><br>  Despite its simplicity and, it would seem, not too much efficiency, these algorithms are still widely used in various fields of IT-sphere. <br><br>  Their plus is simplicity and speed, and more complex and efficient algorithms can be based on their principles and their combinations. <br><br>  Hopefully, the essence of these algorithms presented in this way will help someone to understand the basics and start looking towards more serious things. </div><p>Source: <a href="https://habr.com/ru/post/141827/">https://habr.com/ru/post/141827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141819/index.html">Music players in Android</a></li>
<li><a href="../141820/index.html">Today IndexTank turns off all its servers</a></li>
<li><a href="../141822/index.html">Speakers at UA PyCon</a></li>
<li><a href="../141825/index.html">Protecting traffic with Comodo TrustConnect and DNSCrypt</a></li>
<li><a href="../141826/index.html">Tim Cook will open the D10 conference</a></li>
<li><a href="../141829/index.html">Samba <3.6.4 (CVE-2012-1182) remote execution of arbitrary code with root-rights</a></li>
<li><a href="../141830/index.html">How Instagram prepared for the launch of the Android application</a></li>
<li><a href="../141832/index.html">Google Chrome 19 introduces open tabs sync.</a></li>
<li><a href="../141833/index.html">Routes on Google Maps in your Android application</a></li>
<li><a href="../141834/index.html">Meteor - A new way to create applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>