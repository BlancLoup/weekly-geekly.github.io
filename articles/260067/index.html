<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive User Interface Programming in Jancy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is reactive programming? The Wikipedia article teaches that this is a programming paradigm that focuses on data flow and propagation of changes ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive User Interface Programming in Jancy</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/ad0/874/2f7ad0874dad40130476cdf7f7adba58.png" alt="rocket" align="right">  What is reactive programming?  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">The Wikipedia article</a> teaches that this is a programming paradigm that <b>focuses on data flow and propagation of changes</b> .  This definition, though technically correct (of course!), Gives an extremely vague idea of ‚Äã‚Äãwhat really hides behind all this.  Meanwhile, the concept of reactivity is simple and natural, and it is best explained using the following example. <br><br>  We all have ever used spreadsheets like Microsoft Excel.  In the cell of the table, the user can write a formula that refers to other cells.  If the value of any of them changes, the formula will be recalculated, and our cell will automatically update.  At the same time, if our cell participates in other formulas, then they will be automatically recalculated, and so on, and so on - a process resembling the development of a chain reaction.  So, this is the main idea of ‚Äã‚Äãreactive programming! <br><br>  On Habr√©, there were already quite a few articles on the topic of reactive programming ( <a href="http://habrahabr.ru/post/198656/">one</a> , <a href="http://habrahabr.ru/post/140719/">two</a> , <a href="http://habrahabr.ru/company/2gis/blog/228125/">three</a> , <a href="http://habrahabr.ru/post/254569/">four,</a> and others) - mainly they describe reactivity in their <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">FRP-</a> apostles in the form of libraries like <a href="https://baconjs.github.io/">bacon.js</a> for JavaScript, <a href="https://github.com/ReactiveX/RxJava">JavaRx</a> for Java, etc. .  This article will discuss the implementation and application of reactive programming in the <a href="http://tibbo.com/jancy/">Jancy</a> language.  The material will be interesting to read, even if you have never heard of Jancy and do not intend to write anything on it - because we will demonstrate a rather unusual approach to reactivity from an imperative language. <br><a name="habracut"></a><br>  Whichever of the existing reactive libraries we take, the <b>‚ÄúObservable‚Äù</b> pattern will be key in the implementation.  Indeed, in order to ‚Äúpropagate‚Äù the changes, we at least need to receive notification of them.  Observable entities are usually divided into two primitives (they are called differently in different libraries): <br><ul><li>  Event stream (EventStream / Observable / Event / Stream); </li><li>  Properties (Property / Behavior / Attribute) - a value that changes with time. </li></ul><br>  In FRP, all this is insisted on the elements of <b>functional programming</b> : to construct complex structures of such primitives, functions of higher order are used such as map, reduce, filter, combine, etc.  which generate secondary streams and events (instead of ‚Äúmodifying‚Äù the original ones).  The resulting compote of observables and functionalism is not so difficult to understand and master, and at the same time allows us to express the dependencies between components in a <b>declarative form</b> .  This is great for programming intricate user interfaces and distributed asynchronous systems.  So is there anything to improve? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Problems </h1><br>  The first problem is this.  If reactivity is implemented at the library level, without observables in the compiler, then <b>automatically recalculated formulas a la Excel</b> remain an unattainable ideal.  Instead, you have to manually make several map and combine over our observables - the more, the more complex the logic of our formula, and then onValue / assign to write the resulting value to the right place. <br><br>  Perhaps <a href="http://flapjax-lang.org/">Flapjax</a> , an open source JavaScript compiler, came closest to Excel-like formulas (if there are other projects of this kind, please write about them in the comments).  Type 2 observables, which are called Behavor in Flapjax, can be arbitrarily combined in expressions and get new Behavor output. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/772/1cf/5bc/7721cf5bc33a694798ad419c2de6b7fb.jpg" alt="magic-pot" align="left">  But there is another fundamental problem that is inherent in both reactive libraries, and Flapjax - this is the problem <b>‚Äúdo not boil the pot‚Äù</b> .  After we have created our infrastructure from streams of events, properties, and reciprocal subscriptions to each other, it begins to live its own life.  The data flows and is transformed, as we asked them, the necessary actions are performed in all onValue and onCompleted, everything is great.  So, how to stop it now?  Run through all root observables and stop the issue of events manually?  Already not very beautiful.  And what if it is necessary to stop not everything, but only a part of our reactive dependency graph?  Given that the lion's share of our observables exists in the form of implicit results map / combine / filter? <br><br>  If we reformulate it somewhat differently, then one of the problems with existing reactive libraries is that (largely due to their functional orientation) they generate a single-level structure of observable objects! <br><br>  However, it is always easier to criticize than to offer some alternative.  So what does Jancy boast in terms of reactivity? <br><ol><li>  Excel-like <b>automatic recalculation of formulas</b> with observables - and only where the programmer chooses; </li><li>  The ability to group <b>dependency clusters</b> between observables - and then start and stop all subscriptions in the cluster at once. </li></ol><br>  It looks like this: <br><pre><code class="cpp hljs">reactor TcpConnectionSession.m_uiReactor () { m_title = $<span class="hljs-string"><span class="hljs-string">"TCP $(m_addressCombo.m_editText)"</span></span>; m_isTransmitEnabled = m_state == State.Connected; m_adapterProp.m_isEnabled = m_useLocalAddressProp.m_value; m_localPortProp.m_isEnabled = m_useLocalAddressProp.m_value; m_actionTable [ActionId.Connect].m_text = m_state ? <span class="hljs-string"><span class="hljs-string">"Disconnect"</span></span> : <span class="hljs-string"><span class="hljs-string">"Connect"</span></span>; m_actionTable [ActionId.Connect].m_icon = m_iconTable [m_state ? IconId.Disconnect : IconId.Connect]; m_statusPaneTable [StatusPaneId.State].m_text = m_stateStringTable [m_state]; m_statusPaneTable [StatusPaneId.RemoteAddress].m_text = m_state &gt; State.Resolving ? m_remoteAddress.getString () : <span class="hljs-string"><span class="hljs-string">"&lt;peer-address&gt;"</span></span>; m_statusPaneTable [StatusPaneId.RemoteAddress].m_isVisible = m_state &gt; State.Resolving; }</code> </pre> <br>  This is a squeeze from the source of the session TCP Connection Terminal <a href="http://tibbo.com/ioninja/">IO Ninja</a> .  As it is easy to guess, this code is engaged in updating the UI with changes in status, text in the combo box, etc. <br><br>  And now about how it works. <br><br><h1>  General plan </h1><br>  First of all, in order to avoid confusion, we will agree on terminology. <br><br>  <b>The property</b> (property) in Jancy has a generally accepted (non-reactive) definition - this is a kind of thing that looks like a variable / field, but at the same time allows you to perform actions in accessor functions. <br><br>  <b>Multicasts</b> (multicast) and <b>events</b> (event) are used to accumulate pointers to functions and call them all at once (the differences between multicasts and events a little later). <br><br>  In Jancy, only one type of observable at the compiler level is the <b>‚Äú</b> bindable property‚Äù, i.e.  a property that can notify about its change through the onChanged event. <br><br>  Unlike analogs, reactivity in Jancy does not try to be ‚Äútoo smart‚Äù and go everywhere where observables are used ‚Äî with side effects like automatic subscription, implicit generation of new observables, etc.  She stands in the corner and is not asking.  Access to associated properties in an imperative style is no more than access to a regular variable. <br><br>  How does this combine with the above-mentioned reactive recalculation a la Excel?  The conflict-free coexistence of reactive and imperative beginnings in Jancy is possible because there are <b>special zones of reactive code</b> - the so-called.  <b>reactors</b> (reactors).  Instead of a sequence of instructions, reactors consist of Excel-like formulas - expressions, each of which must use associated properties.  Inside the reactors, the properties to be bound behave ‚Äúreactively‚Äù. <br><br>  So, the main building blocks of which reactive programming in Jancy is built are <b>events</b> , <b>associated properties</b> and <b>reactors</b> .  Consider these bricks closer. <br><br><h1>  Multicasts and events </h1><br>  <b>The</b> multicast (multicast) in Jancy is a compiler-generated special class that allows you to accumulate function pointers and then call them all at once.  A multicast declaration is very similar to a function declaration, which is not surprising since it must uniquely determine which type of function pointers will be stored in this multicast: <br><pre> <code class="cpp hljs">foo (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x); bar ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y ); baz () { <span class="hljs-function"><span class="hljs-function">multicast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// normal (fat) multicast intptr fooCookie = m.add (foo); m += bar ~(, 200); // capture the 2nd argument m (100); // &lt;-- foo (100); bar (100, 200); m -= fooCookie; m (300); // &lt;-- bar (300, 200); m.clear (); }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Learn more about multicast class methods.</b> <div class="spoiler_text">  For example, let's define a simple multicast: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">multicast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  The multicast class generated in the example above will have the following methods: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">intptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(function* (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// returns cookie intptr add (function* (int)); // returns cookie function* remove (intptr cookie) (int); function* getSnapshot () (int); void call (int);</span></span></code> </pre><br>  The set and add methods return a certain integer cookie that can be used in the remove method to effectively remove a pointer from a multicast. <br><br>  Some of the methods also have aliases in the form of statements: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">multicast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; m = foo; <span class="hljs-comment"><span class="hljs-comment">// same as m.set (foo); m += bar; // same as m.add (bar); m -= cookie; // same as m.remove (cookie); m = null; // same as m.clear (); m (10); // same as m.call (10);</span></span></code> </pre><br>  Multicast can be led to a pointer to a function that will cause all the pointers accumulated in the multicast.  But there is ambiguity, namely: should such a casting be ‚Äúlive‚Äù (live) or snapshot?  In other words, if after creating a pointer to a function, we modify the original multicast, should this pointer see changes? <br><br>  To resolve ambiguity multicashes provide a getSnapshot method that returns a snapshot.  At the same time, the cast operator gives a ‚Äúlive‚Äù pointer: <br><pre> <code class="cpp hljs">foo (); bar (); baz () { <span class="hljs-function"><span class="hljs-function">multicast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; m += foo; <span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= m.getSnapshot (); <span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= m; m += bar; f1 (<span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- foo (); f2 (55); // &lt;-- foo (); bar (); return 0; }</span></span></code> </pre><br></div></div><br>  <b>Events</b> ( <b>events</b> ) in Jancy are special <b>pointers</b> to multicasts <b>with access restriction</b> : you can only do add and remove: <br><pre> <code class="cpp hljs">foo () { <span class="hljs-function"><span class="hljs-function">multicast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">event* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= m; p += bar; <span class="hljs-comment"><span class="hljs-comment">// OK p (100); // &lt;-- error, 'call' is inaccessible }</span></span></code> </pre><br>  Declaring a variable or field of type "event" creates a <b>dual type</b> : for "friends", this type behaves as if the multicast modifier were used, and for "alien" it is an event with the prohibition of calling all methods except add and remove. <br><div class="spoiler">  <b class="spoiler_title">Read more about dual types in Jancy</b> <div class="spoiler_text">  The main difference between the access model in Jancy and most other object-oriented languages ‚Äã‚Äãis the reduction of the number of access specifiers to two - <b>public</b> and <b>protected</b> . <br><br>  On the one hand, it provides developers with significantly less flexibility in determining who has access to what.  On the other hand, this simplified model makes it possible to clearly divide everyone into <b>‚Äúfriend or foe‚Äù</b> , and this, in turn, opens up the possibility of <b>dual modifiers</b> , i.e.  modifiers that have different meanings for "their" and "alien", and the <b>dual types</b> created with their help. <br><br>  So, in Jancy, for each individual namespace A, the rest of the world falls into two categories: ‚Äúown‚Äù and ‚Äúalien‚Äù.  In addition to the namespace A itself, its ‚Äúowns‚Äù include: <br><ul><li>  Namespaces of classes or structures inherited from A; </li><li>  Namespaces declared as friend (friend); </li><li>  Children in relation to A namespaces; </li><li>  Extensions (extension namespaces) A. </li></ul><br>  All others are "alien".  "Own" have access to both public (public) and protected (protected) members of the namespace, while "alien" - only to public members.  In addition, belonging to the group of "their" or "alien" changes the meaning of Jancy dual modifiers. <br><br>  The <b>readonly</b> dual modifier can be used for elegant read-only access.  Instead of writing trivial getters, the only purpose of which would be access control, a Jancy developer can declare fields with a readonly modifier.  For "their", the readonly modifier seems to be invisible, for the "alien" readonly is treated as <b>const</b> : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> readonly m_progress; foo () { m_progress += <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK // ... } } bar (C1* c) { c.m_progress = 100; // &lt;-- error, cannot write to 'const' location }</span></span></code> </pre><br>  The main advantage of this approach is that it makes the code shorter and more natural;  As a side effect, you can call a simplification, and therefore an acceleration of the work of the optimizer, which does not need to analyze and discard dummy getters. <br><br>  The second dual modifier in Jancy is <b>event</b> .  The event owner must have complete control over it, including the ability to call all subscribers or clear their list.  The event client should only be able to add or remove a subscriber.  For "their" field with the event modifier works the same way as a multicast with the corresponding signature of the arguments.  For "alien", this field restricts access to multicast methods: only add and remove calls are allowed;  call, set, clear, getSnapshot and casting to a pointer-to-function are prohibited: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">event </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_onCompleted</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// dual type bool work () { // ... m_onCompleted (); // OK, friends have multicast-access to m_onComplete return true; } } foo () { C1 c; c.m_onCompleted += completionFunc; // ok, aliens have event-access to m_onComplete c.m_onCompleted (); // &lt;-- error, 'call' is inaccessible c.m_onCompleted.clear (); // &lt;-- error, 'clear' is inaccessible }</span></span></code> </pre><br></div></div><br><h1>  Properties </h1><br>  In the context of programming languages, a <b>property</b> is something that looks and behaves like data, but at the same time allows you to perform some additional actions when reading and writing.  Without false modesty, Jancy provides the most comprehensive to date implementation of the properties of any shape, color and size. <br><div class="spoiler">  <b class="spoiler_title">More and with examples</b> <div class="spoiler_text"><h3>  Definitions </h3><br>  Functions that perform actions in reading and writing are called <b>accessors</b> : the property reading accessor is called a getter, and the writing is called a setter. <br><br>  Each property in Jancy has one <b>getter</b> and optionally one or several (overloaded) <b>setters</b> (that is, there is no write-only property in Jancy).  If the setter is overloaded, then the selection of a specific setter will be made while assigning a value to a property according to the same rules that select the overloaded function. <br><br>  If the property does not have a setter, then it is called <b>constant</b> (const-property).  In other programming languages, properties without setters are usually called read-only, but since Jancy's <b>const</b> and <b>readonly</b> coexist (readonly is a dual modifier), it would have to override the well-known definitions one way or another.  So, in Jancy, a property without a setter is a const property. <br><br><h3>  Simple properties </h3><br>  For simple properties without overloaded setters (to which most practical tasks come down) the most natural form of declaration is proposed: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> property g_simpleProp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property g_simpleConstProp;</code> </pre><br>  This form is ideal for declaring interfaces, or if the developer prefers the C ++ style of posting declarations and method implementations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g_simpleProp.get () { <span class="hljs-comment"><span class="hljs-comment">// ... } g_simpleProp.set (int x) { // ... } int g_simpleConstProp.get () { // ... }</span></span></code> </pre><br><h3>  Full form ad </h3><br>  For properties of arbitrary complexity (i.e., properties with overloaded setters, data fields, auxiliary methods, etc.) there is a complete form of the declaration: <br><pre> <code class="cpp hljs">property g_prop { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// member field with in-place initializer int get () { return m_x; } set (int x) { m_x = x; update (); } set (double x); // overloaded setter update (); // helper method }</span></span></code> </pre><br><h3>  Indexed properties </h3><br>  Jancy also supports indexable properties, i.e.  properties with array semantics.  Accessors of such properties take additional index arguments.  However, unlike real arrays, index arguments of properties are not required to be integer, and, strictly speaking, they do not have to have the meaning of an ‚Äúindex‚Äù at all - their use is completely determined by the developer: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> indexed property </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g_simpleProp</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; property g_prop { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j )</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x ); <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x ); } foo () { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = g_simpleProp [<span class="hljs-number"><span class="hljs-number">10</span></span>]; g_prop [x] [<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; }</code> </pre><br><h3>  Autoget properties </h3><br>  In the overwhelming majority of cases, the getter simply has to return the value of some variable or field where the current value of the property is stored, and the actual behavior logic of the property is embodied in the setter.  Obviously, the creation of such trivial getters can be passed on to the compiler - as was done in Jancy.  For autoget properties, the compiler automatically creates a getter and a field for storing data.  Moreover, the compiler generates direct access to the field, bypassing the getter, wherever possible: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget property g_simpleProp; g_simpleProp.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { m_value = x; <span class="hljs-comment"><span class="hljs-comment">// the name of a compiler-generated field is 'm_value' } property g_prop { int autoget m_x; // declaring an autoget field makes the whole property autoget set (int x); set (double x); }</span></span></code> </pre><br>  The opposite situation, when the special logic of the behavior of the property is embedded in the getter, and the empty setter must simply put the data in a memory cell, is rare and does not deserve the creation of a special syntax. <br></div></div><br>  When applied to reactive programming, the <b>properties of</b> interest are of greatest interest,  properties that can notify subscribers of their changes.  As you can guess, Jancy uses the <b>multicast / event</b> mechanism to implement the associated properties: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget bindable property g_simpleProp; g_simpleProp.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == m_value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; m_value = x; m_onChanged (); <span class="hljs-comment"><span class="hljs-comment">// the name of a compiler-generated bindable event is 'm_onChanged' } property g_prop { autoget int m_x; bindable event m_e (); // declaring a bindable event makes the whole property bindable set (int x); set (double x); }</span></span></code> </pre><br>  For access to the events notifying on changes of the bound properties, the operator is used <b>bindingof</b> : <br><pre> <code class="cpp hljs">onSimplePropChanged () { <span class="hljs-comment"><span class="hljs-comment">// ... } foo () { bindingof (g_simpleProp) += onSimplePropChanged; g_simpleProp = 100; // bindable event is going to get fired }</span></span></code> </pre><br>  Jancy also supports binding properties with fully compiled accessor accessors ‚Äî both the getter and the setter.  These kind of degenerative properties are called bindable data.  They serve the only purpose - to catch the moment of change - and can act as simple observable variables / fields: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bindable g_data; onDataChanged () { <span class="hljs-comment"><span class="hljs-comment">// ... } foo () { bindingof (g_data) += onDataChanged; g_data = 100; // onDataChanged will get called g_data = 100; // onDataChanged will NOT get called }</span></span></code> </pre><br><h1>  Reactors </h1><br>  <b>The reactor</b> in Jancy is a zone of a reactive code.  All reactive dependencies and implicit subscriptions are located inside the reactors. <br><br>  Externally, the reactor looks like a normal function, except that in the declaration specified modifier reactor.  Unlike functions, each reactor creates a variable or field of a special <b>reactor class</b> with two public methods: start and stop, which allow starting and stopping the reactor.  Instead of statements (statements) that make up the body of a normal function, the reactor body consists of a sequence of expressions, each of which should use in its right side the associated properties: <br><br><pre> <code class="cpp hljs">State bindable m_state; <span class="hljs-function"><span class="hljs-function">reactor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_uiReactor</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_isTransmitEnabled = m_state == State.Connected; m_actionTable [ActionId.Disconnect].m_isEnabled = m_state != State.Closed; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  At start-up, the reactor builds a dependency graph and subscribes to all associated events of all ‚Äúcontrolling‚Äù properties.  When changing any of them, all dependent expressions are recalculated (which, of course, can cause an avalanche change in other properties). <br><div class="spoiler">  <b class="spoiler_title">And what to do with cyclical dependencies?</b> <div class="spoiler_text">  At the moment, cyclic dependency updates are simply ignored - that is, if any of the control properties of P changed and caused a recalculation of expressions in the reactor, which in turn changed the value of this property P, then this repeated change will not cause recursive calculations in the reactor. <br><br>  In the future, most likely, the reactors will have the settings for the permissible recursion depth and recovery strategy, if the depth is still exceeded (ignore / stop the reactor with an error / call some callback / etc.) <br></div></div><br>  In addition to reactive expressions, arbitrary events and their processing code can be linked in reactors in an intuitive syntax.  For this, the construction of <b>onevent</b> .  This approach allows you to use the traditional event approach to the UI and at the same time eliminates the need to subscribe to events manually: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">reactor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_uiReactor</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ onevent m_startButton.m_onClicked () { <span class="hljs-comment"><span class="hljs-comment">// handle start button click... } onevent (bindingof (m_userEdit.m_text), bindingof (m_passwordEdit.m_text)) () { // handle login change... } // ... }</span></span></code> </pre><br>  At shutdown, the reactor unsubscribes from all events to which it is subscribed (if the reactor is a member of the class, then the shutdown automatically occurs at the moment of destruction of the parent object).  Thus, the developer has the ability to determine in detail and <b>where to</b> use the reactive approach (reactor zones), and <b>when</b> (start / stop).  All implicit subscriptions are gathered together and it is very easy to make a sacramental <b>"pot not boiling"</b> : <br><pre> <code class="cpp hljs">m_uiReactor.stop ();</code> </pre><br>  In this case, of course, there may be several reactors that use the same properties to be linked and other events - if this is required for the logical grouping of dependencies into certain clusters. <br><br><h1>  Putting it all together </h1><br>  So, we have all the cubes in order to collect beautiful user interface frameworks from them and use them in a reactive style: <br><div class="spoiler">  <b class="spoiler_title">Multiple UI Classes</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> bitflag <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SizePolicyFlag { Grow, Expand, Shrink, Ignore, } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SizePolicy { Fixed = <span class="hljs-number"><span class="hljs-number">0</span></span>, Minimum = SizePolicyFlag.Grow, Maximum = SizePolicyFlag.Shrink, Preferred = SizePolicyFlag.Grow | SizePolicyFlag.Shrink, MinimumExpanding = SizePolicyFlag.Grow | SizePolicyFlag.Expand, Expanding = SizePolicyFlag.Grow| SizePolicyFlag.Shrink | SizePolicyFlag.Expand, Ignored = SizePolicyFlag.Shrink | SizePolicyFlag.Grow | SizePolicyFlag.Ignore } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> intptr m_handle; SizePolicy readonly m_hsizePolicy; SizePolicy readonly m_vsizePolicy; setSizePolicy ( SizePolicy hpolicy, SizePolicy vpolicy ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> autoget property m_isVisible; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> autoget property m_isEnabled; } opaque <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class">:</span></span> Widget { bitflag <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Alignment { Left, Right, HCenter, Justify, Absolute, Top, Bottom, VCenter, } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* autoget property m_text; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget property m_color; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget property m_backColor; Alignment autoget property m_alignment; <span class="hljs-function"><span class="hljs-function">Label* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* text)</span></span></span></span>; } opaque <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class">:</span></span> Widget { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* autoget property m_text; <span class="hljs-function"><span class="hljs-function">event </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_onClicked</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Button* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* text)</span></span></span></span>; } opaque <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckBox</span></span></span><span class="hljs-class">:</span></span> Widget { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* autoget property m_text; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bindable property m_isChecked; <span class="hljs-function"><span class="hljs-function">CheckBox* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* text)</span></span></span></span>; } opaque <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextEdit</span></span></span><span class="hljs-class">:</span></span> Widget { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* property m_text; <span class="hljs-function"><span class="hljs-function">TextEdit* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } opaque <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Slider</span></span></span><span class="hljs-class">:</span></span> Widget { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget property m_minimum; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> autoget property m_maximum; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bindable property m_value; <span class="hljs-function"><span class="hljs-function">Slider* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minimum = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maximum = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Their use from the reactor</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Slider* g_redSlider; Slider* g_greenSlider; Slider* g_blueSlider; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bindable g_color; Label* g_colorLabel; CheckBox* g_enablePrintCheckBox; TextEdit* g_textEdit; Button* g_printButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcColorVolume</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (color &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) + ((color &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) + ((color &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-function"><span class="hljs-function">reactor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g_uiReactor</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ g_color = (g_redSlider.m_value &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (g_greenSlider.m_value &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (g_blueSlider.m_value); g_colorLabel.m_text = $<span class="hljs-string"><span class="hljs-string">"#$(g_color;06x)"</span></span>; g_colorLabel.m_backColor = g_color; g_colorLabel.m_color = calcColorVolume (g_color) &gt; <span class="hljs-number"><span class="hljs-number">0x180</span></span> ? <span class="hljs-number"><span class="hljs-number">0x000000</span></span> : <span class="hljs-number"><span class="hljs-number">0xffffff</span></span>; g_textEdit.m_isEnabled = g_enablePrintCheckBox.m_isChecked; g_printButton.m_isEnabled = g_enablePrintCheckBox.m_isChecked; onevent g_printButton.m_onClicked () { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> ($<span class="hljs-string"><span class="hljs-string">"&gt; $(g_textEdit.m_text)\n"</span></span>); } }</code> </pre></div></div><br>  Dear habrovchane are invited to the <a href="http://tibbo.com/jancy/live_demo.html">live page of</a> our compiler, to test the reactive capabilities of Jancy without the need to download, install or build anything. <br><br>  Those who want to download and compile / just delve into the source Jancy, can do it from the <a href="http://tibbo.com/jancy/downloads.html">download page</a> .  By the way, in the samples / 02_dialog folder is the above example of hanging reactivity on QT widgets. <br><br>  And the real use of Jancy and its reactive capabilities can be viewed in our programmable terminal / <a href="http://tibbo.com/ioninja/">IO Ninja</a> sniffer. </div><p>Source: <a href="https://habr.com/ru/post/260067/">https://habr.com/ru/post/260067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260047/index.html">Interesting notes on C # and CLR (v2.0)</a></li>
<li><a href="../260049/index.html">One of the features of PHP related to methods and functions</a></li>
<li><a href="../260053/index.html">How to bind Docker containers without forcing the application to read environment variables</a></li>
<li><a href="../260061/index.html">Development of modular C / C ++ applications using annotations</a></li>
<li><a href="../260065/index.html">NGINX inside: born for performance and scaling</a></li>
<li><a href="../260069/index.html">Squires of microelectronics. Video report from the San Francisco Electronics Design Conference</a></li>
<li><a href="../260071/index.html">Charm Solitaire game defense study</a></li>
<li><a href="../260073/index.html">The construction of Bitcoin data centers continues, despite the fall in the cost of cryptocurrency</a></li>
<li><a href="../260077/index.html">WWDC15. Third day. Interesting</a></li>
<li><a href="../260081/index.html">On the organization of the workflow of the photographer. (Comparing with the opinion of the magazine What Digital Camera)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>