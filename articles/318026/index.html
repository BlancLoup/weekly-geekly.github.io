<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your own ‚Äúsandbox‚Äù: an example of the simplest ‚Äúsandbox‚Äù. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, you got a brief idea about drivers in a privileged mode. It's time to delve into our sandbox. 

 Sandbox example: dr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your own ‚Äúsandbox‚Äù: an example of the simplest ‚Äúsandbox‚Äù. Part II</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fdc/969/1cf/fdc9691cf47f4bad99e9929fefd129b0.png" alt="image"><br><br>  In the <a href="https://habrahabr.ru/company/infowatch/blog/317396/">first part of the</a> article, you got a brief idea about drivers in a privileged mode.  It's time to delve into our sandbox. <br><a name="habracut"></a><br><h3>  Sandbox example: driver assembly and installation </h3><br>  The core of our sandbox is a mini filter driver.  You can find its source code in src \ FSSDK \ Kernel \ minilt.  I assume that you are using the WDK 7.x kit to build the driver.  To do this, you must run the appropriate environment, say, Win 7 x86 checked, and go to the directory with the source code.  Just type ‚Äúbuild / c‚Äù on the command line when running in the development environment and you will get the built drivers.  To install the driver, just copy the * .inf file to the folder containing the * .sys file, navigate to this directory using Explorer and use the context menu on the * .inf file, where you select the "Install" option, and the driver will be installed.  I recommend that you conduct all the experiments inside the virtual machine, VMware will be a good choice.  Please note that 64-bit versions of Windows will not load unsigned drivers.  To be able to run the driver in VMware, you must enable the privileged mode debugger in the guest OS.  This can be done by executing the following cmd commands running as administrator: <br><br>  1. bcdedit / debug on <br>  2. bcdedit / bootdebug on 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now you must assign the named pipe as a serial port for VMware and setup using WinDBG installed on your machine.  Then you can connect to VMware with a debugger and debug your drivers. <br><br>  You can find detailed information on configuring VMware for debugging drivers in <a href="http://silverstr.ufies.org/lotr0/windbg-vmware.html">this article</a> . <br><br><h3>  Sandbox Example: Architecture Overview </h3><br>  Our simple sandbox consists of three modules: <br><br>  ‚Ä¢ a privileged mode driver that implements virtualization primitives; <br>  ‚Ä¢ a user mode service that receives messages from the driver and can change the behavior of the file system by changing the parameters of the received notifications from the driver; <br>  ‚Ä¢ the fsproxy intermediate library that helps the service communicate with the driver. <br><br>  Let's start the consideration of our simplest sandbox driver in privileged mode. <br><br><h3>  Example sandbox: write driver </h3><br>  While normal applications, as a rule, begin their execution in WinMain (), drivers do this with the DriverEntry () function.  Let's start learning the driver with this feature. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DriverEntry</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __in PDRIVER_OBJECT DriverObject, __in PUNICODE_STRING RegistryPath )</span></span></span><span class="hljs-function"> </span></span>{ OBJECT_ATTRIBUTES oa; UNICODE_STRING uniString; PSECURITY_DESCRIPTOR sd; NTSTATUS status; UNREFERENCED_PARAMETER( RegistryPath ); ProcessNameOffset = GetProcessNameOffset(); DbgPrint(<span class="hljs-string"><span class="hljs-string">"Loading driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// //     // status = FltRegisterFilter( DriverObject, &amp;FilterRegistration, &amp;MfltData.Filter ); if (!NT_SUCCESS( status )) { DbgPrint("RegisterFilter failure 0x%x \n",status); return status; } // //   . // RtlInitUnicodeString( &amp;uniString, ScannerPortName ); // //   ,          . // status = FltBuildDefaultSecurityDescriptor( &amp;sd, FLT_PORT_ALL_ACCESS ); if (NT_SUCCESS( status )) { InitializeObjectAttributes( &amp;oa, &amp;uniString, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, sd ); status = FltCreateCommunicationPort( MfltData.Filter, &amp;MfltData.ServerPort, &amp;oa, NULL, FSPortConnect, FSPortDisconnect, NULL, 1 ); // //      .    //  ,   FltCreateCommunicationPort() // FltFreeSecurityDescriptor( sd ); regCookie.QuadPart = 0; if (NT_SUCCESS( status )) { // //    -. // DbgPrint(" Starting Filtering \n"); status = FltStartFiltering( MfltData.Filter ); if (NT_SUCCESS(status)) { status = PsSetCreateProcessNotifyRoutine(CreateProcessNotify,FALSE); if (NT_SUCCESS(status)) { DbgPrint(" All done! \n"); return STATUS_SUCCESS; } } DbgPrint(" Something went wrong \n"); FltCloseCommunicationPort( MfltData.ServerPort ); } } FltUnregisterFilter( MfltData.Filter ); return status; }</span></span></code> </pre> <br>  DriverEntry has several key features.  First, this function registers the driver as a minifler with the FltRegisterFilter () function: <br><br><pre> <code class="cpp hljs">status = FltRegisterFilter( DriverObject, &amp;FilterRegistration, &amp;MfltData.Filter );</code> </pre><br>  It is an array of pointers for handlers of certain operations that it wants to intercept in FilterRegistration, and receives an instance of the filter in MfltData.Filter in case of successful registration.  FilterRegistration is declared as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FLT_REGISTRATION FilterRegistration = { <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( FLT_REGISTRATION ), <span class="hljs-comment"><span class="hljs-comment">//  FLT_REGISTRATION_VERSION, //  0, //  NULL, //   Callbacks, //  DriverUnload, //   FSInstanceSetup, //    FSQueryTeardown, //     NULL, NULL, FSGenerateFileNameCallback, //    FSNormalizeNameComponentCallback, //    NULL, //    #if FLT_MGR_LONGHORN NULL, //    FSNormalizeNameComponentExCallback, //     #endif // FLT_MGR_LONGHORN };</span></span></code> </pre><br>  As you can see, the structure contains a pointer to an array of event handlers (Callbacks).  This is an analogue of dispatching procedures in ‚Äúoutdated‚Äù drivers.  In addition, this structure contains pointers to some other auxiliary functions ‚Äî we will describe them later.  Now we‚Äôll focus on the handlers described in the Callbacks array.  They are defined as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FLT_OPERATION_REGISTRATION Callbacks[] = { { IRP_MJ_CREATE, <span class="hljs-number"><span class="hljs-number">0</span></span>, FSPreCreate, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }, { IRP_MJ_CLEANUP, <span class="hljs-number"><span class="hljs-number">0</span></span>, FSPreCleanup, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}, { IRP_MJ_OPERATION_END} };</code> </pre><br>  You can see a detailed description of the FLT_OPERATION_REGISTRATION structure in MSDN.  Our driver registers only two handlers - FSPreCreate, which will be called each time the IRP_MJ_CREATE request is received, and FSPreCleanup, which, in turn, will be called each time the IRP_MJ_CLEANUP is received.  This request will arrive when the last file handle is closed.  We can (and will) change the input parameters and send the modified request down the stack, so that the lower filters and the file system driver will receive the modified request.  We could register the so-called post-notifications coming at the end of the operation.  For this, the null pointer that follows the pointer to FSPreCreate can be replaced by a pointer to the corresponding post-processor.  We need to terminate our array with IRP_MJ_OPERATION_END.  This is a ‚Äúfake‚Äù operation, which marks the end of an array of event handlers.  Note that we do not have to provide a handler for each IRP_MJ_XXX operation, as we would have to do for ‚Äútraditional‚Äù filter drivers. <br><br>  The second important thing that our DriverEntry () performs is the creation of a mini filter port.  It is used to send notifications from the user-level service and receives responses from it.  This is done using the FltCreateCommunicationPort () operation: <br><br><pre> <code class="cpp hljs">status = FltCreateCommunicationPort( MfltData.Filter, &amp;MfltData.ServerPort, &amp;oa, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, FSPortConnect, FSPortDisconnect, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre><br>  Pointers to the FSPortConnect () and FSPortDisconnect () functions occur respectively when the user mode service is connected and disconnected from the driver. <br><br>  And the last thing to do is to start filtering: <br><br><pre> <code class="cpp hljs">status = FltStartFiltering( MfltData.Filter );</code> </pre><br>  Note that a pointer to the filter instance returned by FltRegisterFilter () is passed to this procedure.  From this point on, we will start receiving notifications about IRP_MJ_CREATE &amp; IRP_MJ_CLEANUP requests.  Along with notifications about file filtering, we also ask the OS to inform us when a new process is loaded and unloaded using this function: <br><br><pre> <code class="cpp hljs">PsSetCreateProcessNotifyRoutine(CreateProcessNotify,FALSE);</code> </pre><br>  CreateProcessNotify is our notification handler for process creation and termination. <br><br><h3>  Sandbox Example: FSPreCreate Handler </h3><br>  Real magic is born here.  The essence of this function is to tell which file is open and which process initiated the opening.  This data is sent to the user mode service.  The service (service) provides a response in the form of a command either to deny access to the file, or to redirect the request to another file (this is exactly how the sandbox works), or to allow the operation to be performed.  The first thing that happens in this case is to check the connection with the user mode service through the communication port (communication port) that we created in DriverEntry (), and, in the case of no connection, no further action will occur.  We also check whether the service (service) is the source (initiator) of the request - we do this by checking the UserProcess field of the globally allocated MfltData structure.  This field is populated in the PortConnect () subroutine, which is called when the user mode service (service) connects to the port.  Also, we don‚Äôt want to deal with paging requests.  In all these cases, we return the return code FLT_PREOP_SUCCESS_NO_CALLBACK, meaning that we have completed the processing of the request and we do not have a postoperative handler.  Otherwise, we will return FLT_PREOP_SUCCESS_WITH_CALLBACK.  If this were a ‚Äútraditional‚Äù filter driver, then we would have to deal with stack frames that I mentioned earlier, the IoCallDriver procedure, etc.  In the case of mini-filters, the transfer request is quite simple. <br><br>  If we want to process the request, the first thing we need to do is to fill in the structure that we want to pass to the user mode - MINFILTER_NOTIFICATION.  It is completely customizable.  We pass the type of operation (CREATE), the file name on which the request was made, the identification number (PID) of the process and the name of the source process.  It is worth paying attention to how we figure out the name of the process.  In fact, this is an undocumented way to get the name of a process that is not recommended for use in commercial software.  Moreover, it does not work with x64-versions of Windows.  In commercial software, you will transfer only the process ID (identification number) of the process to user mode, and if you need an executable name, you can get it using the user mode API.  For example, you can use the OpenProcess () API to open a process by its ID and then call the GetProcessImageFileName () API to get the name of the executable file.  But to simplify our sandbox, we get the process name from the undocumented field of the PEPROCESS structure.  To find out the name offset (relative address), we consider that the system has a process called "SYSTEM".  We scan the process containing the given name in the PEPROCESS structure, then use the detected name offset when analyzing some other process.  For more information, see the SetProcessName () function. <br><br>  We obtain the file name from the ‚Äútarget‚Äù file for which a request was received (for example, a request to open a file) using two functions - FltGetFileNameInformation () and FltParseFileNameInformation (). <br><br>  After filling in the MINFILTER_NOTIFICATION structure, we send it to user mode: <br><br><pre> <code class="cpp hljs">Status = FltSendMessage( MfltData.Filter, &amp;MfltData.ClientPort, notification, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MINFILTER_NOTIFICATION), &amp;reply, &amp;replyLength, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> );</code> </pre><br>  And we get the answer in the reply variable.  If we are asked to cancel the operation, then the action is simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reply.bAllow) { Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED; Data-&gt;IoStatus.Information = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FLT_PREOP_COMPLETE; }</code> </pre><br>  The key points here are the following: first, we change the return code by returning FLT_PREOP_COMPLETE.  This means that we will not send the request down the driver stack, as, for example, we would do when calling IoCompleteRequest () from the ‚Äútraditional‚Äù driver without calling IoCallDriver ().  Second, we fill in the IoStatus field in the request structure.  Set the error code STATUS_ACCESS_DENIED and the Information field "to zero".  As a rule, the number of bytes sent during the operation is recorded in the Information field, for example, the number of bytes copied is recorded during the copy operation. <br><br>  If we want to redirect the operation, it looks different: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reply.bSupersedeFile) { <span class="hljs-comment"><span class="hljs-comment">//    //   : \Device\HardDiskVolume1\Windows\File, //  \DosDevices\C:\Windows\File OR \??\C:\Windows\File  C:\Windows\File RtlZeroMemory(wszTemp,MAX_STRING*sizeof(WCHAR)); // \Device\HardDiskvol\file  \DosDevice\C:\file int endIndex = 0; int nSlash = 0; //    int len = wcslen(reply.wsFileName); while (nSlash &lt; 3 ) { if (endIndex == len ) break; if (reply.wsFileName[endIndex]==L'\\') nSlash++; endIndex++; } endIndex--; if (nSlash != 3) return FLT_PREOP_SUCCESS_NO_CALLBACK; //     WCHAR savedch = reply.wsFileName[endIndex]; reply.wsFileName[endIndex] = UNICODE_NULL; RtlInitUnicodeString(&amp;uniFileName,reply.wsFileName); HANDLE h; PFILE_OBJECT pFileObject; reply.wsFileName[endIndex] = savedch; NTSTATUS Status = RtlStringCchCopyW(wszTemp,MAX_STRING,reply.wsFileName + endIndex ); RtlInitUnicodeString(&amp;uniFileName,wszTemp); Status = IoReplaceFileObjectName(Data-&gt;Iopb-&gt;TargetFileObject, reply.wsFileName, wcslen(reply.wsFileName)*sizeof(wchar_t)); Data-&gt;IoStatus.Status = STATUS_REPARSE; Data-&gt;IoStatus.Information = IO_REPARSE; FltSetCallbackDataDirty(Data); return FLT_PREOP_COMPLETE; }</span></span></code> </pre><br>  The key here is the call to IoReplaceFileObjectName <br><br><pre> <code class="cpp hljs"> Status = IoReplaceFileObjectName(Data-&gt;Iopb-&gt;TargetFileObject, reply.wsFileName, wcslen(reply.wsFileName)*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>));</code> </pre><br>  This function changes the file name of the transferred file object (FILE_OBJECT) ‚Äîthe I / O manager object, which is an open file.  The manual name is replaced as follows: after freeing up the memory with the field containing the name, we allocate a buffer and copy the new name there.  But since the appearance of the IoReplaceFileObjectName function in Windows 7, it is strongly recommended to be used instead of a buffer.  In the author's personal project (Cybergenic Shade Sandbox product), which is compatible with all operating systems - from XP to Windows 10, I‚Äôm just manually managing buffers if the driver works on outdated OSs (up to Win 7).  After the file name is changed, we fill in the data with the special status STATUS_REPARSE, and fill the Information field with the value IO_REPARSE.  Next, we return the status FLT_PREOP_COMPLETE.  REPARSE means that we want the I / O manager to restart the original request (with new parameters), as in the case when the application (the initiator of the request) initially asked to open a file with a new name.  We also need to call FltSetCallbackDataDirty () - this API function is needed every time we change the data structure, except when we also change IoStatus.  In fact, we are really changing IoStatus here, so we call this function to make sure that the I / O manager has been notified of these changes. <br><br><h3>  Sandbox Example: Name Providers </h3><br>  As we change the file names, our driver must contain the implementation of the name provider handlers that are called when the file name is requested or when the file name is "normalized".  These handlers are FSGenerateFileNameCallback and FSNormalizeNameComponentCallback (Ex). <br><br>  Our virtualization method is based on the ‚Äúrestarting‚Äù of the IRP_MJ_CREATE request (we pretend that the virtualized names are REPARSE_POINTS), and the implementation of these handlers is a fairly simple matter, which is described in detail <a href="http://fsfilters.blogspot.ru/2011/03/names-in-minifilters-implementing-name.html">here</a> . <br><br><h3>  User Mode Service </h3><br>  User mode is in the filewall project (see the source code for the article) and communicates with the driver.  Key functionality is represented by the following function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CService::FS_Emulate( MINFILTER_NOTIFICATION* pNotification, MINFILTER_REPLY* pReply, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CRule&amp; rule) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    // ,   ,   - / if(IsSandboxedFile(ToDos(pNotificationÔÉ†wsFileName).c_str(),rule.SandBoxRoot)) { pReply-&gt;bSupersedeFile = FALSE; pReply-&gt;bAllow = TRUE; return true; } wchar_t* originalPath = pNotification-&gt;wsFileName; //   int iLen = GetNativeDeviceNameLen(originalPath); wstring relativePath; for (int i = iLen ; i &lt; wcslen(originalPath); i++) relativePath += originalPath[i]; wstring substitutedPath = ToNative(rule.SandBoxRoot) + relativePath; if (PathFileExists(ToDos(originalPath).c_str())) { if (PathIsDirectory(ToDos(originalPath).c_str()) ) { //   ‚Äì     CreateComplexDirectory(ToDos(substitutedPath).c_str() ); } else { //    ‚Äì      (sandbox),     wstring path = ToDos(substitutedPath); wchar_t* pFileName = PathFindFileName(path.c_str()); int iFilePos = pFileName - path.c_str(); wstring Dir; for (int i = 0; i&lt; iFilePos-1; i++) Dir = Dir + path[i]; CreateComplexDirectory(ToDos(Dir).c_str()); CopyFile(ToDos(originalPath).c_str(),path.c_str(),TRUE); } } else { //   ,     ,    wstring path = ToDos(substitutedPath); wchar_t* pFileName = PathFindFileName(path.c_str()); int iFilePos = pFileName - path.c_str(); wstring Dir; for (int i = 0; i&lt; iFilePos-1; i++) Dir = Dir + path[i]; CreateComplexDirectory(ToDos(Dir).c_str()); } wcscpy(pReply-&gt;wsFileName,substitutedPath.c_str()); pReply-&gt;bSupersedeFile = TRUE; pReply-&gt;bAllow = TRUE; return true; }</span></span></code> </pre><br>  It is called when the driver decides to redirect the file name.  The algorithm here is very simple: if the file placed in the sandbox already exists, the request is simply redirected by filling the variable pReply with the new file name ‚Äî the name in the sandbox folder.  If such a file does not exist, the original file is copied and only after that the original request is changed to point to the new copied file.  How does the service know that the request needs to be redirected for a specific process?  This is done using rules ‚Äî see the implementation of the CRule class.  Rules (usually the only rule in our demo service) are loaded with the LoadRules () function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CService::LoadRules() { CRule rule; ZeroMemory(&amp;rule, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(rule)); rule.dwAction = emulate; wcscpy(rule.ImageName,<span class="hljs-string"><span class="hljs-string">L"cmd.exe"</span></span>); rule.GenericNotification.iComponent = COM_FILE; rule.GenericNotification.Operation = CREATE; wcscpy(rule.GenericNotification.wsFileName,<span class="hljs-string"><span class="hljs-string">L"\\Device\\Harddisk*\\*.txt"</span></span>); wcscpy(rule.SandBoxRoot,<span class="hljs-string"><span class="hljs-string">L"C:\\Sandbox"</span></span>); GetRuleManager()-&gt;AddRule(rule); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  This function creates a rule for the process (or processes) called ‚Äúcmd.exe‚Äù and redirects all operations with * .txt files to the sandbox.  If you run cmd.exe on the PC where our service is running, it isolates your operations in the sandbox.  For example, you can create a txt file from cmd.exe, say, by running the ‚Äúdir&gt; files.txt‚Äù command, files.txt will be created in C: /sandbox//files.txt, where is the current directory for cmd.exe.  If you add an existing file from cmd.exe, you will get two copies of it - the unchanged version in the original file system and modified in C: / Sandbox. <br><br><h3>  Conclusion </h3><br>  In this article we covered the main aspects of creating a sandbox.  However, some of the details and problems remained unaffected. <br><br>  For example, you cannot control the rules from user mode, as this significantly slows down the PC.  This approach is quite simple in terms of implementation and is possible for use in educational purposes, but in no case should not be used in commercial software. <br><br>  Another limitation is the structure of notifications / responses with predefined buffers for file names.  These buffers have two drawbacks: first, their size is limited and some files deep in the file system will be processed incorrectly.  Secondly, a substantial part of the kernel-mode memory allocated for the file name is not used in most cases.  Thus, a more reasonable strategy for memory allocation in commercial software should be applied. <br><br>  Another disadvantage is the widespread use of the FltSendMessage () function, which is rather slow.  It should be used only when the user-mode application must show the user a request, and the user must allow or reject the operation.  In this case, this function can be used, since interaction with a person is much slower than the execution of any code.  But if the program responds automatically, you should avoid excessive interaction with the user mode code. <br><br><h3>  References to sources </h3><br>  ¬ª <a href="http://www.codeproject.com/Articles/1008420/How-to-make-your-own-sandbox-Simple-sandbox-explai">Original article</a> <br>  ¬ª <a href="https://github.com/coddie83/tyny_sandbox/">Source code of the sandbox in question</a> </div><p>Source: <a href="https://habr.com/ru/post/318026/">https://habr.com/ru/post/318026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318016/index.html">Consumer psychology - free book and lecture with HSE</a></li>
<li><a href="../318018/index.html">Entertaining tasks and an excerpt from the book "Career Programmer"</a></li>
<li><a href="../318020/index.html">How not to write too much. No magic</a></li>
<li><a href="../318022/index.html">Calendar functions in MySQL and MariaDB</a></li>
<li><a href="../318024/index.html">Interface designer on Habr√© - the results of my first year</a></li>
<li><a href="../318028/index.html">Lord of Wi-Fi: Aruba ClearPass</a></li>
<li><a href="../318030/index.html">New Year's Release SBM 11.2</a></li>
<li><a href="../318032/index.html">Agile in work with outsourcing</a></li>
<li><a href="../318034/index.html">Native advertising: How much it costs, where it is located, what result</a></li>
<li><a href="../318038/index.html">A systematic approach to improving the efficiency of a working web project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>