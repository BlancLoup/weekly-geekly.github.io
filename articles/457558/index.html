<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing EvilParcel Vulnerabilities</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In mid-April, we published a news about the Android.InfectionAds.1 Trojan, which exploited several critical vulnerabilities in the Andr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing EvilParcel Vulnerabilities</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  In mid-April, we <a href="https://news.drweb.ru/show/%3Fi%3D13108">published a news</a> about the <b>Android.InfectionAds.1</b> Trojan, which exploited several critical vulnerabilities in the Android OS.  One of them - CVE-2017-13156 (also known as <a href="https://vms.drweb.ru/vuln/%3Fi%3D11731">Janus</a> ) - allows malware to infect APK files without damaging their digital signature. <br><br>  The other is CVE-2017-13315.  It gives the Trojan extended privileges, and it can independently install and uninstall applications.  A detailed analysis of <b>Android.InfectionAds.1 is</b> available in our virus library, it can be found <a href="https://vms.drweb.ru/virus/%3Fi%3D17750684%26amp%3Blng%3Dru">here</a> .  We will dwell on the vulnerability CVE-2017-13315 and see what it is. <br><a name="habracut"></a><br>  CVE-2017-13315 belongs to the group of vulnerabilities that have been named EvilParcel.  They are found in various system classes of the Android OS.  Due to errors in the latter in the exchange of data between applications and the system, it becomes possible to substitute this data.  Malicious programs that exploit the vulnerabilities of EvilParcel receive higher privileges and can do the following with their help: <br><br><ul><li>  install and remove applications with any permissions without user confirmation; </li><li>  when used in conjunction with other vulnerabilities, infect programs installed on the device and replace "clean" originals with infected copies; </li><li>  reset the lock screen code of the Android device; </li><li>  reset PIN lock screen Android device. </li></ul><br>  At the moment, there are 7 known vulnerabilities of this type: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  CVE-2017-0806 (error in the class GateKeeperResponse), published in October 2017; </li><li>  CVE-2017-13286 (error in the class OutputConfiguration, published in April 2018; </li><li>  CVE-2017-13287 (error in class VerifyCredentialResponse), published April 2018; </li><li>  CVE-2017-13288 (error in the PeriodicAdvertizingReport class), published in April 2018; </li><li>  CVE-2017-13289 (an error in the ParcelableRttResults class) published in April 2018; </li><li>  CVE-2017-13311 (error in the SparseMappingTable class), published May 2018; </li><li>  CVE-2017-13315 (error in class DcParamObject), published May 2018 </li></ul><br>  All of them threaten devices running Android OS 5.0 - 8.1, on which the May security update of 2018 and later is not installed. <br><br><h3>  Prerequisites for EvilParcel Vulnerabilities </h3><br>  Let's see how EvilParcel vulnerabilities arise.  First of all, consider some features of the Android applications.  In the Android OS, all programs interact with each other, as well as with the operating system itself, by sending and receiving objects of the Intent type.  These objects can contain an arbitrary number of key-value pairs inside an object of type Bundle. <br><br>  When passing an Intent, the Bundle object is converted (serialized) into a byte array clothed in Parcel, and when reading keys and values ‚Äã‚Äãfrom a serialized Bundle, it is automatically deserialized. <br><br>  In the Bundle, the key is the string, and the value can be almost anything.  For example, a primitive type, string, or container containing primitive types or strings.  In addition, it can be an object of type Parcelable. <br><br>  Thus, in the Bundle you can put an object of any type that implements the Parcelable interface.  For this, you need to implement the writeToParcel () and createFromParcel () methods to serialize and deserialize the object. <br><br>  As a visual example, create a simple serialized Bundle.  Let's write a code that puts three key-value pairs in the Bundle and serializes it: <br><br>  Bundle demo = new Bundle (); <br>  demo.putString ("String", "Hello, World!"); <br>  demo.putInt ("Integer", 42); <br>  demo.putByteArray ("ByteArray", new byte [] {1, 2, 3, 4, 5, 6, 7, 8}); <br>  Parcel parcel = Parcel.obtain (); <br>  parcel.writeBundle (demo); <br><br>  After executing this code, we get the following Bundle: <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>Figure 1.</b> Structure of the serialized Bundle object. <br><br>  Pay attention to the following features of the Bundle serialization: <br><br><ul><li>  all key-value pairs are written one after another; </li><li>  before each value its type is indicated (13 for the byte array, 1 for the integer, 0 for the string, and so on); </li><li>  before the variable length data their size is indicated (length for the string, number of bytes for the array); </li><li>  all values ‚Äã‚Äãare written with alignment 4 bytes. </li></ul><br>  Due to the fact that all keys and values ‚Äã‚Äãin the Bundle are written sequentially, when accessing any key or value of a serialized Bundle object, the latter is deserialized completely, including initializing all Parcelable objects contained in it. <br><br>  It would seem, what could be the problem?  And it is that in some system classes that implement Parcelable, there may be errors in the createFromParcel () and writeToParcel () methods.  In these classes, the number of bytes read in the createFromParcel () method will differ from the number of bytes written in the writeToParcel () method.  If you put an object of this class inside the Bundle, the borders of the object inside the Bundle after re-serialization will change.  And it is here that the conditions are created for the exploitation of the vulnerability of EvilParcel. <br><br>  Here is an example of a class with a similar error: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  If the size of the data array is 0, then when creating an object, one int (4 bytes) will be read into createFromParcel (), and two int (8 bytes) will be written to writeToParcel ().  The first int will be written by explicitly calling writeInt.  The second int will be written when calling writeByteArray (), because the length of the parcel is always written before the array (see Figure 1). <br><br>  Situations where the size of the data array is 0, rarely occur.  But even when this happens, the program continues to work anyway, if you transmit only one object in serialized form at a time (in our example, the Demo object).  Therefore, such errors tend to go unnoticed. <br><br>  Now let's try to place a Demo object with zero length of the array in the Bundle: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>Figure 2.</b> The result of adding a zero-length Demo object to the Bundle. <br><br>  Serialize the object: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>Figure 3.</b> Bundle object after serialization. <br><br>  Let's try to deserialize it: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>Figure 4.</b> After deserializing the Bundle object. <br><br>  What is the result?  Consider the Parcel fragment: <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>Figure 5.</b> Parcel structure after Bundle de-serialization. <br><br>  From Figures 4 and 5, we see that during deserialization in the createFromParcel method, one int was read instead of two previously written.  Therefore, all subsequent values ‚Äã‚Äãfrom the Bundle were read incorrectly.  The value 0x0 at address 0x60 was read as the length of the next key.  And the value 0x1 at address 0x64 was read as a key.  The value 0x31 at address 0x68 was read as a value type.  In Parcel there are no values ‚Äã‚Äãwhose type is 0x31, therefore readFromParcel () faithfully reported an error (exception). <br><br>  How can this be used in practice and become a vulnerability?  Let's get a look!  The error described above in the Parcelable system classes allows the construction of a Bundle, which may differ during the first and repeated deserializations.  To demonstrate this, modify the previous example: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  This code creates a serialized Bundle that contains the vulnerable class.  Let's look at the result of executing this code: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>Figure 6.</b> Build a Bundle with a vulnerable class. <br><br>  After the first deserialization, this Bundle will contain the following keys: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>Figure 7.</b> The result of deserializing a Bundle with a vulnerable class. <br><br>  Now we will serialize the received Bundle again, then deserialize it again and look at the list of keys: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>Figure 8.</b> Result of re-serialization and deserialization of the Bundle with the vulnerable class. <br><br>  What do we see?  In the Bundle appeared key hidden (with the string value "Hi there!"), Which was not there before.  Consider the Parcel fragment of this Bundle to see why this happened: <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>Figure 9.</b> Parcel structure of the Bundle object with a vulnerable class after two cycles of serialization-deserialization. <br><br>  This is where EvilParcel‚Äôs vulnerabilities become clearer.  It is possible to create a specially crafted Bundle that will contain the vulnerable class.  Changing the boundaries of such a class will allow placing any object in this Bundle - for example, Intent, which will appear in the Bundle only after the second deserialization.  This will give the opportunity to hide Intent from the operating system protection mechanisms. <br><br><h3>  EvilParcel operation </h3><br>  Android.InfectionAds.1 using CVE-2017-13315 independently installed and removed programs without the intervention of the owner of the infected device.  But how does this happen? <br><br>  In 2013, an error <a href="https://android.googlesource.com/platform/frameworks/base/%2B/5bab9da">7699048</a> , also known as Launch AnyWhere, was detected.  It allowed a third-party application to start arbitrary activity on behalf of the more privileged user system.  The diagram below shows the mechanism of its action: <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>Figure 10.</b> The scheme of the work error 7699048. <br><br>  Using this vulnerability, an exploit application can implement the AccountAuthenticator service, which is designed to add new accounts to the operating system.  Thanks to the error 7699048, the exploit is able to launch activity for installing, deleting, replacing applications, resetting a PIN or Pattern Lock and doing other unpleasant things. <br><br>  Google Corp. has eliminated this gap by prohibiting arbitrary activity from running AccountManager.  Now AccountManager only allows starting the activity originating from the same application.  To do this, check and match the digital signature of the program that initiated the launch of activity with the signature of the application in which the started activity is located.  It looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  It would seem that the problem has been solved, but not everything is so smooth here.  It turned out that this fix can be circumvented using the well-known vulnerability EvilParcel CVE-2017-13315!  As we already know, after fixing Launch AnyWhere, the system verifies the digital signature of the application.  If this check is successful, the Bundle is passed to IAccountManagerResponse.onResult ().  At the same time, the onResult () call occurs through the IPC mechanism, so the Bundle is serialized again.  In the implementation of onResult (), the following happens: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Next, the Bundle retrieves the intent key and the activity is started without checks.  As a result, to launch an arbitrary activity with system rights, it is enough just to construct a Bundle so that the intent field is hidden during the first deserialization, and it appears when it is repeated.  And, as we have already seen, it is this task that is performed by the EvilParcel vulnerabilities. <br><br>  At the moment, all known vulnerabilities of this type are fixed with fixes in the vulnerable Parcelable classes themselves.  However, the reappearance of vulnerable classes in the future cannot be ruled out.  The implementation of the Bundle and the mechanism for adding new accounts are still the same as before.  They still allow you to create exactly the same exploit when detecting (or the appearance of new) vulnerable classes Parcelable.  Moreover, the implementation of these classes is still done manually, and the programmer must keep track of the constant length of the serialized Parcelable object.  And this is the human factor with all that it implies.  However, let's hope that there will be as few of such errors as possible, and EvilParcel‚Äôs vulnerabilities will not bother users of Android devices. <br><br>  You can check your mobile device for EvilParcel vulnerabilities using our anti-virus <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.drweb.pro">Dr.Web Security Space</a> .  The ‚ÄúSecurity Auditor‚Äù built into it will report on the identified problems and give recommendations on how to eliminate them. </div><p>Source: <a href="https://habr.com/ru/post/457558/">https://habr.com/ru/post/457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457542/index.html">Breaking and protection of disk encryption LUKS</a></li>
<li><a href="../457546/index.html">Demo Day: why is this all and how to make it UPD + Broadcast</a></li>
<li><a href="../457548/index.html">Generation of multi-phase PWM signal on TMS320F28027</a></li>
<li><a href="../457550/index.html">What does the digital industry need to be protected from</a></li>
<li><a href="../457552/index.html">Climbers in Zafasadye. How do the promalpy on the tower Lakhta Center</a></li>
<li><a href="../45756/index.html">Who will drink today?</a></li>
<li><a href="../457560/index.html">Tokenized shares: how to become a Gett investor before the company‚Äôs IPO</a></li>
<li><a href="../457562/index.html">Ivideon Counter 3D: who, how and why to count visitors</a></li>
<li><a href="../457564/index.html">Estimating the cost of the company's IT systems</a></li>
<li><a href="../457566/index.html">The pressure is normal: why does the data center control the air overpressure?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>