<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three-dimensional visualization in simulators of rolling stock based on the OpenSceneGraph engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A little less than a year ago, a publication was published, where we talked about the training and laboratory complex (ULK) of the EL1 Lastochka elect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three-dimensional visualization in simulators of rolling stock based on the OpenSceneGraph engine</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/4h/_g/bp4h_g1ct8gq0ntec_7pe8pkan8.jpeg"></div><br><br>  A little less than a year ago, a <a href="https://habr.com/ru/post/408885/">publication</a> was published, where we talked about the training and laboratory complex (ULK) of the EL1 Lastochka electric train, developed by our university.  Then I promised that this would not be the last publication on this topic, in particular, I threatened to talk about the problems of creating three-dimensional visualization for simulators of this kind and to outline the main approaches to their solution. <br><br>  The past year has pleased us with yet another release - ULK of high-speed electric train EVS2 ‚ÄúSapsan‚Äù, which took place back in August last year.  By itself, the educational and laboratory complex of this electric train deserves a separate story, but in the context of this publication we will discuss the painful problem of creating an adequate subsystem of three-dimensional visualization, which our team has approached from different sides for about two years.  The release of the Sapsan simulator is significant (among other things) by the fact that it determined the vector of development of our developments in this area. <br><a name="habracut"></a><br><h1>  1. Briefly about ULC EVS2 ‚ÄúSapsan‚Äù </h1><br>  I want to emphasize once again (which I do with enviable periodicity) that the training and laboratory complexes of rolling stock developed at our university are not intended to train locomotive brigades.  As <a href="https://habr.com/ru/post/408885/">one of the commentators of the</a> previous article rightly <a href="https://habr.com/ru/post/408885/">noted</a> , our ULCs are not simulators, but simulators, where the main emphasis is placed on the competent implementation of the physics of train movement and modeling the operation of rolling stock subsystems ensuring its movement and stopping.  The Sapsan simulator is not an exception, where the following tasks are solved: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Implemented a dynamic model of the mechanical part of the train, taking into account the longitudinal forces and the profile of the track </li><li>  A detailed computer model of the operation of the key subsystems of an electric train has been built: a power electric circuit, a traction electric drive, pneumatic and electropneumatic brakes </li><li>  Reproduced the main algorithms of the electric train control system at different levels </li></ul><br>  In addition, the educational and laboratory complex includes a full-size model of the electric train's cabin with the main controls and information display facilities.  Unlike the Swallows simulator, this cabin was not made by us independently, but was acquired in 2015 from one of the well-known in our country offices engaged in the production of training simulators.  Therefore, in the process of developing a simulator focused on creating software. <br><br><div class="spoiler">  <b class="spoiler_title">Cab photo</b> <div class="spoiler_text">  <i>General view of the cabin interior</i> <br><img src="https://habrastorage.org/webt/ud/de/ic/uddeiczrsp23eszvl6tx6zwal7y.jpeg"><br><br>  <i>View through the windshield</i> <br><img src="https://habrastorage.org/webt/r1/nz/kn/r1nzknpyastfa6b8iy6ghp2m4ic.jpeg"><br><br>  <i>Display of the integrated locomotive safety device (CLUB-U).</i>  <i>The red ‚Äú290‚Äù is the current speed limit received from the CLUB-U e-card.</i>  <i>For the time being, the maximum speed achieved by the Sapsan on the Oktyabrskaya railway is adorning here.</i>  <i>In the future, the electronic map will be implemented as it is done in life.</i> <br><img src="https://habrastorage.org/webt/nt/on/-g/nton-ggphlulx1e0yxmznf_epnu.jpeg"><br><br>  <i>Main display "Human Machine Interface"</i> <br><img src="https://habrastorage.org/webt/xk/kd/qk/xkkdqkxqznjjkl_vx-lfbdhys4w.jpeg"><br><br>  <i>Display showing the state of the brake system of an electric train</i> <br><img src="https://habrastorage.org/webt/ap/wl/qv/apwlqvuggyfjgwd_prliwn3hjck.jpeg"><br><br>  <i>Speed ‚Äã‚Äãadjuster and traction controller</i> <br><img src="https://habrastorage.org/webt/u3/ok/nb/u3oknbv0nitjk-d7fcpqmywhxr4.jpeg"><br><br>  <i>Electric Train Brake Controller</i> <br><img src="https://habrastorage.org/webt/6k/mf/eg/6kmfegwxufy_317kqfvmp7n00k8.jpeg"><br><br>  <i>Toggle switches for control of current collectors and protection devices (BV / GV) - black toggle switches near the speed limiter</i> <br><img src="https://habrastorage.org/webt/dn/gs/3p/dngs3pxzgoqcawtdewf84z8squc.jpeg"><br><br>  <i>Workout Management Interface - Route Selection Screen</i> <br><img src="https://habrastorage.org/webt/_n/sh/jp/_nshjpyo8nu8wbxalcfhtfowns0.jpeg"><br><br>  <i>Audio Effects Volume Control Screen</i> <br><img src="https://habrastorage.org/webt/ba/ll/p_/ballp_v52zh8rmq4iosfkicienw.jpeg"><br><br>  <i>Mileage counter.</i>  <i>A funny story is connected with his appearance.</i>  <i>When we handed over our first diesel locomotive simulator 2TE116, to our question when the certificate of completion would be signed, the customer‚Äôs representative joked: ‚ÄúWell, let's do it in life - when entering a new locomotive into operation, it must pass 5,000 km.</i>  <i>That will pass ... ".</i>  <i>The act of course was signed much earlier, but we, having assessed the humor of the situation, made a similar counter already on the Swallows simulator.</i>  <i>The counter can be reset to ‚Äú0‚Äù by entering the service password.</i> <br><img src="https://habrastorage.org/webt/yo/hc/jq/yohcjqcfhoe8irnm6j3ynr9exby.jpeg"><br><br>  <i>Right auxiliary panel with control gauges brake system and emergency brake valve.</i>  <i>Not all the elements inherent in the present Sapsan are installed here - we received such a remote control from the supplier.</i> <br><img src="https://habrastorage.org/webt/fr/te/5l/frte5lrezbuss2ng2iesdqcl0p8.jpeg"><br><br>  <i>Therefore, some of the critical for us controls were implemented by software, in particular, the panel of bypass switches, controlled from the touch display</i> <br><img src="https://habrastorage.org/webt/he/c2/ga/hec2gahq08cziegrxl1qfkriqya.png"><br></div></div><br>  Software development of such a simulator simulator is a very broad question, and I will try (to the best of reason) to satisfy readers' interest in these issues in the future (if any), but for now, let us return to the main topic of the article - three-dimensional visualization of the train movement process. <br><br><h1>  2. Background and technology of the past </h1><br>  In the comments to the previous article <a href="https://habr.com/ru/post/408885/">, a question was asked</a> which, I confess honestly, pretty much amused me.  Yes, indeed, in many simulators still in operation today, the following approach is still used: video is shot on the real section of the railway and then scrolls on the simulator at a speed proportional to the speed of movement.  They did this only because in those early times, when such simulators were created, the quality of three-dimensional graphics left much to be desired, and this applied to harsh graphic stations on commercial Unixes, and the PC was out of the question.  Therefore, even manufacturers of computer games, for example <a href="https://ru.wikipedia.org/wiki/Journeyman_Project">, this one</a> , did not disdain to use this approach. <br><br>  Today it does not make sense, because: <br><br><ol><li>  Insufficient frame rate at low train speeds does not provide the desired smoothness of updating the picture.  The cherished 25 fps we will have only at the speed at which the video from the driver‚Äôs cab was filmed.  And this fatal flaw cannot be overcome - either by shooting with a high-speed camera (how much will the video shot at 120 frames per second weigh? That's the same ...), or by software generation of intermediate frames.  The latter was undertaken by us using the OpenCV technology, but did not lead to normal results.  This question was repeatedly worked out from all sides and as a result it was concluded that the costs of creating such a system far exceed the development of a similar system, but based on 3D graphics </li><li>  Difficulties with smooth scrolling video back.  And even considering that they will be overcome, then where the dogs running along the platform will run, can we even think about going backwards? </li><li> The lack of all "interactivity".  How to deal with a change in the signal of a traffic light, with the movement of turnouts, the movement of oncoming and passing trains? </li></ol><br>  Therefore, all modern simulators and simulators are created using interactive 3D-graphics, the benefit today there are no obstacles either from a software or from a hardware point of view. <br><br>  If from a hardware point of view, everything is extremely clear - a monitor installed instead of a windshield is connected to a PC with a normal video card (not even the top one), then from a software point of view it is a question of choosing a technology to implement the task. <br><br><h1>  3. Graphics engine versus game engine or why OpenSceneGraph was chosen </h1><br>  I can be mistaken, but I anticipate comments in advance, in which a completely logical question will be asked, why didn‚Äôt our choice analyze such mastodons like Unity or Unreal Engine 4 when analyzing existing technologies?  I will answer this question, moreover, I substantiate my answer. <br><br>  In short, neither Unity nor the Unreal Engine satisfies the requirements of the problem to be solved.  A more detailed answer provides, first of all, the enumeration of the requirements in question.  The TK compiled by us for the three-dimensional visualization subsystem includes (in decreasing order of importance) the following provisions: <br><br><ol><li>  The independence of the software development process of the visualization subsystem and the process of creating resources for it.  Resources, in this case, include three-dimensional models, textures, as well as the so-called <i>routes</i> .  A route is a set of configuration objects and resources that allow a video subsystem to display the desired section of the railway and provide a simulation of train movement on it.  This also includes the <i>possibility of changing the route without rebuilding the software part of the video subsystem.</i> </li><li>  Creating routes of unlimited length.  I will make a reservation that unlimited length is in principle unattainable due to limited hardware resources.  This requirement should be understood that the length of the route should be at least within one ‚Äúshoulder‚Äù, that is, the section of the road between revolving points, and this, depending on various factors, is a sufficiently large distance, calculated by more than one hundred kilometers.  This requirement imposes the need to provide dynamic loading / unloading of program resources with sufficient smoothness with reasonable memory consumption.  And it is desirable that the engine contains such functionality "out of the box" </li><li>  Convenient integration with used technology stack.  Traditionally, due to objective reasons, our team uses C ++ language with Qt framework, IDT QtCreator, and Git as the version control system.  As a system platform, ULK PS uses the OS based on the Linux kernel. </li></ol><br>  What is wrong with Unity and UE?  What is the fact that the other engines are able to import resources of completely different formats.  However, when assembling a project, they are irreversibly transformed into an internal binary format, which makes it impossible to add and change resources without re-assembling the project.  Technologies like prefabs and asset bundles available in Unity do not solve the problem, as the engine editor is not the best place to create railway locations, which is why the need for an editor extension arises, which leads to the need to write ‚Äúengine inside the engine‚Äù.  In addition, the creation of prefabs and bundles is impossible without the use of the Unity editor, and this, as practice has shown, is not very convenient, especially for pure modelers and level designers.  As for the UE, and in this and other resources for two years I asked enough questions about how to separate the project build process from the process of adding / changing the resources used by it, and I did not receive an adequate answer either in the documentation or from hardened "gamedevelopers.  I would be very happy (without sarcasm) if I reasonably stumble with my nose into something that I missed. <br><br>  As for the second requirement, both Unity and UE seem to provide the ability to create dynamically loaded locations, but the question remains: how can such locations be created independently of the editor without rebuilding the project?  Only one way out - to write a ‚Äúengine inside the engine‚Äù, which will load the ‚Äúraw‚Äù (in any of the predefined export format from 3D editors) geometry and textures, apply all the necessary effects to them and position in space based on the data described in the external A format independent of the engine that needs to be further developed and taught the engine to interpret it. <br><br>  In connection with the above, the question arises - if to solve the problem it is necessary to write a powerful software layer over the game engine, most of the functionality of which is simply not needed in the task in question, then why do we need a game engine? <br><br>  Maybe enough graphics engine?  I asked this question to the previous team, which took up the problem under discussion, relying on Unity (and naturally merged a bit later).  In response, I received a counter question: ‚ÄúWhat do you propose?‚Äù, Answering which, in the spirit of the above text, received an opponent‚Äôs sarcastic smile. <br><br>  If we do without sarcasm, then the presented task is a typical visualization task - here only a framework for working with graphics is required, since both physics and audio subsystem, based on physics, are implemented on the server side.  My team and I came to understand this fact, moving by the inertia of previous developers, first towards Unity, through the UE and trying to fasten the graphics subsystem from the open railway simulators (OpenBVE, which by the way turned out, but became a temporary crutch) <br><br>  <a href="http://www.openscenegraph.org/">OpenSceneGraph</a> is by far the most advanced (open and free) graphics engine, focused on C ++ development.  It is widely used abroad for technical three-dimensional visualization.  This engine is not spared, and all sorts of simulator, the most famous of which - <a href="http://home.flightgear.org/">FlightGear</a> .  There was once a railway simulator based on this engine - <a href="http://openscenegraph.sourceforge.net/screenshots/Indra/">Indra</a> , from which, however, there were only dull screenshots of the above link and its further fate is unknown to me. <br><br>  In the context of the problem being solved, the OSG graphics engine has the following positive qualities: <br><br><ul><li>  Cross-platform, which makes it possible to apply it in the GNU / Linux ecosystem </li><li>  The C ++ / STL development language, which makes it easy and natural to integrate it into the development process established in our team; </li><li>  The widest range of supported out of the box resource formats - 3D geometry and textures due to an advanced plugin system.  A simple and intuitive interface for writing your own plug-ins to configure the resource manager for non-standard formats, which we used (I will write about this below); </li><li>  A memory management system based on a proprietary model of smart pointers (the proprietary format of smart pointers has been used historically, due to the fact that there was no smart pointer in the C ++ standard at the beginning of the development of the engine); </li><li>  Flexible modular architecture; </li><li>  The scene object manager, which dynamically loads objects, provides for loading and drawing only those objects that fall within the clipping pyramid (due to the class osg :: PagedLOD) </li><li>  Ability to integrate with the Qt framework.  Thanks to the convenient ‚Äúsignals-slots‚Äù model provided by Qt, which significantly simplifies and accelerates development in C ++, we widely use this framework for developing software for training complexes.  Accordingly, we have accumulated a significant code base reused in various projects, especially with regard to the interprocess communication library based on TCP sockets.  Using Qt features in the video subsystem project seems to be a logical decision; </li><li>  Quality of a picture, sufficient for the solved task. </li></ul><br>  It took about six months of intense study of the possibilities of OSG in order to thoroughly "test the ground" and find approaches to solving the problem with the help of this engine.  What was born as a result deserves a separate discussion. <br><br><h1>  4. From architecture to working prototype </h1><br>  The video subsystem of the rolling stock simulators (HTSC) is a client application, commonly referred to as video3d-client, and performs the following functions: <br><br><ul><li>  A request to connect to the server part of the simulator, authorization on the server with a subsequent periodic request for the identifier of the loaded route, and then the current train position.  When the connection is broken by the server, the transition to the standby mode, the possibility of reconnecting </li><li>  Loading the selected route; organizing dynamic management of the contents of the rendered scene; </li><li>  Actually rendering the scene in accordance with the current position of the train on the route </li></ul><br>  Not that this project was opensource, but it is quite possible to get acquainted with the code of a full-featured technology demo <a href="https://github.com/maisvendoo/video3d-client">here</a> .  The project consists of the following modules: <br><br><ul><li>  <i>filesystem</i> - a library for working with the file system; it provides the generation of paths to configuration files and application resources </li><li>  <i>library</i> - cross-platform implementation of a dynamic library loader.  In general, a crutch written at a time when the possibilities of integration with Qt (where there is a QLibrary module ready for battle) were still vague </li><li>  <i>osgdb_dmd</i> - plugin for loading models of a format specific for the DGLEngine engine version 1.1.  What it took, I will explain below </li><li>  <i>route-loader</i> is a library that provides an abstract interface to the route loader.  The possibility of loading routes of arbitrary format is assumed. </li><li>  <i>tcp-connection</i> - interprocess communication library via TCP sockets </li><li>  <i>viewer</i> - the main executable module of the program </li><li>  <i>zds-route-loader</i> - plugin for downloading ZDSimulator format routes </li></ul><br>  When designing VTPS, the question of choice arose: to develop the format of routes independently, or use the existing format of routes, as well as ready-made routes of domestic railways for the existing railway simulator.  Fortunately, the decision turned up - a closed proprietary product <a href="https://zdsimulator.com.ua/">ZDSimulator</a> , which has the peculiarity that it is sharpened by domestic rolling stock and the specifics of the railway network.  Despite the boast of the authors of the project, it has a lot of significant drawbacks, but it also has a simple and clear format of routes that are publicly available.  At the first stage, it was a sin not to use the available opportunity, despite the fact that the graphic part of the simulator is based on the open engine DGLEngine.  The trouble is that this engine is developing (though the current state of the project <a href="https://github.com/DGLE-HQ/DGLE">can be seen here</a> ), but its current second version is incompatible with version 1.1, on which the ZDSimulator is based.  The source code of version 1.1 has been lost, the links leading to them have long been rotten. <br><br>  A thorough search in the web archive made it possible to find the lost and save by posting <a href="https://github.com/maisvendoo/DGLEngine">DGLEngine v1.1</a> on Gtihub.  This engine uses its own specific format of 3D models.  Having the source of the engine it was not difficult to write the appropriate plugin for OSG. <br><br>  Thus, the task of creating the VTPS has been reduced to writing the program part on the OSG engine.  In the future, it is planned to develop a proprietary route format, since the current format provides for movement only along the main routes and has several disadvantages that do not allow recreating a number of complex routes. <br><br>  The hierarchy of the main classes of HTSC is presented in the following diagram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/2l/sx/592lsx2l9c4ktp7q9j__9mqu3ic.png"></div><br>  The class hierarchy of route loader looks like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/yw/lb/dlywlbrbkjuzxgl_3whfakiv11q.png"></div><br>  The loader of any other route format can be written as a plugin containing a class that inherits from the RouteLoader class.  When the VTPS starts, it receives the path to the directory with the route, determines the format of the route, and dynamically loads the corresponding plug-in that performs the rest of the dirty work. <br><br>  A fundamentally important nuance was the integration of the OSG engine and Qt.  This integration exists and is called <a href="https://github.com/openscenegraph/osgQt">osgQt</a> .  This library is not used in this project for two reasons: <br><br><ol><li>  No need for window controls provided by Qt.  OSG has its own fairly well-developed GUI window management system and it makes no sense to build a GUI on top of another GUI, since osgQt is intended primarily for integrating the OSG viewer into a GUI based on Qt </li><li>  osgQt is bug-prone - incorrect work with the OpenGL context, which in some cases it cannot divide between OSG and QGLWidget, because of which the scene is displayed anywhere, just not on the Qt widget.  Moreover, it has not been possible to find reasons yet, since on some systems this bug does not manifest itself. </li></ol><br>  There was an understanding that integration with Qt is necessary in terms of using the ‚Äúsignals-slots‚Äù concept to ensure interoperability with the tcp-connection network subsystem that uses Qt and is the de facto standard in our developments.  I didn‚Äôt want to rely on the OSG messaging system and re-write a TCP client (and even a cross-platform one).  There was an elegant solution based on the fact that if we want one object to send a signal that triggers a slot to activate from another object, we must fulfill three conditions: <br><br><ol><li>  Inherit QObject Interactive Classes </li><li>  Arrange a signal processing loop </li><li>  Create an instance of the QApplication class (or QCoreApplication) that exists in memory during the operation of the application </li></ol><br>  In this case, by no means should you make a call to QApplication :: exec (), which starts a regular signal processing cycle, it is enough to organize a cycle in which you simply process the signals with a call to QApplication :: processEvents ().  In OSG, such a cycle exists (the cycle in which rendering is performed) and it is possible to create an event handler in which the event osgGA :: GUIEventAdapter :: FRAME is processed, which is generated by the engine when rendering the next frame.  Thus, the whole integration has been reduced to code <br><br>  <b>qt-events.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QtCore/QtCore&gt; class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(){} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br><br>  <b>qt-events.cpp</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); break; } default: break; } return false; }</span></span></code> </pre><br>  <b>main.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! * \fn * \brief Entry point */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); RouteViewer viewer(argc, argv); if (viewer.isReady()) return viewer.run(); return 0; }</span></span></span></span></code> </pre><br>  after that, classes inherited from QObject and its derivatives can exchange signals before the loss of pulse. <br><br>  All of the above allowed in two months to create the first working prototype of the VTTS.  To demonstrate what happened in the end, I propose the following thread from experienced trips along real routes.  I apologize in advance for the quality of the shooting - they did not get hold of a sensible technique. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CENZVOC2ZxE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Conclusion and conclusions </h1><br>  The main conclusion, at least for our team, was that the ‚Äúseryabryannoy bullet‚Äù does not exist in the choice of technology for the implementation of the project.  Game engines aggressively promoted to the market are not always suitable for solving specific tasks, such as the visualization of simulation results of technical systems.  And if they are suitable, they are not optimal in terms of the effort spent on developing and supporting the project. <br><br>  It's a shame that a very good, and most importantly free, OSG graphics engine in fact does not have a community in our country.  In order to fix this problem, I write a <a href="https://habr.com/ru/post/429816/">series of articles here on the resource</a> (there I collected all the links to more or less adequate sources of information, including in Russian).  In addition, as a documentation describing the basic principles of OSG I can offer <a href="https://maisvendoo.github.io/">this blog as well</a> .  I hope that this information will be useful to someone. <br><br>  As for the VTPS, the work in this direction continues.  The next step is still a lot of important tasks to be solved in the near future. <br><br>  Thank you for attention! <br><br>  <a href="https://vk.com/crikrgups">() Center for Development of Innovative Competences of RSTU</a> </div><p>Source: <a href="https://habr.com/ru/post/436276/">https://habr.com/ru/post/436276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435968/index.html">An overview of deep machine learning algorithms for robots</a></li>
<li><a href="../435970/index.html">Beginner's Guide to Web Server Development with Node.js</a></li>
<li><a href="../435972/index.html">Introduction to reactive programming in Spring</a></li>
<li><a href="../435974/index.html">Three.js - make controls for space or planetarium</a></li>
<li><a href="../435976/index.html">WebAssembly in production and ‚Äúminefield‚Äù Smart TV: interview with Andrei Nagikh</a></li>
<li><a href="../436374/index.html">Trends in the design of UI and UX 2019</a></li>
<li><a href="../437996/index.html">SITIS CTF: how a seal helped CTF win</a></li>
<li><a href="../440462/index.html">Top 7 content marketing strategies not to be missed in 2019</a></li>
<li><a href="../441114/index.html">Relational programming: pain, interest, and pain again</a></li>
<li><a href="../441116/index.html">KubeSail and its free Kubernetes-cluster for developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>