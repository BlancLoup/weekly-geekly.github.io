<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods of designing databases in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Working as an Android developer, I had to deal with two different approaches to database design in mobile applications. Perhaps someone stated here se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods of designing databases in Android</h1><div class="post__text post__text-html js-mediator-article">  Working as an Android developer, I had to deal with two different approaches to database design in mobile applications.  Perhaps someone stated here seems obvious, but maybe someone will give a new idea or save from errors.  In general, without a long introduction go to the case ... <br><br><h4>  Two looks at the problem </h4><br>  As you know, universities teach you to build databases according to all the rules: decompose the subject area into entities, select attributes and identify primary keys, define relationships between entities, bring it all to at least 3 normal forms, etc.  One of the ‚Äúside effects‚Äù of this approach is a drop in performance on read operations, with a rather strong decomposition and normalization, since in queries you need to perform a greater number of joins.  And the more entries you have in the tables, the longer they take. <br><br>  Add here the very limited hardware capabilities of mobile platforms, in particular a tiny amount of RAM.  Its already small, so in addition to this, Android limits the amount of available RAM per process, depending on the OS version from 16 to 48 MB.  And even from these several megabytes, the DBMS gets only a part, because there is also the application itself.  And finally, SQLite itself, because of its peculiarities, supports only two levels of transaction isolation.  They are either serialized or disabled altogether! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In a situation where application performance begins to rest on the performance of the DBMS to the rescue and an alternative approach can come, let's call it key-value oriented.  Instead of decomposing an entity into attributes and creating separate fields in the table into each attribute, the entity is stored ‚Äúas is‚Äù into one single BLOB type field, in other words, it is serialized. <br><a name="habracut"></a><br>  Consider an example for clarity.  Let our data model in Java code look like this: <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Group</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long _id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String number; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Student&gt; students; <span class="hljs-comment"><span class="hljs-comment">// getters and setters ... } class Student { private Long _id; private String name; private String surname; private Group group; // getters and setters ... }</span></span></code> </pre> <br>  Thus, in the ‚Äústandard‚Äù version, we obtain two tables with corresponding sets of attributes. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>( _id primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> autoincrement, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> Student( _id primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> autoincrement, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, surname <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>);</code> </pre><br>  In the present project, entities and attributes are much larger, plus various utility fields are added here, such as the last synchronization date with the server or a flag flag, is the entity required to be sent to the server to update the changed data, etc. <br><br>  When applying the same key-value, the tables will look like this. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>( _id primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> autoincrement, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> Student( _id primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> autoincrement, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>);</code> </pre><br>  while groups and students are serialized separately on different tables.  Or in general like this: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>( _id primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> autoincrement, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span>);</code> </pre><br>  when the group is serialized directly with all students in one table. <br>  Consider the advantages and disadvantages of both approaches and what benefits can be derived from this. <br><br><h4>  Comparison of approaches, pros and cons </h4><br><h5>  Relational Algebra Features </h5><br>  When using the standard approach, we get all the advantages to which we are so used to using the relational approach, namely, the SQL language for convenient sampling, filtering and sorting data, as well as modifying the database schema.  In order to get a collection of entities, we only need to form the required condition and take our data from the database.  In the key-value approach, the task of filtering or organizing data lies on the shoulders of the developer. <br><br><h5>  DB file size </h5><br>  When using the standard approach, the database file is usually smaller.  This is due to the lack of redundancy in data storage, due to normalization.  In theory, the higher the degree of normalization, the less redundancy, however, increases the load on the database when reading these data.  Significant resources are spent on table joins.  When using the key-value approach, the degree of data redundancy is higher, since, as a rule, the level of normalization is much lower, which leads to an increase in the size of the database file. <br><br><h5>  Flexibility when changing the database schema </h5><br>  Usually, with the development of the project, the database schema is transformed more than once, new fields are added, previously used entities are deleted, the entities can be split up into several new ones, or vice versa, they are denormalized and several tables are combined into one.  If, when updating the scheme, we can donate the data accumulated in the database, then everything is simple: we create a new database file every time we update the scheme, and delete the old one.  But what if the data should be saved and converted to a new format? <br>  In this embodiment, the standard approach has advantages.  It is enough to write the corresponding update scripts that convert the database schema to the required form and update the new fields with default values ‚Äã‚Äãor calculate them using one or another logic.  When using serialization, updating the database schema is no longer such an easy task.  It is necessary to convert the schema with the preservation of all the data, as well as update the data itself, de-implementing them, initializing new fields and serializing them back.  Both the logical complexity of the operation and the time required for updating are increasing. <br><br><h5>  Synchronize access to entity instances </h5><br>  One of the main drawbacks of the key-value approach, it seems to me, is that in order to change just one field in essence, we need to deserialize the entire object.  This greatly complicates access to objects.  For example, in the case when a group is serialized into the database together with all students, in order to change the name of one of the students, we need to remove the entire group from the database, change one last name and save it back.  If there are several streams, services and / or content providers in the application that can work with the same entities, the task is many times more complicated.  The more potential ‚Äúwriters‚Äù, the more locks will arise and the more difficult it will be for us to synchronize access to objects.  In the case of the standard approach, this problem is solved at the DBMS level. <br><br><h5>  Performance </h5><br>  On the one hand, the key-value approach allows for higher performance when sampling small amounts of data.  The number of joins is reduced, a specific query and the DBMS as a whole works faster.  On the other hand, with large amounts of data, if we need to filter or sort these data by a field that is serialized along with the entire object, then to perform this operation, we will first need to read all the entities, and only then filter everything that is unnecessary, which can lead not to performance gain, but to its further deterioration.  Alternatively, you can store the fields involved in the request filtering or sorting standard approach, and the rest of the essence in the form BLOBa, but then this mess will be difficult to maintain. <br><br><h5>  Amount of code </h5><br>  In the standard approach, the number of SQL code, various scripts for creating and modifying the database schema, queries and conditions, DAO objects, etc., increase.  In the key-value, the amount of such a code is reduced, but the amount of code that performs various sorting, grouping and filtering by conditions increases, because all this has to be done ‚Äúmanually‚Äù, when using the standard approach the DBMS does it, and we only need to write the required query. <br><br><h5>  Serialization </h5><br>  The minus key-value of the approach may consist in a drop in performance associated with the use of standard Java serialization / deserialization, which is known not to have high speed.  Here, as an alternative, you can use one of the libraries that solve this problem, for example, protobuf from Google.  In addition to speed, an additional advantage, in the case of protobuf, is the versioning, since  This protocol supports object versioning. <br><br><h4>  Conclusion </h4><br>  It turned out a bit messy, but in general, I wanted to say: both approaches are good, you need to choose according to the situation, considering all the pros and cons listed.  As a rule, if there are no problems with performance, then it is better to use a standard approach with greater flexibility.  If these problems start to occur, try using denormalization.  Perhaps, if there are only a few critical sections in the program, this can solve everything.  If you experience permanent performance problems when denormalization does not help, you should take a closer look at the key-value approach. </div><p>Source: <a href="https://habr.com/ru/post/145442/">https://habr.com/ru/post/145442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145437/index.html">132 servers in a rack or how to pack up and not burst</a></li>
<li><a href="../145438/index.html">Bluetooth Spying - W32.Flamer Features</a></li>
<li><a href="../145439/index.html">Online conference "Growth of the mobile applications market and its development prospects"</a></li>
<li><a href="../145440/index.html">Computex 2012 - the third day</a></li>
<li><a href="../145441/index.html">The press began to give to everyone</a></li>
<li><a href="../145444/index.html">Release GlobalsDB 2012.2</a></li>
<li><a href="../145445/index.html">How to become even more mobile, or what to do if there is no 220V outlet nearby?</a></li>
<li><a href="../145446/index.html">Birds and robots. MP3 players / souvenirs</a></li>
<li><a href="../145447/index.html">Notification of new emails in Gmail via SMS using Google Calendar + Google Apps Script</a></li>
<li><a href="../145448/index.html">In the footsteps of LinkedIn safely flowed base and Last.fm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>