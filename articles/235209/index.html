<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unicode tutorial</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We finally did it! For a long time, the shameful legacy of CP1251 irritated developers, suggested that, how could that be? The Unicode era has come a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unicode tutorial</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/mailru/blog/235209/"><img src="https://habrastorage.org/files/688/ce3/73d/688ce373d4bd4d37993f6cb76b97c0fc.png"></a> <br><br>  We finally did it!  For a long time, the shameful legacy of CP1251 irritated developers, suggested that, how could that be?  The Unicode era has come a long time ago, and we still use single-byte encoding and place crutches in different places for compatibility with external systems.  But the reason for this was quite rational: to translate a large project into Unicode, into which <a href="http://my.mail.ru/">My World</a> has evolved, is very laborious.  We estimated it at half a year and were not ready to spend so many resources on a feature that does not bring significant benefits to the Russian-speaking audience. <br><br>  But the story makes its own adjustments, often quite unexpected.  It is no secret that the My World project, which is the most popular social network in this country, is very popular in Kazakhstan.  And we always wanted our Kazakh users to have the opportunity to use symbols of the Kazakh alphabet from the extended Cyrillic set, which, unfortunately, had no place in CP1251.  And an additional incentive for us, which finally allowed us to justify the long-term development, was the further growth of the project‚Äôs popularity outside our country.  We realized that it was time to take a step towards foreign users. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, the first thing that was needed to internationalize a project was to start receiving, transmitting, processing, and storing data in UTF-8.  This procedure for a large project is not easy and time consuming, along the way we had to solve some rather interesting tasks, about which we will try to tell. <br><a name="habracut"></a><br><h1>  Database recoding </h1>  The first choice we encountered was fairly standard - from which end to start: from page display or from data stores.  We decided to start with the repositories for the reason that this is the most protracted and time-consuming process, requiring coordinated actions of developers and administrators. <br><br>  The situation was further complicated by the fact that in our social network, for speed reasons, a large variety of specialized repositories are used.  Of course, not all of them contained text fields that are subject to internationalization, but still they turned out to be quite a few.  And the first thing that had to be done was to conduct a complete inventory of all our repositories for the content of text lines in them.  We have to admit that we have learned a lot of new things. <br><br><h1>  Mysql </h1>  We started converting storage into UTF-8 with MySQL.  The reason for this was that, in general, a change in the encoding of this base is supported natively.  But in practice, everything was not so simple. <br><br>  Firstly, it was necessary to carry out the conversion of the base without downtime at the time of conversion. <br><br>  Secondly, it turned out that for all the tables <i>alter table `my_table` convert to character set utf8;</i>  not rational and, moreover, impossible.  It is not rational because the index for a UTF-8-field always takes <i>3 * length_in_characters</i> bytes, even if the field contains only ASCII characters.  And we had a lot of such fields, including index fields, especially those that contained hex strings.  It is impossible due to the fact that the maximum length of the index key in MySQL is 767 bytes, and the indices (especially multi-column ones) no longer fit.  In addition, it was found that in some text fields binary data is stored by mistake and vice versa, and each field must be carefully checked. <br><br>  After we collected information about the tables there from our databases, it became clear that most of them were not used.  So it turned out as a result, we deleted about half of all the tables in them from the databases.  In order to find unused tables, we used the following technique: using tcpdump, we collected all queries to our databases in 24 hours, then crossed the list of tables from this dump with the current database schema and searched for unused tables by code (at the same time, cleaned up the code).  Tcpdump was used because, unlike writing all requests to the log using MySQL, it does not require restarting the database and does not affect the speed of processing requests.  Of course, it was scary to delete the tables right away, so at first they just renamed the tables with a special suffix, waited several weeks and then deleted (by the way, it was not for nothing that they reinsured, a couple of extra little-used ones were hooked by mistake, had to be returned). <br><br>  Then we started the actual writing of the DDL for database conversion.  For this, several standard patterns were used: <br><ul><li>  if there were no text fields in the table, then (just in case, all of a sudden we <i>‚Äôll</i> add) just executed the query: <i>alter table `my_table` default character set utf8;</i> </li><li>  If the table contains only <i>varchar</i> text fields requiring internationalization, then: <i>alter table `my_table` convert to character set utf8;</i> </li><li>  fields containing only ASCII characters converted to ASCII: <i>alter table `my_table` modify` my_column` varchar (n) character set ascii ...;</i> </li><li>  fields requiring internationalization are standard: <i>alter table `my_table` modify` my_column` varchar (n) character set utf8 ...;</i> </li><li>  but, for some fields with a unique index, because of the equality in <i>collation utf8_general_ci</i> (as opposed to <i>cp1251_general_ci</i> ) of the letter e and e, it was necessary to crutch: <i>alter table `my_table` modify` my_column` varchar (n) charater set utf8 collate utf8_bin ...;</i> </li><li>  for index fields, which, after conversion, stopped getting into the index, I also had to crutch: <i>alter table `my_table` drop index` my_index`, modify `my_column` varchar (n) character set utf8 ..., add index` my_index` (`my_column` ( m));</i>  (where <i>m &lt;n</i> , and the index, as a rule, by several fields); </li><li>  text fields containing binary data were translated into <i>binary</i> and <i>varbinary;</i> </li><li>  binary fields containing text strings in CP1251 were converted in two <i>ways</i> : <i>alter table `my_table` modify` my_column` varchar (n) character set cp1251;</i>  <i>alter table `my_table` modify` my_column` varchar (n) character set utf8</i> ;  This is necessary for the first MySQL query to understand that the data is in cp1251 encoding, and the second to convert it to utf8. </li><li>  text blobs had to be processed separately, since when <i>converting to character set utf8</i> MySQL expands the blob to the minimum necessary in order to fit the text of maximum length, all of which is three byte characters.  That is, the <i>text</i> automatically expands to <i>mediumtext</i> .  This is not exactly what we wanted in a number of cases, so we gave it explicitly: <i>alter table `my_table` alter` my_column` text character set utf8;</i> </li><li>  and, of course, for the future, the final chord: <i>alter database `my_database` default character set utf8;</i> </li></ul><br>  The task of converting the base to UTF-8 without downtime at the time of conversion was decided in the usual way: through a replica.  But not without its features.  First, in order for the strings to be automatically converted when the replica is picked up from the wizard, it is necessary that replication be sure to be in <i>statement</i> mode, and in <i>raw</i> mode it is not converted.  Secondly, to switch to <i>statement</i> replication, you also need to change the <i>transaction isolation level</i> from the default <i>repeatable read</i> to <i>read commited</i> . <br><br>  Actually converted as follows: <br><ol><li>  Switch the master to statement replication mode. </li><li>  Raise a temporary copy of the database for conversion, run the conversion on it. </li><li>  At the end of the conversion, we transfer the copy to the replica mode from the main database, the data is caught up, the strings are also converted on the fly. </li><li>  For each base replica: <br>  - we transfer the load from the replica to the temporary replica to UTF-8; <br>  - Pour all replicas from scratch from the time base, turn on replication from it; <br>  - return the load back to the replica. </li><li>  We transfer the temporary database to the master mode, transfer requests from the old master to the temporary one using NAT. </li><li>  The old master is poured from the time base, we catch up with replication. </li><li>  We switch the master back, remove the NAT, return the replication back to mixed. </li><li>  Disable temporary database. </li></ol><br>  As a result, for three months of hard work, we managed to convert all 98 masters (plus a bunch of replicas) with fifteen different database schemes (one especially large 750GB base was converted to almost two weeks of computer time).  Admins cried, didn‚Äôt sleep at night (sometimes the developers weren‚Äôt allowed to sleep either), but the process wasn‚Äôt as fast as we wanted.  Initially we wanted the best way and carried out the conversion according to the above scheme; to speed up the process, we used machines with SSD disks.  But at the end of the third month, realizing that in this situation it would take two more months to work, they did not stand, threw the entire load from the replicas to the masters and began to convert directly on old replicas.  Fortunately, there were no abnormal situations during this time on the masters, and in a week (mainly because the replicas were spinning on rather weak old wheelbarrows) the conversion was completed. <br><br>  In addition to the conversion of the bases themselves, it also took the support for UTF-8 in the code, as well as to ensure a smooth and imperceptible transition.  With MySQL, everything is true, simple.  The fact is that he has a separate encoding in which he stores the data, and a separate encoding in which he gives the data to the client.  Historically, the servers we have been registered that <i>character_set_ * = cp1251</i> .  For the parameters <i>character_set_client, character_set_connection, character_set_results,</i> we did not change anything so as not to break old customers, and left cp1251.  The rest was replaced by utf8.  As a result, old clients working in cp1251 still receive data in cp1251, regardless of whether the base is converted or not, and new ones working in UTF-8, after establishing the connection, immediately execute the set names utf8 command;  and begin to enjoy all the benefits of this encoding. <br><br><h1>  Tarantool </h1> What is a tarantula, I think, you can not tell.  This brainchild of My World has already gained sufficient fame and has grown into a good open source <a href="http://tarantool.org/">project</a> . <br><br>  Over the years of its use, we managed to accumulate a huge amount of information in it, and when it turned out that we had 400 pieces of tarantula instances, frankly, it became scary that the conversion would take a long time.  But, fortunately for us, it turned out that only 60 of them have text fields (mostly user profiles). <br><br>  We have to admit that transcoding tarantulas was a really interesting task.  And the decision turned out quite elegant.  But, of course, not quite out of the box.  Immediately, I‚Äôll make a reservation that historically it turned out that after tarantool began to develop as an open source project, it turned out that the needs of the community and ours do not coincide a bit.  The community needs an understandable product, a key-value repository that works out of the box, we need a product with a modular architecture (a framework for writing repositories), additional highly specialized features, and performance optimizations.  Therefore, somewhere we continued to use tarantool, and somewhere we began to use its fork <a href="https://github.com/delamonpansie/octopus">octopus</a> , which is being developed by the author of the very first tarantula.  And this greatly simplified the conversion process.  The fact is that in Octopus it is possible to write replication filters on lua, that is, to transfer not original commands from snapshot and xlog masters, but those that have been modified using the lua function.  This possibility was once added long ago in order to be able to raise partial replicas containing not all the data from the master, but only certain tuple fields.  And we had the idea that, in the same way, we can recode texts in the process of replication on the fly. <br><br>  And yet, the octopus for this task had to be slightly finished: although the <i>feeder</i> (the master process feeding the xlog and replica) had already been implemented as a separate octopus module <i>mod_feeder</i> for a long time, it still could not be started separately without storage (in this case, the key value, implemented by the <i>mod_box</i> module), and it was necessary that changes in the replication mechanism did not require restarting the wizard.  Well, of course, I had to write replication filters on lua, which for each namespace converted the necessary fields from CP1251 to UTF-8. <br><br>  In addition to actually converting data in tarantulas and octopuses, it was necessary to ensure that the code works transparently with their shards that have already been converted and not yet, as well as to ensure atomic switching from working in CP1251 to working in UTF-8.  Therefore, it was decided to put a special transcoding proxy in front of the repositories, which, depending on the checkbox in the client's request, converted the data from the encoding of the base into the encoding of the client.  Here, <i>Octopus</i> came again to help us, or rather, its <i>mod_colander</i> module, which allows you to write fast proxy servers, including lua (since octopus uses luajit and ffi, it turns out really productive). <br><br>  Total, the tarantool / octopus to UTF-8 conversion scheme is as follows: <br><ol><li>  Configure <i>utf8proxy</i> on the master and replicas.  We raise it on the port that the tarantula had previously listened to; we tangent the tarantula itself to another port.  From this point on, customers can execute queries in both CP1251 and UTF-8. </li><li>  On the server with the master, we launch the <i>reconverting utf8feeder</i> , configure it to read snapshot'y and xlog'i from the same directories where the master writes them. </li><li>  On another server, aside, we raise a temporary replica of the wizard, configure it to replicate from the converting feeder.  In a temporary replica, the data will already arrive in UTF-8 encoding. </li><li>  <i>utf8proxy</i> replicas set up to replicate from a temporary replica, the old replica is poured from a temporary replica, then we return the load back. </li><li>  Firewall port on <i>utf8proxy</i> wizard (so that there are no conflicts on updates), <i>utf8proxy is</i> reconfigured to a temporary replica, we make a temporary replica a temporary master, we extinguish the old master, decapitate the port to <i>utf8proxy</i> . </li><li>  We translate the new master from the temporary one, switch the replicas to the replication from it. </li><li>  We make the new master a master with <i>utf8proxy</i> , turn off the temporary master.  In this step, all instances contain data in UTF-8, you can start writing non-Cyrillic texts from clients. </li><li>  After switching all clients to UTF-8, <i>remove utf8proxy</i> . </li></ol><br><br><img src="https://habrastorage.org/files/c22/dbe/bf9/c22dbebf901b4a41be43fe136241a772.gif"><br><br>  The whole process of recoding tarantulas / octopus took about a month.  Unfortunately, there were no overlays: since they converted several shards in parallel, they managed to confuse the two shards in places when switching masters.  By the time the problem was discovered, a significant amount of data changes had already occurred.  I had to analyze xlogs from both shards and restore justice. <br><br><h1>  Memcached </h1>  At first glance, it seems (to us, at least, it seemed so at first) that with the conversion of caches it will be easiest: either we write UTF-8 to keys with a different name, or to other instances.  But in practice this does not work.  There are two reasons for this: first, it will take twice as many caches, and second, when switching the encoding, the caches will be cold.  If the second problem can be fought by smoothly switching across several servers, then from the first, given the large number of caches, it is much more difficult. <br><br>  Therefore, we chose to mark each key with a flag about the encoding it contains.  Moreover, the pearl barley client to the <i>Cache :: Memcached :: Fast</i> memkesh already has this feature: when saving a string in a memkey in one of the key flags ( <i>F_UTF8 = 0x4</i> ), it writes the internal pearl-barley flag of the string <i>SVf_UTF8,</i> which is set if the string contains multibyte characters .  Thus, if the flag is set, then the string is uniquely in UTF-8, if not, then everything is a bit more complicated: this is either a string of text in CP1251, or a binary one.  The text strings, of course, we convert if necessary, but with the binary ones there is a difficulty: in order not to break them with unnecessary conversion, we had to separate the set / get methods (and so on) for text strings and binary ones, to find all the saving binary strings into memeshed and receive them, and replace them with appropriate methods without automatic transcoding.  In the code, they did the same and added support for the <i>F_UTF8</i> flag. <br><br><h1>  Other self-storage </h1>  In addition to the above-mentioned standard repositories, we use a huge number of self-stored repositories used to store the ‚Äúwhat's new‚Äù tape, comments, message queues, dialogs, search, and other things.  We will not dwell on each of them in more detail; we only mention the main cases and the ways of solving them. <br><ol><li>  <b>Storage is difficult to convert without downtime, or soon we plan to transfer the data to a new storage, or data with a short lifespan.</b>  In such cases, the data was not converted, but the new records were marked with the encoding feature in one of two ways: either with a flag indicating what encoding the entire record is in, or with a BOM marker at the beginning of each string field if it is in UTF-8. </li><li>  <b>The storage does not store the strings themselves, but the hash sum from them.</b>  Used by us to search.  There they simply went through the entire repository with a script that replicated the hash sums from the original lines converted to UTF-8.  At the time of conversion, I had to perform two database queries for each search query: one in CP1251, the other in UTF-8. </li><li>  <b>A proxy is already installed in front of the repository, and all requests to the repository go through it.</b>  In this case, a conversion to a proxy was implemented, similar to how it was done for a tarantula, with the only difference that if this is a temporary functionality for a tarantula, then in this case it will remain until the data stored in the database is relevant. </li></ol><br><h1>  UTF-8 support in code </h1>  In parallel with the way our administrators converted databases, the developers adapted the code to work with UTF-8 encoding.  Our entire code base is conditionally divided into three parts: Perl, C, and templates. <br><br>  When designing the procedure for switching a project to UTF-8 encoding, one of the key requirements for us was the ability to switch on one server.  It was necessary first of all in order to ensure the possibility of testing a project in UTF-8 using combat bases, first by our testers, and then by a few percent of our users. <br><br><h1>  Perl and UTF-8 </h1>  To adapt the pearl barley code to work with UTF-8, it was necessary to solve several basic tasks: <br><ul><li>  convert the Cyrillic strings scattered across the code; </li><li>  take into account the server encoding when establishing a connection to all storages and services; </li><li>  consider that the parameters of HTTP requests may not come in the encoding in which the server operates; </li><li>  it is necessary to give the content in the server encoding and use the correct templates; </li><li>  it is necessary to unambiguously logically separate byte strings and character strings, decode UTF-8 (from bytes to characters) at the input and encode it at the output. </li></ul><br>  We decided to convert the perl code from CP1251 to UTF-8 in a somewhat nontrivial way: we started by converting modules on the fly when compiling using filters (see <i>perlfilter</i> and <i>Filter :: Util :: Call</i> ; perl allows you to modify the source codes between reading disk and compilation).  This was needed in order to avoid multiple conflicts with the merge of the repository branches, which would arise if we tried to convert repo in one single branch and keep it aside during the development and testing process.  The entire testing process and the first week after launch, the source codes continued to remain in CP1251 and were converted directly on the combat servers when the daemons were started, if the server was configured as UTF-8.  A week after the launch, we converted the repository and immediately set the result to master.  As a result, conflicts with merge arose only for those branches that were in development at this moment in time. <br><br>  The most routine was the process of adding to all necessary places the automatic conversion of rows for storage, which we did not convert to UTF-8 entirely.  But even in those cases where the conversion of strings in the pearl was not needed, it was still necessary to take into account the fact that in the pearl there is a difference (and significant) between byte and character strings.  Of course, we wanted all text strings to automatically become character after reading from the database, which required analyzing all I / O for binary data or text data, had to go through all the pack / unpack calls, and after unpacking, mark all the necessary strings as symbolic (or, on the contrary, before packing, make a byte string so that the length is counted in bytes, not characters). <br><br>  The problem that the HTTP request parameters can come either to CP1251 or to UTF-8 (depending on the encoding of the referer page) was first decided to be solved by passing an additional parameter in the request.  But then, after analyzing how CP1251 and UTF-8 is encoded, they came to the conclusion that we can always uniquely distinguish Cyrillic in CP1251 from Cyrillic in UTF-8 by checking the line for whether it is valid UTF-8 (only Russian letters in CP1251 is almost impossible to make valid UTF-8). <br><br>  In general, the way work with UTF-8 in pearl is organized is convenient enough, but nevertheless it is often magical, and you should keep in mind that it is necessary: <br><ul><li>  forget about the fact that the lines have the <i>SVf_UTF8</i> flag (it is useful only for debugging), instead, treat the lines as byte and character, but forget that the internal representation of the pearl-barley string with the <i>SVf_UTF8</i> flag is UTF-8; </li><li>  forget about the functions <i>Encode :: _ utf8_on (), Encode :: _ utf8_off (), utf8 :: upgrade (), utf8 :: downgrade (), utf8 :: is_utf8 (), utf8 :: valid ();</i> </li><li>  use <i>utf8 :: encode ()</i> when converting a character Unicode string to UTF-8; </li><li>  take into account that for a pearl the <i>UTF-8</i> and <i>utf8</i> encoding are slightly different encodings: for the first, only the code point &lt;= 0x10FFFF are valid (as defined by the Unicode standard), and for the second, any IV (int32 or int64 depending on the architecture), encoded using the UTF-8 encoding algorithm; </li><li>  accordingly, <i>utf8 :: decode ()</i> can only be used for decoding from trusted sources (own databases), in which there can be no invalid UTF-8, and when decoding external input, always use <i>Encode :: decode ('UTF-8 ', $ _)</i> to protect against invalid, in terms of Unicode, code points; </li><li>  do not forget that the result of the <i>utf8 :: decode ()</i> function is sometimes useful to check to see if the byte string was utf8 valid. For similar purposes of checking for valid UTF-8, you can use the third parameter in <i>Encode :: decode ();</i> </li><li>  Note that the upper half of the latin1 table contains the same characters as the Unicode code points with the same numbers, but they will be encoded differently in UTF-8.  This affects the result of the erroneous double call <i>utf8 :: decode ()</i> : for the rows containing only the code point from the ASCII table or containing at least one character with code point&gt; 0xff everything will be fine, but if the string contains only the characters with the code point from the upper half of the latin1 and ascii tables, the symbols from latin1 will be beaten. </li><li>  use the latest version of pearl.  On perl 5.8.8, we attacked a remarkable bug: a combination of <i>use locale</i> and some regular expressions with the correct input data leads to an infinite loop of the regular.  It was necessary to limit the scope of the use of <i>use locale</i> only for the strictly necessary set of functions: <i>sort, cmp, lt, le, gt, ge, lc, uc, lcfirst, ucfirst.</i> </li></ul><br><h1>  C and UTF-8 </h1>  In our C code, fortunately, there were not as many lines as in the pearl, so we went along the classical path: we took all the Cyrillic lines into a separate file.  This allowed limiting potential conflicts in merge in the framework of a single file, as well as simplified subsequent localization.  In the process of converting repo to UTF-8, they found something amusing - the Russian-language comments in the code were in all 4 Cyrillic encodings: cp1251, cp866, koi8-r and iso8859-5.  When converting, it was necessary to use auto detection of the encoding of each specific string. <br><br>  In addition to the repo conversion, C also needed support for basic string functions: defining the length in characters, adjusting the registers, cutting the string to length, etc. To work with Unicode, C has a wonderful <i>libicu</i> library, but it has a certain inconvenience: UTF-16 uses internal representation.  Of course, we wanted to avoid the overhead of transcoding between UTF-8 and UTF-16, so for the most frequently used simple functions, we had to implement analogs that work directly with UTF-8 without transcoding. <br><br><h1>  Templates, javascript and UTF-8 </h1>  With patterns, fortunately, everything was quite simple.  In production, they are decomposed into rpm packages, so the logical solution was to transcode the rpm into the build process.  We added another package with templates in UTF-8, which were installed in the next directory, and the code (both pearl barley and sishny) after that simply selected the template from the corresponding directory. <br><br>  With javascript out of the box did not work.  Most browsers when downloading javascript take into account its Content-Type, but still there are some old instances that do not do this, but focus on the encoding of the page.  Therefore, we put a crutch: when building a package with javascript, we replaced all non-ASCII characters with their escape sequences in the form of code points numbers.  With this approach, the size of js increases, but then any browser loads it correctly. <br><br><h1>  What is the result </h1>  In the end, after six months solitaire converged.  The admins have just finished recoding a couple of hundred bases, the developers have finished the code, the testing process is also complete.  We gradually switched knobs on the World control panels: first, all our colleagues' accounts were transferred to UTF-8, then one percent of users, after which they began to switch backend servers and 10 servers and, finally, frontendes.  Visually, nothing changed, neither the project page nor the load schedules, which could not but rejoice.  The only external change, according to which it was clear that half a year was not by chance, is a change in the <i>Content-Type</i> line <i>charset = windows-1251 to charset = UTF-8</i> . <br><br>  Three months have passed since then, our Russian-speaking users have already appreciated the ability to insert emoji and other ryushech into the text, and the Kazakh have begun to correspond in their own language and, more recently, they have had the opportunity to use the web interface and mobile applications in their native language.  There were also enough interesting tasks in the process of internationalization and localization of the project that followed unicode, and we will try to devote a separate article to this. </div><p>Source: <a href="https://habr.com/ru/post/235209/">https://habr.com/ru/post/235209/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235197/index.html">How dangerous is an open recursive DNS server?</a></li>
<li><a href="../235199/index.html">Cubietruck. Road mini server. Part 2</a></li>
<li><a href="../235203/index.html">SAP SDM. 6 letters - many problems</a></li>
<li><a href="../235205/index.html">Small utility for CoffeeScript developer</a></li>
<li><a href="../235207/index.html">We manage servos from OpenWRT without Arduino</a></li>
<li><a href="../235213/index.html">Openstreetmap-based navigation apps for Windows Phone</a></li>
<li><a href="../235215/index.html">Receiving HF to RTL-SDR, free of charge without converter</a></li>
<li><a href="../235217/index.html">Windows RT as a development assistant - use experience</a></li>
<li><a href="../235221/index.html">Industry of eSports: from a box of beer to a million dollars</a></li>
<li><a href="../235223/index.html">Star Citizen: Until September 5, the game is available to everyone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>