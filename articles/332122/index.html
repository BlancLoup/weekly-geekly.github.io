<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practical use in Go: organizing access to databases</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few weeks ago, someone created a topic on Reddit with the request: 
 What would you use as Go's best practice for accessing a database in (HTTP or o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Practical use in Go: organizing access to databases</h1><div class="post__text post__text-html js-mediator-article"><p>  A few weeks ago, someone created a <a href="https://www.reddit.com/r/golang/comments/38hkor/go_best_practice_for_accessing_database_in/">topic on Reddit</a> with the request: </p><br><blockquote>  What would you use as Go's best practice for accessing a database in (HTTP or other) handlers, in the context of a web application? </blockquote><p>  The answers he received were varied and interesting.  Some people suggested using dependency injection, some supported the idea of ‚Äã‚Äãusing simple global variables, others suggested putting the connection pool pointer in x / net / context (the <a href="https://golang.org/pkg/context/">context</a> package is used with golang 1.7). </p><br><p>  As for me?  I think that the correct answer depends on the project. </p><br><p>  <em>What is the overall structure and size of the project?</em>  <em>What approach do you use for testing?</em>  <em>How will the project develop in the future?</em>  All of these things, and much more, partly affect which approach is right for you. </p><br><p>  In this post we consider four different approaches to organizing your code and structuring access to a pool of connections to a database. </p><br><p>  <em>This post is a free translation of the original <a href="http://www.alexedwards.net/blog/organising-database-access">article</a> .</em>  <em>The author of the article offers four approaches to organizing database access in an application written in golang</em> </p><a name="habracut"></a><cut></cut><br><h2 id="globalnye-peremennye">  Global variables </h2><br><p>  The first approach that we consider is common and simple - take a pointer to the pool of connections to the database and put it in a global variable. </p><br><p>  To make the code look beautiful and conform to the DRY principle (Don't Repeat Yourself - rus. Do not repeat), you can use the initialization function that will establish a global pool of connections from other packages and tests. </p><br><p>  I like specific examples, let's continue working with the online store database and the code from my previous <a href="http://www.alexedwards.net/blog/practical-persistence-sql">post</a> .  We will consider creating simple applications with MVC (Model View Controller) with a similar structure - with HTTP handlers in the main application and a separate model package containing global variables for the database, the InitDB () function, and our database logic. </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">bookstore</span></span> ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.go</span></span> ‚îî‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">models</span></span> ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">books</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.go</span></span> ‚îî‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">db</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.go</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  File: main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { models.InitDB(<span class="hljs-string"><span class="hljs-string">"postgres://user:pass@localhost/bookstore"</span></span>) http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/books"</span></span>, booksIndex) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":3000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">booksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Method != <span class="hljs-string"><span class="hljs-string">"GET"</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">405</span></span>), <span class="hljs-number"><span class="hljs-number">405</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bks, err := models.AllBooks() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">500</span></span>), <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bk := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bks { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s, %s, %s, ¬£%.2f\n"</span></span>, bk.Isbn, bk.Title, bk.Author, bk.Price) } }</code> </pre> <br><p>  File: models / db.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataSourceName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error db, err = sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, dataSourceName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = db.Ping(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } }</code> </pre> <br><p>  File: models / books.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Isbn <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Book, error)</span></span></span></span> { rows, err := db.Query(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM books"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() bks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*Book, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { bk := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Book) err := rows.Scan(&amp;bk.Isbn, &amp;bk.Title, &amp;bk.Author, &amp;bk.Price) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, bk) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bks, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  If you run the application and make a request for / books, you should get an answer similar to: </p><br><pre> <code class="bash hljs">$ curl -i localhost:3000/books HTTP/1.1 200 OK Content-Length: 205 Content-Type: text/plain; charset=utf-8 978-1503261969, Emma, Jayne Austen, ¬£9.44 978-1505255607, The Time Machine, HG Wells, ¬£5.99 978-1503379640, The Prince, Niccol√≤ Machiavelli, ¬£6.99</code> </pre> <br><p>  Using global variables is potentially suitable if: </p><br><ul><li>  all database logic is in one package; </li><li>  your application is quite small and tracking global variables should not cause you problems; </li><li>  approach to testing means that you do not need to check the database and do not run parallel tests. </li></ul><br><p>  In the example above, using global variables is great.  But what will happen in more complex applications when database logic is used in several packages? </p><br><p>  One option is to call InitDB several times, but this approach can quickly become clumsy and it looks a bit strange (it is easy to forget to initialize the connection pool and get the null pointer to panic at runtime).  The second option is to create a separate configuration package with the exported database variable and import "yourproject / config" into each file, where necessary.  If it is not clear what is at stake, you can see <a href="https://gist.github.com/alexedwards/8b4b0cd4495d7c3abadd">an example</a> . </p><br><h2 id="vnedrenie-zavisimosti">  Dependency injection </h2><br><p>  In the second approach, we will consider dependency injection.  In our example, we obviously want to pass a pointer to the connection pool, to our HTTP handlers, and then to our database logic. </p><br><p>  In the real world, applications probably have an additional level (competitively safe) in which there are elements to which your handlers have access.  These may be pointers to a logger or cache, as well as a pool of database connections. </p><br><p>  For projects in which all your handlers are in the same package, a neat approach is to have all the elements in the custom Env type: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Env <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db *sql.DB logger *log.Logger templates *template.Template }</code> </pre> <br><p>  ... and then define your handlers and methods in the same place as Env.  This provides a clean and distinctive way to create a pool of connections (and for other elements) for your handlers. </p><br><p>  Full example: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  File: main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Env <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := models.NewDB(<span class="hljs-string"><span class="hljs-string">"postgres://user:pass@localhost/bookstore"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } env := &amp;Env{db: db} http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/books"</span></span>, env.booksIndex) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":3000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env *Env)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">booksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Method != <span class="hljs-string"><span class="hljs-string">"GET"</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">405</span></span>), <span class="hljs-number"><span class="hljs-number">405</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bks, err := models.AllBooks(env.db) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">500</span></span>), <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bk := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bks { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s, %s, %s, ¬£%.2f\n"</span></span>, bk.Isbn, bk.Title, bk.Author, bk.Price) } }</code> </pre> <br><p>  File: models / db.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataSourceName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sql.DB, error)</span></span></span></span> { db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, dataSourceName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = db.Ping(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  File: models / books.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Isbn <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Book, error)</span></span></span></span> { rows, err := db.Query(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM books"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() bks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*Book, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { bk := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Book) err := rows.Scan(&amp;bk.Isbn, &amp;bk.Title, &amp;bk.Author, &amp;bk.Price) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, bk) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bks, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><h2 id="ili-ispolzovat-zamykaniya">  Or use closures ... </h2><br><p>  If you do not want to define your handlers and methods in Env, an alternative approach would be to use handler logic to close and close the Env variable as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  File: main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Env <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := models.NewDB(<span class="hljs-string"><span class="hljs-string">"postgres://user:pass@localhost/bookstore"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } env := &amp;Env{db: db} http.Handle(<span class="hljs-string"><span class="hljs-string">"/books"</span></span>, booksIndex(env)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":3000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">booksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env *Env)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Method != <span class="hljs-string"><span class="hljs-string">"GET"</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">405</span></span>), <span class="hljs-number"><span class="hljs-number">405</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bks, err := models.AllBooks(env.db) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">500</span></span>), <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bk := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bks { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s, %s, %s, ¬£%.2f\n"</span></span>, bk.Isbn, bk.Title, bk.Author, bk.Price) } }) }</code> </pre> </div></div><br><p>  Dependency injection is a good approach when: </p><br><ul><li>  all your handlers are in the same package; </li><li>  all handlers have the same dependency set; </li><li>  approach to testing means that you do not need to check the database and do not run parallel tests. </li></ul><br><p>  Once again, you can use this approach if your handlers and database logic are distributed across multiple packages.  One way to achieve this is to create a separate configuration package, the exported type of Env.  One way to use Env in the example above.  As well as a simple <a href="https://gist.github.com/alexedwards/5cd712192b4831058b21">example</a> . </p><br><h2 id="ispolzovanie-interfeysov">  Use of interfaces </h2><br><p>  We will use the dependency injection example a little later.  Let's modify the model package so that it returns a custom database type (which includes <em>sql.DB</em> ) and <em>implement the</em> database logic in the form of a DB type. </p><br><p>  We get a double advantage: first we get a clean structure, but more importantly, it opens up the potential to test our database in the form of unit tests. </p><br><p>  Let's change the example and enable the new Datastore interface, which implements some of the methods, in our new DB type. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Datastore <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { AllBooks() ([]*Book, error) }</code> </pre> <br><p>  We can use this interface throughout our application.  Updated example. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  File: main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Env <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db models.Datastore } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := models.NewDB(<span class="hljs-string"><span class="hljs-string">"postgres://user:pass@localhost/bookstore"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } env := &amp;Env{db} http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/books"</span></span>, env.booksIndex) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":3000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env *Env)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">booksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Method != <span class="hljs-string"><span class="hljs-string">"GET"</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">405</span></span>), <span class="hljs-number"><span class="hljs-number">405</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bks, err := env.db.AllBooks() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">500</span></span>), <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bk := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bks { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s, %s, %s, ¬£%.2f\n"</span></span>, bk.Isbn, bk.Title, bk.Author, bk.Price) } }</code> </pre> <br><p>  File: models / db.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Datastore <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { AllBooks() ([]*Book, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DB <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataSourceName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*DB, error)</span></span></span></span> { db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, dataSourceName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = db.Ping(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;DB{db}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  File: models / books.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Isbn <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Book, error)</span></span></span></span> { rows, err := db.Query(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM books"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() bks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*Book, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { bk := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Book) err := rows.Scan(&amp;bk.Isbn, &amp;bk.Title, &amp;bk.Author, &amp;bk.Price) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, bk) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bks, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  Due to the fact that our handlers now use the Datastore interface, we can easily create unit tests for responses from the database. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http/httptest"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mockDB <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mdb *mockDB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*models.Book, error)</span></span></span></span> { bks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*models.Book, <span class="hljs-number"><span class="hljs-number">0</span></span>) bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, &amp;models.Book{<span class="hljs-string"><span class="hljs-string">"978-1503261969"</span></span>, <span class="hljs-string"><span class="hljs-string">"Emma"</span></span>, <span class="hljs-string"><span class="hljs-string">"Jayne Austen"</span></span>, <span class="hljs-number"><span class="hljs-number">9.44</span></span>}) bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, &amp;models.Book{<span class="hljs-string"><span class="hljs-string">"978-1505255607"</span></span>, <span class="hljs-string"><span class="hljs-string">"The Time Machine"</span></span>, <span class="hljs-string"><span class="hljs-string">"HG Wells"</span></span>, <span class="hljs-number"><span class="hljs-number">5.99</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bks, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestBooksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { rec := httptest.NewRecorder() req, _ := http.NewRequest(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/books"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) env := Env{db: &amp;mockDB{}} http.HandlerFunc(env.booksIndex).ServeHTTP(rec, req) expected := <span class="hljs-string"><span class="hljs-string">"978-1503261969, Emma, Jayne Austen, ¬£9.44\n978-1505255607, The Time Machine, HG Wells, ¬£5.99\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expected != rec.Body.String() { t.Errorf(<span class="hljs-string"><span class="hljs-string">"\n...expected = %v\n...obtained = %v"</span></span>, expected, rec.Body.String()) } }</code> </pre> </div></div><br><h2 id="kontekst-v-oblasti-vidimosti-zaprosa-request-scoped-context">  Request context (Request-scoped context) </h2><br><p>  Finally, let's look at the use of context in the scope of the request and the transfer of a pool of connections to the database.  In particular, we will use the x / net / context package. </p><br><p>  Personally, I'm not a fan of application-level variables in the context of a request scope ‚Äî it looks awkward and burdensome to me.  The x / net / context package documentation also advises: </p><br><blockquote>  Use context values ‚Äã‚Äãonly for the visibility of data within the request that the API processes and entry points transmit, and not to pass optional parameters to the function. </blockquote><p>  However, people use this approach.  And if your project contains many packages, and the use of the global configuration is not discussed, then this is quite an attractive solution. </p><br><p>  Let's adapt the bookstore example for the last time, passing context to our handlers using the template suggested in the wonderful <a href="http-handler/">article</a> from Joe Shaw </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  File: main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bookstore/models"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContextHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ServeHTTPContext(context.Context, http.ResponseWriter, *http.Request) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContextHandlerFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, http.ResponseWriter, *http.Request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h ContextHandlerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTPContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, rw http.ResponseWriter, req *http.Request)</span></span></span></span> { h(ctx, rw, req) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContextAdapter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ctx context.Context handler ContextHandler } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ca *ContextAdapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { ca.handler.ServeHTTPContext(ca.ctx, rw, req) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := models.NewDB(<span class="hljs-string"><span class="hljs-string">"postgres://user:pass@localhost/bookstore"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } ctx := context.WithValue(context.Background(), <span class="hljs-string"><span class="hljs-string">"db"</span></span>, db) http.Handle(<span class="hljs-string"><span class="hljs-string">"/books"</span></span>, &amp;ContextAdapter{ctx, ContextHandlerFunc(booksIndex)}) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":3000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">booksIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Method != <span class="hljs-string"><span class="hljs-string">"GET"</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">405</span></span>), <span class="hljs-number"><span class="hljs-number">405</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bks, err := models.AllBooks(ctx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, http.StatusText(<span class="hljs-number"><span class="hljs-number">500</span></span>), <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bk := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bks { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s, %s, %s, ¬£%.2f\n"</span></span>, bk.Isbn, bk.Title, bk.Author, bk.Price) } }</code> </pre> <br><p>  File: models / db.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataSourceName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sql.DB, error)</span></span></span></span> { db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, dataSourceName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = db.Ping(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  File: models / books.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Isbn <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Book, error)</span></span></span></span> { db, ok := ctx.Value(<span class="hljs-string"><span class="hljs-string">"db"</span></span>).(*sql.DB) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"models: could not get database connection pool from context"</span></span>) } rows, err := db.Query(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM books"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() bks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*Book, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { bk := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Book) err := rows.Scan(&amp;bk.Isbn, &amp;bk.Title, &amp;bk.Author, &amp;bk.Price) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } bks = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bks, bk) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bks, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  <em>PS The author of the translation will be grateful for the errors and inaccuracies of the translation.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332122/">https://habr.com/ru/post/332122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332112/index.html">Access ClickHouse with JDBC</a></li>
<li><a href="../332114/index.html">Pygest # 12. Releases, articles, interesting projects from the world of Python [June 20, 2017 - July 03, 2017]</a></li>
<li><a href="../332116/index.html">Installing 3CX on Debian Linux 9 Stretch, updating Session Border Controller and Call Flow Designer</a></li>
<li><a href="../332118/index.html">Practice of applying virtual and augmented reality technology</a></li>
<li><a href="../332120/index.html">Mocking in swift with Sourcery</a></li>
<li><a href="../332124/index.html">Product Design Digest June 2017</a></li>
<li><a href="../332126/index.html">Conference Attendance - Checklist</a></li>
<li><a href="../332130/index.html">Choose a free server in the cloud for test purposes, home projects, etc.</a></li>
<li><a href="../332134/index.html">One bit broke, another lost: data transfer task</a></li>
<li><a href="../332138/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ269 (June 26 - July 2, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>