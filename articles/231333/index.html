<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Archive) Matreshka.js v0.2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is outdated. See current version history . 



- Introduction 
- Inheritance 
- MK.Object 
- MK.Array 
- Matreshka.js v0.1 
- Matreshka.js...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Archive) Matreshka.js v0.2</h1><div class="post__text post__text-html js-mediator-article">  <b>The article is outdated.</b>  <b>See <a href="http://ru.matreshka.io/">current version history</a> .</b> <br><br><ul><li>  <a href="http://habrahabr.ru/post/196146/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/200078/">Inheritance</a> </li><li>  <a href="http://habrahabr.ru/post/196886/">MK.Object</a> </li><li>  <a href="http://habrahabr.ru/post/198212/">MK.Array</a> </li><li>  <a href="http://habrahabr.ru/post/217241/">Matreshka.js v0.1</a> </li><li>  <b>Matreshka.js v0.2</b> </li><li>  <a href="http://habrahabr.ru/post/231347/">Implement TodoMVC</a> </li></ul><br>  Hello.  I present the next update of the Matreshka.js framework to version 0.2.  Let me remind you: Matryoshka is a general-purpose open source framework, the ideology of which predominates data over appearance: you set the rules for how the interface should synchronize with the data, then work exclusively with the data, except when the interface event does not concern the data (for example , clicking on the button or submitting the forms themselves do not change the data, but trigger a function which, in turn, works with the data) <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  Matryoshka allows you to quite simply connect data and presentation elements (for example, a property of an object and the value of an input field), without worrying about further synchronization of data and presentation.  For example, the simplest binding looks like this: <br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-select"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span>3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Create an instance: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka();</code> </pre><br>  Associate the x property with the <code>.my-select</code> element: <br><pre> <code class="javascript hljs">mk.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-select'</span></span> );</code> </pre><br>  Change data <br><pre> <code class="javascript hljs">mk.x = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  After we assign a different value to property x, the state of the element changes accordingly. <br>  <a href="http://jsbin.com/vidawequ/7/edit">Take a look at a live example.</a> <br><br>  Another important feature of nesting dolls are events (including custom ones).  For example, the Matryoshka can catch a change in the value of a property: <br><pre> <code class="javascript hljs">mk.on( <span class="hljs-string"><span class="hljs-string">'change:x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> evt </span></span></span><span class="hljs-function">) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'x   '</span></span> + evt.value ); });</code> </pre><br>  The code will print <code>"x   "</code> : <br><pre> <code class="javascript hljs">mk.x = <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre><br>  For more information about these and other features, see the links above. <br></div></div><br>  <a href="http://finom.github.io/matreshka/">Link to the site Matryoshka</a> .  <a href="https://github.com/finom/matreshka/">Link to github repository</a> . <br><br><h4>  AMD support </h4><br>  Matryoshka now supports specification of the definition of asynchronous modules, Asynchronous Module Definition.  In other words, Matryoshka is compatible with libraries, such as <a href="http://requirejs.org/">requirejs</a> .  This means that you can now write a true code that does not read into the global namespace.  Two types of connection are supported: a request for a named module and a request for an anonymous module. <br><br>  Named modules: <br><pre> <code class="javascript hljs">requirejs.config({ <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: { <span class="hljs-attr"><span class="hljs-attr">xclass</span></span>: <span class="hljs-string"><span class="hljs-string">'path/to/matreshka'</span></span>, <span class="hljs-attr"><span class="hljs-attr">matreshka</span></span>: <span class="hljs-string"><span class="hljs-string">'path/to/matreshka'</span></span> } }); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'xclass'</span></span>, <span class="hljs-string"><span class="hljs-string">'matreshka'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Class, MK</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Class({ <span class="hljs-string"><span class="hljs-string">'extends'</span></span>: MK <span class="hljs-comment"><span class="hljs-comment">//... }); });</span></span></code> </pre><br>  But this is rather a side effect of using the new project file structure.  And the recommended method is to request an unnamed module: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'path/to/matreshka'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> MK </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MK.Class({ <span class="hljs-string"><span class="hljs-string">'extends'</span></span>: MK <span class="hljs-comment"><span class="hljs-comment">// ... }); });</span></span></code> </pre><br>  As you can see, Matryoshka contains a <code>Class</code> property that duplicates the function that creates classes: there is no need to request an additional module. <br><habracut><br><h4>  <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # addDependency method</a> : new name and additional features </h4><br>  <b>1.</b> The <code>addDependence</code> method was renamed to <code>addDependency</code> at the prompt of the buriy <a href="https://habrahabr.ru/users/buriy/" class="user_link">habrauser</a> (thanks to him), the old method is marked as ‚Äúoutdated‚Äù. <br>  <b>2.</b> The method now supports the promised ability to add dependencies on the properties of other classes.  The syntax of the second argument is as follows: <code>[ , "", , "", , "" ... ]</code> is an array, with odd elements ‚Äî instances of classes, even-numbered keys of these instances, on which the desired property depends.  Take a look at an example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'a'</span></span>, [ anotherInstance1, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, anotherInstance2, <span class="hljs-string"><span class="hljs-string">'d'</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> b, c, d </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b + c + d; });</code> </pre><br>  Here the property <code>"a"</code> depends on the property <code>"b"</code> object <code>anotherInstance1</code> , on the property <code>"d"</code> object <code>anotherInstance2</code> and on its own property <code>"c"</code> .  The old syntax still works: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b c'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> b, c </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b + c; });</code> </pre><br>  <b>3.</b> Secure dependencies.  This clause does not affect the syntax: since this release the method avoids an infinite loop if <code>addDependency</code> used <code>addDependency</code> .  Imagine a situation where property <code>"a"</code> depends on property <code>"b"</code> , property <code>"b"</code> depends on property <code>"c"</code> , and property <code>"c"</code> , in turn, depends on <code>"a"</code> .  Abstract illustration for example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> b </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b * <span class="hljs-number"><span class="hljs-number">2</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> c </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-number"><span class="hljs-number">3</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a / <span class="hljs-number"><span class="hljs-number">5</span></span>; });</code> </pre><br>  Each dependency in this code caused the following, resulting in a dangling page.  Now, protection against such errors has appeared: the code passes a special flag through the entire dependency chain, and when the framework reaches a potentially dangerous dependency, the chain stops.  <code>addDependency</code> in a new form allows you to build mutual dependencies based on complex (or not) formulas, without fear of errors in the implementation of these formulas.  An example of calculating the perimeter of a rectangle by the length of the sides, and calculating the lengths of the sides: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'p'</span></span>, <span class="hljs-string"><span class="hljs-string">'a b'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a, b </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) * <span class="hljs-number"><span class="hljs-number">2</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'p b'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p, b </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p/<span class="hljs-number"><span class="hljs-number">2</span></span> - b; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addDependency( <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'p a'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p, a </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p/<span class="hljs-number"><span class="hljs-number">2</span></span> - a; });</code> </pre><br><br><h4>  Static method <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka.procrastinate</a> </h4><br>  Imagine the following situation (taken from my practice).  You have a form with certain text fields: checkboshes, etc. When the value of one of the form elements changes, the application must send a request to the server, which, in turn, returns data for rendering three graphs.  Drawing graphs is hard for a processor and takes half a second on a weak computer ( <a href="http://www.highcharts.com/">Highcharts</a> is that).  Now imagine a user who is bored and he decided to repeatedly click on the checkbox.  What will happen?  A lot of requests will be sent, a bunch of answers will come back, which will also draw the schedule many times.  What do they usually do in this case?  Cancel the request to the server.  The question is: why was this request to send, if you could wait until it calms down?  :) <br><br>  To solve this problem, I used the simplest function (possibly a bicycle), which takes another function as an argument and returns its modification, which can only be run once in a certain period of time.  No project can do without it, so it was decided to include it in the Matryoshka code.  Example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doSomethingHeavy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> i </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'Ok'</span></span>, i ); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> procrastinateSomethingHeavy = MK.procrastinate( doSomethingHeavy ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++ ) { procrastinateSomethingHeavy( i ); } <span class="hljs-comment"><span class="hljs-comment">// &gt;&gt; Ok 100</span></span></code> </pre><br>  Function code (in case you want to use it outside the Matryoshka): <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> procrastinate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> f, d, thisArg </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> d !== <span class="hljs-string"><span class="hljs-string">'number'</span></span> ) { thisArg = d; d = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; clearTimeout( timeout ); timeout = setTimeout( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ f.apply( thisArg || _this, args ); }, d || <span class="hljs-number"><span class="hljs-number">0</span></span> ); }; };</code> </pre><br>  The method, in addition to the "procraticizing" function, takes a delay, and the context as arguments.  The delay is responsible for how many milliseconds the actual function call will be delayed during the next attempt to call it. <br><br>  And here is an example of the case when the function will never be called (for better understanding). <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> procrastinateSomethingHeavy = MK.procrastinate( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'Ok'</span></span> ); }, <span class="hljs-number"><span class="hljs-number">1000</span></span> ); setInterval( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ procrastinateSomethingHeavy(); }, <span class="hljs-number"><span class="hljs-number">500</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br><br><h4>  New key binder <code>initialize</code> </h4><br>  Binder ( <a href="http://finom.github.io/matreshka/docs/global.html">binder</a> ) - the third argument of the <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # bindElement method</a> .  If you remember, this is an object consisting of three properties: <code>on</code> (for which DOM event the property is updated), <code>getValue</code> (how to extract the property value from the element), <code>setValue</code> (how to set the property value for the element).  More details <a href="http://habrahabr.ru/post/196146/">here</a> (by the way, all the articles about Matryoshka are updated every release and are relevant material).  Now there is one more optional property <code>initialize</code> . <br><br>  <code>initialize</code> is a function that starts at the time of binding, or rather, before it.  The task of the function is to sweeten the code.  Take a look at an example from the <a href="http://habrahabr.ru/post/196146/">first article</a> : <br><blockquote>  First, before binding, we will announce the slider: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slider"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs">$( <span class="hljs-string"><span class="hljs-string">".slider"</span></span> ).slider({ <span class="hljs-attr"><span class="hljs-attr">min</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">max</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> });</code> </pre><br>  Secondly, we declare a copy of the Matryoshka: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka();</code> </pre><br>  Next, call the binding: <br><pre> <code class="javascript hljs">mk.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.slider'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">on</span></span>: <span class="hljs-string"><span class="hljs-string">'slide'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ,       getValue: function() { return $( this ).slider( 'option', 'value' ); //      (.  jQuery ui.slider)? }, setValue: function( v ) { $( this ).slider( 'option', 'value', v ); //      (.  jQuery ui.slider)? } });</span></span></code> </pre></blockquote><br>  The code is somewhat redundant: we refer twice to the element with the <code>slider</code> class (first, applying the plugin, then tying the element).  Now this can be avoided: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka(); mk.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.slider'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).slider({ <span class="hljs-attr"><span class="hljs-attr">min</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">max</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> }); }, <span class="hljs-attr"><span class="hljs-attr">on</span></span>: <span class="hljs-string"><span class="hljs-string">'slide'</span></span>, <span class="hljs-attr"><span class="hljs-attr">getValue</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).slider( <span class="hljs-string"><span class="hljs-string">'option'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span> ); }, <span class="hljs-attr"><span class="hljs-attr">setValue</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> v </span></span></span><span class="hljs-function">) </span></span>{ $( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).slider( <span class="hljs-string"><span class="hljs-string">'option'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, v ); } });</code> </pre><br><br><h4>  <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka</a> method <a href="http://finom.github.io/matreshka/docs/Matreshka.html"># defineSetter</a> </h4><br>  This new method, it is not difficult to guess, determines the setter for the property. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.defineSetter( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> value </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> alert( value ); });</code> </pre><br>  When using the method, you need to remember that it messes up the built-in property setter (if it was) and property change events will not work. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'change:x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> evt </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,    -   alert( 'x is changed to ' + evt.value ); }); this.defineSetter( 'x', function() { // ... }); this.x = 2;</span></span></code> </pre><br><br><h4>  New syntax for event names: adding event handlers for properties and collection items </h4><br>  Perhaps the most important thing in this release is the ability to add an event handler to the internal contents of the instance. <br><br><h5>  Event <code>"@_"</code> </h5><br>  Now you can add a handler for the property inside any class inherited from the Nested Doll (including for <a href="http://finom.github.io/matreshka/docs/Matreshka.Object.html">MK.Object</a> and <a href="http://finom.github.io/matreshka/docs/Matreshka.Array.html">MK.Array</a> ), provided that the value of the property is an instance of the Nested Doll.  Take a look at an example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK; mk.on( <span class="hljs-string"><span class="hljs-string">'x@yeah'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> ); }); mk.x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK; mk.x.trigger( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> );</code> </pre><br>  Note that the order of defining the property and hanging the handler is not important: you can first add an event handler, and then declare the property.  Moreover, if the value of the property changes, then the handler works only for the new value, and for the old one, the handler is deleted. <br><br><h5>  Event <code>"@_"</code> for <code>MK.Object</code> </h5><br>  This event name allows you to add a handler for the JSON key of the instance of <code>MK.Object</code> (see the <a href="http://habrahabr.ru/post/196886/">article about MK.Object</a> for the JSON key or the key responsible for the data). <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mkObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK.Object; mkObject.on( <span class="hljs-string"><span class="hljs-string">'@yeah'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> ); }); mkObject.jset( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK ); mkObject.x.trigger( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> );</code> </pre><br>  The order of the property declaration and event handler is also not important. <br><br><h5>  Event <code>"@_"</code> for <code>MK.Array</code> </h5><br>  By analogy with <code>MK.Object</code> , <code>MK.Object</code> the same opportunity: the handler is hung on any of the array elements, provided that this element is inherited from the Matryoshka. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mkArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK.Array; mkArray.on( <span class="hljs-string"><span class="hljs-string">'@yeah'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> ); }); mkArray.push( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK ); mkArray[ <span class="hljs-number"><span class="hljs-number">0</span></span> ].trigger( <span class="hljs-string"><span class="hljs-string">'yeah'</span></span> );</code> </pre><br>  These three changes are not limited to just listening to the <code>"yeah"</code> event, you can safely listen to other events, for example, <code>"change:"</code> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'x@change:y'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'@change:y'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } );</code> </pre><br>  Theoretically, this feature allows you to build fancy event names while listening to other events in the depths of the data tree.  Let's say we have a data structure that can be represented as an object: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">b</span></span>: { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: { <span class="hljs-attr"><span class="hljs-attr">e</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: { <span class="hljs-attr"><span class="hljs-attr">d</span></span>: { <span class="hljs-attr"><span class="hljs-attr">e</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> } } }] }</code> </pre><br>  In order to get to the bottom of the changes to the <code>"e"</code> property, you can add this handler: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'a@@b@@change:e'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } );</code> </pre><br><br><h4>  <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka</a> method <a href="http://finom.github.io/matreshka/docs/Matreshka.html"># $ bound</a> </h4><br>  Nested dolls have two methods that return bound elements: <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # bound</a> , which returns the first bound element or <code>null</code> and <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # boundAll</a> , which returns a collection of bound elements.  There may be problems for newbies who work with jQuery and are not familiar with <a href="http://vanilla-js.com/">VanillaJS</a> in understanding the term ‚Äúcollection‚Äù and are used to knowing the dollar.  Therefore, the <code>$bound</code> method was added to the framework, which does the exact same thing as <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # boundAll</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindElement( <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'#x, #y'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bound( <span class="hljs-string"><span class="hljs-string">'a'</span></span> ).animate( <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//   jQuery </span></span></code> </pre><br><br><h4>  Other changes </h4><br><h5>  <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka.useAs $</a> instead of <code>usejQuery</code> and <code>useBalalaika</code> </h5><br>  Let me remind you, starting from version 0.1, Matryoshka got rid of the hard jQuery dependency using the micro-library ‚ÄúBalalaika‚Äù if jQuery is not on the page.  The effect of this change was to create two methods that, regardless of the presence of jQuery, forced Matryoshka to use one of the two libraries using the <code>usejQuery</code> methods (in case jQuery was connected after Matryoshka) and <code>useBalalaika</code> (in case jQuery was connected before Matrioshka , but you still want to use the built-in library).  Now there was a method that allows using any jQuery-like library in general ( <code>usejQuery</code> and <code>useBalalaika</code> are marked as obsolete). <br><br>  Examples of using: <br><pre> <code class="javascript hljs">MK.useAs$( jQuery ); MK.useAs$( jQuery.noConflict() ); MK.useAs$( Zepto ); MK.useAs$( MK.$b ); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br>  The consequence of this change was that Matryoshka, when loading, uses the dollar-sign library, if it exists and has certain methods, instead of using only jQuery.  Which methods you can find out in the <a href="">source code of one of the project files</a> . <br><br><h5>  <a href="http://finom.github.io/matreshka/docs/global.html">Xclass.same</a> method </h5><br>  A slight change that adds sitaxic sugar to classes (see the <a href="http://habrahabr.ru/post/200078/">article on nursing</a> ).  Often, when creating a class, the constructor of this class only needs to call the parent constructor in its own context: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyClass = Class({ <span class="hljs-string"><span class="hljs-string">'extends'</span></span>: AnotherClass, <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ AnotherClass.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span> ); }, <span class="hljs-attr"><span class="hljs-attr">someNewMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } });</code> </pre><br>  Now the same can be done more briefly: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyClass = Class({ <span class="hljs-string"><span class="hljs-string">'extends'</span></span>: AnotherClass, <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: AnotherClass.same(), <span class="hljs-attr"><span class="hljs-attr">someNewMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } });</code> </pre><br><br><h5>  Adding DOM event handlers (for example, <code>"click::x"</code> ) before the element has been bound </h5><br>  Matryoshka has the ability to hang event handlers on attached elements using the <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # on</a> method: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-element'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'click::x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'.my-element is clicked'</span></span> ); });</code> </pre><br>  The problem is that it was impossible to add a DOM event handler before the element was bound.  It was necessary to be perverted by waiting for the <code>bind</code> event and adding a handler upon the occurrence of this event: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'bind:x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'click::x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'.my-element is clicked'</span></span> ); }); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-element'</span></span> );</code> </pre><br>  Now the order of binding / adding DOM events is not important: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on( <span class="hljs-string"><span class="hljs-string">'click::x'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert( <span class="hljs-string"><span class="hljs-string">'.my-element is clicked'</span></span> ); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindElement( <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-element'</span></span> );</code> </pre><br><br><h4>  Bug fixes / refactoring </h4><br><ul><li>  <a href="http://finom.github.io/matreshka/docs/Matreshka.Array.html">Matreshka.Array # initializeSmartArray</a> (method documentation in work) now returns <code>this</code> </li><li>  <a href="http://finom.github.io/matreshka/docs/Matreshka.Array.html">Matreshka.Array # createFrom</a> accepts <code>undefined</code> as an argument </li><li>  Changed cases when the <code>"modify"</code> event is triggered for the <a href="http://finom.github.io/matreshka/docs/Matreshka.Array.html">Matreshka.Array</a> class </li><li>  Matryoshka now raises the <code>"delete"</code> event when deleting a property instead of <code>"remove"</code> because <code>Matreshka.Array</code> has an event with the same name, but called in another case </li><li>  If <code>[].forEach</code> does not exist, an error is generated with the suggestion to subnet <a href="https://github.com/es-shims/es5-shim">es5-shim</a> </li><li>  Fixed a bug in the Balalaika parser </li><li>  Fixed a bug in the <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # once</a> method, now the handler can be removed using the <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # off</a> method </li><li>  Now the triad <code>eventName + eventHandler + context</code> can only be added once per instance. </li><li>  Fixed a bug in the <code>Class</code> function ( <code>splice</code> vs <code>slice</code> ) </li><li>  Refactoring <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # on</a> and <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # off</a> methods </li><li>  Small refactoring <a href="http://finom.github.io/matreshka/docs/Matreshka.html">Matreshka # trigger</a> and <a href="http://finom.github.io/matreshka/docs/Matreshka.html">MK # set</a> </li></ul><br><br><h4>  What's next? </h4><br>  1. In the next article I will introduce you to the implementation of TodoMVC.  The article is ready, but requires editing.  The implementation is also ready, but the documentation is completed for it. <br>  2. After this, a large article is planned on <code>MK.Array</code> , replacing the previous one.  There I will talk in more detail about the methods, how the elements of the array are rendered, about the ‚Äúmodel‚Äù and how to pass options to the methods of the arrays. <br>  3. Version 0.3 with a bunch of interesting changes that are already being tested.  As usual, there will be an article. <br><br>  Then, a big review of the documentation is coming, including combing texts and correcting errors related to the English language.  The text of the <a href="http://finom.github.io/matreshka/">main page</a> and the page <a href="http://finom.github.io/matreshka/about/">"Why Matryoshka?" Has</a> already been corrected. <br><br>  All good! </habracut></div><p>Source: <a href="https://habr.com/ru/post/231333/">https://habr.com/ru/post/231333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231321/index.html">Gamification in E-commerce</a></li>
<li><a href="../231323/index.html">Overview of the most interesting materials on data analysis and machine learning ‚Ññ6 (July 21 - 28, 2014)</a></li>
<li><a href="../231325/index.html">Single refactoring analysis</a></li>
<li><a href="../231327/index.html">Anton Arkhipov - Class Loaders and Bytecode Instrumentation</a></li>
<li><a href="../231331/index.html">Interview with Dino Esposito, author of Microsoft .NET: Architecting Applications for the Enterprise</a></li>
<li><a href="../231335/index.html">Mayor of London promised full coverage of 5G in 2020</a></li>
<li><a href="../231337/index.html">What IM architecture do you consider acceptable?</a></li>
<li><a href="../231339/index.html">How we did FrontTalks</a></li>
<li><a href="../231341/index.html">Overview of ZTE Open C - the next phone on Firefox OS</a></li>
<li><a href="../231343/index.html">Linux and LibreOffice installed in schools, government offices and courts of Valencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>