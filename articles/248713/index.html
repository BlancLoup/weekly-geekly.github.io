<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perl 6 and Rakudo: Notes from 2009</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A series of articles on Perl 6 and Rakudo, one of the compilers that support the Perl6 specification. This article is compiled from 2009 notes. 

 Ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perl 6 and Rakudo: Notes from 2009</h1><div class="post__text post__text-html js-mediator-article">  <i>A series of articles on Perl 6 and Rakudo, one of the compilers that support the Perl6 specification.</i>  <i>This article is compiled from 2009 notes.</i> <br><br><h4>  Install Rakudo </h4><br>  Currently, there are several incomplete implementations of Perl 6. The most complete of them is the <a href="http://en.wikipedia.org/wiki/Rakudo_Perl_6">Rakudo</a> compiler ( <a href="http://rakudo.org/how-to-get-rakudo/">download</a> ). <br><br>  Git users can create their own copy using the following commands: <br><pre><code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/rakudo/rakudo.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rakudo $ perl Configure.pl --gen-parrot --gen-moar --gen-nqp --backends=parrot,jvm,moar $ make $ make install</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Alternatively, you can build it from source by downloading it from <a href="http://github.com/rakudo/rakudo/tree/nom">github.com/rakudo/rakudo/tree/nom</a> <br><br>  For Windows, there is a ready-made binary installer.  Installer versions and source code are available <a href="http://rakudo.org/downloads/star/">by reference.</a> <br><a name="habracut"></a><br>  By executing the perl6 command, you will be taken to the REPL environment, where you can play with various language commands. <br><br><pre> <code class="bash hljs">$ perl6 &gt; say <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>; Hello world! &gt; say (10/7).WHAT (Rat) &gt; say [+] (1..999).grep( { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> % 3 == 0 || <span class="hljs-variable"><span class="hljs-variable">$_</span></span> % 5 == 0 } ); 233168</code> </pre><br><br>  Lines beginning with ‚Äú&gt;‚Äù are commands, and all others are system responses.  The first example is a simple ‚Äúsay‚Äù instruction.  The second creates a rational number and asks for its type (Rat).  The third one takes a list of numbers from 1 to 999, filters those that are not divisible by 3 or 5, adds them and displays the result. <br><br><h4>  The beauty of formatting </h4><br>  In this article, we will look at the .fmt method. <br><br>  If you are familiar with the sprintf instruction, then it will be easier for you to deal with .fmt.  If not, or if you forgot how to use it - read perldoc.  But do not go deep, just browse. <br><br>  So .fmt.  Here are some ways to use it to format strings and integers. <br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>.fmt(<span class="hljs-string"><span class="hljs-string">'%+d'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># '+42' say 42.fmt('%4d') # ' 42' say 42.fmt('%04d') # '0042' say :16&lt;1337f00d&gt;.fmt('%X') # '1337F00D'</span></span></code> </pre><br><br>  Good, but for now this is just a shorter way to write sprintf.  However, when used with arrays (more precisely, lists), it turns out that this method works differently: <br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> &lt;  &gt;.fmt <span class="hljs-comment"><span class="hljs-comment">#    say &lt;10 11 12&gt;.fmt('%x') # 'abc' say &lt;1 2 3&gt;.fmt('%02d', '; ') # '01; 02; 03'</span></span></code> </pre><br><br>  But its use with hashes (mappings): <br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> { <span class="hljs-string"><span class="hljs-string">foo =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">bar =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> }.fmt <span class="hljs-comment"><span class="hljs-comment"># 'foo 1 # bar 2' say { '' =&gt; 85, '' =&gt; 75 }.fmt('%s   %d ') # '   85  #    75  ' say { '' =&gt; 1, '' =&gt; 2, '' =&gt; 3 }.fmt('%s', ' -- ') #  --  -- </span></span></code> </pre><br><br>  However, in the case of a hash, the order of issuance may differ from that given.  For couples, there is also a .fmt, but it works just like hashes.  .fmt is a handy tool to change a value or an array of values ‚Äã‚Äãand bring it to the desired format.  It looks like sprintf, but it also works with arrays.  The only negative is that the code is too readable.  To restore Perl‚Äôs reputation as a write-only language, here‚Äôs a Christmas present in the form of a one-liner drawing a Christmas tree: <br><br><pre> <code class="bash hljs">$ perl6 -e <span class="hljs-string"><span class="hljs-string">'say " "x 9-$_,"#"x$_*2-1 for 0..9,2 xx 3'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ### ##### ####### ######### ########### ############# ############### ################# ### ### ###</span></span></code> </pre><br><br>  Option for Windows (other quotes required): <br><pre> <code class="bash hljs">&gt; perl6.exe -e <span class="hljs-string"><span class="hljs-string">"say ' 'x 9-</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">,'#'x</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">*2-1 for 0..9,2 xx 3"</span></span></code> </pre><br><br><h4>  Static typing and multi subs </h4><br>  In Perl 5, the $ scalar variables could contain either a reference or a value.  The value could be anything - an integer, string, non-integer number, date.  Flexibility due to loss in clarity. <br><br>  Perl 6 introduces static typing.  If you need a variable of a certain type, you specify this type during initialization.  For example, here is a variable containing an integer: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Int $days = <span class="hljs-number"><span class="hljs-number">24</span></span>;</code> </pre><br><br>  Other examples of types: <br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Str $phrase = <span class="hljs-string"><span class="hljs-string">" !"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Num $pi = <span class="hljs-number"><span class="hljs-number">3.141</span></span>e<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Rat $other_pi = <span class="hljs-number"><span class="hljs-number">22</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span>;</code> </pre><br><br>  To use variables of the old format, you can either not specify the type, or specify the type Any. <br><br>  The second topic of the chapter is multy subs.  This is an opportunity to overload a procedure using the same name for different cases.  Here is an example: <br><br><pre> <code class="perl hljs">multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify</span></span></span></span>(Int $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> "$<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> ‚Äì  ."; } multi sub identify(Str $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qq&lt;"$<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>" ‚Äì  .&gt;; } multi sub identify(Int $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, Str $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> " $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>   \"$<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>\"."; } multi sub identify(Str $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, Int $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> " \"$<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>\"    $y."; } multi sub identify(Int $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, Int $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> "   - $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>  $y."; } multi sub identify(Str $<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, Str $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> "  - \"$<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>\"  \"$<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>\"."; } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(42); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"    !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> identify(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>);</code> </pre><br><br>  Result: <br><br><pre> <code class="bash hljs">42 ‚Äì  . <span class="hljs-string"><span class="hljs-string">"   !"</span></span> ‚Äì  .  42   <span class="hljs-string"><span class="hljs-string">"    !"</span></span>.  <span class="hljs-string"><span class="hljs-string">"   !"</span></span>    42.   - <span class="hljs-string"><span class="hljs-string">"   !"</span></span>  <span class="hljs-string"><span class="hljs-string">"!"</span></span>.    - 42  24.</code> </pre><br><br><h4>  Testing </h4><br>  The authors of perl-modules are used to supplying a set of tests with the modules they release to the world.  This tradition is maintained in perl 6 through special instructions. <br><br>  The classic way to write tests in perl is to output data using the Test Anything Protocol.  But you don't have to do it manually - you can use the module. <br><br>  Suppose you have a factorial function: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fac</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">) </span></span>{ [*] <span class="hljs-number"><span class="hljs-number">1</span></span>..$n }</code> </pre><br><br>  So far it does not matter how it works - we just want to know if it works correctly.  Let's check: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> v6; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fac</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">) </span></span>{ [*] <span class="hljs-number"><span class="hljs-number">1</span></span>..$n } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test; plan <span class="hljs-number"><span class="hljs-number">6</span></span>; is fac(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fac(0) '</span></span>; is fac(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fac(1)  '</span></span>; is fac(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'fac(2)  '</span></span>; is fac(<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'fac(3)  '</span></span>; is fac(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-string"><span class="hljs-string">'fac(4)  '</span></span>; dies_ok { fac(<span class="hljs-string"><span class="hljs-string">' ,    '</span></span>) }, <span class="hljs-string"><span class="hljs-string">'    '</span></span>;</code> </pre><br><br>  Run: <br><br><pre> <code class="bash hljs"> $ perl6 fac-test.pl 1..6 ok 1 - fac(0)  ok 2 - fac(1)  ok 3 - fac(2)  ok 4 - fac(3)  ok 5 - fac(4)  ok 6 -     </code> </pre><br><br>  Details: use Test;  loads the testing module, plan 6;  announces the launch of six tests.  Then there are five lines in the format of "what is", "what we expect to receive", "description".  is () compares strings, and since integers are automatically converted to strings, everything works out. <br><br>  At the end of dies_ok {$ some_code}, $ description, we check that calling a function with a non-integer argument results in an error. <br><br>  Issuing a test indicates that 6 tests are run, and then on each line displays test results (ok - if passed, not ok - if failed), test number and description. <br><br>  When you run a large number of tests do not want to view them all in detail, but I want to see the results.  The prove command does exactly that: <br><br><pre> <code class="bash hljs"> prove --<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> perl6 fac-test.pl fac-test.pl .. ok All tests successful. Files=1, Tests=6, 11 wallclock secs ( 0.02 usr 0.00 sys + 10.26 cusr 0.17 csys = 10.45 CPU) Result: PASS</code> </pre><br><br>  It is customary to add test files to a separate directory t / and run prove recursively on all files from the directory with the .t extension: <br><br><pre> <code class="bash hljs"> prove --<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> perl6 -rt</code> </pre><br><br>  If you place this line in the Makefile, then you can simply type make test to run the tests. <br><br><h4>  Meta-operators </h4><br>  Earlier, we saw an interesting implementation of the factorial function: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fac</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">) </span></span>{ [*] <span class="hljs-number"><span class="hljs-number">1</span></span>..$n }</code> </pre><br><br>  But how does this work?  Perl 6 has several meta-operators that modify existing operators, which are becoming more powerful.  Square brackets are a metaoperator, reduce, which places the operator specified inside the brackets between all elements of the list.  For example, <br><br><pre> <code class="perl hljs"> [+] <span class="hljs-number"><span class="hljs-number">1</span></span>, $a, <span class="hljs-number"><span class="hljs-number">5</span></span>, $b</code> </pre><br><br>  means the same as <br><br><pre> <code class="perl hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> + $a + <span class="hljs-number"><span class="hljs-number">5</span></span> + $b</code> </pre><br><br>  Thus, we can easily summarize the elements of the list: <br><br><pre> <code class="perl hljs"> $sum = [+] @a; <span class="hljs-comment"><span class="hljs-comment">#    @a</span></span></code> </pre><br><br>  Almost all operators can be placed in square brackets: <br><br><pre> <code class="perl hljs"> $prod = [*] @a; <span class="hljs-comment"><span class="hljs-comment">#   @a $mean = ([+] @a) / @a; #    @a $sorted = [&lt;=] @a; # ,   @a    $min = [min] @a, @b; #       @a  @b</span></span></code> </pre><br><br>  Therefore, in factorial, the expression [*] 1 .. $ n takes the value of the multiplied list elements from 1 to $ n. <br><br>  Another meta-operator is hyper.  Placing "or" (or their ASCII analogues &gt;&gt; and &lt;&lt;) next to the operator, we make it work on all elements of the list.  For example, the following expression makes @c the result of the pairwise addition of the elements @a and @b: <br><br><pre> <code class="perl hljs"> @c = @a ¬ª+¬´ @b;</code> </pre><br><br>  In Perl 5, we would have to write something like <br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; @a; $i++) { $c[$i] = $a[$i] + $b[$i]; }</code> </pre><br><br>  Hyper is used on various operators, including user-defined operators: <br><br><pre> <code class="perl hljs"> <span class="hljs-comment"><span class="hljs-comment">#    @xyz  1 @xyz¬ª++ #    @x      @a  @b @x = @a ¬ªmin¬´ @b;</span></span></code> </pre><br><br>  Instead of arrays, you can use scalars: <br><br><pre> <code class="perl hljs"> <span class="hljs-comment"><span class="hljs-comment">#    @a  3.5 @b = @a ¬ª*¬ª 3.5; #    @x  $m   $b @y = @x ¬ª*¬ª $m ¬ª+¬ª $b; #    @x @inv = 1 ¬´/¬´ @x; #   @last @first   @full @full = (@last ¬ª~¬ª ', ') ¬ª~¬´ @first;</span></span></code> </pre><br><br>  Of course, reduce and hyper can be combined: <br><br><pre> <code class="perl hljs"> <span class="hljs-comment"><span class="hljs-comment">#    @x $sumsq = [+] ( @x ¬ª**¬ª 2);</span></span></code> </pre><br><br>  There are many more metaoperators, for example X (cross), R (reverse), S (sequential).  Generally speaking, operators like + =, * =, ~ = are already meta-forms of operators, to which an equal sign is added: <br><br><pre> <code class="perl hljs"> $a += <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">#  ,   $a = $a + 5; $b //= 7; #  ,   $b = $b // 7; $c min= $d; #  ,   $c = $c min $d;</span></span></code> </pre><br><br>  We leave in the hyperspace <br><br>  Before we continue exploring metaoperators, we introduce the auxiliary function lsay, which displays nicely formatted lists.  Defining it through our you can then use it in the REPL environment: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">our</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lsay</span></span></span><span class="hljs-function">(@</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">) </span></span>{ @a.perl.say }</code> </pre><br><br>  Let's start with a simple one: add two lists of the same length: <br><br><pre> <code class="bash hljs">&gt; lsay (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1, 3, 1) [4, 3, 6, 5] &gt; lsay (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1, 3, 1) [4, 3, 6, 5]</code> </pre><br><br>  If the lengths of the lists are the same, both entries are identical.  But if their lengths are different: <br><br><pre> <code class="bash hljs">&gt; lsay (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1) [4, 3, 4, 5] &gt; lsay (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br><br>  The rule is this: what the pointed end of the hyperoperator indicates may be extended if it is shorter than what is on the other end of it.  Renewal occurs by repeating the last item in the list.  What the ‚Äúblunt‚Äù end indicates is not subject to extension.  All combinations are possible, for example, when only the left side (&lt;&lt; + &lt;&lt;), only the right (&gt;&gt; + &gt;&gt;), both sides (&lt;&lt; + &gt;&gt;), or neither side (&gt;&gt; + &lt;&lt; ).  Single scalars can also be extended: <br><br><pre> <code class="bash hljs">&gt; lsay (1, 2, 3, 4) &gt;&gt;+&gt;&gt; 2 [3, 4, 5, 6] &gt; lsay 3 &lt;&lt;+&lt;&lt; (1, 2, 3, 4) [4, 5, 6, 7]</code> </pre><br><br>  This is the basics of using hyperoperators.  They can also be used with postfix and prefix operators: <br><br><pre> <code class="bash hljs">&gt; lsay ~&lt;&lt;(1, 2, 3, 4) [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>] &gt; my @a= (1, 2, 3, 4); @a&gt;&gt;++; lsay @a; [2, 3, 4, 5]</code> </pre><br><br>  It is also possible: <br><br><pre> <code class="bash hljs">&gt; lsay (0, pi/4, pi/2, pi, 2*pi)&gt;&gt;.sin [0, 0.707106781186547, 1, 1.22464679914735e-16, -2.44929359829471e-16] &gt; lsay (-1, 0, 3, 42)&gt;&gt;.Str [<span class="hljs-string"><span class="hljs-string">"-1"</span></span>, <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"42"</span></span>]</code> </pre><br><br>  In this case, &gt;&gt;.  calls a method on each item in the list. <br><br>  If you want to write <a href="https://habrahabr.ru/users/array/" class="user_link">array</a> &gt;&gt;. Say, then it is better not to.  The use of hyperoperators implies that the operation can be performed in parallel, and the order of operations on the list is not fixed. <br><br>  Hyper operators work not only with built-in operators.  You can define your operator, and they will also work with him.  They should work (but do not work yet) with in-place operators - for example, the instruction @a &gt;&gt; / = &gt;&gt; 2 should divide the entire array into 2. They work with multi-dimensional lists, trees and hashes.  An interesting example of the use of hyperoperators is the Vector class. <br>  <a href="">github.com/LastOfTheCarelessMen/Vector/blob/master/lib/Vector.pm</a> <br>  which represents the implementation of multidimensional vectors without a single cycle. <br><br><h4>  Cycles </h4><br>  Any programmer knows how useful cycles are.  A common example of using loops is the foreach loop for traversing arrays.  We used this keyword in Perl 5, although it was possible to use for, more reminiscent of style C. <br><br>  Perl 6 is different. <br><br>  Now for the passage through the lists used for.  foreach is gone, and the word loop is used for C-style.  For now, we will only look at for, which is a new, flexible, and powerful language property: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> { .say }</code> </pre><br><br>  Immediately noticeable lack of brackets around the list.  Typically, Perl 6 needs fewer brackets than Perl 5. The default variable, as in Perl 5, is $ _.  Calling a method without specifying a variable means calling the method $ _, that is, in our case, $ _. Say.  You cannot use say with no arguments ‚Äî you need to write either .say or $ _. Say <br><br>  Instead of a simple block, you can use a ‚Äúpointed‚Äù block, which allows you to specify the name of a loop variable: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; $i { $i.say }</code> </pre><br><br>  The ‚Äúpointed‚Äù block resembles an anonymous procedure, it just does not catch exceptions.  And if you write a return inside such a block, it will exit from the whole procedure that caused it.  Such blocks take more than one parameter.  And what happens if you write this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; $i, $j { <span class="hljs-string"><span class="hljs-string">"$i, $j"</span></span>.say }</code> </pre><br><br>  When you start you will receive: <br><br><pre> <code class="bash hljs">1 2 3 4</code> </pre><br><br>  That is, you went through the list, going through two elements at a time.  This works with any number of parameters (at least one, and in its absence $ _ is implied).  Well, what about creating a list that we follow?  Of course, you can use an array variable: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @array { .say }</code> </pre><br><br>  But in simple cases, we can instead use a map: <br><br><pre> <code class="perl hljs">@array.map: *.say;</code> </pre><br><br>  Or a hyperoperator, if the sequence is not important to us: <br><br><pre> <code class="perl hljs">@array¬ª.say;</code> </pre><br><br>  But we are not talking about that now.  You can create a list through the interval operator &lt;..&gt;: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">4</span></span> { .say }</code> </pre><br><br>  It is often necessary to create a list of $ n numbers, starting with 0. One would write 0 .. $ n-1 or use the constructor of spaces 0 .. ^ $ n, but in Perl 6 there is a shorter way using the perfix ^: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^<span class="hljs-number"><span class="hljs-number">4</span></span> { .say }</code> </pre><br><br>  At the output we get: <br><br><pre> <code class="bash hljs">0 1 2 3</code> </pre><br><br>  The reasons for using cycles in the style of C - you need to know which of the list elements we are in now, or we need to go through several arrays at the same time.  Perl 6 also has a short entry for this through the Z (zip) operator: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @array1 Z @array2 -&gt; $one, $two { ... }</code> </pre><br><br>  If both arrays have the same length, $ one passes through all the elements of @ array1, and $ two passes through all the corresponding elements of @ array2.  If the length is different, the cycle stops, reaching the end of the shortest.  Thus, you can include an array index in a loop like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^Inf Z @array -&gt; $index, $item { ... }</code> </pre><br><br>  If you don‚Äôt like endless lists: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^@array.elems Z @array -&gt; $index, $item { ... }</code> </pre><br><br>  which leads to the same result, but the most elegant option is <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @array.kv -&gt; $index, $item { ... }</code> </pre><br><br>  <a href="https://habrahabr.ru/users/array/" class="user_link">array</a> .kv returns keys and values, and for an array, keys are just indices of elements. <br><br>  Thus, you can go through at least four arrays at the same time: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @one Z @two Z @three Z @four -&gt; $one, $two, $three, $four { ... }</code> </pre><br><br><h4>  Limitations of parameters and .comb </h4><br>  As static types limit variable values, so also constraints (constraints) allow regulating the work of procedures and methods.  In many PLs, it is necessary to pass parameters to the procedure and check the values ‚Äã‚Äãobtained.  With restrictions, you can check directly during the announcement.  Example: we do not need even numbers.  In Perl 5, you could write: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">very_odd</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $odd = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> ($odd % <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span>; } <span class="hljs-comment"><span class="hljs-comment">#     }</span></span></code> </pre><br><br>  In Perl 6, you can make it easier: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">very_odd</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-function"> </span></span>{$odd % <span class="hljs-number"><span class="hljs-number">2</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">#     }</span></span></code> </pre><br><br>  If you call very_odd with an even parameter, you get an error.  For convenience, you can reload procedures, and work with any numbers: <br><br><pre> <code class="perl hljs">multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">very_odd</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-function"> </span></span>{$odd % <span class="hljs-number"><span class="hljs-number">2</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">#     } multi sub very_odd(Int $odd) { return Bool::False; }</span></span></code> </pre><br><br>  Parameter restrictions are conveniently used in pairs with the .comb method.  What is .comb?  (comb - comb).  In the case of hair and a comb, you separate the strands and put them on your head.  .comb is the opposite of .split.  If the latter method allows you to split a line into those elements that you do not need, then .comb separates it into the necessary elements.  Here is a simple example: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Perl 6 Advent"</span></span>.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;alpha&gt;/</span></span>).join(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Perl 6 Advent"</span></span>.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;alpha&gt;+/</span></span>).join(<span class="hljs-string"><span class="hljs-string">'|'</span></span>);</code> </pre><br><br>  The first line gives out ‚ÄúP | e | r | l | A | d | v | e | n | t‚Äù: it takes each letter and puts it into a temporary array, which is then combined through ‚Äú|‚Äù.  The second line is similar, only there is captured the largest possible number of letters in a row, and the result is ‚ÄúPerl | Advent‚Äù. <br><br>  But .comb is much more powerful.  After you have brushed the string, you can manipulate the strands.  If you have a string of ASCII characters, you can use hyper operators to replace each piece with an ASCII equivalent: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"5065726C36"</span></span>.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;xdigit&gt;**2/</span></span>)¬ª.fmt(<span class="hljs-string"><span class="hljs-string">"0x%s"</span></span>)¬ª.chr <span class="hljs-comment"><span class="hljs-comment">#  "P erl 6"</span></span></code> </pre><br><br>  You can write this through the .map method: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"5065726C36"</span></span>.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;xdigit&gt;**2/</span></span>).map: { <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span> <span class="hljs-string"><span class="hljs-string">'0x'</span></span> ~ $_ } ; <span class="hljs-comment"><span class="hljs-comment">#  "P erl 6"</span></span></code> </pre><br><br>  As usual, there is more than one way to do something. <br><br>  But the task is more complicated: I present to you the ancient <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B8%25D1%2584%25D1%2580_%25D0%25A6%25D0%25B5%25D0%25B7%25D0%25B0%25D1%2580%25D1%258F">cipher of Caesar</a> through the limitations of the parameters, .comb and .map <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> v6; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate_one</span></span></span></span>( Str $c where { $c.chars == 1 }, Int $n ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $c !~~ /&lt;alpha&gt;/; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $out = $c.ord + $n; $out -= 26 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $out &gt; ($c eq $c.uc ?? 'Z'.ord !! 'z'.ord); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $out.chr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span></span>(Str $<span class="hljs-keyword"><span class="hljs-keyword">s</span></span> where {$s.chars}, Int $n = 3) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($s.comb.map: { rotate_one( $_, $n % 26 ) }).join( '' ); } <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">":\n$*PROGRAM_NAME  _"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> @*ARGS == <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Str $mess = @*ARGS[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Int $rotate = @*ARGS[<span class="hljs-number"><span class="hljs-number">1</span></span>].Int; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">qq|"$mess"  $rotate    "{rotate($mess,$rotate)}".|</span></span>;</code> </pre><br><br><h4>  Beautiful arguments and parameters </h4><br>  In Perl 5, working with parameters is built in @_: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span></span>{ [+] @_ } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> sum <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment"># 123</span></span></code> </pre><br><br>  [+] - instruction from Perl 6, but if we write <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i += $_ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @_; $i</code> </pre><br><br>  then it will work in Perl 5. In Perl 6, just like in Perl 5, the parameters passed to the procedure are accessible through the @_ array.  The system is very flexible and does not impose restrictions on the parameters.  But this is a rather dreary process, especially if you need to check: <br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grade_essay</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($essay, $grade) = @_; <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">'     Essay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $essay ~~ Essay; <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">'      0  5'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $grade ~~ Int &amp;&amp; $grade ~~ <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span>; %grades{$essay} = $grade; }</code> </pre><br><br>  In Perl 5, you had to write isa instead of ~~, and $ grades instead of% grades, but that's all.  Now take a look and be terrified how many manual checks would have to be carried out.  Do you feel?  That's it. <br><br>  In Perl 5, various convenient modules with CPAN do this, for example, Sub :: Signatures or MooseX :: Declare. <br><br>  Other methods are available in Perl 6.  For example, this example can be written as: <br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grade_essay</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Essay</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">essay</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grade</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-function"> 0..5) </span></span>{ %grades{$essay} = $grade; }</code> </pre><br><br>  Another thing, and without any third-party modules.  Sometimes it is convenient to set default values: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entreat</span></span></span><span class="hljs-function">($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-function"> = ' !', $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> = 1) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $message <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^$times; }</code> </pre><br><br>  These values ‚Äã‚Äãdo not have to be constants, but they can also include the previous parameters: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_tag</span></span></span><span class="hljs-function"> ($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">, $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endtag</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matching_tag</span></span></span><span class="hljs-function">($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">) ) </span></span>{...}</code> </pre><br><br>  If the default value is not set, mark the parameter as an optional question mark: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate</span></span></span></span>(PowerPlant $plant, Str $comment?) { $plant.initiate_shutdown_sequence(); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $comment <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $comment; }</code> </pre><br><br>  What is especially cool is that the parameters can be referenced by name, and transmitted in any order.  I could never remember the sequence of parameters: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_line</span></span></span></span>($x1, $y1, $x2, $y2) { ... } draw_line($x1, $y1, $x2, $y2); <span class="hljs-comment"><span class="hljs-comment"># ,     . draw_line($x1, $x2, $y1, $y2); # ! :-/</span></span></code> </pre><br><br>  And so you can refer to them by name: <br><br><pre> <code class="perl hljs"> draw_line(:x1($x1), :y1($y1), :x2($x2), :y2($y2)); <span class="hljs-comment"><span class="hljs-comment">#  draw_line(:x1($x1), :x2($x2), :y1($y1), :y2($y2)); #   !</span></span></code> </pre><br><br>  The colon means "now there will be a named parameter", and all together there will be: parameter_name ($ transferred_variable).  When the names of parameters and variables are the same, you can use a brief entry: <br><br><pre> <code class="perl hljs"> draw_line(:$x1, :$y1, :$x2, :$y2); <span class="hljs-comment"><span class="hljs-comment"># ! draw_line(:$x1, :$x2, :$y1, :$y2); #   !</span></span></code> </pre><br><br>  If the author of any API wants everyone to use the named parameters, he will need to specify colons in the function declaration: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_line</span></span></span><span class="hljs-function">(:$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-function">, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y1</span></span></span><span class="hljs-function">, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-function">, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y2</span></span></span><span class="hljs-function"> ) </span></span>{ ... } <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br><br>  Named parameters are optional by default.  In other words, the top example is equivalent to the following: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_line</span></span></span><span class="hljs-function">(:$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-function">?, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y1</span></span></span><span class="hljs-function">?, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-function">?, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y2</span></span></span><span class="hljs-function">?) </span></span>{ ... } <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br><br>  If you need to make the parameters mandatory, use the exclamation mark: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_line</span></span></span><span class="hljs-function">(:$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-function">!, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y1</span></span></span><span class="hljs-function">!, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-function">!, :$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y2</span></span></span><span class="hljs-function">!) </span></span>{ ... } <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br><br>  Now they need to pass. <br><br>  What about a variable number of parameters?  Easy: make an array parameter preceded by an asterisk: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(*@</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terms</span></span></span><span class="hljs-function">) </span></span>{ [+] @terms } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> sum <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment"># 123</span></span></code> </pre><br><br>  It turns out that if you do not specify a constraint on the parameters of a future function, then it receives the default constraints * @_.  What it means is no constraint, or emulation of Perl 5 behavior. <br><br>  But the array with the star receives only the parameters in a certain order.  If you need to pass named parameters, use the hash: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect_nonfoos</span></span></span></span>(:$foo!, *%nonfoos) { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> " 'foo'   ", %nonfoos.keys.fmt("'%<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>; } detect_nonfoos(:foo(1), :bar(2), :baz(3)); <span class="hljs-comment"><span class="hljs-comment">#  'foo'   'bar', 'baz'</span></span></code> </pre><br><br>  It is worth noting that you can pass named parameters in the manner of a hash: <br><br><pre> <code class="perl hljs"> detect_nonfoos(<span class="hljs-string"><span class="hljs-string">foo =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">bar =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">baz =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">#  'foo'   'bar', 'baz'</span></span></code> </pre><br><br>  Another difference from Perl 5: by default, parameters are read-only: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increase_by_one</span></span></span></span>($n) { ++$n } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $value = 5; increase_by_one($value); <span class="hljs-comment"><span class="hljs-comment"># </span></span></code> </pre><br><br>  One of the reasons is efficiency.  Optimizers like read-only variables.  The second is the cultivation of correct habits in the programmer.  Functional programming is good for the optimizer and for the soul. <br><br>  To make the top example work, you need to write it like this: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increase_by_one</span></span></span></span>($n is rw) { ++$n } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $value = 5; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> increase_by_one($value); <span class="hljs-comment"><span class="hljs-comment"># 6</span></span></code> </pre><br><br>  Sometimes this is suitable, but sometimes it is easier to change the copy of the parameter: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_name</span></span></span></span>($first, $middle is copy, $<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>) { $middle .= <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(0, 1); <span class="hljs-string"><span class="hljs-string">"$first $middle. $last"</span></span> }</code> </pre><br><br>  The original variable will remain unchanged. <br><br>  In Perl 6, passing an array or hash does not align the default arguments.  Instead, to force alignment, use ‚Äú|‚Äù: <br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list_names</span></span></span></span>($<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>, $z) { "$<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, $<span class="hljs-keyword"><span class="hljs-keyword">y</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $z" } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @ducklings = &lt;huey dewey louie&gt;; try { list_names(@ducklings); } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $!; <span class="hljs-comment"><span class="hljs-comment"># '  ; #  1,  3' say list_names(|@ducklings); # 'huey, dewey and louie'</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the hash is aligned, its contents will be transferred in the form of named parameters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to arrays and hashes, it is possible to transfer blocks of code:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_inorder</span></span></span></span>(TreeNode $n, &amp;action) { traverse_inorder($n.left, &amp;action) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $n.left; action($n); traverse_inorder($n.right, &amp;action) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $n.right; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three characters act as type limiters: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ Array (positional) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% Hash (associative) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; Code (called) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ is a parameter without restrictions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not fall into the trap, trying to assign a type twice - through the name of the type and through the symbol:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">) </span></span>{ ... } <span class="hljs-comment"><span class="hljs-comment"># ,        sub f( @a) { ... } # ,      sub f(Int @a) { ... } #   </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you've read this far, you deserve another one-liner: </font></font><br><br><pre> <code class="bash hljs"> $ perl6 -e <span class="hljs-string"><span class="hljs-string">'.fmt("%b").trans("01" =&gt; " #").say for &lt;734043054508967647390469416144647854399310&gt;.comb(/.**7/)'</span></span> <span class="hljs-comment"><span class="hljs-comment">### ## ### # # ## # ## # # ### # # ## # #### # #### # # # # # # # # # # # ## # ## ###</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regular history </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A long time ago, in the not-so-distant kingdom, a student of a Perl 6 programmer named Tim worked on the simple problem of parsing. </font><font style="vertical-align: inherit;">His boss, Mr. C, asked him to parse logs containing inventory information to make sure that they contain only valid lines. </font><font style="vertical-align: inherit;">Valid lines should look like this:</font></font><br><br><pre> <code class="bash hljs"> &lt; &gt; &lt;&gt; &lt; &gt; &lt;&gt;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The student, a little familiar with the regulars, wrote a beautiful regular book to determine the allowable stitches. </font><font style="vertical-align: inherit;">The code looked like this:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $line ~~ <span class="hljs-regexp"><span class="hljs-regexp">/ ^^ \d+ \s+ \d+ \s+ \S+ \s+ \N* $$ /</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ~~ operator checks the regularity on the right with respect to the scalar on the left. In the regular calendar, ^^ means the beginning of a line, \ d + - at least one digit, \ S + - at least one non-whitespace character, \ N * any number of characters that are not line breaks, \ s + spaces and $$ line ending. In Perl 6, these characters can be separated by spaces to improve readability. And everything was great. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But then Mr. C decided that it would be nice to extract information from the logs, and not just check it. Tim thought there was no problem and you just need to add some exciting brackets. So he did:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $line ~~ <span class="hljs-regexp"><span class="hljs-regexp">/ ^^ (\d+) \s+ (\d+) \s+ (\S+) \s+ (\N*) $$ /</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a match, the contents of each pair of brackets is available through the entry $ / [0], $ [1], etc. Or through the variables $ 0, $ 1, $ 2, etc. Tim was happy, Mr. C too. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But then it turned out that on some lines the color was not separated from the description. Such lines looked as follows:</font></font><br><br><pre> <code class="bash hljs"> &lt;part number&gt; &lt;quantity&gt; &lt;description&gt; (&lt;color&gt;)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time in the description could be any number of characters with spaces. </font><font style="vertical-align: inherit;">"Hedgehog-korzhiki," thought Tim, "the task has just become very complicated!" </font><font style="vertical-align: inherit;">But Tim knew where to ask for advice. </font><font style="vertical-align: inherit;">He quickly went to irc.freenode.org on channel # perl6 and asked there. </font><font style="vertical-align: inherit;">Someone advised to name parts of the regular season to facilitate working with them and then use alternation to catch all possible alternatives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, Tim tried to call parts of the regular season. </font><font style="vertical-align: inherit;">Looking at the description of regulars in Perl 6, Tim found that he could make this entry:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $line ~~ <span class="hljs-regexp"><span class="hljs-regexp">/ ^^ $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+ $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*) $$ /</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then, after finding it, the pieces of the regular list are available through the match object or the variables $, $, $ and $. </font><font style="vertical-align: inherit;">It was easy, and Tim cheered up. </font><font style="vertical-align: inherit;">Then he added an alternation so that both variants of the lines could pass the test:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $line ~~ <span class="hljs-regexp"><span class="hljs-regexp">/ ^^ $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+ [ | $&lt;description&gt;=(\N*) \s+ '(' $&lt;color&gt;=(\S+) ')' | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*) ] $$ /</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To isolate the alternation from the rest of the regular season, Tim surrounded it with grouping square brackets. These brackets separate the part of the regular schedule, much like round ones, but do not return the separated parts into $ 0 variables, etc. Since he needed to catch the parentheses in the file, Tim used another handy feature of Perl 6: what is enclosed in quotes is searched in the text as it is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tim was inspired. He showed the code to Mr. C, and he, too, was inspired! ‚ÄúWell done, Tim!‚Äù Said Mr. S. Everyone was happy, and Tim glowed with pride. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, he then critically looked at his work. Some lines had the color set to ‚Äú(color)‚Äù or ‚Äú(color)‚Äù or ‚Äú(color)‚Äù. As a result, the regulars ranked such colors as the description, and the $ variable did not set at all.</font></font> It was unacceptable.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tim rewrote the regular season by adding \ s * to it: </font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> $line ~~ <span class="hljs-regexp"><span class="hljs-regexp">/ ^^ $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+ [ | $&lt;description&gt;=(\N*) \s+ '(' \s* $&lt;color&gt;=(\S+) \s* ')' | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*) ] $$ /</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It worked, but the regular season began to look awkward. </font><font style="vertical-align: inherit;">And Tim turned back to channel # perl6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, a user named PerlJam said: ‚ÄúWhy don't you put your regular season in a grammar? </font><font style="vertical-align: inherit;">After all, you practically do this by assigning each piece its own variable. ‚Äù </font><font style="vertical-align: inherit;">‚ÄúShchito?‚Äù Tim thought. </font><font style="vertical-align: inherit;">He had no idea what PerlJam was talking about. </font><font style="vertical-align: inherit;">After a short conversation, Tim seemed to understand what he meant, thanked the user and sat down to write the code. </font><font style="vertical-align: inherit;">This time the regulars disappeared and turned into a grammar. </font><font style="vertical-align: inherit;">Here is how she looked:</font></font><br><br><pre> <code class="perl hljs">grammar Inventory { regex product { \d+ } regex quantity { \d+ } regex color { \S+ } regex description { \N* } regex TOP { ^^ &lt;product&gt; \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ &lt;quantity&gt; \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ [ | &lt;description&gt; \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ <span class="hljs-string"><span class="hljs-string">'('</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>* &lt;color&gt; \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>* <span class="hljs-string"><span class="hljs-string">')'</span></span> | &lt;color&gt; \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ &lt;description&gt; ] $$ } } <span class="hljs-comment"><span class="hljs-comment"># ...  ,    ,   : next unless Inventory.parse($line);</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúWell,‚Äù Tim thought, ‚Äúthis time everything is organized well.‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each of the past variables has evolved into its regular grammar. </font><font style="vertical-align: inherit;">In the Perl 6 regular, the named regulars are added to the check by enclosing them in angle brackets. </font><font style="vertical-align: inherit;">The TOP special regular is used when calling Grammar.parse with a scalar. </font><font style="vertical-align: inherit;">And the behavior is the same - the found part of the expression is stored in the named variable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And although there is no limit to perfection, Tim and Mr. S were very pleased with the result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The end!</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes, attributes, methods, and other </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to write a class in a new Perl 6 object model: </font></font><br><br><pre> <code class="perl hljs">class Dog { has $.name; method bark($times) { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"w00f! "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> $times; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start with the class keyword. </font><font style="vertical-align: inherit;">For those who know Perl, 5 class is somewhat similar to package, but out of the box gives a bunch of semantic features. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We then used the has keyword, declaring an attribute that has an accessor method. </font><font style="vertical-align: inherit;">The point between the $ and the name is tvigil, which reports on the peculiarities of access to the variable. </font><font style="vertical-align: inherit;">Twidgill-point means "attribute + accessor". </font><font style="vertical-align: inherit;">More options:</font></font><br><br><pre> <code class="perl hljs">has $!name; <span class="hljs-comment"><span class="hljs-comment"># ,     has $.name is rw; #    </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the method is declared through the keyword method. </font><font style="vertical-align: inherit;">Method - as a procedure, only with its entry in the class table of methods. </font><font style="vertical-align: inherit;">It is available for calling via $ self. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All classes inherit a default constructor named new, which assigns named parameters to attributes. </font><font style="vertical-align: inherit;">To get an instance of a class, you can write this:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fido = Dog.new(<span class="hljs-string"><span class="hljs-string">name =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Fido'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $fido.name; <span class="hljs-comment"><span class="hljs-comment"># Fido $fido.bark(3); # w00f! w00f! w00f!</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calling methods is done with a dot instead of an arrow in Perl 5. It is 50% shorter and familiar to programmers of other languages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there is inheritance. </font><font style="vertical-align: inherit;">This is how we can create a puppy class:</font></font><br><br><pre> <code class="perl hljs">class Puppy is Dog { method bark($times) { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"yap! "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> $times; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a delegation: </font></font><br><br><pre> <code class="perl hljs">class DogWalker { has $.name; has Dog $.dog handles (<span class="hljs-string"><span class="hljs-string">dog_name =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'name'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $bob = DogWalker.new(<span class="hljs-string"><span class="hljs-string">name =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>, <span class="hljs-string"><span class="hljs-string">dog =&gt;</span></span> $fido); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $bob.name; <span class="hljs-comment"><span class="hljs-comment"># Bob say $bob.dog_name; # Fido</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we declare that calls to the dog_name method of the DogWalker class are redirected to the name method of the Dog class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under the layers of all this beauty there is a meta model. </font><font style="vertical-align: inherit;">Classes, attributes, and methods are represented via meta objects. </font><font style="vertical-align: inherit;">This is how you can work with objects at runtime:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Dog.^methods(:<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>) -&gt; $meth { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Dog has a method "</span></span> ~ $meth.name; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The. ^ Operator is an option., But it calls a metaclass - an object representing the class. </font><font style="vertical-align: inherit;">Here we ask him to give a list of methods defined in the class (: local excludes methods inherited from other classes). </font><font style="vertical-align: inherit;">And we get not just a list of names, but a list of Method objects. </font><font style="vertical-align: inherit;">We could call the method itself in this way, but in this case we just print its name. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-programmers who want to extend Perl 6 syntax will be thrilled to learn that using the method keyword actually results in a call to add_method from the meta class. </font><font style="vertical-align: inherit;">Therefore, in Perl 6 there is not only a powerful syntax for describing objects, but also the ability to extend it for those cases that we have not yet envisaged.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modules and exports </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To create a library in Perl 6, you need to use the module keyword: </font></font><br><br><pre> <code class="perl hljs">module Fancy::Utilities { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lolgreet</span></span></span><span class="hljs-function">($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">who</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"O HAI "</span></span> ~ <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span> $who; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Put it in the Fancy / Utilities.pm file somewhere in $ PERL6LIB, and then you can use it like this: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Fancy::Utilities; Fancy::Utilities::lolgreet(<span class="hljs-string"><span class="hljs-string">'Tene'</span></span>);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not particularly comfortable. </font><font style="vertical-align: inherit;">As in Perl 5, it is possible to designate that some things should be available within the scope of the code that loads this module. </font><font style="vertical-align: inherit;">There is a syntax for this:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment"># Utilities.pm module Fancy::Utilities { sub lolgreet($who) is export { say "O HAI " ~ uc $who; } } # foo.pl use Fancy::Utilities; lolgreet('Jnthn');</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Characters marked ‚Äúis export‚Äù are exported by default. </font><font style="vertical-align: inherit;">You can also note that characters are exported within a named group:</font></font><br><br><pre> <code class="perl hljs">module Fancy::Utilities { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lolgreet</span></span></span><span class="hljs-function">($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function">(:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lolcat</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"O HAI "</span></span> ~ <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span> $who; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nicegreet</span></span></span><span class="hljs-function">($</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function">(:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEFAULT</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Good morning, $who!"</span></span>; <span class="hljs-comment"><span class="hljs-comment"># Always morning? } sub shortgreet is export(:greet) { say "Hi!"; } sub lolrequest($item) is export(:lolcat) { say "I CAN HAZ A {uc $item}?"; } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can use these tags in the upload code to choose what to import: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Fancy::Utilities; <span class="hljs-comment"><span class="hljs-comment">#   DEFAULTs use Fancy::Utilities :greet, :lolcat; use Fancy::Utilities :ALL; #  ,   </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multi-procedures are exported by default, they can only be given labels at will: </font></font><br><br><pre> <code class="perl hljs">multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Str</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">who</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Good morning, $who!"</span></span> } multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">() </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span> } multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lolcat</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">who</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"O HAI "</span></span> ~ $who.name }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes are a specialization of modules, so you can export something from them too. </font><font style="vertical-align: inherit;">In addition, you can export a method to use it as a multi-procedure. </font><font style="vertical-align: inherit;">For example, the following code exports the close method from the IO class so that it can be called as ‚Äúclose ($ fh);‚Äù</font></font><br><br><pre> <code class="perl hljs">class IO { ... method <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() is export { ... } ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perl 6 also supports importing characters from libraries by name. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Junctions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Among the new features of Perl 6, I like combining the most. </font><font style="vertical-align: inherit;">I imagine not all options for their use, but I know a few handy tricks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unions are variables that can contain several values ‚Äã‚Äãat once. </font><font style="vertical-align: inherit;">It sounds weird, but let's take an example. </font><font style="vertical-align: inherit;">Suppose you need to check the variable for compliance with one of the options values:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $var == <span class="hljs-number"><span class="hljs-number">3</span></span> || $var == <span class="hljs-number"><span class="hljs-number">5</span></span> || $var == <span class="hljs-number"><span class="hljs-number">7</span></span> { ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never loved that bullshit. </font><font style="vertical-align: inherit;">Too many repetitions. </font><font style="vertical-align: inherit;">Using the any association, this can be written as:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $var == any(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) { ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the core of the language is the concept of ‚Äúautomatic separation of associations into threads‚Äù (junctive auto-reading). </font><font style="vertical-align: inherit;">This means that you can almost always pass a join to where only one value is expected. </font><font style="vertical-align: inherit;">The code will be executed for all members of the union, and the result will be a combination of all the results obtained. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the last example, == runs for each element of the union and compares it with $ var. </font><font style="vertical-align: inherit;">The result of each comparison is written to the new any union, which is then evaluated in a boolean context in an if statement. </font><font style="vertical-align: inherit;">In a boolean context, an any union is true if any of its members is true, so if $ var matches any of the values ‚Äã‚Äãof the union, the test will be passed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can save code and looks pretty nice. </font><font style="vertical-align: inherit;">There is another way to write the any union, which can be constructed through the operator |:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $var == <span class="hljs-number"><span class="hljs-number">3</span></span>|<span class="hljs-number"><span class="hljs-number">5</span></span>|<span class="hljs-number"><span class="hljs-number">7</span></span> { ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you need to invert the test results, a join variant called none is used: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $var == none(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) { ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you might guess, none in a boolean context is true only if none of its elements is true. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic threading works in other cases:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $j = any(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $k = $j + <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What will happen? </font><font style="vertical-align: inherit;">By analogy with the first example, $ k will have the value any (3, 4, 5). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Associations also work with smart search. </font><font style="vertical-align: inherit;">There are special types of associations that are well suited for this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose you have a text string and you need to find out if it matches all the regulars from the set:</font></font><br><br><pre> <code class="perl hljs">$string ~~ <span class="hljs-regexp"><span class="hljs-regexp">/&lt;first&gt;/</span></span> &amp; <span class="hljs-regexp"><span class="hljs-regexp">/&lt;second&gt;/</span></span> &amp; <span class="hljs-regexp"><span class="hljs-regexp">/&lt;third&gt;/</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the regulars first, second and third must be defined. </font><font style="vertical-align: inherit;">Like the |, &amp; operator that creates the joins, but in this case all the joins will be true if all their members are also true. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The beauty of associations is that they can be passed to almost any function of any library, and this function does not necessarily know that these are associations (but there is an opportunity to recognize them and work with them somehow in a special way). </font><font style="vertical-align: inherit;">If you have a function that makes a smart comparison of something to a value, you can pass it as a union. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are still useful things that can be turned with the help of associations. </font><font style="vertical-align: inherit;">Is the value in the list:</font></font><br><br><pre> <code class="perl hljs">any(@list) == $value</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lists work with associations easily and naturally. </font></font> For example: <br><br><pre> <code class="perl hljs">all(@list) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">#      ? all(@a) == any(@b); #     @a   @b?</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rational Fractions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl 6 supports rational fractions, which are created in a simple way - dividing one whole by another. </font><font style="vertical-align: inherit;">To see something unusual is difficult here:</font></font><br><br><pre> <code class="bash hljs">&gt; say (3/7).WHAT Rat() &gt; say 3/7 0.428571428571429</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rat is converted to a string by representing a number as a record with a decimal point. </font><font style="vertical-align: inherit;">But Rat uses an exact internal representation, and not an approximate floating point content like Num:</font></font><br><br><pre> <code class="bash hljs">&gt; say (3/7).Num + (2/7).Num + (2/7).Num - 1; -1.11022302462516e-16 &gt; say 3/7 + 2/7 + 2/7 - 1 0</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to find out what is happening inside the Rat number is using the built-in .perl method. </font><font style="vertical-align: inherit;">It returns a human-readable string, which through eval turns into the original object:</font></font><br><br><pre> <code class="bash hljs">&gt; say (3/7).perl 3/7</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can select Rat components: </font></font><br><br><pre> <code class="bash hljs">&gt; say (3/7).numerator 3 &gt; say (3/7).denominator 7 &gt; say (3/7).nude.perl [3, 7]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All standard numeric operations work with Rat. </font><font style="vertical-align: inherit;">Arithmetic operations with Rat at the output, if possible, also give Rat, and if it is impossible, Num:</font></font><br><br><pre> <code class="bash hljs">&gt; my <span class="hljs-variable"><span class="hljs-variable">$a</span></span> = 1/60000 + 1/60000; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.WHAT; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.perl Rat() 3.33333333333333e-05 1/30000 &gt; my <span class="hljs-variable"><span class="hljs-variable">$a</span></span> = 1/60000 + 1/60001; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.WHAT; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.perl Num() 3.33330555601851e-05 3.33330555601851e-05 &gt; my <span class="hljs-variable"><span class="hljs-variable">$a</span></span> = cos(1/60000); say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.WHAT; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>; say <span class="hljs-variable"><span class="hljs-variable">$a</span></span>.perl Num() 0.999999999861111 0.999999999861111</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Num has a trendy method that gives out Rat of the given approximation (by default, 1e-6): </font></font><br><br><pre> <code class="bash hljs">&gt; say 3.14.Rat.perl 157/50 &gt; say pi.Rat.perl 355/113 &gt; say pi.Rat(1e-10).perl 312689/99532</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> According to the specification, the numbers written in the source code in the form of decimal, are represented in the form of Rat. </font></font><br><br><pre> <code class="bash hljs">&gt; say 1.75.WHAT Rat() &gt; say 1.75.perl 7/4 &gt; say 1.752.perl 219/125</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .pick </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another Perl 6 innovation is the .pick method, which allows you to select a random list item. </font><font style="vertical-align: inherit;">In Perl 5, you could do it like this:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @dice = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $index = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> @dice); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $dice[$index] . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; &gt; <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Perl 6 it will be easier, moreover, you can immediately select several elements: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @dice = <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @dice.pick(<span class="hljs-number"><span class="hljs-number">2</span></span>).join(<span class="hljs-string"><span class="hljs-string">" "</span></span>); &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, let's see what kind of attack I get if I throw out 10 d6s ... </font></font><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @dice = <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @dice.pick(<span class="hljs-number"><span class="hljs-number">10</span></span>).join(<span class="hljs-string"><span class="hljs-string">" "</span></span>); &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that .pick corresponds to its name - if something is removed from the list, then it no longer appears in the list. </font><font style="vertical-align: inherit;">If you need to allow this item to be selected again, use the word: replace</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @dice = <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @dice.pick(<span class="hljs-number"><span class="hljs-number">10</span></span>, :replace).join(<span class="hljs-string"><span class="hljs-string">" "</span></span>); &gt; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The list does not have to contain elements in any particular order. </font><font style="vertical-align: inherit;">Here are the bills from "Monopoly":</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @dice = &lt;<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @dice.pick(<span class="hljs-number"><span class="hljs-number">10</span></span>, :replace).join(<span class="hljs-string"><span class="hljs-string">" "</span></span>); &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But an option for a deck of cards: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> v6; class Card { has $.rank; has $.suit; multi method Str() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.rank ~ $.suit; } } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @deck; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &lt;A <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> TJQ K&gt; -&gt; $rank { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &lt; &gt; -&gt; $suit { @deck.push(Card.new(:$rank, :$suit)); } } <span class="hljs-comment"><span class="hljs-comment"># Shuffle the cards. @deck .= pick(*); say @deck.Str;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does pick (*) do? </font><font style="vertical-align: inherit;">Consider a little later. </font><font style="vertical-align: inherit;">For now, think about how to improve the code for the deck of cards and make the class deck.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Good old switch </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Although the construction is called the ‚Äúswitch operator‚Äù, the keyword is changed to given. </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">given</span></span> $weather { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'sunny'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'! '</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'cloudy'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">' . '</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'rainy'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'   ? '</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'snowy'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'! '</span></span> } default { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">' ,  .'</span></span> } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is only necessary to note that not all blocks when are automatically processed ‚Äî if suddenly several conditions are fulfilled simultaneously, only the first suitable block will be executed. </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">given</span></span> $probability { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> * &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">75</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> * &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">50</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> * &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> * &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'  '</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'  '</span></span> } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If your $ probability will be equal to 0.80, the code will give 'Most likely', and the rest will not give you. If you need several blocks to work, end them with the word continue (and the block-controlling keywords break / continue are renamed to succeed / proceed). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that in the code, the when expression uses both strings and numbers. How does Perl 6 know how to match a given value with a when value, if these things can be completely different types? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the two values ‚Äã‚Äãare processed through the so-called. the clever comparison that was mentioned earlier. A clever comparison, written as $ a ~ ~ $ b, is a trickier version of regulars. If a period is specified, a smart comparison checks to see if the value falls into it. If $ b is a class, or a role, or a subtype, smart comparison will check the types.</font></font> And so on.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For values ‚Äã‚Äãof type Num and Str, their equivalence is checked. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The asterisk passes a clever comparison with anything. </font><font style="vertical-align: inherit;">And default means the same as ‚Äúwhen *‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But here is something unexpected: given and when can be used independently. </font><font style="vertical-align: inherit;">While you are saying your ‚ÄúShield?‚Äù, I will explain to you how this: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">given is a one-time cycle.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">given</span></span> $punch-card { .bend; .fold; .mutilate; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">given here simply sets a topic that is known to perlovikam as $ _. </font><font style="vertical-align: inherit;">And calls to .method methods are equivalent to calling $ _. Method </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when can be used inside any block that specified $ _, explicitly or implicitly:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $scanning; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> $*IN.lines { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> /start/ { $scanning = True } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> /stop/ { $scanning = False } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $scanning { <span class="hljs-comment"><span class="hljs-comment">#  -,    ,   #   ,  'start'  'stop' } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when demonstrates the same behavior as in the given block, i.e. </font><font style="vertical-align: inherit;">skips remaining code in the block after execution. </font><font style="vertical-align: inherit;">In the example above, this means moving to the next line. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another example, with an explicit $ _:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $_) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> * &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-number"><span class="hljs-number">1</span></span> } default { fib($_ - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib($_ - <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Independence is given and when can be used in other situations. </font><font style="vertical-align: inherit;">When processing a CATCH block, when given works with a $! Variable containing the last exception caught. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variants with a modified sequence of writing, when the expression ends with the operator:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> .[<span class="hljs-number"><span class="hljs-number">0</span></span>] + .[<span class="hljs-number"><span class="hljs-number">1</span></span>] + .[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">given</span></span> @list; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'  ,    !'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> /^ &lt;[]&gt;+ $/;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when can be embedded in a given: </font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">'!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">given</span></span> $castle;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since given and when make the code very understandable, here is another perl obfuscation </font></font><br><br><pre> <code class="bash hljs">$ perl6 -e <span class="hljs-string"><span class="hljs-string">'for ^20 {my ($a,$b)=&lt;AT CG&gt;.pick.comb.pick(*);\ my ($c,$d)=sort map {6+4*sin($_/2)},$_,$_+4;\ printf "%{$c}s%{$d-$c}s\n",$a,$b}'</span></span> GC TA CG GC CG GC TA CG CG CG TA TA TA CG TA TA TA AT CG GC</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Making snowmen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me explain to you how to work with complex numbers in Perl 6 using the example of the Mandelbrot set. </font><font style="vertical-align: inherit;">Then you and higher mathematics, and beautiful pictures, and all sorts of advanced features of the language. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the first version of the script:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> v6; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $height = @*ARGS[<span class="hljs-number"><span class="hljs-number">0</span></span>] // <span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $width = $height; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $max_iterations = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $upper-right = -<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>)i; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $lower-left = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> - (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>)i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mandel</span></span></span></span>(Complex $c) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $z = 0i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^$max_iterations { $z = $z * $z + $c; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($z.abs &gt; 2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subdivide</span></span></span></span>($low, $high, $count) { (^$count).map({ $low + ($_ / ($count - 1)) * ($high - $low) }); } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"P1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"$width $height"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> subdivide($upper-right.re, $lower-left.re, $height) -&gt; $re { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @line = subdivide($re + ($upper-right.im)i, $re + 0i, ($width + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>).map({ mandel($_) }); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $middle = @line.pop; (@line, $middle, @line.<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>).join(<span class="hljs-string"><span class="hljs-string">' '</span></span>).say; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 3-5 set the size of the chart for the chart. </font><font style="vertical-align: inherit;">@ * ARGS - the name of the array with the command line parameters. </font><font style="vertical-align: inherit;">The // operator is a new ‚Äúdefined‚Äù, it returns the first argument if it is defined, and in another case the second one. </font><font style="vertical-align: inherit;">In other words, line 3 sets the height of the value of the first command line argument, and if not, then at 31. The width is set equal to the height. </font><font style="vertical-align: inherit;">$ max_iterations set the number of repetitions of the main loop, after which it is decided that the point belongs to the set (we work with symmetric figures, so the width must be an odd number)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 7-8 define the boundaries of the picture on the complex plane. </font><font style="vertical-align: inherit;">It is very easy to add an imaginary component to a number; you just need to add to the number or expression i. </font><font style="vertical-align: inherit;">It turns out a number of type Complex. </font><font style="vertical-align: inherit;">It works quite intuitively, for example, when adding Complex to Rat or Int, we again get Complex.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 10 through 17 define the basic function of Mandelbrot. In short, the complex number c is included in the set if the equation z = z * z + c (the initial z is 0) remains bounded if we continue to iterate. So the function is written - we define the cycle running $ max_iterations times. It is known that when the module z grows more than 2, it will not remain limited, so we use the test $ z.abs&gt; 2. If it does, we exit the cycle and return 1, indicating that the point must be black. If the loop passes the maximum number of times and the value does not exceed the limits, we return 0, and the dot turns white.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 19-21 are an auxiliary function that returns an arithmetic progression from $ low to $ high with the number of elements $ count. The type $ low and $ high is not set, so any type that allows basic arithmetic operations will work here. In this script, this is first Num, then Complex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 23-24 specify the PBM file header. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 26-30 draw a picture. $ upper-right.re is the real part of the complex number $ upper-right, and $ upper-right.im is imaginary. The cycle goes through the real part of the gap. In the cycle, we again take a subset of the imaginary part to compile a list of complex values ‚Äã‚Äãthat we need to test half of this series of pictures. This list is then run through the mandel function using map, and the output is a list of zeros and ones for half the series, including the midpoint.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do this because the Mandelbrot set is symmetrical about the axis. Therefore, we select the last, midpoint, and expand the list so that it becomes the same list, only backwards (and with the exception of the midpoint). The loan is passed to join to fill the string to the end and output it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such an operation produces a set rotated 90 degrees from the usual position, so we get a beautiful snowman like this: </font></font><br><br><img src="https://perl6advent.files.wordpress.com/2009/12/snowman.png?w=450" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can make this algorithm automatically parallelized through hyperoperators, but there is one catch: the hyperoperator cannot call the normal procedure. They only call class methods and operators. Therefore, we will tweak the Complex class so that it contains the .mandel method</font></font><br><br><pre> <code class="perl hljs">augment class Complex { method mandel() { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $z = 0i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^$max_iterations { $z = $z * $z + self; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($z.abs &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> subdivide($upper-right.re, $lower-left.re, $height) -&gt; $re { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @line = subdivide($re + ($upper-right.im)i, $re + 0i, ($width + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>)&gt;&gt;.mandel; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $middle = @line.pop; (@line, $middle, @line.<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>).join(<span class="hljs-string"><span class="hljs-string">' '</span></span>).say; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The difference is that mandel is now a method, and the role of the $ c argument is self. </font><font style="vertical-align: inherit;">And then instead of map ({mandel ($ _)}) we use the hyper-operator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if someone does not like to change the Complex class, you can simply turn mandel into an operator.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postfix</span></span></span><span class="hljs-function">:&lt;&gt;</span></span>(Complex $c) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $z = 0i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ^$max_iterations { $z = $z * $z + $c; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($z.abs &gt; 2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> subdivide($upper-right.re, $lower-left.re, $height) -&gt; $re { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @line = subdivide($re + ($upper-right.im)i, $re + 0i, ($width + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $middle = @line.pop; (@line, $middle, @line.<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>).join(<span class="hljs-string"><span class="hljs-string">' '</span></span>).say; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl 6 supports Unicode, so you can have fun and set the operator through the snowman symbol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the latest version of Rakudo, I remade the script so that it would produce a multi-colored picture. </font><font style="vertical-align: inherit;">It is slow and eats a lot of memory, but it works stably. </font><font style="vertical-align: inherit;">Here is a set of Mandelbrot in the resolution of 1001 √ó 1001, which was calculated 14 hours, and which took 6.4 GB of memory.</font></font><br><br><img src="http://www.harmonyware.com/pictures/big.png" alt="image"><br><br><h4>  Roles </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionally, OOP classes handle instance management and reuse. </font><font style="vertical-align: inherit;">Unfortunately, this leads to opposite results: reuse tends to make classes small and minimal, but if they represent a complex entity, they must support everything that is needed for this. </font><font style="vertical-align: inherit;">In Perl 6, classes retain control of instances, and Roles reuse them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the role? </font><font style="vertical-align: inherit;">Imagine that we are building a bunch of classes, each of which represents a different type of product. </font><font style="vertical-align: inherit;">Some will have common functionality and attributes. </font><font style="vertical-align: inherit;">For example, we may have the role of BatteryPower.</font></font><br><br><pre> <code class="perl hljs">role BatteryPower { has $.battery-type; has $.batteries-included; method find-power-accessories() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProductSearch::find($.battery-type); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first glance it looks like a class - attributes and methods. </font><font style="vertical-align: inherit;">However, we cannot use the role on our own. </font><font style="vertical-align: inherit;">Instead, we insert (compose) it into the class via the does keyword.</font></font><br><br><pre> <code class="perl hljs">class ElectricCar does BatteryPower { has $.manufacturer; has $.model; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The composition takes the attributes and methods from the role and copies them to the class. </font><font style="vertical-align: inherit;">From this point on, everything works as if the attributes and methods were defined in the class itself. </font><font style="vertical-align: inherit;">Unlike inheritance, where parent classes are searched for at the moment of distribution of methods, classes have no connection with roles at the time of program execution, except that the class says ‚Äúyes‚Äù in response to the question of whether it performs any specific role. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting things begin when we insert several roles into the class. </font><font style="vertical-align: inherit;">Suppose we have another role, SocketPower.</font></font><br><br><pre> <code class="perl hljs">role SocketPower { has $.adapter-type; has $.min-voltage; has $.max-voltage; method find-power-accessories() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProductSearch::find($.adapter-type); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The laptop can work from a power outlet or battery, so we insert both roles. </font></font><br><br><pre> <code class="perl hljs">class Laptop does BatteryPower does SocketPower { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We try to compile - and nothing happens. Unlike mixins and inheritance, all roles are in the same position. If both roles offer a method with the same name ‚Äî in our case, find-power-accessories ‚Äî then a conflict arises. It can be resolved by giving the class a method that decides what to do.</font></font><br><br><pre> <code class="perl hljs">class Laptop does BatteryPower does SocketPower { method find-power-accessories() { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ss = $.adapter-type ~ <span class="hljs-string"><span class="hljs-string">' OR '</span></span> ~ $.battery-type; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProductSearch::find($ss); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the most typical example of the use of roles, but not the only one. The role can be accepted and inserted into the object (that is, at the class level, and at the object level) through the does and but operators, and this will work like interfaces in Java and C #. But let's not talk about it now - I‚Äôd better show you how Perl 6 roles handle generalized programming, or parametric polymorphism. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roles can take parameters, which can be types or values. For example, you can make a role that we assign to products that need to calculate shipping costs. However, we need to be able to provide other models for calculating shipping costs, so we take a class that can handle shipping costs as a parameter to a role.</font></font><br><br><pre> <code class="perl hljs">role DeliveryCalculation[::Calculator] { has $.mass; has $.dimensions; method calculate($destination) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $calc = Calculator.new( :$!mass, :$!dimensions ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $calc.delivery-to($destination); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here :: Calculator in square brackets after the name of the role says that we want to capture the object and associate it with the name Calculator inside the role. Then we can use this object to call .new. Suppose we wrote classes that calculate shipping costs for ByDimension and ByMass. Then we can write:</font></font><br><br><pre> <code class="perl hljs">class Furniture does DeliveryCalculation[ByDimension] { } class HeavyWater does DeliveryCalculation[ByMass] { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When defining a role with parameters, you simply specify a set of parameters in square brackets, and when using a role, a list of arguments is placed in square brackets. </font><font style="vertical-align: inherit;">Therefore, you can use the full power of Perl 6 parameter sets in this case. </font><font style="vertical-align: inherit;">And besides, the default roles are multi, multiple, so you can set many roles with the same name, which take different types and different types of parameters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the ability to parameterize roles through square brackets, it is also possible to use the keyword of if each of the roles accepts only one parameter. </font><font style="vertical-align: inherit;">Therefore, after the following announcements:</font></font><br><br><pre> <code class="perl hljs">role Cup[::Contents] { } role Glass[::Contents] { } class EggNog { } class MulledWine { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can write like this: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Cup of EggNog $mug = get_eggnog(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Glass of MulledWine $glass = get_wine();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It can even be folded as follows: </font></font><br><br><pre> <code class="perl hljs">role Tray[::ItemType] { } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Tray of Glass of MulledWine $valuable;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last example is simply a more readable version of the Tray [Glass [MulledWine]] entry. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anything </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúAnything‚Äù is a type in Perl 6 that represents everything that makes sense in this context.</font></font><br><br>  Examples: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>..* <span class="hljs-comment"><span class="hljs-comment">#   my @x = &lt;abcd e&gt;; say @x[*-2] #     #  'd' say @x.map: * ~ 'A'; #  A  ,   #   say @x.pick(*) #     @x #    </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So how does this magic work? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some examples are simple. </font><font style="vertical-align: inherit;">* at the position of a member of the expression produces a Whatever object, and some built-in functions (for example, List.pick) know what to do with it. </font><font style="vertical-align: inherit;">By the way, Perl 6 parses the file predictively, that is, when the compiler reads the code, it always knows whether it has encountered a member of the expression or an operator.</font></font><br><br><pre> <code class="bash hljs">say 2 + 4 | | | | | | | +   () | | +  ( +) | +   () +   (listop),      </code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Therefore, in the record </font></font><br><br><pre> <code class="perl hljs">* * <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the first * is treated as a member of the expression, the second - as an operator. </font><font style="vertical-align: inherit;">This example generates a block of code -&gt; $ x {$ x * 2}.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $x = * * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $x(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment"># says 8</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Same Makar, </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @x.map: * ~ <span class="hljs-string"><span class="hljs-string">'A'</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is just a short entry for </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @x.map: -&gt; $x { $x ~ <span class="hljs-string"><span class="hljs-string">'A'</span></span> };</code> </pre><br><br>  but <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @x.map: *.succ;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> just a short record for </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @x.map: -&gt; $x { $x.succ };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Whatever is useful in sorting - for example, to sort the list in numerical order (the prefix + means to convert to a numeric form): </font></font><br><br><pre> <code class="perl hljs">@list.sort: +*</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To sort the list according to the rules for strings (the prefix ~ means to convert the value to a string view): </font></font><br><br><pre> <code class="perl hljs">@list.sort: ~*</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Little tricks </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the simple and powerful ideas of Perl 6 is introspection. </font><font style="vertical-align: inherit;">For PL, this is the mechanism by which you can ask questions about a language using the language itself. </font><font style="vertical-align: inherit;">For example, instances of objects have methods that tell which class it belongs to, methods that give a list of available methods, and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even the procedure has a method reporting the name of this procedure:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stuff</span></span></span><span class="hljs-function">, $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blah</span></span></span><span class="hljs-function"> = 5) </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> &amp;foo.name; <span class="hljs-comment"><span class="hljs-comment">#  "foo"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Although it does not look very meaningful, but remember: procedures can be assigned to scalars, you can give them aliases or create them on the fly, so the procedure name is not always obvious when looking at the code: </font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $bar = &amp;foo; <span class="hljs-comment"><span class="hljs-comment"># ...    ... say $bar.name; #  - , ?</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here are some other methods for learning the procedures: </font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> &amp;foo.signature.perl; <span class="hljs-comment"><span class="hljs-comment">#    ? say &amp;foo.count; #    ? say &amp;foo.arity; #     ?</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last parameter is arity, or the number of required parameters. </font><font style="vertical-align: inherit;">Thanks to introspection in Perl 6, you can do things previously impossible. </font><font style="vertical-align: inherit;">For example, in Perl 5, the map block takes a list of items one at a time and converts to one or more new items from which it creates a new list. </font><font style="vertical-align: inherit;">Because Perl 6 knows how many arguments are expected, it can take as much as it needs.</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> -&gt; $x, $y { ... }, @bar; <span class="hljs-comment"><span class="hljs-comment">#      @bar   @foo my @coords = map -&gt; $x, $y, $z { ... }, @numbers; #   @numbers    </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another advantage is a more convenient mechanism for sorting arrays according to criteria different from string comparison. </font><font style="vertical-align: inherit;">If you specify a sorting procedure for an array, it usually takes two arguments ‚Äî the compared items from the array. </font><font style="vertical-align: inherit;">If we wanted to sort people by their karma, we would write something like:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl6 use v6; class Person { has $.name; has $.karma; method Str { return "$.name ($.karma)" } #    } my @names = &lt;Jonathan Larry Scott Patrick Carl Moritz Will Stephen&gt;; my @people = map { Person.new(name =&gt; $_, karma =&gt; (rand * 20).Int) }, @names; .say for @people.sort: { $^a.karma &lt;=&gt; $^b.karma };</span></span></code> </pre><br><br>  But.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to introspection there is another option. </font><font style="vertical-align: inherit;">By passing a procedure that accepts only one parameter, Perl 6 can automatically create the equivalent of the Schwartz transform. </font></font><br> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A8%25D0%25B2%25D0%25B0%25D1%2580%25D1%2586%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ru.wikipedia.org/wiki/Schwartz Conversion</font></font></a> <br><br><pre> <code class="perl hljs"> .say <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @people.sort: { $^a.karma };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, since we have only one parameter, $ _ is implicitly specified in the procedure, so you can get rid of extra characters: </font></font><br><br><pre> <code class="perl hljs"> .say <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @people.sort: { .karma };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This example calls the .karma method for each element of the array once (rather than twice, as for comparison in the usual case) and then sorts the array by these results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another trick is the built-in type system. </font><font style="vertical-align: inherit;">In the example above, I did not declare the need for numeric sorting, since perl itself would guess that we use numbers. </font><font style="vertical-align: inherit;">If I had to force the sorting type, I would use + or ~:</font></font><br><br><pre> <code class="perl hljs"> .say <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @people.sort: { +.karma }; <span class="hljs-comment"><span class="hljs-comment">#  .say for @people.sort: { ~.karma }; # </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the .min and .max methods this is especially convenient. </font><font style="vertical-align: inherit;">They also adopt a procedure for determining the sorting criteria:</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @people.min: { +.karma } <span class="hljs-comment"><span class="hljs-comment">#  say @people.max: { ~.name } # </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This can also be written using Whatever: </font></font><br><br><pre> <code class="perl hljs"> .say <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @people.sort: *.karma; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @values.min: +*.karma; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> @values.max: ~*.name;</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grammar and Action </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have a bunch of text to parse. </font><font style="vertical-align: inherit;">Is Perl meant for this? </font><font style="vertical-align: inherit;">We specify the problem: the following text describes the questions and answers:</font></font><br><br><pre> <code class="bash hljs">pickmany:     ? ac:  ac:  ac:  ai:  pickone:     ? ac:  ai:  ai:  ai: </code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Perl 6, for parsing, I define Grammar. </font><font style="vertical-align: inherit;">This is a special kind of namespace that contains regular expressions. </font><font style="vertical-align: inherit;">We will also set several named expressions to divide the parsing task into parts.</font></font><br><br><pre> <code class="perl hljs">grammar Question::Grammar { token TOP { \n* &lt;question&gt;+ } token question { &lt;header&gt; &lt;answer&gt;+ } token header { ^^ $&lt;type&gt;=[<span class="hljs-string"><span class="hljs-string">'pickone'</span></span>|<span class="hljs-string"><span class="hljs-string">'pickmany'</span></span>] <span class="hljs-string"><span class="hljs-string">':'</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;text&gt;=[\N*] \n } token answer { ^^ \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;correct&gt;=[<span class="hljs-string"><span class="hljs-string">'ac'</span></span>|<span class="hljs-string"><span class="hljs-string">'ai'</span></span>] <span class="hljs-string"><span class="hljs-string">':'</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;text&gt;=[\N*] \n } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By default, in grammars, spaces are ignored, and matches are searched for the entire line ‚Äî as if the modifiers / x and / s are included in Perl 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'token' is one of the three identifiers used to define the regular schedule, including 'regex', 'token', and 'rule'. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'regex' is a simple version, while the other two simply add the options </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'token' prohibits returns back, and the 'rule' prohibits returns and includes a literal search for spaces specified in the regular schedule. We will not use the 'rule'.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The syntax is used to call another named regular. </font><font style="vertical-align: inherit;">'^^' is used to indicate the beginning of a line, as opposed to '^', which marks the beginning of the whole text. </font><font style="vertical-align: inherit;">Square brackets are a grouping that does not affect the array of found parts of a string, an analogue (?:) In Perl 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The = sign assigns a name to the right side on the left side. </font><font style="vertical-align: inherit;">Let's see what happens if we search for this grammar and display the search results:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $text = Q { pickmany:     ? ac:  ac:  ac:  ai:  pickone:     ? ac:  ai:  ai:  ai:  }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $match = Question::Grammar.parse($text); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $match.perl;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not include the issue in 232 lines here as a whole. </font><font style="vertical-align: inherit;">Consider one part, questions.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#   for $match&lt;question&gt;.flat -&gt; $q { say $q&lt;header&gt;&lt;text&gt;; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.flat is used because $ match is an array contained in a scalar container. </font><font style="vertical-align: inherit;">Angle brackets are equivalent to the following:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#   for $match{'question'}.flat -&gt; $q { say $q{'header'}{'text'}; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This shows that the object contains named items as hash values, and repetitions are contained in an array. </font><font style="vertical-align: inherit;">If we had an array of found results created by parentheses, as in Perl 5 (), its elements could be accessed via the positional interface using square brackets (as when working with arrays). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to make several classes and multiply them based on the object. </font><font style="vertical-align: inherit;">Class definitions:</font></font><br><br><pre> <code class="perl hljs">class Question::Answer { has $.text is rw; has Bool $.correct is rw; } class Question { has $.text is rw; has $.type is rw; has Question::Answer @.answers is rw; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating Question objects from the search results is not so difficult, but it looks ugly: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @questions = $match&lt;question&gt;.map: { Question.new( <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$_&lt;header&gt;&lt;text&gt;, <span class="hljs-string"><span class="hljs-string">type =&gt;</span></span> ~$_&lt;header&gt;&lt;type&gt;, <span class="hljs-string"><span class="hljs-string">answers =&gt;</span></span> $_&lt;answer&gt;.map: { Question::Answer.new( <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$_&lt;text&gt;, <span class="hljs-string"><span class="hljs-string">correct =&gt;</span></span> ~$_&lt;correct&gt; eq <span class="hljs-string"><span class="hljs-string">'ac'</span></span>, ) }, ); };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearing in mind that any repetition in the regular list leads to the appearance of an array in the object, we run the map by attribute, and build for each Question object. Each entry pulls an array of, which we also pass with the help of map, building a list of Question :: Answer objects. We convert the values ‚Äã‚Äãfound from Math objects to strings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach does not scale. It would be more convenient to build objects on the fly. To do this, pass the object as an argument: action to the grammar's .parse () method. The parsing engine will then call methods with the same name that the regular schedule has, to which the Match object will be passed as an argument. If the method calls make () at run time, the argument to make () is written as an attribute .ast (‚ÄúAbstract Syntax Tree‚Äù,abstract syntax tree of the Match object.</font></font><br><br>      ‚Äì    .     ,   ,    : <br><br><pre> <code class="perl hljs">class Question::Actions { method TOP($/) { make $&lt;question&gt;¬ª.ast; } method question($/) { make Question.new( <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$&lt;header&gt;&lt;text&gt;, <span class="hljs-string"><span class="hljs-string">type =&gt;</span></span> ~$&lt;header&gt;&lt;type&gt;, <span class="hljs-string"><span class="hljs-string">answers =&gt;</span></span> $&lt;answer&gt;¬ª.ast, ); } method answer($/) { make Question::Answer.new( <span class="hljs-string"><span class="hljs-string">correct =&gt;</span></span> ~$&lt;correct&gt; eq <span class="hljs-string"><span class="hljs-string">'ac'</span></span>, <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$&lt;text&gt;, ); } }</code> </pre><br><br> $/ ‚Äî     Match,     ,  $_ ‚Äî         .        ($  $[1])     $/ ($/  $/[1]).    ,         ,   $1, $2, $3  Perl 5. <br><br>   TOP     ,     .ast     $.      'make'   ,   -   .ast   Match,     ,     'make'   'question'. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the 'question' method, we create a new Question object, passing all attributes from the match object to it, and assigning to its 'answer' attributes a list of objects that is received each time the 'answer' regular question 'question' is called. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the 'answer' method, we do the same thing, assigning the comparison result to the 'correct' attribute to satisfy the attribute type 'bool'. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When parsing, we make an instance of this new class and pass the object as the: action parameter to the grammar's .parse method, and then we get the constructed object from the .ast attribute from the search object that it returns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my $ actions = Question :: Actions.new (); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my </font></font><a href="https://habrahabr.ru/users/questions/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">questions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Question :: Grammar.parse ($ text,: actions ($ actions)). ast.flat;</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now you can check the created object to make sure that everything goes according to plan: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @questions -&gt; $q { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $q.text; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> $q.answers.kv -&gt; $i, $a { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">" $i) {$a.text}"</span></span>; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And for completeness, let's add a method in Question that will ask a question, get an answer and evaluate it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with the presentation of the question, answers and input request:</font></font><br><br><pre> <code class="perl hljs"> method ask { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> %hints = ( <span class="hljs-string"><span class="hljs-string">pickmany =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"   ,   "</span></span>, <span class="hljs-string"><span class="hljs-string">pickone =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"   "</span></span>, ); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"\n{%hints{$.type}}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $.text; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @.answers.kv -&gt; $i, $a { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"$i) {$a.text}"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we will get the string from STDIN and extract the numbers from it: </font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $line = $*IN.get(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @answers = $line.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;digit&gt;+/</span></span>)&gt;&gt;.Int.sort</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'comb' is the opposite of 'split', in the sense that we determine what we need to leave, and not what we need to throw away. </font><font style="vertical-align: inherit;">The advantage is that we don‚Äôt need to choose a separating character. </font><font style="vertical-align: inherit;">The user can enter ‚Äú1 2 3 ‚Ä≥,‚Äú 1,2,3 ‚Äùor even‚Äú 1, 2 and 3 ‚Ä≥. </font><font style="vertical-align: inherit;">Then, by calling the hyperoperator method, we create an array of integers from the array of found characters and sort it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's create an array of indices of all the correct answers, and find out the correct answers.</font></font><br><br><pre> <code class="perl hljs"> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @correct = @.answers.kv.map({ $^value.correct ?? $^key !! () }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @correct ~~ @answers { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">",  !"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">" ,  "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call it for each of the questions and collect the results through the map of our new method: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @results = @questions.map(*.ask); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"\nFinal score: "</span></span> ~ [+] @results;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The results will be something like this: </font></font><br><br><pre> <code class="bash hljs">[sweeks@kupo ~]$ perl6 /tmp/questions.pl    ,        ? 0)  1)  2)  3)  &gt; 0 1 2 ,  !         ? 0)  1)  2)  3)  &gt; 1  ,    : 1</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is the full text of the program: </font></font><br><br><pre> <code class="perl hljs">class Question::Answer { has $.text is rw; has Bool $.correct is rw; } class Question { has $.text is rw; has $.type is rw; has Question::Answer @.answers is rw; method ask { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> %hints = ( <span class="hljs-string"><span class="hljs-string">pickmany =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"    ,   "</span></span>, <span class="hljs-string"><span class="hljs-string">pickone =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"    "</span></span>, ); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"\n{%hints{$.type}}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $.text; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @.answers.kv -&gt; $i, $a { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"$i) {$a.text}"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $line = $*IN.get(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @answers = $line.comb(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;digit&gt;+/</span></span>)&gt;&gt;.Int.sort @correct = @.answers.kv.map({ $^value.correct ?? $^key !! () }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @correct ~~ @answers { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">" ,  !"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"  ,  "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } grammar Question::Grammar { token TOP { \n* &lt;question&gt;+ } token question { &lt;header&gt; &lt;answer&gt;+ } token header { ^^ $&lt;type&gt;=[<span class="hljs-string"><span class="hljs-string">'pickone'</span></span>|<span class="hljs-string"><span class="hljs-string">'pickmany'</span></span>] <span class="hljs-string"><span class="hljs-string">':'</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;text&gt;=[\N*] \n } token answer { ^^ \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;correct&gt;=[<span class="hljs-string"><span class="hljs-string">'ac'</span></span>|<span class="hljs-string"><span class="hljs-string">'ai'</span></span>] <span class="hljs-string"><span class="hljs-string">':'</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+ $&lt;text&gt;=[\N*] \n } } class Question::Actions { method TOP($/) { make $&lt;question&gt;¬ª.ast; } method question($/) { make Question.new( <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$&lt;header&gt;&lt;text&gt;, <span class="hljs-string"><span class="hljs-string">type =&gt;</span></span> ~$&lt;header&gt;&lt;type&gt;, <span class="hljs-string"><span class="hljs-string">answers =&gt;</span></span> $&lt;answer&gt;¬ª.ast, ); } method answer($/) { make Question::Answer.new( <span class="hljs-string"><span class="hljs-string">correct =&gt;</span></span> ~$&lt;correct&gt; eq <span class="hljs-string"><span class="hljs-string">'ac'</span></span>, <span class="hljs-string"><span class="hljs-string">text =&gt;</span></span> ~$&lt;text&gt;, ); } } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $text = Q { pickmany:     ? ac:  ac:  ac:  ai:  pickone:     ? ac:  ai:  ai:  ai:  }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $actions = Question::Actions.new(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @questions = Question::Grammar.parse($text, :actions($actions)).ast.flat; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @results = @questions.map(*.ask); <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> ~ [+] @results;</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator Overloading </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl 6 allows you to overload existing operators and define new ones. </font><font style="vertical-align: inherit;">Operators are simply multi-procedures with a special name, and standard rules for multi-procedures are used to determine the desired variant of the operator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A common example is the definition of a factorial operator, similar to a mathematical notation:</font></font><br><br><pre> <code class="perl hljs">multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postfix</span></span></span><span class="hljs-function">:&lt;!&gt;(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Int</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">) </span></span>{ [*] <span class="hljs-number"><span class="hljs-number">1</span></span>..$n; } <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>!;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first part of the definition is a syntactic category (prefix, postfix, infix, circumfix, or postcircumfix). After the colon are the angle brackets, in which the operator is written. In the case of circumfix, two pairs of brackets are required, but for all the rest one is sufficient, inside which there may be several characters. In the example, we defined a postfix operator!, Working with integers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can set additional attributes, such as tighter, equiv, and looser, which set the order of priority compared to other operators. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you specify a replacement for an existing statement, a new definition is simply added to its multiprocessing set. For example, you can define your class and determine that its objects can be added with the + operator:</font></font><br><br><pre> <code class="perl hljs">class PieceOfString { has Int $.<span class="hljs-keyword"><span class="hljs-keyword">length</span></span>; } multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">infix</span></span></span><span class="hljs-function">:&lt;+&gt;</span></span>(PieceOfString $lhs, PieceOfString $rhs) { PieceOfString.new(:<span class="hljs-keyword"><span class="hljs-keyword">length</span></span>($lhs.length + $rhs.length)); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, real-life examples are more complex and include several variables. </font><font style="vertical-align: inherit;">You can set a string equality check:</font></font><br><br><pre> <code class="perl hljs">multi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">infix</span></span></span><span class="hljs-function">:&lt;==&gt;(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PieceOfString</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lhs</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PieceOfString</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rhs</span></span></span><span class="hljs-function"> --&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function">) </span></span>{ $lhs.length == $rhs.length; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What should be avoided is the overload of the prefix: &lt;~&gt; operator (conversion to string). </font><font style="vertical-align: inherit;">If you do this, you will not be able to intercept all string conversions. </font><font style="vertical-align: inherit;">Instead, it's better to define your class's Str method, which will do the job:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MONKEY_TYPING; augment class PieceOfString { method Str { <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> $.<span class="hljs-keyword"><span class="hljs-keyword">length</span></span>; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this method will be called by the traditional operator ~. </font><font style="vertical-align: inherit;">Methods whose names match the types are used to convert types, so you can specify Str and Num methods for your classes in cases where this makes sense. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And since the source code for Perl 6 is written in Unicode, you can define new statements using all the richness of characters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lazy fruits of the Garden of Eden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider an infrequently found structure in other languages ‚Äã‚Äã- an iterator constructor called gather. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historically, many perloviki know convenient functions map, grep and sort:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @squares = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> { $_ * $_ }, @numbers; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @primes = <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> { is-prime($_) }, @numbers;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> map and grep are especially good when you have learned to build them into chains: </font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @children-of-single-moms = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> { .children }, <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> { !.is-married }, <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> { .gender == FEMALE }, @citizens;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This led to the creation of the Schwartz transformation - an idiom for caching in that case. </font><font style="vertical-align: inherit;">when sorting is resource intensive:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @files-by-modification-date = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> { .[<span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">#  sort { $^a[1] &lt;=&gt; $^b[1] }, map { [$_, $_ ~~ :M] }, #    @files;</span></span></code> </pre><br><br>       ,       sort: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @files-by-modification-date = <span class="hljs-keyword"><span class="hljs-keyword">sort</span></span> { $_ ~~ :M }, @files;</code> </pre><br><br>    gather?     map  grep. <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mymap</span></span></span></span>(&amp;transform, @list) { gather <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @list { take transform($_); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mygrep</span></span></span></span>(&amp;condition, @list) { gather <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @list { take $_ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition($_); } };</code> </pre><br><br> gather ,       .  take    .    push   : <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @result = gather { take $_ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span> }; <span class="hljs-comment"><span class="hljs-comment">#  - my @result; push @result, $_ for 5..7; #  </span></span></code> </pre><br><br> ,    gather ‚Äì    ,  map, grep  sort . ,    ‚Ä¶  ,   ,      ,  . <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incremental</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span></span>(@list) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $string-accumulator = ""; gather <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> @list { take ~($string-accumulator ~= $_); } }; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> incremental-concat(&lt;ab c&gt;).perl; <span class="hljs-comment"><span class="hljs-comment"># ["a", "ab", "abc"]</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The example is more convenient than the map, because between iterations we need to process $ string-accumulator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second property of the gather - although take calls must occur in the scope of the gather block, they need not be in the lexical area - only in the dynamic. For those who are not clear differences, I will explain:</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inorder</span></span></span></span>(Tree $t) { traverse-tree-inorder($t.left) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $t.left; take transform($t); traverse-tree-inorder($t.right) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $t.right; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $tree = ...; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @all-nodes = gather traverse-tree-inorder($tree);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we wrap the &amp; traverse-tree-inorder call in the gather instruction. The instruction itself does not contain lexically take calls, but the called procedure contains, and thus take inside it remembers that it is in the context of the gather. This is the dynamic context. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third property of the gather: it is "lazy." In the case of a tree traversal code, this means: when assigning @ all-nodes, the tree has not yet been bypassed. The traversal begins only when accessing the first element of the array, @ all-nodes [0]. And it stops when the leftmost vertex is found. Request @ all-nodes [1] - and the detour will resume from where it ended, to stop after it finds the second vertex.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the code in the gather block starts and stops so as not to do the work more than it is asked. </font><font style="vertical-align: inherit;">This is the "lazy" behavior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this is a deferred execution. </font><font style="vertical-align: inherit;">Perl 6 promises to execute the code inside the gather block, but only if you need its information. </font><font style="vertical-align: inherit;">Interestingly, almost all arrays are lazy by default, and reading strings from a file too. </font><font style="vertical-align: inherit;">map and grep is not just possible to create with the help of the gather, they themselves are also lazy. </font><font style="vertical-align: inherit;">This behavior opens up the possibilities of programming threads and using infinite arrays.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @natural-numbers = <span class="hljs-number"><span class="hljs-number">0</span></span> .. Inf; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @even-numbers = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ... *; <span class="hljs-comment"><span class="hljs-comment">#   my @odd-numbers = 1, 3 ... *; my @powers-of-two = 1, 2, 4 ... *; #   my @squares-of-odd-numbers = map { $_ * $_ }, @odd-numbers; sub enumerate-positive-rationals() { #     take 1; for 1..Inf -&gt; $total { for 1..^$total Z reverse(1..^$total) -&gt; $numerator, $denominator { take $numerator / $denominator; } } } sub enumerate-all-rationals() { map { $_, -$_ }, enumerate-positive-rationals(); } sub fibonacci() { gather { take 0; my ($last, $this) = 0, 1; loop { # infinitely! take $this; ($last, $this) = $this, $last + $this; } } } say fibonacci[10]; # 55 #   ,     sub merge(@a, @b) { !@a &amp;&amp; !@b ?? () !! !@a ?? @b !! !@b ?? @a !! (@a[0] &lt; @b[0] ?? @a.shift !! @b.shift, merge(@a, @b)) } sub hamming-sequence() # 2**a * 3**b * 5**c, where { all(a,b,c) &gt;= 0 } gather { take 1; take $_ for merge( (map { 2 * $_ } hamming-sequence()), merge( (map { 3 * $_ }, hamming-sequence()), (map { 5 * $_ }, hamming-sequence()) )); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last procedure is solving the Hamming problem on Perl 6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here is another ‚Äúabracadabra‚Äù that implements a cellular automaton that suddenly draws a Christmas tree.</font></font><br><br><pre> <code class="bash hljs">$ perl6 -e <span class="hljs-string"><span class="hljs-string">'my %r=[^8]&gt;&gt;.fmt("%03b") Z (0,1,1,1,1,0,0,0);\ say &lt;. X&gt;[my@i=0 xx 9,1,0 xx 9];\ for ^9 {say &lt;. X&gt;[@i=map {%r{@i[($_-1)%19,$_,($_+1)%19].join}},^19]};'</span></span> .........X......... ........XXX........ .......XX..X....... ......XX.XXXX...... .....XX..X...X..... ....XX.XXXX.XXX.... ...XX..X....X..X... ..XX.XXXX..XXXXXX.. .XX..X...XXX.....X. XX.XXXX.XX..X...XXX</code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standard grammar perl 6 </font></font></h4><br>      . ,     ‚Äì              ,  ? <br><br>   Perl 6,    .         ,    . , Perl 6    ,    .         ,  ,   .. <br><br>    ‚Äì   .        .       : <br><br><pre> <code class="perl hljs"> rule statement { | &lt;if_statement&gt; | &lt;while_statement&gt; | &lt;for_statement&gt; | &lt;expr&gt; } rule if_statement { <span class="hljs-string"><span class="hljs-string">'if'</span></span> &lt;expr&gt; &lt;statement&gt; } rule while_statement { <span class="hljs-string"><span class="hljs-string">'while'</span></span> &lt;expr&gt; &lt;statement&gt; } rule for_statement { <span class="hljs-string"><span class="hljs-string">'for'</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">';'</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">';'</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span> &lt;stmt&gt; }</code> </pre><br><br>      : <br><br><pre> <code class="perl hljs"> proto token statement { &lt;...&gt; } rule statement:sym&lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>&gt; { <span class="hljs-string"><span class="hljs-string">'if'</span></span> &lt;expr&gt; &lt;statement&gt; } rule statement:sym&lt;<span class="hljs-keyword"><span class="hljs-keyword">while</span></span>&gt; { <span class="hljs-string"><span class="hljs-string">'while'</span></span> &lt;expr&gt; &lt;statement&gt; } rule statement:sym&lt;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>&gt; { <span class="hljs-string"><span class="hljs-string">'for'</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">';'</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">';'</span></span> &lt;expr&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span> &lt;stmt&gt; } rule statement:sym&lt;expr&gt; { &lt;expr&gt; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We determine that it is looking for matches in any of the described constructions, but the PDF version is much easier to expand. </font><font style="vertical-align: inherit;">In the first version, adding a new statement (for example, ‚Äúrepeat..until‚Äù) would require rewriting the entire rule statement. </font><font style="vertical-align: inherit;">But with PDF, add one more rule:</font></font><br><br><pre> <code class="perl hljs"> rule statement:sym&lt;repeat&gt; { <span class="hljs-string"><span class="hljs-string">'repeat'</span></span> &lt;stmt&gt; <span class="hljs-string"><span class="hljs-string">'until'</span></span> &lt;expr&gt; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This rule is added to the PDP candidates. </font><font style="vertical-align: inherit;">And it works in the new version of the grammar:</font></font><br><br><pre> <code class="perl hljs"> grammar MyNewGrammar is BaseGrammar { rule statement:sym&lt;repeat&gt; { <span class="hljs-string"><span class="hljs-string">'repeat'</span></span> &lt;stmt&gt; <span class="hljs-string"><span class="hljs-string">'until'</span></span> &lt;expr&gt; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyGrammar parsit is the same as BaseGrammar, with the additional definition of the operator repeat..until. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another useful component of standard grammar is advanced error diagnostics. </font><font style="vertical-align: inherit;">Instead of messages like ‚Äúthere is an error,‚Äù the language offers options for its solution. </font><font style="vertical-align: inherit;">In addition, efforts have been made to help those who migrate from Perl 5 to Perl 6 while tracking constructs that have changed their meaning. </font><font style="vertical-align: inherit;">For example, if you try to use else with the unless block, you will get the error:</font></font><br><br><pre> <code class="bash hljs"> unless does not take <span class="hljs-string"><span class="hljs-string">"else"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Perl 6; please rewrite using <span class="hljs-string"><span class="hljs-string">"if"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Or, using the ternary operator (? :), the parser will return: </font></font><br><br><pre> <code class="bash hljs"> Unsupported use of <span class="hljs-string"><span class="hljs-string">"?:"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Perl 6 please use <span class="hljs-string"><span class="hljs-string">"??!!"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We hope you enjoyed our notes on the new Perl 6 language as applied to the Rakudo compiler. </font></font></div><p>Source: <a href="https://habr.com/ru/post/248713/">https://habr.com/ru/post/248713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248695/index.html">(Kiev) February 12-13, the course ‚ÄúImplementing MSA 2000 Storage Solutions (U4226S)‚Äù will take place</a></li>
<li><a href="../248697/index.html">(Kiev) from January 28, the course ‚ÄúAdministration and management of HP BladeSystem (HE646S)‚Äù begins</a></li>
<li><a href="../248699/index.html">(Kiev) On January 28-30, the course ‚ÄúFortiGate Multi-Threat Security Systems II - Secured Network Deployment and Virtual Private Networks‚Äù will take place</a></li>
<li><a href="../248703/index.html">Mountain Data Center</a></li>
<li><a href="../248705/index.html">How to make simple building animations in strategic games</a></li>
<li><a href="../248715/index.html">Some interesting and useful things for web developer # 37</a></li>
<li><a href="../248719/index.html">Research projects on the Odesk freelance market through the eyes of a web developer</a></li>
<li><a href="../248721/index.html">PHP7 revolution: return types and artifact removal</a></li>
<li><a href="../248723/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 4b of 6</a></li>
<li><a href="../248725/index.html">Getting vk.com community members in seconds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>