<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modbus protocol extension options: polling acceleration and a bit of security</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modbus is essentially the accepted standard in automation systems for interacting with sensors, actuators, I / O modules, and programmable logic contr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modbus protocol extension options: polling acceleration and a bit of security</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/u-/xb/js/u-xbjsrlclhvjxzllmmpihesmic.png" alt="image"><br><br>  Modbus is essentially the accepted standard in automation systems for interacting with sensors, actuators, I / O modules, and programmable logic controllers. <br><br>  In areas where an event model is required, newer standards such as IEC 60870-5-101 / 103/104, CANopen, DNP3 and the like are gradually replacing it, however, due to simplicity, the request-response model and the ability to work in half duplex , Modbus remains an excellent solution for telemetry systems when working through radio modems. <br><a name="habracut"></a><br>  With an increase in the number of objects polled from the base station and an increase in data volumes (values ‚Äã‚Äãfrom sensors, I / O status, archives, etc.), the question arises of the polling rate.  The main disadvantage when working through the radio modem is the time of "warming up" of the radio module at each initiation of the transfer of the request (it can reach 200-500 ms), which is multiplied by the number of relay nodes.  With a large length of the relay chain, the probability that the request and response packet does not reach the addressee due to interference also increases.  This is all the laws of physics, and they can not be circumvented. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About obvious techniques, such as grouping data in the address space so that they can be counted as one request, storing all the values ‚Äã‚Äãin the Holding-zone (and not separately in Holding and Inputs) for the same reason, we will not analyze, but think about How can Modbus be improved to optimize radio traffic.  The proposed solutions can be easily implemented if you are both a top (OPC server) developer and a middle (controller) level developer, or if you have a close contact between the developers. <br><br>  An important issue will be maintaining compatibility, so that, for example, your controller can also be polled by any other standard OPC server, and not just by your development.  In the case of Modbus, this is easy, because  there are about 24 standard functions (of which half is used at best in practice), and the rest are either ‚Äúuser-defined‚Äù or reserved.  At a minimum, functions from 65 to 72 and from 100 to 110 can be freely redefined for their needs, which we will do. <br><br><h3>  Large packages </h3><br>  If the quality of communication with individual objects is very good (almost without loss), it makes sense to try to interrogate them in large packets.  By standard, the maximum amount of data in a packet is 253 bytes.  However, no one forbids us to transfer the client-server and more within our system, and for this you don‚Äôt even need to redo much. <br>  Let's take a look at the usual Modbus function request 0x3 (Read holding registers): <br><br> <code>01 03 FF 01 00 07 4B 44</code> <br> <br>  Device address, 3rd function, start register address, number of registers requested, CRC-16.  For the number of registers requested in the ADU, 2 bytes are reserved, that is, nothing prevents you from requesting values ‚Äã‚Äãgreater than 255 - the main thing is that both the polled device and the polling server support this feature. <br><br>  The answer is a little more complicated <br><br> <code>01 03 FF 01 00 07 14 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E F2 56</code> <br> <br>  as we see, one byte is added there (it keeps the length of the data in bytes), we no longer get into it, and therefore we have to implement a custom modbus function, in which 2 bytes will be allocated for this field. <br><br><h3>  Data compression </h3><br>  Everything is simple here.  The less data we transmit in one packet, the more likely it is to correctly reach the destination address and the CRC will match.  Or if we do not slightly fit into one package, it would be wise to try to compress the data so as not to send another request. <br>  The compression algorithm is required to be simple (because it will have to be implemented not only on the server, but also on the controller), and works well with small portions of data (from 16 to 1024 bytes). <br><br>  In our case, the RLE algorithm, which is ridiculously simple, copes with such conditions, but it turned out to be very effective on data sets typical in PLC registers (order data from ADC channels, configuration settings, etc.).  True, the classic implementation, which can be found on almost all sites with algorithms, is still not perfect, because it encodes only the number of repetitions, and if there are few repetitions, the output buffer may turn out even more than the input one.  Therefore, I use my own implementation, which encodes not only the number of repetitions, but also the number of non-repetitions :) <br>  A simplified code like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief   * @param in_buf      * @param out_buf       (   maxclen) * @param len     * @param maxclen    . * @return     ,  -1     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *in_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxclen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *c_start = in_buf; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *c_curr = in_buf; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> curr_type; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> run_len = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*c_curr == *(c_curr+<span class="hljs-number"><span class="hljs-number">1</span></span>)) curr_type = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curr_type = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((c_curr - in_buf) &lt;= len) &amp;&amp; (result_size &lt; maxclen)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ( (*c_curr != *(c_curr+<span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; (curr_type == <span class="hljs-number"><span class="hljs-number">1</span></span>) ) || ( (*c_curr == *(c_curr+<span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; (curr_type == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) &amp;&amp; (run_len &lt; <span class="hljs-number"><span class="hljs-number">127</span></span>) &amp;&amp; ((c_curr - in_buf) &lt;= len) ) { c_curr++; run_len++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curr_type == <span class="hljs-number"><span class="hljs-number">0</span></span>) { *out_buf = run_len; out_buf++; *out_buf = *c_curr; out_buf++; c_curr++; result_size = result_size + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { run_len--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (run_len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *out_buf = <span class="hljs-number"><span class="hljs-number">0x80</span></span> | run_len; out_buf++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= run_len; i++) *(out_buf + i) = *(c_start + i); out_buf = out_buf + run_len; result_size = result_size + run_len + <span class="hljs-number"><span class="hljs-number">1</span></span>; } } c_start = c_curr; curr_type = curr_type ^ <span class="hljs-number"><span class="hljs-number">1</span></span>; run_len = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result_size &gt;= maxclen) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_size; } <span class="hljs-comment"><span class="hljs-comment">/** * @brief   * @param in_buf      * @param out_buf      (    ) * @param len    * @return    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *in_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* c_curr = in_buf; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((c_curr - in_buf) &lt; len) { count = *c_curr &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>; size = size + count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*c_curr &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) { c_curr++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { *out_buf = *c_curr; c_curr++; out_buf++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { c_curr++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { *out_buf = *c_curr; out_buf++; } c_curr++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  In compressed form, the data will look something like this: <br><br> <code>81 45 32 41 81 42 02 41</code> <br> <br>  First there is a byte that determines whether it is a block of repeating or non-repeating bytes (the high bit 0x80 is active for non-repeating blocks, and vice versa), and then directly or the repeating byte itself, or an array of non-repeating, and so on. <br><br>  The above code is simplified, ‚Äúfast and dirty‚Äù, there is always room to be better.  It should be noted that this example compresses data using bytes, and in the case of Modbus, it will sometimes be wiser to compress using words (2 bytes each).  It is easy to guess that the changes in the code will be minimal, and which of the options will suit you better depends on the characteristics of the data that you will compress. <br><br>  If you use large packages, and a full-fledged operating system runs on the PLC (for example, Linux on LinPac controllers), you can even try using zlib. <br><br><h3>  Incremental read </h3><br>  If polling occurs very often, or vice versa, the data in the controller is updated very rarely, then sometimes it makes sense to read only the changed blocks of the address space. <br>  The algorithm may be something like this: <br><br>  1. The server sends a request similar to the 0x3 or 0x4 modbus function, but also indicating the last read number (just an incremental counter) <br><br>  2. The controller checks if the number of the last reading matches the same number in the controller (that is, the previous answer was correctly delivered and processed), then the XOR goes through the prepared register buffer for sending, comparing it with the same buffer saved from the previous one request, after which it encodes only the changed data in the following way. <br><br> <code>&lt;   &gt;&lt; &gt;&lt; &gt;</code> <br> <br>  As you can see, the algorithm will be in many ways similar to the RLE described above (we kind of believe that all the unchanged data are the same for us) and there is no magic here. <br>  When using this method, more or less frequently changing data (timers, signals from the ADC, etc.) should be placed next to each other in the register map, and only then can the infrequently changing data go in a grouped way (bitmasks of the task‚Äôs status, discrete signals). inputs, etc.). <br><br><h3>  Little about security </h3><br>  Modbus does not offer any encryption or authentication technology.  And from this it follows that if security is not an empty sound for you, then it is better to use a more suitable protocol for this. <br><br>  It is clear that no one will manage the critical systems through an open radio channel, but I have probably seen a dozen systems in my life that worked through FSK radio modems, and the developers and users didn‚Äôt even think that any owner of a similar radio kit and laptop, knowing the register card can send any commands to the objects on behalf of the server.  The same situation applies to RS-485 cable lines, they are also not protected. <br><br>  The situation is somewhat complicated by the fact that often PLCs and embedded systems are limited in resources, and therefore any more or less complex and reliable symmetric algorithm will not be easy to put in there, let alone asymmetric ones. <br><br>  Therefore, when writing to registers (sending an executive command or changing the configuration), besides the register values, you can additionally send, for example, MD5-hash (the algorithm is simple, fast, and despite the fact that it contains flaws in collisions, in our case they do not play a serious role) from the data itself, some ‚Äúsalt‚Äù (a key known only to the server and controller, and it would be nice to also provide for the rotation of keys with a small periodicity) and, for example, the current timestamp with an accuracy of 10 seconds ( Zevivimos  te on the quality of time synchronization between the server and the PLC and the relay chain).  Protection is far from perfect, but due to a combination of factors it can significantly complicate the implementation of evil plans. <br><br>  If the controller carries on board a full-fledged OS, such as Linux or WinCE and a powerful processor, you can swing a little wider, and take, for example, libCryptoPP, and encrypt blocks, for example, with the 3DES algorithm, and not only for recording functions, but even normal reading. <br><br><h3>  Address expansion </h3><br>  This solution is not so simple, and not in technical terms (since everything is just the same with this), but rather administratively, because compatibility, alas, is already breaking. <br><br>  If there is a need to poll more than 247 devices on the same communication line or in the same frequency range, it is worth considering the option of switching to double-byte addresses.  Some well-known controllers (for example, ScadaPack) support this solution out of the box. <br><br>  To be able to interrogate a device locally with a standard modbus scanner, it is possible to provide for a device to be reset to single-byte mode, for example, when a certain jumper is closed, or to reserve some address (for example, 247) that will never be found in the high byte of extended addresses, and when receiving a package with which the controller will always treat it as a standard package. <br><br>  If the relay algorithm is processed by modems, then there should be no problems with this if devices with addresses containing the same high-order byte of the address are in the same relay group ‚Äî in this way, the modems will accept the message as a normal Modbus packet, retransmit it to of the final sector, there all the controllers will receive it, in which the high byte of the address matches, but only one will process and respond to it, in which not only the high byte, but also the low byte will match. <br><br>  It sounds a bit confusing, but this scheme is really tested in practice and works. </div><p>Source: <a href="https://habr.com/ru/post/351172/">https://habr.com/ru/post/351172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351162/index.html">Alexey Ragozin on Java Mission Control on jug.msk.ru</a></li>
<li><a href="../351164/index.html">Welcome to the Whatever Hack hackathon March 16</a></li>
<li><a href="../351166/index.html">Guide to background work in Android. Part 3: Executors and EventBus</a></li>
<li><a href="../351168/index.html">Understanding redux-saga: From action generators to sagas</a></li>
<li><a href="../351170/index.html">How Red Hat killed its main product and became a multi-billion dollar corporation</a></li>
<li><a href="../351174/index.html">Oculus Rift helmets did not work for almost a day due to an overdue code signature certificate.</a></li>
<li><a href="../351176/index.html">Personal recommendations in ivi: Hydra</a></li>
<li><a href="../351178/index.html">How we adopted the Khan Academy experience and made our course for testers</a></li>
<li><a href="../351180/index.html">JetBrains Open Day in Moscow</a></li>
<li><a href="../351182/index.html">Hosting PCI DSS: what you need to know</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>