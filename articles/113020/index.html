<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mamdani algorithm in fuzzy inference systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 It just so happened that any article on fuzzy logic can be started from the mention of the name Lotfi Zade. And I will not be an except...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mamdani algorithm in fuzzy inference systems</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  It just so happened that any article on fuzzy logic can be started from the mention of the name Lotfi Zade.  And I will not be an exception.  The fact is that this man became not only the founding father of a whole scientific theory, writing the fundamental work Fuzzy Sets in 1965, but also worked on various possibilities of its practical application.  He described his approach in 1973 in the text ‚ÄúOutline of the Systems and Decision Processes‚Äù (published in IEEE Transactions on Systems).  It is noteworthy that immediately after its release, one enterprising Danish company very successfully applied the principles laid down in it to improve its management system for a complex production process. <br><br>  But with all the merits of L. Zadeh, the followers of this theory made an equally important contribution.  For example, the English mathematician E. Mamdani (Ebrahim Mamdani).  In 1975, he developed an algorithm that was proposed as a method for controlling a steam engine.  The algorithm proposed by him, based on fuzzy logical inference, made it possible to avoid an excessively large amount of computation and was appreciated by experts.  This algorithm is currently the most practical application in fuzzy modeling problems. <br><a name="habracut"></a><br><h3>  Basic definitions </h3><br>  Before you begin to get acquainted with the algorithm, it is important to briefly review the following definitions: <br><br>  <em>A fuzzy variable</em> is a tuple of the form &lt;Œ±, <em>X</em> , <em>Œë</em> &gt;, where: <br>  Œ± is the name of a fuzzy variable; <br>  <em>X</em> is its domain; <br>  <em>A</em> is a fuzzy set in the universe <em>X.</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u>Example:</u> Fuzzy variable &lt;‚ÄúHeavy body armor‚Äù, { <em>x</em> |  0 kg &lt; <em>x</em> &lt;35 kg}, <em>B</em> = { <em>x</em> , Œº ( <em>x</em> )}&gt; characterizes the mass of the military body armor.  We consider it heavy if its mass is&gt; 16 kg (Fig. 1). <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/05/64/05647afdf51cf81437d5528334e11813.png"></div><br>  Fig.  1. Graph of the membership function Œº ( <em>x</em> ) for a fuzzy set <em>B</em> <br><br>  <em>The linguistic variable</em> is a tuple &lt;Œ≤, <em>T, X, G, M</em> &gt;, where: <br>  Œ≤ is the name of a linguistic variable; <br>  <em>T</em> is the set of its values ‚Äã‚Äã(terms); <br>  <em>X</em> - the universe of fuzzy variables; <br>  <em>G</em> - syntactic procedure for the formation of new terms; <br>  <em>M</em> is a semantic procedure that forms fuzzy sets for each term of a given linguistic variable. <br><br>  <u>Example:</u> Suppose we have a subjective assessment of the mass of the body armor.  For example, it can be obtained from military personnel (acting as experts) who directly deal with such ammunition.  This assessment can be formalized using the following linguistic variable &lt;Œ≤, <em>T, X, G, M</em> &gt; (Fig. 2), where: <br>  Œ≤ - body armor; <br>  <em>T</em> - {‚ÄúLightweight bullet-proof vest (Light)‚Äù, ‚ÄúBullet-proof vest of medium weight (Medium)‚Äù, ‚ÄúHeavy bulletproof vest (Heavy)‚Äù}; <br>  <em>X</em> = [0;  35]; <br>  <em>G</em> - procedure for the formation of new terms with the help of logical connectives and modifiers.  For example, ‚Äúvery heavy body armor‚Äù; <br>  <em>M</em> - the procedure for setting the universe <em>X</em> = [0;  35] of the linguistic variable values, i.e.  terms from the set <em>T.</em> <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/ca/4c/ca4ca5983ae8e30a8086b42500456a53.png"></div><br>  Fig.  2. Graphs of the membership functions of the values ‚Äã‚Äãof the linguistic variable ‚ÄúVest‚Äù <br><br>  <em>A fuzzy statement</em> will be called a statement of the form "Œ≤ IS Œ±", where: <br>  Œ≤ is a linguistic variable; <br>  Œ± is one of the terms of this variable. <br><br>  <u>Example:</u> "IS bulletproof vest light."  Here, ‚ÄúBulletproof vest‚Äù is a linguistic variable, and ‚Äúeasy‚Äù is its meaning. <br><br>  Simply put, the <em>rule of fuzzy products</em> (hereinafter simply the rule) will be called the classical rule of the form ‚ÄúIF ... THEN ...‚Äù, where fuzzy statements will be used as conditions and conclusions.  Such rules are written in the following form: <br><br>  IF (Œ≤ <sub>1</sub> IS Œ± <sub>1</sub> ) AND (Œ≤ <sub>2</sub> IS Œ± <sub>2</sub> ) THEN (Œ≤ <sub>3</sub> IS Œ± <sub>3</sub> ). <br><br>  In addition to ‚ÄúAND‚Äù, the logical link ‚ÄúOR‚Äù is also used.  But such a record is usually avoided by dividing such rules into somewhat simpler ones (without the ‚ÄúOR‚Äù).  Also, each of the fuzzy statements in the condition of any rule will be called a <em>sub-condition</em> .  Similarly, each of the statements in conclusion is called a <em>sub-statement</em> . <br><br>  <u>Example:</u> The following examples will help fix the definition: <br><br>  1) IF (Body armor heavy) THEN (Soldier tired); <br>  2) IF (Male sober) AND (High salary) THEN (wife satisfied). <br><br>  Everything.  This minimum is sufficient for understanding the principles of the algorithm. <br><br><h3>  Mamdani Algorithm </h3><br>  This algorithm describes several successive stages (Fig. 3).  In this case, each subsequent stage receives as input the values ‚Äã‚Äãobtained in the previous step. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/d3/96/d3963d1f04f1e048aca0db4ed759cdb2.png"></div><br>  Fig.  3. Diagram of Fuzzy Output Process Activity <br><br>  The algorithm is notable for the fact that it works on the black box principle.  The input receives quantitative values, at the output they are the same.  At the intermediate stages, the apparatus of fuzzy logic and the theory of fuzzy sets is used.  This is the elegance of using fuzzy systems.  You can manipulate the usual numerical data, but at the same time use the flexibility that provide a system of fuzzy inference. <br><br>  To implement the algorithm, an object-oriented approach was used.  The source code is written in the Java programming language.  The diagram (Fig. 4) shows the most significant connections and relationships between the classes involved in the algorithm. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/a7/71/a771e037fe628b78f0331371fda7f0f9.png"></div><br>  Fig.  4. Class diagram of the implementation of the Mamdani algorithm <br><br>  Rules (Rule) consist of conditions (Condition) and conclusions (Conclusion), which in turn are fuzzy statements (Statement).  A fuzzy statement includes a linguistic variable (Variable) and a term that is represented by a fuzzy set (FuzzySet).  The membership function is defined on a fuzzy set, the value of which can be obtained using the getValue () method.  This is a method defined in the FuzzySetIface interface.  When executing the algorithm, you will need to use the ‚Äúactivated‚Äù fuzzy set (ActivatedFuzzySet), which in some way redefines the membership function of the fuzzy set (FuzzySet).  The algorithm also uses the union of fuzzy sets (UnionOfFuzzySets).  The union is also a fuzzy set, and therefore has an membership function (defined in FuzzySetIface). <br><br>  The Mamdani algorithm (MamdaniAlgorithm), includes all stages (Fig. 3) and uses the rule base (List &lt;Rule&gt;) as input data.  The algorithm also assumes the use of ‚Äúactivated‚Äù fuzzy sets (ActivatedFuzzySet) and their associations (UnionOfFuzzySets). <br><br>  So, the stages of fuzzy output are performed sequentially.  And all the values ‚Äã‚Äãobtained in the previous step can be used in the following. <br><br>  <b>1. Formation of the rule base</b> <br>  <em>A rule base</em> is a set of rules, where each sub-conclusion is associated with a certain weighting factor. <br><br>  The rule base can have the following form (for example, the rules of various structures are used): <br><br>  RULE_1: IF ‚ÄúCondition_1‚Äù THEN ‚ÄúConclusion_1‚Äù ( <em>F</em> <sub>1</sub> ) AND ‚ÄúConclusion_2‚Äù ( <em>F</em> <sub>2</sub> ); <br>  RULE_2: IF "Condition_2" AND "Condition_3" THEN "Conclusion_3" ( <em>F</em> <sub>3</sub> ); <br>  ... <br>  RULE_n: IF ‚ÄúCondition_k‚Äù THEN ‚ÄúConclusion_ (q-1)‚Äù ( <em>F</em> <sub>q-1</sub> ) AND ‚ÄúConclusion_q‚Äù ( <em>F</em> <sub>q</sub> ); <br><br>  Where <em>F</em> <sub>i</sub> are weighting factors, meaning the degree of confidence in the truth of the obtained subconclusions ( <em>i</em> = 1 .. <em>q</em> ).  By default, the weighting factor is assumed to be 1. The linguistic variables present in the conditions are called <em>input</em> , and in the conclusions <em>output</em> . <br><br>  <u>Legend:</u> <br>  <em>n</em> is the number of fuzzy product rules (numberOfRules). <br>  <em>m</em> - number of input variables (numberOfInputVariables). <br>  <em>s</em> - number of output variables (numberOfOutputVariables). <br>  <em>k</em> is the total number of sub-conditions in the rule base (numberOfConditions). <br>  <em>q</em> is the total number of sub-conclusions in the rule base (numberOfConclusions). <br><br>  <u>Note:</u> These symbols will be used in the following steps.  In parentheses are the names of the corresponding variables in the source code. <br><br>  <b>2. Fuzzing input variables</b> <br>  This stage is often referred to as blurring.  The generated rule base and the input data array A = {a <sub>1</sub> , ..., a <sub>m</sub> } are input.  This array contains the values ‚Äã‚Äãof all input variables.  The purpose of this stage is to obtain truth values ‚Äã‚Äãfor all sub-conditions from the rule base.  This happens as follows: for each of the sub-conditions, the value <em>b</em> <sub>i</sub> = Œº ( <em>a</em> <sub>i</sub> ) is found.  Thus, a set of values <em>b</em> <sub>i</sub> ( <em>i</em> = 1 .. <em>k</em> ) is obtained. <br><br>  <u>Implementation:</u> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">double</font> [] fuzzification( <font color="#0000ff">double</font> [] inputData) { <br> <font color="#0000ff">int</font> i = 0; <br> <font color="#0000ff">double</font> [] b = <font color="#0000ff">new</font> <font color="#0000ff">double</font> [numberOfConditions]; <br> <font color="#0000ff">for</font> (Rule rule : rules) { <br> <font color="#0000ff">for</font> (Condition condition : rule.getConditions()) { <br> <font color="#0000ff">int</font> j = condition.getVariable().getId(); <br> FuzzySet term = condition.getTerm(); <br> b[i] = term.getValue(inputData[j]); <br> i++; <br> } <br> } <br> <font color="#0000ff">return</font> b; <br> }</font></code> <br> <br>  <u>Note:</u> The input data array is formed in such a way that the <em>i-</em> th element of the array corresponds to the <em>i-</em> th input variable (the variable number is stored in the integer ¬´id‚Äô field). <br><br>  <b>3. Aggregation of sub-conditions</b> <br>  As mentioned above, the rule condition can be composite, i.e.  include sub-conditions related to each other using the logical AND operation.  The purpose of this stage is to determine the degree of truth of the conditions for each rule of the fuzzy inference system.  Simply put, for each condition we find the minimum value of the truth of all its sub-conditions.  Formally, it looks like this: <br><br>  <em>c</em> <sub>j</sub> = min { <em>b</em> <sub>i</sub> }. <br><br>  Where: <br>  <em>j</em> = 1 .. <em>n</em> ; <br>  <em>i</em> is a number from the set of numbers of sub-conditions in which the <em>j-</em> th input variable participates. <br><br>  <u>Implementation:</u> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">double</font> [] aggregation( <font color="#0000ff">double</font> [] b) { <br> <font color="#0000ff">int</font> i = 0; <br> <font color="#0000ff">int</font> j = 0; <br> <font color="#0000ff">double</font> [] c = <font color="#0000ff">new</font> <font color="#0000ff">double</font> [numberOfInputVariables]; <br> <font color="#0000ff">for</font> (Rule rule : rules) { <br> <font color="#0000ff">double</font> truthOfConditions = 1.0; <br> <font color="#0000ff">for</font> (Condition condition : rule.getConditions()) { <br> truthOfConditions = <font color="#2B91AF">Math</font> .min(truthOfConditions, b[i]); <br> i++; <br> } <br> c[j] = truthOfConditions; <br> j++; <br> } <br> <font color="#0000ff">return</font> c; <br> }</font></code> <br> <br>  <b>4. Activation of sub-conclusions</b> <br>  At this stage there is a transition from the conditions to the sub-conclusions.  For each sub-conclusion there is a degree of truth <em>d</em> <sub>i</sub> = <em>c</em> <sub>i</sub> * <em>F</em> <sub>i</sub> , where <em>i</em> = 1 .. <em>q</em> .  Then, again, to each <em>i</em> -th subclause, the set <em>D</em> <sub>i is</sub> associated with a new membership function.  Its value is determined at least from <em>d</em> <sub>i</sub> and the value of the term membership function from the subconclusions.  This method is called min-activation, which is formally written as follows: <br><br>  Œº <sup>'</sup> <sub>i</sub> ( <em>x</em> ) = min { <em>d</em> <sub>i</sub> , Œº <sub>i</sub> ( <em>x</em> )}. <br><br>  Where: <br>  Œº <sup>'</sup> <sub>i</sub> ( <em>x</em> ) - ‚Äúactivated‚Äù membership function; <br>  Œº <sub>i</sub> ( <em>x</em> ) - term membership function; <br>  <em>d</em> <sub>i</sub> - the degree of truth of the <em>i-</em> th sub-conclusion. <br><br>  So, the goal of this stage is to get a set of ‚Äúactivated‚Äù fuzzy sets <em>D</em> <sub>i</sub> for each of the sub-conclusions in the rule base ( <em>i</em> = 1 .. <em>q</em> ). <br><br>  <u>Implementation:</u> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#2B91AF">List</font> &lt;ActivatedFuzzySet&gt; activation( <font color="#0000ff">double</font> [] c) { <br> <font color="#0000ff">int</font> i = 0; <br> <font color="#2B91AF">List</font> &lt;ActivatedFuzzySet&gt; activatedFuzzySets = <font color="#0000ff">new</font> <font color="#2B91AF">ArrayList</font> &lt;ActivatedFuzzySet&gt;(); <br> <font color="#0000ff">double</font> [] d = <font color="#0000ff">new</font> <font color="#0000ff">double</font> [numberOfConclusions]; <br> <font color="#0000ff">for</font> (Rule rule : rules) { <br> <font color="#0000ff">for</font> (Conclusion conclusion : rule.getConclusions()) { <br> d[i] = c[i]*conclusion.getWeight(); <br> ActivatedFuzzySet activatedFuzzySet = (ActivatedFuzzySet) conclusion.getTerm(); <br> activatedFuzzySet.setTruthDegree(d[i]); <br> activatedFuzzySets.add(activatedFuzzySet); <br> i++; <br> } <br> } <br> <font color="#0000ff">return</font> activatedFuzzySets; <br> }</font></code> <br> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">double</font> getActivatedValue( <font color="#0000ff">double</font> x) { <br> <font color="#0000ff">return</font> <font color="#2B91AF">Math</font> .min(super.getValue(x), truthDegree); <br> }</font></code> <br> <br>  <b>5. Accumulation of conclusions</b> <br>  The purpose of this stage is to obtain a fuzzy set (or their union) for each of the output variables.  It is executed as follows: the <em>i-</em> th output variable is associated with the union of the sets <em>E</em> <sub>i</sub> = ‚à™ <em>D</em> <sub>j</sub> .  Where <em>j</em> is the number of sub-conclusions in which the <em>i</em> -th output variable participates ( <em>i</em> = 1 .. <em>s</em> ).  The union of two fuzzy sets is the third fuzzy set with the following membership function: <br><br>  Œº <sup>'</sup> <sub>i</sub> ( <em>x</em> ) = max {Œº <sub>1</sub> ( <em>x</em> ), Œº <sub>2</sub> ( <em>x</em> )}, where Œº <sub>1</sub> ( <em>x</em> ), Œº <sub>2</sub> ( <em>x</em> ) are the membership functions of the joined sets. <br><br>  <u>Implementation:</u> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#2B91AF">List</font> &lt;UnionOfFuzzySets&gt; accumulation( <font color="#2B91AF">List</font> &lt;ActivatedFuzzySet&gt; activatedFuzzySets) { <br> <font color="#2B91AF">List</font> &lt;UnionOfFuzzySets&gt; unionsOfFuzzySets = <br> <font color="#0000ff">new</font> <font color="#2B91AF">ArrayList</font> &lt;UnionOfFuzzySets&gt;(numberOfOutputVariables); <br> <font color="#0000ff">for</font> (Rule rule : rules) { <br> <font color="#0000ff">for</font> (Conclusion conclusion : rule.getConclusions()) { <br> <font color="#0000ff">int</font> id = conclusion.getVariable().getId(); <br> unionsOfFuzzySets. <font color="#0000ff">get</font> (id).addFuzzySet(activatedFuzzySets. <font color="#0000ff">get</font> (id)); <br> } <br> } <br> <font color="#0000ff">return</font> unionsOfFuzzySets; <br> }</font></code> <br> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">double</font> getMaxValue( <font color="#0000ff">double</font> x) { <br> <font color="#0000ff">double</font> result = 0.0; <br> <font color="#0000ff">for</font> (FuzzySet fuzzySet : fuzzySets) { <br> result = <font color="#2B91AF">Math</font> .max(result, fuzzySet.getValue(x)); <br> } <br> <font color="#0000ff">return</font> result; <br> }</font></code> <br> <br>  <b>6. Defusing output variables</b> <br>  The purpose of defuzzification is to obtain a quantitative value (crisp value) for each of the output linguistic variables.  Formally, this happens as follows.  The <em>i-</em> th output variable and the related set <em>E</em> <sub>i</sub> ( <em>i</em> = 1 .. <em>s</em> ) are considered.  Then using the method of defuzzification is the total quantitative value of the output variable.  In this implementation of the algorithm, the center of gravity method is used, in which the value of the <em>i-</em> th output variable is calculated by the formula: <br><img src="https://habrastorage.org/storage/habraeffect/10/99/1099e57e49a38aa7474ce2321474706e.png"><br><br>  Where: <br>  Œº <sub>i</sub> ( <em>x</em> ) is the membership function of the corresponding fuzzy set <em>E</em> <sub>i</sub> ; <br>  <em>Min</em> and <em>Max</em> - the boundaries of the universe of fuzzy variables; <br>  <em>y</em> <sub>i</sub> is the result of defuzzification. <br><br>  <u>Implementation:</u> <br> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">double</font> [] defuzzification( <font color="#2B91AF">List</font> &lt;UnionOfFuzzySets&gt; unionsOfFuzzySets) { <br> <font color="#0000ff">double</font> [] y = <font color="#0000ff">new</font> <font color="#0000ff">double</font> [numberOfOutputVariables]; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; numberOfOutputVariables; i++) { <br> <font color="#0000ff">double</font> i1 = integral(unionsOfFuzzySets. <font color="#0000ff">get</font> (i), <font color="#0000ff">true</font> ); <br> <font color="#0000ff">double</font> i2 = integral(unionsOfFuzzySets. <font color="#0000ff">get</font> (i), <font color="#0000ff">false</font> ); <br> y[i] = i1 / i2; <br> } <br> <font color="#0000ff">return</font> y; <br> }</font></code> <br> <br><h3>  Conclusion </h3><br>  The Mamdani algorithm and many other fuzzy output algorithms are already implemented in such remarkable products as Fuzzy Logic Toolbox (extension for MatLab), fuzzyTECH and many others.  Therefore, such a detailed consideration of the algorithm, as in this article, is of more theoretical value than practical.  However, I note that only having a solid foundation under you from the knowledge and understanding of the fundamentals of the algorithm, it is possible to apply it with maximum effect. <br><br><h3>  Literature </h3><br>  For those who want to get acquainted with specific examples of the application of the described algorithm, I recommend turning to the following literature: <br><br>  1. Leonenkov A.V.  Fuzzy modeling in MATLAB and fuzzyTECH / A. Leonenkov.  - SPb: BHV-Petersburg, 2003. - 736 p. <br><br>  2. Shtovba S.D.  Design of fuzzy systems using MATLAB / S. Shtovba.  - M: Hotline ‚Äì Telecom, 2007. - 288 p. </div><p>Source: <a href="https://habr.com/ru/post/113020/">https://habr.com/ru/post/113020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113015/index.html">What to feed AI (end)</a></li>
<li><a href="../113016/index.html">Fon. Results of 2010</a></li>
<li><a href="../113017/index.html">A small study of spam sms</a></li>
<li><a href="../113018/index.html">Pending Ext JS 4: Data Package</a></li>
<li><a href="../113019/index.html">Amazon will launch its own video service soon.</a></li>
<li><a href="../113022/index.html">Programming and entrepreneurial fees Imagine Cup</a></li>
<li><a href="../113025/index.html">IBM celebrates 100 years of participation in technical progress.</a></li>
<li><a href="../113026/index.html">Data generation using C ++ templates</a></li>
<li><a href="../113029/index.html">Computer control with variable resistor</a></li>
<li><a href="../113030/index.html">Satellite lost after launch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>