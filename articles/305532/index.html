<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sort warnings of static analyzers by priority when searching for and fixing program errors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In 2015, 6,488 new software vulnerabilities were registered in the National Vulnerability Database ( NVD ) in the United States , for a total of 74.88...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sort warnings of static analyzers by priority when searching for and fixing program errors</h1><div class="post__text post__text-html js-mediator-article">  In 2015, <a href="https://web.nvd.nist.gov/view/vuln/statistics-results%3Fadv_search%3Dtrue%26amp%3Bcves%3Don%26amp%3Bpub_date_start_month%3D0%26amp%3Bpub_date_start_year%3D2015%26amp%3Bpub_date_end_month%3D11%26amp%3Bpub_date_end_year%3D2015%26amp%3Bcvss_version%3D3">6,488 new software vulnerabilities were registered in the <i>National Vulnerability Database</i> ( <i>NVD</i> ) in the United States</a> , for a total of <a href="https://web.nvd.nist.gov/view/vuln/statistics-results%3Fadv_search%3Dtrue%26amp%3Bcves%3Don%26amp%3Bcvss_version%3D3">74.885 vulnerabilities found in the period 1988-2016</a> .  The static analysis tools check the source code of the programs for defects, including potential security vulnerabilities, and issue diagnostic messages (warnings) that indicate the location of the alleged defect, its nature, and, as a rule, additional contextual information.  The accuracy of such warnings is then evaluated by the user.  The effort required to check all warnings and correct all confirmed errors manually is often much larger than the project‚Äôs budget and deadlines.  For this reason, users need tools that would allow them to sort warnings by importance, thereby determining the order in which they are checked.  This article is devoted to our study of this issue using classification models designed to help analysts and programmers in classifying warnings by priority and determining the optimal procedure for correcting the corresponding errors. <br><a name="habracut"></a><br><h2>  Warnings of static analyzers: problems and main task </h2><br>  <a href="https://en.wikipedia.org/wiki/Static_program_analysis">Static analysis tools</a> test applications without performing them, unlike <a href="http://www.ibm.com/developerworks/library/se-static/">dynamic analysis tools</a> .  Static analysis usually checks the source files of a program, although it is possible to check binary files.  The result of such tools is a set of warnings that at a minimum contain information about the location of the defect in the source code (for example, the file path and line number), as well as a text description of the problem.  Many analyzers also provide additional contextual information, for example, information about the execution branches of the investigated code area and the values ‚Äã‚Äãof variables that may trigger this diagnostic.  In case of errors affecting several lines of code at once, in some static analyzers the warning indicates the starting and ending lines. <br><br>  Some of the warnings may be <a href="https://www.cs.umd.edu/~pugh/BugWorkshop05/papers/34-chou.pdf">false positives</a> (false alarms), which are erroneously issued to the correct code and due to the compromise between accuracy and speed of verification that is inevitable for static analysis.  In particular, the analyzer may be forced to produce inaccurate results in order to meet within a reasonable time and an acceptable amount of computing resources.  Some static analyzers, for example, tools for the automatic proof of theorems like the <a href="https://github.com/Z3Prover/z3">Z3</a> , are focused on the accuracy of the analysis at the expense of performance.  In addition to false positive results, static analyzers can also demonstrate false negatives (i.e., when warnings are not issued for an erroneous code).  In some cases, this behavior is explained by the fact that the tool simply cannot detect certain types of errors. <br><br>  The permissible ratios between speed and accuracy of the analysis were agreed upon during discussions between the developers of static analyzers (both closed and open), which resulted in the determination of the optimal number of warnings issued, which would reveal real errors without causing too many false positives. .  On the topic of how difficult these discussions were, there is a noteworthy article by Al Bessie from Coverity <a href="http://cacm.acm.org/magazines/2010/2/69354-a-few-billion-lines-of-code-later/fulltext"><i>: Using the Static Analysis of the Real World</i></a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://resources.sei.cmu.edu/library/asset-view.cfm%3Fassetid%3D295724">A previous study found a</a> decrease in coincidence in the types of defects detected by the most popular tools.  On the one hand, this is explained by the fact that developing a static analyzer from scratch is a laborious task, and manufacturers simply cannot include all types of analysis at once.  On the other hand, diagnostics for some types of errors require a large amount of memory, time for analysis or disk space.  Such diagnostics are not included in the tool if they are in low demand among users. <br><br>  By checking the code base with several analyzers at once, users can identify a wider range of problems, which allows for a deeper analysis.  However, this approach leads to the accumulation of too many warnings to be checked, including false positives. <br><br>  <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.442.4936%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">According to empirical data obtained by Kremenek et al.</a> , For analyzers that are able to effectively detect software errors, false positives account for 30% or more of the total number of warnings issued by them.  Our task, therefore, is to achieve the maximum possible automation of the process of establishing the truth / falsehood of warnings.  We also determine the confidence level of those alerts that require user verification in order to facilitate the sorting of alerts by priority. <br><br><h2>  Our approach </h2><br>  Studies by other authors on the problem of combining warnings from different tools and their evaluation - [ <a href="http://www.cs.utexas.edu/users/mengna09/publications/result-merge-08.pdf">Meng 2008</a> ], [ <a href="http://staff.ustc.edu.cn/~qzheng/45.pdf">Kong 2007</a> ], [ <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.63.9430%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">Kremenek 2004a</a> ] and [ <a href="http://resources.sei.cmu.edu/library/asset-view.cfm%3Fassetid%3D295724">Plakosh 2014</a> ] - rely on statistical methods that do not take into account the complex potential correlations between various factors (for example, they take into account a smaller number of classification features and / or use simpler mathematical models) or do not provide detailed descriptions for warnings from several tools.  At the same time, there are many works that explore the issue of classifying warnings of a single tool and use methods of sorting them by priority based on the same characteristics that are taken into account in our classification models.  Examples of such articles are: [ <a href="https://www.infona.pl/resource/bwmeta1.element.elsevier-ac8f9647-c2f7-3868-855d-dc5bc9f8d42c">Heckman 2011</a> ], [ <a href="http://groups.csail.mit.edu/pag/OLD/reading-group/ruthruff08warnings.pdf">Ruthruff 2008</a> ], [ <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.442.4936%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">Kremenek 2004b</a> ] and [ <a href="http://dl.acm.org/citation.cfm%3Fid%3D1349339">Heckman 2007</a> ]. <br><br>  The authors of previous studies were able to accurately determine the degree of reliability of warnings of individual analyzers and, based on this indicator and a number of other factors, classify them by priority.  Thus, the authors of the study <a href="http://groups.csail.mit.edu/pag/OLD/reading-group/ruthruff08warnings.pdf"><i>Predicting Accurate and Actionable Static Analysis Warnings: An Experimental Approach</i></a> developed models that correctly identified false alarms among the warnings of the <a href="http://findbugs.sourceforge.net/">FindBugs</a> static analyzer in more than 85% of cases.  Warnings to be assessed were sorted by priority based on dynamically updated data on whether confirmed errors of one type or another were corrected in the past.  In previous studies, in solving the problem of differentiation between false and real errors, methods such as collecting contextual information about the code, the choice of warning types, data fusion, machine learning, and mathematical and statistical models were used.  All these methods and mechanisms are used in our study.  In addition, we use the technology of dynamic defect detection, graph theory and model verification mechanism.  Based on the work of other researchers, we have combined many classification features that correspond to the parameters of warnings and the code itself. <br><br>  Our approach also takes into account the research experience of the Carnegie Mellon <i>Software Engineering Institute</i> ( <i>SEI</i> ), <i>Improving the Coding Violations</i> [ <a href="http://resources.sei.cmu.edu/library/asset-view.cfm%3Fassetid%3D295724">Plakosh 2014</a> ], which resulted in the development of three binary logistic regression models for warning classification ( The warnings were taken as a basis, for which there are correspondences in the base of the <a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI%2BCERT%2BCoding%2BStandards">Standards of Safe Programming for SEI CERT</a> ) - these models take into account in which analyzers this or that diagnostics worked.  In other words, for the three rules from <a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI%2BCERT%2BCoding%2BStandards">the SEI CERT Secure Programming Standards, the</a> authors of the study developed classifiers, which were then ‚Äútrained‚Äù on a set of already verified warnings from several tools.  Further, these classifiers were tested on a different set of warnings, each classifier had to evaluate them as true or false, after which the accuracy of the predictions was compared with actual manual evaluation data.  In this work, for the first time, advanced methods of statistical analysis of a set of warnings from different static analyzers were proposed, allowing to predict the truth / falsity of a warning as accurately as possible. <br><br>  In our study, we complement the work of SEI by introducing a mechanism for evaluating additional classification methods and using a much larger number of classification features.  In addition, the data set analyzed by us is more voluminous and heterogeneous.  We have developed classifiers for the rules, as well as an initial classifier that uses the SEI CERT rule identifier format (it includes a 3-letter prefix denoting the rule type, number, hyphen, and programming language name, for example: "INT33-C") one more sign of classification.  We continue to improve our classification models by trying different parameters of classifiers, adding new data to the warning sets that the models are ‚Äútrained‚Äù and tested, as well as experimenting with the input data sets when developing classifiers.  Once the classifier is ready, we apply it to the corresponding warnings in the test set in order to evaluate the prediction accuracy of our models.  The novelty of our approach lies in the fact that we use several analyzers, take into account more signs and apply a number of advanced classification methods from which the most productive ones are selected. <br><br>  The team of researchers from SEI, which helps me in working on this project, includes David Svoboda, Will Sneevli, <a href="http://www.sei.cmu.edu/about/people/profile.cfm%3Fid%3Dstoddard_13987">Robert Stodard</a> , <a href="http://www.sei.cmu.edu/about/people/profile.cfm%3Fid%3Dzubrow_13060">David Zubrow</a> , Jennifer Burns, Guillermo Mars√©-Santurio, Eli Canal, Christine Beck and Richard Jin.  Our team works with <a href="http://clairelegoues.com/">Claire Le Gu</a> , Senior Lecturer <a href="https://www.scs.cmu.edu/">at Carnegie Mellon</a> <i>School of Computer Science</i> ( <i>CMU's School of Computer Science</i> ), who acts as a consultant.  Her experience is extremely useful for our project, since she is engaged in research in the field of software engineering and programming languages, namely, she specializes in the problems of developing, debugging and ensuring the quality of software systems.  Our study also responds to the tasks set by the Ministry of Defense in connection with the need for technology for <a href="https://resources.sei.cmu.edu/asset_files/Webinar/2015_018_101_447799.pdf">operational, followed and automated analysis and verification of applications</a> .  In addition, our study corresponds to one of two objectives <a href="https://insights.sei.cmu.edu/sei_blog/2015/08/the-sei-technical-strategic-plan.html">of the SEI strategic plan</a> : ensuring the security of program-dependent systems throughout their life cycle. <br><br>  Our approach will allow analytics and programmers to sort warnings by importance by automating the following processes: <ul><li>  Determining the degree of reliability of a warning (that is, the probability that a warning is true or false). </li><li>  Distribution of warnings in three categories: estimated true warnings (e-TP), estimated false positives (e-FP) and intermediate warnings (I).  In this case, the warnings of the first group (e-TP), after detection, are immediately sent to the debuggers, bypassing the manual check. </li><li> Sort intermediate warnings based on their confidence level.  It may also take into account additional factors related to this warning, for example, the risks and costs associated with its processing. </li></ul><br>  When developing a classifier for a rule from <a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI%2BCERT%2BCoding%2BStandards">the SEI CERT Secure Programming Standards,</a> we use historical data on all verified warnings related to this rule, as well as new data collected in this project.  Similarly, archived and new data are taken into account when creating a classifier for the entire set of warnings. <br><br>  Based on the experience of the above-mentioned studies (both inside and outside the SEI), we have identified the following classification criteria for inclusion in our models (incomplete list): <ul><li>  warning depth (the depth of the alleged defect in the file) </li><li>  the number of significant lines of code (SLOC) in the function / method, file, program </li><li>  total number of lines of code (LOC) in a function / method, file, program </li><li>  cyclomatic complexity </li><li>  connectivity (program modules) </li><li>  coupling ("" of elements of the module) </li><li>  tongue </li><li>  matching warnings (same lines of code, file and rule) issued by all analyzers </li><li>  code change rate </li><li>  the number of warnings (per file, function, etc.) </li><li>  number of tokens in function / method </li><li>  number of functions / methods in file </li><li>  number of parameters in function / method </li><li>  average number of tokens </li><li>  average SLOC </li><li>  overlapping file paths </li><li>  class name (where applicable) </li><li>  method / function name </li><li>  package name (where applicable) </li><li>  many other instrument-specific indicators that may vary for different warnings </li></ul><br>  The processing of archived data on verified warnings and the corresponding signs from the above list is carried out using four classification methods: <ul><li>  <a href="http://www.jmp.com/support/help/Overview_of_Logistic_Regression.shtml">Nominal Logistic Regression</a> </li><li>  <a href="http://www.stat.cmu.edu/~cshalizi/350/lectures/22/lecture-22.pdf">CART algorithm (decision tree building)</a> </li><li>  <a href="http://trevorstephens.com/post/73770963794/titanic-getting-started-with-r-part-5-random">Random Forest algorithm</a> </li><li>  <a href="https://community.dur.ac.uk/d.p.kaye/dissertation/dissertation.pdf">Teaching with a teacher based on information theory</a> </li></ul><br>  One of the data sets used in our study includes the results of evaluating warnings for 20 source code bases with a total volume of 19,237 KLOC ( <i>thousands of lines of code</i> ) and contains 3,147 confirmed real warnings and 11,772 confirmed false alarms. <br><br>  To verify these databases, the <a href="https://www.cert.org/secure-coding/products-services/scale.cfm%3F">Source Code Analysis Laboratory (SCALe)</a> CERT-software platform was used, combining tools for analyzing a variety of commercial, open and experimental tools.  Due to the fact that SCALe uses the capabilities of several static analyzers, it detects more defects than any single instrument.  However, this approach implies a large amount of output data and, accordingly, requires a lot of labor costs for their processing.  In total, over 16 million lines of code were analyzed using SCALe, including the source databases of the Ministry of Defense, energy supply systems, medical equipment, etc. <br><br>  Using the SCALe GUI, the user loads a set of static analyzer reports and corresponding source files into the tool.  Alerts are saved in a single format to a separate SCALe database.  Each warning is accompanied by additional information, for example, information about the corresponding rule from the set of <a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI%2BCERT%2BCoding%2BStandards">CERT Secure Programming Standards</a> .  SCALe also preserves the associations between these rules and the warnings from each of the connected analyzers, so that several warnings from different tools can correspond to the same CERT rule.  These associations between warnings and rules are of particular importance for our task of classifying warnings at the level of individual rules. <br><br>  The app can also be used to examine alerts.  The browser-based interface allows you to filter warnings and sort them by priority, view the corresponding section of the source code and mark warnings as true or false.  The database is dynamically updated when changes are made. <br><br>  We improved SCALe for our project, so now it can collect additional information for each warning and perform a number of auxiliary tasks, for example, to ensure anonymity of the data.  Additional information is extracted from several sources.  Source code metrics (such as <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> and number of significant lines of code) are calculated using a modified version of the <a href="https://github.com/terryyin/lizard">Lizard</a> tool.  Fields for additional parameters are retrieved from analyzer reports. <br><br>  In addition, we have developed a script that combines and analyzes warnings, preparing data for processing by applications of statistical analysis.  This script converts a multi-table database of a modified version of SCALe into a linear .csv file, in which the records are separated by commas - this format is convenient for tools that perform the classification.  Our script also combines warnings that match the parameters [rule, line number, file].  Finally, the script performs additional analysis and adds to the records such information as the number of warnings per file, the number of warnings per function and the nesting depth of the file in the project, as well as splits the paths to the files so that partially coincident paths can be used as signs of classification. <br><br>  Our method of developing classifiers can easily be extended to work with other standards and platforms that can store verification data.  For example, the CERT programming rules can be replaced by other similar standards, and the SCALe tool by other platforms.  SCALe warnings associations with rules can be replaced with associations with other rules and numbered error lists, for example, <a href="https://cwe.mitre.org/"><i>Common Weakness Enumeration</i></a> , <a href="https://www.owasp.org/index.php/Category:OWASP_Application_Security_Verification_Standard_Project"><i>OWASP Application Security Verification Standard Project,</i></a> and <a href="https://en.wikipedia.org/wiki/MISRA_C">Software Development Standard in C MISRA</a> .  Similarly, alert assessment data from other platforms working with multiple analyzers can be converted to other formats supported by our classifiers and their development tools. <br><br><h2>  Testing our approach with partners from the Ministry of Defense </h2><br>  In addition to the 20 code bases verified by CERT, we use data from three divisions of the Ministry of Defense (we will talk about this type of cooperation in a separate article), two of which stated the need to check the security of their code of more than 100 MSLOC ( <i>million significant lines of code</i> ).  Extrapolating the results collected on the archived data of previous CERT checks (with a ratio of 3.31 warnings per 1,000 lines of code), we expect that for the code bases of both units, approximately 662,000 warnings can be identified.  Our task is to automatically establish the truth / falsity of the marked defects with an accuracy of 95%.  If successful, our method (and analyzers based on it) will help to significantly reduce labor costs for evaluating analysis results and sorting found defects by priority. <br><br>  When using our automatic classification system, specialists in the mentioned divisions could process warnings according to the following scheme: <ul><li>  <b>e-TP</b> (perceived true errors) are sent directly to the debugger team. </li><li>  <b>I</b> (interim warnings) are sent for evaluation by a team of analysts. </li><li>  <b>e-FP</b> (suspected false positives) are ignored. </li></ul><br>  Further extrapolation of CERT archive data gives a true / false warning ratio of 1: 3.74.  Thus, given our ambitious task of processing 90% of warnings and correctly distributing them to the <i>e-TP</i> and <i>e-FP</i> groups, the following results are expected for 200 MSLOC: 126,000 <i>e-TP</i> , which will be sent immediately to the debugger team, 470,000 <i>e-FP</i> which will be ignored, and 66,000 <i>I</i> , which will be evaluated manually.  These numbers suggest a 90% reduction in the time for manual evaluation of warnings, and all warnings will be taken into account, so that the code‚Äôs security level will not decrease (in other words, 90% of the automatically identified <i>e-TP</i> or <i>e-FP</i> warnings correspond to a reduction in their manual estimate by 90%).  The degree of reliability of intermediate warnings will help determine the order of their verification.  In practice, those of them that have the lowest priority can be completely ignored. <br><br>  The figure below shows how our method will help improve the process of checking applications.  Code bases are checked by several static analyzers, and each of them gives its own set of warnings.  The arrows under the caption "Today" ("today"), leading from the ‚ÄúAlerts‚Äù block to the chart with a red frame, indicate a familiar alert handling strategy, in which each of the alerts and the corresponding code must be manually checked to establish its truth or falsity. This process usually takes too much time, given the limited budget of projects. The yellow circle on this diagram shows the number of warnings that can be estimated for 12,939 hours of work (assuming that  each alert normally takes 5 minutes, according to a study [ <a href="http://www.coverity.com/library/pdf/Coverity-Effective-Management-of-Static-Analysis-Defects.pdf">Hayward, 2008</a> ]), and the red ellipse - the remaining 506.733 untested prevention On the other hand, our strategy shows the upper row of arrows:. 90% of alerts will be automatically and correctly divided into groups <i>e-TP</i> or <i>e-FP</i> , with the result that the user will only have to check 66,000 interim warnings.This will take only 5,500 hours, which is less than half the time for the first scenario.  Moreover, our method ensures that all warnings requiring manual verification will definitely pass it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/071/caf/4a1/071caf4a1d2eacd5a0b7e08e76452830.png"><br><br>  <i>Fig.</i>  <i>1: The task of our study is to significantly reduce the time for the manual assessment of unverified warnings and their number.</i>  <i>The image of a woman and a laptop (‚ÄúWoman And Laptop‚Äù) is taken from the following source: <a href="http://www.publicdomainpictures.net/view-image.php%3Fimage%3D47526%26amp%3Bpicture%3Dwoman-and-laptop"><i></i></a><i><a href="http://www.publicdomainpictures.net/view-image.php%3Fimage%3D47526%26picture%3Dwoman-and-laptop">www.publicdomainpictures.net/view-image.php?image=47526&amp;picture=woman-and-laptop</a></i> .</i> <br><br><h2>  Further work </h2><br>  A recent study on <a href="https://ece.uwaterloo.ca/~lintan/publications/deeplearn-icse16.pdf"><i>Automatically Learning Semantic Features for Defect Prediction</i></a> has shown that analyzing the semantic features of programs can significantly improve the detection accuracy of software defects.  In this regard, we plan to subsequently add such an analysis to our classification models.  Moreover, we expect to use semantic features from reports stored in repositories when developing classifiers.  We are also going to use the automatic parameter optimization mechanism for classification methods, which, according to a recent study of <a href="http://chakkrit.com/assets/papers/tantithamthavorn2016icse.pdf"><i>Automated Parameter Optimization of Classification Techniques for Defect Prediction Models</i></a> , will significantly improve our classifiers. <br><br>  In the future, we may also add an advanced analysis of the costs, risks and benefits of verifying warnings and taking these indicators into account, along with the degree of confidence in determining the sensitivity of our classification models.  This approach will increase the likelihood of their implementation in software companies. <br><br>  Our system supports any rules of CERT programming, and in the future we plan to develop classifiers for other standards.  At the moment, we are limited to a set of analyzers used and the willingness of potential consumers to acquire and maintain several tools. <br><br>  It is also possible that in the future the results of our research will be combined with automatic code correction solutions that are currently being worked on at SEI.  In this case, our models will be applied <b><i>after</i></b> automatic refactoring of the code, which will help eliminate only a small number of warnings about potential errors.  Our method can be used to sort by priority (in expert analysis) of potential semi-automatic fixes that are not guaranteed correct and require manual evaluation (for example, the specialist must determine whether some automatic fix will be correct given the <b><i>desired</i></b> code <b><i>behavior</i></b> ).  All other warnings for which there are no automatic fixes can be classified in the usual way using our method, as described above (i.e., categorized as <i>e-TP</i> , <i>e-FP</i> and <i>I</i> ). <br><br>  In the next article of this series, we will discuss the cooperation of our team with the three divisions of the Ministry of Defense mentioned above. <br><br>  We welcome your feedback on this work - leave them in the comments section below the text. <br><br><h2>  Additional resources </h2><br>  Read and comment on our articles and help us improve <a href="https://www.securecoding.cert.org/confluence/display/seccode/SEI%2BCERT%2BCoding%2BStandards">the SEI CERT Programming Standards</a> , which are developed on the basis of publicly available wikis. <br><br>  We also invite you to visit the <a href="https://www.cert.org/secure-coding/products-services/scale.cfm%3F">CERT source code analysis</a> website. <br><br>  The following are sources of citations in this article: <br><br>  [Heckman 2011] Heckman, Sarah, and Laurie Williams.  <a href="https://www.infona.pl/resource/bwmeta1.element.elsevier-ac8f9647-c2f7-3868-855d-dc5bc9f8d42c"><i>Automated code review</i></a> .  Information and Software Technology 53.4 (2011): 363-387. <br><br>  [Heckman 2007] Heckman, Sarah.  <a href="http://dl.acm.org/citation.cfm%3Fid%3D1349339"><i>Adaptively ranking alerts generated from automated static analysis</i></a> , Crossroads 14.1, 2007. <br><br>  [Kong 2007] Kong, Deguang, et al.  <a href="http://staff.ustc.edu.cn/~qzheng/45.pdf"><i>ISA: a source code for static data fusion</i></a> .  Scalable information systems.  ICST, 2007. <br><br>  [Kremenek 2004] Kremenek, Ted, et al.  Correlation exploitation in error ranking.  ACM SIGSOFT Software Engineering Notes.  Volume 29. N6.  ACM, 2004. <br><br>  [Meng 2008] N. Meng, Q. Wang, Q. Wu, H. Mei, <a href="http://www.cs.utexas.edu/users/mengna09/publications/result-merge-08.pdf"><i>Analogue of the Multiple Scattering Analysis Tools</i></a> , International Conference on Quality Software, Oxford, UK, August 12-13, 2008 <br><br>  [Plakosh, 2014] Plakosh, Daniel, Robert Seacord, Robert W. Stoddard, David Svoboda, and David Zubrow.  <a href="http://resources.sei.cmu.edu/library/asset-view.cfm%3Fassetid%3D295724"><i>Improving the Automated Detection and Analysis of Secure Coding Violations</i></a> .  (2014). <br><br>  [Ruthruff 2008] Ruthruff, Joseph R., et al.  <a href="http://groups.csail.mit.edu/pag/OLD/reading-group/ruthruff08warnings.pdf"><i>Predicting accurate and static analysis warnings: an experimental approach</i></a> .  Proceedings of the 30th international conference on Software engineering.  ACM, 2008. <br><br><div class="spoiler">  <b class="spoiler_title">Translation Acknowledgments</b> <div class="spoiler_text"><ul><li>  This is a non-SEI-sanctioned translation of the blog post "by Lori Flynn 2016", by Carnegie Mellon University, has been trained by the Software Engineering Institute. <br></li><li>  This is not the case for the Carnegie University.  Accuracy and interpretation of this translation are by Andrey Karpov. </li><li>  ANY MATERIAL OF CARNEGIE MELLON UNIVERSITY AND / OR ITS SOFTWARE ENGINEERING INSTITUTE CONTAINED HEREIN IS FURNISHED ON AN "AS-IS" BASIS.  CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, ETHER EXPRESSED OR IMPLIED, BUT NOT LIMITED  UNITED KINGDOES OF THE KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT. </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/305532/">https://habr.com/ru/post/305532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305520/index.html">How artificial restrictions help in work</a></li>
<li><a href="../305524/index.html">Organization of an international gambling company in Curacao</a></li>
<li><a href="../305526/index.html">City AD: schoolchildren and students</a></li>
<li><a href="../305528/index.html">Android development using qt and android studio part two</a></li>
<li><a href="../305530/index.html">Linux kernel module on Swift</a></li>
<li><a href="../305534/index.html">Clojure course materials</a></li>
<li><a href="../305536/index.html">Rust code is included in Firefox 48</a></li>
<li><a href="../305544/index.html">Expansion of functionality Scene View in Unity3D. Interception of events</a></li>
<li><a href="../305546/index.html">Who is aggregated by Meduza?</a></li>
<li><a href="../305548/index.html">Fighting BEM: 10 major mistakes and how to avoid them</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>