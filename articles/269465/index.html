<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We have problems with promises</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let me introduce you to the translation of Nolan Lawson's article ‚Äú We have problems with promises ‚Äù, one of the best topics I've ever read. 

 We hav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We have problems with promises</h1><div class="post__text post__text-html js-mediator-article">  <i>Let me introduce you to the translation of Nolan Lawson's article ‚Äú <a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">We have problems with promises</a> ‚Äù, one of the best topics I've ever read.</i> <br><br><h3>  We have problems with promises </h3><br>  Dear JavaScript developers, the time has come to recognize this - we have problems with promises. <br><br>  No, not with the promises themselves.  Their implementation of <a href="https://promisesaplus.com/">the A + specification is</a> excellent.  The main problem, which itself appeared to me over the years of observing how many programmers are struggling with the rich API promises, is the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - Many of us use promises without a real understanding of them. <br><br>  If you do not believe me, solve this problem: <br><br>  <b>Question: What is the difference between these four options for using promises?</b> <br><br><pre><code class="javascript hljs">doSomething().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingElse(); }); doSomething().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ doSomethingElse(); }); doSomething().then(doSomethingElse()); doSomething().then(doSomethingElse);</code> </pre> <br><a name="habracut"></a><br>  If you know the answer, then let me congratulate you - on the part of promises you are a ninja.  Perhaps you can not read further this post. <br><br>  The rest of 99.99% of you, I am in a hurry to say that you are not upset, you are in good company.  No one who responded to <a href="https://twitter.com/nolanlawson/status/578948854411878400">my tweet</a> could solve the problem.  Even I was very surprised by the answer to the 3rd question.  Yes, despite the fact that I asked him! <br><br>  The answer to the problem is given at the very end of the article, but first I would like to explain why promises in the first approximation are so insidious, and why many of us, beginners and experts, fall into their traps.  I also want to offer you my solution, one unusual trick that will help you better understand the promises.  And, of course, I believe that after my explanation they will not seem so complicated to you. <br><br>  Before we begin, let's mark some points. <br><br><h3>  Why promises? </h3><br>  If you read articles about promises, you will often see references to the " <a href="https://medium.com/%40wavded/managing-node-js-callback-hell-1fe03ba8baf">pyramid of evil</a> " ("pyramide of doom" in orig.), Formed by a terrible code on callbacks, which stretches the page to the right behind the screen. <br><br>  Promises do solve this problem, but this is more than just reducing indents.  As explained in the remarkable conversation ‚Äú <a href="http://www.youtube.com/watch%3Fv%3Dhf1T_AONQJU">Salvation from callbacks of hell,</a> ‚Äù their real problem is that they make it impossible for us to use the <b>return</b> and <b>throw</b> instructions.  Instead, the logic of our programs is based on the use of side effects when one function calls another. <br><br>  Also callbacks do something really sinister, they deprive us of the stack, what is taken for granted in programming languages.  Writing code without a stack is the same as driving a car without a brake pedal.  You have no idea how important it is until you really do not need it and it is not there. <br><br>  The whole point of the promises is to give us back the basics of the language that were lost at the time of our transition to asynchrony: <b>return</b> , <b>throw,</b> and stack.  But you must know how to properly use promises to rise to a higher level in this. <br><br><h2>  Novice bugs </h2><br>  Someone is trying to explain the promises <a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html">in the form of a cartoon</a> or, saying: <i>‚ÄúOh!</i>  <i>This is a thing that you can create and transmit everywhere, and it symbolizes some value that is received and returned asynchronously</i> . <i>‚Äù</i> <br><br>  I do not find such an explanation quite useful.  For me, promises are always part of the code structure, its execution flow. <br><br>  A small digression: the term "promises" for different people carries a different meaning.  In this article I will talk about the <a href="https://promisesaplus.com/">official specification</a> , available in modern browsers as <b>window.Promise</b> .  For those browsers that do not have <b>window.Promise</b> , there is a nice polifil with a cheeky name <a href="https://github.com/calvinmetcalf/lie">Lie</a> (false), containing a minimal implementation of the specification. <br><br><h3>  Error novice number 1 - "pyramid of evil" from promises </h3><br>  Looking at how people use PouchDB, whose API is heavily tied to promises, I see a lot of bad patterns for using them.  Here is the most common example: <br><br><pre> <code class="javascript hljs">remotedb.allDocs({ <span class="hljs-attr"><span class="hljs-attr">include_docs</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">attachments</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> docs = result.rows; docs.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ localdb.put(element.doc).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Pulled doc with id "</span></span> + element.doc._id + <span class="hljs-string"><span class="hljs-string">" and added to local db."</span></span>); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err.status == <span class="hljs-number"><span class="hljs-number">409</span></span>) { localdb.get(element.doc._id).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resp</span></span></span><span class="hljs-function">) </span></span>{ localdb.remove(resp._id, resp._rev).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ‚Ä¶</span></span></code> </pre><br>  Yes, it turns out that we can use the promises as if they were callbacks, and yes, it is like shooting a gun at the sparrows. <br><br>  If you think that only absolute beginners make such mistakes, I will surprise you - the <a href="">example</a> code <a href="">above is</a> taken from the <a href="http://devblog.blackberry.com/2015/05/connecting-to-couchbase-with-pouchdb/">official BlackBerry developers blog</a> !  It is difficult to get rid of the old habits of using callbacks. <br><br>  Here is a better option: <br><br><pre> <code class="javascript hljs">remotedb.allDocs(...) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultOfAllDocs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localdb.put(...); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultOfPut</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localdb.get(...); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultOfGet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localdb.put(...); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); });</code> </pre><br>  In the example above, composite promises were used (‚Äúcomposing promises‚Äù in orig.) - one of the strongest sides of promises.  Each subsequent function will be called when the previous promise is ‚Äúkilled‚Äù, and it will be called with the result of the previous promise.  Details will be below. <br><br><h3>  Newbie error number 2 - how do I use forEach () with promises? </h3><br>  This is the moment when the understanding of promises by most people begins to pass.  They are familiar with the <b>forEach</b> , <b>for,</b> or <b>while</b> iterators, but they have no idea how to combine them with promises.  Then something like this is born: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    remove()    db.allDocs({include_docs: true}) .then(function (result) { result.rows.forEach(function (row) { //  remove  promise db.remove(row.doc); }); }) .then(function () { //     ,     ! });</span></span></code> </pre><br>  What is wrong with this code?  The problem is that the first function returns <b>undefined</b> , which means the second does not wait for the completion of <b>db.remove ()</b> for all documents.  In fact, it waits for nothing at all and will be executed when any number of documents are deleted, and maybe not even one. <br><br>  This is a very insidious mistake, because at first you may not even notice it, especially if the documents are deleted quickly enough to update the interface.  A bug can pop up only in rare cases, not in all browsers, which means it will be almost impossible to identify and fix it. <br><br>  Summing up, I will say that constructions like <b>forEach</b> , <b>for</b> and <b>while are</b> <i>‚Äúnot the drones you are looking for</i> . <i>‚Äù</i>  You need <b>Promise.all ()</b> : <br><br><pre> <code class="javascript hljs">db.allDocs({<span class="hljs-attr"><span class="hljs-attr">include_docs</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayOfPromises = result.rows.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.remove(row.doc); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(arrayOfPromises); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arrayOfResults</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ! });</span></span></code> </pre><br>  What's going on here?  <b>Promise.all ()</b> accepts an array of promises as an argument and returns a new promise, which is ‚Äúcleared‚Äù only when all documents are deleted.  This is the asynchronous equivalent of a <b>for</b> loop. <br><br>  Also promise from <b>Promise.all ()</b> will transfer to the next function an array of results, which can be very convenient if you, for example, do not delete documents, but receive data from several sources at once.  If at least one promise from the array passed to <b>Promise.all () is</b> "registered", then the resulting promise will go to the <b>rejected</b> state. <br><br><h3>  Newbie error number 3 - forget to add .catch () </h3><br>  This is another common mistake - blissfully believing that your promises will never return an error.  Many developers simply forget to add <b>catch ()</b> anywhere in their code. <br><br>  Unfortunately, this often means that errors will be ‚Äúswallowed‚Äù.  You never even know that they were - a special pain when debugging an application. <br><br>  To avoid this unpleasant scenario, I made it a rule, which then grew into a habit of always adding a <b>catch ()</b> method to the end of my promis chain: <br><br><pre> <code class="javascript hljs">somePromise().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherPromise(); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherPromise(); }) <span class="hljs-comment"><span class="hljs-comment">//      : .catch(console.log.bind(console));</span></span></code> </pre><br>  Even if you are guaranteed not to expect any errors at all, adding <b>catch ()</b> is a reasonable solution.  Then, if suddenly your assumption about mistakes is not justified, you will thank yourself. <br><br><h3>  Newbie error number 4 - use "deferred" </h3><br>  I see this error all the time, and I don‚Äôt even want to repeat the name of this object, fearing that he, like The <a href="https://afisha.mail.ru/cinema/movies/625126_bitldzhus/">Beatles</a> from the film of the same name, is just waiting to increase the number of instances of his use. <br><br>  In short, in its development, the promises have gone a long way.  It took a lot of time for the javascript community to implement them correctly.  Initially, jQuery and Angular used the pattern of deferred objects everywhere, which was later replaced by the specification of ES6 promises, which were based on the ‚Äúgood‚Äù libraries Q, When, RSVP, Bluebird, Lie and others. <br><br>  In general, if you suddenly wrote this word in your code (I will not repeat it a third time!), Know that you are doing something wrong.  Below is a recipe for how to avoid it. <br><br>  Most "promis" libraries give you the ability to import promises from other libraries.  For example, the <b>$ q</b> module from Angular allows you to wrap non- $ q promises with <b>$ q.when ()</b> .  That is, Angular users can wrap PouchDB promises like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  : $q.when(db.put(doc)).then(/* ... */);</span></span></code> </pre><br>  Another way is to use the ‚Äúrevealing constructor pattern‚Äù pattern in the original.  It is convenient for wrapping an API that does not use promises.  For example, to wrap a callback-based Node.js API, you can do the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ fs.readFile(<span class="hljs-string"><span class="hljs-string">'myfile.txt'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, file</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject(err); } resolve(file); }); }).then(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>)</code> </pre><br>  Done!  We dealt with a terrible defer ... Ah, I almost said the third time!  :) <br><br><h3>  Novice Error 5 - using external functions instead of returning results </h3><br>  What is wrong with this code? <br><br><pre> <code class="javascript hljs">somePromise().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ someOtherPromise(); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,   someOtherPromise ¬´¬ª‚Ä¶ // , : ,  ¬´¬ª. });</span></span></code> </pre><br>  Well, now is the perfect moment to talk about everything that you should know about promises. <br><br>  Seriously, this is the same trick, having understood that, you yourself will be able to avoid all those mistakes that we talked about.  You are ready? <br><br>  As I already mentioned, the magic of promises is that they return precious <b>return</b> and <b>throw to us</b> .  But what does this mean in practice? <br><br>  Each promise provides you with the <b>then ()</b> method (and also <b>catch ()</b> , which in practice is just ‚Äúsugar‚Äù for <b>then (null, ...)</b> ).  And here we are inside the <b>then ()</b> function: <br><br><pre> <code class="javascript hljs">somePromise().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,    then()! });</span></span></code> </pre><br>  What can we do here?  Three things: <br><br><ol><li>  Return ( <b>return</b> ) another promise </li><li>  Return ( <b>return</b> ) synchronous value (or <b>undefined</b> ) </li><li>  Throw a synchronous error </li></ol><br>  That's it, the whole trick.  If you understand him, you will understand promises.  Let's now analyze in detail each of the items. <br><br><h4>  1. Return another promise </h4><br>  This is a frequent pattern that you could see in all sorts of promise literature, as well as in the example with the composite promises above: <br><br><pre> <code class="javascript hljs">getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  getUserAccountById  promise, //      then return getUserAccountById(user.id); }) .then(function (userAccount) { //     ! });</span></span></code> </pre><br>  Pay attention that I return the second promis, I use <b>return</b> .  Using <b>return</b> here is a key point.  If I just called <b>getUserAccountById</b> , then yes, there would be a request for user data, a result would be obtained that would not be useful anywhere - the next would <b>then</b> get <b>undefined</b> instead of the desired <b>userAccount</b> . <br><br><h4>  2. Return a synchronous value (or undefined) </h4><br>  Returning <b>undefined</b> as a result is a common mistake.  But the return of any synchronous value is a great way to convert a synchronous code into a chain of promises.  Suppose we have a cache of user data in our memory.  We can: <br><br><pre> <code class="javascript hljs">getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inMemoryCache[user.id]) { <span class="hljs-comment"><span class="hljs-comment">//     , //   return inMemoryCache[user.id]; } //       , //    return getUserAccountById(user.id); }) .then(function (userAccount) { //     ! });</span></span></code> </pre><br>  Isn't it cool?  The second function in the chain does not matter where the data came from, from the cache or as a result of the request, and the first is free to return either a synchronous value immediately or an asynchronous promise, which already in turn returns a synchronous value. <br><br>  Unfortunately, if you did not use <b>return</b> , the function will still return a value, but it will no longer be the result of a call to the nested function, but a useless <b>undefined</b> , which is returned by default in such cases. <br><br>  For myself, I made a rule, which then grew into a habit - always use <b>return</b> inside then or give an error with <b>throw</b> .  I recommend that you do the same. <br><br><h4>  3. Issue a synchronous error </h4><br>  Here we come to <b>throw</b> .  Here the promises start to shine even brighter.  Suppose we want to issue ( <b>throw</b> ) a synchronous error if the user is not authorized.  It's simple: <br><br><pre> <code class="javascript hljs">getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.isLoggedOut()) { <span class="hljs-comment"><span class="hljs-comment">//   ‚Äî  ! throw new Error('user logged out!'); } if (inMemoryCache[user.id]) { //     , //   return inMemoryCache[user.id]; } //       , //    return getUserAccountById(user.id); }) .then(function (userAccount) { //     ! }) .catch(function (err) { // , ,     ! });</span></span></code> </pre><br>  Our <b>catch ()</b> will get a synchronous error if the user is not authorized, or asynchronous if any of the promises above go into the <b>rejected</b> state.  And again, the functions in <b>catch</b> without a difference, were a synchronous or asynchronous error. <br><br>  This is especially useful for tracing errors during development.  For example, the formation of an object from a string using <b>JSON.parse ()</b> somewhere inside <b>then ()</b> may give an error if <b>json is</b> invalid.  With callbacks, it will be ‚Äúswallowed up,‚Äù but with the help of the <b>catch ()</b> method we can easily handle it. <br><br><h2>  Advanced bugs </h2><br>  Well, now that you've learned the main trick of the promises, let's talk about extreme cases.  Because there are always extreme cases. <br><br>  I call this category of errors ‚Äúadvanced‚Äù, because I only met them in the code that are familiar with programmer promises.  We need to discuss such errors in order to make out the puzzle that I published at the very beginning of the article. <br><br><h3>  Advanced error number 1 - do not know about Promise.resolve () </h3><br>  I have already shown above how convenient promises are when wrapping synchronous logic in asynchronous code.  You might have noticed something similar: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve(someSynchronousValue); }).then(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre><br>  Keep in mind, you can write the same thing much shorter: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(someSynchronousValue).then(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre><br>  Also, this approach is very convenient for catching any synchronous errors.  It is so convenient that I use it in almost all API methods that return promises: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">somePromiseAPI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ doSomethingThatMayThrow(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; }) .then(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); }</code> </pre><br>  Just remember, any code that can produce a synchronous error is a potential debugging problem due to swallowed errors.  But if you wrap it in <b>Promise.resolve ()</b> , you can be sure that you will catch it with <b>catch ()</b> . <br><br>  There is also <b>Promise.reject ()</b> .  It can be used to return promise in <b>rejected</b> status: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-  '</span></span>));</code> </pre><br><h3>  Advanced error # 2 - catch () is not the same with then (null, ...) </h3><br>  Just above, I mentioned that <b>catch ()</b> is just ‚Äúsugar‚Äù.  The two examples below are equivalent: <br><br><pre> <code class="javascript hljs">somePromise().catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }); somePromise().then(null, function (err) { //   });</span></span></code> </pre><br>  However, the examples below are no longer ‚Äúequal‚Äù: <br><br><pre> <code class="javascript hljs">somePromise().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someOtherPromise(); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }); somePromise().then(function () { return someOtherPromise(); }, function (err) { //   });</span></span></code> </pre><br>  If you think about why the examples above are ‚Äúnot equal,‚Äù look carefully at what happens if an error occurs in the first function: <br><br><pre> <code class="javascript hljs">somePromise().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'oh noes'</span></span>); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! :) }); somePromise().then(function () { throw new Error('oh noes'); }, function (err) { // ?  ? O_o });</span></span></code> </pre><br>  It turns out that if you use the <b>then (resolveHandler, rejectHandler) format</b> , then the <b>rejectHandler</b> in fact cannot catch the error that occurred inside the <b>resolveHandler</b> function. <br><br>  Knowing this feature, for myself I introduced the rule never to use the second function in the <b>then ()</b> method, and in return always add error handling below in the form of <b>catch ()</b> .  I have only one exception - asynchronous tests in <a href="http://mochajs.org/">Mocha</a> , in cases when I deliberately wait for an error: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should throw an error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingThatThrows().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'I expected an error!'</span></span>); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ should.exist(err); }); });</code> </pre><br>  By the way, <a href="http://mochajs.org/">Mocha</a> and <a href="http://chaijs.com/">Chai</a> are a great combination for testing promise-based APIs. <br><br><h3>  Advanced error number 3 - promises against promise factories </h3><br>  Suppose you want to perform a series of promises one after another, sequentially.  You want something like <b>Promise.all ()</b> , but one that <b>does not</b> perform promises in parallel. <br><br>  In the heat of the moment, you can write something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeSequentially</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(); promises.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function">) </span></span>{ result = result.then(promise); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Unfortunately, the example above will not work as intended.  Promises from the list passed to <b>executeSequentially ()</b> will still run in parallel. <br><br>  The reason is that, according to the specification, the promis starts to execute the logic embedded in it immediately after its creation.  He will not wait.  Thus, not the promises themselves, but an array of promise factories - this is what really needs to be passed to <b>executeSequentially</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeSequentially</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promiseFactories</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(); promiseFactories.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promiseFactory</span></span></span><span class="hljs-function">) </span></span>{ result = result.then(promiseFactory); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  I know you are thinking now: <i>‚ÄúWho the hell is this Java programmer, and why does he tell us about factories?‚Äù</i> .  In fact, a factory is a simple function that returns a promise: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myPromiseFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> somethingThatCreatesAPromise(); }</code> </pre><br>  Why this example will work?  And because our factory will not create a promise until it is a turn.  It works exactly as <b>resolveHandler</b> for <b>then ()</b> . <br><br>  Look closely at the <b>executeSequentially ()</b> function and mentally replace the link to <b>promiseFactory with</b> its contents - now a light bulb should joyfully flash above your head :) <br><br><h3>  Advanced error # 4 - what if I want the result of two promises? </h3><br>  It often happens that one promise depends on the other, and we need the results of both at the output.  For example: <br><br><pre> <code class="javascript hljs">getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUserAccountById(user.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userAccount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     ¬´user¬ª ! });</span></span></code> </pre><br>  Wanting to remain good JavaScript developers, we may want to bring the <b>user</b> variable to a higher level of visibility so as not to create an ‚Äúevil pyramid‚Äù. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user; getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ user = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUserAccountById(user.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userAccount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,    ¬´user¬ª,  ¬´userAccount¬ª });</span></span></code> </pre><br>  It works, but personally I think that the code ‚Äúsmacks‚Äù.  My decision is to push aside prejudice and take a conscious step towards the ‚Äúpyramid‚Äù: <br><br><pre> <code class="javascript hljs">getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUserAccountById(user.id) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userAccount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,    ¬´user¬ª,  ¬´userAccount¬ª }); });</span></span></code> </pre><br>  ... at least a temporary step.  If you feel that the indentation is increasing and the pyramid begins to grow threateningly, do what JavaScript developers have done for centuries - create a function and use it by name. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onGetUserAndUserAccount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, userAccount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomething(user, userAccount); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onGetUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUserAccountById(user.id) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userAccount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> onGetUserAndUserAccount(user, userAccount); }); } getUserByName(<span class="hljs-string"><span class="hljs-string">'nolan'</span></span>) .then(onGetUser) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     doSomething() , //     ‚Äî     });</span></span></code> </pre><br>  As the code becomes more complex, you will notice that more and more of it is transformed into named functions, and the application logic itself begins to take on an aesthetic pleasure: <br><br><pre> <code class="javascript hljs">putYourRightFootIn() .then(putYourRightFootOut) .then(putYourRightFootIn) .then(shakeItAllAbout);</code> </pre><br>     . <br><br><h3>   ‚Ññ5 ‚Äî ¬´¬ª   </h3><br> ,      ,       .    . ,       .  ,   . <br><br>   ,      ? <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) .then(<span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); });</code> </pre><br>   ,    bar,  .    foo! <br><br>   , ,     <b>then()</b> -    (, ),    <b>then(null)</b>       ¬´¬ª  .  : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) .then(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); });</code> </pre><br>    <b>then(null)</b> ,    ‚Äî     foo. <br><br>           .    .  ,      <b>then()</b> ,      ,   .  <b>then()</b>  .   ,    - : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); });</code> </pre><br>     bar,   . <br><br> :   <b>then()</b>   . <br><br><h2>   </h2><br> ,       ,   ,   ,    ,    . <br><br>          . <br><br><h4>  ‚Ññ1 </h4><br><pre> <code class="javascript hljs">doSomething().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingElse(); }) .then(finalHandler);</code> </pre><br>  Answer: <br><br><pre> <code class="hljs ruby">doSomething <span class="hljs-params"><span class="hljs-params">|-----------------|</span></span> doSomethingElse(undefined) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span> finalHandler(resultOfDoSomethingElse) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span></code> </pre><br><h4>  ‚Ññ2 </h4><br><pre> <code class="javascript hljs">doSomething().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ doSomethingElse(); }) .then(finalHandler);</code> </pre><br>  Answer: <br><br><pre> <code class="hljs ruby">doSomething <span class="hljs-params"><span class="hljs-params">|-----------------|</span></span> doSomethingElse(undefined) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span> finalHandler(undefined) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span></code> </pre><br><h4>  ‚Ññ3 </h4><br><pre> <code class="javascript hljs">doSomething().then(doSomethingElse()) .then(finalHandler);</code> </pre><br>  Answer: <br><br><pre> <code class="hljs ruby">doSomething <span class="hljs-params"><span class="hljs-params">|-----------------|</span></span> doSomethingElse(undefined) <span class="hljs-params"><span class="hljs-params">|---------------------------------|</span></span> finalHandler(resultOfDoSomething) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span></code> </pre><br><h4>  ‚Ññ4 </h4><br><pre> <code class="javascript hljs">doSomething().then(doSomethingElse) .then(finalHandler);</code> </pre><br>  Answer: <br><br><pre> <code class="hljs ruby">doSomething <span class="hljs-params"><span class="hljs-params">|-----------------|</span></span> doSomethingElse(resultOfDoSomething) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span> finalHandler(resultOfDoSomethingElse) <span class="hljs-params"><span class="hljs-params">|------------------|</span></span></code> </pre><br>     ,        ,     <b>doSomething()</b>  <b>doSomethingElse()</b> ,      . ,       -  . <br><br>      <a href="https://gist.github.com/nolanlawson/6ce81186421d2fa109a4">  </a> . <br><br><h2>     </h2><br>   .       ,       .    , ,  ,    . <br><br>     ,  - ‚Äî <a href="https://github.com/pouchdb/mapreduce/commit/dfe44b0ab3da9d213640a1010b34bb27327da4c9"> PounchDB  map/reduce     </a> . : 290  , 555 . -,       ‚Ä¶ .           . <br><br>   ,  .  ,    .   ,   ,          . , -   ,      .      ,     ,        .        .    ,  ,    ,    ,      . <br><br><h2>  async/await </h2><br>    ¬´ <a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html">    ES7</a> ¬ª   <b>async/await</b>  ,       .   -  (   <b>catch()</b> ,    <b>try/catch</b> ,   , ES7     <b>try/catch/return</b> . <br><br>     JavaScript,   ,   -   -  ,          . <br><br>      JavaScript,  ,  <a href="http://jslint.com/">JSLint</a>  <a href="http://jshint.com/">JSHint</a>     ,  ¬´ <a href="http://www.amazon.com/dp/0596517742/ref%3Dcm_sw_su_dp">  JavaScript</a> ¬ª,       .   ,         ,      ,         ,     . <br><br>  <b>async/await</b>    ,            JS,   -  -    .          ,  ,     ES5  ES6. <br><br>    ¬´  JavaScript¬ª,     .          ,       : <br><br> ‚Äî     ! </div><p>Source: <a href="https://habr.com/ru/post/269465/">https://habr.com/ru/post/269465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269449/index.html">Setting the correct time on the site and server</a></li>
<li><a href="../269455/index.html">Oracle has updated Java</a></li>
<li><a href="../269459/index.html">Host-Tracker added new agents for monitoring site availability</a></li>
<li><a href="../269461/index.html">Advanced Simplified JSON</a></li>
<li><a href="../269463/index.html">PostgreSQL Evangelist Memo: Criticizing MySQL More Intelligently</a></li>
<li><a href="../269467/index.html">Transfer. Cutting corners: why rails can kill ruby</a></li>
<li><a href="../269469/index.html">Payler is back, or a story about conflicts and their consequences</a></li>
<li><a href="../269471/index.html">Marshmallow. This must be done by everyone. Add SDK 23 support to our applications.</a></li>
<li><a href="../269473/index.html">Using gitlab continuous integration for deployment</a></li>
<li><a href="../269475/index.html">CQRS, UI, based on tasks, Event sources ... ah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>