<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creation of the world Experience of creating intelligent life with their own hands</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes you spend the day trying to explain to the chief accountant without using the terms ‚Äúrecursive call‚Äù and ‚Äúidiots‚Äù why a simple change in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creation of the world Experience of creating intelligent life with their own hands</h1><div class="post__text post__text-html js-mediator-article">  Sometimes you spend the day trying to explain to the chief accountant without using the terms ‚Äúrecursive call‚Äù and ‚Äúidiots‚Äù why a simple change in the accounting system is actually delayed for almost a week due to a spelling mistake made by someone in the 2009 code.  On such days, I want to wrestle the hands of the wise man who created this world and rewrite everything from scratch. <br><br><img src="https://habrastorage.org/files/8fd/c07/73c/8fdc0773c47140ddb1b93904dcbfdcbc.jpeg" alt="image"><br><br>  TL; DR <br>  Under the cut, the story of how I, as a practice to learn Python, develop my library for <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B3%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">agent-based modeling</a> with machine learning and gods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://github.com/pavmav/sandbox-learn">Link</a> to github.  To work out of the box you need <a href="http://www.pygame.org/download.shtml">pygame</a> .  For an introductory example, <a href="http://scikit-learn.org/stable/install.html">sklearn is</a> required. <br><a name="habracut"></a><br><h3>  The origin of the idea </h3><br>  The idea to build a bicycle, which I will talk about, appeared gradually.  First, the popularity of the machine learning topic has not bypassed me.  <a href="https://www.coursera.org/specializations/machine-learning">Several courses</a> on the cursor gave a deceptive sense of belonging.  Several open contests and registration for kaggle slightly corrected self-esteem, however, they did not cool enthusiasm. <br><br>  Secondly, being a representative of the <a href="https://1c.ru/">untouchable</a> caste of the domestic IT community, I rarely have the opportunity to practice my favorite Python.  And from smart people I heard that my project in this regard is just what we need. <br><br>  But the impetus was the disappointment of No Man's Sky.  Technically smart idea, but the procedurally generated world was empty.  And like any disappointed fan, I began to think what I would do if they asked me.  And he came up with the idea that the world was empty because there is actually very little intelligent life in it.  The endless expanses, the habit of relying only on oneself, the joy of the discoverer is all, of course, good.  But there is not enough opportunity to return to the base, look around the market, find out the latest gossip in the diner.  Deliver the parcel and get your 100 gold for it, after all.  It is clear that any city, any dialogue or quest in games is the fruit of the labor of a living person and it is not possible to populate such a huge world with human forces.  But what if we could also procedurally generate NPCs with their needs, small stories and quests? <br><br><h3>  Plan in general </h3><br>  This is how the idea of ‚Äã‚Äãa library appeared, or even, if you will, a framework that would have the following usage scenarios: <br><br><ol><li>  Classical <a href="https://en.wikipedia.org/wiki/Agent-based_model">agent-based modeling</a> (the existence of which I learned only when I sat down to write this article).  We create the world, describe the actions of agents in this world, look what happened, change some parameters, run the simulation again.  And so in a circle, until we find out how changes in the actions of individual agents affect the overall picture.  Very useful stuff. <br><br></li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BA%25D1%2580%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">Training with reinforcement</a> (it is also <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">reinforced learning</a> ).  Building learning models that adapt to interact with a specific environment.  A simple example is learning a game whose rules you do not know, but at any time you can get information about the status of the party, choose one of a specific set of actions and see how it affected the number of points you earned (the <a href="http://blackboxchallenge.com/">competition on this topic</a> , however, has already ended ).  There are many differences from the usual models of classifiers or regressions.  This is a possible delayed outcome, and the need for planning, and many other features. <br><br></li><li>  And finally, after we create the world and populate it with living creatures that are reasonable and not very good, it would be nice to be able to go there personally, grabbing your faithful blaster, favorite sword, multi-functional pickaxe or red nail puller. </li></ol><br><h3>  Few technical details </h3><br>  So, first we need to decide on the low-level physics of our world.  It should be simple, but flexible enough to simulate different situations: <br><br><ol><li>  We take as a basis the usual cellular automaton - a two-dimensional rectangular discrete world, each object of which occupies one Planck length in a square.  Distances shorter than the Planck length will not make sense - you cannot place an object between two cells, you cannot arrange it so that it takes up more than one cell, not even completely. <br><br></li><li>  We will measure the distance in steps in only four directions, that is, the cells next to each other will have 4, not 8. There will be 2 steps in each diagonal direction. <br><br></li><li>  To slightly dilute the solidity of the resulting structure, add a little depth: each object will have a sign of permeability.  For the same spatial coordinates in the world there can be at least one, but not more than two objects: passable and / or impassable.  You can think of it as a surface on which objects stand and on which objects move.  Types of surfaces are different, types of objects, too.  It is possible to put a curbstone (impassable object) on the carpet (passable object).  But you can not lay linoleum on laminate (because who does this at all?) And you can not put a chair on the cabinet. <br><br></li><li>  But in the cabinet can be stored different items.  And in the carpet can, and in the pockets of active objects, too.  That is, any object can be a container for items.  But not for other objects, otherwise we will violate the third law. <br><br></li><li>  Time also goes discretely.  Each step, each object lives one Planck time, during which it can receive information about the world around it as of this epoch from outside.  Now this is the weakest point - the objects have to act in turn, because of this some rassinhron is obtained.  Objects to which the ‚Äúmove‚Äù comes later have to take into account the state of objects that have already ‚Äúwalked‚Äù in this era.  If you allow objects to focus only on the beginning of an epoch, then this can lead to two impassable objects, for example, taking up the same free cell at the beginning of an era.  Or they will take the same sock out of the dresser.  This can be leveled out a little by addressing the objects of each epoch in a random order, but this approach does not solve the whole problem. </li></ol><br>  This gives us a few necessary basic objects: the world itself (Field), the object of this world (Entity) and the object (Substance).  Hereinafter, the code in the article is just an illustration.  You can view it fully <a href="https://github.com/pavmav/sandbox-learn">in the library</a> on github. <br><br><div class="spoiler">  <b class="spoiler_title">Entity classes with examples</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># home universe self.board = None # time-space coordinates self.x = None self.y = None self.z = None # lifecycle properties self.age = 0 self.alive = False self.time_of_death = None # common properties self.passable = False self.scenery = True self._container = [] # visualization properties self.color = None def contains(self, substance_type): for element in self._container: if type(element) == substance_type: return True return False def live(self): self.z += 1 self.age += 1 class Blank(Entity): def __init__(self): super(Blank, self).__init__() self.passable = True self.color = "#004400" def live(self): super(Blank, self).live() if random.random() &lt;= 0.0004: self._container.append(substances.Substance()) if len(self._container) &gt; 0: self.color = "#224444" else: self.color = "#004400" class Block(Entity): def __init__(self): super(Block, self).__init__() self.passable = False self.color = "#000000"</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Field class</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, length, height)</span></span></span><span class="hljs-function">:</span></span> self.__length = length self.__height = height self.__field = [] self.__epoch = <span class="hljs-number"><span class="hljs-number">0</span></span> self.pause = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.__height): row = [] self.__field.append(row) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.__length): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> y == (height - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> x == (length - <span class="hljs-number"><span class="hljs-number">1</span></span>): init_object = Block() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: init_object = Blank() init_object.x = x init_object.y = y init_object.z = <span class="hljs-number"><span class="hljs-number">0</span></span> row.append([init_object])</code> </pre><br></div></div><br>  The Substance class does not make sense to describe, it has nothing. <br><br>  For the time we will meet the world itself.  Each era, he will poll all objects in it and force them to make a move.  How they will make this move is their business: <br><br><div class="spoiler">  <b class="spoiler_title">Time forward!</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.pause: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.height): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.length): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__field[y][x]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> element.z == self.epoch: element.live() self.__epoch += <span class="hljs-number"><span class="hljs-number">1</span></span> ...</code> </pre><br></div></div><br>  But why do we need peace, and even with the planned opportunity to place a protagonist in it, if we cannot see it?  On the other hand, if you start to deal with graphics, you can get distracted and the world rule will be postponed indefinitely.  Therefore, without wasting time, we master <a href="https://habrahabr.ru/post/193888/">this wonderful article</a> about writing a platformer using <a href="http://pygame.org/hifi.html">pygame</a> (in fact, we only need the first third of the article), give each object a color sign, and now we already have some sort of map. <br><br><div class="spoiler">  <b class="spoiler_title">Visualization code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list_obj_representation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> representation = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.height): row_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cell <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__field[y]: row_list.append(cell[<span class="hljs-number"><span class="hljs-number">-1</span></span>]) representation.append(row_list) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> representation .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visualize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(field)</span></span></span><span class="hljs-function">:</span></span> pygame.init() screen = pygame.display.set_mode(DISPLAY) pygame.display.set_caption(<span class="hljs-string"><span class="hljs-string">"Field game"</span></span>) bg = Surface((WIN_WIDTH, WIN_HEIGHT)) bg.fill(Color(BACKGROUND_COLOR)) myfont = pygame.font.SysFont(<span class="hljs-string"><span class="hljs-string">"monospace"</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) f = field tick = <span class="hljs-number"><span class="hljs-number">10</span></span> timer = pygame.time.Clock() go_on = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> go_on: timer.tick(tick) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pygame.event.get(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.type == QUIT: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> SystemExit, <span class="hljs-string"><span class="hljs-string">"QUIT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.type == pygame.KEYDOWN: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.key == pygame.K_SPACE: f.pause = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> f.pause <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> e.key == pygame.K_UP: tick += <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> e.key == pygame.K_DOWN <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tick &gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>: tick -= <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> e.key == pygame.K_ESCAPE: go_on = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> screen.blit(bg, (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) f.integrity_check() f.make_time() level = f.list_obj_representation() label = myfont.render(<span class="hljs-string"><span class="hljs-string">"Epoch: {0}"</span></span>.format(f.epoch), <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) screen.blit(label, (<span class="hljs-number"><span class="hljs-number">630</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) stats = f.get_stats() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(stats): label = myfont.render(<span class="hljs-string"><span class="hljs-string">"{0}: {1}"</span></span>.format(element, stats[element]), <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) screen.blit(label, (<span class="hljs-number"><span class="hljs-number">630</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span> + (i * <span class="hljs-number"><span class="hljs-number">15</span></span>))) x = y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> level: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row: pf = Surface((PLATFORM_WIDTH, PLATFORM_HEIGHT)) pf.fill(Color(element.color)) screen.blit(pf, (x, y)) x += PLATFORM_WIDTH y += PLATFORM_HEIGHT x = <span class="hljs-number"><span class="hljs-number">0</span></span> pygame.display.update()</code> </pre><br></div></div><br>  Of course, later it will be possible to write a somewhat more intelligible visualization module, but not one.  But while the colorful running squares are enough to immerse themselves in the atmosphere of the emerging life.  In addition, it develops a fantasy. <br><br><img src="https://habrastorage.org/files/ab5/586/64a/ab558664ac0449d0a4792334528b58b4.gif" alt="image"><br><br>  Now you need to think about how active agents will act.  First, all significant actions will be objects (Python objects, not objects of the world, I apologize for ambiguity).  So you can keep history, manipulate their state, distinguish one action from another, even if they are of the same type.  So, the actions will look like this: <br><br><ol><li>  Every action must have a subject.  The subject of action can only be the object of our world (Entity). <br><br></li><li>  Every action must have results.  At a minimum, ‚Äúcompleted / not completed‚Äù and ‚Äúgoal achieved / goal not achieved‚Äù.  But there may be additional ones, depending on the type of action: for example, the action ‚ÄúSearch for the Next Pizzeria‚Äù may have, in addition to the required ones, the coordinates or the pizzeria object as results. <br><br></li><li>  Each action may or may not have a set of parameters.  For example, the action ‚ÄúPouring a CupCoffee‚Äù may not have parameters, since it does not require clarification, while for the action ‚ÄúPour‚Äù you need the opportunity to clarify what to pour and where. <br><br></li><li>  Action may be instantaneous or non-instantaneous.  During one epoch, one object can perform no more than one non-instantaneous action and any number of instantaneous.  This is a controversial point - if we have discretely space and we cannot move half a cell, then the ability to perform an unlimited number of actions during one epoch looks strange and blurs a clear discrete course of time.  There was also an idea to ask each type of action the time that it is necessary to spend on it, ranging from 0 to 1, where the action of a duration of 1 takes the entire era.  While I stopped at the version with the sign of instantaneousness, since for the definition of discrete time, all actions necessary for the simulation can always be made not instantaneous, but the option with the duration makes it all too complicated. </li></ol><br>  Thus, from a technical point of view, an action object (Action) is some kind of function, which can be set parameters, execute, get a result, and which itself in itself stores both the parameters passed to it, and the result, and everything that associated with its implementation, starting with the one who caused it, and ending with the state of the world around during its implementation.  Therefore, we can create it at one time, set the parameters in another, execute the parameters in the third, get the return value and put it on the shelf for further analysis. <br><br><div class="spoiler">  <b class="spoiler_title">Action object</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subject)</span></span></span><span class="hljs-function">:</span></span> self.subject = subject self.accomplished = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self._done = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self.instant = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_objective</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_objective</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, control=False, **kwargs)</span></span></span><span class="hljs-function">:</span></span> valid_objectives = self.get_objective().keys() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kwargs.keys(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> valid_objectives: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> control: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"{0} is not a valid objective"</span></span>.format(key)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-comment"><span class="hljs-comment"># maybe need to print else: setattr(self, "_{0}".format(key), kwargs[key]) def action_possible(self): return True def do(self): self.check_set_results() self._done = True def check_set_results(self): self.accomplished = True @property def results(self): out = {"done": self._done, "accomplished": self.accomplished} return out def do_results(self): self.do() return self.results</span></span></code> </pre><br></div></div><br>  If someone besides me suddenly wants to create a cozy little world for himself with the help of this library, then it is assumed that out of the box it will contain a set of necessary low-level actions - go to the coordinates, follow the object, find a specific object or object, pick up an object, etc. d.  These actions can be used both on their own and combined to produce some complicated manipulations.  An example of such complex actions will be further, in the description of the first experiment. <br><br>  Secondly, every self-respecting active agent should be able to plan their actions.  Therefore, we divide the phase of its activity during the epoch into 2 stages: planning and action.  As a planning tool, we will have a simple lineup of actions that we are going to consistently perform.  However, if we already have a plan, then there is nothing to ponder once more, we must act quickly, decisively.  It turns out that at the beginning of the move, the active object determines whether it is necessary to plan for this move (for a start, we will assume that it is necessary when the action queue is empty), then plans if it decided that this is necessary, and at the end performs actions.  Should planning, as a serious process, which does not tolerate haste, take up the whole course - a debatable question.  For my own purposes, I have stopped at the fact that there is no - my agents do not think for a long time and start to fulfill the plan on the same turn. <br><br><div class="spoiler">  <b class="spoiler_title">Planning and action</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Agent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Entity)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">live</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.need_to_update_plan(): self.plan() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(self.action_queue) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: current_action = self.action_queue[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.perform_action(current_action) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(self.action_queue) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.action_queue[<span class="hljs-number"><span class="hljs-number">0</span></span>].instant: current_action = self.action_queue[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.perform_action(current_action) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">need_to_update_plan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.action_queue) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action)</span></span></span><span class="hljs-function">:</span></span> results = action.do_results() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> results[<span class="hljs-string"><span class="hljs-string">"done"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> action.action_possible(): self.action_log.append(self.action_queue.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results ... ...</code> </pre><br></div></div><br>  In addition to this, it seemed to me convenient to introduce such an entity as a state of an object that could influence its actions.  After all, the agent can be tired, not in the mood, get wet, get poisoned or vice versa, be cheerful and full of energy.  Sometimes even at the same time.  Therefore, we add to our objects an array of states, each of which will affect the object at the beginning of an epoch. <br><br><div class="spoiler">  <b class="spoiler_title">Status code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subject)</span></span></span><span class="hljs-function">:</span></span> self.subject = subject self.duration = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">affect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.duration += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... self._states_list = [] ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_affected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._states_list: state.affect() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">live</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.get_affected() self.z += <span class="hljs-number"><span class="hljs-number">1</span></span> self.age += <span class="hljs-number"><span class="hljs-number">1</span></span> ...</code> </pre><br></div></div><br>  For modeling and training, it is necessary to be able to assess how well we have written an action algorithm or chose a training model.  To do this, we add a simple simulation and evaluation module with the ability to describe a method for determining the end of the simulation and collecting the results. <br><br><div class="spoiler">  <b class="spoiler_title">Like that</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(initial_field, check_stop_function, score_function, times=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, verbose=False)</span></span></span><span class="hljs-function">:</span></span> list_results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> iteration <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(times): field = copy.deepcopy(initial_field) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> check_stop_function(field): field.make_time() current_score = score_function(field) list_results.append(current_score) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> verbose: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Iteration: {0} Score: {1})"</span></span>.format(iteration+<span class="hljs-number"><span class="hljs-number">1</span></span>, current_score) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list_results</code> </pre><br></div></div><br>  At this stage, everything, in principle, is ready to close the first scenario of using our library: modeling, if we don‚Äôt want to train agents, but want to prescribe the logic of their actions independently.  The procedure in this case is as follows: <br><br><ol><li>  We decide which static objects we want to see in the world: walls, mountains, furniture, types of surfaces, etc.  We describe them by inheriting the Entity class.  We do the same with objects and the Substance class. </li><li>  Create a world of the right size, fill it with a landscape of these objects and objects. </li><li>  We inherit the class Action and describe all the actions we need.  We do the same with the State class and states if we need them for our simulation. </li><li>  We create a class of our agents, inheriting Agent.  We add service functions to it, we describe the planning process. </li><li>  We inhabit our world with active agents. </li><li>  To debug actions and enjoy the contemplation of your creation, you can drive visualization. </li><li>  And in the end, having played enough with visualization, we start the simulation and evaluate how well the agents we created play according to the rules we create in the world we created. </li></ol><br><h3>  Proof of concept i </h3><br>  So, we announce the conditions of the first experiment. <br><br><ul><li>  The world consists of: walls, earth.  Walls - just impassable walls, nothing else.  With the land it is more interesting - every era there is a non-zero probability that a unit of resource will appear in any or several cells of the earth. </li><li>  Population: creatures of two sexes.  Since, for simplicity, we will store the floor in a logical variable, the floor may be false or true. </li><li>  Creatures of the false sex are greedy and have the purpose of their life to collect as much resource as possible.  As soon as they appear, they find the nearest cell with the resource, go to it, collect the resource and so on in a circle.  However, it is they who are endowed with the ability to bear children. </li><li>  Creatures of the true sex are somewhat more diverse.  They have a choice of two actions: also collect a resource or look for a partner for mating (naturally, of the opposite sex, so as not to accidentally land in places where there are few resources, and it‚Äôs better not to even think about possible partners for mating). </li><li>  When the creature of the true sex that decides to mate catches up with the chosen partner and invites him to retire, the creature of the false sex decides whether it is located for mating, according to certain rules based on the amount of the resource from both participants.  If the provider has more resources, he gets consent.  If less or the same, then the probability of pairing depends on the difference in the amount of resources. </li><li>  Ten epochs after conception, a creature of random sex is born.  It is born immediately, an adult, and acts in accordance with the rules for its gender. </li><li>  All creatures must die.  Every being, every epoch, beginning with the tenth after its birth, has a non-zero and constant probability of ceasing its active existence. </li></ul><br>  Our task will be to write a planning procedure for creatures of the true sex in such a way that the population of creatures reproduces as quickly as possible. <br><br>  Out of gratitude, I will not tire out reading to this place with long illustrations, I will show only: <br><div class="spoiler">  <b class="spoiler_title">A variant of the implementation of integrated action on the example of mating</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoMating</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Action)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subject)</span></span></span><span class="hljs-function">:</span></span> super(GoMating, self).__init__(subject) self.search_action = SearchMatingPartner(subject) self.move_action = MovementToEntity(subject) self.mate_action = Mate(subject) self.current_action = self.search_action <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action_possible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.current_action: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.current_action.action_possible() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.subject.has_state(states.NotTheRightMood): self._done = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.results[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.action_possible(): self._done = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (self.current_action <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.current_action.instant) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.results[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: first = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> current_results = self.current_action.do_results() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_results[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_results[<span class="hljs-string"><span class="hljs-string">"accomplished"</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(self.current_action, SearchMatingPartner): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_results[<span class="hljs-string"><span class="hljs-string">"accomplished"</span></span>]: self.current_action = self.move_action self.current_action.set_objective(**{<span class="hljs-string"><span class="hljs-string">"target_entity"</span></span>: current_results[<span class="hljs-string"><span class="hljs-string">"partner"</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(self.current_action, MovementXY): self.current_action = self.mate_action self.current_action.set_objective(**{<span class="hljs-string"><span class="hljs-string">"target_entity"</span></span>: self.search_action.results[<span class="hljs-string"><span class="hljs-string">"partner"</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(self.current_action, Mate): self.current_action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.accomplished = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._done = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.current_action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self._done = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_set_results</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.accomplished = self._done</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">And the planning option that I decided that the model works</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creature</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Agent)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> nearest_partner = actions.SearchMatingPartner(self).do_results()[<span class="hljs-string"><span class="hljs-string">"partner"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nearest_partner <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: chosen_action = actions.HarvestSubstance(self) chosen_action.set_objective(** {<span class="hljs-string"><span class="hljs-string">"target_substance_type"</span></span>: type(substances.Substance())}) self.queue_action(chosen_action) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self_has_substance = self.count_substance_of_type(substances.Substance) partner_has_substance = nearest_partner.count_substance_of_type(substances.Substance) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> partner_has_substance - self_has_substance &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.queue_action(actions.GoMating(self)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: chosen_action = actions.HarvestSubstance(self) chosen_action.set_objective(**{<span class="hljs-string"><span class="hljs-string">"target_substance_type"</span></span>: type(substances.Substance())}) self.queue_action(chosen_action) ...</code> </pre><br></div></div><br><h3>  About machine learning and gods </h3><br>  Making sure that the simple modeling works, we will begin to increase the degree of fun and add the possibility of machine learning.  At the time of this writing, not all of the planned capabilities are implemented, however, I promised to tell you about the gods. <br><br>  But first we need to decide how we want to train our creatures.  Take the same task with resource searches and pairing.  If we solved it in the traditional way, then first we would have to decide on a set of signs, based on which we plan to make decisions.  Then, acting randomly or somehow, collect the training and test datasets and save them.  You should train a couple of models on these datasets, compare them and choose the best one.  Finally, rewrite the planning process using this model, run the simulation and see what happens.  And here we would have thought of using a new feature, which means reassembling the data, overtraining the models, re-aligning them with each other and restarting, in order to reexamine what will happen again. <br><br>  And what would we like ideally?  Ideally, I would like to define a set of features, configure the training model and run a simulation that would already assemble the datasets, train the model, connect it to the planning process and give us ready results of several runs that we could compare with the results of other models or other sets signs. <br><br>  And that's how I imagine it: <br><br><ul><li>  In order to gain datasets and make decisions, we need to declaratively describe the receipt of features on which we will train and which we will use to predict the model in the planning process.  Now I implemented it as an array of functions, each of which returns the value of a particular attribute.  For our test task, this is, for example, a function that returns the presence of possible partners, another one that considers the amount of a resource in a decision maker, a distance to the nearest resource, etc.  Perhaps it would have been more successful to have a function that returns an array of attributes, but at the time of writing, the array of functions seemed more convenient to me.  Thus, we get the opportunity at any time to get a description of the world around us. <br><br></li><li>  We also declaratively describe the method of obtaining the result of interest to us.  In the case of our example, this is, say, mating successfully or unsuccessfully. <br><br></li><li>  Specify the training model that we want to use, and its parameters.  For example, a stochastic gradient descent, a random forest, some kind of neural network, or anything at all. <br><br></li><li>  Run the simulation.  First, every time when it is necessary to make a decision, the creatures, according to the rules described by us, receive an array of signs and choose some kind of action without using the model (which is still empty).  Having performed this action, they again, according to the rules described by us, determine the result, connect it with a description of the environment in which the decision was made (set of signs obtained before the action), and voila, we have a sample ready for the training dataset.  Having done this a certain number of times and having accumulated enough data, the creatures finally feed the training dataset into the model.  After the model is trained, they begin using it in the planning process. <br><br></li><li>  Further options are possible.  You can stop at this.  And you can continue to memorize the sets of signs and the results of actions and feed them with pieces of the model, if the model allows you to complete your education.  Or, for example, overtraining it if the percentage of desired results starts to decrease. </li></ul><br>  Here we need a few new objects.  First, creatures should have some kind of memory in which they will add their datasets.  She should be able to separately memorize a set of signs.  Separately attach to them the result of the decision made with this set of features.  Return to us in a convenient way.  Well, and forget all that we were taught in high school. <br><br><div class="spoiler">  <b class="spoiler_title">Secrets of memory</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LearningMemory</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.memories = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, state, action)</span></span></span><span class="hljs-function">:</span></span> self.memories[action] = {<span class="hljs-string"><span class="hljs-string">"state"</span></span>: state} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_results</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, results, action)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memories: self.memories[action][<span class="hljs-string"><span class="hljs-string">"results"</span></span>] = results <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action_type)</span></span></span><span class="hljs-function">:</span></span> table_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> memory <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memories: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(memory, action_type): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"state"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memories[memory] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"results"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memories[memory]: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> row = self.memories[memory][<span class="hljs-string"><span class="hljs-string">"state"</span></span>][:] row.append(self.memories[memory][<span class="hljs-string"><span class="hljs-string">"results"</span></span>]) table_list.append(row) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> table_list <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obliviate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.memories = {}</code> </pre><br></div></div><br>  Secondly, we need to teach agents to get jobs and to remember the environment and the results of their actions. <br><br><div class="spoiler">  <b class="spoiler_title">Getting jobs</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Agent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Entity)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... self.memorize_tasks = {} .... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_memorize_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action_types, features_list, target)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(action_types, list): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> action_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> action_types: self.memorize_tasks[action_type] = {<span class="hljs-string"><span class="hljs-string">"features"</span></span>: features_list, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: target} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.memorize_tasks[action_types] = {<span class="hljs-string"><span class="hljs-string">"features"</span></span>: features_list, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: target} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_features</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action_type <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memorize_tasks: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> features_list_raw = self.memorize_tasks[action_type][<span class="hljs-string"><span class="hljs-string">"features"</span></span>] features_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> feature_raw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> features_list_raw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(feature_raw, dict): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"kwargs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> feature_raw: features_list.append(feature_raw[<span class="hljs-string"><span class="hljs-string">"func"</span></span>](**feature_raw[<span class="hljs-string"><span class="hljs-string">"kwargs"</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: features_list.append(feature_raw[<span class="hljs-string"><span class="hljs-string">"func"</span></span>]()) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> callable(feature_raw): features_list.append(feature_raw()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: features_list.append(feature_raw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> features_list <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action_type <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memorize_tasks: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> target_raw = self.memorize_tasks[action_type][<span class="hljs-string"><span class="hljs-string">"target"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callable(target_raw): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_raw() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(target_raw, dict): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"kwargs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target_raw: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_raw[<span class="hljs-string"><span class="hljs-string">"func"</span></span>](**target_raw[<span class="hljs-string"><span class="hljs-string">"kwargs"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_raw[<span class="hljs-string"><span class="hljs-string">"func"</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_raw <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(action) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memorize_tasks: self.private_learning_memory.save_state(self.get_features(type(action)), action) self.public_memory.save_state(self.get_features(type(action)), action) self.action_queue.append(action) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_action_save_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, action)</span></span></span><span class="hljs-function">:</span></span> self.chosen_action = action <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(action) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.memorize_tasks: results = self.perform_action(action) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> results[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: self.private_learning_memory.save_results(self.get_target(type(action)), action) self.public_memory.save_results(self.get_target(type(action)), action) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: results = self.perform_action(action) ...</code> </pre><br></div></div><br> , ,    , -    ,   ,   , ,   ,   ,   .  ,      ,     -      -,              ,      ,     . <br><br>     Demiurge,      .  ,  ,       insert_object.       ,     : <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demiurge</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_creation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, creation, refuse)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, length, height)</span></span></span><span class="hljs-function">:</span></span> ... self.demiurge = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y, entity_object, epoch_shift=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.demiurge <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: refuse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self.demiurge.handle_creation(entity_object, refuse) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> refuse: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x &lt; self.length <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> y &lt; self.height self.__field[y][x][<span class="hljs-number"><span class="hljs-number">-1</span></span>] = entity_object entity_object.z = self.epoch + epoch_shift entity_object.board = self entity_object.x = x entity_object.y = y ...</code> </pre><br></div></div><br>     : <br><br><ul><li>        (  ) .            ,        . <br><br></li><li>          ‚Äî  , , ,   . ,   ,      ,   <s> </s>       . <br><br></li><li>    ( )   ,      (   ,   ,    ).   , ,          . </li></ul><br>               .   ‚Äî -    .                 .    ‚Äî    ,        ,     . ,       ‚Äî        .    ‚Äî ,     ,      . <br><br><h3> Proof of concept II </h3><br> ,             .     ,             ,         .        ,            . <br><br>       : <br><br><ul><li>       (Priapus). </li><li>       ,     .  , , <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html">SGDClassifier   sklearn</a> . </li><li>  handle_creation. </li><li>    ,       :    ,          .  ,    ,        ,    . </li><li>   :     ,       (,   ,   sklearn ,    ?).      (   20   ,      ),  ,       .  ,         .  ,   . </li><li>  30   500        500  .          ,     ,    . </li><li>      . </li></ul><br><div class="spoiler">  <b class="spoiler_title">What happened</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Create deity class Priapus(field.Demiurge): # Create deity def __init__(self): self.public_memory = brain.LearningMemory(self) self.public_decision_model = SGDClassifier(warm_start=True) def handle_creation(self, creation, refuse): if isinstance(creation, entities.Creature): creation.public_memory = self.public_memory creation.public_decision_model = self.public_decision_model creation.memory_type = "public" creation.model_type = "public" creation.memory_batch_size = 20 if creation.sex: def difference_in_num_substance(entity): nearest_partner = actions.SearchMatingPartner(entity).do_results()["partner"] if nearest_partner is None: return 9e10 else: self_has_substance = entity.count_substance_of_type(substances.Substance) partner_has_substance = nearest_partner.count_substance_of_type(substances.Substance) return partner_has_substance - self_has_substance def possible_partners_exist(entity): find_partner = actions.SearchMatingPartner(entity) search_results = find_partner.do_results() return float(search_results["accomplished"]) features = [{"func": lambda creation: float(creation.has_state(states.NotTheRightMood)), "kwargs": {"creation": creation}}, {"func": difference_in_num_substance, "kwargs": {"entity": creation}}, {"func": possible_partners_exist, "kwargs": {"entity": creation}}] creation.set_memorize_task(actions.GoMating, features, {"func": lambda creation: creation.chosen_action.results["accomplished"], "kwargs": {"creation": creation}}) def plan(creature): if creature.sex: try: # raise NotFittedError current_features = creature.get_features(actions.GoMating) current_features = np.asarray(current_features).reshape(1, -1) if creature.public_decision_model.predict(current_features): go_mating = actions.GoMating(creature) creature.queue_action(go_mating) return else: harvest_substance = actions.HarvestSubstance(creature) harvest_substance.set_objective( **{"target_substance_type": type(substances.Substance())}) creature.queue_action(harvest_substance) return except NotFittedError: chosen_action = random.choice( [actions.GoMating(creature), actions.HarvestSubstance(creature)]) if isinstance(chosen_action, actions.HarvestSubstance): chosen_action.set_objective( **{"target_substance_type": type(substances.Substance())}) creature.queue_action(chosen_action) return else: harvest_substance = actions.HarvestSubstance(creature) harvest_substance.set_objective(**{"target_substance_type": type(substances.Substance())}) creature.queue_action(harvest_substance) creation.plan_callable = plan universe = field.Field(60, 40) # Create sample universe (length, height universe.set_demiurge(Priapus()) # Assign deity to universe # Fill universe with blanks, blocks, other scenery if necessary for y in range(10, 30): universe.insert_object(20, y, field.Block()) for x in range(21, 40): universe.insert_object(x, 10, field.Block()) for y in range(10, 30): universe.insert_object(40, y, field.Block()) universe.populate(entities.Creature, 20) # Populate universe with creatures def check_stop_function(field): return field.epoch &gt;= 500 def score_function(field): stats = field.get_stats() if "Creature" not in stats: return 0 else: return stats["Creature"] res = modelling.run_simulation(universe, check_stop_function, score_function, verbose=True, times=30) print res print np.asarray(res).mean()</span></span></code> </pre><br></div></div><br><h3>  Conclusion </h3><br>        , ,    -    .     (    )   .       : <br><br><ul><li>     .           . </li><li>       (/ ,    , /    ..).     ‚Äî ,    - -. </li><li>    . </li><li>  . </li><li>          ,  ,    . </li><li>   </li><li>  Optimization </li><li>  ... </li><li> PROFIT </li></ul><br> , ,     ,      -,           ,     -,     .    ,   ,  -        ,       -,       ,       .          ,         ,      .   ,   . <br><br>   <a href="https://github.com/pavmav/sandbox-learn"></a>  github.    <a href="http://www.pygame.org/download.shtml">pygame</a>  <a href="http://scikit-learn.org/stable/install.html">sklearn</a> ,      . </div><p>Source: <a href="https://habr.com/ru/post/315424/">https://habr.com/ru/post/315424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315414/index.html">Pro web client 1C</a></li>
<li><a href="../315416/index.html">Personal experience of receiving the Blue Card in Germany 2015-2016. Part 3: Arriving in Germany</a></li>
<li><a href="../315418/index.html">Polish clouds. Price notes (not only for Ukrainians)</a></li>
<li><a href="../315420/index.html">How to create elusive goals in the game 2016 Hitman</a></li>
<li><a href="../315422/index.html">We control the quality of the code using the SonarQube platform</a></li>
<li><a href="../315428/index.html">The first private city in Russia, to be or not to be? Part 1</a></li>
<li><a href="../315430/index.html">We write the protocols of counters Mercury 230 and Mercury 200 for OpenSCADA</a></li>
<li><a href="../315432/index.html">Veeam Availability Suite 9.5 released - what's new?</a></li>
<li><a href="../315434/index.html">Connect (); // 2016: Text Translation</a></li>
<li><a href="../315436/index.html">The history of communication towers 2: forms and types</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>