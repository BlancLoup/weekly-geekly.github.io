<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study With using GDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Allan O'Donnell Learning C with GDB . 

 Based on the characteristics of such high-level languages ‚Äã‚Äãlike Ruby, Scheme o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study With using GDB</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the article by Allan O'Donnell <a href="https://www.hackerschool.com/blog/5-learning-c-with-gdb">Learning C with GDB</a> .</i> <br><br>  Based on the characteristics of such high-level languages ‚Äã‚Äãlike Ruby, Scheme or Haskell, learning C can be a daunting task.  In addition to overcoming such low-level features of C, like manual memory management and pointers, you still need to do without a <a href="http://ru.wikipedia.org/wiki/REPL">REPL</a> .  Once you get used to <a href="https://en.wikipedia.org/wiki/Exploratory_programming">research programming</a> in the REPL, dealing with a cycle of write-compiled-launched will be a little disappointment for you. <br><br>  Recently it occurred to me that I could use GDB as a pseudo-REPL for C. I experimented using GDB as a tool for learning the language, not just for debugging, and it turned out that it was a lot of fun. <br><a name="habracut"></a><br>  The purpose of this post is to show you that GDB is a great tool for learning C. I will introduce you to a few of my favorite teams from GDB, and demonstrate how you can use GDB to understand one of the difficult parts of C: the difference between arrays and pointers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Introduction to GDB </h4><br>  Let's start by creating the following small C program - <i>minimal.c</i> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1337</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Note that the program does absolutely nothing, and does not even have a single <i>printf</i> command.  Now dive into the new world of learning using GBD. <br><br>  Let's compile this program with the <i>-g</i> flag to generate debug information that GDB will work with, and give it the same information: <br><br><pre> <code class="bash hljs">$ gcc -g minimal.c -o minimal $ gdb minimal</code> </pre><br>  You should now be on the GDB command line with lightning speed.  I promised you a REPL, so get: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> 1 + 2 <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 3</code> </pre><br>  Amazing  <i>print</i> is a built-in GDB command that computes the result of the Cth expression.  If you do not know what exactly a GDB command does, just use the help ‚Äî type <i>help name-of-the-command</i> on the GDB command line. <br><br>  Here is a more interesting example: <br><br><pre> <code class="bash hljs">(gbd) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (int) 2147483648 <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = -2147483648</code> </pre><br>  I will miss clarifying why <i>2147483648 == -2147483648</i> .  The main point here is that even arithmetic can be insidious in C, and GDB perfectly understands C arithmetic. <br><br>  Now let's set a breakpoint in the <i>main</i> function and run the program: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> main (gdb) run</code> </pre><br>  The program stopped at the third line, just where the variable <i>i is</i> initialized.  Interestingly, although the variable has not yet been initialized, we can already now see its value using the <i>print</i> command: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> i <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 32767</code> </pre><br>  In C, the value of a local uninitialized variable is undefined, so the result you received may differ. <br><br>  We can execute the current line of code using the <i>next</i> command: <br><br><pre> <code class="bash hljs">(gdb) next (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> i <span class="hljs-variable"><span class="hljs-variable">$4</span></span> = 1337</code> </pre><br><h4>  Investigate memory using command <i>X</i> </h4><br>  Variables in C are contiguous blocks of memory.  In this case, the block of each variable is characterized by two numbers: <br><br>  1. The numeric address of the first byte in the block. <br>  2. Block size in bytes.  This size is determined by the type of the variable. <br><br>  One of the distinguishing features of the C language is that you have direct access to the variable memory block.  The <i>&amp;</i> operator gives us the address of a variable in memory, and <i>sizeof</i> calculates the size occupied by a variable in memory. <br><br>  You can play with both possibilities in GDB: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> &amp;i <span class="hljs-variable"><span class="hljs-variable">$5</span></span> = (int *) 0x7fff5fbff584 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> sizeof(i) <span class="hljs-variable"><span class="hljs-variable">$6</span></span> = 4</code> </pre><br>  Speaking in a normal language, this means that the variable <i>i</i> is located at <i>0x7fff5fbff5b4</i> and occupies 4 bytes in memory. <br><br>  I already mentioned above that the size of a variable in memory depends on its type, and generally speaking, the <i>sizeof</i> operator can also operate with the data types themselves: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> sizeof(int) <span class="hljs-variable"><span class="hljs-variable">$7</span></span> = 4 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> sizeof(double) <span class="hljs-variable"><span class="hljs-variable">$8</span></span> = 8</code> </pre><br>  This means that at least on my machine, variables of type <i>int</i> occupy four bytes, and of type <i>double</i> - eight bytes. <br><br>  GDB has a powerful tool for direct memory exploration ‚Äî the <i>x</i> command.  This command checks memory starting at a specific address.  It also has a number of formatting commands, which provide precise control over the number of bytes that you want to check, and in what form you want to display them.  In case of difficulty, type <i>help x</i> on the GDB command line. <br><br>  As you already know, the <i>&amp;</i> operator calculates the address of a variable, which means that you can pass the value of <i>&amp; i</i> to the <i>x</i> command and thereby get the opportunity to look at the individual bytes hidden behind the <i>i</i> variable: <br><br><pre> <code class="bash hljs">(gdb) x/4xb &amp;i 0x7fff5fbff584: 0x39 0x05 0x00 0x00</code> </pre><br>  The formatting flags indicate that I want to get four ( <u>4</u> ) values, displayed in hexadecimal (he <u>x</u> ), one byte each ( <u>b</u> yte).  I specified a test of only four bytes, because the variable <i>i</i> occupies so much in memory.  The output shows a by-byte representation of the variable in memory. <br><br>  But one subtlety is connected with the byte-by-output, which must be constantly kept in my head - on Intel machines, the bytes are stored in the order ‚Äú <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">from the youngest to the oldest</a> ‚Äù (from right to left), unlike the more usual record for a person, where the low byte would have to be in end (left to right). <br><br>  One way to clarify this question is to assign a more interesting value to the variable <i>i</i> and check this memory area again: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> var i = 0x12345678 (gdb) x/4xb &amp;i 0x7fff5fbff584: 0x78 0x56 0x34 0x12</code> </pre><br><h4>  Examine memory with the <i>ptype</i> command </h4><br>  The <i>ptype</i> command is probably one of my favorites.  It shows the type of C-th expression: <br><br><pre> <code class="bash hljs">(gdb) ptype i <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = int (gdb) ptype &amp;i <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = int * (gdb) ptype main <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = int (void)</code> </pre><br>  Types in C can become <a href="http://c-faq.com/decl/spiral.anderson.html">complicated</a> , but <i>ptype</i> allows you to explore them interactively. <br><br><h4>  Pointers and arrays </h4><br>  Arrays are a surprisingly subtle concept in C. The point of this clause is to write a simple program and then run it through GDB until the arrays have any meaning. <br><br>  So, we need a program code with array <i>array.c</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Compile it with the <i>-g</i> flag, run it in GDB, and use <i>next to</i> go to the initialization string: <br><br><pre> <code class="bash hljs">$ gcc -g arrays.c -o arrays $ gdb arrays (gdb) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> main (gdb) run (gdb) next</code> </pre><br>  At this stage, you can display the contents of the variable and find out its type: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = {1, 2, 3} (gdb) ptype a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = int [3]</code> </pre><br>  Now that our program is properly configured in GDB, the first thing to do is to use the <i>x</i> command to see what the variable <i>a</i> ‚Äúunder the hood‚Äù looks like: <br><br><pre> <code class="bash hljs">(gdb) x/12xb &amp;a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 0x02 0x00 0x00 0x00 0x7fff5fbff574: 0x03 0x00 0x00 0x00</code> </pre><br>  This means that the memory location for array <i>a</i> begins at <i>0x7fff5fbff56c</i> .  The first four bytes contain <i>a [0]</i> , the next four bytes <i>a [1]</i> , and the last four bytes contain <i>a [2]</i> .  Indeed, you can check and make sure that <i>sizeof</i> knows that <i>a</i> is in memory of exactly twelve bytes: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> sizeof(a) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 12</code> </pre><br>  Up to this point, arrays look what they should be.  They have types corresponding to arrays and they store all values ‚Äã‚Äãin adjacent memory locations.  However, in certain situations, arrays behave very similarly to pointers!  For example, we can apply arithmetic operations to <i>a</i> : <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a + 1 <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = (int *) 0x7fff5fbff570</code> </pre><br>  In normal words, this means that <i>a + 1</i> is a pointer to an <i>int</i> that has the address <i>0x7fff5fbff570</i> .  At this point, you should already reflexively transfer pointers to the <i>x</i> command, so let's see what happened: <br><br><pre> <code class="bash hljs">(gdb) x/4xb a + 1 0x7fff5fbff570: 0x02 0x00 0x00 0x00</code> </pre><br><br>  Note that the address <i>0x7fff5fbff570 is</i> exactly four more than <i>0x7fff5fbff56c</i> , that is, the address of the first byte of the array <i>a</i> .  Given that the type <i>int</i> occupies four bytes in memory, we can conclude that <i>a + 1</i> indicates <i>a [1]</i> . <br><br>  In fact, indexing arrays in C is syntactic sugar for pointer arithmetic: <i>a [i] is</i> equivalent to <i>* (a + i)</i> .  You can check this in gdb: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a[0] <span class="hljs-variable"><span class="hljs-variable">$4</span></span> = 1 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> *(a + 0) <span class="hljs-variable"><span class="hljs-variable">$5</span></span> = 1 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a[1] <span class="hljs-variable"><span class="hljs-variable">$6</span></span> = 2 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> *(a + 1) <span class="hljs-variable"><span class="hljs-variable">$7</span></span> = 2 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a[2] <span class="hljs-variable"><span class="hljs-variable">$8</span></span> = 3 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> *(a + 2) <span class="hljs-variable"><span class="hljs-variable">$9</span></span> = 3</code> </pre><br>  So, we saw that in some situations, <i>a</i> behaves like an array, and in some - like a pointer to its first element.  What is going on? <br><br>  The answer is as follows: when the name of an array is used in an expression in C, it ‚Äúsplits (decay)‚Äù into a pointer to the first element.  There are only two exceptions to this rule: when the array name is passed in <i>sizeof</i> and when the array name is used with the address taking operator <i>&amp;</i> . <br><br>  The fact that the name <i>a</i> does not fall into a pointer to the first element when using the <i>&amp;</i> operator raises an interesting question: what is the difference between a pointer into which <i>a</i> and <i>&amp; a</i> breaks up? <br><br>  Numerically, they both represent the same address: <br><br><pre> <code class="bash hljs">(gdb) x/4xb a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 (gdb) x/4xb &amp;a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00</code> </pre><br>  However, their types are different.  As we have already seen, the name of the array splits into a pointer to its first element and therefore must be of type <i>int *</i> .  As for type <i>&amp; a</i> , we can ask GDB about it: <br><br><pre> <code class="bash hljs">(gdb) ptype &amp;a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = int (*)[3]</code> </pre><br>  Simply put, <i>&amp; a</i> is a pointer to an array of three integers.  This makes sense: <i>a</i> does not decay when passed to the operator <i>&amp;</i> and a is of type <i>int [3]</i> . <br><br>  You can trace the difference between the pointer, which splits <i>a</i> and the operation <i>&amp; a</i> by the example of how they behave in relation to pointer arithmetic: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a + 1 <span class="hljs-variable"><span class="hljs-variable">$10</span></span> = (int *) 0x7fff5fbff570 (gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> &amp;a + 1 <span class="hljs-variable"><span class="hljs-variable">$11</span></span> = (int (*)[3]) 0x7fff5fbff578</code> </pre><br>  Notice that adding 1 to <i>a</i> increases the address by four units, while adding 1 to <i>&amp; a</i> adds twelve to the address. <br><br>  The pointer to which a really splits <i>a</i> has the form <i>&amp; a [0]</i> : <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> &amp;a[0] <span class="hljs-variable"><span class="hljs-variable">$11</span></span> = (int *) 0x7fff5fbff56c</code> </pre><br><h4>  Conclusion </h4><br>  I hope I convinced you that GDB is an elegant research environment for studying C. It allows you to output the value of expressions using the <i>print</i> command, examine the memory by command <i>x by one by one,</i> and work with types using the <i>ptype</i> command. <br><br>  If you plan to continue experimenting with learning C with GDB, then I have some suggestions: <br><br>  1. Use GDB to work on <a href="https://blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge">The Ksplice Pointer Challenge</a> . <br>  2. Understand how structures are stored in memory.  How do they compare to arrays? <br>  3. Use GDB disassembler commands to better understand assembly programming.  It is especially fun to explore how the function call stack works. <br>  4. Check out the ‚ÄúTUI‚Äù GDB mode, which provides a graphical ncurses add-on over the usual GDB.  On OS X, you will probably have to build GDB from source. <br><br>  <i>From the translator: Traditionally, to specify errors, use the LAN.</i>  <i>I will be glad to constructive criticism.</i> </div><p>Source: <a href="https://habr.com/ru/post/181738/">https://habr.com/ru/post/181738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181720/index.html">Video interview from Silicon Valley. Ilya Semin: "I do not need investors" - how to build a business in IT without attracting investment</a></li>
<li><a href="../181728/index.html">Distributed audio player on Odroid U2</a></li>
<li><a href="../18173/index.html">USB-HomoLudens</a></li>
<li><a href="../181732/index.html">Google will have to disclose user data at the request of the FBI</a></li>
<li><a href="../181734/index.html">Five file managers for Android</a></li>
<li><a href="../181740/index.html">Super simple iOS JSON mapper</a></li>
<li><a href="../181744/index.html">What is a FlexPod?</a></li>
<li><a href="../181746/index.html">Implementing underscore styles in LESS via png generation in data-URI</a></li>
<li><a href="../181748/index.html">Petersburg game development evenings with Unity Technologies</a></li>
<li><a href="../18175/index.html">Login usability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>