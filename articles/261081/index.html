<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hardcore old school: QEMU and reverse floppy image</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On the eve of the ‚Äú face-to-face ‚Äù NeoQUEST-2015, which will take place tomorrow, July 2, at 11:00, in St. Petersburg, we are publishing a write-up of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hardcore old school: QEMU and reverse floppy image</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/a0e/1d1/28a/a0e1d128aba04e2aaf1e25a1c97a941c.png"><br>  On the eve of the ‚Äú <a href="http://neoquest.ru/timeline.php%3Fyear%3D2015">face-to-face</a> ‚Äù NeoQUEST-2015, which will take place tomorrow, July 2, at 11:00, in St. Petersburg, we are publishing a write-up of the last unsorted job of the online stage! <br><br>  We remind you that the entrance to the event is free, and we are waiting for everyone who is interested in information security!  NeoQUEST is a chance to learn something new, improve your ‚Äúhacker‚Äù skills, communicate with colleagues, watch the decisive competition of the best hackers, and just have a great time! <br><br>  You can read more about the venue and topics of the NeoQUEST-2015 reports <a href="http://habrahabr.ru/company/neobit/blog/255629/">here</a> and <a href="http://neoquest.ru/timeline.php%3Fyear%3D2015">there</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task of the online stage, left ‚Äúfor dessert‚Äù, was quite old-school: it is enough that it was a dump of all the long-forgotten floppy disk!  How the participants of the quest had to tinker with the reverse and with QEMU - under the cut! <br><a name="habracut"></a><br><br><h4>  <b>What to do with the source data for the task?</b> </h4><br>  In a task, the task.bin file acts as the source data.  According to the legend, this should be an image of a boot floppy.  Let's try to feed it to the file utility. <br><br><img src="https://habrastorage.org/files/89f/1f7/237/89f1f723760641119da4960b38ab7543.png"><br><br>  The assumption was true, it is a floppy disk.  Well, let's try to boot from it.  As a virtual machine, we use QEMU.  Will execute <br><br><pre><code class="cpp hljs">qemu ‚Äìfda task.bin</code> </pre> <br>  and ... <br><br><img src="https://habrastorage.org/files/894/c6f/605/894c6f605a8340dcab679049f6a78fc8.png"><br><br>  ‚Ä¶ and nothing.  For some reason, it failed to load - QEMU wrote ‚ÄúLoading‚Äù and hung.  First, let's try to see what happens inside the virtual machine by connecting gdb to it as a debugger.  To connect gdb, it is important to know the operating mode of the virtual machine, since this affects the format of the data transferred from the application to the debugger. <br><br><h4>  <b>Virtual machine: a view from the inside</b> </h4><br>  Go to the QEMU window and press Ctrl + Alt + 2 to open the command console.  Perform the ‚Äúinfo registers‚Äù in it and scroll up with the Ctrl + Up combination. <br><br><img src="https://habrastorage.org/files/a14/d48/0ca/a14d480ca2a848c1a083b104e6c044e7.png"><br><br>  The picture above outlines the fields you should pay attention to - <a href="https://en.wikipedia.org/wiki/Control_register">CR0</a> and the attributes of the <a href="http://wiki.osdev.org/Global_Descriptor_Table">descriptor</a> pointed to by CS.  From the values ‚Äã‚Äãof CR0 and CS.ATTR, it follows that the protected mode is turned on without virtual memory and a 32-bit code is executed.  For us, this means that in gdb you need to switch the mode with the command <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> architecture i386</code> </pre><br><br>  In case gdb is 32bit, this architecture is set by default. <br><br>  Run QEMU with the ‚Äú‚Äìs‚Äù option (this option allows you to connect a debugger) and enable gdb by running the command ‚Äútarget remote localhost: 1234‚Äù.  Let's output several instructions around EIP, and see that the virtual machine is in HALT, with zeroes on the stack.  It is completely incomprehensible where we got here?  It seems to have to disassemble. <br><br><img src="https://habrastorage.org/files/aca/c62/39d/acac6239dc5242cfaeea798f49970b88.png"><br><br><h4>  <b>Disassembling and debugging code</b> </h4><br>  Let's try to figure out where the jump takes place in HALT, consistently disassembling and debugging the code!  Let's start with the first sector of the floppy disk.  When booting from floppy in legacy mode (and otherwise, it probably won't work), the BIOS reads the first sector and loads it at 0x7c00.  Most often, the task of the code from the first sector is to load the ‚Äúcontinuation‚Äù from the disk and switch to protected mode.  Let's see what the code is there, using the <a href="https://ru.wikipedia.org/wiki/Dd">dd</a> and <a href="http://we.easyelectronics.ru/CADSoft/obzor-vspomogatelnyh-utilit-iz-gcc-toolchain-chast-2.html">objdump</a> utilities. <br><br><img src="https://habrastorage.org/files/6ca/aea/ea7/6caaeaea74004f5ebc401b979ce53cef.png"><br><br>  After a little flipping through the code from the beginning, you can notice the transition to protected mode.  The ljmp instruction here is used to change the code selector, the transition address is 0x7c61.  Since I did not specify a base equal to 0x7c00 when disassembling, in my listing 0x7c61 corresponds to 0x61. <br><br>  This is usually done in order to start executing 32bit code.  Additionally, you can verify this by finding the gdt structure, whose address is in the gdtr register, whose value lies at 0x7d95 and is loaded with the lgdtw instruction at 0x7c4d (0x4d in our listing). <br><br>  In gdt, you need to look at the type of the descriptor with an offset of 8; this is the first argument to the ljmp instruction.  This means that the code at the address 0x7c61 is 32bit, and therefore, it is necessary to disassemble the objdump with other parameters.  Select the code of interest from the task.bin by offset 0x61 and disassemble it as 32bit. <br><br><img src="https://habrastorage.org/files/051/676/c5e/051676c5e942407aa6441ced959c79b0.png"><br><br>  In the resulting code, new values ‚Äã‚Äãare loaded into the selectors, and a jump occurs to the address 0x80000.  We will start the virtual machine and set breakpoint to this address.  To do this, QEMU starts with the command <br><br><pre> <code class="cpp hljs">qemu ‚Äìs ‚ÄìS ‚Äìfda task.bin</code> </pre><br><br>  gdb connects the way it was done before.  Set breakpoint to address - ‚Äúb * 0x80000‚Äù in gdb, continue - ‚Äúc‚Äù.  After the breakpoint has been triggered, we will display several instructions. <br><br><img src="https://habrastorage.org/files/550/82f/3fd/55082f3fde3d41368febfbee481f05d0.png"><br><br>  Perform the first jmp with the ‚Äúsi‚Äù command and again display the code for execution. <br><br><img src="https://habrastorage.org/files/3a5/05d/cc0/3a505dcc08d14cf8b01168cae927f7de.png"><br><br>  The code before the first ret is not rich in branching, and there is only one call in which something can occur.  Let's take 4K of memory at 0x82961, and see what code is executed there.  A memory dump can be obtained from gdb with the following command: <br><br><img src="https://habrastorage.org/files/d0d/5ce/f1b/d0d5cef1bcf5454da6d796e502c7fe02.png"><br><br>  Disassemble the resulting dump command <br><br><pre> <code class="cpp hljs">objdump ‚ÄìD ‚Äìb binary ‚Äìm i386 ./eip_dump.bin &gt; eip.txt</code> </pre><br><br>  The function at 0x82961 contains quite a lot of calls, but is itself a sequential piece of code with one ret at the end.  We are interested in where we get to halt, and since there is no halt in the visible code, we set breakpoints on all the call'y and ret at the end of the function. <br><br>  Here is a list of addresses of interest: 0x82970, 0x82aef, 0x82A5B, 0x82A7D, 0x82A91, 0x82AB0, 0x82AEF, 0x82B10, 0x82B32, 0x82B46, 0x82B65, 0x82C53, 0x82CAD.  Further we will continue execution, consistently falling out on each set breakpoint.  We are interested in breakpoint, after which there will be a hangup.  It is a breakpoint set to ret - at the end of the function under study.  This is unexpected, but if you pay attention to push before ret, it becomes clear that this is not a return to the dial peer, but a transfer of control to the new code.  Perform si and get to the address 0x4000020. <br><br><img src="https://habrastorage.org/files/c0c/9b5/2e3/c0c9b52e3b16448287b9b0e2bcd59318.png"><br><br><h4>  <b>Hurray, finally we launched the task!</b> </h4><br>  As we remember, the halt instruction is located at 0x4000260, which is already much closer to the current eip.  In order not to look for calls again and not to set breakpoints with our hands, let's do the following: we will write a simple script that will execute one instruction in a loop, print the next one and check that eip! = 0x4000260.  The script looks like this: <br><br><pre> <code class="cpp hljs">b *<span class="hljs-number"><span class="hljs-number">0x4000020</span></span> commands <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> $pc != <span class="hljs-number"><span class="hljs-number">0x4000260</span></span> x /<span class="hljs-number"><span class="hljs-number">1</span></span>i $pc si end x /<span class="hljs-number"><span class="hljs-number">1</span></span>i $pc end c</code> </pre><br><br>  Place the script in the script.txt file and execute it in gdb with the source command.  After the execution we get the following: <br><br><img src="https://habrastorage.org/files/008/987/5d7/0089875d7c3e4d6b878d1d5d388c3912.png"><br><br>  Two cpuid calls are apparent in the code, after which there is a hangup.  It seems that this is some kind of check.  We will understand what they check.  The first call is made with the parameter eax = 0x80000000, as a result, eax contains the maximum value of the parameter that can be passed to cpuid instructions.  Next, the value is compared with 0x80000001, this is a test for the ability to make the next call.  The second call is performed with the eax = 0x800000001 parameter, and the 29th edx bit is checked, which is set to 1 if Long Mode is supported. <br><br>  It seems that the virtual machine hangs because QEMU, which I run, does not support Long Mode.  Let's start the virtual machine as follows: <br><br><img src="https://habrastorage.org/files/196/5c2/db7/1965c2db74254f19aace86b5ad8d1ba3.png"><br><br>  Hooray, we managed to start the task!  The case remains for a little - execute it!  In general, the problem described above with the hang would not have happened if the linux in which we work was 64-bit.  In this case, we are just not lucky with the capacity of the system. <br><br><h4>  <b>Password selection</b> </h4><br>  Having reached the task itself, it becomes clear what needs to be done.  Apparently, you need to pick up the "password", which would satisfy the checking algorithm.  To do this, find the place where the password is checked. <br><br>  We will try to stop the execution of the virtual machine as close as possible to checking the password.  You may notice that before the error message is displayed, the entered password is printed on the fourth line.  Most likely, by this time the verification has not yet been completed, so, having fallen out of the debugger in this place, we will find ourselves with a password already entered, which has not yet passed the verification.  It will remain up the stack to the function in which the display of the password on the screen and its verification are called in sequence. <br><br><img src="https://habrastorage.org/files/c20/381/338/c203813382364cadb5db0e209e693c44.png"><br><br>  How to determine where to put a breakpoint in the code in order to get to the right place?  Printing a symbol on the screen is possible in two ways: <br><br><ol><li>  A simple way is to write a symbol to video memory at 0xb8000 in text mode, which is enabled by default at startup. </li><li>  A difficult way is to write a driver that would set up a video card and provide the function of drawing a point on the screen, and then, using fonts, draw a character point by point.  Instead of the driver, you can use the VBE BIOS, as it is done <a href="http://habrahabr.ru/company/neobit/blog/176707/">here</a> . </li></ol><br><br>  Suppose a simple method was used.  Then we can put a breakpoint on the access to the video memory, namely, to the first character of the fourth line.  Video memory starts with the address 0xb8000, the line size is 80 characters, for each character there are 2 bytes (symbol + color), the required address is 0xb8000 + 80 * 2 * 3 = 0xb81e0.  The command to set a breakpoint for writing to gdb memory will look like this: <br><br><pre> <code class="cpp hljs">watch *<span class="hljs-number"><span class="hljs-number">0xb81e0</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/643/fd4/a35/643fd4a351e24e14a385c22b3245b6d3.png"><br><br>  The assumption was true, we fell out immediately after writing the character to memory.  Breakpoint is no longer needed, you can delete it.  We make one more assumption - suppose that there is a function in which the printing and password verification code is sequentially called.  Then the source code should look like this: <br><br><img src="https://habrastorage.org/files/c4f/c0e/820/c4fc0e820ce6474185023da5b09654a5.png"><br><br>  Our goal is to find the CheckPass () function.  To do this, we will set breakpoints to return addresses from the functions nested in PrintPass (), and continue execution.  If the breakpoint has just fallen out, and the message ‚ÄúPassword incorrect.‚Äù Has not yet been printed, then we put a new one and continue. <br><br>  If it is printed, then the last but one set and we needed it - it stood right after the call to PrintPass () in the body of task ().  We will understand how to get the return address.  If the code was compiled without specific flags, then at the beginning of the function with a couple of instructions ‚Äúpush $ rbp;  mov $ rsp, $ rbp ‚Äùformed a new stack frame.  In this case, the return address is stored at $ rbp + 8.  It's easy to check: <br><br><img src="https://habrastorage.org/files/f12/ca0/1b3/f12ca01b38ae48408ca371f4a40a5123.png"><br><br>  Indeed, before the address 0xfffff8000020e5b5 there is an instruction call.  Now we can carry out our plans. <br><br><h4>  <b>We write a script</b> </h4><br>  Since it is unknown what the depth of the stack is, we will write a small script for gdb that will go up the stack until QEMU starts typing on the ‚ÄúPassword incorrect‚Äù screen. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> confirm off <span class="hljs-meta"><span class="hljs-meta"># save start values of first 4 chars from 5th row of screen set $start_vmem_val = *(unsigned long long*)(0xb8280) set $curr_vmem_val = $start_vmem_val # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> nothing changed in 5th row of screen, we continue while $start_vmem_val == $curr_vmem_val # delete all old breakpoints d # get return addres from stack and set breakpoint on it. Then, continue. set $ret_addr = *(unsigned long long*)($rbp + 8) b *$ret_addr c set $curr_vmem_val = *(unsigned long long*)(0xb8280) end</span></span></code> </pre><br><br>  Save the script to a file and execute the command source, as already done before.  We get the following: <br><br><img src="https://habrastorage.org/files/fc7/6ec/29a/fc76ec29ae08498ebb8247d92ab0b0c3.png"><br><br>  The script is frozen, never getting into breakpoint at 0x20069c, but the message ‚ÄúPassword incorrect‚Äù is printed.  This means that the assumption about the existence of a function that we called task () is true.  The hang indicates that the task () function never returns after the ‚ÄúPassword incorrect‚Äù message is printed to the screen.  However, this is not important, the main thing is that we now know the return address from the PrintPass () function, to which we put the last but thirteenth breakpoint. <br><br><h4>  <b>The search continues ...</b> </h4><br>  Let's continue the search for the password verification procedure from the newly received address 0xfffff80000205808: run QEMU, set a breakpoint at this address and enter an arbitrary password.  We'll dump the code by stepping back a few bytes from the RIP to find out the address of the function we just left. <br><br><img src="https://habrastorage.org/files/40d/4fe/6a9/40d4fe6a97e94ee1b7e9dfe7c242ab72.png"><br><br>  Disassemble the resulting dump with the command ‚Äúobjdump ‚ÄìD ‚Äìb binary ‚Äìm i386: x86-64 ‚Äìadjust-vma = 0xfffff800002057fc task.bin&gt; task.txt‚Äù. <br><br>  Note that we have just left the function at 0xfffff80000203358, and this address is found several times in the received dump. <br><br>  fffff800002057fc &lt;.data&gt;: <br>  fffff800002057e3: 48 8d 85 60 ff ff ff lea -0xa0 (% rbp),% rax <br>  fffff800002057ea: 48 89 c6 mov% rax,% rsi <br>  fffff800002057ed: 48 bf 56 15 21 00 00 movabs $ 0xfffff80000211556,% rdi <br>  fffff800002057f4: f8 ff ff <br>  fffff800002057f7: b8 00 00 00 00 mov $ 0x0,% eax <br>  fffff800002057fc: 48 ba 58 33 20 00 00 movabs $ 0xfffff80000203358,% rdx <br>  fffff80000205803: f8 ff ff <br>  fffff80000205806: ff d2 callq *% rdx <br>  rip =&gt; fffff80000205808: 48 b8 08 15 21 00 00 movabs $ 0xfffff80000211508,% rax <br>  fffff8000020580f: f8 ff ff <br>  ... <br>  fffff80000205930: 48 bf 65 15 21 00 00 movabs $ 0xfffff80000211565,% rdi <br>  fffff80000205937: f8 ff ff <br>  fffff8000020593a: b8 00 00 00 00 mov $ 0x0,% eax <br>  fffff8000020593f: 48 ba 58 33 20 00 00 movabs $ 0xfffff80000203358,% rdx <br>  fffff80000205946: f8 ff ff <br>  fffff80000205949: ff d2 callq *% rdx <br>  ... <br>  fffff8000020594d: 48 bf 78 15 21 00 00 movabs $ 0xfffff80000211578,% rdi <br>  fffff80000205954: f8 ff ff <br>  fffff80000205957: b8 00 00 00 00 mov $ 0x0,% eax <br>  fffff8000020595c: 48 ba 58 33 20 00 00 movabs $ 0xfffff80000203358,% rdx <br>  fffff80000205963: f8 ff ff <br>  fffff80000205966: ff d2 callq *% rdx <br><br>  The considered code is 64-bit and there are two main conventions of calls used in a 64-bit code: <br><ol><li>  " <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">Microsoft x64 calling convention</a> " </li><li>  " <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">System V ABI</a> " </li></ol><br>  In this case, System V is used, since the arguments for call are passed through the RDI, RSI, RDX registers, etc.  We have just exited a function that, at a minimum, displayed text, and this function is called several times.  The first time it is called with the arguments 0xfffff80000211556 and -0xa0 (% rbp), the second time with 0xfffff80000211565, the third time with 0xfffff80000211578.  Let's see what is at these addresses. <br><br><img src="https://habrastorage.org/files/21d/c74/d0d/21dc74d0d8d34e7784fc18758da285d8.png"><br><br>  The function 0xfffff80000203358 is printf, and, depending on the result of the check, it displays different messages.  The string "123" is the entered password.  Let's see, depending on what messages are displayed. <br><br>  fffff8000020591c: movabs $ 0xfffff800002114c0,% rax <br>  fffff80000205926: mov 0x38 (% rax),% rax <br>  fffff8000020592a: cmp $ 0x1,% rax if (g_struct.res == 1) <br>  , ==== &lt;fffff8000020592e: jne 0xfffff8000020594d { <br>  |  fffff80000205930: movabs $ 0xfffff80000211565,% rdi <br>  |  fffff8000020593a: mov $ 0x0,% eax <br>  |  fffff8000020593f: movabs $ 0xfffff80000203358,% rdx <br>  |  fffff80000205949: callq *% rdx printf (‚ÄúPassword correct!‚Äù); <br>  |  , == &lt;fffff8000020594b: jmp 0xfffff80000205968} <br>  `====&gt; fffff8000020594d: movabs $ 0xfffff80000211578,% rdi else <br>  |  fffff80000205957: mov $ 0x0,% eax { <br>  |  fffff8000020595c: movabs $ 0xfffff80000203358,% rdx <br>  |  fffff80000205966: callq *% rdx printf (‚ÄúPassword incorrect.‚Äù); <br>  `==&gt; fffff80000205968: movabs $ 0xfffff80000204b83,% rax} <br>  fffff80000205972: callq *% rax some_func (); <br>  fffff80000205974: leaveq <br>  fffff80000205975: retq <br><br>  The result of the check is stored in the structure at address 0xfffff800002114c0 with an offset of 0x38.  Let's see if there are any calls to this structure in the function in question. <br><br>  fffff8000020587c: mov $ 0x48,% edx <br>  fffff80000205881: mov $ 0x0,% esi <br>  fffff80000205886: movabs $ 0xfffff800002114c0,% rdi <br>  fffff80000205890: movabs $ 0xfffff80000203d40,% rax <br>  fffff8000020589a: callq *% rax memset (&amp; g_struct, 0, 0x48); <br>  fffff8000020589c: lea -0xa0 (% rbp),% rdx <br>  fffff800002058a3: movabs $ 0xfffff800002114c0,% rax <br>  fffff800002058ad: mov% rdx, (% rax) * (u64 *) &amp; g_struct = password; <br>  fffff800002058b0: lea -0xa0 (% rbp),% rdx <br>  fffff800002058b7: movabs $ 0xfffff800002114c0,% rax <br>  fffff800002058c1: mov% rdx, 0x20 (% rax) * ((u64 *) &amp; g_struct + 4) = password; <br><br>  Above the code is a function call with three arguments, one of which is a pointer to our structure.  If you refer to the code of this function, it becomes clear that this is a memset.  A pointer to the string with the entered password, at offset 0 and 32 (0x20), is written twice to the structure.  Apparently, this is initialization.  If you look at the code between initialization and checking the result, we will see the following: <br><br>  ;  above is the initialization of the g_struct structure <br>  fffff800002058c5: movzbl -0x1 (% rbp),% eax l_var1 = -0x1 (% rbp); <br>  fffff800002058c9: mov% rax,% rdi <br>  fffff800002058cc: movabs $ 0xfffff80000203e94,% rax <br>  fffff800002058d6: callq *% rax if (func1 (l_var1)) <br>  fffff800002058d8: test% rax,% rax { <br>  fffff800002058db: sete% al <br>  fffff800002058de: test% al,% al <br>  , ==== &lt;fffff800002058e0: je 0xfffff80000205909 <br>  |  fffff800002058e2: movabs $ 0xfffff80000211508,% rax asm ( <br>  |  fffff800002058ec: mov (% rax),% rax push * 0xfffff80000211508 <br>  |  fffff800002058ef: mov% rax,% rdx retq <br>  |  fffff800002058f2: push% rdx); <br>  |  fffff800002058f3: retq <br>  |  fffff800002058f4: movzbl -0x1 (% rbp),% eax <br>  |  fffff800002058f8: mov% rax,% rdi <br>  |  fffff800002058fb: movabs $ 0xfffff800002040b2,% rax <br>  |  fffff80000205905: callq *% rax func2 (l_var1); <br>  |  , == &lt;fffff80000205907: jmp fffff8000020591c} <br>  `====&gt; fffff80000205909: movzbl -0x1 (% rbp),% eax else <br>  |  fffff8000020590d: mov% rax,% rdi { <br>  |  fffff80000205910: movabs $ 0xfffff800002040b2,% rax <br>  |  fffff8000020591a: callq *% rax func2 (l_var1); <br>  `==&gt; fffff8000020591c: movabs $ 0xfffff800002114c0,% rax} <br>  ;  below is the test and output <br><br>  Yellow highlighted branches in the code, which may be code verification password.  The push / ret construction looks somewhat strange in the middle of the code, since it is not clear how execution will continue after it.  We are still looking for a password verification feature. <br><br>  Functions at addresses 0xfffff800002040b2 and 0xfffff80000203e94 do not use the entered password and do not access the found structure.  Of interest is a pair of instructions push, retq, through which the jump to the address 0xfffff80000600000 occurs, but if you try to see what the code is at this address, we will see the following: <br><br><img src="https://habrastorage.org/files/8b4/be7/642/8b4be7642c064a6daf67405489a68382.png"><br><br>  When you try to execute it, a transition occurs to the address 0xfffff80000209ac5.  Why it happens?  The memory access error message suggests that virtual memory is not available at this address.  This can be checked by running ‚Äúinfo mem‚Äù in the QEMU console. <br><br><img src="https://habrastorage.org/files/014/85a/efc/01485aefcd4140bbbd0688095c4a8ad7.png"><br><br>  And indeed, the 2 megabyte range from the address 0xf80000600000 is not zamaplen.  Do not be confused by the fact that the top 4 digits are zero, not f - when translating virtual addresses in 64-bit mode, the top 16 bits are not used, and the address 0x0 is equal to the address 0xfffff00000000000.  When accessing an unplugged address, #PF (page fault) occurs, the problem address is written to CR2, control is transferred to the appropriate exception handler, which in our case is located at 0xfffff80000209ac5.  The accuracy of this assumption can be verified once again by looking at the value of the CR2 register in the QEMU console ‚Äî it is equal to 0xfffff80000600000. <br><br><h4>  <b>We carefully look at the code</b> </h4><br>  In the interrupt handler, the state is saved at the beginning, and the first C code appears at 0xfffff8000020da3c.  It has an interesting place: <br>  ... <br>  0xfffff8000020da5b: cmp $ 0xe,% rax <br>  0xfffff8000020da5f: jne 0xfffff8000020da95 <br>  0xfffff8000020da61: mov -0x18 (% rbp),% rax <br>  0xfffff8000020da65: mov 0xb8 (% rax),% rdx <br>  0xfffff8000020da6c: movabs $ 0xfffff80000211508,% rax <br>  0xfffff8000020da76: mov (% rax),% rax <br>  0xfffff8000020da79: cmp% rax,% rdx <br>  0xfffff8000020da7c: jb 0xfffff8000020da95 <br>  0xfffff8000020da7e: mov -0x18 (% rbp),% rax <br>  0xfffff8000020da82: mov% rax,% rdi <br>  0xfffff8000020da85: movabs $ 0xfffff80000204df8,% rax <br>  0xfffff8000020da8f: callq *% rax <br>  ... <br>  Comparing with 0xe ( <a href="http://wiki.osdev.org/Exceptions">#PF</a> ) is very similar to checking the cause of the exception that has occurred, and at 0xfffff80000211508 lies the value 0xfffff80000600000, with which another comparison takes place.  If both conditions are met, then a call to the address 0xfffff80000204df8 occurs.  There we can see the following code: <br>  ... <br>  0xfffff80000204e19: movabs $ 0xfffff8000020fda0,% rax <br>  0xfffff80000204e23: lea (% rdx,% rax, 1),% rax <br>  0xfffff80000204e27: mov (% rax),% rdx <br>  0xfffff80000204e2a: mov% rdx, -0x50 (% rbp) <br>  0xfffff80000204e2e: mov 0x8 (% rax),% rdx <br>  0xfffff80000204e32: mov% rdx, -0x48 (% rbp) <br>  0xfffff80000204e36: mov 0x10 (% rax),% rax <br>  0xfffff80000204e3a: mov% rax, -0x40 (% rbp) <br>  0xfffff80000204e3e: mov -0x50 (% rbp),% rax <br>  0xfffff80000204e42: cmp $ 0x726574,% rax <br>  0xfffff80000204e48: je 0xfffff80000205418 <br>  0xfffff80000204e4e: cmp $ 0x726574,% rax <br>  0xfffff80000204e54: ja 0xfffff80000204ea4 <br>  0xfffff80000204e56: cmp $ 0x69667a,% rax <br>  0xfffff80000204e5c: je 0xfffff80000205067 <br>  0xfffff80000204e62: cmp $ 0x69667a,% rax <br>  0xfffff80000204e68: ja 0xfffff80000204e87 <br>  0xfffff80000204e6a: cmp $ 0x616464,% rax <br>  0xfffff80000204e70: je 0xfffff80000205225 <br>  ... <br>  A significant part of the function is taken by a couple of cmp / je instructions, the abundance of which suggests that there was a long switch / case in the C code, where each value had its own handler.  The 8-byte value, readable at 0xfffff8000020fda0 with a certain offset, acts as a compared one. <br><br>  If you put a break point on this code, you can see that it is executed repeatedly and the offset is always a multiple of 24 m.  It looks like a virtual machine with an instruction length of 24 bytes, where the first 8 bytes are the instruction signature, and the remaining 16 are the parameters.  We will dump the memory at 0xfffff8000020fda0 with the command ‚Äúdump memory vmcode.bin 0xfffff8000020fda0 0xfffff80000210da0‚Äù and open it in the hex editor (Okteta turned out to be on my hands). <br><br><img src="https://habrastorage.org/files/3ee/808/6f9/3ee8086f91384661a138fa05496c5ba1.png"><br><br>  The right side of the figure clearly shows that instruction signatures are encoded as combinations of ASCII characters.  Among the instructions there are such as llac, tixe, bus, which suggests that we see them upside down.  This is due to the fact that they were written in C code as a value in single quotes stored in little-endian.  The parameters of the instructions are either the values ‚Äã‚Äãof r0, r1, ..., etc., or numbers. <br><br><h4>  <b>Got to the virtual machine code!</b> </h4><br>  In principle, having reached the virtual machine code, disassembling it is a matter of technology.  Signatures of instructions clearly hint at how they work, and if something needs to be clarified, it suffices to find the appropriate handler in the function at 0xfffff80000204df8.  In pseudocode, the VM code looks like this: <br><br><pre> <code class="cpp hljs">r3 = <span class="hljs-number"><span class="hljs-number">5381</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { r1 = *(u8*)r0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; r3 = r3 * <span class="hljs-number"><span class="hljs-number">33</span></span> + r1; } <span class="hljs-comment"><span class="hljs-comment">// check DJB hash if (r3 != 0x40e1baa8ff648029) { return 0; } r5 &lt;&lt; 64 + r3 = (u128)hexstr2val(r4) if (r5 - r3 != 0x2a60386296a57940) { return 0; } r2 = r3 &gt;&gt; 32; r1 = (r3 &lt;&lt; 32) &gt;&gt; 32; if (r2 - r1 != 0x3394749a) { return 0; } r2 = (r3 &lt;&lt; 32) &gt;&gt; 48; r1 = (r3 &lt;&lt; 48) &gt;&gt; 48; if (r2 - r1 != 0x465e) { return 0; } return 1; // success</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After checking the DJB hash from the entered string, there are additional conditions that the key must satisfy. </font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program for the selection of key</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key is not present in the checks explicitly, but based on 4 conditions in the pseudocode, it can be quickly picked up. </font><font style="vertical-align: inherit;">Below is an example of a program that selects the right key.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d64 = <span class="hljs-number"><span class="hljs-number">0x2a60386296a57940</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d32 = <span class="hljs-number"><span class="hljs-number">0x3394749a</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d16 = <span class="hljs-number"><span class="hljs-number">0x465e</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> step = <span class="hljs-number"><span class="hljs-number">0x1000100010001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> key_l = ((d32 &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) + (d16 &lt;&lt; <span class="hljs-number"><span class="hljs-number">48</span></span>)) + ((d16 &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> key_h = key_l + d64; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> key_ss; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { key_ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::hex &lt;&lt; key_h; key_ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::hex &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">16</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setfill(<span class="hljs-string"><span class="hljs-string">'0'</span></span>) &lt;&lt; key_l; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> key_str_hash = djb2_hash(key_ss.str().c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_str_hash == <span class="hljs-number"><span class="hljs-number">0x40e1baa8ff648029</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Success! "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"res_key = '"</span></span> &lt;&lt; key_ss.str() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"'\n"</span></span>; } key_h += step; key_l += step; i++; key_ss.str(<span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br> P !      ,       ,     . <br><br><img src="https://habrastorage.org/files/626/fa0/c50/626fa0c503a748ef9f139b02f0701c4c.png"><br><br>    VM    #PF,         VM,      exit,   longjmp,         #PF.     .      VM,        #PF,    . <br><br><h4> <b>  </b> </h4><br>  :          ,  IDA,           (, , ), ,  , ,     .  -    IDA    64 . <br><br>        radare2,   ,   ,    ,  rasm     ‚Äúmovabs $0xfffff800002114c0,%rax‚Äù,        ,    (bin.laddr),  4Gb.  -    ,   radare2      ,    .        objdump, gdb  $EDITOR. <br><br><h4> <b>   NeoQUEST-2015?</b> </h4><br>       7 ,    8  (    ‚Äî  10:00)!       ,        ,     .  18:00   ,      ‚Äî      , ¬´¬ª  ¬´¬ª     .        ! </div><p>Source: <a href="https://habr.com/ru/post/261081/">https://habr.com/ru/post/261081/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261069/index.html">Google AI or Data Center in the power of artificial intelligence</a></li>
<li><a href="../261071/index.html">Decoding the upcoming 3CX Phone System update to version 14</a></li>
<li><a href="../261075/index.html">Antiviruses at gunpoint: a big hole in ESET and an attack on Kaspersky</a></li>
<li><a href="../261077/index.html">5 internships for IT professionals abroad</a></li>
<li><a href="../261079/index.html">D for beginners, part 2</a></li>
<li><a href="../261083/index.html">GIF, WebP, APNG, BPG animation comparison</a></li>
<li><a href="../261085/index.html">Samsung software can intentionally disable Windows Update</a></li>
<li><a href="../261087/index.html">Microsoft DevOps tools</a></li>
<li><a href="../261089/index.html">Infrastructure: What is behind the pictures on the Internet</a></li>
<li><a href="../261091/index.html">HP StormRunner Load. A practical guide. Part III</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>