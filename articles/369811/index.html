<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Refactoring using C ++ 17 std :: optional</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In development, there are many situations where you need to express something with the help of an " optional " object, which may or may not contain an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Refactoring using C ++ 17 std :: optional</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/vg/ol/lg/vgollgyrmhj2ukthgazv0ohhnsw.png"></p><br><p> In development, there are many situations where you need to express something with the help of an " <code>optional</code> " object, which may or may not contain any value.  You can implement an optional type with several options, but with C ++ 17 you can accomplish this with the most convenient option: std :: optional. </p><br><p>  Today, I have prepared one refactoring task for you, to which you can learn how to apply the new C ++ feature 17. </p><br><h2 id="vstuplenie">  Introduction </h2><br><p>  Let's quickly dive into the code. </p><br><p>  Imagine that there is a function that takes an <code>ObjSelection</code> object, which is, for example, the current position of the mouse pointer.  The function scans the selection and finds the number of animated objects, whether there are civilian units there and whether there are military units there. </p><a name="habracut"></a><br><p>  The existing code looks like this: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ObjSelection</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// more code... }; bool CheckSelectionVer1(const ObjSelection &amp;objList, bool *pOutAnyCivilUnits, bool *pOutAnyCombatUnits, int *pOutNumAnimating);</span></span></code> </pre> <br><p>  As you can see above, the function mainly contains output parameters (in the form of raw pointers) and returns <code>true/false</code> to indicate the success of its execution (for example, the selection may be incorrect). </p><br><p>  I will skip the implementation of this function, but below you can see the code that calls this function: </p><br><pre> <code class="hljs objectivec">ObjSelection sel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> anyCivilUnits { <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> anyCombatUnits {<span class="hljs-literal"><span class="hljs-literal">false</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numAnimating { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckSelectionVer1(sel, &amp;anyCivilUnits, &amp;anyCombatUnits, &amp;numAnimating)) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Why is this feature not perfect? </p><br><p>  There are several reasons for this: </p><br><ul><li>  Look at the code that calls it: we need to create all the variables that will store the output values ‚Äã‚Äãof the function.  This may look like duplication of code if you call the function in several places. </li><li>  Output Parameters: Core Guidelines recommend not using them.  ( <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">F.20: For return values, prefer return values ‚Äã‚Äãfrom a function, rather than output parameters</a> ) </li><li>  Raw pointers need to be checked for correctness. </li><li>  What about expanding the function?  What if you need to add another output parameter? </li></ul><br><p>  Anything else? </p><br><p>  How will you refactor it? </p><br><p>  Guided by Core Guidelines and new features of C ++ 17, I plan to divide the refactoring into the following steps: </p><br><ol><li>  Refactoring output parameters to <code>std::tuple</code> , which will be the return value. </li><li>  Refactoring <code>std::tuple</code> to a separate structure and reducing <code>std::tuple</code> to <code>std::pair</code> . </li><li>  Use <code>std::optional</code> to emphasize possible errors. </li></ol><br><h2 id="seriya">  Series </h2><br><p>  This article is part of my C ++ 17 library utility series.  Here is a list of other topics that I‚Äôm talking about: </p><br><ul><li>  Refactoring using C ++ 17 std :: optional ( <strong>this post</strong> ). </li><li>  <a href="https://habr.com/post/372103/"><code> std::optional</code> .</a> </li><li>  <a href="https://www.bfilipek.com/2018/05/errors-and-optional.html"><code>    std::optional</code> .</a> </li><li>  Using <code>std::variant</code> . </li><li>  Using <code>std::any</code> . </li><li>  In place constructors for <code>std::optional</code> , <code>std::variant</code> and <code>std::any</code> . </li><li>  Use <code>std::string_view</code> . </li><li>  C ++ 17 utilities for searching and converting strings. </li><li>  Work with <code>std::filesystem</code> . </li><li>  Something else?  :) </li></ul><br><p>  C ++ 17 STL Resources: </p><br><ul><li>  <a href="https://leanpub.com/cpp17">The complete guide to C ++ 17</a> by Nikolai Josuttis (English language). </li><li>  <a href="https%253A%252F%252Fwww.pluralsight.com%252Fcourses%252Fcplusplus-fundamentals-c17">Basics of C ++, including C ++ 17</a> by Keith Gregory (English). </li><li>  <a href="http://amzn.to/2v6KkmV">The recipe book of C ++ 17 STL</a> from Jacek Galovitsza (English language). </li></ul><br><p>  OK, now let's refactor something. </p><br><h2 id="stdtuple"> <code>std::tuple</code> </h2> <br><p>  The first step is to convert the output parameters to <code>std::tuple</code> and return it from the function. </p><br><p>  In accordance with <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">F.21: For returning multiple output values, it is preferable to use tuples or structures (English language)</a> </p><br><blockquote>  The return value is documented itself as a "return only" value.  Note that a function in C ++ can have multiple return values ‚Äã‚Äãusing the tuple usage agreement (including the ( <code>std::pair</code> ) <code>std::pair</code> , with the additional use of (possibly) <code>std::tie</code> on the caller. </blockquote><p>  After the change, our code should look like this: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; CheckSelectionVer2(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjSelection &amp;objList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!objList.IsValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// local variables: int numCivilUnits = 0; int numCombat = 0; int numAnimating = 0; // scan... return {true, numCivilUnits &gt; 0, numCombat &gt; 0, numAnimating }; }</span></span></code> </pre> <br><p>  A bit better, isn't it? </p><br><ul><li>  There is no need to check the values ‚Äã‚Äãof raw pointers. </li><li>  The code has become quite expressive. </li></ul><br><p>  Moreover, you can use <a href="https://www.bfilipek.com/2017/07/cpp17-details-simplifications.html">structured bindings (English language: Structured Bindings, <em>note lane.: There is no well-established name in Russian</em> )</a> to wrap the tuple on the caller: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [ok, anyCivil, anyCombat, numAnim] = CheckSelectionVer2(sel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ok) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Unfortunately, it seems to me that this is not the best option.  I think it's easy to forget the order of the output variables in a tuple.  There is an article on SimplifyC ++ on this topic: <a href="https://arne-mertz.de/2017/03/smelly-pair-tuple/"><code> std::pair</code> and <code>std::tuple</code> (English language)</a> . </p><br><p>  Moreover, there is still the problem of expanding the function in the future.  Therefore, when you want to add another output value, you will need to expand the tuple on the caller. </p><br><p>  Therefore, I propose the next step: structure (the same is proposed in Core Guidelines). </p><br><h2 id="otdelnaya-struktura">  Separate structure </h2><br><p>  The output results are related data.  Therefore, it seems like a good idea to wrap them in a structure called <code>SelectionData</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectionData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> anyCivilUnits { <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> anyCombatUnits { <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numAnimating { <span class="hljs-number"><span class="hljs-number">0</span></span> }; };</code> </pre> <br><p>  After that we can rewrite our function as follows: </p><br><pre> <code class="hljs objectivec">std::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, SelectionData&gt; CheckSelectionVer3(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjSelection &amp;objList) { SelectionData <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!objList.IsValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// scan... return {true, out}; }</span></span></code> </pre> <br><p>  And on the caller: </p><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">auto</span></span> [ok, selData] = CheckSelectionVer3(<span class="hljs-name"><span class="hljs-name">sel</span></span>)<span class="hljs-comment"><span class="hljs-comment">; ok) { // ... }</span></span></code> </pre> <br><p>  I used <code>std::pair</code> , so we still save the flag of successful function execution, it does not become part of the new structure. </p><br><p>  The main advantage is that we got a logical structure and extensibility here.  If you want to add a new parameter, simply expand the structure. </p><br><p>  But <code>std::pair&lt;bool, MyType&gt;</code> very similar to <code>std::optional</code> , isn't it? </p><br><h2 id="stdoptional"> <code>std::optional</code> </h2> <br><p>  Below is a description of the type <a href="http://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code> with CppReference</a> : </p><br><blockquote>  The template class <code>std::optional</code> controls an optional value, i.e., a value that may or may not be represented. <br>  A common example of using an optional data type is the return value of a function, which may return an erroneous result during execution.  Unlike other approaches, such as <code>std::pair&lt;T, bool&gt;</code> , the optional data type is well managed with heavy objects for construction and is more readable, since it clearly expresses the intentions of the developer. </blockquote><p>  This seems to be the perfect choice for our code.  We can remove <code>ok</code> from our code and rely on the semantics of the optional type. </p><br><p>  For reference, <code>std::optional</code> was added in C ++ 17, but before C ++ 17 you could use <code>boost::optional</code> , since they are almost identical. </p><br><p>  The new version of our code looks like this: </p><br><pre> <code class="hljs kotlin">std::optional&lt;SelectionData&gt; CheckSelection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjSelection &amp;objList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!objList.IsValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { }; SelectionData <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; <span class="hljs-comment"><span class="hljs-comment">// scan... return {out}; }</span></span></code> </pre> <br><p>  and on the caller: </p><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (auto ret = CheckSelection(sel); ret.has_value()) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> access via *ret <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> even ret-&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ret-&gt;numAnimating }</code> </pre> <br><p>  The version with the optional data type has the following advantages: </p><br><ul><li>  Pure and expressive form. </li><li>  Efficiency: the implementation of the optional type does not allow the use of additional memory (eg, dynamic) to store the value.  The value should be stored in the memory area that was allocated by the optional type for the template parameter <code>T</code> </li><li>  No need to worry about extra memory allocation. </li></ul><br><p>  It seems to me that the version using the optional type is the best in the considered example. </p><br><h2 id="kod">  Code </h2><br><p>  You can play with the code at this <a href="https://tech.io/playground-widget/85cf8cbfb026d494ea01678ab4b862ba0385/c-tests-2/275561/std%253A%253Aoptional%2520refactor%2520">link</a> . </p><br><h2 id="itog">  Total </h2><br><p>  In this article, you saw how to refactor a lot of badly smelling code with output parameters using an optional type.  The wrapper over the data in the form of an optional type makes it clear that the calculated value may not exist.  I also showed how to wrap several function parameters in a separate structure.  You can easily extend your code using separate data types while maintaining the logical structure of the code. </p><br><p>  On the other hand, this new implementation omits an important aspect of the code: error handling.  At the moment, you can not find out why the function could not calculate the value.  In the previous example, when implemented with <code>std::pair</code> , we could return some kind of error code to indicate the reason. </p><br><p>  Here is what I found in the <a href="https://www.boost.org/doc/libs/1_63_0/libs/optional/doc/html/boost_optional/tutorial/when_to_use_optional.html">documentation boost (English language)</a> : </p><br><blockquote>  The optional data type <code>std::optional&lt;T&gt;</code> recommended to be used in cases where there is only one reason why we could not get an object of type <code>T</code> and where the absence of a value of <code>T</code> just as normal as its presence. </blockquote><p>  In other words, the version of <code>std::optional</code> looks great only if we take the situation of "incorrect allocation" for the usual working situation in the application ... this is a good topic for the next article :) I wonder what you think about the places where would be great to use <code>std::optional</code> . </p><br><p>  How would you refactor the first version of the code? <br>  Would you return tuples or create structures from them? </p><br><p>  See the following article: <a href="https://www.bfilipek.com/2018/05/using-optional.html"><code> std::optional</code></a> . </p><br><p>  Below you can see some articles that helped me with this post: </p><br><ul><li>  <a href="https://akrzemi1.wordpress.com/2015/07/15/efficient-optional-values/">Effective optional values ‚Äã‚Äã(English language)</a> </li><li>  <a href="https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/">Reference Specifiers (English)</a> </li><li> <a href="https://www.fluentcpp.com/2016/11/24/clearer-interfaces-with-optionalt/"><code> C++:     std::optional&lt;T&gt;</code></a> </li> </ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/369811/">https://habr.com/ru/post/369811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../369801/index.html">Australian scientists have increased qubit stability 10 times</a></li>
<li><a href="../369803/index.html">Autophone "D-Beacon" - the latest version of the stolen vehicle search system</a></li>
<li><a href="../369805/index.html">Autonomous truck Otto from Uber made its first unmanned flight</a></li>
<li><a href="../369807/index.html">IBM and Siemens to help improve the quality of healthcare services for patients with chronic diseases</a></li>
<li><a href="../369809/index.html">LinkedIn: a job search assistant or a hunter for domestic specialists?</a></li>
<li><a href="../369813/index.html">Oscillose - electric mini-saw and multi-tool</a></li>
<li><a href="../369817/index.html">Zero HIV patient probably flew to New York from Haiti in 1971</a></li>
<li><a href="../369819/index.html">Overview of the flagship reader PocketBook 631 Touch HD with E Ink Carta screen</a></li>
<li><a href="../369821/index.html">Ilon Mask at Tesla Motors presentation showed new solar roof panels to the public</a></li>
<li><a href="../369823/index.html">Higher temperatures turn Spain into a desert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>