<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>14 index questions in SQL Server that you feel shy about asking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Indexes are the first thing that needs to be well understood in the work of SQL Server , but in a strange way, basic questions are not often asked in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>14 index questions in SQL Server that you feel shy about asking</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>Indexes</b> are the first thing that needs to be well understood in the work of <i>SQL Server</i> , but in a strange way, basic questions are not often asked in forums and receive not so many answers. <br>  <i>Rob Sheldon</i> answers these embarrassing professional circles, questions about indexes in <i>SQL Server</i> : some of them we are just too shy to ask, and before asking others we first think twice. </blockquote><br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  This post is a compilation of two articles by Rob Sheldon: <br><ul><li>  <a href="https://www.simple-talk.com/sql/learn-sql-server/sql-server-index-basics/">SQL Server Index Basics</a> on November 25, 2008 (this note gives an understanding of the basic terms) </li><li>  <a href="https://www.simple-talk.com/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/">14 SQL Server Indexing Questions You Were Too Shy To Ask</a> on March 25, 2014 (actually, for her, everything was started) </li></ul><br>  If you write queries in <i>T-SQL</i> , but you don‚Äôt understand where the data comes from, then you should read this translation. <br>  If you want to know more, then at the end of the translation I give three books from which to move on. </div></div><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Used terminology in Russian translation</b> <div class="spoiler_text"><table><tbody><tr><td>  index </td><td>  index </td></tr><tr><td>  heap </td><td>  a bunch </td></tr><tr><td>  table </td><td>  table </td></tr><tr><td>  view </td><td>  representation </td></tr><tr><td>  B-tree </td><td>  balanced tree </td></tr><tr><td>  clustered index </td><td>  clustered index </td></tr><tr><td>  nonclustered index </td><td>  nonclustered index </td></tr><tr><td>  composite index </td><td>  composite index </td></tr><tr><td>  covering index </td><td>  covering index </td></tr><tr><td>  primary key constraint </td><td>  primary key constraint </td></tr><tr><td>  unique constraint </td><td>  uniqueness constraint </td></tr><tr><td>  query </td><td>  request </td></tr><tr><td>  query engine </td><td>  query subsystem </td></tr><tr><td>  database </td><td>  database </td></tr><tr><td>  database engine </td><td>  storage subsystem </td></tr><tr><td>  fill factor </td><td>  index fill factor </td></tr><tr><td>  surrogate primary key </td><td>  surrogate primary key </td></tr><tr><td>  query optimizer </td><td>  query optimizer </td></tr><tr><td>  index selectivity </td><td>  index selectivity </td></tr><tr><td>  filtered index </td><td>  filtered index </td></tr><tr><td>  execution plan </td><td>  execution plan </td></tr></tbody></table></div></div><br><br>  <a href="https://habr.com/ru/post/247373/">Skip reading the basics and go directly to 14 questions.</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  The Basics of Indexes in SQL Server </h1><br>  One of the most important ways to achieve high performance in <i>SQL Server</i> is to use indexes.  The index speeds up the query process by providing quick access to the data rows in the table, just as the pointer in the book helps you quickly find the necessary information.  In this article, I will provide a brief overview of indexes in <i>SQL Server</i> and explain how they are organized in the database and how they help speed up the execution of database queries. <br><br><h3>  Index structure </h3><br>  Indexes are created for table and view columns.  Indexes provide a way to quickly find data based on the values ‚Äã‚Äãin these columns.  For example, if you create an index on a primary key and then search for a row with data using primary key values, <i>SQL Server</i> will first find the index value and then use the index to quickly find the entire row with data.  Without an index, a full scan (scan) of all rows of the table will be performed, which can have a significant performance impact. <br>  You can create an index on most columns of a table or view.  The exception is mostly columns with data types for storing large objects ( <i>LOB</i> ), such as <i>image</i> , <i>text,</i> or <i>varchar (max)</i> .  You can also create indexes on columns intended for storing data in <i>XML format</i> , but these indexes are arranged a little differently than standard ones and their consideration is beyond the scope of this article.  The article also does not <i>cover columnstore</i> indexes.  Instead, I focus on the indexes most commonly used in <i>SQL Server databases</i> . <br>  An index consists of a set of pages, index nodes, which are organized in the form of a tree structure - a <i>balanced tree</i> .  This structure is hierarchical in nature and begins with the root node at the top of the hierarchy and leaf nodes, at the bottom, as shown in the figure: <br><img src="https://habrastorage.org/getpro/habr/post_images/e35/b8e/5a8/e35b8e5a8538064b22082a4e5351574a.jpg" alt="Index structure"><br>  When you form a query on an indexed column, the query subsystem starts going up from the root node and gradually moves down through the intermediate nodes, with each layer of the intermediate level containing more detailed information about the data.  The query subsystem continues to move through the nodes of the index until it reaches the lowest level with the leaves of the index.  For example, if you are looking for the value 123 in the indexed column, then the query subsystem will first determine the page at the first intermediate level at the root level.  In this case, the first page indicates the value from 1 to 100, and the second from 101 to 200, thus the query subsystem will turn to the second page of this intermediate level.  Further it will be clarified that you should refer to the third page of the next intermediate level.  From here, the query subsystem reads at the lower level the value of the index itself.  The leaves of the index can contain both the data of the table itself, and just a pointer to the rows with data in the table, depending on the type of the index: clustered index or nonclustered. <br><br><h5>  Clustered index </h5><br>  A clustered index stores the actual data rows in the leaves of the index.  Returning to the previous example, this means that the data string associated with the key value of 123 will be stored in the index itself.  An important characteristic of a clustered index is that all values ‚Äã‚Äãare sorted in a specific order, either increasing or decreasing.  Thus, a table or view can have only one clustered index.  In addition, it should be noted that the data in the table is stored in a sorted form only if a clustered index is created on this table. <br>  A table that does not have a clustered index is called a heap. <br><br><h5>  Nonclustered index </h5><br>  Unlike a clustered index, the leaves of a nonclustered index contain only those columns ( <i>key</i> ) for which this index is determined, and also contains a pointer to rows with real data in the table.  This means that an additional operation is necessary for the subquery system to detect and obtain the required data.  The content of the data pointer depends on the way the data is stored: a clustered table or a heap.  If the pointer refers to a clustered table, then it leads to a clustered index, using which real data can be found.  If the pointer refers to a heap, then it leads to a specific identifier of the data string.  Nonclustered indexes cannot be sorted in contrast to clusterized ones, however you can create more than one nonclustered indexes on a table or view, up to 999. This does not mean that you should create as many indices as possible.  Indexes can both improve and degrade system performance.  In addition to the ability to create multiple nonclustered indexes, you can also include additional columns ( <i>included column</i> ) in your index: not only the value of the indexed columns themselves will be stored on the index leaves, but also the values ‚Äã‚Äãof these non-indexed additional columns.  This approach will allow you to bypass some of the restrictions imposed on the index.  For example, you can include a non-indexable column or bypass the restriction on the length of the index (900 bytes in most cases). <br><br><h3>  Types of indexes </h3><br>  In addition to the fact that the index can be either clustered or non-clustered, it is possible to further configure it as a composite index, a unique index or a covering index. <br><br><h5>  Composite index </h5><br>  Such an index may contain more than one column.  You can include up to 16 columns in the index, but their total length is limited to 900 bytes.  Both clustered and nonclustered indexes can be composite. <br><br><h5>  Unique index </h5><br>  Such an index ensures the uniqueness of each value in the indexed column.  If the index is composite, then uniqueness applies to all the columns in the index, but not to each individual column.  For example, if you create a unique index on the columns <i>NAME</i> and <i>NAME</i> , then the full name must be unique, but duplicates in the name or surname are possible separately. <br>  A unique index is automatically created when you define a column constraint: a primary key or a uniqueness constraint: <br><ul><li>  <i>Primary key</i> <br>  When you define a primary key constraint on one or more columns, then <i>SQL Server</i> automatically creates a unique clustered index if the clustered index has not been created previously (in this case, a unique non-clustered index is created on the primary key) </li><li>  <i>Uniqueness of values</i> <br>  When you define a unique constraint on values, then <i>SQL Server</i> automatically creates a unique nonclustered index.  You can specify that a unique clustered index be created if the clustered index has not yet been created on the table. </li></ul><br><br><h5>  Covering index </h5><br>  This index allows a specific query to immediately get all the necessary data from the leaves of the index without additional reference to the records of the table itself. <br><br><h3>  Index Design </h3><br>  How useful indexes can be, how carefully they should be designed.  Since indexes can take up considerable disk space, you don‚Äôt want to create indexes more than necessary.  In addition, indexes are automatically updated when the data row itself is updated, which can lead to additional resource overhead and performance degradation.  When designing indexes, several considerations regarding the database and its queries should be taken into account. <br><br><h5>  Database </h5><br>  As noted earlier, indexes can improve system performance, since  they provide the query subsystem in a fast way to locate data.  However, you should also take into account how often you are going to insert, update or delete data.  When you change data, the indexes should also be changed to reflect the corresponding actions on the data, which can significantly reduce system performance.  Consider the following guidelines when planning your indexing strategy: <br><ul><li>  For tables that are frequently updated, use as few indices as possible. </li><li>  If the table contains a large amount of data, but their changes are minor, then use as many indices as necessary to improve the performance of your queries.  However, think carefully before using indexes on small tables, since  perhaps using index search may take longer than scanning all the rows. </li><li>  For clustered indexes, try to use as short fields as possible.  Best practice is to use a clustered index on columns with unique values ‚Äã‚Äãand not allowing the use of NULL.  This is why the primary key is often used as a clustered index. </li><li>  The uniqueness of the values ‚Äã‚Äãin the column affects the performance of the index.  In general, the more duplicates you have in a column, the worse the index works.  On the other hand, the more unique values, the higher the performance index.  When possible use a unique index. </li><li>  For a composite index, take into account the order of the columns in the index.  Columns that are used in <i>WHERE</i> expressions (for example, <i>WHERE FirstName = 'Charlie'</i> ) must be in the index first.  Subsequent columns should be listed taking into account the uniqueness of their values ‚Äã‚Äã(the columns with the highest number of unique values ‚Äã‚Äãgo first). </li><li>  You can also specify an index on the calculated columns, if they meet certain requirements.  For example, an expression that is used to get the value of a column must be deterministic (always return the same result for a given set of input parameters). </li></ul><br><br><h5>  Database Requests </h5><br>  Another consideration to consider when designing indexes is what queries are being performed on the database.  As mentioned earlier, you should consider how often data changes.  Additionally, the following principles should be used: <br><ul><li>  Try to insert or modify as many lines in a single query as possible, rather than do it in several single queries. </li><li>  Create a nonclustered index on the columns that are often used in your queries as search conditions in <i>WHERE</i> and joins in <i>JOINs</i> . </li><li>  Consider indexing the columns used in the string search queries for exact match values. </li></ul><br><br><hr><br>  And now, actually: <a name="subj"></a><br><br><h1>  14 index questions in SQL Server that you feel shy about asking </h1><br>  <a href="https://habr.com/ru/post/247373/">Why can't a table have two clustered indexes?</a> <br>  <a href="https://habr.com/ru/post/247373/">If a clustered table has many advantages, then why use a bunch?</a> <br>  <a href="https://habr.com/ru/post/247373/">How to change the default index fill factor?</a> <br>  <a href="https://habr.com/ru/post/247373/">Is it possible to create a clustered index on a column containing duplicates?</a> <br>  <a href="https://habr.com/ru/post/247373/">How is the table stored if a clustered index was not created?</a> <br>  <a href="https://habr.com/ru/post/247373/">What is the relationship between uniqueness constraints and the primary key with the table indexes?</a> <br>  <a href="https://habr.com/ru/post/247373/">Why in SQL Server are clustered and non-clustered indexes called a balanced tree?</a> <br>  <a href="https://habr.com/ru/post/247373/">How can an index improve query performance in general if you have to go through all these index nodes?</a> <br>  <a href="https://habr.com/ru/post/247373/">If indexes are so wonderful, why not just create them on each column?</a> <br>  <a href="https://habr.com/ru/post/247373/">Is it necessary to create a clustered index on a column with a primary key?</a> <br>  <a href="https://habr.com/ru/post/247373/">So what if you indexed a view, will it still be a view?</a> <br>  <a href="https://habr.com/ru/post/247373/">Why use a covering index instead of a composite index?</a> <br>  <a href="https://habr.com/ru/post/247373/">Does the number of duplicates in the key column matter?</a> <br>  <a href="https://habr.com/ru/post/247373/">Is it possible to create a nonclustered index only for a specific subset of the key column data?</a> <br><br><a name="01"></a><br><h3>  Why can't a table have two clustered indexes? </h3><br>  Want a short answer?  The clustered index is the table.  When you create a clustered index on a table, the storage subsystem sorts all the rows in the table in ascending or descending order, according to the index definition.  A clustered index is not a separate entity like other indexes, but a mechanism for sorting data in a table and facilitating quick access to data rows. <br>  Imagine that you have a table containing a history of sales operations.  The Sales table includes information such as an order ID, product position in the order, product number, quantity, product number and order date, etc.  You create a clustered index on the <i>OrderID</i> and <i>LineID columns</i> , sorted in ascending order, as shown in the following <i>T-SQL</i> code: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> CLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_oriderid_lineid <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.Sales(OrderID, LineID);</code> </pre> <br>  When you run this script, all rows in the table will be physically sorted first by the OrderID column and then by the LineID, but the data itself will remain in a single logical block in the table.  For this reason, you cannot create two clustered indexes.  There can be only one table with the same data and this table can be sorted only once in a certain order. <br><br><a name="02"></a><br><h3>  If a clustered table has many advantages, then why use a bunch? </h3><br>  You're right.  Clustered tables are different and most of your queries will execute better to tables with a clustered index.  But in some cases, you may want to leave the tables in their natural, original state, i.e.  in the form of a heap, and create only nonclustered indexes to maintain the health of your queries. <br>  A heap, as you remember, stores data in a random order.  Typically, the storage subsystem adds data to the table in the order in which they are inserted, but the subsystem also likes to move rows for more efficient storage.  As a result, you have no chance to predict in what order the data will be stored. <br>  If the query engine must find the data without the benefits of a nonclustered index, it will do a full table scan to find the rows it needs.  On very small tables, this is usually not a problem, but as soon as the heap grows in size, performance drops rapidly.  Of course, a nonclustered index can help by using a pointer to the file, the page and the row where the necessary data is stored - this is usually a much better alternative to scanning the table.  But even in this case, it is difficult to compare with the advantages of a clustered index when considering query performance. <br>  However, a bunch can help improve performance in certain situations.  Consider a table with a large number of inserts, but rare updates or deletion of data.  For example, a table that stores a log is primarily used to insert values ‚Äã‚Äãuntil it is archived.  In the heap, you will not see page splitting and data fragmentation, as is the case with a clustered index, because rows are simply added to the end of the heap.  Too much page separation can have a significant impact on performance and in a not very good way.  In general, the heap allows you to insert data relatively painlessly and you do not have to struggle with the overhead of storage and maintenance, as is the case with a clustered index. <br>  But the lack of updating and deleting data should not be considered as the only reason.  Data sampling is also an important factor.  For example, you should not use a heap if you frequently perform data range queries or the requested data often must be sorted or grouped. <br>  All this means that you should consider using a heap only when working with very small tables or your entire interaction with the table is limited to inserting data and your queries are extremely simple (and you still use nonclustered indexes).  Otherwise, hold a well-designed clustered index, for example, defined on a simple incremental key field, as a widely used column with <i>IDENTITY</i> . <br><br><a name="03"></a><br><h3>  How to change the default index fill factor? </h3><br>  Changing the default index fill factor is one thing.  Understanding how the default factor works is another.  But first, a couple of steps back.  The fill factor of the index determines the amount of space on the page for storing the index at the lower level (leaf level) before starting to fill a new page.  For example, if the coefficient is set to 90, then with growth the index will take 90% on a page, and then go to the next page. <br>  By default, the value of the index fill factor in <i>SQL Server</i> is 0, which is equivalent to a value of 100. As a result, all new indexes automatically inherit this setting unless you specifically specify a value other than the system default for the system or change the default behavior.  You can use <i>SQL Server Management Studio</i> to adjust the default value or run the <i>sp_configure</i> system saved procedure.  For example, the following set of <i>T-SQL</i> commands sets the value of the coefficient equal to 90 (you must first switch to the advanced settings mode): <br><pre> <code class="sql hljs">EXEC sp_configure '<span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">advanced</span></span> options<span class="hljs-string"><span class="hljs-string">', 1; GO RECONFIGURE; GO EXEC sp_configure '</span></span>fill factor<span class="hljs-string"><span class="hljs-string">', 90; GO RECONFIGURE; GO</span></span></code> </pre> <br>  After changing the index fill factor, you must restart the <i>SQL Server</i> service.  Now you can check the set value by running sp_configure without the specified second argument: <br><pre> <code class="sql hljs">EXEC sp_configure 'fill factor' GO</code> </pre> <br>  This command should return a value of 90. As a result, all newly created indexes will use this value.  You can check this by creating an index and querying the fill factor value: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> AdventureWorks2012; <span class="hljs-comment"><span class="hljs-comment">--    GO CREATE NONCLUSTERED INDEX ix_people_lastname ON Person.Person(LastName); GO SELECT fill_factor FROM sys.indexes WHERE object_id = object_id('Person.Person') AND name='ix_people_lastname';</span></span></code> </pre> <br>  In this example, we created a nonclustered index in the <i>Person</i> table in the <i>AdventureWorks2012</i> database.  After creating the index, we can get the fill factor value from the sys.indexes system tables.  The request should return 90. <br>  However, imagine that we deleted the index and created it again, but now we have indicated a specific fill factor value: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> NONCLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_people_lastname <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Person.Person(LastName) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">80</span></span>); GO <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fill_factor <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.indexes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> object_id = object_id(<span class="hljs-string"><span class="hljs-string">'Person.Person'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>=<span class="hljs-string"><span class="hljs-string">'ix_people_lastname'</span></span>;</code> </pre> <br>  This time, we added the <i>WITH</i> statement and the <i>fillfactor</i> option for our <i>CREATE INDEX</i> index creation operation and set the value to 80. The <i>SELECT statement</i> now returns the corresponding value. <br>  Until now, everything was pretty straightforward.  Where you can really get stuck in this whole process is when you create an index that uses the default coefficient value, meaning that you know this value.  For example, someone clumsily picks at the server settings and he is so upset that he sets the index fill factor to 20. Meanwhile, you continue to create indexes, assuming a default value of 0. Unfortunately, you have no way to know the value of the coefficient as long as you do not create an index, then check the value, as we did in our examples.  Otherwise, you will have to wait for the moment when the query performance will drop so much that you begin to suspect something. <br>  Another problem you should keep in mind is rebuilding indexes.  As with the creation of an index, you can specify the value of the index fill factor when you rebuild it.  However, unlike the index creation command, the restructuring does not use the default server settings, even though it may seem so.  Even more, if you do not specifically specify the value of the index fill factor, <i>SQL Server</i> will use the value of the coefficient with which this index existed prior to its restructuring.  For example, the following <i>ALTER INDEX</i> operation rebuilds the index we just created: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_people_lastname <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Person.Person <span class="hljs-keyword"><span class="hljs-keyword">REBUILD</span></span>; GO <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fill_factor <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.indexes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> object_id = object_id(<span class="hljs-string"><span class="hljs-string">'Person.Person'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>=<span class="hljs-string"><span class="hljs-string">'ix_people_lastname'</span></span>;</code> </pre> <br>  When we check the value of the fill factor, we get a value of 80, because we specified it during the last creation of the index.  The default value is ignored. <br>  As you can see, changing the value of the index fill factor is not that difficult.  It is much more difficult to know the current value and understand when it is applied.  If you always specifically specify the ratio when creating and rebuilding indexes, then you always know the specific result.  Is that you have to take care that someone else did not screw up in the server settings again, causing the restructuring of all indexes with a ridiculously low index fill factor. <br><br><a name="04"></a><br><h3>  Is it possible to create a clustered index on a column containing duplicates? </h3><br>  Yes and no.  Yes, you can create a clustered index on a key column containing duplicate values.  No, the value of the key column cannot remain in a state of uniqueness.  Let me explain.  If you create a non-unique clustered index (non-unique clustered index) on a column, the storage subsystem adds an integer value (uniquifier) ‚Äã‚Äãto the duplicate value to verify the uniqueness and, accordingly, to ensure the ability to identify each row in a clustered table. <br>  For example, you can decide to create in the table with customer data a clustered index on the <i>LastName</i> column storing the last name.  The column contains values ‚Äã‚Äãsuch as Franklin, Hancock, Washington and Smith.  Then you insert the values ‚Äã‚ÄãAdams, Hancock, Smith, and again Smith.  But the value of the key column must be unique, so the storage subsystem changes the value of duplicates so that they look something like this: Adams, Franklin, Hancock, Hancock1234, Washington, Smith, Smith4567 and Smith5678. <br>  At first glance, this approach seems normal, but the integer value increases the key size, which can be a problem with a large number of duplicates, and these values ‚Äã‚Äãwill become the basis of a nonclustered index or a foreign key reference.  For these reasons, you should always try to create unique clustered indexes whenever possible.  If this is not possible, then at least try to use columns with very high content of unique values. <br><br><a name="05"></a><br><h3>  How is the table stored if a clustered index was not created? </h3><br>  <i>SQL Server</i> supports two types of tables: clustered tables that have a clustered index and heap tables or simply heaps.  Unlike clustered tables, the data in the heap is not sorted in any way.  In essence, this is the jumble (pile) of data.  If you add a row to such a table, the storage subsystem simply adds it to the bottom of the page.  When the page is filled with data, they will be added to the new page.  In most cases, you will want to create a clustered index on a table in order to take advantage of the ability to sort and speed up queries (try to imagine finding a phone number in your address book that is not sorted by any principle).  However, if you decide not to create a clustered index, you can still create a nonclustered index at the heap.  In this case, each index line will have a pointer to the heap line.  The pointer includes the file ID, page number and line number of the data. <br><br><a name="06"></a><br><h3>  What is the relationship between uniqueness constraints and the primary key with the table indexes? </h3><br>  The primary key and the uniqueness constraint ensure that the values ‚Äã‚Äãin the column are unique.  You can create only one primary key for the table and it cannot contain <i>NULL</i> values.  You can create several constraints on the uniqueness of the value of the table and each of them can have a single entry with <i>NULL</i> . <br>  When you create a primary key, the storage subsystem also creates a unique clustered index, in case the already clustered index was not created.  However, you can override the default behavior and then a nonclustered index will be created.  If a clustered index exists when you create a primary key, a unique nonclustered index will be created. <br>  When you create a unique constraint, the storage subsystem creates a unique nonclustered index.  But you can specify the creation of a unique clustered index, if it was not created earlier. <br>  In general, the uniqueness constraint value and unique index are one and the same. <br><br><a name="07"></a><br><h3>  Why in SQL Server are clustered and non-clustered indexes called a balanced tree? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base indexes in SQL Server, clustered or non-clustered, are distributed across page sets ‚Äî index nodes. These pages are organized as a specific hierarchy with a tree structure called a balanced tree. At the top level is the root node, at the bottom, leaf nodes, with intermediate nodes between the top and bottom levels, as shown in the figure: </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/e35/b8e/5a8/e35b8e5a8538064b22082a4e5351574a.jpg" alt=" "><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The root node provides the main entry point for queries attempting to retrieve data through an index. Starting from this node, the query subsystem initiates the transition through the hierarchical structure down to the appropriate end node containing the data.</font></font><br>  , ,      ,     82.       ,      ,    1-100.    1-100     51-100,      76-100.    ,       ,     82.     ,             . <br><br><a name="08"></a><br><h3>       ,        ? </h3><br> -,     .             .  ,      ,        . <br>    ,    <i>SQL Server</i> (,    ). ,        <a href="http://msdn.microsoft.com/ru-ru/library/bb933866.aspx"> </a> .                    ( ,         ). ,     ,    ,          (),         (). <br>    ,   <i>SQL Server</i>             ,   .        ,        ,          ,    ,        . ,                . <br><br><a name="09"></a><br><h3>    ,          ? </h3><br>        .   ,       . ,    ,         <i>SELECT</i> ,        <i>INSERT</i> , <i>UPDATE</i>  <i>DELETE</i> ,     . <br>       <i>SELECT</i> ,    ,         .    ?   ,     ,   <i>UPDATE</i> . ,               ‚Äì   .        ,     ,      .  ,      ,  ,      ,         ‚Äì    ,     ,      ,      . <br>       <i>DELETE</i> .       ,           .   <i>INSERT</i> ,    :      ,           . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So consider the types of queries to your database when thinking about what type of indexes and how much should be created. </font><font style="vertical-align: inherit;">No longer means better. </font><font style="vertical-align: inherit;">Before adding a new index to a table, calculate the cost of not only basic queries, but also the amount of disk space occupied, the cost of maintaining health and indexes, which can lead to a domino effect for other operations. </font><font style="vertical-align: inherit;">Your index design strategy is one of the most important aspects of implementation and should include many considerations: from the size of the index, the number of unique values, to the type of index supported by the query.</font></font><br><br><a name="10"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is it necessary to create a clustered index on a column with a primary key? </font></font></h3><br>        ,   .  ,                 ,    ,      ,       ,      .   ,   ,         ,       . <br>               ,    .          . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The primary key of a table can be a good choice, because it uniquely identifies each row in the tables without the need to add additional data. In some cases, the best choice would be a surrogate primary key, which has not only a sign of uniqueness, but also small size, and whose values ‚Äã‚Äãincrease sequentially, which makes nonclustered indexes based on this value more efficient. The query optimizer also likes this combination of a clustered index and a primary key, because the joining of tables is faster than connecting in a different way that does not use the primary key and the associated clustered index. As I said, this is a marriage made in heaven.</font></font><br>   , , ,           :        ,             .              ,        .         ,      ,     .          ,       ,        ,  .      ,   .   ,     . <br><br><a name="11"></a><br><h3>     ,   -  ? </h3><br>  ‚Äì   ,       .  ,   ,      ,       .     ,         ,       ,      ,     ,      . <br>     ( ),       . ,   ,      <i>SELECT</i> ,    .      .         ,      ,   .  ,      ,      ( ,         ,     ).   ,    ‚Äî   ,      ,    . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before you can create an index on a view, it must meet several restrictions. </font><font style="vertical-align: inherit;">For example, a view can refer only to base tables, but not to other views, and these tables must be in the same database. </font><font style="vertical-align: inherit;">There are actually many other limitations, so be sure to consult the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> documentation </font><font style="vertical-align: inherit;">for all the dirty details.</font></font><br><br><a name="12"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why use a covering index instead of a composite index? </font></font></h3><br> -,  ,      .      ,      .           ,   ,       ,   ,           .  , ,      ,      ,       . <br>   ,     ,         ,    .      , ..     (          ).         .           ,           . <br>       .     ,        .  , ,        <i>OrderID</i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OrderDate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sales</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> table </font><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> OrderID, OrderDate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> OrderID = <span class="hljs-number"><span class="hljs-number">12345</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can create a composite nonclustered index on both columns, but the OrderDate column only adds to the overhead of maintaining the index, but it still cannot serve as a particularly useful key column. </font><font style="vertical-align: inherit;">The best solution would be to create a covering index with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OrderID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> key column </font><font style="vertical-align: inherit;">and the optional </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OrderDate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> column </font><i><font style="vertical-align: inherit;">included</font></i><font style="vertical-align: inherit;"> :</font></font><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> NONCLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_orderid <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.Sales(OrderID) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (OrderDate);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In doing so, you avoid the drawbacks that arise when indexing redundant columns, while at the same time retaining the advantages of storing data on the leaves when performing queries. </font><font style="vertical-align: inherit;">The included column is not part of the key, but the data is stored on the end node, the index sheet. </font><font style="vertical-align: inherit;">This can improve query performance without incurring any additional costs. </font><font style="vertical-align: inherit;">In addition, the columns included in the covering index are less constrained than the key columns of the index.</font></font><br><br><a name="13"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Does the number of duplicates in the key column matter? </font></font></h3><br>    ,          .   :       ,   . <br>      ,         .       ,         .  ,        <i>FirstName</i>  <i>LastName</i> ,       John   Doe,         John Doe,      John Doe. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The coefficient of uniqueness of key column values ‚Äã‚Äãis called index selectivity. </font><font style="vertical-align: inherit;">The more unique values, the higher the selectivity: the unique index has the highest possible selectivity. </font><font style="vertical-align: inherit;">The query subsystem is very fond of columns with a high selectivity value, especially if these columns participate in the WHERE selection conditions of your most frequently performed queries. </font><font style="vertical-align: inherit;">The higher the index selectivity, the faster the query subsystem can reduce the size of the resulting data set. </font><font style="vertical-align: inherit;">The downside, of course, is that columns with a relatively small number of unique values ‚Äã‚Äãare rarely good candidates for indexing.</font></font><br><br><a name="14"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is it possible to create a nonclustered index only for a specific subset of the key column data? </font></font></h3><br>  ,          . ,         ,   ,       .     ,   ¬´  ¬ª  ,  ,    <i>SQL Server 2008</i> ,       ,      .       , ..       ,  , ,    ‚Äî       .             .         . <br>  ,    .   <i>CREATE INDEX</i>     <i>WHERE</i>  .  ,       ,  NULL,    : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> NONCLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_trackingnumber <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Sales.SalesOrderDetail(CarrierTrackingNumber) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> CarrierTrackingNumber <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  , ,   ,      .   , .. <i>SQL Server</i>      , ,       ,     . <br> ,  ,         . ,     ,            .       -.      . <br><br><hr><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text">               <a href="https://www.simple-talk.com/sql/">SimpleTalk</a>  <i>RedGate</i> . <br>        . <br>        <i>RedGate</i> ,    . <br><br> <b>  ,       </b> <br>        (   <i>kindle</i>    <i>Amazon</i> ): <br><table><tbody><tr><td><img src="https://habrastorage.org/files/937/4ce/178/9374ce17861349768d0a8086f5db531d.JPG"></td><td> <a href="https://www.amazon.com/Microsoft-Server-Fundamentals-Developer-Reference-ebook/dp/B00JDMPI0I/ref%3Das_sl_pc_ss_til%3Ftag%3Dhobuon-20%26linkCode%3Dw01%26linkId%3D6D2REUVQOAIR43YZ%26creativeASIN%3DB00JDMPI0I">Microsoft SQL Server 2012 T-SQL Fundamentals (Developer Reference)</a> <br> Author Itzik Ben-Gan <br> Publication Date: July 15, 2012 <br> ,   ,        . <br>        ,      </td></tr><tr><td><img src="https://habrastorage.org/files/228/df1/63b/228df163b53f493dbbf904c95cc30da7.JPG"></td><td> <a href="https://www.amazon.com/Server-Execution-Plans-Grant-Fritchey-ebook/dp/B00CXWRFQA/ref%3Das_sl_pc_ss_til%3Ftag%3Dhobuon-20%26linkCode%3Dw01%26linkId%3DPT3GVP6URN3NYSIZ%26creativeASIN%3DB00CXWRFQA">SQL Server Execution Plans</a> <br> Author Grant Fritchey <br> Publication Date: May 21, 2013 <br>           . <br> <a href="http://habrahabr.ru/users/gradea/" class="user_link">GraDea</a> <a href="http://habrahabr.ru/post/247373/"></a> ,    <a href="http://www.red-gate.com/community/books/sql-server-execution-plans-ed-2"></a> pdf   <i>RedGate</i> <br></td></tr><tr><td><img src="https://habrastorage.org/files/9e9/0c2/acd/9e90c2acd34d4e7eb961dedb89d0c7ca.JPG"></td><td> <a href="https://www.amazon.com/SQL-Server-Query-Performance-Tuning-ebook/dp/B00LPDV9V0/ref%3Das_sl_pc_ss_til%3Ftag%3Dhobuon-20%26linkCode%3Dw01%26linkId%3D3XXCT5ZFC62GKYFQ%26creativeASIN%3DB00LPDV9V0">SQL Server Query Performance Tuning</a> <br> Author Grant Fritchey <br> Publication Date: September 3, 2014 <br>                   . <br></td></tr></tbody></table><br> ,         . <br>  ,    <a href="http://www.amazon.com/gp/most-wished-for/books/6133987011/%3Fie%3DUTF8%26camp%3D1789%26creative%3D390957%26linkCode%3Dur2%26tag%3Dhobuon-20%26linkId%3DDZLD6Q6Q2JUYVT3Z">    SQL Server</a>   . <br>        . , ,   ! <br>             (upd: ,   ). </div></div></div><p>Source: <a href="https://habr.com/ru/post/247373/">https://habr.com/ru/post/247373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247353/index.html">IT distribution in Europe or how we started our business - Part 3</a></li>
<li><a href="../247355/index.html">Upgrade SNMP on Huawei and H3C devices</a></li>
<li><a href="../247363/index.html">Programming Philosophy 2 - Myth and Language</a></li>
<li><a href="../247365/index.html">Processing the structure of the list of basic types</a></li>
<li><a href="../247367/index.html">58 signs of a good interface</a></li>
<li><a href="../247375/index.html">Free application promotion + results</a></li>
<li><a href="../247377/index.html">Apple fixes an important iCloud vulnerability</a></li>
<li><a href="../247379/index.html">On automatic differentiation, Newton's method and solution of SLAE on Delphi. Part 1</a></li>
<li><a href="../247381/index.html">Waterban, PlanTrack, GtkSharp and other funny phrases - a couple of thoughts about why you should make a decision on UE</a></li>
<li><a href="../247385/index.html">Fourier transform in action: accurate signal frequency determination and note highlighting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>