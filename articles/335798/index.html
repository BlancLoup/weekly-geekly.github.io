<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What a job scheduler can do in Postgres Pro</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scheduler tasks (scheduler) is not at all times considered a mandatory tool in the world of databases. Everything depended on the purpose and origin o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What a job scheduler can do in Postgres Pro</h1><div class="post__text post__text-html js-mediator-article">  Scheduler tasks (scheduler) is not at all times considered a mandatory tool in the world of databases.  Everything depended on the purpose and origin of the DBMS.  It is absolutely impossible to imagine classic commercial DBMS (Oracle, DB2, MS SQL) without a scheduler.  On the other hand, it is difficult to imagine a potential MongoDB user who refuses to choose this trendy NoSQL-DBMS due to the lack of a scheduler.  (By the way, the term ‚Äútask scheduler‚Äù is used in the Russian context of a DBMS to distinguish it from the query planner - query planner, but for brevity we will call it here as a planner). <br><br>  PostgreSQL, being an Open Source and having absorbed the traditions of the DIY community (‚Äúdo it yourself‚Äù), nowadays regularly claims to be at least a deputy commercial DBMS.  From this it automatically follows that PostgreSQL simply must have a scheduler, and that this scheduler should be convenient for the database administrator and the user. <a name="habracut"></a>  And that it is desirable to reproduce the full functionality of commercial DBMS, although it would be nice to add something of your own. <br><br>  The need for a scheduler is most obviously manifested when working with a base in industrial operation.  To the developer, who was assigned a server to experiment with the database, the scheduler, in general, is useless: if necessary, he himself will plan all the necessary operations using OS tools (cron or at in Unix).  But to the working base of his serious company will not let a gun shot.  There is also an important administrative nuance, that is, no longer a nuance, but a serious, if not decisive, reason: the database administrator and the sysadmin are not just different people with different tasks.  It is not excluded that they belong to different divisions of the company, and, maybe, even sit on different floors.  Ideally, the database administrator maintains its viability and monitors its evolution, and the sysadmin‚Äôs area of ‚Äã‚Äãresponsibility maintains the viability of the OS and network. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consequently, the base administrator must have a tool to perform the necessary set of possible jobs on the server.  It is not for nothing that <i>the Oracle Scheduler</i> materials say that <i>‚ÄúOracle Scheduler eliminates the need to use OS-specific task schedulers (cron, at) when building a database-centric application.‚Äù</i>  That is, the admin database can do everything, especially since it is difficult to imagine an Oracle administrator who is not oriented in the OS mechanisms.  He does not have to run to the sysadmin or write letters to him every time when routine operations by means of the OS are required. <br><br>  Here are the scheduler requirements that are typical for commercial databases, such as Oracle, DB2, MS SQL: <br><br>  Planner should be able to <br><br><ul><li>  run the work on schedule </li><li>  supervise the execution of work, be able to shoot tasks, if necessary, </li><li>  run tasks in a limited period of time (in the window), </li><li>  build a sequence of tasks (the next one starts to run after the previous one is completed), </li><li>  be able to perform multiple queries in a single transaction, </li><li>  a task defined in one DB, run on several, </li><li>  use the (basic) features of the OS, </li><li>  notify the administrator if any tasks from the schedule have not been completed, </li><li>  perform one-time tasks. </li></ul><br>  The last point seems to be not obvious: there are quite a few other, regular means besides the scheduler, capable of running one-time tasks.  But this is not a completely normal execution mode.  For example, the detached job mode: we are talking about a task, which seems to be disconnected (temporarily or permanently) from the process that caused it.  Having done the work, the disconnected process can again contact the process that started it (by sending a signal of successful or unsuccessful completion) to it, report the result to it or write the result (to a file or database table).  Some DBMS schedulers are able to stop and start the DBMS itself (we did not set such a task). <br><br><h2>  PostgreSQL and its agent </h2><br>  You can solve the tasks in different ways: ‚Äúoutside‚Äù and ‚Äúinside‚Äù of the DBMS itself.  The most serious attempt to make a full-featured scheduler is pgAgent, distributed with pgAdmin III / IV.  In the commercial version ‚Äî in the EnterpriseDB distribution ‚Äî it is integrated into the pgAdmin graphical user interface and can be used cross-platform. <br><br>  pgAgent can: <br><br><ul><li>  run tasks </li><li>  run a sequence of tasks consisting of SQL scripts (including on different databases) and / or shell / batch scripts, </li><li>  set non-working windows (for example, DO NOT perform some action on weekends). </li></ul><br>  This scheduler works as a PostgreSQL extension, but does not execute tasks ‚Äúinside‚Äù the DBMS, but creating its own, ‚Äúexternal‚Äù daemons. <br><br>  There are drawbacks to this approach.  Among them are important: <br><br>  <i>All tasks started by pgAgent will be executed with the rights of the user who started the agent.</i>  <i>SQL queries will be executed with the rights of the user connected to the database.</i>  <i>The shell scripts will be executed with the rights of the user on whose behalf the daemon (or the Windows service) pgAgent is running.</i>  <i>Therefore, for security, you will have to control users who can create and run tasks.</i>  <i>In addition, the password cannot be included in the connection string (connection string), since in Unix it will be visible in the output of the ps command and in the database startup script, and in Windows it will be stored in the registry as unencrypted text.</i> <br>  (from <a href="https://www.pgadmin.org/docs/pgadmin4/dev/using_pgagent.html">pgAdmin 4 1.6 documentation</a> ). <br><br>  In this solution, pgAgent polls the base server at specified intervals (since the information about the jobs is stored in the base tables): whether there are any jobs available.  Therefore, if for some reason the agent does not work at the moment when the work should start, it will not start until the agent starts working. <br><br>  In addition, any connection to the server consumes a pool of possible connections, the maximum number of which is determined by the configuration parameter max_connections.  If an agent spawns many processes, and the administrator has not shown proper vigilance, this can be a problem. <br><br>  Creating a fully integrated scheduler in the DBMS (‚Äúinside‚Äù the DBMS) eliminates these problems.  And it is especially convenient for those users who are accustomed to minimalist interfaces for accessing the database, such as psql. <br><br><h2>  pgpro_scheduler and its schedule </h2><br>  At the end of 2016, Postgres Professional started to create their own scheduler, which is fully integrated into the database.  Now it is used by customers and is documented in detail.  The scheduler was created as an extension (optional module), called pgpro_scheduler, and comes as part of the commercial version of Postgres Pro Enterprise, starting with the first version.  Developer - <i>Vladimir Ershov.</i> <br><br>  When installing it in the DBMS configuration files, you need to remember to include it in the configuration file <code>shared_preload_libraries = 'pgpro_scheduler'</code> .  Having installed the extension <code>( <font color="#a020f0">CREATE EXTENSION</font> pgpro_scheduler;)</code> , you must enable it in a line in the configuration file (schedule.enabled = on) and let it list which databases fall under the action of the scheduler (for example <code>schedule.database = 'database1,database2'</code> ). <br><br>  From the very beginning, it was decided to create pgpro_scheduler in a modern style, organic for the company - with a configuration record in JSON.  This is convenient, for example, for web services creators who can integrate the scheduler into their applications.  But for those who do not want to use JSON, there are functions that take parameters as ordinary variables.  The scheduler comes with the distribution of the DBMS and it is cross-platform. <br><br>  pgpro_scheduler does not start external daemons or services, but creates child processes in relation to the postmaster background background processes.  The number of ‚Äúworkers‚Äù is set in the pgpro_scheduler configuration, but is limited to the overall server configuration.  Actually, the most usual SQL commands come to the scheduler input, without any restrictions, so you can run functions in any available Postgres language.  If several SQL queries are included in the JSON structure, they can (if you follow a certain syntax) be executed inside a single transaction: <br><br> <code><font color="#a020f0">SELECT</font> schedule.create_job( <font color="#8b2252">'{"commands": [ "SELECT 1", "SELECT 2", "SELECT 3"], "cron": "23 23 */2 * *" }'</font> );</code> <br> <br>  this is equivalent to: <br><br> <code><font color="#a020f0">SELECT</font> schedule.create_job( <font color="#8b2252">'{"commands": [ "SELECT 1", "SELECT 2", "SELECT 3"], "cron": "23 23 */2 * *","use_same_transaction": true}'</font> );</code> <br>  and if each request is in its own transaction, then: <br><br> <code><font color="#a020f0">SELECT</font> schedule.create_job( <font color="#8b2252">'{"commands": [ "SELECT 1", "SELECT 2", "SELECT 3" ], "cron": "23 23 */2 * *" }'</font> );</code>  - that is, without the last parameter, by default. <br><br>  For example, in the second command in the list, an error will occur (of course, in <code><font color="#a020f0">SELECT</font> 2</code> it is unlikely to occur, but let's imagine some dumb query).  In the case of execution in one transaction, all results will be rolled back, but in the scheduler's log a message will appear about the collapse of the second command.  The same message will appear in the case of execution of separate transactions, but the result of the first will be saved (the third transaction will not be executed). <br><br>  When pgpro_scheduler is started, a group of background workers with its own hierarchy always starts working: one worker, in the rank of supervisor scheduler, controls workers in the rank of database managers - one for each database specified in the configuration line.  Managers, in turn, control workers directly serving the tasks.  The supervisor and managers are fairly easy processes, so if the scheduler serves even dozens of bases, this does not affect the overall system load.  And then the workers are started in each database according to the needs in processing requests.  In sum, they must fit within the limitation of the max_worker_processes DBMS.  A group of teams for the instant execution of tasks uses resources differently, but more on that later. <br><br><img src="https://habrastorage.org/web/b62/984/118/b62984118cae4bf48c3a97aaa6a16b8c.jpg"><br>  <i>Fig.1 Basic mode of operation pgpro_scheduler</i> <br><br>  <code>pgpro_scheduler</code> is a Postgres extension.  Therefore, it is installed on a specific database.  This creates several system tables in the schedule scheme; by default, they are not visible to the user.  The database now knows 2 new, special data types: cron_rec and cron_job, with which it will be possible to work through SQL queries.  There is a table-log, which does not duplicate the DBMS log.  Information about the success or failure of the task scheduler is available only through the functions of the extension pgpro_scheduler.  This is done so that one user of the scheduler does not know about the activities of another user of the scheduler.  Functions enable selective viewing of the log, starting from a specific date, for example: <br><br> <code><font color="#a020f0">SELECT</font> * <font color="#a020f0">from</font> schedule.get_user_log() <font color="#a020f0">WHERE</font> started &gt; now() - <font color="#228b22">INTERVAL</font> <font color="#8b2252">'1 day'</font> ;</code> <br> <br>  You can create a task using JSON using the function <code>schedule.create_job(data jsonb)</code> .  The only argument to this function is a JSONB object with the job information.  Examples will come next. <br><br>  This object may contain the following keys, some of which may be omitted: <br><br><ul><li>  name - the name of the task; </li><li>  node is the name of the node (in case of work in the multimaster architecture); </li><li>  command - a set of SQL queries to be executed, specified as an array; </li><li>  run_as is the user on whose behalf the commands will be executed; </li></ul><br>  You can choose from the types of representation of the schedule: for those who are accustomed to cron - a line in the style of crontab, which defines the schedule of execution.  But you can use the rule - then the schedule will be represented as a JSONB object (see description below).  Another option: date - a set of specific dates on which the execution of commands is scheduled.  They can be combined, but at least one option must be used.  It will look, for example, like this: <code>"cron":"55 7 * * *"</code> - from the example that can be seen below. <br>  In addition, there are still many useful parameters, which can be found in the <a href="https://postgrespro.ru/docs/postgresproee/9.6/pgpro-scheduler.html">documentation</a> .  Among them: <br><br><ul><li>  start_date and end_date - the beginning and end of the interval in which the execution of the scheduled command is possible (maybe NULL); </li><li>  max_instances - the maximum number of job instances that can be run simultaneously.  1 by default; </li><li>  max_run_time - determines the maximum duration of the task.  It is specified in the interval type format.  If this field is NULL or not specified, the time is not limited.  The default is NULL; </li><li>  onrollback is a SQL query that will be executed when the main transaction fails.  By default, the query is not defined; </li><li>  next_time_statement - SQL query that will be executed to calculate the next task start time.  It must return a value in the format timestamp with time zone; </li></ul><br>  The schedule can be specified as a crontab-style string (cron key) or as a JSONB object (rule key).  They may contain the following keys: <br><br><ul><li>  minutes - minutes;  Array of integers in the range 0 ... 59; </li><li>  hours - hours;  Array of integers in the range 0 ... 23; </li><li>  days - days of the month;  array of integers in the range of 1 ... 31; </li><li>  months - months;  array of integers in the range 1 ... 12; </li><li>  wdays - days of the week;  Array of integers in the range 0 ... 6 (0 - Sunday); </li><li>  onstart is an integer value of 0 or 1;  if this value is 1, the task will be executed only once when the scheduler is started. </li></ul><br>  An assignment can also be scheduled for a specific date or set of dates.  That is, in principle, the task can be one-time, although for one-time tasks you can use the special one-time job mode with other function calls. <br><br><img src="https://habrastorage.org/web/cc4/51b/eee/cc451beeedf544a09979432f4d0d3bf4.jpg"><br>  <i>Scheme 1. Scheduler Hierarchy Process</i> <br><br>  The <code>next_time_statement</code> field may contain a SQL query that will be executed after the main transaction to calculate the next run time.  If this key is defined, the time of the first start of the task will be calculated according to the methods described above, but the next start will be scheduled at the time that this request returns.  This request should return an entry containing in the first field a value of type timestamp with time zone.  If the return value is of a different type or an error occurs during the execution of the query, the task is marked as failed and its further execution is canceled. <br><br>  This query will be executed under any state of completion of the main transaction.  You can get the transaction completion status in it from the Postgres Pro Enterprise <code>schedule.transaction_state:</code> <br><br><ul><li>  success - transaction completed successfully </li><li>  failure - the transaction failed </li></ul><br>  As can be seen even from the abbreviated description, the range of possibilities is rich.  In total, there are about 40 functions that work with the pgpro_scheduler application. You can create tasks, cancel them, view their status, filter information about tasks by users and other criteria. <br><br><h2>  Once, but out of turn </h2><br>  As mentioned, there is still an important class of tasks for the scheduler: the formation of separate, non-periodic tasks using the one-time job mechanism.  If the run_after parameter is not specified, then in this mode the scheduler is able to start executing the task immediately at the moment of arrival - up to the polling time interval of the table to which the task is written.  In the current implementation, the interval is fixed and equal to 1 second.  Background workers start in advance and wait for jobs to appear "under steam", rather than starting as needed, as in schedule mode.  Their number is defined by the schedule.max_parallel_workers parameter.  The corresponding number of requests can be processed in parallel. <br><br><img src="https://habrastorage.org/web/715/e30/f06/715e30f064d7476684d8904c8601d599.jpg"><br>  <i>Fig.2 One-time job mode.</i> <br><br>  The main function that forms the task is as follows: <br><br> <code>schedule.submit_job(query <font color="#228b22">text</font> [options...])</code> <br> <br>  This function has, in accordance with its specificity, which was at the beginning, fine tuning.  The max_duration parameter sets the maximum execution time.  If the work is not done in the allotted time, the task is removed (by default, the execution time is unlimited).  max_wait_interval does not refer to the running time, but to the waiting time to start working.  If the DBMS does not find ‚Äúworkers‚Äù within this period of time ready to take on execution, the task is removed.  An interesting parameter depends_on specifies an array of work (in one-time mode), after which you have to start this work. <br><br>  A useful parameter - <code>resubmit_limit</code> - sets the maximum number of restart attempts.  Let's say a task runs a procedure that starts sending a message to the mail.  The mail server, however, is not in a hurry to receive it, and after a timeout or even because of a lack of communication, the process ends in order to resume again immediately or after a specified time.  Without restrictions in resubmit_limit attempts will continue until the bitter end. <br><br><h2>  Condiments and desserts </h2><br>  At the beginning, detached jobs were mentioned.  In the current version, the process that started the one-time task is dragging its existence in anticipation of the result.  The overhead of the background worker‚Äôs work is small, it makes no sense to stop it.  It is important that the execution or non-performance of the task will not pass without a trace, we can learn about its fate from a request to the scheduler log, available to us, and not just to the database administrator.  This is not the only way to track down a transaction even if it is rolled back: Postgres Pro Enterprise has an autonomous transaction mechanism that can be used for the same purpose.  But in this case, the result will be recorded in the DBMS log, and not in the ‚Äúpersonal‚Äù log of the user running the scheduler. <br><br>  If the scheduler user needs to schedule or simply run some OS commands with the rights that are available to him inside the OS, he can easily do this through the scheduler, using the programming languages ‚Äã‚Äãavailable to him.  Suppose he decided to use untrusted Perl: <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">LANGUAGE</font> plperlu;</code> <br> <br>  After that, you can write in the usual request such as, for example, the function: <br><br> <code>DO <font color="#a020f0">LANGUAGE</font> <font color="#8b2252">'plperlu'</font> $$ <br> <font color="#a020f0">system</font> ( <font color="#8b2252">'cat /etc/postgresql/9.6/main/pg_hba.conf &gt; $HOME/conf_tmp'</font> ); <br> $$;</code> <br> <br><h2>  Life example: 1. storing irrelevant logs </h2><br><br>  To begin with, a simplified example of managing sections (partitions) from the scheduler.  Suppose we broke the logs of visiting the site into sections by month.  We do not want to store on the two-year freshness and younger sections on expensive fast drives, and dump the rest into another tablespace corresponding to other, cheaper media, while maintaining full-featured search and other operations on all the logs (with a table that is not divided into sections). impossible).  We use convenient section management functions in the pg_pathman extension.  The postgresql.conf file should contain the line shared_preload_libraries = 'pg_pathman, pgpro_scheduler'. <br><br> <code><font color="#a020f0">CREATE</font> EXTENSION pg_pathman; <font color="#a020f0">CREATE</font> EXTENSION pgpro_scheduler;</code> <br> <br>  Configuring: <br><br> <code><font color="#a020f0">ALTER</font> <font color="#a020f0">SYSTEM</font> <font color="#a020f0">SET</font> schedule.enabled = <font color="#a020f0">on</font> ; <br> <font color="#a020f0">ALTER</font> <font color="#a020f0">SYSTEM</font> <font color="#a020f0">SET</font> schedule.database = <font color="#8b2252">'test_db'</font> ;</code> <br> <br>  Baz can be several.  In this case, they are listed separated by commas inside quotes. <br> <code><font color="#a020f0">SELECT</font> pg_reload_conf();</code>  - reread configuration changes without restarting Postgres. <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">TABLE</font> <font color="#0000ff">partitioned_log</font> (id <font color="#228b22">int</font> <font color="#a020f0">NOT</font> <font color="#a020f0">NULL</font> , visit <font color="#228b22">timestamp</font> <font color="#a020f0">NOT</font> <font color="#a020f0">NULL</font> );</code> <br> <br>  We have just created a parent table that we will split into sections.  This is a tribute to the traditional PostgreSQL syntax based on table inheritance.  Now, in Postgres Pro Enterprise, you can create sections not in 2 stages (first empty parent table, then specify sections), but immediately define sections.  In this case, we will use the convenient pg_pathman function, which allows you to first set the approximate number of sections.  As you fill the necessary sections will be created automatically: <br><br> <code><font color="#a020f0">SELECT</font> create_range_partitions( <font color="#8b2252">'partitioned_log'</font> , <font color="#8b2252">'visit'</font> , <font color="#8b2252">'2015-01-01'</font> :: <font color="#228b22">date</font> , <font color="#8b2252">'1 month'</font> :: <font color="#228b22">interval</font> , 10);</code> <br> <br>  We set 10 initial sections, one per month, starting from 1 January.  2015. Fill them with some amount of data. <br><br> <code><font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> partitioned_log <font color="#a020f0">SELECT</font> i, <font color="#8b2252">'2015-01-01'</font> :: <font color="#228b22">date</font> + 60*60*i*random():: <font color="#228b22">int</font> * <font color="#8b2252">'1 second'</font> :: <font color="#228b22">interval</font> visit <font color="#a020f0">FROM</font> generate_series(1,24*365) <font color="#a020f0">AS</font> g(i);</code> <br> <br>  You can monitor the number of sections as follows: <br><br> <code><font color="#a020f0">SELECT</font> <font color="#483d8b">count</font> (*) <font color="#a020f0">FROM</font> pathman_partition_list <font color="#a020f0">WHERE</font> parent='partitioned_log':: <font color="#228b22">regclass</font> ;</code> <br> <br>  Starting <code><font color="#a020f0">INSERT</font></code> , ‚Äúspinning up‚Äù the initial date and / or multipliers before random, make the number of sections a little more than 24 (2 years). <br><br>  Create a directory in the OS and the corresponding tablespace where the outdated logs will be stored: <br><br> <code><font color="#a020f0">CREATE</font> TABLESPACE archive LOCATION <font color="#8b2252">'/tmp/archive'</font> ;</code> <br> <br>  And finally, the function that the scheduler will run every day: <br><br> <code><font color="#a020f0">CREATE OR REPLACE FUNCTION</font> <font color="#0000ff">move_oldest_to_archive</font> (parent_name <font color="#228b22">text</font> , suffix <font color="#228b22">text</font> , tblsp_name <font color="#228b22">text</font> , months_hot <font color="#228b22">int</font> ) <font color="#a020f0">RETURNS</font> <font color="#228b22">int</font> <font color="#a020f0">AS</font> <br> $$ <br> <font color="#a020f0">DECLARE</font> <br> i <font color="#228b22">int</font> ; <br> part_rename_sql <font color="#228b22">text</font> ; <br> part_chtblsp_sql <font color="#228b22">text</font> ; <br> part_name <font color="#228b22">text</font> ; <br> <font color="#a020f0">BEGIN</font> <br> i=0; <br> <font color="#a020f0">FOR</font> part_name <font color="#a020f0">IN</font> <font color="#a020f0">SELECT</font> partition <font color="#a020f0">FROM</font> pathman_partition_list <font color="#a020f0">WHERE</font> parent=parent_name::regclass <font color="#a020f0">and</font> partition:: <font color="#228b22">text</font> <font color="#a020f0">NOT</font> <font color="#a020f0">LIKE</font> <font color="#8b2252">'%'</font> ||suffix <font color="#a020f0">ORDER</font> <font color="#a020f0">BY</font> range_max <font color="#a020f0">OFFSET</font> months_hot <font color="#a020f0">LOOP</font> <br> i:=i+1; <br> part_rename_sql:=format( <font color="#8b2252">'ALTER TABLE %I RENAME to %I'</font> , part_name, part_name|| <font color="#8b2252">'_'</font> ||suffix); <br> part_chtblsp_sql:=format( <font color="#8b2252">'ALTER TABLE %I SET TABLESPACE %I'</font> , part_name, tblsp_name); <br> <font color="#a020f0">EXECUTE</font> part_chtblsp_sql; <br> <font color="#a020f0">EXECUTE</font> part_rename_sql; <br> RAISE NOTICE <font color="#8b2252">'executed %, %'</font> ,part_rename_sql,part_chtblsp_sql; <br> <font color="#a020f0">END LOOP</font> ; <br> <font color="#a020f0">RETURN</font> i; <br> <font color="#a020f0">END</font> ; <br> $$ <font color="#a020f0">LANGUAGE</font> plpgsql;</code> <br> <br>  It takes as parameters: the name of the partitioned table <code>(partitioned_log)</code> , the suffix added to the name of the moved partition <code>(archived)</code> , the table space (archive) and the number of months - the boundary of the 1st freshness logs (24). <br><br>  To warm up, we will set a one-time task: <br><br> <code><font color="#a020f0">SELECT</font> schedule.submit_job(query := $$ <font color="#a020f0">select</font> move_oldest_to_archive( <font color="#8b2252">'partitioned_log'</font> , <font color="#8b2252">'archived'</font> , <font color="#8b2252">'archive'</font> , 24);$$);</code> <br> <br>  Once executed, the scheduler will display the task id.  Its status can be viewed in the views <code>schedule.job_status</code> and <code>schedule.all_job_status</code> .  The task scheduler log assigned by the <code>submit_job()</code> function is not <code>submit_job()</code> . <br><br>  To make it easier to play with the scheduler and sections, you can create a function <code>unarchive(parent_name <font color="#228b22">text</font> , suffix <font color="#228b22">text</font> )</code> that rolls back changes (we do not give to save space). <br><br>  It can also be run from the scheduler, but using the run_after parameter, which sets the delay time in seconds - so that we have time to think about whether we did the right thing: <br><br> <code><font color="#a020f0">SELECT</font> schedule.submit_job(query := $$ <font color="#8b2252">'select unarchive('partitioned_log','archived');',run_after='10'</font> $$);</code> <br> <br>  and if wrong, you can cancel it with the function <code>schedule.cancel_job(id)</code> ; <br>  Making sure that everything works as planned, you can put the task (now in JSON syntax) already in the schedule: <br><br> <code><font color="#a020f0">SELECT</font> schedule.create_job($$ <font color="#8b2252">{"commands":"SELECT move_oldest_to_archive('partitioned_log','archived', 'archive', 24);","cron":"55 7 * * *"}</font> $$);</code> <br> <br>  That is, every morning at five minutes to eight the planner will check if it is time to move the outdated partitions to the ‚Äúcold‚Äù archive and relocate if it is time.  The status at this time can be checked by the scheduler log: <code>schedule.get_log()</code> ; <br><br><h2>  Example from life: 2. we spread banners on servers </h2><br>  Let us show how one of the typical tasks is solved, in which the execution of works on a schedule is required and one-time tasks are used. <br><br>  We have a content delivery network (CDN).  We are going to put banners on several websites that are part of it, which the users from advertising agencies have automatically uploaded to the directory assigned to them. <br><br> <code><font color="#a020f0">DROP</font> <font color="#a020f0">SCHEMA IF EXISTS</font> banners <font color="#a020f0">CASCADE</font> ; <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">SCHEMA</font> banners; <br> <br> <font color="#a020f0">SET</font> search_path <font color="#a020f0">TO</font> <font color="#8b2252">'banners'</font> ; <br> <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">TYPE</font> <font color="#228b22">banner_status_t</font> <font color="#a020f0">AS</font> enum ( <font color="#8b2252">'submitted'</font> , <font color="#8b2252">'distributing'</font> , <font color="#8b2252">'ready'</font> , <font color="#8b2252">'error'</font> ); <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">TYPE</font> <font color="#228b22">cdn_dist_status_t</font> <font color="#a020f0">AS</font> enum ( <font color="#8b2252">'submitted'</font> , <font color="#8b2252">'processing'</font> , <font color="#8b2252">'ready'</font> , <font color="#8b2252">'error'</font> ); <br> <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">TABLE</font> <font color="#0000ff">banners</font> ( <br> id SERIAL <font color="#a020f0">PRIMARY</font> <font color="#a020f0">KEY</font> , <br> title <font color="#228b22">text</font> , <br> file <font color="#228b22">text</font> , <br> status <font color="#228b22">banner_status_t</font> <font color="#a020f0">DEFAULT</font> <font color="#8b2252">'submitted'</font> <br> ); <br> <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">TABLE</font> <font color="#0000ff">cdn_servers</font> ( <br> id SERIAL <font color="#a020f0">PRIMARY</font> <font color="#a020f0">KEY</font> , <br> title <font color="#228b22">text</font> , <br> address <font color="#228b22">text</font> , <br> active <font color="#228b22">boolean</font> <br> ); <br> <br> <font color="#a020f0">CREATE</font> <font color="#a020f0">TABLE</font> <font color="#0000ff">banner_on_cdn</font> ( <br> banner_id <font color="#228b22">int</font> , <br> server_id <font color="#228b22">int</font> , <br> created <font color="#228b22">timestamp with time zone</font> <font color="#a020f0">DEFAULT</font> now(), <br> started <font color="#228b22">timestamp with time zone</font> , <br> finished <font color="#228b22">timestamp with time zone</font> , <br> url <font color="#228b22">text</font> , <br> error <font color="#228b22">text</font> , <br> status <font color="#228b22">cdn_dist_status_t</font> <font color="#a020f0">DEFAULT</font> <font color="#8b2252">'submitted'</font> <br> ); <br> <br> <font color="#a020f0">CREATE</font> INDEX banner_on_cdn_banner_server_idx <font color="#a020f0">ON</font> banner_on_cdn (banner_id, server_id); <br> <font color="#a020f0">CREATE</font> INDEX banner_on_cdn_url_idx <font color="#a020f0">ON</font> banner_on_cdn (url);</code> <br> <br>  Let's create a function that initializes the loading of the banner on the server.  For each server, it creates a download task, as well as a task that waits for all created downloads and sets the correct status for the banner when the downloads are completed: <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">FUNCTION</font> <font color="#0000ff">start_banner_upload</font> (bid <font color="#228b22">int</font> ) <font color="#a020f0">RETURNS</font> <font color="#228b22">bigint</font> <font color="#a020f0">AS</font> <br> $BODY$ <br> <font color="#a020f0">DECLARE</font> <br> job_id <font color="#228b22">bigint</font> ; <br> r <font color="#228b22">record</font> ; <br> dep <font color="#228b22">bigint</font> []; <br> <font color="#a020f0">sql</font> <font color="#228b22">text</font> ; <br> len <font color="#228b22">int</font> ; <br> <font color="#a020f0">BEGIN</font> <br> <font color="#a020f0">UPDATE</font> banners <font color="#a020f0">SET</font> status = <font color="#8b2252">'distributing'</font> <font color="#a020f0">WHERE</font> id = bid; <br> dep := <font color="#8b2252">'{}'</font> :: <font color="#228b22">bigint</font> []; <br> <font color="#a020f0">FOR</font> r <font color="#a020f0">IN</font> <font color="#a020f0">SELECT</font> * <font color="#a020f0">FROM</font> cdn_servers <font color="#a020f0">WHERE</font> active <font color="#a020f0">is</font> <font color="#a020f0">TRUE</font> <font color="#a020f0">LOOP</font> <br> <font color="#b22222">--        <br></font> <font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> banner_on_cdn (banner_id, server_id) <font color="#a020f0">VALUES</font> (bid, r.id); <br> <font color="#a020f0">sql</font> := format( <font color="#8b2252">'select banners.send_banner_to_server(%s, %s)'</font> , bid, r.id); <br> job_id := schedule.submit_job( <br> <font color="#a020f0">sql</font> , <br> <font color="#a020f0">name</font> := format( <font color="#8b2252">'send banner id = %s to server %s'</font> , bid, r.title) <br> ); <br> <font color="#b22222">--       <br></font> dep := array_append(dep, job_id); <br> <font color="#a020f0">END LOOP</font> ; <br> len := array_length(dep, 1); <br> <font color="#a020f0">IF</font> len = 0 <font color="#a020f0">THEN</font> <br> <font color="#a020f0">UPDATE</font> banners <font color="#a020f0">SET</font> status = error <font color="#a020f0">WHERE</font> id = bid; <br> <font color="#a020f0">RETURN</font> <font color="#a020f0">NULL</font> ; <br> <font color="#a020f0">END IF</font> ; <br> <font color="#b22222">--  ,       , <br></font> <font color="#b22222">--       dep <br></font> job_id = schedule.submit_job( <br> format( <font color="#8b2252">'SELECT banners.finalize_banner(%s)'</font> , bid), <br> depends_on := dep, <br> <font color="#a020f0">name</font> := format( <font color="#8b2252">'finalization of banner %s'</font> , bid) <br> ); <br> <font color="#a020f0">RETURN</font> job_id; <br> <font color="#a020f0">END</font> <br> $BODY$ <br> <font color="#a020f0">LANGUAGE</font> plpgsql <font color="#a020f0">SET</font> search_path <font color="#a020f0">FROM</font> <font color="#a020f0">CURRENT</font> ;</code> <br> <br>  And this function simulates sending a banner to the server (in fact, it‚Äôs just sleeping for a while): <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">FUNCTION</font> <font color="#0000ff">send_banner_to_server</font> (bid <font color="#228b22">int</font> , sid <font color="#228b22">int</font> ) <br> <font color="#a020f0">RETURNS</font> <font color="#228b22">boolean</font> <font color="#a020f0">AS</font> <br> $BODY$ <br> <font color="#a020f0">DECLARE</font> <br> banner <font color="#228b22">record</font> ; <br> server <font color="#228b22">record</font> ; <br> <font color="#a020f0">BEGIN</font> <br> <font color="#a020f0">SELECT</font> * <font color="#a020f0">from</font> banners <font color="#a020f0">WHERE</font> id = bid <font color="#a020f0">LIMIT</font> 1 <font color="#a020f0">INTO</font> banner; <br> <font color="#a020f0">SELECT</font> * <font color="#a020f0">from</font> cdn_servers <font color="#a020f0">WHERE</font> id = sid <font color="#a020f0">LIMIT</font> 1 <font color="#a020f0">INTO</font> server; <br> <br> <font color="#a020f0">UPDATE</font> banner_on_cdn <font color="#a020f0">SET</font> <br> status = <font color="#8b2252">'processing'</font> , <br> started = now() <br> <font color="#a020f0">WHERE</font> <br> banner_id = bid <font color="#a020f0">AND</font> server_id = sid; <br> <br> <font color="#a020f0">PERFORM</font> pg_sleep((random()*10):: <font color="#228b22">int</font> ); <br> <font color="#a020f0">UPDATE</font> banner_on_cdn <font color="#a020f0">SET</font> <br> url = <font color="#8b2252">'http://'</font> || server.address || <font color="#8b2252">'/'</font> || banner.file, <br> status = <font color="#8b2252">'ready'</font> , <br> finished = now() <br> <font color="#a020f0">WHERE</font> <br> banner_id = bid <font color="#a020f0">AND</font> server_id = sid; <br> <br> <font color="#a020f0">RETURN</font> <font color="#a020f0">TRUE</font> ; <br> <font color="#a020f0">END</font> ; <br> $BODY$ <br> <font color="#a020f0">LANGUAGE</font> plpgsql <font color="#a020f0">set</font> search_path <font color="#a020f0">FROM</font> <font color="#a020f0">CURRENT</font> ;</code> <br> <br>  This function, based on the status of uploading a banner to the server, will determine which status to put the banner: <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">FUNCTION</font> <font color="#0000ff">finalize_banner</font> (bid <font color="#228b22">int</font> ) <br> <font color="#a020f0">RETURNS</font> <font color="#228b22">boolean</font> <font color="#a020f0">AS</font> <br> $BODY$ <br> <font color="#a020f0">DECLARE</font> <br> N <font color="#228b22">int</font> ; <br> <font color="#a020f0">BEGIN</font> <br> <font color="#a020f0">SELECT</font> <font color="#483d8b">count</font> (*) <font color="#a020f0">FROM</font> banner_on_cdn <font color="#a020f0">WHERE</font> banner_id = bid <font color="#a020f0">AND</font> status <font color="#a020f0">IN</font> ( <font color="#8b2252">'submitted'</font> , <font color="#8b2252">'processing'</font> ) <font color="#a020f0">INTO</font> N; <br> <font color="#a020f0">IF</font> N &gt; 0 <font color="#a020f0">THEN</font> <font color="#b22222">--      <br></font> <font color="#a020f0">RETURN</font> <font color="#a020f0">FALSE</font> ; <br> <font color="#a020f0">END IF</font> ; <br> <font color="#a020f0">SELECT</font> <font color="#483d8b">count</font> (*) <font color="#a020f0">FROM</font> banner_on_cdn <font color="#a020f0">WHERE</font> banner_id = bid <font color="#a020f0">AND</font> status <font color="#a020f0">IN</font> ( <font color="#8b2252">'error'</font> ) <font color="#a020f0">INTO</font> N; <br> <font color="#a020f0">IF</font> N &gt; 0 <font color="#a020f0">THEN</font> <font color="#b22222">--     <br></font> <font color="#a020f0">UPDATE</font> banners <font color="#a020f0">SET</font> status = <font color="#8b2252">'error'</font> <font color="#a020f0">WHERE</font> id = bid; <br> <font color="#a020f0">RETURN</font> <font color="#a020f0">FALSE</font> ; <br> <font color="#a020f0">END IF</font> ; <br> <font color="#b22222">--   <br></font> <font color="#a020f0">UPDATE</font> banners <font color="#a020f0">SET</font> status = <font color="#8b2252">'ready'</font> <font color="#a020f0">WHERE</font> id = bid; <br> <font color="#a020f0">RETURN</font> <font color="#a020f0">TRUE</font> ; <br> <font color="#a020f0">END</font> ; <br> $BODY$ <br> <font color="#a020f0">LANGUAGE</font> plpgsql <font color="#a020f0">set</font> search_path <font color="#a020f0">FROM</font> <font color="#a020f0">CURRENT</font> ;</code> <br> <br>  This function will check on schedule whether there are raw banners.  And, if necessary, run the banner processing: <br><br> <code><font color="#a020f0">CREATE</font> <font color="#a020f0">FUNCTION</font> <font color="#0000ff">check_banners</font> () <font color="#a020f0">RETURNS</font> <font color="#228b22">int</font> <font color="#a020f0">AS</font> <br> $BODY$ <br> <font color="#a020f0">DECLARE</font> <br> r <font color="#228b22">record</font> ; <br> N <font color="#228b22">int</font> ; <br> <font color="#a020f0">BEGIN</font> <br> N := 0; <br> <font color="#a020f0">FOR</font> r <font color="#a020f0">IN</font> <font color="#a020f0">SELECT</font> * <font color="#a020f0">from</font> banners <font color="#a020f0">WHERE</font> status = <font color="#8b2252">'submitted'</font> <font color="#a020f0">FOR</font> <font color="#a020f0">UPDATE</font> <font color="#a020f0">LOOP</font> <br> <font color="#a020f0">PERFORM</font> start_banner_upload(r.id); <br> N := N + 1; <br> <font color="#a020f0">END LOOP</font> ; <br> <br> <font color="#a020f0">RETURN</font> N; <br> <font color="#a020f0">END</font> ; <br> $BODY$ <br> <font color="#a020f0">LANGUAGE</font> plpgsql <font color="#a020f0">SET</font> search_path <font color="#a020f0">FROM</font> <font color="#a020f0">CURRENT</font> ;</code> <br> <br>  Now let's take a look at the data.  Create a list of servers: <br><br> <code><font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> cdn_servers (title, address, active) <br> <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'server #1'</font> , <font color="#8b2252">'cdn1.local'</font> , <font color="#a020f0">true</font> ); <br> <font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> cdn_servers (title, address, active) <br> <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'server #2'</font> , <font color="#8b2252">'cdn2.local'</font> , <font color="#a020f0">true</font> ); <br> <font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> cdn_servers (title, address, active) <br> <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'server #3'</font> , <font color="#8b2252">'cdn3.local'</font> , <font color="#a020f0">true</font> ); <br> <font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> cdn_servers (title, address, active) <br> <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'server #4'</font> , <font color="#8b2252">'cdn4.local'</font> , <font color="#a020f0">true</font> );</code> <br> <br>  Create a couple of banners: <br><br> <code><font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> banners (title, file) <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'banner #1'</font> , <font color="#8b2252">'bbb1.jpg'</font> ); <br> <font color="#a020f0">INSERT</font> <font color="#a020f0">INTO</font> banners (title, file) <font color="#a020f0">VALUES</font> ( <font color="#8b2252">'banner #2'</font> , <font color="#8b2252">'bbb2.jpg'</font> );</code> <br> <br>  And, finally, we will schedule the task of checking newly submitted banners, which should be decomposed into servers.  The task will be executed every minute: <br><br> <code><font color="#a020f0">SELECT</font> schedule.create_job( <font color="#8b2252">'* * * * *'</font> , <font color="#8b2252">'select banners.check_banners()'</font> ); <br> <br> <font color="#a020f0">RESET</font> search_path;</code> <br> <br>  That's all, pictures will be laid out on sites, you can relax. <br><br><h2>  Afterword </h2><br>  As <i>Post Scriptum,</i> we inform you that the pgpro_scheduler scheduler works not only on a separate server, but also in a multimaster cluster configuration.  But this is a topic for another conversation. <br><br>  And as <i>Post Post Scriptum</i> - in the future plans of embedding the scheduler in the graphical administration shell that is being created now. </div><p>Source: <a href="https://habr.com/ru/post/335798/">https://habr.com/ru/post/335798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335788/index.html">XBRL: just about the complex - Chapter 6. Immersion in the XBRL - Part 2. Improving the result</a></li>
<li><a href="../335790/index.html">10 free and cool fonts</a></li>
<li><a href="../335792/index.html">Fighting hardcodes with static C # analyzers</a></li>
<li><a href="../335794/index.html">The return of Locky and Mamba: users are attacking new versions of encryption viruses</a></li>
<li><a href="../335796/index.html">Baruch Sadogursky, JFrog: Developer Advocate, Java 9 and Kotlin's world domination (but you better look at Groovy)</a></li>
<li><a href="../335800/index.html">The Great Silk Road: from tablets from China to a nanny-robot from Moscow region</a></li>
<li><a href="../335804/index.html">Random forest vs neural network: who will better cope with the task of recognizing gender in speech (part 2)</a></li>
<li><a href="../335806/index.html">Guide to localizing applications for the Chinese market. Part 1</a></li>
<li><a href="../335808/index.html">BIM: how we build builders in construction</a></li>
<li><a href="../335810/index.html">We break and restore the Chinese IP camera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>