<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SQL Server: Performance when inserting data into a table with a clustered index and without</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article SQL Server Insert Performance for Clustered Indexes vs. Heap tables 

 Question 
 I have rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SQL Server: Performance when inserting data into a table with a clustered index and without</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="https://www.mssqltips.com/sqlservertip/4961/sql-server-insert-performance-for-clustered-indexes-vs-heap-tables/">SQL Server Insert Performance for Clustered Indexes vs.</a>  <a href="https://www.mssqltips.com/sqlservertip/4961/sql-server-insert-performance-for-clustered-indexes-vs-heap-tables/">Heap tables</a> <br><br><h2>  Question </h2><br>  I have read many different documentation on modern SQL Server methods, stating that each table should have a clustered index and not be a bunch of non-clustered indexes.  Most sources point out the administrative benefits of using clustered indexes.  But is there any impact on performance and other positive or negative sides? <br><a name="habracut"></a><br><h2>  Decision </h2><br>  To check the performance of each option, we will create two identical tables with one difference: in one there will be a primary key created on the basis of a clustered index, and in the other a primary key will be created on the basis of a nonclustered index and the data will remain as a heap.  Below is a script to create test tables and fill them with data. <br><br><div class="spoiler">  <b class="spoiler_title">Script 1</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- Create table and indexes CREATE TABLE testtable ([col1] [int] NOT NULL PRIMARY KEY CLUSTERED, [col2] [int] NULL, [col3] [int] NULL, [col4] [varchar](50) NULL, [col5] uniqueidentifier); -- Load sample data into table DECLARE @val INT SELECT @val=1 WHILE @val &lt; 5000000 BEGIN INSERT INTO testtable (col1, col2, col3, col4, col5) VALUES (@val,round(rand()*100000,0), round(rand()*100000,0),'TEST' + cast(@val AS VARCHAR), newid()) SELECT @val=@val+1 END GO -- Create sample table and indexes CREATE TABLE testtable2 ([col1] [int] NOT NULL PRIMARY KEY NONCLUSTERED, [col2] [int] NULL, [col3] [int] NULL, [col4] [varchar](50) NULL, [col5] uniqueidentifier); INSERT INTO testtable2 SELECT * FROM testtable;</span></span></code> </pre> <br></div></div><br>  The first thing I noticed at once was that the heap used more space, since  table and index are separate structures.  With a clustered index, data is stored in the leaves of the index and therefore uses less space.  Below is a table showing the amount of space used by each object at the end of the data load. <br><table><tbody><tr><th>  Table </th><th>  Index </th><th>  Used (KB) </th><th>  Reserved (KB) </th><th>  Number of lines </th></tr><tr><td>  testtable </td><td>  PK__testtabl__357D0D3E3D086A66 </td><td>  257952 </td><td>  257992 </td><td>  4999999 </td></tr><tr><td>  testtable2 </td><td>  HEAP </td><td>  256992 </td><td>  257032 </td><td>  4999999 </td></tr><tr><td>  testtable2 </td><td>  PK__testtabl__357D0D3F2CBA35D8 </td><td>  89432 </td><td>  89608 </td><td>  4999999 </td></tr></tbody></table><br>  After the primary data has been loaded, we proceed to the second stage of loading and look at the performance using the SQL Profiler, and also check the used space.  Below is a script that loads an additional 100,000 records into each table. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Script 2</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- insert when all pages are full DECLARE @val INT SELECT @val=5000000 WHILE @val &lt; 5100000 BEGIN INSERT INTO testtable (col1, col2, col3, col4, col5) VALUES (@val,round(rand()*100000,0), round(rand()*100000,0),'TEST' + cast(@val AS VARCHAR), newid()) SELECT @val=@val+1 END GO DECLARE @val INT SELECT @val=5000000 WHILE @val &lt; 5100000 BEGIN INSERT INTO testtable2 (col1, col2, col3, col4, col5) VALUES (@val,round(rand()*100000,0), round(rand()*100000,0),'TEST' + cast(@val AS VARCHAR), newid()) SELECT @val=@val+1 END GO</span></span></code> </pre> <br></div></div><br>  To begin with, we will look at the used space, which, as expected (after all, the pages were filled to the end and nothing was deleted), increased proportionally for each object.  Both tables increased in size about the same. <br><table><tbody><tr><th>  Table </th><th>  Index </th><th>  Used (KB) </th><th>  Reserved (KB) </th><th>  Number of lines </th></tr><tr><td>  testtable </td><td>  PK__testtabl__357D0D3E3D086A66 </td><td>  263128 </td><td>  263176 </td><td>  5099999 </td></tr><tr><td>  testtable2 </td><td>  HEAP </td><td>  262392 </td><td>  262472 </td><td>  5099999 </td></tr><tr><td>  testtable2 </td><td>  PK__testtabl__357D0D3F2CBA35D8 </td><td>  91216 </td><td>  91272 </td><td>  5099999 </td></tr></tbody></table><br>  But the SQL Profiler shows us more interesting things.  Since  when inserting data into a heap, two objects need to be updated - a nonclustered index and the table itself, this also requires additional resources from the CPU, plus more read and write operations are performed at this moment than when inserting data into a table with a clustered index, therefore It will take a little longer. <br><table><tbody><tr><th>  Index type </th><th>  CPU (ms) </th><th>  Read operations </th><th>  Write operations </th><th>  Duration (ms) </th></tr><tr><td>  Clustered </td><td>  3500 </td><td>  304919 </td><td>  654 </td><td>  11288 </td></tr><tr><td>  A pile </td><td>  3890 </td><td>  406083 </td><td>  904 </td><td>  11438 </td></tr></tbody></table><br>  Now we will randomly delete some of the data and insert another 100,000 entries to check how the presence of white space on some pages will affect performance.  The script that performs the removal and insertion is shown below. <br><br><div class="spoiler">  <b class="spoiler_title">Script 3</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- remove 1000000 random records from each table DELETE FROM testtable WHERE col1 in (SELECT TOP 1000000 col1 FROM testtable ORDER BY newid()); DELETE FROM testtable2 WHERE col1 not in (SELECT col1 FROM testtable); GO -- insert when there is free space in pages DECLARE @val INT SELECT @val=5100000 WHILE @val &lt; 5200000 BEGIN INSERT INTO testtable (col1, col2, col3, col4, col5) VALUES (@val,round(rand()*100000,0), round(rand()*100000,0),'TEST' + cast(@val AS VARCHAR), newid()) SELECT @val=@val+1 END GO DECLARE @val INT SELECT @val=5100000 WHILE @val &lt; 5200000 BEGIN INSERT INTO testtable2 (col1, col2, col3, col4, col5) VALUES (@val,round(rand()*100000,0), round(rand()*100000,0),'TEST' + cast(@val AS VARCHAR), newid()) SELECT @val=@val+1 END GO</span></span></code> </pre> <br>  This time, SQL Profiler shows an increase in the performance gap between the two tables in favor of a clustered index. <br><table><tbody><tr><th>  Index type </th><th>  CPU (ms) </th><th>  Read operations </th><th>  Write operations </th><th>  Duration (ms) </th></tr><tr><td>  Clustered </td><td>  3562 </td><td>  304859 </td><td>  653 </td><td>  10334 </td></tr><tr><td>  A pile </td><td>  4973 </td><td>  422142 </td><td>  7053 </td><td>  13042 </td></tr></tbody></table><br></div></div><br>  Most likely, this difference arose from the fact that when inserting records into a heap, the DBMS will look for empty space on each page to place data in it.  The reason for this is the fact that the data in the heap is not sorted, which means that the inserted records can be placed anywhere.  When it comes to a table with a clustered index, when increasing the value of the primary key, the insertion is always done at the end of the table.  Also pay attention to the space used by the tables.  In the case of a heap, when reusing space, the amount of space occupied by the table should not increase, because  we inserted as much as we deleted.  Below is information about the tables, recorded after the last script, in which it is clear that the space occupied by the heap has not changed and this confirms the earlier suggestion. <br><table><tbody><tr><th>  Table name </th><th>  Index name </th><th>  Used (KB) </th><th>  Reserved (KB) </th><th>  Number of lines </th></tr><tr><td>  testtable </td><td>  PK__testtabl__357D0D3E3D086A66 </td><td>  268304 </td><td>  268360 </td><td>  4199999 </td></tr><tr><td>  testtable2 </td><td>  HEAP </td><td>  262392 </td><td>  262472 </td><td>  4199999 </td></tr><tr><td>  testtable2 </td><td>  PK__testtabl__357D0D3F2CBA35D8 </td><td>  93008 </td><td>  93064 </td><td>  4199999 </td></tr></tbody></table><br><h2>  Conclusion </h2><br>  In this study, we have seen that using a clustered index, as compared to a heap, gives the best results for all the categories measured: CPU, I / O, and execution time.  The only side effect is that using a clustered index requires a bit more space.  This space can be reduced by rebuilding the index.  In any case, before making any changes to the indexes on the production system, you need to check everything on your equipment to make sure that the performance has improved. </div><p>Source: <a href="https://habr.com/ru/post/340216/">https://habr.com/ru/post/340216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340204/index.html">Cj - new programming language</a></li>
<li><a href="../340206/index.html">BaumankaCoin - a bike in 3000 lines or a blockchain on the fingers</a></li>
<li><a href="../340210/index.html">New Yandex.Cashi API: payment lego for e-commerce of all stripes</a></li>
<li><a href="../340212/index.html">Deep learning with R and Keras on the example of the Carvana Image Masking Challenge</a></li>
<li><a href="../340214/index.html">Preview RamblerFront & # 3</a></li>
<li><a href="../340218/index.html">MBLTdev 2017 is near: program on hardcore</a></li>
<li><a href="../340220/index.html">3CX PBX Express: 1 year free PBX in the Google Cloud</a></li>
<li><a href="../340222/index.html">Stone in the designer's garden</a></li>
<li><a href="../340224/index.html">How to hide</a></li>
<li><a href="../340228/index.html">How to enforce PCI DSS 3.2 requirements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>