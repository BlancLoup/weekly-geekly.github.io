<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QtDockTile - cross-platform use of docks!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Considering the current trends in the development of desktops, it is difficult not to pay attention to the fact that the idea of ‚Äã‚Äãthe dock is becomin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QtDockTile - cross-platform use of docks!</h1><div class="post__text post__text-html js-mediator-article">  Considering the current trends in the development of desktops, it is difficult not to pay attention to the fact that the idea of ‚Äã‚Äãthe dock is becoming more and more popular.  There are at least three popular implementations of this principle: Makovsky Doc, taskbar from windiws 7 and launcher from unity.  Icon tasks will be added to this list in kde 4.8. <br>  In short, there is a need to create a universal library for working with all this diversity. <br>  Meet qtdocktile <br><a name="habracut"></a><br><br><h4>  Common to all docks </h4><br><br>  First of all, you need to highlight a list of features that are common to all docks: <br><ol><li>  Badges </li><li>  Progress indicator </li><li>  Menu </li><li>  Signaling </li></ol><br>  All this functionality is basic and is somehow supported both in the seven, and in makosi, and in ubunt.  It is based on it that the qtdocktile base API will be built, and all platform-specific extensions will be added as the library develops and will not be required. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Library architecture </h4><br><br>  For maximum flexibility and extensibility, I decided that the implementations of each specific dock would be ordinary Qt plugins - this allows adding support for new APIs without recompiling the entire library, and if it is impossible to use this or that implementation, the plugin simply won't start.  Plugins are loaded by a special singleton manager.  Each plug-in tells the manager whether it can work in this environment or not, with the result that the manager can call the necessary methods only on those plug-ins that are workable in this environment. <br>  The user works with a simple QtDockTile class, which is a wrapper for the manager.  As a result, you can safely create any number of QtDockTile instances - they will not break the work of the dock. <br>  For the dock menu, the usual QMenu Qt will be used.  It is only necessary to remember the limitations that this or that platform puts up. <br><br><h5>  Sample library usage </h5><br><pre><code class="hljs pgsql">m_tile-&gt;setMenu(ui-&gt;menu); <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(ui-&gt;pushButton, SIGNAL(clicked()), m_tile, SLOT(alert())); <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(ui-&gt;lineEdit, SIGNAL(textChanged(QString)), m_tile, SLOT(setBadge(QString))); <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(ui-&gt;horizontalSlider, SIGNAL(valueChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>)), m_tile, SLOT(setProgress(<span class="hljs-type"><span class="hljs-type">int</span></span>)));</code> </pre> <br><br>  As you can see, it is very simple!  But to write a simple API is still half the problem, now you need to implement support for all platforms: <br><br>  Attention!  There will be a lot of technical details, if you are not interested in them, you can immediately proceed to the reading of the conclusion. <br><br><h4>  Unity plugin implementation </h4><br><br>  Strangely enough, but for Unity the shortest and laconic implementation turned out.  All api is built on sending fairly simple dbus messages: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnityLauncher::sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QVariantMap &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { QDBusMessage message = QDBusMessage::createSignal(appUri(), <span class="hljs-string"><span class="hljs-string">"com.canonical.Unity.LauncherEntry"</span></span>, <span class="hljs-string"><span class="hljs-string">"Update"</span></span>); QVariantList args; args &lt;&lt; appDesktopUri() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; message.setArguments(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!QDBusConnection::sessionBus().send(message)) qWarning(<span class="hljs-string"><span class="hljs-string">"Unable to send message"</span></span>); }</code> </pre><br><br>  Where appUri is the unique name of the application, in this implementation it just matches the process name, and appDesktopUri is a record of the application: //$appUri.desktop type. <br>  In order to change the value on the badge just send a message: <br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">QVariantMap</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.insert(<span class="hljs-type"><span class="hljs-type">QLatin1String</span></span>(<span class="hljs-string"><span class="hljs-string">"count"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.insert(<span class="hljs-type"><span class="hljs-type">QLatin1String</span></span>(<span class="hljs-string"><span class="hljs-string">"count-visible"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); sendMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre><br><br>  Similarly, for the progress indicator and alarm, the menu is slightly more interesting: you need to use the DBusMenuExporter class when creating an appUri and a pointer to QMenu when creating it.  That's all the API, now let's list the restrictions: <br><br><h5>  Unity Launcher API Restrictions </h5><br><br><ol><li>  Badges are only digital and only greater than 0. Otherwise 0 is displayed. </li><li>  The exported menu does not show submenus, so it‚Äôs best to avoid them </li><li>  If the menu is also exported to appmenu, it will not appear in the dock. </li><li>  There is a bug in the implementation of DBusMenuExporter, which causes the checked state of the menu to be inverted </li></ol><br><br>  And finally: for the API to work, it is necessary to have an icon for the application in / usr / share / applications .desktop.  By the way, the Unity API allows you to add permanent items to the menu that work when the application is not running, it looks like this: <br><pre> <code class="hljs pgsql">X-Ayatana-Desktop-Shortcuts=NewWindow; [NewWindow Shortcut <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>] <span class="hljs-type"><span class="hljs-type">Name</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">Open</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Window</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>[ast]=Abrir una ventana nueva <span class="hljs-type"><span class="hljs-type">Name</span></span>[bn]=Abrir una ventana nueva <span class="hljs-type"><span class="hljs-type">Name</span></span>[ca]=Obre una finestra nova <span class="hljs-type"><span class="hljs-type">Name</span></span>[da]=√Öbn et nyt vindue <span class="hljs-type"><span class="hljs-type">Name</span></span>[de]=Ein neues Fenster √∂ffnen <span class="hljs-type"><span class="hljs-type">Name</span></span>[es]=Abrir una ventana nueva <span class="hljs-type"><span class="hljs-type">Name</span></span>[fi]=Avaa uusi ikkuna <span class="hljs-type"><span class="hljs-type">Name</span></span>[fr]=Ouvrir une nouvelle fen√™tre <span class="hljs-type"><span class="hljs-type">Name</span></span>[gl]=Abrir unha nova xanela <span class="hljs-type"><span class="hljs-type">Name</span></span>[he]=◊§◊™◊ô◊ó◊™ ◊ó◊ú◊ï◊ü ◊ó◊ì◊© <span class="hljs-type"><span class="hljs-type">Name</span></span>[hr]=Otvori novi prozor <span class="hljs-type"><span class="hljs-type">Name</span></span>[hu]=√öj ablak nyit√°sa <span class="hljs-type"><span class="hljs-type">Name</span></span>[it]=Apri una nuova finestra <span class="hljs-type"><span class="hljs-type">Name</span></span>[ja]=Êñ∞„Åó„ÅÑ„Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíÈñã„Åè<span class="hljs-type"><span class="hljs-type">Name</span></span>[ku]=Paceyeke n√ª veke <span class="hljs-type"><span class="hljs-type">Name</span></span>[lt]=Atverti naujƒÖ langƒÖ <span class="hljs-type"><span class="hljs-type">Name</span></span>[nl]=Nieuw venster openen <span class="hljs-type"><span class="hljs-type">Name</span></span>[ro]=Deschide o fereastrƒÉ nouƒÉ <span class="hljs-type"><span class="hljs-type">Name</span></span>[ru]=   <span class="hljs-type"><span class="hljs-type">Name</span></span>[sv]=√ñppna ett nytt f√∂nster <span class="hljs-type"><span class="hljs-type">Name</span></span>[ug]=Ÿä€ê⁄≠Ÿâ ŸÉ€Üÿ≤ŸÜ€ïŸÉ ÿ¶€ê⁄ÜŸâÿ¥ <span class="hljs-type"><span class="hljs-type">Name</span></span>[uk]=—ñ  —ñ <span class="hljs-type"><span class="hljs-type">Name</span></span>[zh_CN]=Êñ∞Âª∫Á™óÂè£<span class="hljs-type"><span class="hljs-type">Name</span></span>[zh_TW]=ÈñãÂïüÊñ∞Ë¶ñÁ™óExec=firefox -<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> TargetEnvironment=Unity</code> </pre><br><br><h5>  And a couple of screenshots for a snack: </h5><br><br>  Unity: <br><img src="http://storage4.static.itmages.ru/i/11/1223/h_1324664391_2996068_ce440ed8c3.png" alt="image"><br>  KDE (Icon Tasks): <br><img src="http://storage8.static.itmages.ru/i/11/1220/h_1324329980_7675224_0af6510bc2.png" alt="image"><br><br>  When writing a plugin, I used the <a href="http://habrahabr.ru/users/torkve/" class="user_link">Torkve tkimt</a> 's tv experience. <br><br><h4>  Plugin implementation for Macos X </h4><br><br>  Also, there were no particular difficulties, for exporting the menu to Qt there is already a special method, a lot has been said about it <a href="http://habrahabr.ru/blogs/qt_software/133700/">here.</a> <br>  The badge is elementary using Cocoa tools; you just need to convert the QString to NSString, send a message to the dock and take care of clearing the memory. <br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *utf8String = badge.toUtf8().constData(); <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cocoaString = [[<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> alloc] initWithUTF8String:utf8String]; [[<span class="hljs-built_in"><span class="hljs-built_in">NSApp</span></span> dockTile] setBadgeLabel:cocoaString]; [cocoaString release];</code> </pre><br>  It turned out to be a little harder to make the progress indicator: the dock API does not have a built-in method, but there is a method for drawing its image in the dock icon.  In order not to bother much, I just took the implementation of the indicator from QtCreator, since the LGPL license quietly allows such a feint with my ears. <br><br><h5>  Screenshot </h5><br><img src="http://storage3.static.itmages.ru/i/11/1220/h_1324381823_1545713_5c2943a7c1.png" alt="image"><br><br><h4>  Implementation for Windows 7 Taskbar </h4><br><br>  And finally, the most delicious!  If in other systems the process of writing plug-ins went more or less smoothly, then for the most popular desktop OS everything was far from being so cloudless, I had to remember for myself the different bad words of Bill Gates, Steve Balmer and nameless programmers who carefully laid out various rakes!  In the course of writing, the phrase must die, wtf, and so on, up to the good old windos, appeared more than once in my head. <br>  There are strange and unreadable types of LPCSTR instead of wchar_t * and Hungarian notation in all fields and great and terrible COM, in a word, the style of the code is simply terrible.  And there is also a problem here in ABI, as a result of which it is impossible to link the C ++ library compiled by the MS compiler to the code compiled by minGW.  Well, the API itself is somewhat strange because of what had to go on some crutches.  In addition, examples of jump lists contain the use of the ATL library, which is only available in a paid studio and is not suitable for us for this reason. <br>  To solve problems with ABI, we with <a href="http://habrahabr.ru/users/dtf/" class="user_link">dtf</a> decided to make a minimal C wrapper over the taskbar's COM API so that in the future we could link to it dynamically from any compiler. <br>  The API turned out to be quite simple, the wrapper itself does not depend on Qt and can be used from anything, although it is written and not at all in the style of winAPI. <br><br><pre> <code class="hljs cpp">... <span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setApplicationId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *appId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOverlayIcon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND winId, HICON icon, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearOverlayIcon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND winId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setProgressValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND winId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> percents)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setProgressState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND winId, ProgressState state)</span></span></span></span>; ...</code> </pre><br><br>  I started with the simplest: I decided to make a progress indicator, the code for it was already written by a friend of <a href="http://habrahabr.ru/users/dtf/" class="user_link">dtf</a> , so there was no particular difficulty with the transfer. <br><br><pre> <code class="hljs bash">//    static ITaskbarList3 *<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowsTaskBar</span></span></span></span>() { ITaskbarList3 *taskbar; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(S_OK != CoCreateInstance(CLSID_TaskbarList, 0, CLSCTX_INPROC_SERVER, IID_ITaskbarList3, (void**)&amp;taskbar)) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> taskbar; } ... //   void setProgressValue(HWND winId, int progress) { ITaskbarList3 *taskbar = windowsTaskBar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!taskbar) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>; taskbar-&gt;HrInit(); taskbar-&gt;SetProgressValue(winId, progress, 100); taskbar-&gt;SetProgressState(winId, progress ? TBPF_NORMAL : TBPF_NOPROGRESS); taskbar-&gt;Release(); } //    void setProgressState(HWND winId, ProgressState state) { TBPFLAG flags; ITaskbarList3 *taskbar = windowsTaskBar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!taskbar) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>; taskbar-&gt;HrInit(); switch (state) { default: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ProgressStateNone : flags = TBPF_NOPROGRESS; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ProgressStateNormal : flags = TBPF_NORMAL; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ProgressStatePaused : flags = TBPF_PAUSED; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ProgressStateError : flags = TBPF_ERROR; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ProgressStateIndeterminate : flags = TBPF_INDETERMINATE; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } taskbar-&gt;SetProgressState(winId, flags); taskbar-&gt;Release(); }</code> </pre><br>  I implemented the badge through the setOverlayIcon method, and I drew the icon itself and turned it into HICON using Qt <br><pre> <code class="hljs php">QPixmap WindowsTaskBar::createBadge(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;badge) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QPixmap pixmap(overlayIconSize()); QRect rect = pixmap.rect(); rect.adjust(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); pixmap.fill(Qt::transparent); QPainter painter(&amp;pixmap); painter.setRenderHint(QPainter::Antialiasing); QPalette palette = window()-&gt;palette(); painter.setBrush(palette.toolTipBase()); QPen pen = painter.pen(); pen.setColor(palette.color(QPalette::ToolTipText)); painter.setPen(pen); QString label = QFontMetrics(painter.font()).elidedText(badge, Qt::ElideMiddle, rect.width()); painter.drawRoundedRect(rect, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); painter.drawText(rect, Qt::AlignCenter | Qt::TextSingleLine, label); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixmap; }</code> </pre><br>  As a result, only 2 symbols are in the badge.  The size of the icon is set through QStyle :: pixelMetrics, I found out that other overlayIcon implementations simply draw the 16x16 icon and do not care about the dpi, so the icon on my monitor turns out to be blurred. <br>  And now the most interesting is the implementation of jump lists.  This is where old Billy heard many kind words addressed to him in absentia! <br><br><h5>  Cruelty number 1 - serialization QAction'a given the limitations of the API </h5><br><br>  Each action has a name, a command that is executed when you click on the action and optionally the path to the icon in the ico format and a description.  And all this needs to be transferred in the form of sishnyh wide char strings, and therefore independently follow the time of their life.  And of course, you need to somehow organize a callback, which is also not obvious, because you need to call the trigger method on QAction, which also does not look simple at first glance. <br>  In our wrapper we will pass an array of structures of this content: <br><pre> <code class="hljs delphi">struct ActionInfo <span class="hljs-comment"><span class="hljs-comment">{ const char *id; wchar_t *name; wchar_t *description; wchar_t *iconPath; ActionType type; void *data; //    -                 . }</span></span>; typedef void <span class="hljs-comment"><span class="hljs-comment">(*ActionInvoker)(void*)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      void *data</span></span></code> </pre><br><br>  Now let's reveal the secret void * data: <br><pre> <code class="hljs pgsql">typedef QVector&lt;ActionInfo&gt; ActionInfoList; //   ++,          typedef QVector&lt;wchar_t&gt; WCharArray; //  wchar_t * static WCharArray toWCharArray(const QString &amp;str) { WCharArray <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(str.length() + <span class="hljs-number"><span class="hljs-number">1</span></span>); str.toWCharArray(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.data()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; } struct Data { Data(QAction *action) : action(action), icon(action-&gt;icon()), id(QUuid::createUuid().toByteArray()), <span class="hljs-type"><span class="hljs-type">name</span></span>(toWCharArray(action-&gt;text())), description(toWCharArray(action-&gt;toolTip())), iconPath(toWCharArray(icon.filePath())) { } QWeakPointer&lt;QAction&gt; action; TemporaryIcon icon; QByteArray id; WCharArray <span class="hljs-type"><span class="hljs-type">name</span></span>; WCharArray description; WCharArray iconPath; }; <span class="hljs-type"><span class="hljs-type">void</span></span> invokeQAction(<span class="hljs-type"><span class="hljs-type">void</span></span> *pointer) { Data *data = reinterpret_cast&lt;Data*&gt;(pointer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;action) { qDebug() &lt;&lt; data-&gt;action.data(); data-&gt;action.data()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span>(); } }</code> </pre><br>  Here such action serialization turned out.  I tried to keep the number of manual new and delete to a minimum - everything happens automatically.  This approach is a guarantee that your hair will be smooth and silky! <br><br>  Now let's remember the limitations of the platform and understand which actions we can serialize and which ones should be ignored.  So there is no submenu in jump lists, there are no both disabled and checkable items here, the total number of items is limited to 20.  But there are separators, it turns out something like this: <br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!action-&gt;menu() &amp;&amp; action-&gt;isVisible() &amp;&amp; action-&gt;isEnabled() &amp;&amp; !action-&gt;isCheckable()) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.append(serialize(action)); ... ActionInfo JumpListsMenuExporterPrivate::serialize(QAction *action) { Data *data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data(action); ActionType type = action-&gt;isSeparator() ? ActionTypeSeparator : ActionTypeNormal; ActionInfo info = { data-&gt;id.constData(), data-&gt;name.data(), data-&gt;description.data(), data-&gt;iconPath.data(), type, data }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre><br>  In order to display the icons, we had to create our own implementation of temporary files, the QTemporaryFile doesn‚Äôt really suit us, because it owns the file exclusively.  I will not consider it separately: everything is very simple and clear there. <br><br><h5>  Ordeal number 2 - filling in jumpLists </h5><br><br>  To fill jump lists, call the beginList method. <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JumpListsManager::beginList() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_destList) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ICustomDestinationList *list; HRESULT res = CoCreateInstance(<span class="hljs-built_in"><span class="hljs-built_in">CLSID_DestinationList</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CLSCTX_INPROC_SERVER</span></span>, IID_ICustomDestinationList, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FAILED(res)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">UINT</span></span> maxSlots; m_destList = list; m_destList-&gt;SetAppID(m_appId); m_destList-&gt;BeginList(&amp;maxSlots, IID_IObjectArray, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;m_destListContent); m_destListContent-&gt;Release(); IObjectArray *objArray; CoCreateInstance(<span class="hljs-built_in"><span class="hljs-built_in">CLSID_EnumerableObjectCollection</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CLSCTX_INPROC_SERVER</span></span>, IID_IObjectArray, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;objArray); objArray-&gt;QueryInterface(IID_IObjectCollection, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;m_destListContent); objArray-&gt;Release(); }</code> </pre><br>  Then fill this list <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-type"><span class="hljs-type">JumpListsManager</span></span>::addTask(<span class="hljs-type"><span class="hljs-type">ActionInfo</span></span> *info) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_destList) return; <span class="hljs-type"><span class="hljs-type">IShellLinkW</span></span> *task; <span class="hljs-type"><span class="hljs-type">HRESULT</span></span> res = <span class="hljs-type"><span class="hljs-type">CoCreateInstance</span></span>(<span class="hljs-type"><span class="hljs-type">CLSID_ShellLink</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-type"><span class="hljs-type">CLSCTX_INPROC_SERVER</span></span>, <span class="hljs-type"><span class="hljs-type">IID_IShellLinkW</span></span>, (void**)&amp;task); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">FAILED</span></span>(res)) return; task-&gt;<span class="hljs-type"><span class="hljs-type">SetDescription</span></span>(info-&gt;description); task-&gt;<span class="hljs-type"><span class="hljs-type">SetPath</span></span>(<span class="hljs-type"><span class="hljs-type">L</span></span><span class="hljs-string"><span class="hljs-string">"rundll32.exe"</span></span>); task-&gt;<span class="hljs-type"><span class="hljs-type">SetArguments</span></span>(makeArgs(info).c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info-&gt;iconPath) task-&gt;<span class="hljs-type"><span class="hljs-type">SetIconLocation</span></span>(info-&gt;iconPath, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">IPropertyStore</span></span> *title; <span class="hljs-type"><span class="hljs-type">PROPVARIANT</span></span> titlepv; res = task-&gt;<span class="hljs-type"><span class="hljs-type">QueryInterface</span></span>(<span class="hljs-type"><span class="hljs-type">IID_IPropertyStore</span></span>, (void**)&amp;title); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">FAILED</span></span>(res)) { task-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); return; } <span class="hljs-type"><span class="hljs-type">InitPropVariantFromString</span></span>(info-&gt;name, &amp;titlepv); title-&gt;<span class="hljs-type"><span class="hljs-type">SetValue</span></span>(<span class="hljs-type"><span class="hljs-type">PKEY_Title</span></span>, titlepv); title-&gt;<span class="hljs-type"><span class="hljs-type">Commit</span></span>(); <span class="hljs-type"><span class="hljs-type">PropVariantClear</span></span>(&amp;titlepv); res = m_destListContent-&gt;<span class="hljs-type"><span class="hljs-type">AddObject</span></span>(task); title-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); task-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); m_actionInfoMap.insert(std::make_pair(info-&gt;id, info)); //    :      id    . } ... void <span class="hljs-type"><span class="hljs-type">JumpListsManager</span></span>::addSeparator() { <span class="hljs-type"><span class="hljs-type">IShellLinkW</span></span> *separator; <span class="hljs-type"><span class="hljs-type">IPropertyStore</span></span> *propStore; <span class="hljs-type"><span class="hljs-type">PROPVARIANT</span></span> pv; <span class="hljs-type"><span class="hljs-type">HRESULT</span></span> res = <span class="hljs-type"><span class="hljs-type">CoCreateInstance</span></span>(<span class="hljs-type"><span class="hljs-type">CLSID_ShellLink</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-type"><span class="hljs-type">CLSCTX_INPROC_SERVER</span></span>, <span class="hljs-type"><span class="hljs-type">IID_IShellLinkW</span></span>, (void**)&amp;separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">FAILED</span></span>(res)) return; res = separator-&gt;<span class="hljs-type"><span class="hljs-type">QueryInterface</span></span>(<span class="hljs-type"><span class="hljs-type">IID_IPropertyStore</span></span>, (void**)&amp;propStore); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">FAILED</span></span>(res)) { separator-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); return; } <span class="hljs-type"><span class="hljs-type">InitPropVariantFromBoolean</span></span>(<span class="hljs-type"><span class="hljs-type">TRUE</span></span>, &amp;pv); propStore-&gt;<span class="hljs-type"><span class="hljs-type">SetValue</span></span>(<span class="hljs-type"><span class="hljs-type">PKEY_AppUserModel_IsDestListSeparator</span></span>, pv); <span class="hljs-type"><span class="hljs-type">PropVariantClear</span></span>(&amp;pv); propStore-&gt;<span class="hljs-type"><span class="hljs-type">Commit</span></span>(); propStore-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); res = m_destListContent-&gt;<span class="hljs-type"><span class="hljs-type">AddObject</span></span>(separator); separator-&gt;<span class="hljs-type"><span class="hljs-type">Release</span></span>(); }</code> </pre><br>  And call the commitList method <br><pre> <code class="hljs php">void JumpListsManager::commitList() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_destList) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; m_destList-&gt;AddUserTasks(m_destListContent); m_destList-&gt;CommitList(); m_destList-&gt;Release(); m_destListContent-&gt;Release(); m_destList = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_destListContent = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Verbose, is not it?  But alas, you have to bite the bullet and continue scribbling hundreds of lines of code, otherwise nothing will work, but we are not real men and difficulties?  And since we are not afraid, let's implement the callback! <br><br><h5>  Prosecution number 3 - Implementation of the callback </h5><br><br>  So what do we have?  Activating a clause in jumpList invokes a command with some set of arguments.  But how do we say through it that we want to find actionInfo with a specific id and make a callback? <br>  <a href="http://habrahabr.ru/users/dtf/" class="user_link">Dtf</a> and <a href="http://habrahabr.ru/users/dtf/" class="user_link">I have</a> been thinking about this for a long time, and he proposed to do everything through rundll, which is able to call a specific method from the library with given arguments. <br>  As a result, a method was born that accepts an action id, opens a socket on port 42042 and sends the received id to it, and the library listens to this socket and after receiving id it calmly makes a callback and our desired QAction is called! <br><pre> <code class="hljs pgsql">std::wstring JumpListsManager::makeArgs(ActionInfo *<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>) { std::wstring args = m_wrapperPath; #ifdef _WIN64 args += L",_RundllCallback@28 "; // <span class="hljs-built_in"><span class="hljs-built_in">WARNING</span></span>: TEST ME! // ptr√ó<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-type"><span class="hljs-type">int</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> args += L",_RundllCallback@16 "; #endif // Convert <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> a wchar_t* size_t origsize = strlen(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;id) + <span class="hljs-number"><span class="hljs-number">1</span></span>; const size_t newsize = <span class="hljs-number"><span class="hljs-number">64</span></span>; size_t convertedChars = <span class="hljs-number"><span class="hljs-number">0</span></span>; wchar_t buffer[newsize]; mbstowcs_s(&amp;convertedChars, buffer, origsize, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;id, _TRUNCATE); args += buffer; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args; }</code> </pre><br>  And the last method: the implementation of the function that rundll calls <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> CALLBACK </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RundllCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd, HINSTANCE hinst, LPSTR cmdLine, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cmdShow)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> CALLBACK </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RundllCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND, HINSTANCE, LPSTR cmdLine, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ WSADATA wsaData; WSAStartup(MAKEWORD(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), &amp;wsaData); SOCKET sk; sk = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sk == INVALID_SOCKET) { WSACleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sockaddr_in sai; sai.sin_family = AF_INET; sai.sin_addr.s_addr = inet_addr(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>); sai.sin_port = htons(Handler::port); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connect(sk, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;SOCKADDR*&gt;(&amp;sai), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sai)) == SOCKET_ERROR) { WSACleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = cmdLine; send(sk, cmd.c_str(), cmd.size(), <span class="hljs-number"><span class="hljs-number">0</span></span>); closesocket(sk); WSACleanup(); }</code> </pre><br><br>  Everything, the code for today is enough, you can breathe easy, let's summarize: <br><br><h5>  Restrictions in windows implementation </h5><br><br><ol><li>  Only two characters in the badge </li><li>  As a result of our manipulations, the last files from jump lists disappear. </li><li>  Actions not supported - switches and inactive actions </li><li>  Submenus not supported </li></ol><br><br><h5>  Screenshot: </h5><br><img src="http://storage4.static.itmages.ru/i/11/1226/h_1324889267_6337096_ffd5b15a39.png" alt="image"><br><br><h4>  Conclusion </h4><br><br>  The library was very easy to use and easy to expand.  While it covers only the basic features that are on all platforms.  In the future, we will think about how to add platform-specific extensions. <br>  In order for the menu to be guaranteed to be exported without problems to the dock, it must satisfy the following items: <br><ul><li>  Do not have a submenu </li><li>  Do not have switchable or disabled items </li><li>  There should be a few items </li><li>  Should not be changed after it was set via setMenu </li></ul><br>  And a couple of comments: <br><ul><li>  The correct work of the dock is possible only in the case of a single application, use the dock with <a href="http://doc.qt.nokia.com/solutions/4/qtsingleapplication/">Qt Single Application</a> or other similar means. </li><li>  In badges it is better to use positive numbers less than 100. </li></ul><br>  In other cases, something will not be available in all platforms.  In principle, this is not fatal, but you need to remember this! <br>  Thanks to <a href="http://habrahabr.ru/users/torkve/" class="user_link">Torkve</a> for helping to implement the Unity plugin, <a href="http://habrahabr.ru/users/dtf/" class="user_link">dtf</a> for the tremendous help in implementing the Windows plugin and the QtCreator developers for helping to implement the Macos X version. <br>  Source code is available on <a href="https://github.com/gorthauer/QtDockTile">github</a> 'e.  Corrections and improvements are welcome. <br>  Shl <br>  Anyone wanting to implement the Dockmanager API? </div><p>Source: <a href="https://habr.com/ru/post/135443/">https://habr.com/ru/post/135443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135437/index.html">Dropbox is testing an automatic image upload feature.</a></li>
<li><a href="../135438/index.html">Migrating from ISA 2004/2006 to Forefront TMG</a></li>
<li><a href="../135439/index.html">Static code analyzer PC-Lint</a></li>
<li><a href="../135440/index.html">Google+ keeps track of how your finger is scratching your beard</a></li>
<li><a href="../135441/index.html">JXD S7100 - portable gaming console on Android OS</a></li>
<li><a href="../135444/index.html">Torvalds - 42. Do not panic!</a></li>
<li><a href="../135446/index.html">Apple patented YouTube icon for iOS</a></li>
<li><a href="../135448/index.html">ASUS ROG G74SX Review</a></li>
<li><a href="../135449/index.html">Clementine-player 1.0.0 released</a></li>
<li><a href="../135450/index.html">Electric Brainstorming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>