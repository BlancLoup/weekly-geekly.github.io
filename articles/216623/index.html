<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Managing JavaScript UI stream using WinJS scheduler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: the article describes the new task scheduler in the WinJS 2.0 library, updated with the release of Windows 8.1. To understand som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Managing JavaScript UI stream using WinJS scheduler</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: the article describes the new task scheduler in the WinJS 2.0 library, updated with the release of Windows 8.1.</i>  <i>To understand some of the material, it is highly desirable to understand how to work with deferred results (Promise).</i>  <i>See the MSDN section <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/hh700330.aspx">on asynchronous programming with JavaScript</a> .</i> <br><br>  Apart from web workers and background tasks, which are also executed as separate web processes, all JavaScript code in Windows Store applications is executed in the general so-called UI stream.  This code can make asynchronous calls to the WinRT API that perform their operations in separate threads, but there is one important point to keep in mind: the results from these non-UI threads are sent back to the UI stream for processing.  This means that launching a series of asynchronous calls to WinRT (for example, HTTP requests), all at once, can potentially overload the UI stream if the results come from them at about the same time.  Moreover, if you (or WinJS) add elements to the DOM or change the styles that require updating the page layout in the UI stream, this creates even more tasks competing for CPU resources.  As a result, your application becomes ‚Äúslowing down‚Äù and non-responsive. <br><br>  In Windows 8, an application can take a series of steps to reduce such effects, for example, run asynchronous operations within temporary blocks to control the frequency of returns to the UI stream, or combine tasks that require a page refresh cycle so that more operations are performed in one pass.  Starting from Windows 8.1, it became possible to asynchronously prioritize various tasks directly in the UI thread. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  Although the application host offers a low-level scheduler API ( <b>MSApp.executeAtPriority</b> ), we recommend using the <a href="http://msdn.microsoft.com/library/windows/apps/dn301978.aspx">WinJS.Utilities.Scheduler</a> API <a href="http://msdn.microsoft.com/library/windows/apps/dn301978.aspx">instead</a> .  The reasons for this recommendation are that WinJS manages its tasks through this scheduler API, which in turn means that any work that you manage in the same way will be properly coordinated with the work that WinJS does for you.  The WinJS scheduler also provides a simpler interface to the entire process, especially when it comes to working with pending results (promises). <br>  It is important to note that the use of a scheduler is not mandatory.  It is needed to help you tune the performance of your application, and not to complicate your life!  Let's first understand the different priorities that are used by the planner, and then we will see how to plan and manage the work with these priorities in mind. <br><br>  It is important to note that the use of a scheduler is not mandatory.  It is needed to help you tune the performance of your application, and not to complicate your life!  Let's first understand the different priorities that are used by the planner, and then we will see how to plan and manage the work with these priorities in mind. <br><br><h2>  Scheduler Priorities </h2><br>  The relative priorities for the WinJS scheduler are listed in the <a href="http://msdn.microsoft.com/library/windows/apps/dn301907.aspx">Scheduler.Priority</a> enumeration, in decreasing order they look like: <b>max</b> , <b>high</b> , <b>aboveNormal</b> , <b>normal</b> (default for application code), <b>belowNormal</b> , <b>idle</b> and <b>min</b> .  The following is a general guide to how best to use them: <br><br><ul><li>  max, high - use sparingly for tasks with a really high priority, since these priorities block the page rendering passes in the rendering process.  If you use these priorities too actively, the application may actually become less responsive. </li><li>  aboveNormal, normal, belowNormal - use to indicate relative importance for most important tasks. </li><li>  idle, min - use for long-running or supporting tasks that do not impose dependencies on the UI. </li></ul><br><br>  Although it is not necessary for you to use the scheduler in your code, a small analysis of the use of asynchronous operations will most likely reveal the places where prioritization can play a great role.  For example, you can prioritize non-UI work while the splash screen is displayed, because the splash screen is not interactive by definition, or send the most important HTTP requests with <b>max</b> or <b>high</b> priorities while setting secondary requests at <b>belowNormal</b> .  This will help to process those first requests before drawing the home page, on which the user expects interaction with the content, and then you can work out the secondary requests in the background.  Of course, if the user navigates to a page on which secondary content is needed, you can change the priority of this task to <b>aboveNormal</b> or <b>high</b> . <br><br>  The WinJS library itself is actively using prioritization.  For example, it will work out the source change blocks to bind data with a <b>high</b> priority, and scheduling cleaning tasks will be done with <b>idle</b> priority.  In complex controls, for example, ListView, requests for new items required for rendering the visible part of the ListView are done with maximum priority, rendering of visible items is done <b>above normal</b> , preloading the next page of items (forward) is <b>normal</b> (assuming that the user will scroll further), and the preloading of the previous page (for the case of reverse paging) is done on <b>belowNormal</b> . <br><br><h2>  Planning and Task Management </h2><br>  Now that we know the priorities of the scheduler, we can talk about what needs to be done in order to asynchronously execute code in the UI thread with the right priority.  To do this, call the <a href="http://msdn.microsoft.com/library/windows/apps/dn301941.aspx">Scheduler.schedule</a> method (the default priority is <b>normal</b> ).  This method gives you the opportunity to specify an optional object to use as this inside a function, as well as a name to use for logging and diagnostics.  (The <a href="http://msdn.microsoft.com/library/windows/apps/dn301933.aspx">Scheduler.execHigh</a> method is a short link to a direct <b>MSApp.execAtPriority</b> call with <b>Priority.high</b> priority. This method takes no additional arguments.) <br>  As a simple illustration, scenario 1 of the <a href="http://code.msdn.microsoft.com/windowsapps/HTML-Scheduler-Sample-4b8084f2">HTML Scheduler</a> example adds to the scheduler a set of functions with different priorities in some random (js / schedulesjobscenario.js): <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"\nScheduling Jobs..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S = WinJS.Utilities.Scheduler; S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Running job at aboveNormal priority"</span></span>); }, S.Priority.aboveNormal); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Scheduled job at aboveNormal priority"</span></span>); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Running job at idle priority"</span></span>); }, S.Priority.idle, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Scheduled job at idle priority"</span></span>); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Running job at belowNormal priority"</span></span>); }, S.Priority.belowNormal); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Scheduled job at belowNormal priority"</span></span>); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Running job at normal priority"</span></span>); }, S.Priority.normal); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Scheduled job at normal priority"</span></span>); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Running job at high priority"</span></span>); }, S.Priority.high); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Scheduled job at high priority"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Finished Scheduling Jobs\n"</span></span>);</code> </pre> <br><br>  The results window shows that ‚Äútasks‚Äù, when called, are executed in the expected order: <br><br><pre> <code class="hljs dos">Scheduling Jobs... Scheduled job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> aboveNormalPriority Scheduled job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> idlePriority Scheduled job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> belowNormalPriority Scheduled job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normalPriority Scheduled job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> highPriority Finished Scheduling Jobs Running job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> high priority Running job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> aboveNormal priority Running job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normal priority Running job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> belowNormal priority Running job <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> idle priority</code> </pre> <br><br>  I hope this is not a surprise for you! <br><br>  When you call the <b>schedule</b> method, you get back an object that satisfies the <a href="http://msdn.microsoft.com/library/windows/apps/dn255156.aspx">Scheduler.IJob</a> interface, which defines the following methods and properties: <br><br><h5>  Properties </h5><br><ul><li>  id - (read only) the unique id assigned by the scheduler. </li><li>  name - (read-write) the name of the task provided by the application, if one was specified (name-attribute in the schedule method). </li><li>  priority - (read-write) the priority assigned when accessing the scheduler;  setting the property will change the priority. </li><li>  completed - (read-only) A Boolean value indicating whether the task was completed (the function passed to the scheduler has completed, and all dependent asynchronous tasks have also been completed). </li><li>  owner - (read-write) owner flag used to group tasks.  Default is undefined. </li></ul><br><h5>  Methods </h5><br><ul><li>  pause - stops further execution of the task. </li><li>  resume - starts a previously paused task (no effect, if the task is not stopped). </li><li>  cancel - removes the task from the scheduler. </li></ul><br><br>  In practice, if you have planned a low priority task, but go to the page where you really need the task to complete before rendering, you simply update its <b>priority</b> property (and then clear the scheduler, as we will see very soon).  Similarly, if you have planned some work on the page and the need to continue it has disappeared when you move to another place, simply call the <b>cancel</b> method of your tasks in the page <b>unload</b> method.  Or perhaps you have a start page from which you usually go to the detailed and back.  In this case, you can pause ( <b>pause</b> ) any task on the start page when you go to the detailed one and then continue ( <b>resume</b> ) when you go back.  For a demonstration, see scenarios 2 and 3 in the example. <br><br>  Scenario 2 also shows the use of the <b>owner</b> property (the code is quite understandable, so you can easily study it yourself).  The owner's attribute (token) is created via the <a href="http://msdn.microsoft.com/library/windows/apps/dn301931.aspx">Scheduler.createOwnerToken</a> method, then assigned via the <b>owner</b> property of the task (this replaces the previous value).  The owner's attribute is simply an object with a single <a href="http://msdn.microsoft.com/library/windows/apps/dn255179.aspx">cancelAll</a> method that calls the <b>cancel</b> method for all tasks to which it is attached, and nothing more.  This is a simple mechanism, in reality it simply supports an array of tasks, but it allows you to group related tasks and cancel them with a single call.  Thus, you do not need to maintain your own lists and go through them for this action.  (To make a similar decision to pause and continue, of course, you can simply repeat this pattern in your code.) <br><br>  Another important feature of the scheduler is the <a href="http://msdn.microsoft.com/library/windows/apps/dn301934.aspx">requestDrain</a> method.  It allows you to make sure that all scheduled tasks with a given priority or higher will be executed before transferring control to the UI thread.  Typically, this is used to ensure that all high priority tasks are completed prior to drawing.  <b>requestDrain returns a</b> pending result (promise), which is implemented when all tasks are ‚Äúcleared‚Äù.  At this point, you can go to lower priority tasks or add new ones. <br><br>  A simple demonstration is in scenario 5 of the example.  It has two buttons that plan the same sets of different tasks and then call <b>requestDrain</b> with a high priority or priority <b>belowNormal</b> .  When the pending result is executed, the corresponding message is displayed (js / drainingscenario.js): <br><br><pre> <code class="javascript hljs">S.requestDrain(priority).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.output(<span class="hljs-string"><span class="hljs-string">"Done draining"</span></span>); });</code> </pre> <br><br>  If you compare the two outputs in parallel ( <b>high</b> on the left, <b>belowNormal</b> on the right), as indicated below, you will notice that the delayed result appears at different times depending on the priority: <br><br><pre> <code class="hljs dos">Draining scheduler to high priority | Draining scheduler to belowNormal priority Running job2 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> high priority | Running job2 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> high priority Done draining | Running job1 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normal priority Running job1 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normal priority | Running job5 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normal priority Running job5 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> normal priority | Running job4 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> belowNormal priority Running job4 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> belowNormal priority | Done draining Running job3 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> idle priority | Running job3 <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> idle priority</code> </pre> <br><br>  Another method defined in the scheduler is <a href="http://msdn.microsoft.com/library/windows/apps/dn301935.aspx">retrieveState</a> , a diagnostic tool that returns a description of current tasks or cleanup requests.  If in scenario 5 you add its call immediately after <b>requestDrain</b> , you will get the following results: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, priority: high <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">27</span></span>, priority: normal <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">31</span></span>, priority: normal <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span>, priority: belowNormal <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">29</span></span>, priority: idle n requests: *priority: high, name: Drain Request <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><br><h2>  Prioritization in a chain of pending results </h2><br>  Imagine that you have a set of asynchronous methods that request data that you want to execute sequentially, as described below, processing their results at each step: <br><br><pre> <code class="javascript hljs">getCriticalDataAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondaryPages = processCriticalData(results1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSecondaryDataAsync(secondaryPages); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemsToCache = processSecondaryData(results2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getBackgroundCacheDataAsync(itemsToCache); }).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results3</span></span></span><span class="hljs-function">) </span></span>{ populateCache(results3); });</code> </pre> <br><br>  By default, all this code will be executed with the current priority against the background of everything else that happens in the UI thread.  But you might want the <b>processCriticalData</b> function <b>to</b> execute with <b>high</b> priority, <b>processSecondaryData to</b> work in <b>normal</b> mode and <b>populateCache</b> in <b>idle</b> .  By working directly with the scheduler, you would have to do everything in a complicated way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S = WinJS.Utilities.Scheduler; getCriticalDataAsync().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results1</span></span></span><span class="hljs-function">) </span></span>{ S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondaryPages = processCriticalData(results1); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getSecondaryDataAsync(secondaryPages).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemsToCache = processSecondaryData(results2); S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getBackgroundCacheDataAsync(itemsToCache).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results3</span></span></span><span class="hljs-function">) </span></span>{ populateCache(results3); }); }, S.Priority.idle); }); }, S.Priority.normal); }, S.Priority.high); });</code> </pre> <br><br>  In our opinion, going to the dentist is more fun than writing such code!  For simplicity, you could wrap the process of setting a new priority inside another pending result, which in turn you would insert into the chain.  The best way to do this is to dynamically generate a handler for the completed event (completed), which takes the results from the previous step in the chain, schedules the execution with the right priority and returns the Promise object with the same result: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedulePromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  . return function completedHandler (results) { //     ,    //   ,   ... return new WinJS.Promise(function initializer (completeDispatcher) { //       . WinJS.Utilities.Scheduler.schedule(function () { completeDispatcher(results); }, priority); }); } }</span></span></code> </pre> <br><br>  Fortunately, we don‚Äôt have to write such code on our own.  <b>WinJS.Utilities.Scheduler</b> already contains five ready-made completion handlers like the one above, which also automatically cancel the task when an error occurs.  They are called accordingly: <a href="http://msdn.microsoft.com/library/windows/apps/dn301938.aspx">schedulePromiseHigh</a> , <a href="http://msdn.microsoft.com/library/windows/apps/dn301936.aspx">schedulePromiseAboveNormal</a> , <a href="http://msdn.microsoft.com/library/windows/apps/dn301940.aspx">schedulePromiseNormal</a> , <a href="http://msdn.microsoft.com/library/windows/apps/dn301937.aspx">schedulePromiseBelowNormal</a> and <a href="http://msdn.microsoft.com/library/windows/apps/dn301939.aspx">schedulePromiseIdle</a> . <br><br>  Having finished completion handlers, you just have to insert the correct method name in the chain of pending results where you want to change the priority, as shown below: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S = WinJS.Utilities.Scheduler; getCriticalDataAsync().then(S.schedulePromiseHigh).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondaryPages = processCriticalData(results1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSecondaryDataAsync(secondaryPages); }).then(S.schedulePromise.normal).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemsToCache = processSecondaryData(results2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getBackgroundCacheDataAsync(itemsToCache); }).then(S.schedulePromiseIdle).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results3</span></span></span><span class="hljs-function">) </span></span>{ populateCache(results3); });</code> </pre> <br><br>  For clarity: the use of these functions is only that you insert their names in the chain of deferred calls.  You do not need to call them directly as separate functions (this may not be completely clear in the current documentation). <br><br><h2>  Long living tasks </h2><br>  All the examples of jobs that we have considered at the moment are short-lived in the sense that we plan some work function with a certain priority and it just performs its work at the time of the call.  However, some tasks may require much more time to complete.  In this case, you hardly want to block work with a higher priority in your UI thread. <br><br>  To help in such situations, the scheduler has a built-in interval timer for sorting tasks that are planned with priorities <b>aboveNormal</b> or lower - so that the task can check whether it should not be ‚Äúcooperatively‚Äù supplanted and rescheduled for the next block of work.  Here we need to clarify the word ‚Äúcooperatively‚Äù: nothing forces the task to postpone its execution, but since this all affects the performance of the UI of your application, and indeed the whole application, if you do not handle these situations properly, you will harm yourself ! <br><br>  The implementation mechanism for such a maneuver is carried out through the <b>jobInfo</b> object, which is passed as an argument to the work function itself.  Let's first take a look at what is available for a function in its scope, it is easiest to understand from a few comments inside the base code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> job = WinJS.Utilities.Scheduler.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobInfo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//jobInfo.job ‚Äì   ,    . //Scheduler.currentPriority ‚Äì    . //this ‚Äì  ,  . }, S.Priority.idle, this);</span></span></code> </pre> <br><br>  The members of the <b>jobInfo</b> object <b>are</b> defined in the <a href="http://msdn.microsoft.com/library/windows/apps/dn255148.aspx">Scheduler.IJobInfo</a> interface: <br><br><h5>  Properties </h5><br><ul><li>  job - (read-only) the same object that is returned from <b>schedule</b> . </li><li>  shouldYield - (read only) Boolean flag, which is usually set to <b>false</b> when the task is first run and then <b>true</b> if the function is to be pushed out of the UI flow and its work needs to be rescheduled. </li></ul><br><br><h5>  Methods </h5><br><ul><li>  setWork is a function for rescheduling a task. </li><li>  setPromise is a delayed result, which the scheduler will wait for the task to be rescheduled, and the function for rescheduling is the value for the delayed result. </li></ul><br><br>  Scenario 4 of the <a href="http://code.msdn.microsoft.com/windowsapps/HTML-Scheduler-Sample-4b8084f2">HTML Scheduler</a> example shows how to work with this.  When you click the ‚ÄúExecute a Yielding Task‚Äù button, a function called <b>idle-</b> priority worker is added to the scheduler, which simply idle cycles until you press the ‚ÄúComplete Yielding Task‚Äù button, which sets the taskCompleted <b>flag</b> to <b>true</b> (js /yieldingscenario.js, with intervals of 2s, replaced by 200ms): <br><br><pre> <code class="javascript hljs">S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobInfo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!taskCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jobInfo.shouldYield) { <span class="hljs-comment"><span class="hljs-comment">//  ,      window.output("Yielding and putting idle job back on scheduler."); jobInfo.setWork(worker); break; } else { window.output("Running idle yielding job..."); var start = performance.now(); while (performance.now() &lt; (start + 200)) { //   ; } } } if (taskCompleted) { window.output("Completed yielding task."); taskCompleted = false; } }, S.Priority.idle);</span></span></code> </pre> <br><br>  If the task is active, it does ‚Äúwork‚Äù for <b>200 ms</b> and then checks whether the <b>shouldYield</b> property is <b>set</b> to <b>true</b> .  If so, the function <b>calls the setWork</b> method to reschedule itself (or another function, if necessary).  Such a transition can be provoked while the long task is working by clicking the ‚ÄúAdd Higher Priority Tasks to Queue‚Äù button in the example.  You will see how these tasks (with high priority) will work until the next call to the work function.  In addition, you can click anywhere else in the interface to make sure that this idle task does not block the UI thread. <br><br>  Notice that the working function checks <b>shouldYield</b> first to vytisnytsya immediately, if necessary.  However, it is quite normal to do a little work first, and then make a check.  Once again, this is a matter of cooperation within your own code, so your locks are on your own conscience. <br><br>  As for <b>setPromise</b> , this is a slightly more subtle idea.  Call the <b>setPromise</b> scheduler to wait until the pending result appears before rescheduling the task.  Moreover, the following work function for the task is provided directly through the value of the pending result.  (As such, the <b>IJobInfo.setPromise</b> method <b>does</b> not manage asynchronous operations, as do other <b>setPromise</b> methods inside WinJS, which in turn are tied to delay mechanisms in WinRT. If you called <b>IJobInfo.setPromise</b> with a delayed result from some random asynchronous API, the scheduler will try to use the execution value of this operation, - it can be anything, in the form of a function, which can lead to an exception.) <br><br>  In general, if <b>setWork</b> says "let's re-plan with this work function", then <b>setPromise</b> says "wait with re-planning, wait until I give you the necessary function sometime later."  This is usually convenient for creating a work queue made up of many jobs with an accompanying task for processing this queue.  To illustrate, imagine that you have the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> workQueue = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToQueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">worker</span></span></span><span class="hljs-function">) </span></span>{ workQueue.push(worker); } S.schedule(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processQueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobInfo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (work.length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jobInfo.shouldYield) { jobInfo.setWork(processQueue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } work.shift()(); <span class="hljs-comment"><span class="hljs-comment">//    FIFO-  . } }}, S.Priority.belowNormal);</span></span></code> </pre> <br><br>  Assuming that there are some jobs in the queue at the time of the first call to the scheduler, the <b>processQueue</b> task will ‚Äúcooperatively‚Äù release this queue.  And, if new jobs are added to the queue at run time, the <b>processQueue</b> will continue to be rescheduled for further execution. <br><br>  The problem, however, is that the processQueue function ends when the queue is empty, which means that whatever work you add to the queue will not be processed.  To fix this, you could force <b>processQueue to</b> periodically call <b>setWork</b> again and again, even if the queue is empty, but it would be a waste of resources.  Instead, you can set <b>setPromise</b> to make the scheduler wait until a new job appears in the queue.  Here's how it will work: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> workQueue = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> haveWork = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-comment"><span class="hljs-comment">//   function addToQueue(worker) { workQueue.push(worker); haveWork(); } S.schedule(function processQueue(jobInfo) { while (work.length) { if (jobInfo.shouldYield) { jobInfo.setWork(processQueue); return; } work.shift()(); //     FIFO-  . } //   ,  ,        . // ,   setWork  - ,   , //  ,  addToQueue   ,    ,  // haveWork ,     . jobInfo.setPromise(new WinJS.Promise(function (completeDispatcher) { haveWork = function () { completeDispatcher(processQueue) }; })) });</span></span></code> </pre> <br><br>  Within the framework of this code, suppose we filled out <b>workQueue with</b> some amount of work and then make a call to <b>schedule</b> .  At this point and the next, until the queue becomes empty, we are inside the <b>while loop of</b> the <b>processQueue</b> function.  Any call to the empty <b>haveWork</b> function <b>requires</b> virtually no additional operations. <br><br>  If the queue becomes empty, we exit the <b>while loop</b> , but do not want to exit the <b>processQueue</b> .  Instead, we want to tell the planner to wait until a new job is added to the queue.  That is why we have a stub for the <b>haveWork</b> function, which we will be able to replace with another function that completes the pending result in the <b>processQueue</b> and thus causes the rescheduling of the working function itself. <br><br>  Note that an alternative way to achieve the same goal would be to use the following assignment of the <b>haveWork</b> function: <br><br><pre> <code class="javascript hljs">haveWork = completeDispatcher.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, processQueue);</code> </pre> <br><br>  This gives the same result as an anonymous function, but without creating a closure. <br><br><h2>  Conclusion </h2><br>  The WinJS <b>Scheduler</b> API allows applications to schedule different tasks within a UI stream with relative priorities, including different tasks within a single chain of pending results.  At the same time, the application automatically coordinates its tasks with the tasks that WinJS performs for the same application, for example, optimizing data binding and drawing controls.  With careful use of the available priorities, the application can take notable steps toward improving overall performance and user experience. <br><br>  - Kraig Brockschmidt <br>  Program Manager, Windows Ecosystem and Frameworks Team <br>  Author of ‚Äú <a href="http://aka.ms/brockschmidtbook2">Programming Windows Store Apps with HTML, CSS, and JavaScript,</a> ‚Äù Second Edition <br><br><h4>  Links </h4><br>  <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/dn465795.aspx">Quick guide to working with the scheduler</a> <br>  <a href="http://code.msdn.microsoft.com/windowsapps/HTML-Scheduler-Sample-4b8084f2">HTML Scheduler Example</a> <br>  <a href="http://www.visualstudio.com/downloads/download-visual-studio-vs">Download Visual Studio 2013</a> </div><p>Source: <a href="https://habr.com/ru/post/216623/">https://habr.com/ru/post/216623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216605/index.html">Yii connection many to many</a></li>
<li><a href="../216609/index.html">The history of the creation of a torrent render for 3ds max</a></li>
<li><a href="../216615/index.html">Cubieboard A10. Learning to control the system from a remote control</a></li>
<li><a href="../216619/index.html">Volvo makes sure you don't fall asleep</a></li>
<li><a href="../216621/index.html">Competition from Veeam! The main prize is a $ 25,000 round-the-world trip for two, and not only</a></li>
<li><a href="../216625/index.html">Force Majeure with Alexei Kibkalo</a></li>
<li><a href="../216627/index.html">Tickets for AppSummit - iOS, Android, Windows and business on applications</a></li>
<li><a href="../216629/index.html">Twitter interface Android errors</a></li>
<li><a href="../216631/index.html">Estimated Bitcoin Transaction Base</a></li>
<li><a href="../216633/index.html">The logic of thinking. Part 15. Memory consolidation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>