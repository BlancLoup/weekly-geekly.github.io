<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About one method of memory allocation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is no secret that sometimes memory allocation requires separate solutions. For example - when memory is allocated and released by a fast ram flow, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About one method of memory allocation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/082/2c6/650/0822c6650b82cdb9e93115603a09667e.png" alt="image" align="left"><br>  It is no secret that sometimes memory allocation requires separate solutions.  For example - when memory is allocated and released by a fast <s>ram</s> flow, in parallel tasks. <br><br>  As a result, the standard conservative allocator builds all requests in the queue at the pthread_mutex / critical section.  And our multi-core processor is driving slowly and sadly in first gear. <br><br>  And what to do with it?  Let's take a closer look at the details of the implementation of the Scalable Lock-Free Dynamic Memory Allocation method.  Maged M. Michael.  IBM Thomas J. Watson Research Center. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The easiest code I managed to find was written under the LGPL comrades Scott Schneider and Christos Antonopoulos.  And consider it. <br><br><a name="habracut"></a><br><br><h4>  Let's start from afar </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1e2/c9f/1bb/1e2c9f1bb2b73e36ed6bbcbde2c9aaa6.png" alt="image" align="left"><br>  So - how do we get rid of unnecessary locks? <br><br>  The answer lies on the surface - it is necessary to allocate memory in the lock-free lists.  Good idea - but how are such lists built? <br><br>  Atomic operations are rushing to help us.  The ones that are InterlockedCompareExchange.  But wait, the maximum we can expect is a long long, aka __int64.  And what to do?  And that's what - we define our own pointer with the tag. <br><br>  By limiting the address size to 46 bits, we can hide the add-ons we need in 64bit integer, and they will be needed later. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(1) typedef struct { volatile unsigned __int64 top:46, ocount:18; } top_aba_t;</span></span></code> </pre> <br><br>  <i>By the way, with 8/16 byte alignment, we can get not 2 to 46 degrees, but a bit more.</i>  <i>Standard method - the address given cannot be odd and, moreover, must be aligned for a floating point.</i> <br><br>  And another point - the code becomes very long.  That is the standard footcloth <br><pre> <code class="cpp hljs">desc-&gt;Next = queue_head; queue_head = desc;</code> </pre><br>  turns into pasta like that <br><pre> <code class="cpp hljs"> descriptor_queue old_queue, new_queue; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { old_queue = queue_head; desc-&gt;Next = (descriptor*)old_queue.DescAvail; new_queue.DescAvail = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64)desc; new_queue.tag = old_queue.tag + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!compare_and_swap64k(queue_head, old_queue, new_queue));</code> </pre><br>  which greatly lengthens the code and makes it less readable.  Therefore, the obvious things are removed under spoilers. <br><br><h4>  Lock-free fifo queue </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/f3a/652/c5c/f3a652c5cf3fcf9bacc18657477c8bcc.png" alt="image" align="right"><br>  Since we now have our own pointer, we can go over the list. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Pseudostructure for lock-free list elements. // The only requirement is that the 5th-8th byte of // each element should be available to be used as // the pointer for the implementation of a singly-linked // list. struct queue_elem_t { char *_dummy; volatile queue_elem_t *next; };</span></span></code> </pre><br>  And in our case - do not forget about alignment, for example <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 _pad0[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">top_aba_t</span></span> both; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 _pad1[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">lf_fifo_queue_t</span></span>;</code> </pre><br><br><h5>  Wrapping work with atomic functions </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/bdb/560/647/bdb560647f9de8ec254698c1302eaa7b.png" alt="image" align="left"><br>  Now we define a couple of abstractions so that our code can be portable (for Win32, for example, this is implemented like this): <br><br><div class="spoiler">  <b class="spoiler_title">Atom Wrapper for Win32</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fetch_and_store(address, value) InterlockedExchange((PLONG)(address), (value)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> atmc_add(address, value) InterlockedExchangeAdd((PLONG)(address), (value)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> compare_and_swap32(address, old_value, new_value) \ (InterlockedCompareExchange(\ (PLONG)(address), (new_value), (old_value))\ == (old_value)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> compare_and_swap64(address, old_value, new_value) \ (InterlockedCompareExchange64(\ (PLONGLONG)(address), (__int64)(new_value), (__int64)(old_value)) \ == (__int64)(old_value)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> compare_and_swap_ptr(address, old_value, new_value) \ (InterlockedCompareExchangePointer((address), \ (new_value), (old_value)) \ == (old_value))</span></span></code> </pre><br></div></div><br>  and add another method, just to not be distracted by casting the parameters to __int64 and passing them along the pointers. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> compare_and_swap64k(a,b,c) \ compare_and_swap64((volatile unsigned __int64*)&amp;(a), \ *((unsigned __int64*)&amp;(b)), \ *((unsigned __int64*)&amp;(c)))</span></span></code> </pre><br>  And now we are ready to implement the basic functions (add and delete). <br><br><h5>  Determine the basic functions of the list </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/828/806/b17/828806b17f8e7a02dce7183739a4e4c9.png" alt="image" align="right"><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lf_fifo_enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lf_fifo_queue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">top_aba_t</span></span> old_top; <span class="hljs-keyword"><span class="hljs-keyword">top_aba_t</span></span> new_top; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { old_top.ocount = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.ocount; old_top.top = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.top; ((<span class="hljs-keyword"><span class="hljs-keyword">queue_elem_t</span></span> *)element)-&gt;next = (<span class="hljs-keyword"><span class="hljs-keyword">queue_elem_t</span></span> *)old_top.top; new_top.top = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64)element; new_top.ocount += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap64k(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both, old_top, new_top)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  What you need to pay attention to - the usual operation to add is wrapped in a loop, the output of which is that we have successfully written a new value over the old one, and at the same time the old one has not changed.  Well, if you change it, we repeat it all over again.  And another point - in our ocount we write down the number of the attempt with which we succeeded.  A trifle, and each attempt gives a unique 64bit integer. <br><br>  It is on such a simple shamanism that lock-free data structures are built. <br><br>  Similarly, the removal from the top of our FIFO list is implemented: <br><br><div class="spoiler">  <b class="spoiler_title">Similar to lf_fifo_dequeue</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lf_fifo_dequeue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lf_fifo_queue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">top_aba_t</span></span> head; <span class="hljs-keyword"><span class="hljs-keyword">top_aba_t</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { head.top = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.top; head.ocount = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.ocount; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (head.top == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; next.top = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64)(((struct <span class="hljs-keyword"><span class="hljs-keyword">queue_elem_t</span></span> *)head.top)-&gt;next); next.ocount += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap64k(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both, head, next)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)head.top); } }</code> </pre><br></div></div><br>  Here we see exactly the same thing - in a cycle we try to remove, if there is something, and we remove so that the old value is still correct - that is fine, but no - we try again. <br><br>  And of course, the initialization of such an element of the list is trivial - here it is: <br><br><div class="spoiler">  <b class="spoiler_title">lf_fifo_queue_init</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lf_fifo_queue_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lf_fifo_queue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.top = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;both.ocount = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br><br><h5>  Actually the idea of ‚Äã‚Äãthe allocator </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/292/07b/495/29207b495e0eb09fb87935a87bac4ded.png" alt="image" align="left"><br>  We now turn directly to the allocator.  The allocator must be fast ‚Äî so we divide the memory into classes.  Large (directly from the system), and small, beaten for many, many small subclasses ranging in size from 8 bytes to 2 kilobytes. <br><br>  Such a knight's move will allow us to solve two problems.  The first - small pieces will be allocated super-fast, and due to the fact that they are divided into a table - will not lie in one huge list.  And large pieces of memory will not interfere under your feet and lead to problems with fragmentation.  Moreover, since in each subclass we have all the blocks of the same size, working with them is very easy. <br><br>  And another moment!  Selection of small pieces we will tie to the threads (and the release - no).  Thus, we will kill two birds with one stone - the allocation control will be simplified, and the memory islands allocated to the thread locally - will not be mixed up once more. <br><br>  We get something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/1e7/4c9/445/1e74c9445fbe20b159a394586a7de058.jpg" alt="image"><br><br>  And this is how the data will be displayed on the superblock <br><img src="https://habrastorage.org/getpro/habr/post_images/c08/e69/aa2/c08e69aa2badc78cb6d318bb0fe652dc.jpg" alt="image"><br>  In the picture we see 4 cases <br><ol><li>  The active superblock contains 5 items organized into a list, 4 of them are available for use. </li><li>  And now we have reserved the next item (see credits) </li><li>  As a result, they gave out block number 5. </li><li>  And then it was returned back (but it hit the partial list) </li></ol><br><br><h5>  We describe the block hip and handle </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/e7c/cf6/9d4/e7ccf69d4e77bab7f60e21be8e5ff39f.png" alt="image" align="left"><br>  Praying to the goddess Techno, let's get started. <br><br>  Define a couple of constants <br><br><div class="spoiler">  <b class="spoiler_title">Balnalschina a la GRANULARITY and PAGE_SIZE</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Descriptor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Descriptor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">descriptor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Procheap</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Procheap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">procheap</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPE_SIZE sizeof(void*) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PTR_SIZE sizeof(void*) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_SIZE (TYPE_SIZE + PTR_SIZE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SMALL 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAGESIZE 4096 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SBSIZE (16 * PAGESIZE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DESCSBSIZE (1024 * sizeof(descriptor)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACTIVE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FULL 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PARTIAL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXCREDITS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 2^(bits for credits in active) #define GRANULARITY 8</span></span></span></span></code> </pre><br></div></div><br>  And we will be engaged in a creative, we will define the necessary data types.  So, we will have many hipov - each in its class, but tied to the current thread.  There will be two pointers in the superblock - the active list and the redistributed one. <br><br>  You ask - what is it and why is it so difficult? <br><br>  First, it‚Äôs the main thing - to single out the list elementwise is trivially unprofitable.  That is - the classic unidirectional list with millions of elements turns into hell and Israel.  For each element of the list, you need to allocate 8/16 bytes in order to store two unfortunate pointers to the data itself and to the next element of the list. <br><br>  Is it profitable?  Obviously - no!  And what should you do?  That's right, but let's group our list descriptors into groups (stripe) by 500 (for example) items.  And we get a list of not elements, but - groups.  Economically, practically, it is possible to work with elements as in the classic version.  The whole question is only in non-standard memory allocation. <br><br>  Moreover, all the Next within the block simply point to the neighboring element of the array, and we can explicitly initialize them immediately when the stripe is selected.  In fact, the last Next in a stripe will indicate the next stripe, but from the point of view of working with lists, nothing changes. <br><br>  It is easy to guess that the lists of memory block descriptors are built that way. <br><br>  And yet - Active is our active stripe with pre-allocated pieces of memory on an enByte, in which we conduct memory allocation on the FIFO principle.  If there is a place in the stripe - we take from there.  If not, we are already looking for the Partial classic list.  If there is neither there nor there - well, select a new stripe. <br><br>  Secondly, such ‚Äúbanding‚Äù leads to some memory overuse, since we can allocate a stripe for 8 byte memory pieces as an array in 64K, and a couple of pieces will be requested.  And yet, active stripes for each thread is its own, which will further aggravate the problem. <br><br>  However, if we are really actively working with memory, it will give a good gain in speed. <br><br>  Here is the hip itself <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Procheap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> active Active; <span class="hljs-comment"><span class="hljs-comment">// initially NULL volatile descriptor* Partial; // initially NULL sizeclass* sc; // pointer to parent sizeclass };</span></span></code> </pre><br>  But what he needs: <br><br><div class="spoiler">  <b class="spoiler_title">What is this Active / Partial such</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 ptr:<span class="hljs-number"><span class="hljs-number">58</span></span>, credits:<span class="hljs-number"><span class="hljs-number">6</span></span>; } active; <span class="hljs-comment"><span class="hljs-comment">/* We need to squeeze this in 64-bits, but conceptually * this is the case: * descriptor* DescAvail; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 DescAvail:<span class="hljs-number"><span class="hljs-number">46</span></span>, tag:<span class="hljs-number"><span class="hljs-number">18</span></span>; } descriptor_queue; <span class="hljs-comment"><span class="hljs-comment">/* Superblock descriptor structure. We bumped avail and count * to 24 bits to support larger superblock sizes. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 avail:<span class="hljs-number"><span class="hljs-number">24</span></span>,count:<span class="hljs-number"><span class="hljs-number">24</span></span>, state:<span class="hljs-number"><span class="hljs-number">2</span></span>, tag:<span class="hljs-number"><span class="hljs-number">14</span></span>; } anchor; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lf_fifo_queue_t</span></span> Partial; <span class="hljs-comment"><span class="hljs-comment">// initially empty unsigned int sz; // block size unsigned int sbsize; // superblock size } sizeclass;</span></span></code> </pre><br></div></div><br><br>  and the descriptor itself is a handle to our fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Descriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">queue_elem_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lf_fifo_queue_padding</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> anchor Anchor; <span class="hljs-comment"><span class="hljs-comment">// anchor to superblock exact place descriptor* Next; // next element in list void* sb; // pointer to superblock procheap* heap; // pointer to owner procheap unsigned int sz; // block size unsigned int maxcount; // superblock size / sz };</span></span></code> </pre> <br>  As you can see - nothing supernatural.  We need the description of the hip and the superblock in the descriptor, since it is possible to allocate memory in one thread, and free it in another. <br><br><h5>  Let's start the implementation </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/805/199/e10/805199e107707e23b8ac2f523b2013e8.png" alt="image" align="left"><br>  First we need to define our local variables ‚Äî hips, sizes, and so on.  Something like this: <br><br><div class="spoiler">  <b class="spoiler_title">As without global variables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This is large and annoying, but it saves us from needing an * initialization routine. */</span></span> sizeclass sizeclasses[<span class="hljs-number"><span class="hljs-number">2048</span></span> / GRANULARITY] = { {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">8</span></span>, SBSIZE}, {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">16</span></span>, SBSIZE}, ... {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">2024</span></span>, SBSIZE}, {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">2032</span></span>, SBSIZE}, {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">2040</span></span>, SBSIZE}, {LF_FIFO_QUEUE_STATIC_INIT, <span class="hljs-number"><span class="hljs-number">2048</span></span>, SBSIZE}, }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LF_FIFO_QUEUE_STATIC_INIT {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}} __declspec(thread) procheap* heaps[2048 / GRANULARITY]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// = { }; static volatile descriptor_queue queue_head;</span></span></span></span></code> </pre><br></div></div><br>  Here we see everything that was considered in the previous section: <br><br><pre> <code class="cpp hljs">__declspec(thread) procheap* heaps[<span class="hljs-number"><span class="hljs-number">2048</span></span> / GRANULARITY]; <span class="hljs-comment"><span class="hljs-comment">// = { }; static volatile descriptor_queue queue_head;</span></span></code> </pre><br>  This is our per thread heaps.  And - a list of all per-process descriptors. <br><br><h5>  Malloc - how it works </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f31/6cb/4e7f316cb3c2aa2703136962503519ea.png" alt="image" align="left"><br>  Consider the actual memory allocation process in more detail.  It is easy to see a few features, namely: <br><br><ol><li>  If the requested size does not have our hip for small sizes, simply request from the system </li><li>  We allocate memory in turn - first from the active list, then from the list of fragments, and finally - try to request a new piece from the system. </li><li>  We always have memory in the system, and if not, we just need to wait in the loop. </li></ol><br><br>  Here is a solution. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sz)</span></span></span><span class="hljs-function"> </span></span>{ procheap *heap; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* addr; <span class="hljs-comment"><span class="hljs-comment">// Use sz and thread id to find heap. heap = find_heap(sz); if (!heap) // Large block return alloc_large_block(sz); for(;;) { addr = MallocFromActive(heap); if (addr) return addr; addr = MallocFromPartial(heap); if (addr) return addr; addr = MallocFromNewSB(heap); if (addr) return addr; } }</span></span></code> </pre> <br>  Delve into the topic, consider each part separately.  Let's start from the beginning - by adding a new piece from the system. <br><br><div class="spoiler">  <b class="spoiler_title">MallocFromNewSB</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MallocFromNewSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap* heap)</span></span></span><span class="hljs-function"> </span></span>{ descriptor* desc; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* addr; active newactive, oldactive; *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64*)&amp;oldactive) = <span class="hljs-number"><span class="hljs-number">0</span></span>; desc = DescAlloc(); desc-&gt;sb = AllocNewSB(heap-&gt;sc-&gt;sbsize, SBSIZE); desc-&gt;heap = heap; desc-&gt;Anchor.avail = <span class="hljs-number"><span class="hljs-number">1</span></span>; desc-&gt;sz = heap-&gt;sc-&gt;sz; desc-&gt;maxcount = heap-&gt;sc-&gt;sbsize / desc-&gt;sz; <span class="hljs-comment"><span class="hljs-comment">// Organize blocks in a linked list starting with index 0. organize_list(desc-&gt;sb, desc-&gt;maxcount, desc-&gt;sz); *((unsigned __int64*)&amp;newactive) = 0; newactive.ptr = (__int64)desc; newactive.credits = min(desc-&gt;maxcount - 1, MAXCREDITS) - 1; desc-&gt;Anchor.count = max(((signed long)desc-&gt;maxcount - 1 ) - ((signed long)newactive.credits + 1), 0); // max added by Scott desc-&gt;Anchor.state = ACTIVE; // memory fence. if (compare_and_swap64k(heap-&gt;Active, oldactive, newactive)) { addr = desc-&gt;sb; *((char*)addr) = (char)SMALL; addr = (char*) addr + TYPE_SIZE; *((descriptor **)addr) = desc; return (void *)((char*)addr + PTR_SIZE); } else { //Free the superblock desc-&gt;sb. munmap(desc-&gt;sb, desc-&gt;heap-&gt;sc-&gt;sbsize); DescRetire(desc); return NULL; } }</span></span></code> </pre><br></div></div><br>  No miracles - just creating a superblock, a descriptor, and initializing an empty list.  And adding to the list of active new block.  Here I ask you to pay attention to the fact that there is no assignment loop.  If it failed, then it failed.  Why is that?  Because the function is already called from the loop, and if it was not possible to insert it into the list, it means that someone else inserted it and it is necessary to allocate the memory first. <br><br>  We now turn to the selection of a block from the list of active ones - after all, we have already learned how to select the superblock and so on. <br><br><div class="spoiler">  <b class="spoiler_title">MallocFromActive</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MallocFromActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap *heap)</span></span></span><span class="hljs-function"> </span></span>{ active newactive, oldactive; descriptor* desc; anchor oldanchor, newanchor; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* addr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 morecredits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// First step: reserve block do { newactive = oldactive = heap-&gt;Active; if (!(*((unsigned __int64*)(&amp;oldactive)))) return NULL; if (oldactive.credits == 0) *((unsigned __int64*)(&amp;newactive)) = 0; else --newactive.credits; } while (!compare_and_swap64k(heap-&gt;Active, oldactive, newactive)); // Second step: pop block desc = mask_credits(oldactive); do { // state may be ACTIVE, PARTIAL or FULL newanchor = oldanchor = desc-&gt;Anchor; addr = (void *)((unsigned __int64)desc-&gt;sb + oldanchor.avail * desc-&gt;sz); next = *(unsigned long *)addr; newanchor.avail = next; ++newanchor.tag; if (oldactive.credits == 0) { // state must be ACTIVE if (oldanchor.count == 0) newanchor.state = FULL; else { morecredits = min(oldanchor.count, MAXCREDITS); newanchor.count -= morecredits; } } } while (!compare_and_swap64k(desc-&gt;Anchor, oldanchor, newanchor)); if (oldactive.credits == 0 &amp;&amp; oldanchor.count &gt; 0) UpdateActive(heap, desc, morecredits); *((char*)addr) = (char)SMALL; addr = (char*) addr + TYPE_SIZE; *((descriptor**)addr) = desc; return ((void*)((char*)addr + PTR_SIZE)); }</span></span></code> </pre> </div></div><br>  The algorithm itself is simple, only a cumbersome form of recording confuses us slightly.  In fact, if you have something to take, then we take a new piece from the superblock, and note this fact.  Along the way, we check to see if we took the last piece, and if so, mark that. <br><br>  There is a roano here, one subtlety, namely, if it suddenly turned out that we took the last piece from the superblock, then the next query after us will lead to the addition of a new superblock in exchange for the already used one.  And as soon as we discovered this, we have nowhere to write down the fact that the block is selected.  Therefore, we enter the newly selected piece in the partial list. <br><br><div class="spoiler">  <b class="spoiler_title">UpdateActive</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap* heap, descriptor* desc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __int64 morecredits)</span></span></span><span class="hljs-function"> </span></span>{ active oldactive, newactive; anchor oldanchor, newanchor; *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64*)&amp;oldactive) = <span class="hljs-number"><span class="hljs-number">0</span></span>; newactive.ptr = (__int64)desc; newactive.credits = morecredits - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap64k(heap-&gt;Active, oldactive, newactive)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Someone installed another active sb // Return credits to sb and make it partial do { newanchor = oldanchor = desc-&gt;Anchor; newanchor.count += morecredits; newanchor.state = PARTIAL; } while (!compare_and_swap64k(desc-&gt;Anchor, oldanchor, newanchor)); HeapPutPartial(desc); }</span></span></code> </pre> </div></div><br>  It is time to consider working with descriptors before we get to the final part of this essay. <br><br><h5>  Memory Block Descriptors </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/577/76c/937/57776c937b3dbf4f31b5ce44e9a68f6b.png" alt="image" align="left"><br>  For starters, learn how to create a descriptor.  But where?  Actually, if anyone has forgotten - we are just writing a memory allocation.  An obvious and beautiful solution would be to use the same mechanisms as for the generic allocation, but alas, it would be the well-known joke pkunzip.zip.  Therefore, the principle is the same - we select a large block containing an array of descriptors, and as soon as the array is full, we create a new one and combine it with the previous one into the list. <br><br><div class="spoiler">  <b class="spoiler_title">DescAlloc</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> descriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DescAlloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ descriptor_queue old_queue, new_queue; descriptor* desc; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { old_queue = queue_head; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_queue.DescAvail) { new_queue.DescAvail = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64)((descriptor*)old_queue.DescAvail)-&gt;Next; new_queue.tag = old_queue.tag + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap64k(queue_head, old_queue, new_queue)) { desc = (descriptor*)old_queue.DescAvail; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { desc = AllocNewSB(DESCSBSIZE, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(descriptor)); organize_desc_list((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)desc, DESCSBSIZE / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(descriptor), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(descriptor)); new_queue.DescAvail = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)desc-&gt;Next; new_queue.tag = old_queue.tag + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap64k(queue_head, old_queue, new_queue)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; munmap((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)desc, DESCSBSIZE); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desc; }</code> </pre> </div></div><br>  Well, now it's up to a no less powerful witch - you also have to learn how to return the descriptor back.  However, we will return in the same FIFO - because we will need to return only if we took it by mistake, and this fact is revealed immediately.  So it turns out to be much easier. <br><br><div class="spoiler">  <b class="spoiler_title">DescRetire</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DescRetire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(descriptor* desc)</span></span></span><span class="hljs-function"> </span></span>{ descriptor_queue old_queue, new_queue; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { old_queue = queue_head; desc-&gt;Next = (descriptor*)old_queue.DescAvail; new_queue.DescAvail = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64)desc; new_queue.tag = old_queue.tag + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!compare_and_swap64k(queue_head, old_queue, new_queue)); }</code> </pre> </div></div><br><br><h5>  Helpers </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/3f8/c05/f05/3f8c05f05edba4613d4e383876eb39f7.png" alt="image" align="left"><br>  We also give auxiliary functions for initializing lists, etc. The functions are so self-evident that there is no sense even to describe them. <br><div class="spoiler">  <b class="spoiler_title">organize_list</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">organize_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i; ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { ptr += stride; *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)ptr) = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">organize_desc_list</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">organize_desc_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(descriptor* start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; start-&gt;Next = (descriptor*)(start + stride); ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { ptr += stride; ((descriptor*)ptr)-&gt;Next = (descriptor*)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptr + stride); } ptr += stride; ((descriptor*)ptr)-&gt;Next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">mask_credits</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> descriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mask_credits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(active oldactive)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (descriptor*)oldactive.ptr; }</code> </pre> </div></div><br>  The superblock is simply requested from the system: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllocNewSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alignement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VirtualAlloc(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, size, MEM_COMMIT, PAGE_READWRITE); }</code> </pre> <br>  Similarly, we get large blocks by requesting a little more under the block header: <br><div class="spoiler">  <b class="spoiler_title">alloc_large_block</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc_large_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* addr = VirtualAlloc(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, sz + HEADER_SIZE, MEM_COMMIT, PAGE_READWRITE); <span class="hljs-comment"><span class="hljs-comment">// If the highest bit of the descriptor is 1, then the object is large // (allocated / freed directly from / to the OS) *((char*)addr) = (char)LARGE; addr = (char*) addr + TYPE_SIZE; *((unsigned long *)addr) = sz + HEADER_SIZE; return (void*)((char*)addr + PTR_SIZE); }</span></span></code> </pre> </div></div><br>  And this is a search in our hip table adapted to the desired size (bkb zero if the size is too large): <br><div class="spoiler">  <b class="spoiler_title">find_heap</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> procheap* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_heap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sz)</span></span></span><span class="hljs-function"> </span></span>{ procheap* heap; <span class="hljs-comment"><span class="hljs-comment">// We need to fit both the object and the descriptor in a single block sz += HEADER_SIZE; if (sz &gt; 2048) return NULL; heap = heaps[sz / GRANULARITY]; if (heap == NULL) { heap = VirtualAlloc(NULL, sizeof(procheap), MEM_COMMIT, PAGE_READWRITE); *((unsigned __int64*)&amp;(heap-&gt;Active)) = 0; heap-&gt;Partial = NULL; heap-&gt;sc = &amp;sizeclasses[sz / GRANULARITY]; heaps[sz / GRANULARITY] = heap; } return heap; }</span></span></code> </pre> </div></div><br>  And here are wrappers for lists.  They are added solely for clarity - we have more than enough code with macaroni around the atomics, so that in one function yt we add ten cycles around compare and swap. <br><div class="spoiler">  <b class="spoiler_title">ListGetPartial</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> descriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListGetPartial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeclass* sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (descriptor*)lf_fifo_dequeue(&amp;sc-&gt;Partial); }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">ListPutPartial</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListPutPartial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(descriptor* desc)</span></span></span><span class="hljs-function"> </span></span>{ lf_fifo_enqueue(&amp;desc-&gt;heap-&gt;sc-&gt;Partial, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)desc); }</code> </pre></div></div><br>  The deletion is built in the simplest way - by rebuilding the list into a temporary one and back: <br><div class="spoiler">  <b class="spoiler_title">ListRemoveEmptyDesc</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListRemoveEmptyDesc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeclass* sc)</span></span></span><span class="hljs-function"> </span></span>{ descriptor *desc; <span class="hljs-keyword"><span class="hljs-keyword">lf_fifo_queue_t</span></span> temp = LF_FIFO_QUEUE_STATIC_INIT; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (desc = (descriptor *)lf_fifo_dequeue(&amp;sc-&gt;Partial)) { lf_fifo_enqueue(&amp;temp, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)desc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (desc-&gt;sb == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) DescRetire(desc); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (desc = (descriptor *)lf_fifo_dequeue(&amp;temp)) lf_fifo_enqueue(&amp;sc-&gt;Partial, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)desc); }</code> </pre> </div></div><br>  And a few wrappers around partial lists <br><div class="spoiler">  <b class="spoiler_title">RemoveEmptyDesc</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveEmptyDesc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap* heap, descriptor* desc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare_and_swap_ptr(&amp;heap-&gt;Partial, desc, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) DescRetire(desc); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ListRemoveEmptyDesc(heap-&gt;sc); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">HeapGetPartial</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> descriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HeapGetPartial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap* heap)</span></span></span><span class="hljs-function"> </span></span>{ descriptor* desc; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { desc = *((descriptor**)&amp;heap-&gt;Partial); <span class="hljs-comment"><span class="hljs-comment">// casts away the volatile if (desc == NULL) return ListGetPartial(heap-&gt;sc); } while (!compare_and_swap_ptr(&amp;heap-&gt;Partial, desc, NULL)); return desc; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">HeapPutPartial</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HeapPutPartial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(descriptor* desc)</span></span></span><span class="hljs-function"> </span></span>{ descriptor* prev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { prev = (descriptor*)desc-&gt;heap-&gt;Partial; <span class="hljs-comment"><span class="hljs-comment">// casts away volatile } while (!compare_and_swap_ptr(&amp;desc-&gt;heap-&gt;Partial, prev, desc)); if (prev) ListPutPartial(prev); }</span></span></code> </pre> </div></div><br><br><h5>  The last spurt - and select / release ready! </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/b3e/488/a97/b3e488a978e0e0aacda545b78bb657e7.png" alt="image" align="left"><br>  And finally, we are ready to realize memory allocation not in a stripe, we already have all the possibilities for this. <br><br>  The algorithm is simple - we find our list, reserve a place in it (freeing up empty blocks at the same time), and return it to the client. <br><br><div class="spoiler">  <b class="spoiler_title">MallocFromPartial</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MallocFromPartial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(procheap* heap)</span></span></span><span class="hljs-function"> </span></span>{ descriptor* desc; anchor oldanchor, newanchor; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 morecredits; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* addr; retry: desc = HeapGetPartial(heap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!desc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; desc-&gt;heap = heap; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-comment"><span class="hljs-comment">// reserve blocks newanchor = oldanchor = desc-&gt;Anchor; if (oldanchor.state == EMPTY) DescRetire(desc); goto retry; } // oldanchor state must be PARTIAL // oldanchor count must be &gt; 0 morecredits = min(oldanchor.count - 1, MAXCREDITS); newanchor.count -= morecredits + 1; newanchor.state = morecredits &gt; 0 ? ACTIVE : FULL; } while (!compare_and_swap64k(desc-&gt;Anchor, oldanchor, newanchor)); do { // pop reserved block newanchor = oldanchor = desc-&gt;Anchor; addr = (void*)((unsigned __int64)desc-&gt;sb + oldanchor.avail * desc-&gt;sz); newanchor.avail = *(unsigned long*)addr; ++newanchor.tag; } while (!compare_and_swap64k(desc-&gt;Anchor, oldanchor, newanchor)); if (morecredits &gt; 0) UpdateActive(heap, desc, morecredits); *((char*)addr) = (char)SMALL; addr = (char*) addr + TYPE_SIZE; *((descriptor**)addr) = desc; return ((void *)((char*)addr + PTR_SIZE)); }</span></span></code> </pre> </div></div><br>  Now consider how to get us back to the list of memory.  In general, the classic algorithm: we retrieve the handle by the pointer given to us, and by the anchor stored in the handle we get to the place of the superblock we need and mark the desired piece as free, and who still read the beer.  And of course, a couple of checks - if we don‚Äôt need to free the entire superblock, otherwise it‚Äôs the last one that has not been released. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr)</span></span></span><span class="hljs-function"> </span></span>{ descriptor* desc; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* sb; anchor oldanchor, newanchor; procheap* heap = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// get prefix ptr = (void*)((char*)ptr - HEADER_SIZE); if (*((char*)ptr) == (char)LARGE) { munmap(ptr, *((unsigned long *)((char*)ptr + TYPE_SIZE))); return; } desc = *((descriptor**)((char*)ptr + TYPE_SIZE)); sb = desc-&gt;sb; do { newanchor = oldanchor = desc-&gt;Anchor; *((unsigned long*)ptr) = oldanchor.avail; newanchor.avail = ((char*)ptr - (char*)sb) / desc-&gt;sz; if (oldanchor.state == FULL) newanchor.state = PARTIAL; if (oldanchor.count == desc-&gt;maxcount - 1) { heap = desc-&gt;heap; // instruction fence. newanchor.state = EMPTY; } else ++newanchor.count; // memory fence. } while (!compare_and_swap64k(desc-&gt;Anchor, oldanchor, newanchor)); if (newanchor.state == EMPTY) { munmap(sb, heap-&gt;sc-&gt;sbsize); RemoveEmptyDesc(heap, desc); } else if (oldanchor.state == FULL) HeapPutPartial(desc); }</span></span></code> </pre> <br>      ‚Äî     partial list,       ‚Äî         Active ,        ¬´    ¬ª.       . <br><br><h4>  findings </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/d31/c44/66a/d31c4466a9f9f209ecacf02bd4966c7d.png" alt="image" align="left"><br>                lock-free FIFO lists,     ,        . ,              . <br><br>  Additional materials <br><br><ol><li> <a href="http://redlinernotes.com/docs/Classics/Later_on/Scalable%2520Lock-Free%2520Dynamic%2520Memory%2520Allocation.pdf">Scalable Lock-Free Dynamic Memory Allocation</a> </li><li> <a href="http://en.wikipedia.org/wiki/Hoard_memory_allocator">Hoard memory allocator</a> </li><li> <a href="http://haiocl.googlecode.com/svn-history/r21/trunk/doc/papers/ismm06.pdf">Scalable Locality-ConsciousMultithreaded Memory Allocation</a> </li></ol><br><br>   ,     [3]      ( ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe7/059/503/fe70595039e1bc71348474cd3b0b3440.jpg" alt="image"><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6a/e22/758/c6ae22758f023dc3902076d32e9f79c2.jpg" alt="image"></a> <br>  ,     ,      ,      . <br><br> <b>Update:</b>  <a href="https://habrahabr.ru/users/skidanovalex/" class="user_link">SkidanovAlex</a>   : <br><br>    ,   ocount.     tagged pointer.   ,      ,       ( <a href="http://en.wikipedia.org/wiki/ABA_problem"> ABA</a> ‚Äî       top_aba_t): <br><br>   pop   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> snapshot = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>-&gt;head; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next = snapshot-&gt;next; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cas(&amp;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>-&gt;head, next, snapshot));</code> </pre><br>    deque     ,   ocount.    :      ,    B (   A -&gt; B).   snapshot = A, next = B. <br><br>        A,    C,    .    : <br> A -&gt; C -&gt; B. <br><br>  pop ,   CAS  (stack-&gt;head == snapshot,    A),   stack-&gt;head  B.  C . <br><br>  ocount   ,    A    ocount,  CAS . <br><br>  ocount     .        snapshot  next     A 2^18 ,  ocount       ,  ABA   . <br><br>          48 .     64- ,  ,   ,   ocount (           ),   double cas. </div><p>Source: <a href="https://habr.com/ru/post/162187/">https://habr.com/ru/post/162187/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162177/index.html">Megaphone launched the UMS service (Unified Messaging Solution), and the beta version of the client on Google Play. New competitor Whatsapp, Joyn, and IMO.IM?</a></li>
<li><a href="../162179/index.html">A billion-dollar high-tech software company is created in the USA every 3 months.</a></li>
<li><a href="../162181/index.html">Monitoring messages and calls to Android</a></li>
<li><a href="../162183/index.html">New Samsung NX lenses are on sale</a></li>
<li><a href="../162185/index.html">Library for working with QIWI through SOAP</a></li>
<li><a href="../162189/index.html">Working with Intelligent Disaster Recovery in Symantec Backup Exec</a></li>
<li><a href="../162191/index.html">Google Nexus 4 can work with LTE, but not everywhere</a></li>
<li><a href="../162193/index.html">Global Local Area Network</a></li>
<li><a href="../162195/index.html">No man is an island</a></li>
<li><a href="../162197/index.html">Bytes do not fit into the metric system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>