<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We get acquainted with the alpha version of snapshots volumes in Kubernetes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : The original article was recently published on the Kubernetes blog and written by Google and Huawei (Jing Xu, Xing Yang, Saad Ali), whos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We get acquainted with the alpha version of snapshots volumes in Kubernetes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: The original article was recently published on the Kubernetes blog and written by Google and Huawei (Jing Xu, Xing Yang, Saad Ali), whose activities you will certainly see in the GitHub project if you have ever been interested in the K8s features and problems with data storage.</i>  <i>Engineers talk about the purpose of volume snapshots, their current capabilities and the basics of working with them.</i> <a name="habracut"></a><br><br>  Kubernetes v1.12 presented an alpha version of snapshot support for volumes.  This feature allows you to create and delete snapshots of volumes, as well as create new volumes from snapshots using the ‚Äúnative‚Äù means of the system - through the Kubernetes API. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What is snapshot? </h2><br>  Many storage systems (like Google Cloud Persistent Disks, Amazon Elastic Block Storage and numerous on-premise storage systems) offer the ability to create snapshots (snapshots) for a persistent volume.  A snapshot is a copy of a volume at a specific point in time.  It can be used to provision a new volume (already filled with data from snapshot) or restore an existing volume to the previous state (which is represented in snapshot). <br><br><h2>  Why add snapshots to Kubernetes? </h2><br>  A powerful abstraction is available in the plugin system of the Kubernetes volumes that automates the provisioning, mounting and mounting of block and file storages. <br><br>  Ensuring all of these capabilities is part of Kubernetes workload portability goals: Kubernetes strives to create a level of abstraction between applications running as distributed systems and underlying clusters in such a way that applications do not depend on the specifics of the cluster on which they are running and does not require application deployment any cluster-specific knowledge. <br><br>  The <a href="https://github.com/kubernetes/community/tree/master/sig-storage">Kubernetes Storage SIG</a> team <a href="https://github.com/kubernetes/community/tree/master/sig-storage">identified the snapshot</a> operations as critical opportunities for many stateful workloads.  For example, a database administrator may want to snapshot his database before performing any operation with it. <br><br>  With the standard way to invoke snapshot operations in Kubernetes API, Kubernetes users can work with them without the need for workarounds (and manually invoking storage-specific operations).  Instead, users were given the opportunity to embed snapshot operations into their tools and policies with the calm understanding that everything will work with any Kubernetes clusters, regardless of the underlying storage. <br><br>  In addition, these Kubernetes primitives function as basic building blocks, opening up possibilities for developing more advanced enterprise-level storage management features ‚Äî for example, data protection, replication, and migration. <br><br><h2>  What volume plugins support snapshots in Kubernetes? </h2><br>  Kubernetes supports three types of volume plugins: in-tree, Flex, and CSI.  See the <a href="">Kubernetes Volume Plugin FAQ for</a> details. <br><br>  Snapshots are supported only for CSI drivers (they are not supported for in-tree or for Flex).  To take advantage of this opportunity, make sure that the Kubernetes cluster has a CSI driver deployed that supports snapshots. <br><br>  By the time of this blog post <i>(October 9, 2018 - <b>approx. Transl.</b> )</i> , Snapshots are supported by the following CSI drivers: <br><br><ul><li>  <a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a> ; </li><li>  <a href="https://github.com/opensds/nbp/tree/master/csi/server">OpenSDS</a> ; </li><li>  <a href="https://github.com/ceph/ceph-csi/tree/master/pkg/rbd">Ceph rbd</a> </li><li>  <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">Portworx</a> </li></ul><br>  Support for snapshots for <a href="https://kubernetes-csi.github.io/docs/Drivers.html">other drivers</a> is in development and should be available soon.  More details about CSI and how to deploy CSI drivers are described in the ‚Äú <a href="https://kubernetes.io/blog/2018/04/10/container-storage-interface-beta/">Container Storage Interface (CSI) for Kubernetes Goes Beta</a> ‚Äù publication <i>(also see our translation of the note ‚Äú <a href="https://habr.com/company/flant/blog/424211/">Understand the Container Storage Interface (in Kubernetes and beyond)</a> ‚Äù - <b>approx. Transl.</b> )</i> . <br><br><h2>  Kubernetes Snapshot API </h2><br>  To manage snapshots in Kubernetes Volume Snapshots, three new API objects are presented in the same way as in the Kubernetes Persistent Volumes API: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Created by the user Kubernetes to request to create a snapshot for the specified volume.  Contains information about snapshot operation, such as timestamp snapshot removal and whether it is ready for use. </li><li>  Like the <code>PersistentVolumeClaim</code> object, creating and deleting this object represents the user's desire to create or delete a cluster resource (snapshot). </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Created by the CSI driver when the snapshot was successfully created.  Contains information about snapshot including its ID. </li><li>  Like the <code>PersistentVolume</code> object, it represents the resource already serviced by the cluster (snapshot). </li><li>  Like the <code>PersistentVolumeClaim</code> and <code>PersistentVolume</code> objects, when the snapshot is created, the <code>VolumeSnapshotContent</code> object <code>VolumeSnapshotContent</code> bound to the <code>VolumeSnapshot</code> for which it was created (one-to-one mapping is used). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Set by cluster administrators to describe which snapshots can be created.  Includes information about the driver, secrets for accessing snapshots, etc. </li></ul></li></ul><br>  It is important to note that - unlike the main Persistent Volume objects in Kubernetes, these snapshots objects are defined as <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">CustomResourceDefinitions (CRDs)</a> .  The Kubernetes project is gradually moving away from the previously defined types of resources in the API Server, approaching the model in which the API Server does not depend on API objects.  This approach allows you to reuse the API server in other projects (besides Kubernetes), and consumer'y (like the same Kubernetes) can set the types of resources they need as CRD. <br><br>  <a href="https://kubernetes-csi.github.io/docs/Drivers.html">CSI drivers</a> supporting snapshots will automatically install the necessary CRDs.  The end users of Kubernetes will only need to verify that the CSI driver supporting snapshots is deployed in a cluster. <br><br>  In addition to these new objects, the already existing <code>PersistentVolumeClaim</code> a new <code>DataSource</code> field: <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  This field (in the status of alpha version) allows you to automatically fill it with data from an existing snapshot when creating a new volume. <br><br><h2>  Kubernetes snapshots requirements </h2><br>  Before using snapshots of volumes in Kubernetes, you must: <br><br><ul><li>  make sure that the CSI driver that implements snapshots is deployed and running on the cluster; </li><li>  enable Kubernetes Volume Snapshotting via a new feature gate (disabled by default for the alpha version): <br><ul><li>  set the following flag for the executable API Server file: <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Before creating a snapshot, you must also determine the CSI driver used, which is done by creating a <code>VolumeSnapshotClass</code> object and specifying the CSI driver in the <code>snapshotter</code> field.  In the following example with <code>VolumeSnapshotClass</code> this driver is <code>com.example.csi-driver</code> .  Each snapshot provider requires at least one <code>VolumeSnapshotClass</code> object.  It is also possible to define the default <code>VolumeSnapshotClass</code> for each CSI driver ‚Äî this is done by setting the <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> annotation in the class definition: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  All required parameters must be set in accordance with the CSI driver documentation.  In the example above, the <code>fakeSnapshotOption: foo</code> parameter and all the mentioned secrets will be passed to the CSI driver during the creation and deletion of the snapshot.  <a href="https://github.com/kubernetes-csi/external-snapshotter">The CSI external-snapshotter</a> saves the <code>csiSnapshotterSecretName</code> and <code>csiSnapshotterSecretNamespace</code> parameter keys by default. <br><br>  Finally, before creating a snapshot, you must create a volume through the CSI driver and fill it with the data you want to see there (see <a href="https://kubernetes.io/blog/2018/04/10/container-storage-interface-beta/">this publication</a> for details on how to use CSI volumes). <br><br><h2>  Creating a new snapshot in Kubernetes </h2><br>  Once the <code>VolumeSnapshotClass</code> object <code>VolumeSnapshotClass</code> defined and there is a volume from which you want to take a snapshot, you can perform this operation by creating a <code>VolumeSnapshot</code> object. <br><br>  The source for snapshot is determined by two parameters: <br><br><ul><li>  <code>kind</code> - <code>PersistentVolumeClaim</code> indicated here; </li><li>  <code>name</code> is the actual name of the PVC object. </li></ul><br>  This implies that the namespace of the volume for which snapshot is created is determined by the namespace of the <code>VolumeSnapshot</code> object. <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  The <code>VolumeSnapshot</code> specification can <code>VolumeSnapshot</code> a <code>VolumeSnapshotClass</code> , which contains information about which CSI driver will be used to create the snapshot.  As previously reported, after creating the <code>VolumeSnapshot</code> object <code>VolumeSnapshot</code> the <code>fakeSnapshotOption: foo</code> parameter and all the mentioned <code>VolumeSnapshotClass</code> secrets are passed to the CSI plugin <code>com.example.csi-driver</code> in the <code>CreateSnapshot</code> call. <br><br>  In response to such a request, the CSI driver snapshot the volume and then automatically creates a <code>VolumeSnapshotContent</code> object that represents the new snapshot and binds this object to the <code>VolumeSnapshot</code> , making it ready for use.  If the CSI driver cannot create snapshots and returns an error, the snapshot controller reports this error in the status of the <code>VolumeSnapshot</code> object and <b>does not</b> make new attempts (this behavior differs from other controllers in Kubernetes - it is implemented in order not to create snapshots in unpredictable times) . <br><br>  If the snapshot class is not set, external-snapshotter will try to find the default class and use it for the snapshot being created.  In this case, the CSI driver pointed to by the <code>snapshotter</code> in the default class must match the CSI driver pointed to by the <code>provisioner</code> in the PVC storage class. <br><br>  Please note that the alpha release snapshots for Kubernetes does not guarantee consistency.  To ensure complete data in the snapshot, it is necessary to prepare the application accordingly (stop the application, freeze the file system, etc.) before removing it. <br><br>  You can <code>VolumeSnapshot</code> that a <code>VolumeSnapshot</code> object <code>VolumeSnapshot</code> created and associated with a <code>VolumeSnapshotContent</code> by using the <code>kubectl describe volumesnapshot</code> command <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> should be <code>true</code> in <code>Status</code> , which will indicate that the snapshot volume is ready for use. </li><li>  The <code>Creation Time</code> field shows when the snapshot was actually made. </li><li>  <code>Restore Size</code> field - the minimum size of the volume to restore snapshot. </li><li>  The <code>Snapshot Content Name</code> field in the specification points to a <code>VolumeSnapshotContent</code> object created for this snapshot. </li></ul><br><h2>  Import existing snapshot into Kubernetes </h2><br>  You can import an existing snapshot into Kubernetes by manually creating a <code>VolumeSnapshotContent</code> object that will represent this snapshot.  Since <code>VolumeSnapshotContent</code> is an API object that is not bound to a namespace, only a system administrator has permission to create it. <br><br>  When the <code>VolumeSnapshotContent</code> object <code>VolumeSnapshotContent</code> created, the user can create another object ‚Äî the <code>VolumeSnapshot</code> ‚Äî that will point to it.  The external-snapshotter controller will mark the snapshot as ready after checking for the existence and correctness of the connection between the <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> .  Snapshot is ready for use in Kubernetes when this connection is established. <br><br>  The <code>VolumeSnapshotContent</code> object should be created with the following fields representing the <i>pre-provisioned</i> snapshot: <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> - information identifying snapshot: <br><ul><li>  <code>snapshotHandle</code> - name / identifier for snapshot.  Obligatory field; </li><li>  <code>driver</code> - CSI driver used to work with this volume.  Obligatory field.  Must match the name of the <code>snapshotter</code> in the controller (snapshot controller); </li><li>  <code>creationTime</code> and <code>restoreSize</code> ‚Äî these are optional for pre-prepared volumes.  The external-snapshotter controller will automatically update them after creating the snapshot. </li></ul></li><li>  <code>volumeSnapshotRef</code> - a pointer to the <code>VolumeSnapshot</code> object to which this object (ie, <code>VolumeSnapshotContent</code> ) should be <code>VolumeSnapshotContent</code> : <br><ul><li>  <code>name</code> and <code>namespace</code> - the name and namespace of the <code>VolumeSnapshot</code> object, the contents of which are bound; </li><li>  <code>UID</code> - optional (for pre-prepared volumes) field.  The external-snapshotter controller will automatically update this field after binding.  If the user specifies this field, you must ensure that it corresponds to the snapshot UID for which the binding occurs.  If there is no match, the content is considered irrelevant (orphan-object) and therefore the controller will delete both it and its associated snapshot. </li></ul></li><li>  <code>snapshotClassName</code> is an optional field.  The external-snapshotter controller will automatically update it after binding. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  The <code>VolumeSnapshot</code> object must be created so that the user can work with snapshot.  In him: <br><br><ul><li>  <code>snapshotClassName</code> is the name of the snapshot class of the volume.  Optional field.  If set, the <code>snapshotter</code> field in the snapshot class must match the name of the snapshot controller.  If not set, the controller will search for the default snapshot class; </li><li>  <code>snapshotContentName</code> is the name of the contents of the snapshot volume.  Required field for pre-prepared volumes. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  When these objects are created, the snapshot controller will link them, set the <code>Ready</code> field (in <code>Status</code> ) to <code>True</code> , indicating that the snapshot is ready for use. <br><br><h2>  Preparing a new snapshot volume in Kubernetes </h2><br>  To create a new volume, pre-filled with data from the snapshot object, use the new <code>dataSource</code> field in <code>PersistentVolumeClaim</code> .  It has three parameters: <br><br><ul><li>  <code>name</code> - the name of the <code>VolumeSnapshot</code> object that represents the source snapshot; </li><li>  <code>kind</code> - must be specified as a <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> - should be <code>snapshot.storage.k8s.io</code> . </li></ul><br>  It is assumed that the namespace of the source ‚Äî the <code>VolumeSnapshot</code> object ‚Äî corresponds to the namespace of the <code>PersistentVolumeClaim</code> object. <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  When the <code>PersistentVolumeClaim</code> object is created, it will provide for the provisioning of a new volume, previously filled with data from the specified snapshot. <br><br><h2>  How to add snapshots support to my CSI driver if I am a storage developer? </h2><br>  In order to support snapshots, additional features of the controller must be added to the CSI driver: <code>CREATE_DELETE_SNAPSHOT</code> and <code>LIST_SNAPSHOTS</code> , and additional RPC controllers are <code>CreateSnapshot</code> : <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  See <a href="">the CSI specification for</a> details. <br><br>  Although Kubernetes provides the most <a href="">minimal guidelines</a> for packaging and deploying the CSI Volume Driver, there is a <a href="">recommended mechanism</a> for deploying an arbitrary containerized CSI driver to Kubernetes to simplify this process. <br><br>  As part of the recommended deployment process, the Kubernetes team suggests using multiple sidecar- (i.e., ancillary) containers, including a sidecar-container with an <a href="https://github.com/kubernetes-csi/external-snapshotter">external-snapshotter</a> . <br><br>  The external-snapshotter referred to in the API Server for the <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> , invoking the <code>CreateSnapshot</code> and <code>DeleteSnapshot</code> for the CSI endpoint.  The CSI <a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a> sidecar-container has also been updated to support recovery of the volume from snapshot using the new <code>dataSource</code> field in the PVC. <br><br>  To support snapshot capabilities, storage vendors are recommended to deploy sidecar containers with an external snapshotter in addition to an external provisioner, and place the CSI driver in a <code>StatefulSet</code> , as shown in the diagram below: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  In <a href="">this example, the Deployment</a> presents two sidecar containers, the external provisioner and the external snapshotter, and the CSI drivers are deployed along with the CSI hostpath plugin within the StatefulSet pod.  The CSI hostpath is an example of a plugin that is not intended for use in production. <br><br><h2>  What are the limitations of the alpha version? </h2><br>  The alpha version of the implementation of snapshots in Kubernetes has the following limitations: <br><br><ul><li>  It does not support rollback of the existing volume to the previous state represented by snapshot (only provisioning of the new volume from snapshot is supported). </li><li>  The in-place restore of the existing <code>PersistentVolumeClaim</code> from snapshot is not supported: i.e.  The provisioning of a new volume from snapshot works, but not updating an existing <code>PersistentVolumeClaim</code> so that it points to a new volume and the PVC rolls back to an earlier state (only the use of a new volume created from snapshot through the new PV / PVC is supported). </li><li>  Snapshot consistency guarantees do not go beyond the guarantees provided by the storage system (for example, integrity in a fall). </li></ul><br><h2>  What's next? </h2><br>  The Kubernetes team plans to bring the implementation of snapshots for CSI to beta in releases 1.13 or 1.14, depending on the feedback received and the adaptation of the technology. <br><br><h2>  How to find out more details? </h2><br>  See additional snapshots documentation on <a href="http://k8s.io/docs/concepts/storage/volume-snapshots">k8s.io/docs/concepts/storage/volume-snapshots</a> and <a href="https://kubernetes-csi.github.io/docs/">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/company/flant/blog/424331/">Kubernetes 1.12: review of major innovations</a> ‚Äù; </li><li>  ‚ÄúWe <a href="https://habr.com/company/flant/blog/424211/">understand the Container Storage Interface (in Kubernetes and not only)</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/348044/">Rook -‚Äú self-service ‚Äùdata store for Kubernetes</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> ‚Äù <i>(review and video of the report)</i> ; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/412901/">Monitoring and Kubernetes</a> ‚Äù <i>(review and video of the report)</i> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/426133/">https://habr.com/ru/post/426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426119/index.html">Antiquities: Cryptonomicon Iron</a></li>
<li><a href="../426121/index.html">MC.exe (Message compiler), rc.exe, link.exe to generate .dll for EventMessageFile</a></li>
<li><a href="../426123/index.html">Learn OpenGL. Lesson 6.1. PBR or Physically-correct rendering. Theory</a></li>
<li><a href="../426125/index.html">Career steroids. Elevators</a></li>
<li><a href="../426131/index.html">Download configuration to FPGA via USB or disassemble FTDI MPSSE</a></li>
<li><a href="../426135/index.html">Private cloud for the Internet of Things</a></li>
<li><a href="../426137/index.html">Age of Honesty</a></li>
<li><a href="../426141/index.html">Red Hat replaces Docker with Podman</a></li>
<li><a href="../426143/index.html">3D animation - video or interactive?</a></li>
<li><a href="../426145/index.html">Seminar "Independent acceptance", October 23, Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>