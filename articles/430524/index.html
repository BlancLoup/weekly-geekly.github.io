<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Neural Network Architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neural Network Architectures Translation 

 Algorithms of deep neural networks today have gained great popularity, which is largely ensured by the wel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Neural Network Architecture</h1><div class="post__text post__text-html js-mediator-article">  <i><a href="https://towardsdatascience.com/neural-network-architectures-156e5bad51ba">Neural Network Architectures</a> Translation</i> <br><br>  Algorithms of deep neural networks today have gained great popularity, which is largely ensured by the well thought-out architecture.  Let's look at the history of their development over the past few years.  If you are interested in a deeper analysis, refer to <a href="https://arxiv.org/abs/1605.07678">this work</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29b/f51/960/29bf5196085373528be31e27f2489bdd.jpg"><br>  <i>Comparison of popular architectures for Top-1 one-crop accuracy and the number of operations required for one straight pass.</i>  <i>Read more <a href="https://medium.com/%40culurciello/analysis-of-deep-neural-networks-dcf398e71aae">here</a> .</i> <br><a name="habracut"></a><br><h3>  LeNet5 </h3><br>  In 1994, one of the first convolutional neural networks was developed, which marked the beginning of deep learning.  This pioneering work of Yan Lekun (Yann LeCun) after many successful iterations since 1988 has received the name <a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf">LeNet5</a> ! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/b19/9c3/8f2/b199c38f21a72c44d7cd3afbca1c94eb.jpg"><br><br>  The architecture of LeNet5 has become fundamental for deep learning, especially in terms of the distribution of image properties throughout the entire picture.  Convolutions with trained parameters made it possible with the help of several parameters to efficiently extract the same properties from different places.  In those years there were still no video cards capable of speeding up the learning process, and even the central processors were slow.  Therefore, the key advantage of the architecture was the ability to save the parameters and results of calculations, in contrast to the use of each pixel as separate input data for a large multilayered neural network.  In LeNet5, in the first layer, pixels are not used, because the images are highly correlated spatially, so using separate pixels as input properties will not allow you to take advantage of these correlations. <br><br>  LeNet5 features: <br><br><ul><li>  A convolutional neural network using a sequence of three layers: convolution layers (convolution), grouping layers (pooling) and nonlinearity layers (non-linearity) -&gt; since the publication of Lekun‚Äôs work, this is probably one of the main features of in-depth training applied to images. </li><li>  Uses convolution to extract spatial properties. </li><li>  A subsample using spatial averaging of maps. </li><li>  Nonlinearity in the form of a hyperbolic tangent or sigmoid. </li><li>  The final classifier in the form of a multilayered neural network (MLP). </li><li>  A sparse connectivity matrix between the layers reduces the amount of computation. </li></ul><br>  This neural network formed the basis of many subsequent architectures and inspired many researchers. <br><br><h3>  Development </h3><br>  From 1998 to 2010, the neural networks were in a state of incubation.  Most people did not notice their growing capabilities, although many developers gradually honed the algorithms.  Due to the flourishing of mobile phone cameras and the cheapening of digital cameras, more and more training data became available to us.  At the same time, computing capabilities grew, processors became more powerful, and video cards became the main computing tool.  All these processes allowed the development of neural networks, albeit rather slowly.  Interest in the tasks that could be solved using neural networks increased, and finally the situation became obvious ... <br><br><h3>  Dan Ciresan Net </h3><br>  In 2010, Dan Kireshan (Dan Claudiu Ciresan) and J√∂rgen Schmidhuber published one of the first descriptions of the implementation of <a href="">GPU-neural networks</a> .  Their work contained a direct and reverse implementation of a 9-layer neural network on the <a href="http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-280">NVIDIA GTX 280</a> . <br><br><h3>  AlexNet </h3><br>  In 2012, Alexey Krizhevsky published <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">AlexNet</a> , an in-depth and extended version of LeNet, which won by a large margin in the difficult competition ImageNet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aad/4ad/3ca/aad4ad3ca7345f8d7e198c2b131298d1.png"><br><br>  In AlexNet, the results of LeNet calculations are scaled to a much larger neural network, which is able to study much more complex objects and their hierarchies.  Features of this solution: <br><br><ul><li>  Use of linear rectification units (ReLU) as non-linearities. </li><li>  Using the drop technique to selectively ignore individual neurons during training, thus avoiding overtraining of the model. </li><li>  Overlap max pooling, which avoids the effects of averaging average pooling. </li><li>  Use the <a href="http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-580/specifications">NVIDIA GTX 580</a> to speed learning. </li></ul><br>  By that time, the number of cores in the video cards had greatly increased, which made it possible to reduce the training time by about 10 times, and as a result, it became possible to use much larger datasets and pictures. <br><br>  The success of AlexNet launched a small revolution, convolutional neural networks turned into a workhorse of deep learning - this term henceforth meant "large neural networks capable of solving useful tasks." <br><br><h3>  Overfeat </h3><br>  In December 2013, NYU Laboratory Yana Lekuna published a description of <a href="">Overfeat</a> , a variety of AlexNet.  The article also described the bounding boxes, and subsequently many other works on this subject were published.  We believe that it is better to learn how to segment objects, and not to use artificial bounding boxes. <br><br><h3>  VGG </h3><br>  In Oxford-developed <a href="">VGG</a> networks, for each convolutional layer, 3x3 filters were first used, and they also combined these layers in a sequence of convolutions. <br><br>  This is contrary to the principles in LeNet, according to which large bundles were used to extract the same image properties.  Instead of the 9x9 and 11x11 filters used in AlexNet, much smaller filters began to be used, dangerously close to the 1x1 convolutions, which LeNet authors tried to avoid, at least in the first layers of the network.  But the great advantage of VGG was the discovery that several 3x3 bundles combined into a sequence could emulate larger receptive fields, for example, 5x5 or 7x7.  These ideas will later be used in the Inception and ResNet architectures. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/e8b/308/dece8b308f74450222deece6fcf9d357.jpg"><br><br>  VGG networks use multiple 3x3 convolutional layers to represent complex properties.  Note blocks 3, 4, and 5 in VGG-E: 256 √ó 256 and 512 √ó 512 3 √ó 3 filter sequences are used to extract more complex properties and combine them.  This is tantamount to large convolutional classifiers 512x512 with three layers!  This gives us a huge amount of parameters and excellent learning abilities.  But it was difficult to learn such networks, it was necessary to break them up into smaller ones, adding layers one by one.  The reason was the lack of effective ways to regularize models or some methods of restricting a large search space, which is supported by many parameters. <br><br>  VGG in many layers use a large number of properties, so the training required a <a href="http://arxiv.org/abs/1605.07678">large computational cost</a> .  You can reduce the load by reducing the number of properties, as is done in the bottleneck layers of the Inception architecture. <br><br><h3>  Network-in-network </h3><br>  The <a href="">network-in-network</a> (NiN) architecture is based on a simple idea: using 1x1 bundles to increase the combinatorial properties of the convolutional layers. <br><br>  In NiN, spatial MLP layers are applied after each convolution in order to better combine the properties before feeding to the next layer.  It may seem that the use of 1x1 bundles is contrary to the original LeNet principles, but in fact it allows you to combine properties better than just stuffing more convolutional layers.  This approach differs from using bare pixels as input to the next layer.  In this case, 1x1 convolutions are used for spatial combination of properties after convolution within property maps, so much fewer parameters can be used that are common to all pixels of these properties! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9a/d08/e5c/d9ad08e5c699a2a9cf320c4b8b622ba3.jpg"><br><br>  MLPs can greatly enhance the efficiency of individual convolutional layers by combining them into more complex groups.  This idea was later used in other architectures, such as ResNet, Inception, and their variants. <br><br><h3>  GoogLeNet and Inception </h3><br>  Google's Christian Szegedy has bothered to reduce the amount of computation in deep neural networks, and as a result, he created <a href="">GoogLeNet, the first Inception architecture</a> . <br><br>  By the fall of 2014, deep learning models have become very useful in categorizing the contents of images and frames from video.  Many skeptics have recognized the benefits of deep learning and neural networks, and Internet giants, including Google, have been greatly interested in deploying efficient and large networks on their server capacities. <br><br>  Christian was looking for ways to reduce the computational load in neural networks, achieving the highest performance (for example, in ImageNet).  Or keeping the amount of calculations, but still at the same time improving performance. <br><br>  As a result, the team created the Inception module: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abf/d01/a92/abfd01a92262ff6e5b9f23380ba8d9cc.jpg"><br><br>  At first glance, this is a parallel combination of convolutional filters 1x1, 3x3 and 5x5.  But the highlight was the use of 1x1 convolutional blocks (NiN) to reduce the number of properties before serving in the "expensive" parallel blocks.  Usually this part is called a bottleneck, it is described in more detail in the next chapter. <br><br>  In GoogLeNet, a stem without Inception modules is used as the initial layer, and also uses an average pooling and softmax classifier similar to NiN.  This classifier performs very few operations compared to AlexNet and VGG.  It also helped create a <a href="http://arxiv.org/abs/1605.07678">very efficient neural network architecture</a> . <br><br><h3>  Bottleneck layer </h3><br>  This layer reduces the number of properties (and hence the operations) in each layer, so that the speed of obtaining the result can be kept at a high level.  Before transferring data to ‚Äúexpensive‚Äù convolutional modules, the number of properties decreases, say, 4 times.  This greatly reduces the amount of computation, which made the architecture popular. <br><br>  Let's figure it out.  Suppose we have 256 properties at the input and 256 at the output, and let the Inception-layer only perform 3x3 convolutions.  We get 256x256x3x3 convolutions (589 000 multiply operations with accumulation, that is, MAC operations).  This may go beyond our computational rate requirements, say that a layer was processed in 0.5 milliseconds on Google Server.  Then reduce the number of properties for coagulation to 64 (256/4).  In this case, we first execute the convolution 1x1 256 -&gt; 64, then another 64 convolutions in all Inception branches, and then again apply the convolution 1x1 of 64 -&gt; 256 properties.  Number of operations: <br><br><ul><li>  256 √ó 64 √ó 1 √ó 1 = 16 000 </li><li>  64 √ó 64 √ó 3 √ó 3 = 36 000 </li><li>  64 √ó 256 √ó 1 √ó 1 = 16,000 </li></ul><br>  A total of about 70,000, reduced the number of operations almost 10 times!  But at the same time, we did not lose generalization in this layer.  Bottleneck layers showed superior performance on dataset ImageNet, and were used in later architectures such as ResNet.  The reason for their success is that the input properties are correlated, which means you can get rid of redundancy by correctly combining the properties with 1x1 convolutions.  And after coagulation with a smaller number of properties, it is possible on the next layer to expand them again into a meaningful combination. <br><br><h3>  Inception V3 (and V2) </h3><br>  Christian and his team have been very effective researchers.  In February 2015, the architecture of <a href="http://arxiv.org/abs/1502.03167">Batch-normalized Inception</a> was introduced as the second version of <a href="http://arxiv.org/abs/1502.03167">Inception</a> .  Batch normalization (batch-normalization) calculates the mean and standard deviation of all property distribution maps in the output layer, and normalizes their responses with these values.  This corresponds to the "bleaching" of the data, that is, the responses of all neural maps lie in the same range and with zero mean.  This approach facilitates learning, because the subsequent layer does not have to remember the offsets of the input data and can only search for the best combinations of properties. <br><br>  In December 2015, a <a href="http://arxiv.org/abs/1512.00567">new version of Inception modules and the corresponding architecture was released</a> .  The author‚Äôs article explains the original GoogLeNet architecture better, there is much more detail about the decisions made.  Key ideas: <br><br><ul><li>  Maximizing the flow of information in the network due to the careful balance between its depth and width.  Before each pooling, property maps increase. </li><li>  With increasing depth, the number of properties or layer width also increases systematically. </li><li>  The width of each layer increases to increase the combination of properties before the next layer. </li><li>  As far as possible, only 3x3 convolutions are used.  Considering that 5x5 and 7x7 filters can be decomposed with a few 3x3 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/849/96f/d8c/84996fd8cb1040fbf0a18187313a8a81.jpg"><br><br>  The new Inception module looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/975/b0b/ad7/975b0bad7d65a0b37aedf0dc119d03b8.jpg"></li><li>  Filters can also be decomposed using <a href="">smoothed bundles</a> into more complex modules: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/c32/21c/bb5c3221cc8f478de3ac5ef504a13357.jpg"></li><li>  Inception modules can use pooling to reduce data size during Inception calculations.  This is similar to performing a convolution with strides in parallel with a simple pooling layer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8b/4c1/263/f8b4c1263b3883d751c7dfe3788110ca.jpg"></li></ul><br>  As the final classifier, Inception uses a softmax pooling layer. <br><br><h3>  ResNet </h3><br>  In December 2015, at about the same time as the architecture of Inception v3 was presented, a revolution occurred - published <a href="https://arxiv.org/abs/1512.03385">ResNet</a> .  It contains simple ideas: we submit the output of two successful convolutional layers And bypass the input data for the next layer! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8a/05d/8b8/b8a05d8b89f55e8d06bb2eae79bd648b.jpg"><br><br>  Such ideas have already been proposed, for example, <a href="http://yann.lecun.com/exdb/publis/pdf/sermanet-ijcnn-11.pdf">here</a> .  But in this case, the authors bypass the TWO layers and apply the approach on a large scale.  Bypassing one layer does not give much benefit, and bypassing two is a key finding.  This can be considered as a small classifier, as a network-in-a-network! <br><br>  It was also the first ever example of learning a network of several hundred, even thousands of layers. <br>  In multi-layer ResNet, a bottleneck layer was used, similar to that used in Inception: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d0/ecf/124/0d0ecf1248874511ae4dbca5f23afcec.jpg"><br><br>  This layer reduces the number of properties in each layer, first using a 1x1 convolution with a lower output (usually a quarter of the input), then a 3x3 layer comes, and then again a 1x1 convolution into more properties.  As in the case of Inception-modules, it saves computational resources, while maintaining a wealth of combinations of properties.  Compare with more complex and less obvious stem in Inception V3 and V4. <br><br>  ResNet uses a softmax for the final classifier in ResNet. <br>  Every day there is more information about the ResNet architecture: <br><br><ul><li>  It can be considered as a system of simultaneously parallel and serial modules: in many modules the inout-signal comes in parallel, and the output signals of each module are connected in series. </li><li>  ResNet can be considered as several <a href="http://arxiv.org/abs/1605.06431">ensembles of parallel or sequential modules</a> . </li><li>  It turned out that ResNet usually operates with blocks of relatively small depth of 20-30 layers, working in parallel, rather than driving them consistently along the entire length of the network. </li><li>  Since the output signal goes back and serves as an input, as is done in the RNN, ResNet can be considered an improved <a href="https://arxiv.org/abs/1604.03640">plausible model of the cerebral cortex</a> . </li></ul><br><h3>  Inception V4 </h3><br>  Once again, Christian and his team distinguished themselves by releasing a <a href="http://arxiv.org/abs/1602.07261">new version of Inception</a> . <br><br>  The inception module following the stem is the same as in Inception V3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48b/955/f38/48b955f385c72d21a20af8517d941580.jpg"><br><br>  In this case, the Inception module is combined with the ResNet module: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4c/5f2/bd7/f4c5f2bd765082fe56dac5710fc30221.jpg"><br><br>  This architecture turned out, for my taste, more complicated, less elegant, and also filled with imperfect heuristic solutions.  It is difficult to understand why the authors made these or other decisions, and it is just as difficult to give them some kind of assessment. <br><br>  Therefore, the prize for a clean and simple neural network, easy to understand and modify, goes to ResNet. <br><br><h3>  SqueezeNet </h3><br>  <a href="http://arxiv.org/abs/1602.07360">SqueezeNet</a> published recently.  This is a remake of a new way of many concepts from ResNet and Inception.  The authors have demonstrated that improving the architecture can reduce the size of networks and the number of parameters without complex compression algorithms. <br><br><h3>  Eet </h3><br>  All the features of recent architectures are combined into a very efficient and compact network that uses very few parameters and computing power, but gives excellent results.  The architecture was called <a href="https://arxiv.org/abs/1606.02147">ENet</a> , it was developed by Adam Paszke.  For example, we used it for very accurate marking of objects on the screen and parsing scenes.  <a href="https://www.youtube.com/watch%3Fv%3D3jq4FnO5Nco%26list%3DPLNgy4gid0G9c4qiVBrERE_5v_b1pu-5pQ">A few examples of how Enet works</a> .  These videos are not related to the <a href="https://www.cityscapes-dataset.com/">training dataset</a> . <br><br>  <a href="https://arxiv.org/abs/1606.02147">Here</a> you can find the technical details of ENet.  This is a network based on the encoder and decoder.  The encoder is built on the usual CNN scheme for categorization, and the decoder is an upsampling netowrk network designed for segmentation by distributing categories back to the original size image.  For segmentation of images only neural networks were used, no other algorithms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18d/c54/7fa/18dc547fade22215961a848b2170b104.png"><br><br>  As you can see, ENet has the highest specific accuracy compared to all other neural networks. <br><br>  ENet was designed to use as few resources as possible from the very beginning.  As a result, the encoder and decoder together occupy only 0.7 MB with an accuracy of fp16.  And with this tiny size, ENet is not inferior or superior to other purely neural network solutions in terms of segmentation accuracy. <br><br><h3>  Module analysis </h3><br>  <a href="https://arxiv.org/abs/1606.02228">Published a</a> systematic assessment of CNN-modules.  It turned out that it is profitable: <br><br><ul><li>  Use ELU non-linearity without batch normalization (batchnorm) or ReLU with normalization. </li><li>  Apply a learned transformation of the RGB color space. </li><li>  Use a linear learning rate decay policy. </li><li>  Use the sum of the average and maximum pooling layer. </li><li>  Use a mini package of 128 or 256. If this is too much for your video card, reduce the learning rate in proportion to the size of the package. </li><li>  Use fully connected layers as convolutional and average forecasts for issuing the final solution. </li><li>  If you increase the size of the training dataset, make sure that you have not reached the plateau in training.  Clean data is more important than size. </li><li>  If you cannot increase the size of the input image, reduce the stride in subsequent layers, the effect will be about the same. </li><li>  If your network has a complex and highly optimized architecture, as in GoogLeNet, then modify it with care. </li></ul><br><h3>  Xception </h3><br>  <a href="https://arxiv.org/abs/1610.02357">Xception</a> introduced to the Inception module a simpler and more elegant architecture that is no less efficient than ResNet and Inception V4. <br>  This is what the Xception module looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/632/40a/deb/63240adebe962726f6d035b5a5d16099.jpg"><br><br>  This network will appeal to anyone thanks to the simplicity and elegance of its architecture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d64/f09/933/d64f099330f0b9290a99202a50863868.jpg"><br><br>  It contains 36 convolutions, and this is similar to ResNet-34.  At the same time, the model and code are simple, as in ResNet, and much nicer than in Inception V4. <br><br>  The Torch7 implementation of this network is available <a href="https://gist.github.com/culurciello/554c8e56d3bbaf7c66bf66c6089dc221">here</a> , and the implementation on Keras / TF is here. <br><br>  Curiously, the authors of the recent Xception architecture were also inspired by <a href="">our work on separable convolution filters</a> . <br><br><h3>  MobileNets </h3><br>  New architecture M <a href="https://arxiv.org/abs/1704.04861">obileNets</a> was released in April 2017.  To reduce the number of parameters, it uses detachable convolutions, the same as in Xception.  Even in the paper it is argued that the authors were able to greatly reduce the number of parameters: approximately twice in the case of FaceNet.  Full model architecture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/689/04b/c1e/68904bc1e353888d4fcd54975a064362.jpg"><br><br>  We tested this network in a real problem and found that it runs disproportionately slowly on the package of 1 (batch of 1) on the Titan Xp video card.  Compare the duration of the output for one image: <br><br><ul><li>  resnet18: 0.002871 </li><li>  alexnet: 0,001003 </li><li>  vgg16: 0.001698 </li><li>  squeezenet: 0.002725 </li><li>  mobilenet: 0.033251 </li></ul><br>  This is not a quick job!  The number of parameters and the size of the network on the disk are reduced, but there is no sense in it. <br><br><h3>  Other noteworthy architectures </h3><br>  <a href="https://arxiv.org/abs/1605.07648">FractalNet</a> uses a recursive architecture that has not yet been tested on ImageNet and is a derivative or more general version of ResNet. <br><br><h3>  Future </h3><br>  We believe that the development of neural network architectures is of paramount importance for the development of deep learning.  We highly recommend that you carefully read and think about all the works presented here. <br><br>  You may ask why we have to spend so much time developing architectures, and why we don‚Äôt use data instead that will tell us what to use and how to combine the modules?  Tempting opportunity, but work on this is still underway.  <a href="https://arxiv.org/abs/1606.06216">Here</a> are some initial results. <br>  In addition, we only talked about computer vision architectures.  In other areas, development is also underway, and it would be interesting to study the evolution in other areas. <br><br>  If you are interested in comparing neural networks and computational performance, see <a href="http://arxiv.org/abs/1605.07678">our recent work</a> . </div><p>Source: <a href="https://habr.com/ru/post/430524/">https://habr.com/ru/post/430524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430512/index.html">How do freelancers live: do not work with ‚Äúall-knowing‚Äù clients and allow yourself to grow</a></li>
<li><a href="../430514/index.html">Blockchain Charity - DataArt won the Malta Blockchain Summit</a></li>
<li><a href="../430518/index.html">How to render a frame Middle Earth: Shadow of Mordor</a></li>
<li><a href="../430520/index.html">Meet Spring Data MongoDB</a></li>
<li><a href="../430522/index.html">Do you need a corporate culture in IT? Confession brand manager of the Krasnodar studio Plarium</a></li>
<li><a href="../430526/index.html">Slot machines: where did they come from in the USSR and how are they arranged</a></li>
<li><a href="../430528/index.html">Programming with PyUSB 1.0</a></li>
<li><a href="../430530/index.html">Mock server to automate mobile testing</a></li>
<li><a href="../430532/index.html">Security in iOS applications</a></li>
<li><a href="../430534/index.html">Creating a template for Zabbix using DVR Trassir SDK as an example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>