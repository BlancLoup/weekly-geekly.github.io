<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting Started with Java 9 and the Jigsaw Project - Part One</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good morning, Habr! 

 Since the time of the book " Java. A New Generation of Development " we have been following the development of the long-announc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting Started with Java 9 and the Jigsaw Project - Part One</h1><div class="post__text post__text-html js-mediator-article"> Good morning, Habr! <br><br>  Since the time of the book " <a href="http://www.piter.com/collection/kompyutery-i-internet/product/java-novoe-pokolenie-razrabotki">Java. A New Generation of Development</a> " we have been following the development of the long-announced new features of this language, united under the common title " <a href="http://openjdk.java.net/projects/jigsaw/">Project Jigsaw</a> ".  Today we are offering a translation of an article from November 24, which gives us sufficient confidence that the Java 9 Jigsaw version will take place. <br><a name="habracut"></a><br>  Eight years have passed since the birth of the Jigsaw project, whose task is to modularize the Java platform and is reduced to the introduction of a common system of modules.  <b>It is assumed that Jigsaw will first appear in the Java 9 version</b> .  This release was previously planned for both Java 7 and Java 8. The scope of Jigsaw has also changed a number of times.  Now there is every reason to believe that Jigsaw is almost ready, since he paid much attention to the Oracle plenary report at the JavaOne 2015 conference, as well as <a href="http://openjdk.java.net/projects/jigsaw/j1/">several presentations</a> on this topic.  What does this mean to you?  What is a jigsaw project and how to work with it? <br><br>  This is the first of two publications in which I want to make a brief introduction to the module system and use numerous code examples to demonstrate the behavior of Jigsaw.  In the first part, we discuss what constitutes a system of modules, how the JDK was modularized, and also consider the behavior of the compiler and the runtime environment in certain situations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is a module? <br><br>  To describe the module is simple: it is a unit in the program, and each module immediately contains answers to three questions.  These responses are recorded in the file <code>module-info.java <br></code> <code>module-info.java <br></code>  which each module has. <br><br><ul><li>  What is the name of the module? </li><li>  What does it export? </li><li>  What is required for this? </li></ul><br><br><img src="https://habrastorage.org/files/d0a/f9a/564/d0af9a5640a948b89b4a93f8ab0abf4c.png"><br><br>  <i>Simple module</i> <br><br>  The answer to the first question is simple.  (Almost) every module has a name.  It must comply with package naming conventions, for example, <code>de.codecentric.mymodule <br></code> <code>de.codecentric.mymodule <br></code>  , in order to avoid conflicts. <br><br>  To answer the second question, the module provides a list of all <b>packages of</b> this particular module, which are considered public APIs and, therefore, can be used by other modules.  If a class is not an exported package, no one can access it from outside your module - even if it is public. <br><br>  The answer to the third question is a list of those <b>modules</b> on which this module depends.  All public types <b>exported by</b> these modules are available to the dependent module.  The Jigsaw team is trying to introduce the term ‚Äú <b>read</b> ‚Äù another module. <br><br>  This is a major change in the status quo.  Up to Java 8 inclusive, any public type in the path to your classes was available to any other type.  With the advent of Jigsaw, Java's accessibility system changes from <br><br><ul><li>  public </li><li>  private </li><li>  default </li><li>  protected </li></ul><br><br>  on <br><br><ul><li>  public to anyone reading this module (exports) </li><li>  public for some modules reading this (exports to, this will be discussed in the second part) </li><li>  public for any other class within this module </li><li>  private </li><li>  default </li><li>  protected </li></ul><br><br>  <b>Modularized JDK</b> <br><br>  The dependencies of the modules must form an acyclic graph, thus avoiding cyclic dependencies.  To implement this principle, the Jigsaw team had to solve the following big task: to break into modules the Java runtime environment, which, as reported, is full of cyclical and illogical dependencies.  It turned out this <a href="">graph</a> : <br><br><img src="https://habrastorage.org/files/fa8/6a1/07c/fa86a107c3f3457da6f81c79a4f2ac5d.png"><br><br>  At the bottom of the graph is java.base.  This is the only module that has only incoming edges.  Each module you create <b>reads</b> <code>java.base <br></code> <code>java.base <br></code>  regardless of whether you declare it or not - as in the case of the implied <code>java.lang.Object <br></code> extension <code>java.lang.Object <br></code>  . <code>java.base <br></code>  exports packages like <code>java.lang <br></code> <code>java.lang <br></code>  <code>java.util <br></code> <code>java.util <br></code>  <code>java.math <br></code> <code>java.math <br></code>  etc. <br><br>  JDK modularization means that you can now specify which Java runtime modules you want to use.  So, your application should not use an environment that supports Swing or Corba, if you do not read the modules <code>java.desktop <br></code> <code>java.desktop <br></code>  or <code>java.corba <br></code> <code>java.corba <br></code>  .  Creating such a reduced environment will be described in the second part. <br>  But pretty dry theory ... <br><br>  <b>Pokhimichim</b> <br><br>  All the code in this article is available <a href="https://github.com/ftrossbach/IntroToJigsaw">here</a> , including shell scripts for compiling, packaging, and running the example. <br><br>  The practical case considered here is very simple.  I have a module <code>de.codecentric.zipvalidator <br></code> <code>de.codecentric.zipvalidator <br></code>  that performs a specific zip code validation.  This module is read by the <code>de.codecentric.addresschecker <br></code> module <code>de.codecentric.addresschecker <br></code> <code>de.codecentric.addresschecker <br></code>  (which could check not only zip-codes, but here we do not do this, so as not to complicate things). <br>  The zip validator is described in the following file <code>module-info.java <br></code> <code>module-info.java <br></code>  : <br><br>  module de.codecentric.zipvalidator { <br>  exports de.codecentric.zipvalidator.api; <br>  } <br><br>  So, this module exports the <code>de.codecentric.zipvalidator.api <br></code> package <code>de.codecentric.zipvalidator.api <br></code> <code>de.codecentric.zipvalidator.api <br></code>  and does not read any other modules (except <code>java.base <br></code> <code>java.base <br></code>  ).  This module is read by addresschecker: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.addresschecker{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.addresschecker.api; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> de.codecentric.zipvalidator; }</code> </pre><br><br>  The general structure of the file system is: <br><br><pre> <code class="java hljs">two-modules-ok/ ‚îú‚îÄ‚îÄ de.codecentric.addresschecker ‚îÇ ‚îú‚îÄ‚îÄ de ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ codecentric ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ addresschecker ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ api ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ AddressChecker.java ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Run.java ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ internal ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ AddressCheckerImpl.java ‚îÇ ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java ‚îú‚îÄ‚îÄ de.codecentric.zipvalidator ‚îÇ ‚îú‚îÄ‚îÄ de ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ codecentric ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ zipvalidator ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ api ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ ZipCodeValidator.java ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ZipCodeValidatorFactory.java ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ internal ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ZipCodeValidatorImpl.java ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ model ‚îÇ ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java</code> </pre><br><br>  There is an agreement according to which the module is placed in the directory of the same name of this module. <br>  In the first example, everything looks great: we work strictly by the rules and in our class <code>AddressCheckerImpl <br></code> <code>AddressCheckerImpl <br></code>  appeal only to <code>ZipCodeValidator <br></code> <code>ZipCodeValidator <br></code>  and <code>ZipCodeValidatorFactory <br></code> <code>ZipCodeValidatorFactory <br></code>  from exported package: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressCheckerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressChecker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkZipCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String zipCode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZipCodeValidatorFactory.getInstance().zipCodeIsValid(zipCode); } }</code> </pre><br><br>  Now run <code>javac <br></code> <code>javac <br></code>  and generate bytecode.  To compile <code>zipvalidator <br></code> <code>zipvalidator <br></code>  (which we, of course, need to do first, since the addresschecker reads the zipvalidator), we do <br><br><pre> <code class="java hljs">javac -d de.codecentric.zipvalidator \ $(find de.codecentric.zipvalidator -name <span class="hljs-string"><span class="hljs-string">"*.java"</span></span>)</code> </pre><br><br>  This looks familiar - as long as there is no talk about modules, since the zipvalidator does not depend on any user module.  <code>find <br></code> <code>find <br></code>  just helps us compile a list of <code>.java <br></code> files <code>.java <br></code>  in the specified directory. <br>  But as we report <code>javac <br></code> <code>javac <br></code>  about the structure of our modules, when we get to the compilation?  To do this, a switch is introduced in Jigsaw - <code>modulepath <br></code> <code>modulepath <br></code>  or <code>-mp <br></code> <code>-mp <br></code>  . <br><br>  To compile addresschecker, we use the following command: <br><br>  javac-modulepath.  -d de.codecentric.addresschecker \ <br>  $ (find de.codecentric.addresschecker -name "* .java") <br><br>  With the help of modulepath, we tell javac where to find the compiled modules (in this case, this.), It turns out something like a classpath switch. <br><br>  However, compiling multiple modules separately seems like a mess - it is better to use another switch -modulesourcepath to compile several modules at once: <br><br><pre> <code class="java hljs">javac -d . -modulesourcepath . $(find . -name <span class="hljs-string"><span class="hljs-string">"*.java"</span></span>)</code> </pre><br><br>  This code searches among all subdirectories.  directories of modules and compiles all java-files contained in them. <br>  All compiled, we naturally want to try what happened: <br><br><pre> <code class="java hljs">java -mp . -m de.codecentric.addresschecker/de.codecentric.addresschecker.api.Run <span class="hljs-number"><span class="hljs-number">76185</span></span></code> </pre><br><br>  Again, we specify the path to the modules, telling the JVM where the compiled modules are located.  We also set the main class (and parameter). <br><br>  Hooray, that's the conclusion: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">76185</span></span> is a valid zip code</code> </pre><br><br>  <b>Modular Jar</b> <br><br>  As you know, in the Java world we are used to receiving and sending our bytecode in jar files.  The concept of modular jar is introduced in jigsaw.  <b>A modular jar is</b> very similar to a regular <b>jar</b> , but it also contains the compiled <code>module-info.class. <br></code> <code>module-info.class. <br></code>  Provided that such files are compiled for the desired target version, these archives will be backward compatible. <code>module-info.java <br></code>  - not a valid type name, therefore compiled <code>module-info.class <br></code> <code>module-info.class <br></code>  will be ignored by older JVMs. <br><br>  To build a jar for zipvalidator, we write: <br><br><pre> <code class="java hljs">jar --create --file bin/zipvalidator.jar \ --<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-version=<span class="hljs-number"><span class="hljs-number">1.0</span></span> -C de.codecentric.zipvalidator</code> </pre>  . <br><br>  We specify the output file, the version (although the use of several versions of the module in Jigsaw is not specified separately during execution) and the module that should be packaged. <br>  Since addresschecker also has a main class, we can also specify it: <br><br><pre> <code class="java hljs">jar --create --file=bin/addresschecker.jar --<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-version=<span class="hljs-number"><span class="hljs-number">1.0</span></span> \ --main-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=de.codecentric.addresschecker.api.Run \ -C de.codecentric.addresschecker .</code> </pre><br><br>  The main class is not specified in <code>module-info.java <br></code> <code>module-info.java <br></code>  , as one might expect (initially the Jigsaw team planned to do so), and is usually written in the manifest. <br><br>  If you run this example with <br><br><pre> <code class="java hljs">java -mp bin -m de.codecentric.addresschecker <span class="hljs-number"><span class="hljs-number">76185</span></span></code> </pre><br><br>  we get the same answer as in the previous case.  We again indicate the path to the modules, which in this case leads to the bin directory where we have written our jars.  We don‚Äôt have to specify the main class, since this information is already in the addresschecker.jar manifest.  Just tell the module name with the <code>-m <br></code> switch. <code>-m <br></code>  . <br><br>  Until now, everything was easy and pleasant.  Next, let's tinker with the modules a bit and see how Jigsaw behaves during compilation and execution if you start hooligans. <br><br>  <b>Using Unexported Types</b> <br><br>  In this example, let's see what happens if we access this type from another module that we should not use. <br><br>  Because we are tired of this factory thing in <code>AddressCheckerImpl <br></code> <code>AddressCheckerImpl <br></code>  , we change implementation to <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZipCodeValidatorImpl().zipCodeIsValid(zipCode);</code> </pre><br><br>  When trying to compile, we get the expected <br><br><pre> <code class="java hljs">error: ZipCodeValidatorImpl is not visible because <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> de.codecentric.zipvalidator.internal is not visible</code> </pre><br>  So, it is the use of unexported types that fail during compilation. <br>  But we are smart guys, so let's cheat a little and use reflection. <br><br><pre> <code class="java hljs">ClassLoader classLoader = AddressCheckerImpl.class.getClassLoader(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Class aClass = classLoader.loadClass(<span class="hljs-string"><span class="hljs-string">"de.[..].internal.ZipCodeValidatorImpl"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((ZipCodeValidator)aClass.newInstance()).zipCodeIsValid(zipCode); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); }</code> </pre><br>  Compiled perfectly, let's run.  But no, it‚Äôs not so easy to fool a jigsaw: <br><br><pre> <code class="java hljs">java.lang.IllegalAccessException: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addresschecker</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressCheckerImpl</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addresschecker</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cannot</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">access</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> [..].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZipCodeValidatorImpl</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zipvalidator</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">because</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zipvalidator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">does</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">export</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zipvalidator</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">codecentric</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addresschecker</span></span></span></span></code> </pre><br><br>  So, Jigsaw includes checking not only at compile time, but also at run time!  And very clearly tells us what we did wrong. <br><br>  <b>Cyclic dependencies</b> <br><br>  In the next case, we suddenly realized that the addresschecker module API contains a class that could be used by the zipvalidator.  Since we are lazy, instead of refactoring a class into another module, we declare a dependency for addresschecker: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.zipvalidator{ <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> de.codecentric.addresschecker; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.zipvalidator.api; }</code> </pre><br><br>  Since cyclic dependencies are forbidden by definition, the compiler gets in our way (for the common good): <br><br><pre> <code class="java hljs">./de.codecentric.zipvalidator/<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java:<span class="hljs-number"><span class="hljs-number">2</span></span>: error: cyclic dependence involving de.codecentric.addresschecker</code> </pre><br><br>  So you can not do, and we are warned in advance about this, even during the compilation. <br><br>  <b>Implied Readability</b> <br><br>  To extend the functionality, we decide to inherit the zipvalidator by introducing a new module <code>de.codecentric.zipvalidator.model <br></code> <code>de.codecentric.zipvalidator.model <br></code>  containing a specific <b>model of</b> the validation result, and not just a banal boolean.  The new file structure is shown here: <br><br><pre> <code class="java hljs">three-modules-ok/ ‚îú‚îÄ‚îÄ de.codecentric.addresschecker ‚îÇ ‚îú‚îÄ‚îÄ de ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ codecentric ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ addresschecker ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ api ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ AddressChecker.java ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Run.java ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ internal ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ AddressCheckerImpl.java ‚îÇ ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java ‚îú‚îÄ‚îÄ de.codecentric.zipvalidator ‚îÇ ‚îú‚îÄ‚îÄ de ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ codecentric ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ zipvalidator ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ api ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ ZipCodeValidator.java ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ZipCodeValidatorFactory.java ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ internal ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ZipCodeValidatorImpl.java ‚îÇ ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java ‚îú‚îÄ‚îÄ de.codecentric.zipvalidator.model ‚îÇ ‚îú‚îÄ‚îÄ de ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ codecentric ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ zipvalidator ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ model ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ api ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ZipCodeValidationResult.java ‚îÇ ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java</code> </pre><br><br>  <code>ZipCodeValidationResult <br></code> class <code>ZipCodeValidationResult <br></code>  - a simple listing with instances of the form ‚Äútoo short‚Äù, ‚Äútoo long‚Äù, etc. <br>  Class <code>module-info.java <br></code> <code>module-info.java <br></code>  inherited this way: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.zipvalidator{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.zipvalidator.api; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> de.codecentric.zipvalidator.model; }</code> </pre><br><br>  Now our ZipCodeValidator implementation looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;strong&gt;ZipCodeValidationResult&lt;/strong&gt; zipCodeIsValid(String zipCode) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zipCode == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZipCodeValidationResult.ZIP_CODE_NULL; [snip] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZipCodeValidationResult.OK; } }</code> </pre><br><br>  The addresschecker module is now adapted so that it can accept and return as a return type, so that you can proceed, right?  Not!  Compilation gives: <br><br><pre> <code class="java hljs">./de.codecentric.addresschecker/de/[..]/internal/AddressCheckerImpl.java:<span class="hljs-number"><span class="hljs-number">5</span></span>: error: ZipCodeValidationResult is not visible because <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> de.codecentric.zipvalidator.model.api is not visible</code> </pre><br>  An error occurred while compiling addresschecker - zipvalidator uses exported types from the zipvalidator model in its public API.  Since addresschecker does not read this module, it cannot access this type. <br><br>  There are two solutions to this problem.  Obvious: add a read edge from addresschecker to the zipvalidator model.  However, this is a slippery slope: why should we declare this dependency, if it is needed only to work with zipvalidator?  Doesn't the zipvalidator have to guarantee that we can access all the necessary modules?  Should and can - here we come to implied readability.  By adding the public keyword to the required definition, we inform all client modules that they must also read another module.  As an example, consider the updated <code>module-info.java <br></code> class <code>module-info.java <br></code> <code>module-info.java <br></code>  zipvalidator: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.zipvalidator{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.zipvalidator.api; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> de.codecentric.zipvalidator.model; }</code> </pre><br><br>  Keyword <code>public <br></code> <code>public <br></code>  informs all modules reading zipvalidator that they must also read its model.  It was different to work with the classpath: well, you could not rely on Maven POM, if you wanted to ensure that all your dependencies were also available to any client;  to achieve this, you had to explicitly specify them if they were part of your public API.  This is a very beautiful model: if you use dependencies only inside the class, then why should your customers care?  And if you use them outside the class, you must also directly report this. <br><br>  <b>Summary</b> <br><br>  That came to an end the first part.  We discussed three questions that need to be answered for each module, as well as the modularization of the Java runtime.  Next, we looked at an example where we compiled, launched, and packaged a simple Java application consisting of two modules.  Then, using a working example, they studied how the module system responds to violation of the established rules.  Next, expanding the functionality, we studied the third module and talked about the concept of implied readability. <br><br>  The following part will address the following questions: <br><br><ul><li>  How does Jigsaw work if the module path contains several modules of the same name? </li><li>  What happens if there are different modules in the module path, which, however, export the same packages? </li><li>  What to do with inherited dependencies that are not modularized? </li><li>  How to create your own trimmed version of the performing environment? </li></ul></div><p>Source: <a href="https://habr.com/ru/post/271941/">https://habr.com/ru/post/271941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271929/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ187 (November 23 - 29, 2015)</a></li>
<li><a href="../271931/index.html">How is the rendering frame in GTA V</a></li>
<li><a href="../271935/index.html">What is under the hood of travel startups or why does a programmer need to go to Hack`n`Roll</a></li>
<li><a href="../271937/index.html">5 major risks in custom software development</a></li>
<li><a href="../271939/index.html">Asterisk + LUA: quick start</a></li>
<li><a href="../271943/index.html">Change desktop background and lock screen from CW / XAML UWP application</a></li>
<li><a href="../271945/index.html">Development of a parser, code generator and SQL editor using EMFText</a></li>
<li><a href="../271947/index.html">Opera Link closes in December</a></li>
<li><a href="../271951/index.html">Application implementation - device owner for Android</a></li>
<li><a href="../271953/index.html">Dispelling myths about secure passwords</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>