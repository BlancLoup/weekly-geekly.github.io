<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WAL in PostgreSQL: 4. Log setup</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, we got acquainted with the device of the buffer cache and, using its example, we realized that when the contents of RAM are lost during a failure,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WAL in PostgreSQL: 4. Log setup</h1><div class="post__text post__text-html js-mediator-article">  So, we got acquainted with the device of the <a href="https://habr.com/ru/company/postgrespro/blog/458186/">buffer cache</a> and, using its example, we realized that when the contents of RAM are lost during a failure, a <a href="https://habr.com/ru/company/postgrespro/blog/459250/">pre-write log is</a> needed to restore.  The size of the required log files and recovery time are limited due to a periodically executed <a href="https://habr.com/ru/company/postgrespro/blog/460423/">checkpoint</a> . <br><br>  In previous articles, we have already looked at a rather large number of important settings related to the journal in one way or another.  In this article (the last in this series), we will consider those tuning issues that have not yet been discussed: log levels and their purpose, as well as the reliability and performance of logging. <br><br><h1>  Log levels </h1><br>  The primary purpose of the prerecord log is to provide recovery after a failure.  But, if you still have to keep a journal, it can be adapted for other tasks, adding a certain amount of additional information to it.  There are several levels of logging.  They are set by the <em>wal_level</em> parameter and are organized so that the log of each next level includes everything that goes into the log of the previous level, plus something else new. <br><a name="habracut"></a><br><h2>  Minimal </h2><br>  The minimum possible level is set by the value <em>wal_level</em> = minimal and guarantees only recovery after a failure.  To save space, operations related to mass data processing (such as CREATE TABLE AS SELECT or CREATE INDEX) are not logged.  Instead, the necessary data is immediately written to disk, and a new object is added to the system directory and becomes visible when the transaction is committed.  If a failure occurs during the operation, the data already recorded remains invisible and does not violate consistency.  If the failure occurs after the operation is completed, everything necessary has already arrived on the disk and does not need to be logged. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We'll see.  First, set the required level (for this you will also need to change another parameter - <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Note that changing the level requires a server restart. <br><br>  Remember the current position in the log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Now let's create the table (CREATE TABLE AS SELECT) and write the position in the log again.  The amount of data selected by the SELECT statement does not matter in this case, so we will limit ourselves to one line. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  With the familiar pg_waldump utility, let's look at the log entries. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Some details, of course, may differ from launch to launch, but in this case this is what happened.  The Heap2 manager entry refers to cleaning, here it is an on-page cleaning of one of the tables in the system catalog (system objects are easily distinguished with the naked eye by the ‚Äúshort‚Äù number in rel): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Then there is a record about getting the next OID for the table that we are going to create: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Now the actual creation of the table: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  However, inserting data into a table is not logged.  Then there are numerous entries about inserting rows into different tables and indexes - this PostgreSQL registers the created table in the system directory (I give it in abbreviated form): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  And finally, transaction fixation: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  Replica </h2><br>  When we restore the system from the backup, we start from some state of the file system and gradually bring the data to the recovery point, playing back the archived journal entries.  The number of such records can be very large (for example, several days), that is, the recovery period will cover not one control point, but many.  Therefore, it is clear that the minimum level of the log is not enough - if some operation is not logged, we simply will not know that it needs to be repeated.  To restore from a backup, <em>all</em> operations must be logged. <br><br>  The same is true for replication - everything that is not logged will not be transferred to the replica and will not be reproduced.  But, if we want to execute requests on a replica, it is still complicated. <br><br>  First, we need information about exclusive locks that occur on the primary server, as they may conflict with requests on the replica.  Such locks are logged and applied on the replica (on behalf of the startup process). <br><br>  Secondly, you need to be able to build <a href="https://habr.com/ru/company/postgrespro/blog/446652/">data snapshots</a> , and for this, as we recall, information about ongoing transactions is needed.  In the case of a replica, we are talking not only about local transactions, but also about transactions on the main server.  The only way to transmit this information is to periodically write it to the log (this happens every 15 seconds). <br><br>  The log level, which guarantees both the ability to restore from a backup and the possibility of physical replication, is set by the value wal_level = <em>replica</em> .  (Prior to version 9.6, there were two separate levels archive and hot_standby, but then they were combined into one common one.) <br><br>  Starting with PostgreSQL 10, this is the default level (and before that it was minimal).  Therefore, just reset the parameters to default values: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  We delete the table and repeat exactly the same sequence of actions as last time: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  Now check the journal entries. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Cleaning, obtaining OID, creating a table and registering in the system directory - for now, everything is as it was: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, ‚Ä¶ rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  But something new.  The record of the exclusive lock related to the Standby manager - in this case, it is blocking the transaction number (why is it needed, we will talk in detail in the next series of articles): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  And this is a record about inserting rows into our table (compare the file number rel with the one indicated above in the CREATE record): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Commit record: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  And another record, which occurs periodically and is not tied to the completed transaction, refers to the Standby manager and reports on the transactions currently ongoing: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  Logical </h2><br>  Finally, the last level is set by the value of the parameter <em>wal_level</em> = logical and provides the possibility of logical decoding and logical replication.  It must be enabled on the publishing server. <br><br>  From the point of view of journal entries, this level is practically no different from replica - entries related to replication origins and arbitrary logical entries that can be added to the application log are added.  Basically, logical decoding depends on information about ongoing transactions, since you need to build a snapshot of data to track changes in the system catalog. <br><br>  Now we will not go into details of the operation of backup and replication - this is a big topic for a separate series of articles. <br><br><h1>  Record reliability </h1><br>  It is clear that the journaling mechanism must be reliable and guarantee the possibility of recovery in any situation (not related, of course, to damage to the data carrier).  Reliability is affected by many factors, of which we will consider caching, data corruption, and atomicity of recordings. <br><br><h2>  Caching </h2><br>  There are numerous caches on the data path to non-volatile storage (such as a hard disk drive). <br><br>  When a program (any, but in our case PostgreSQL) asks the operating system to write something to disk, the operating system transfers the data to its cache in RAM.  Actual recording occurs asynchronously, depending on the settings of the I / O scheduler of the operating system. <br><br>  When the OS decides to write data, they fall into the cache of the drive (hard disk).  Drive electronics can also delay recording, for example, collecting data in groups that are more profitable to record at the same time.  And if a RAID controller is used, another level of caching appears between the OS and the drive. <br><br>  Thus, if you do not take special measures, it is completely unclear when the data will really be safely stored.  This is usually not important, but there are critical places where PostgreSQL needs to be sure that the data is written securely.  First of all, this is journaling (if the journal entry did not reach the disk, it will disappear along with the rest of the contents of the RAM) and a checkpoint (it must be sure that the dirty pages are actually written to disk).  But there are other situations, say, the execution of non-journalized operations at the minimum level, etc. <br><br>  The operating system provides tools that must guarantee the immediate writing of data to non-volatile memory.  There are several options, but they come down to two main ones: either a synchronization command (fsync, fdatasync) is given after recording, or when opening a file (or writing to it), a special flag is indicated for synchronization or even direct recording, bypassing the OS cache. <br><br>  As for the log, the pg_test_fsync utility allows you to choose the method that is most suitable for a particular OS and a specific file system, and it is installed in the configuration parameter <em>wal_sync_method</em> .  Regular files are always synchronized using fsync. <br><br>  The subtle point is that when choosing a method, the characteristics of the equipment must be taken into account.  For example, if you use a controller supported by a backup battery, there is no reason not to use its cache, since the battery will allow you to save data in the event of a power failure. <br><br><blockquote>  The documentation contains <a href="https://postgrespro.ru/docs/postgresql/11/wal-reliability">many details</a> on this subject. <br></blockquote><br>  In any case, synchronization is expensive and takes place no more often than absolutely necessary (we will return to this issue a little lower when we talk about performance). <br><br>  Generally speaking, synchronization can be turned off (the <em>fsync</em> parameter is responsible for this), but in this case you should forget about storage reliability.  By disabling <em>fsync</em> , you agree that data may be irretrievably lost at any time.  Probably the only reasonable option to use this option is to temporarily increase productivity, when data can be easily restored from another source (for example, during the initial migration). <br><br><h2>  Data corruption </h2><br>  The equipment is imperfect and data may be damaged on the media, when transmitting data via interface cables, etc. Some of these errors are processed at the hardware level, but some are not. <br><br>  In order to detect the problem in time, the journal entries are always provided with checksums. <br><br>  Data pages can also be protected with checksums.  For now, this can only be done when the cluster is initialized, but in PostgreSQL 12 it will be possible to turn them on and off using the pg_checksums utility (though not yet on the fly, but only with the server stopped). <br><br>  In a production environment, checksums must be included, despite the overhead of their calculation and control.  This reduces the likelihood that a failure will not be detected in time. <br><br><blockquote>  Reduces, but does not eliminate. <br>  Firstly, checksums are only checked when accessing the page - therefore, damage can go unnoticed until it gets to all backups.  That is why <a href="https://postgrespro.ru/docs/postgrespro/11/app-pgprobackup">pg_probackup</a> checks for checksums of all pages of the cluster during backup. <br>  Secondly, a page filled with zeros is considered correct - if the file system mistakenly "nullifies" the file, this may go unnoticed. <br>  Thirdly, checksums protect only the main layer of data files.  The remaining layers and other files (for example, XACT transaction statuses) are not protected by anything. <br>  Alas. <br></blockquote><br>  Let's see how it works.  First, make sure that checksums are enabled (note that this is not the case when installing a package on Debian-like systems by default): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  The <em>data_checksums</em> parameter is read-only. <br><br>  Here is the file in which our table is located: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Stop the server and change a few bytes in the zero page, for example, delete the last journal entry from the LSN header. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  In principle, the server could not be stopped.  It is enough that the page was written to disk and was forced out of the cache (otherwise the server will work with the page from the cache).  But such a scenario is more difficult to reproduce. <br><br>  Now we start the server and try to read the table. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  But what if the data cannot be restored from the backup?  The <em>ignore_checksum_failure</em> parameter allows <em>you</em> to try to read the table, naturally with the risk of getting distorted data. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  Of course, in this case everything is successful, because we messed up only the page title, and not the data itself. <br><br>  And one moment.  When checksums are turned on, bits of prompts are written to the log (we <a href="https://habr.com/ru/company/postgrespro/blog/445820/">examined</a> them earlier), since a change in any, even non-essential, bit also leads to a change in the checksum.  With the checksums turned off, the <em>wal_log_hints</em> parameter is responsible for writing hint bits to the <em>log</em> . <br><br>  Changes to tooltip bits are always logged as a <em>full page image</em> (FPI, full page image), which increases the size of the log in order.  In this case, it makes sense to enable compression of full images using the <em>wal_compression</em> parameter (this parameter appeared in version 9.5).  Below we look at specific numbers. <br><br><h2>  Atomicity record </h2><br>  And finally, there is the problem of atomicity of the record.  The database page takes at least 8 KB (it can be 16 or 32 KB), and at a low level, recording takes place in blocks that are usually smaller (usually 512 bytes or 4 KB).  Therefore, in the event of a power failure, the data page may be partially recorded.  It is clear that during recovery it makes no sense to apply ordinary journal entries to such a page. <br><br>  For protection, PostgreSQL allows you to write to the log the <em>full image of the page</em> when it is first changed after the start of the control point (the same image is recorded when the tooltip bits change).  The <em>full_page_writes</em> parameter <em>controls this</em> , and it is enabled by default. <br><br>  If a page image is encountered during restoration in a log, it is unconditionally (without LSN checking) written to disk: there is more trust in it, because, like any log record, it is protected by a checksum.  And already regular journal entries are applied to this guaranteed correct image. <br><br>  Although PostgreSQL excludes unallocated space from the full page image (we previously <a href="https://habr.com/ru/company/postgrespro/blog/444536/">examined the</a> structure of the block), the volume of generated journal entries increases significantly.  As already mentioned, the situation can be improved by compressing the full images (parameter <em>wal_compression</em> ). <br><br>  In order to somehow feel the change in the size of the log, we will conduct a simple experiment using the pgbench utility.  Let's initialize: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  The <em>full_page_writes</em> parameter <em>is</em> enabled: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  Run the breakpoint and immediately run the test for 30 seconds. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Log Record Size: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  Now turn off the full_page_writes parameter: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  And repeat the experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Log Record Size: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  Yes, the size has decreased, but not at all as significant as one might expect. <br><br>  The reason is that the cluster is initialized with checksums in the data pages, and therefore you still have to write full page images to the log when changing the tooltip bits.  These data (in our case) make up about half of the total volume, which can be seen by looking at the statistics: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  For compactness, I removed the zero rows from the table.  Pay attention to the total line (Total) and compare the size of the full images (FPI size) with the size of ordinary records (Record size). <br><br>  The <em>full_page_writes</em> parameter can only be disabled if the file system and hardware used by themselves guarantee atomic recording.  But, as we can see, there is no great reason for this (assuming that checksums are included). <br><br>  Now let's see how compression helps. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Repeat the same experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Log Record Size: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Conclusion: in the presence of a large number of full page images (due to checksums or <em>full_page_writes</em> , that is, almost always), it most likely makes sense to use compression despite the fact that this loads the processor. <br><br><h1>  Performance </h1><br>  During normal server operation, a continuous sequential recording of log files occurs.  Since there is no random access, regular HDDs also cope with this task.  But this type of load is significantly different from how data files are accessed. <br><br>  Therefore, it is usually advantageous to place the log on a separate physical disk (or disk array) mounted on the server file system.  Instead of the $ PGDATA / pg_wal directory, you need to create a symbolic link to the corresponding directory. <br><br><blockquote>  There are a couple of situations in which log files need to not only be written, but also read.  The first is the understandable case of recovery after a failure.  The second is less trivial.  It occurs if streaming replication is used, and the replica does not manage to receive journal entries while they are still in the main server RAM buffers.  Then the walsender process has to read the necessary data from the disk.  We‚Äôll talk about this in more detail when we get to replication. <br></blockquote><br>  Logging takes place in one of two modes: <br><br><ul><li>  synchronous - when a transaction is committed, the continuation of work is impossible until all journal entries about this transaction are on the disk; </li><li>  asynchronous - the transaction completes immediately, and the log is written in the background. </li></ul><br>  Synchronous mode is determined by the <em>synchronous_commit</em> parameter and is enabled by default. <br><br>  Since synchronization is associated with real (i.e., slow) I / O, it is beneficial to do it as little as possible.  To do this, the servicing process that completes the transaction and writes a log takes a short pause, determined by the <em>commit_delay</em> parameter.  But this only happens if the system has at least <em>commit_siblings of</em> active transactions.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bet here is on the fact that during the waiting time some transactions will have time to complete and it will be possible to synchronize their records in one go. This is similar to how you hold the elevator door so that someone has time to drop into the cab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The default parameter is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_siblings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 5, and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0, so no wait actually occurs. Change </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is only useful in systems that perform a large number of short OLTP-transactions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the process flushes the log to disk to the required LSN (or slightly more if new entries were added during the wait). After that, the transaction is considered completed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With synchronous recording, durability is guaranteed (letter D in the acronym ACID) - if the transaction is committed, then all its journal entries are already on disk and will not be lost. The flip side is that synchronous recording increases the response time (the COMMIT command does not return control until synchronization ends) and reduces system performance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An asynchronous write can be obtained by setting </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronous_commit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off (or local). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During asynchronous recording, the log writer process resets the journal entries, alternating the wait cycles (which is set by the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 200ms parameter by default).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waking up after the next wait, the process checks to see if the full WAL pages appeared from the last time. If there are, then the process ignores the current, unfilled page, and records only fully filled ones. (True, it‚Äôs not always all at once: the recording stops, reaching the end of the cache, and continues from the beginning of the cache the next time.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If not a single page is full, the process writes the current (incomplete) page of the journal - for good reason woke up? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm aims to not synchronize the same page several times if possible, which is important for a large stream of changes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous recording is more efficient than synchronous recording - committing changes does not wait for recording. However, reliability decreases: the recorded data may disappear in the event of a failure if less than 3 √ó </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> time </font><font style="vertical-align: inherit;">elapsed between the commit and the failure </font><font style="vertical-align: inherit;">(which, by default, is a little more than half a second). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A difficult choice - efficiency or reliability - remains with the system administrator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note: unlike disabling synchronization ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsync</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off), asynchronous mode does not lead to the inability to restore. In the event of a failure, the system will still restore a consistent state, but perhaps some of the latest transactions will be absent from it. </font><em><font style="vertical-align: inherit;">Synchronous_commit</font></em></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be set as part of individual transactions. This allows you to increase productivity by sacrificing the reliability of only part of the transaction. Say, financial transactions always need to be fixed synchronously, and chat messages can sometimes be neglected. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In reality, both of these modes work together. Even with synchronous commit, long transaction logs will be written asynchronously to free up WAL buffers. And if, when resetting a page from the buffer cache, it turns out that the corresponding journal entry is not yet on disk, it will be immediately reset in synchronous mode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get some idea of ‚Äã‚Äãwhat asynchronous commit gives, we try to repeat the pgbench test in this mode.</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With synchronous commit, we received approximately 900 transactions per second (tps), with asynchronous commit - 1500. Of course, in a real system under real load the ratio will be different, but it is clear that the effect can be very significant with short transactions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, the series of articles about journaling came to an end. </font><font style="vertical-align: inherit;">If something important is left behind the scenes, do not find it difficult to write in the comments.</font></font> Thanks to all! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And then we will have exciting adventures in the world of locks, but that's another story. </font></font></div><p>Source: <a href="https://habr.com/ru/post/461523/">https://habr.com/ru/post/461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461509/index.html">Travel Assistants: A selection of gadgets and accessories</a></li>
<li><a href="../46151/index.html">AppleJack - Mac OS X troubleshooter</a></li>
<li><a href="../461511/index.html">Python Dependency Management: A Comparison of Approaches</a></li>
<li><a href="../461519/index.html">Best Copy-Paste Algorithms for C and C ++. Haiku OS Recipe Collection</a></li>
<li><a href="../46152/index.html">Active users</a></li>
<li><a href="../461525/index.html">How I did a really adaptive slider (carousel)</a></li>
<li><a href="../461527/index.html">DIY acoustic levitation</a></li>
<li><a href="../461531/index.html">Tic Tac Toe Part 6: Flask and Celery / RabbitMQ</a></li>
<li><a href="../461533/index.html">Visualization of the sleep of the first year of the child on the patterns of the blanket</a></li>
<li><a href="../461535/index.html">C ++, FIX, Oracle and PL / SQL: what an IT specialist needs to know to get a job in finance + real job opportunities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>