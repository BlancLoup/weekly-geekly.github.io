<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Construct XML using LINQ to XML API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Until recently, I terribly did not like working with XML files, I tried to avoid it wherever possible, simply replacing them with standard application...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Construct XML using LINQ to XML API</h1><div class="post__text post__text-html js-mediator-article">  Until recently, I terribly did not like working with XML files, I tried to avoid it wherever possible, simply replacing them with standard application configuration files.  But where it was necessary to use data exchange - it was impossible to leave XML.  We had to create a large amount of code in order to convert or read a small amount of information.  Yes, such is the XML Document Object Model (DOM) API. <br><a name="habracut"></a><br><h4>  XML DOM API Example </h4><br>  You need to get this message: <br><blockquote><code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Groups</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">Group</font> <font color="#ff0000">Id</font> <font color="#0000ff">="523063B0-47C0-4ABE-8D38-4A449137A00B"</font> <font color="#ff0000">DepartmentId</font> <font color="#0000ff">="D939743F-BFF7-41E4-9A1B-1193EEFF0486"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">Name</font> <font color="#0000ff">&gt;</font> 555A <font color="#0000ff">&lt;/</font> <font color="#800000">Name</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">Course</font> <font color="#0000ff">&gt;</font> 5 <font color="#0000ff">&lt;/</font> <font color="#800000">Course</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Group</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Groups</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><br>  To do this, you need to write a fairly simple but voluminous code: <br><blockquote> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">sealed</font> <font color="#0000ff">class</font> <font color="#2B91AF">Nodes</font> <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> Root = <font color="#A31515">"Groups"</font> ; <br> <br> <font color="#008000">// Attributes.</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> Group = <font color="#A31515">"Group"</font> ; <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> Id = <font color="#A31515">"Id"</font> ; <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> DepartmentId = <font color="#A31515">"DepartmentId"</font> ; <br> <br> <font color="#008000">// Elements.</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> Name = <font color="#A31515">"Name"</font> ; <br> <font color="#0000ff">public</font> <font color="#0000ff">const</font> <font color="#0000ff">string</font> Course = <font color="#A31515">"Course"</font> ; <br> } <br> <br> <font color="#008000">// Create XML document.</font> <br> <font color="#2B91AF">XmlDocument</font> document = <font color="#0000ff">new</font> <font color="#2B91AF">XmlDocument</font> (); <br> <br> <font color="#008000">// Create root element.</font> <br> XmlElement rootElement = document.CreateElement( <font color="#2B91AF">Nodes</font> .Root); <br> <br> <font color="#008000">// Create Group element.</font> <br> XmlElement groupElement = document.CreateElement( <font color="#2B91AF">Nodes</font> .Group); <br> <br> <font color="#008000">// Create attributes.</font> <br> <font color="#2B91AF">XmlAttribute</font> idAttribute = document.CreateAttribute( <font color="#2B91AF">Nodes</font> .Id); <br> idAttribute.InnerText = <font color="#A31515">"523063B0-47C0-4ABE-8D38-4A449137A00B"</font> ; <br> groupElement.Attributes.Append(idAttribute); <br> <br> <font color="#2B91AF">XmlAttribute</font> departmentIdAttribute = document.CreateAttribute( <font color="#2B91AF">Nodes</font> .DepartmentId); <br> departmentIdAttribute.InnerText = <font color="#A31515">"D939743F-BFF7-41E4-9A1B-1193EEFF0486"</font> ; <br> groupElement.Attributes.Append(departmentIdAttribute); <br> <br> <font color="#008000">// Create elements.</font> <br> <font color="#2B91AF">XmlElement</font> nameElement = document.CreateElement( <font color="#2B91AF">Nodes</font> .Name); <br> nameElement.InnerText = <font color="#A31515">"555A"</font> ; <br> groupElement.AppendChild(nameElement); <br> <br> <font color="#2B91AF">XmlElement</font> courseElement = document.CreateElement( <font color="#2B91AF">Nodes</font> .Course); <br> courseElement.InnerText = <font color="#A31515">"5"</font> ; <br> groupElement.AppendChild(courseElement); <br> <br> rootElement.AppendChild(groupElement); <br> document.AppendChild(rootElement);</font></code> </blockquote> <br><br>  Agree with me that writing, disassembling and accompanying such code is not very pleasant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With this code, it is impossible to get an idea of ‚Äã‚Äãthe resulting XML structure.  With each element or attribute, you must always perform three steps: create, set the InnerText property and add to an already existing element or document.  Also, without creating an XmlDocument, it is impossible to simply create an element, and this is necessary quite often. <br><br>  Fortunately, Microsoft gave us not only the ability to perform integrated LINQ to XML queries, but also reworked the XML DOM API. <br>  This is what I want to tell more today.  For this you need to connect the following namespaces: <br><blockquote> <code><font color="black"><font color="#0000ff">using</font> System.Collections.Generic; <br> <font color="#0000ff">using</font> System.Linq; <br> <font color="#0000ff">using</font> System.Xml.Linq;</font></code> </blockquote> <br><br>  As I said, one of the drawbacks of the standard DOM model was the hard-to-read structure of the resulting XML file.  The LINQ to XML API solves this problem by offering a new technique called functional design.  Functional design allows you to construct XML objects and initialize their values ‚Äã‚Äã‚Äî at the same time, in a single statement, at the expense of many overloaded constructors. <br><br>  Let's see how the construction of an XML file already known to us using the LINQ to XML API will look like: <br><blockquote> <code><font color="black"><font color="#2B91AF">XElement</font> document = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">Nodes</font> .Root, <br> <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">Nodes</font> .Group, <br> <font color="#0000ff">new</font> <font color="#2B91AF">XAttribute</font> ( <font color="#2B91AF">Nodes</font> .Id, <font color="#A31515">"523063B0-47C0-4ABE-8D38-4A449137A00B"</font> ), <br> <font color="#0000ff">new</font> <font color="#2B91AF">XAttribute</font> ( <font color="#2B91AF">Nodes</font> .DepartmentId, <font color="#A31515">"D939743F-BFF7-41E4-9A1B-1193EEFF0486"</font> ), <br> <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">Nodes</font> .Name, <font color="#A31515">"555A"</font> ), <br> <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">Nodes</font> .Course, 5)));</font></code> </blockquote> <br>  Well, how?  Which code is easier for you to read?  The answer is obvious. <br><br><h4>  Object model </h4><br><br><img src="https://habrastorage.org/storage/368e4dc5/08b60a24/6fcc83d9/02ff8101.jpg"><br><br>  The <strong>XObject</strong> , <strong>XNode,</strong> and <strong>XContainer classes</strong> are abstract, so we cannot create them. <br>  The <strong>XAttribute</strong> class is not inherited from <strong>XNode</strong> , i.e.  is not a node; it is a simple element of the collection that represents a key-value pair. <br>  The <strong>XDocument</strong> and <strong>XElement</strong> classes are the only ones that can contain nodes inherited from <strong>XNode</strong> . <br><br><h4>  Xdocument </h4><br>  In LINQ to XML API, it is not at all necessary to create an <strong>XDocument</strong> in order to create an XML tree or its fragment. <br><blockquote> <code><font color="black"><font color="#2B91AF">XDocument</font> document = <font color="#0000ff">new</font> <font color="#2B91AF">XDocument</font> (); <br> <font color="#2B91AF">Console</font> .WriteLine(document.ToString());</font></code> </blockquote> <br>  We get an empty result. <br><br>  <strong>XDocument</strong> by itself has nothing useful, only the ability to add an ad to the document ( <strong>XDeclaration</strong> ), type creation ( <strong>XDocumentType</strong> ) or processing instruction ( <strong>XProcessingInstruction</strong> ). <br><br>  It has static methods for reading the contents of documents, with various options for overloads: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">Stream</font> stream); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#0000ff">string</font> uri); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">TextReader</font> textReader); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">XmlReader</font> reader); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">Stream</font> stream, LoadOptions options); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#0000ff">string</font> uri, LoadOptions options); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">TextReader</font> textReader, LoadOptions options); <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">XDocument</font> Load( <font color="#2B91AF">XmlReader</font> reader, LoadOptions options);</font></code> </blockquote> <br>  And also to save the document: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#2B91AF">Stream</font> stream); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#0000ff">string</font> fileName); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#2B91AF">TextWriter</font> textWriter); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#2B91AF">XmlWriter</font> writer); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#2B91AF">Stream</font> stream, SaveOptions options); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#0000ff">string</font> fileName, SaveOptions options); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Save( <font color="#2B91AF">TextWriter</font> textWriter, SaveOptions options);</font></code> </blockquote> <br>  The element ( <strong>XElement</strong> ) has the same methods. <br><br>  I use <strong>XDocument</strong> only if I need to set an advertisement for a document that contains the version number and encoding. <br><br><h4>  Xdeclaration </h4><br>  <strong>XDeclaration</strong> objects, as you may have guessed, contain declarations and are added to the document, although the compiler allows adding declarations to the element ( <strong>XElement</strong> ), but this will not give any visible result. <br><blockquote> <code><font color="black"><font color="#2B91AF">XDocument</font> document = <font color="#0000ff">new</font> <font color="#2B91AF">XDocument</font> ( <br> <font color="#0000ff">new</font> <font color="#2B91AF">XDeclaration</font> ( <font color="#A31515">"1.0"</font> , <font color="#A31515">"UTF-8"</font> , <font color="#A31515">"yes"</font> )); <br> <font color="#2B91AF">Console</font> .WriteLine(document.ToString());</font></code> </blockquote> <br>  This code also does not display any lines, although if you look at the debugger, the ad is still added: <br><br><img src="https://habrastorage.org/storage/86e291f6/7afefa72/84351cba/55cdda9a.png"><br><br>  The declaration will be visible if you use the <strong>Save ()</strong> method of the <strong>XDocument</strong> class. <br><br><h4>  Xelement </h4><br>  The most commonly used API object. <br>  It has many designers, consider two of them: <br><br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">XName</font> name, <font color="#0000ff">object</font> content); <br> <font color="#0000ff">public</font> <font color="#2B91AF">XElement</font> ( <font color="#2B91AF">XName</font> name, <font color="#0000ff">params</font> <font color="#0000ff">object</font> [] content);</font></code> </blockquote> <br>  The first constructor is the simplest case when an element has no child elements and we specify only its value, the second constructor specifies child elements such as elements, attributes, processing instructions, comments ( <strong>XComment</strong> ), etc. <br><br>  Create the simplest element: <br><blockquote> <code><font color="black"><font color="#2B91AF">XElement</font> element = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Element"</font> , 777); <br> <font color="#2B91AF">Console</font> .WriteLine(element.ToString()); <br> <font color="#2B91AF">Console</font> .WriteLine(( <font color="#0000ff">int</font> )element);</font></code> </blockquote> <br>  Result: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Element</font> <font color="#0000ff">&gt;</font> 777 <font color="#0000ff">&lt;/</font> <font color="#800000">Element</font> <font color="#0000ff">&gt;</font> <br> 777</font></code> </blockquote> <br>  As you can see, access to the value has become even easier due to the overridden explicit casting of elements; it is enough to cast the element to its original type in order to see its value.  <strong>XElement</strong> overrides the explicit cast for all simplest types.  Now even the <strong>Value</strong> property is not necessary to access. <br>  You ask, the constructor requires <strong>XName</strong> , and I pass it a string?  And I will answer you: the string is implicitly <strong>cast</strong> to an <strong>XName</strong> object.  In essence, <strong>XName</strong> is a string, only with the possibility of defining a namespace ( <strong>XNamespace</strong> ). <br><br>  I will give a more detailed example of creating XML from objects: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">sealed</font> <font color="#0000ff">class</font> <font color="#2B91AF">Teacher</font> <br> { <br> <font color="#0000ff">public</font> <font color="#2B91AF">Guid</font> Id; <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> FirstName; <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> LastName; <br> } <br> <br> <font color="#2B91AF">IEnumerable</font> &lt; <font color="#2B91AF">Teacher</font> &gt; teachers = <font color="#0000ff">new</font> [] <br> { <br> <font color="#0000ff">new</font> <font color="#2B91AF">Teacher</font> () { Id = <font color="#2B91AF">Guid</font> .NewGuid(), FirstName = <font color="#A31515">""</font> , LastName = <font color="#A31515">""</font> }, <br> <font color="#0000ff">new</font> <font color="#2B91AF">Teacher</font> () { Id = <font color="#2B91AF">Guid</font> .NewGuid(), FirstName = <font color="#A31515">""</font> , LastName = <font color="#A31515">""</font> } <br> }; <br> <br> <font color="#2B91AF">XElement</font> elements = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Teachers"</font> , <br> teachers.Select(t =&gt; <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Teacher"</font> , <br> <font color="#0000ff">new</font> <font color="#2B91AF">XAttribute</font> ( <font color="#A31515">"Id"</font> , t.Id), <br> <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"FirstName"</font> , t.FirstName), <br> <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"LastName"</font> , t.LastName)))); <br> <br> <font color="#2B91AF">Console</font> .WriteLine(elements.ToString());</font></code> </blockquote> <br>  As a result, we have: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Teachers</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">Teacher</font> <font color="#ff0000">Id</font> <font color="#0000ff">="80321d66-ee4b-4b55-ace8-3892b682d483"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">FirstName</font> <font color="#0000ff">&gt;</font>  <font color="#0000ff">&lt;/</font> <font color="#800000">FirstName</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">LastName</font> <font color="#0000ff">&gt;</font>  <font color="#0000ff">&lt;/</font> <font color="#800000">LastName</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Teacher</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">Teacher</font> <font color="#ff0000">Id</font> <font color="#0000ff">="33f58b19-1bbb-468f-acee-961edb63ce0b"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">FirstName</font> <font color="#0000ff">&gt;</font>  <font color="#0000ff">&lt;/</font> <font color="#800000">FirstName</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">LastName</font> <font color="#0000ff">&gt;</font>  <font color="#0000ff">&lt;/</font> <font color="#800000">LastName</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Teacher</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Teachers</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><h4>  XAttribute </h4><br>  As I said earlier, is a key-value pair for the collection of element attributes.  Creating and adding attributes to an element is quite a simple task: <br><blockquote> <code><font color="black"><font color="#2B91AF">XAttribute</font> attribute = <font color="#0000ff">new</font> <font color="#2B91AF">XAttribute</font> ( <font color="#A31515">"Id"</font> , <font color="#2B91AF">Guid</font> .NewGuid()); <br> <font color="#2B91AF">XElement</font> element = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Teachers"</font> ); <br> element.Add(attribute); <br> <font color="#2B91AF">Console</font> .WriteLine(element.ToString());</font></code> </blockquote> <br>  Or: <br><blockquote> <code><font color="black"><font color="#2B91AF">XElement</font> element = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Teachers"</font> , <br> <font color="#0000ff">new</font> <font color="#2B91AF">XAttribute</font> ( <font color="#A31515">"Id"</font> , <font color="#2B91AF">Guid</font> .NewGuid())); <br> <font color="#2B91AF">Console</font> .WriteLine(element.ToString());</font></code> </blockquote> <br>  The result is the same: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Teachers</font> <font color="#ff0000">Id</font> <font color="#0000ff">="713c6cbf-f698-42fd-b5fc-74415b93d824"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <br><br><h4>  Xcomment </h4><br>  Creating and adding comments also does not cause any difficulties: <br><blockquote> <code><font color="black"><font color="#2B91AF">XElement</font> teacherElement = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> ( <font color="#A31515">"Teacher"</font> , <br> <font color="#0000ff">new</font> <font color="#2B91AF">XComment</font> ( <font color="#A31515">"Teacher element"</font> )); <br> <font color="#2B91AF">Console</font> .WriteLine(teacherElement.ToString());</font></code> </blockquote> <br>  Result: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Teacher</font> <font color="#0000ff">&gt;</font> <br> <font>&lt;!--Teacher element--&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Teacher</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><br><h4>  Conclusion </h4><br>  At this stage I would like to finish.  Yes, I did not consider using examples of processing instructions, creating document types and other model classes, but this knowledge will be enough to create both simple and complex in structure XML documents. <br><br>  In the next article, I plan to consider a walk through the contents of an XML document. </div><p>Source: <a href="https://habr.com/ru/post/109900/">https://habr.com/ru/post/109900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../109892/index.html">Overview of Configuration Management Best Practices Book</a></li>
<li><a href="../109894/index.html">New version of ASP.NET MVC 3 RC2 released</a></li>
<li><a href="../109895/index.html">5th Startup Crash Test</a></li>
<li><a href="../109897/index.html">Live stream from TechCrunch Moscow has begun</a></li>
<li><a href="../109899/index.html">Integrated project management system for small and medium businesses</a></li>
<li><a href="../109901/index.html">Hi-Fi in the digital age. Part 1</a></li>
<li><a href="../109904/index.html">Vigenere cipher modification</a></li>
<li><a href="../109905/index.html">City portal of Big Sochi on Drupal</a></li>
<li><a href="../109910/index.html">Who is responsible for user-generated content?</a></li>
<li><a href="../109911/index.html">Greeting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>