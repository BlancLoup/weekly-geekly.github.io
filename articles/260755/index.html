<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the PVS-Studio team improved the Unreal Engine code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our company creates, promotes and sells the PVS-Studio static code analyzer for C / C ++ programmers. However, our interaction with customers is not l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the PVS-Studio team improved the Unreal Engine code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9f9/b32/bd4/9f9b32bd48eac393913819d51ae4f80c.png" align="left">  Our company creates, promotes and sells the PVS-Studio static code analyzer for C / C ++ programmers.  However, our interaction with customers is not limited solely to the sale of licenses for the PVS-Studio product.  For example, we do some contract work.  By virtue of the NDA, we usually cannot tell about them, and an interesting story will not work.  The names of the projects in which we participate will also say nothing to the majority of our readers.  But this time, the name says a lot.  We worked together with Epic Games on the Unreal Engine project.  This will be our story. <br><a name="habracut"></a><br>  To promote the PVS-Studio static code analyzer, we came up with an interesting article format.  We check open projects and write about the defects found in the code.  Here you can take a look at these articles: <a href="http://www.viva64.com/ru/a/0084/">updated list</a> .  From these articles all benefit.  Readers are interested to look at other people's mistakes.  At the same time they will learn for themselves new ways to avoid these mistakes, using some tricks or coding style.  For us, the benefit is that more people learn about the existence of PVS-Studio.  For authors of projects, too, the benefits - they can fix some bugs. <br><br>  One of such articles was " <a href="http://www.viva64.com/ru/b/0249/">Long-awaited check of Unreal Engine 4</a> ".  The Unreal Engine source code was notable for its high quality, but as you know, all software development projects contain errors and PVS-Studio coped well with finding these errors.  We checked the project and sent the test results to Epic Games.  The authors of the project have thanked us and corrected the defects found by us.  But this was not enough for us, and we decided to try to sell the license for PVS-Studio to Epic Games. <br><br>  Epic Games was interested in using PVS-Studio to improve its engine.  Thus, we check and edit the Unreal Engine source code so that there are no bugs left in the code and, at the same time, the analyzer no longer generates a single false positive.  After that, they will start using PVS-Studio on their code base, minimizing the complexity of integrating the analyzer into their development process.  In this case, Epic Games agreed to pay not only the license, but also reward us additionally for the work done. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We agreed.  Work is done.  And now we offer the reader to get acquainted with interesting moments that we encountered while working with the Unreal Engine source codes. <br><br>  From the PVS-Studio side, Pavel Eremeev, Svyatoslav Razmyslov, Anton Tokarev participated in the project.  From Epic Games, we received the most help from Andy Bayle and Dan O'Connor - without them, our work would have been impossible, thank you! <br><br><h2>  Integration of PVS-Studio analysis into the Unreal Engine assembly </h2><br>  For assembly in the Unreal Engine uses its own build system - the Unreal Build Tool.  There is also a set of scripts for generating project files for different platforms and compilers.  Since PVS-Studio is primarily aimed at working with the Microsoft Visual C ++ compiler, we used the script to get project files (* .vcxproj) for the Microsoft Visual Studio environment. <br><br>  PVS-Studio has a plug-in that integrates into the Visual Studio development environment and allows you to perform a one-click analysis.  However, projects generated for the Unreal Engine are not ‚Äúnormal‚Äù MSBuild projects that Visual Studio uses. <br><br>  When compiling the Unreal Engine in Visual Studio, the environment calls MSBuild when the build starts, however, MSBuild itself is used only as a wrapper to invoke the previously mentioned Unreal Build Tool. <br><br>  To analyze the source code in PVS-Studio, you need the results of the preprocessor.  The analyzer requires a <a href="http://www.viva64.com/ru/t/0076/">* .i file</a> in which all header files are inserted and all macros are opened. <br><br>  <b>Note.</b>  <b>Further this section will be of interest only to those who use a nonstandard assembly system, for example, like the Unreal Engine.</b>  If you plan to try checking your project with PVS-Studio, which is going to be cunning somehow, then I suggest reading this section to the end.  Perhaps he will help cope with the verification of your project.  If you have an ordinary project for Visual Studio, or you want to quickly read about the errors found, you can skip this section. <br><br>  In order to correctly run the preprocessor, you need information about the compilation parameters.  This information is available in ‚Äúordinary‚Äù MSBuild projects, and the PVS-Studio plugin ‚Äúsees‚Äù it and can independently preprocess the necessary sources for the subsequent launch of the analyzer.  The situation is different with Unreal Engine projects. <br><br>  As mentioned above, these projects are just a ‚Äúwrapper‚Äù, the actual compiler call is made by the Unreal Build Tool.  Therefore, the compilation options are not available to the PVS-Studio plugin for Visual Studio.  One-click analysis cannot be run, although the plugin can be used to view the analysis results. <br><br>  The analyzer itself (PVS-Studio.exe) is a command-line application similar in its use case to the C ++ compiler.  Like the compiler, it must be run for each source file, passing the compilation parameters of this file via the command line or response file.  The analyzer itself will launch the correct preprocessor and subsequently perform the analysis. <br><br>  <i>Note.</i>  <i>There is another way to work.</i>  <i>You can also run the analyzer for an already prepared preprocessed file.</i> <br><br>  Thus, a universal solution for integrating the PVS-Studio analyzer will be to call its executable file in the same place where the compiler is called ‚Äî that is,  in the assembly system.  In this case, in the Unreal Build Tool.  It is clear that this will require modification of the used assembly system, which, as in our case, may be undesirable.  Therefore, just for similar situations we created a system of ‚Äúinterception‚Äù of calls to the compiler - Compiler Monitoring. <br><br>  The Compiler Monitoring system is able to ‚Äúcatch‚Äù the start of compilation processes (in the case of Visual C ++, these are cl.exe processes), collect all the parameters necessary for preprocessing from such processes, and restart the preprocessing of compiled files, and then run their analysis.  So do. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/766/2a0/9b57662a060ac72e1000f18536594ea6.png"></div><br><br>  Figure 1. Schematic representation of the verification process of the Unreal Engine project. <br><br>  Integration of the Unreal Engine analysis is for us to start immediately before assembling the monitoring process (CLMonitor.exe), which, upon completion of the assembly, will already perform all the necessary steps for preprocessing and directly calling the analyzer.  To start monitoring, you need to run a simple command: <br><pre><code class="cpp hljs">CLMonitor.exe monitor</code> </pre> <br>  CLMonitor.exe will launch itself in tracking mode and exit.  At the same time, another CLMonitor.exe process will remain hanging in the background, carrying out a direct ‚Äútrapping‚Äù of the compilers.  Upon completion of the assembly, you need to execute another simple command: <br><pre> <code class="cpp hljs">CLMonitor.exe analyze <span class="hljs-string"><span class="hljs-string">"UE.plog"</span></span></code> </pre> <br>  Now CLMonitor.exe will launch directly the analysis of the previously collected source files and save the results to the UE.plog file, with which you can already work in our IDE plugin. <br><br>  We set up on our Continuous Integration server a regular nightly build of interesting Unreal Engine configurations with the subsequent launch of the analysis.  Thus, we, first of all, checked that our edits did not break the assembly, and secondly, we received every morning a new report on the verification of the Unreal Engine, taking into account all the revisions made the previous day.  And before sending the Pull Request to include our edits in the main project repository, we could easily check that the current version in our repository is stable by simply restarting the build on the server. <br><br><h2>  Nonlinear speed of edits </h2><br>  So, we have mastered the process of building the project and its analysis.  Now let's talk about edits in the code, based on the issued warnings. <br><br>  At first glance it may seem that the number of warnings issued by the analyzer from day to day should decrease evenly.  Approximately the same number of messages is suppressed with the help of some PVS-Studio mechanisms, approximately the same number of edits are made in the code. <br><br>  That is, theoretically, you can expect some such schedule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/25e/b14/67b25eb14026d185b0d7180d2d31bc1e.png"></div><br><br>  Figure 2. The perfect schedule.  The number of errors decreases evenly with each working day. <br><br>  In fact, messages disappear in the beginning faster than later.  First, at the initial stage, warnings in the macros are suppressed, and this quickly reduces their number.  Secondly, it turns out that in the beginning obvious things are corrected, and incomprehensible places are postponed for later.  We can explain why simple things were ruled in the beginning.  I wanted to show developers from Epic Games that we started to work and the process went.  It would be strange to start with the complex and get stuck on it. <br><br>  In total, it took 17 working days to work directly with the Unreal Engine code.  Our goal was to destroy all the warnings of the first and second levels of general purpose.  Here's how the work went: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/0a5/028/1e40a5028e11e4a2c389dc013f048e52.png"></div><br><br>  Table 1. Number of analyzer warnings on different days. <br><br>  Pay attention to the numbers highlighted in red.  In the first couple of days, we got a little accustomed, and then suppressed warnings in some macros, drastically reducing the number of false positives. <br><br>  Seventeen working days is a lot, and readers should be explained.  First, the project did not work the whole team, but only two people.  At the same time they were engaged in other tasks.  Secondly, the Unreal Engine code is completely unfamiliar to us, so making the edit was quite a challenge.  I had to constantly figure out whether to edit the code, and if so, how. <br><br>  Now the same data presented in the form of a smoothed graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d03/7a4/7a0/d037a47a0e177c4184198a096bc52d31.png"></div><br><br>  Figure 3. The smoothed graph of the number of alerts. <br><br>  <b>Practical conclusion.</b>  It is necessary to remember yourself and others to warn.  A bad idea is to make an estimate of the time it takes to work through all the warnings, only on the first days of work.  In the early days, work is going very fast and the forecast will be too optimistic. <br><br>  But it is still necessary to evaluate somehow.  I think some kind of magic formula will work well here and over time we will compose it and show it to the world.  While we do not have enough statistics to come up with something true. <br><br><h2>  About errors found </h2><br>  We corrected a lot of code fragments.  Edits can be divided into 3 groups: <ol><li>  The real mistakes.  Below we give a few such errors as an example. </li><li>  There was no trouble, but the code was confusing the analyzer and could confuse the person who starts to study this code.  In other words, this code, which "smells" and it is also useful to correct it.  What we did. </li><li>  Edits that are caused solely by the need to "please" the code analyzer, issuing false positives.  We tried, if possible, to put the suppression of false messages in a separate special file or improve the operation of the analyzer itself.  But still, several places had to be refactored to help the analyzer understand what was happening. </li></ol>  As promised, look at some examples of errors.  We chose a simpler and more interesting code. <br><br>  The first interesting message from PVS-Studio: V506 Pointer to local variable "NewBitmap"  Such a pointer will become invalid.  fontcache.cpp 466 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRenderData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... FT_Bitmap* Bitmap = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Slot-&gt;bitmap.pixel_mode == FT_PIXEL_MODE_MONO ) { FT_Bitmap NewBitmap; .... Bitmap = &amp;NewBitmap; } .... OutRenderData.RawPixels.AddUninitialized( Bitmap-&gt;rows * Bitmap-&gt;width ); .... }</code> </pre> <br>  The address of the NewBitmap object is stored in the Bitmap pointer.  The trouble is that right after this, the lifetime of the NewBitmap object ends and it collapses.  It turns out that Bitmap points to an already destroyed object. <br><br>  When attempting to use a pointer to access a destroyed object, <a href="http://www.viva64.com/ru/t/0066/">undefined behavior</a> will occur.  How it will manifest itself is unknown.  The program can even successfully work for many years if, thanks to luck, the data of a dead object (located on the stack) are not overwritten by something else. <br><br>  It will be correct to make the NewBitmap declaration outside the 'if' operator: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRenderData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... FT_Bitmap* Bitmap = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; FT_Bitmap NewBitmap; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Slot-&gt;bitmap.pixel_mode == FT_PIXEL_MODE_MONO ) { FT_Bitmap_New( &amp;NewBitmap ); <span class="hljs-comment"><span class="hljs-comment">// Convert the mono font to 8bbp from 1bpp FT_Bitmap_Convert( FTLibrary, &amp;Slot-&gt;bitmap, &amp;NewBitmap, 4 ); Bitmap = &amp;NewBitmap; } else { Bitmap = &amp;Slot-&gt;bitmap; } .... OutRenderData.RawPixels.AddUninitialized( Bitmap-&gt;rows * Bitmap-&gt;width ); .... }</span></span></code> </pre> <br>  Next warning PVS-Studio: V522 Dereferencing of the null pointer 'GEngine' might take place.  Check the logical condition.  gameplaystatics.cpp 988 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UGameplayStatics::DeactivateReverbEffect(....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GEngine || !GEngine-&gt;UseSound()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } UWorld* ThisWorld = GEngine-&gt;GetWorldFromContextObject(....); .... }</code> </pre> <br>  If the GEngine pointer is non-zero, then the function is exited.  All is well.  But if the GEngine pointer is zero, then it is dereferenced. <br><br>  We fixed the code as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UGameplayStatics::DeactivateReverbEffect(....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GEngine == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || !GEngine-&gt;UseSound()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } UWorld* ThisWorld = GEngine-&gt;GetWorldFromContextObject(....); .... }</code> </pre> <br>  An interesting typo is waiting for readers in the following code snippet.  In it, the analyzer detected a meaningless function call: V530 The return value of the function 'Memcmp' is required to be utilized.  pathfollowingcomponent.cpp 715 <br><pre> <code class="cpp hljs">int32 UPathFollowingComponent::OptimizeSegmentVisibility( int32 StartIndex) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Path.IsValid()) { Path-&gt;ShortcutNodeRefs.Reserve(....); Path-&gt;ShortcutNodeRefs.SetNumUninitialized(....); } FPlatformMemory::Memcmp(Path-&gt;ShortcutNodeRefs.GetData(), RaycastResult.CorridorPolys, RaycastResult.CorridorPolysCount * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(NavNodeRef)); .... }</code> </pre> <br>  The result of the Memcmp function is not used.  This alarmed the analyzer. <br><br>  In fact, the programmer planned to copy the memory using the Memcpy () function, but made a typo.  Corrected code: <br><pre> <code class="cpp hljs">int32 UPathFollowingComponent::OptimizeSegmentVisibility( int32 StartIndex) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Path.IsValid()) { Path-&gt;ShortcutNodeRefs.Reserve(....); Path-&gt;ShortcutNodeRefs.SetNumUninitialized(....); FPlatformMemory::Memcpy(Path-&gt;ShortcutNodeRefs.GetData(), RaycastResult.CorridorPolys, RaycastResult.CorridorPolysCount * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(NavNodeRef)); } .... }</code> </pre> <br>  Let's talk about the diagnostic message, which can be found when checking almost any project.  Already a very common type of error it reveals.  This is a diagnosis of V595.  In our database of errors, it ranks first in the number of defects found (see <a href="http://www.viva64.com/ru/examples/V595/">examples</a> ).  At first glance, the list is not that big compared to, say, <a href="http://www.viva64.com/ru/examples/V501/">V501</a> .  But the fact is that the V595 diagnostics are somewhat boring in order to write many examples from some project.  Often, one example is written out and a type of postscript is made: And 161 additional diagnostic messages.  In half of the cases, these are the real mistakes.  Here's what it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f1/676/ce1/3f1676ce1c837ff79e0f271715d55e8f.png"></div><br><br>  Figure 4. Horror diagnostics V595. <br><br>  Diagnostics V595 finds code points where pointer dereferencing is performed before it is checked for zero.  Usually in the <a href="http://www.viva64.com/ru/a/0084/">checked projects</a> there is always a certain number of such warnings.  Checking and dereferencing a pointer can be quite far in the function code: tens or even hundreds of lines apart, which makes it difficult to correct the error.  But there are also small, very illustrative examples, such as, for example, this function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SGammaUIPanel::OnGetGamma() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DisplayGamma = GEngine-&gt;DisplayGamma; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GEngine ? DisplayGamma : <span class="hljs-number"><span class="hljs-number">2.2f</span></span>; } : V595 The <span class="hljs-string"><span class="hljs-string">'GEngine'</span></span> pointer was utilized before it was verified against <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>. Check lines: <span class="hljs-number"><span class="hljs-number">47</span></span>, <span class="hljs-number"><span class="hljs-number">48.</span></span> gammauipanel.cpp <span class="hljs-number"><span class="hljs-number">47</span></span></code> </pre> <br>  We fixed this function as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SGammaUIPanel::OnGetGamma() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GEngine ? GEngine-&gt;DisplayGamma : <span class="hljs-number"><span class="hljs-number">2.2f</span></span>; }</code> </pre> <br>  Let's go to the next fragment: <br><br>  V517 The use of if (A) {...} else if (A) {...} 'pattern was detected.  There is a possibility of logical error presence.  Check lines: 289, 299. automationreport.cpp 289 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FAutomationReport::ClustersUpdated(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int32 NumClusters) { ... <span class="hljs-comment"><span class="hljs-comment">//Fixup Results array if( NumClusters &gt; Results.Num() ) //&lt;== { for( int32 ClusterIndex = Results.Num(); ClusterIndex &lt; NumClusters; ++ClusterIndex ) { .... Results.Add( AutomationTestResult ); } } else if( NumClusters &gt; Results.Num() ) //&lt;== { Results.RemoveAt(NumClusters, Results.Num() - NumClusters); } .... }</span></span></code> </pre> <br>  In the current form, the second condition is never satisfied.  It is logical to assume that the error in the sign of the second condition, so that extra elements are removed from the array 'Result': <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FAutomationReport::ClustersUpdated(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int32 NumClusters) { .... <span class="hljs-comment"><span class="hljs-comment">//Fixup Results array if( NumClusters &gt; Results.Num() ) { for( int32 ClusterIndex = Results.Num(); ClusterIndex &lt; NumClusters; ++ClusterIndex ) { .... Results.Add( AutomationTestResult ); } } else if( NumClusters &lt; Results.Num() ) { Results.RemoveAt(NumClusters, Results.Num() - NumClusters); } .... }</span></span></code> </pre> <br>  Sample code for careful reading.  Message: V616 The 'DT_POLYTYPE_GROUND' named with value is used in the bitwise operation.  pimplrecastnavmesh.cpp 2006 <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Flags representing the type of a navigation mesh polygon. enum dtPolyTypes { DT_POLYTYPE_GROUND = 0, DT_POLYTYPE_OFFMESH_POINT = 1, DT_POLYTYPE_OFFMESH_SEGMENT = 2, }; uint8 GetValidEnds(...., const dtPoly&amp; Poly) { .... if ((Poly.getType() &amp; DT_POLYTYPE_GROUND) != 0) { return false; } .... }</span></span></code> </pre> <br>  At first glance, everything is fine.  It seems that a bit is selected by the mask and its value is checked.  But, in fact, in the enumeration of 'dtPolyTypes', simply named constants are defined that are not intended to highlight certain bits. <br><br>  In this condition, the DT_POLYTYPE_GROUND constant is 0, which means the condition will never be met. <br><br>  Corrected version: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValidEnds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dtPoly&amp; Poly)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Poly.getType() == DT_POLYTYPE_GROUND) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... }</code> </pre> <br>  Revealed typo: V501 |||  operator:! bc.lclusters ||! bc.lclusters detourtilecache.cpp 687 <br><pre> <code class="cpp hljs">dtStatus dtTileCache::buildNavMeshTile(....) { .... bc.lcset = dtAllocTileCacheContourSet(m_talloc); bc.lclusters = dtAllocTileCacheClusterSet(m_talloc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bc.lclusters || !bc.lclusters) <span class="hljs-comment"><span class="hljs-comment">//&lt;== return status; status = dtBuildTileCacheContours(....); .... }</span></span></code> </pre> <br>  When copying a variable, they forgot to rename it from 'bc.lclusters' to 'bc.lcset'. <br><br><h2>  Regular verification results </h2><br>  Above were listed not all found errors, but only a small part of them.  We led them to demonstrate what errors PVS-Studio can find even in the working and tested code. <br><br>  However, we <a href="http://www.viva64.com/ru/b/0105/">do not tire of repeating</a> that a one-time code check is the wrong way to use a static analyzer.  The analysis should be carried out regularly and then a huge number of errors and typos can be found at the stage of writing the code, and not at the stage of testing or maintenance. <br><br>  Now we will perfectly support our words with the help of the Unreal Engine project. <br><br>  In the beginning, we ruled the code, ignoring whether it is fresh or old.  It was not before.  But we very well noticed how the PVS-Studio analyzer began to detect errors in the new or corrected code when we reduced the number of warnings to 0. <br><br>  In fact, we fiddled with the code a little more than 17 working days.  When we finished making edits, and the analyzer started issuing 0 warnings, we waited for another 2 days for the Unreal Engine developers to receive our last Pull Request.  And during this time continued to be updated from the main repository and perform the verification code. <br><br>  And during these two days we managed to see how the analyzer detected errors in the new code.  We corrected these mistakes too.  But the most important thing is that it perfectly demonstrates the benefits of regular inspections. <br><br>  In fact, the end of the ‚Äúnumber of messages‚Äù chart has become <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/076/522/0490765228a10a7b1e6814c8f2ced7f6.png"></div><br><br>  Figure 5. A schematic graph of the growth in the number of warnings after they became 0. <br><br>  Let's see what we managed to find in the last two days, checking for recent changes in the project code. <br><br><h3>  The first day </h3><br>  Analyzer first message: V560 A part of conditional expression is always true: FBasicToken :: TOKEN_Guid.  k2node_mathexpression.cpp 235 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> FString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Token.TokenType == FBasicToken::TOKEN_Identifier || FBasicToken::TOKEN_Guid) <span class="hljs-comment"><span class="hljs-comment">//&lt;== { .... } else if (Token.TokenType == FBasicToken::TOKEN_Const) { .... }</span></span></code> </pre> <br>  Forgot to add "Token.TokenType ==".  As a result, since the named constant 'FBasicToken :: TOKEN_Guid' is not equal to 0, the condition is always true. <br><br>  Analyzer second message: V611  Consider inspecting this code.  It's probably better to use 'delete [] CompressedDataRaw;'.  crashupload.cpp 222 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FCrashUpload::CompressAndSendData() { .... uint8* CompressedDataRaw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uint8[BufferSize]; <span class="hljs-comment"><span class="hljs-comment">//&lt;== int32 CompressedSize = BufferSize; int32 UncompressedSize = UncompressedData.Num(); .... // Copy compressed data into the array. TArray&lt;uint8&gt; CompressedData; CompressedData.Append( CompressedDataRaw, CompressedSize ); delete CompressedDataRaw; //&lt;== CompressedDataRaw = nullptr; .... }</span></span></code> </pre> <br>  In practice, this error does not always manifest itself, since an array of char elements is allocated.  But still, this is a mistake that leads to indefinite behavior and must be corrected. <br><br><h3>  Second day </h3><br>  Analyzer first warning: V521 Such expressions using the ',' operator are dangerous.  Make sure the expression is correct.  unrealaudiodevicewasapi.cpp 128 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetArrayOfSpeakers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ Speakers.Reset(); uint32 ChanCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Build a flag field of the speaker outputs of this device for (uint32 SpeakerTypeIndex = 0; SpeakerTypeIndex &lt; ESpeaker::SPEAKER_TYPE_COUNT, //&lt;== ChanCount &lt; NumChannels; ++SpeakerTypeIndex) { .... } check(ChanCount == NumChannels); }</span></span></code> </pre> <br>  Good such fat mistake. <br><br>  The comma operator ',' is used to perform expressions on both sides of it in order from left to right and get the value of the right expression. <br><br>  As a result, the condition for stopping the loop is only this check: ChanCount &lt;NumChannels. <br><br>  Corrected condition: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetArrayOfSpeakers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ Speakers.Reset(); uint32 ChanCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Build a flag field of the speaker outputs of this device for (uint32 SpeakerTypeIndex = 0; SpeakerTypeIndex &lt; ESpeaker::SPEAKER_TYPE_COUNT &amp;&amp; ChanCount &lt; NumChannels; ++SpeakerTypeIndex) { .... } check(ChanCount == NumChannels); }</span></span></code> </pre> <br>  The second warning.  V543 It is odd that value '-1' is assigned to the variable 'Result' of HRESULT type.  unrealaudiodevicewasapi.cpp 568 <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> S_OK ((HRESULT)0L) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> S_FALSE ((HRESULT)1L) bool FUnrealAudioWasapi::OpenDevice(uint32 DeviceIndex, EStreamType::Type StreamType) { check(WasapiInfo.DeviceEnumerator); IMMDevice* Device = nullptr; IMMDeviceCollection* DeviceList = nullptr; WAVEFORMATEX* DeviceFormat = nullptr; FDeviceInfo DeviceInfo; HRESULT Result = S_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//&lt;== .... if (!GetDeviceInfo(DataFlow, DeviceIndex, DeviceInfo)) { Result = -1; //&lt;== goto Cleanup; } .... }</span></span></span></span></code> </pre> <br>  <a href="http://www.viva64.com/go.php%3Furl%3D421">HRESULT</a> is a 32-bit value divided into three different fields: the error severity code, the device code, and the error code.  To work with the HRESULT value, use special constants, such as S_OK, E_FAIL, E_ABORT, and so on.  And to check the values ‚Äã‚Äãof type HRESULT, use such macros as SUCCEEDED, FAILED. <br><br>  The V543 warning is issued if a variable of type HRESULT is attempted to write a value of -1, true or false. <br><br>  Writing the value "-1" is incorrect.  If you want to report an incomprehensible error, you should use the value 0x80004005L (Unspecified failure).  This and similar constants are described in ‚ÄúWinError.h‚Äù. <br><br><h2>  Eh, what a difficult implementation ... </h2><br>  Some programmers and managers may be saddened to learn that it will take N days to integrate static analysis into their project.  However, it is not necessary to go this way.  It is necessary to understand that the developers of Epic Games have chosen the PERFECT PATH, but not the easiest and fastest. <br><br>  Yes, ideally, it is better to immediately correct all errors and then quickly respond to new messages from the analyzer issued to the new code.  But you can begin to benefit from static analysis without spending time editing the old code. <br><br>  For this, PVS-Studio offers a special mechanism for marking messages.  In a nutshell we describe the general idea. <br><br>  All messages issued by the analyzer are marked in a special database as inactive.  And then programmers see only analyzer messages related to new or modified code.  That is, you can immediately begin to benefit from the analysis.  And only then, if there is a desire and time, you can slowly view the messages related to the old code and edit the shortcomings. <br><br>  Details about all this can be found here: <a href="http://www.viva64.com/ru/d/0345/">documentation</a> , <a href="http://www.viva64.com/ru/b/0309/">how to quickly implement the analysis in the project</a> . <br><br><h2>  ‚ÄúDid you write to the developers?‚Äù </h2><br>  After each article about checking a project, we are asked: ‚ÄúHave you informed the developers?‚Äù And although we always report, such questions are pretty tiring.  However, this time we not only ‚Äúwrote to the developers,‚Äù but also corrected all these errors.  What anyone can verify in <a href="https://www.unrealengine.com/ue4-on-github">the</a> GitHub repository. <br><br><h2>  Conclusion </h2><br>  Hopefully, the Epic Games developers liked the work done to edit and improve the Unreal Engine code, and the project benefited.  And we are waiting for new projects on the Unreal Engine. <br><br>  Some conclusions that can be drawn from the results of our work: <ol><li>  The code of the Unreal Engine project is very high quality.  Let readers not be confused by a large number of warnings at the initial stage.  This is a normal situation.  Most of these warnings have been removed using various methods and settings.  The number of real errors found in the code for a project of this size is very small. </li><li>  To edit someone else's unfamiliar code is often very difficult.  However, this is so clear to any developer on an intuitive level.  Nevertheless, we decided to mention this. </li><li>  The speed of "processing" warnings is not linear.  It will slow down and this should be taken into account when calculating how much is left until the end of edits. </li><li>  The maximum benefit from static analysis can be obtained only with its regular use. </li></ol>  Thanks to everyone who read this article and wish everyone a reckless code.  Sincerely, developers of the PVS-Studio analyzer.  And now is the time to <a href="http://www.viva64.com/ru/pvs-studio-download/">download</a> and try it on your project. </div><p>Source: <a href="https://habr.com/ru/post/260755/">https://habr.com/ru/post/260755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260741/index.html">Getting started with OpenCV and its use in C #</a></li>
<li><a href="../260745/index.html">Basics of multithreading in the .NET Framework</a></li>
<li><a href="../260747/index.html">Black archeology date of mining</a></li>
<li><a href="../260749/index.html">Making homemade accessories for Dendy</a></li>
<li><a href="../260753/index.html">Collection and visualization of application metrics in Graphite and Graph-Explorer</a></li>
<li><a href="../260757/index.html">How we made programming language from JSON</a></li>
<li><a href="../260761/index.html">Bindings QCustomPlot for Python</a></li>
<li><a href="../260763/index.html">Programming for beginners. My acquaintance with Processing</a></li>
<li><a href="../260765/index.html">SAP's electronic signature is just</a></li>
<li><a href="../260767/index.html">Java string processing Part I: String, StringBuffer, StringBuilder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>