<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to create PVS-Studio under Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This year we started to do something that we had a controversial attitude to for a long time, namely, the adaptation of the PVS-Studio product to the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to create PVS-Studio under Linux</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/8b1/549/715/8b154971575e3156f8d3739c89a7e148.png" align="left"></p>  This year we started to do something that we had a controversial attitude to for a long time, namely, the adaptation of the PVS-Studio product to the Linux system.  In the article I will talk about how after 10 years of the existence of the PVS-Studio analyzer for Windows, we decided to make a product for Linux distributions.  This is a big job, which, unfortunately, a number of programmers do not limit themselves, solely by compiling the source code for the target platform. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  In general, the console core of the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer has been compiled under Linux for quite some time.  For about three years now.  I will immediately answer the question about the absence of such a version in the public domain - to make a software product, even on the basis of an existing one, it is a lot of work and a lot of man-hours, a lot of unforeseen problems and nuances.  Then we only foresaw this, so the official support of the analyzer for Linux systems did not start. <br><br>  As the author of many articles on project validation, unlike my colleagues, I often found inspiration in Linux projects.  This environment is very rich in large and interesting open source projects that are either very difficult to build in Windows or not at all.  It is within the framework of such tasks of checking some open source project that PVS-Studio for Linux has been developing until today. <br><br>  It took a couple of months to port the PVS-Studio kernel code to Linux with small forces.  Replacing several calls to system functions and debugging on the Chromium project gave a well-functioning console application.  This version of the analyzer was added to regular nightly builds, and also tested with the Clang Static Analyzer.  Periodic inspections of open projects and assembly control allowed the analyzer to exist seamlessly for several years and sometimes it even seemed that this tool could already be sold.  But you still do not know how I had to check the projects at that time ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  About using static analysis tools </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/610/4b2/d8c/6104b2d8c404312b148f078139ba97a5.png"></div><p></p><br>  Before continuing the story about the development of our tool, I would like to talk a little bit about the very methodology of static analysis.  Thus, immediately answering the questions in the style: ‚ÄúWhy use third-party tools, if you can immediately write code without errors and make a review with colleagues?‚Äù.  Unfortunately, this question sounds quite often. <br><br>  Static code analysis allows you to detect errors and shortcomings in the source code of programs.  Regardless of the tools used, this is an excellent methodology for code quality control of future applications.  If possible, it is useful to combine different tools of static analysis. <br><br>  Among our readers, users, or listeners at conferences there are people who believe that reviewing code with colleagues is more than enough to identify errors at an early stage of writing code.  And something in such "inspections" certainly manages to find.  But all this time we are talking about the same thing.  After all, static analysis can be viewed as an automated code review process.  Imagine that a static analyzer is another colleague of yours.  A sort of virtual human robot, who tirelessly participates in all reviews of the code and points to suspicious places.  Isn't that helpful ?! <br><br>  In many branches of production, automation is resorted to in order to exclude the so-called ‚Äúhuman factor‚Äù.  And code quality control is no exception.  We do not urge to refuse manual code-review if you practice it.  Just using a static analyzer will help identify even more errors at an early stage. <br><br>  Another important point - the program does not get tired and not lazy.  Errors of a different nature are entered into the code.  Typos?  They are very difficult to distinguish eyes.  Language errors?  Strongly dependent on the qualification of the examiner.  The situation is aggravated by modern code volumes.  Many functions do not fit entirely even on large monitors.  When the context is incomplete, the inspector's vigilance is reduced.  Plus, after 15 minutes of attentive reading, a person starts to get tired.  And the further, the stronger.  Hence the popularity of automatic analysis tools, which is growing every year. <br><br><h2>  What did PVS-Studio users ask for from the Linux version? </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/1d7/8d3/b591d78d34f355b3f49f8672945f07a1.png"></div><p></p><br>  Our product has always been interesting to people, one way or another connected with the development of programs.  These are Windows users who could immediately try the analyzer.  Not programmers in general or programmers of other platforms and languages ‚Äã‚Äãwho also follow our activity with interest.  Such attention is expected, since  Many errors are common to many programming languages. <br><br>  Linux users have long and hard asked about the work of the analyzer on this platform.  Questions and arguments can be summarized as follows: <br><br><ul><li>  Command line utility - ‚ÄúIDE integration is not needed!‚Äù </li><li>  The installer is not needed - "We will install everything ourselves!" </li><li>  Documentation is not needed - "Run it yourself!" </li></ul><br>  A further story will repeatedly confirm the inconsistency of user statements with their expectations. <br><br><h2>  The Myth of Understanding Assembly Scripts </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5f6/ef6/1055f6ef69ebaad6ffdb67d2eae09f75.png"></div><p></p><br>  After talking with people from large commercial projects, it turned out that quite a few developers are not familiar with building projects, and in fact such knowledge is not always needed in full.  How to build / debug your project / module every developer knows.  But usually all this knowledge is in the recruitment of several magic commands that programmers perform.  Figuratively speaking, they have a large button, which is enough to press and at the output they get the assembled modules.  But how it all works inside, they have only a general idea.  And the assembly scripts are often followed by a special person. <br><br>  In such cases, a tool is needed to verify the project without integration, at least to familiarize yourself with the analyzer. <br><br>  The Linux version of the analyzer appeared just after we made a compiler monitoring system in Windows that allowed us to check any projects on this platform.  As it turned out, there are a lot of serious projects that are built using the compiler from Microsoft, but they do not have a project for Visual Studio.  So we wrote articles about checking Qt, Firefox, CryEngine5 and even <a href="https://www.unrealengine.com/blog/how-pvs-studio-team-improved-unreal-engines-code">collaborated</a> with Epic Games, correcting errors in their code.  Our research has shown that if you know the information about the compiler: the launch directory, command line parameters and environment variables, then this information is enough to call the preprocessor and perform the analysis. <br><br>  When planning to check Linux projects, I immediately realized that I would not understand the integration of the analyzer into each specific project, so I made a similar monitoring system for ProcFS (/ proc / id's).  I took the code from the Windows plug-in and ran it in mono to analyze the files.  For several years, this method has been used to test projects, the largest of which is the <a href="http://www.viva64.com/ru/b/0299/">Linux</a> and <a href="http://www.viva64.com/ru/b/0377/">FreeBSD</a> <a href="http://www.viva64.com/ru/b/0299/">kernel</a> .  Despite the long-term use of such a method, it is in no way suitable for mass use.  The product is not yet ready. <br><br><h2>  Choice of monitoring technology </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62e/2dc/f64/62e2dcf646e34efe47255cee4077ebbb.png"></div><p></p><br>  Having decided on the necessity and importance of such a functional, we began to make prototypes and choose. <br><br><ul><li>  (-) Clang scan-build - by looking at the Clang scripts, we made a prototype, which in a similar way wrote the analyzer's call into CC / CXX variables.  We have come across the fact that in this way it is not possible to check some open projects using the Clang Static Analyzer.  Having understood this method better, we realized that often in projects, compilation flags are added to these variables in these variables.  And at redefinition of variables it is not possible to save them.  Therefore, we abandoned this method. <br><br></li><li>  (+) strace - the utility produces a fairly detailed trace log, in which most of the logged processes are not related to compilation.  Also in the output format of this utility there is no working directory of the process that we need.  But the directory was found by linking the child and parent processes, and an application in C ++ parses such a file very quickly, launching the analysis of the files found in parallel.  So you can check the projects with any build system and get acquainted with the analyzer.  For example, we recently rechecked the Linux Kernel again, now it is easy and simple. <br><br></li><li>  (+) JSON Compilation Database - this format can be obtained for the CMake project by specifying one additional flag.  It has all the necessary information for analysis without unnecessary processes.  Supported. <br><br></li><li>  (¬±) LD_PRELOAD ‚Äî analyzer integration through function substitution.  This method will not work if the project is already being built this way.  There are also utilities to get the JSON Compilation Database for non-CMake projects using LD_PRELOAD (for example, <a href="https://github.com/rizsotto/Bear">Bear</a> ).  They have a slight difference from CMake, but we also supported them.  And if the project does not depend on any set environment variables, then we will also be able to check the project.  Therefore ¬±. </li></ul><br><h2>  The appearance of regular tests </h2><br>  There are different ways to test software.  To test the analyzer and diagnostics, the most effective are the runs on a large code base of open projects.  To begin with, we selected about 30 large open source projects.  Earlier, I mentioned that the compiled Linux analyzer existed for more than a year and the projects for the articles were checked regularly.  Everything seemed to work well.  But just starting the full test, we saw a complete picture of the shortcomings of the analyzer.  Before starting the analysis, it is necessary to analyze the code in order to find the necessary constructions.  Despite the insignificant influence of a nonseparable code on the quality of analysis, the situation is still unpleasant.  Non-standard extensions exist in all compilers, but MS Visual C / C ++ we have long supported them, and with GCC we had to start this struggle almost from the very beginning.  Why almost?  In Windows, we have long supported the work with GCC (MinGW), but it is not so widely distributed there, therefore, neither we nor the users had any problems. <br><br><h2>  Compiler extensions </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/6b8/b4d/7be6b8b4d2fb2614d4b06e719b806bb4.png"></div><p></p><br><br>  In this section, we will focus on the code that you, I hope, will not see anywhere else: code that uses GCC extensions.  It would seem, why we may need them?  In most cross-platform projects, they are unlikely to be used.  First, as practice shows, they are used.  Developing a system for testing projects under Linux, we met this code.  But the main problem arises when parsing the standard library code: extensions are used there to the fullest.  In preprocessed files from your project, you can never be sure: for the sake of optimization, the familiar <i>memset</i> function may turn out to be a macro consisting of a statement expression.  But first things first.  What new designs have we met while testing projects under Linux? <br><br>  <i>Noted initializers</i> were one of the first extensions encountered.  Using them you can initialize the array in any order.  This is especially useful if it is indexed by <i>enum</i> : we explicitly specify the index, thereby increasing readability and reducing the likelihood of making a mistake when modifying it further.  It looks very nice and simple: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Enum { A, B, C }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[] = { [A] = <span class="hljs-number"><span class="hljs-number">10</span></span>, [B] = <span class="hljs-number"><span class="hljs-number">20</span></span>, [C] = <span class="hljs-number"><span class="hljs-number">30</span></span>, }</code> </pre> <br>  For the sake of sporting interest, let's complicate an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Enum { A, B, C }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d[<span class="hljs-number"><span class="hljs-number">3</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array2</span></span></span><span class="hljs-class">[50][50] = {</span></span> [A][<span class="hljs-number"><span class="hljs-number">42</span></span>].d[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  That is, any sequence of indexations and calls to members of the structure can be used as an initializer in this construction.  The range can also be specified as an index: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[] = { [<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-number"><span class="hljs-number">99</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">100</span></span> ... <span class="hljs-number"><span class="hljs-number">199</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span>, }</code> </pre> <br>  A small but very useful from a security point of view, the GCC extension is associated with a null pointer.  Many words have already <a href="http://cpphints.com/hints/44">been said</a> about the problem of using <i>NULL</i> , I will not repeat it.  For GCC, the situation is slightly better, because <i>NULL</i> in C ++ is declared as <i>__null</i> .  Thus, GCC saves us from such leg shots: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = foo(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br>  When compiling we get the error: <br><br><pre> <code class="cpp hljs">test.c: In function <span class="hljs-string"><span class="hljs-string">'void test()'</span></span>: test.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span>: error: call of overloaded <span class="hljs-string"><span class="hljs-string">'foo(NULL)'</span></span> is ambiguous <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = foo(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); ^ test.c:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: note: candidate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a)</span></span></span><span class="hljs-function"> </span></span>{ ^ test.c:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: note: candidate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{</code> </pre> <br>  GCC has the ability to set __attribute __ (()) attributes.  There is a whole list of attributes for functions, variables, and types with which you can control linking, alignment, optimizations, and many other things.  One of the interesting attributes is <i>transparent_union</i> .  If we make such a <i>union</i> a function parameter, then not only the <i>union</i> itself, but also the pointers from this enumeration can be passed as an argument.  This code will be correct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *d; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ch; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i; } Union __attribute((transparent_union)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Union arg)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; foo(&amp;d); <span class="hljs-comment"><span class="hljs-comment">//ok foo(&amp;ch); //ok foo(&amp;i); //ok }</span></span></code> </pre> <br>  An example that <i>transparent_union</i> uses is the function <i>wait</i> : it can accept both <i>int *</i> and <i>union wait *</i> .  This is done in favor of compatibility with POSIX and 4.1BSD. <br><br>  You probably heard about the nested functions in GCC.  They can use variables declared before the function.  Another nested function can be passed on a pointer (although it is not necessary, for obvious reasons, to call it on this pointer after the completion of the main function). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k * x + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(x2) - bar(x1); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, foo(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//205 }</span></span></code> </pre> <br>  But did you know that from such a function you can make a goto into a ‚Äúparent function‚Äù?  Especially effectively it looks in combination with the transfer of such a function to another. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> to)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt;= to; ++i) { s += f(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2)</span></span></span><span class="hljs-function"> </span></span>{ __label__ fail; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k * x + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(bar, x1, x2); fail: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Exceptions in my C?!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, foo(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//42 }</span></span></code> </pre> <br>  In practice, however, such code can lead to extremely sad consequences: exception safety is a rather complicated topic even for C ++ with RAII, not to mention C. Therefore, it is better not to do so. <br><br>  Speaking of goto.  In GCC, labels can be stored in pointers and navigated.  And if you write them into an array, you get the transition table: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __label__ fail1, fail2, fail3; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *errors[] = {&amp;&amp;fail1, &amp;&amp;fail2, &amp;&amp;fail3}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = foo(); assert(rc &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rc &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *errors[rc]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fail1: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Fail 1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; fail2: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Fail 2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; fail3: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Fail 3"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  And this is a small Clang extension.  PVS-Studio has been able to work with this compiler for a long time already; nevertheless, even now we do not cease to be surprised at new constructions appearing in the language and compilers.  Here is one of them: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arr[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">static</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">9</span></span>]; foo(a); <span class="hljs-comment"><span class="hljs-comment">//warning int b[10]; foo(b); //ok }</span></span></code> </pre> <br>  With such a record, the compiler checks that the passed array has 10 or more elements and issues a warning if this is not the case: <br><br><pre> <code class="cpp hljs">test.c:<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: warning: <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> argument is too small; contains <span class="hljs-number"><span class="hljs-number">9</span></span> elements, callee requires at least <span class="hljs-number"><span class="hljs-number">10</span></span> [-Warray-bounds] foo(a); ^ ~ test.c:<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span>: note: <span class="hljs-function"><span class="hljs-function">callee declares </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">array</span></span></span><span class="hljs-function"> parameter as </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> here </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arr[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">static</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> ^ ~~~~~~~~~~~</span></span></code> </pre> <br><h2>  Closed testing Beta version.  Wave 1 </h2><br>  Having prepared a stable version of the analyzer, documentation and several ways to test projects without integration, we started closed testing. <br><br>  When we started issuing the analyzer to the first testers, it turned out that it was not enough to provide an analyzer with an executable file.  We received feedback from "You have a great product, we found a bunch of errors" to "I do not trust your application and will not install it in / usr / bin!".  Unfortunately, the latter were more.  Thus, the arguments of the members of the forum about the possibility of independent work with the executable file were exaggerated.  In this form, not everyone can or does not want to work with the analyzer.  You need to use some common ways to distribute software in Linux. <br><br><h2>  Closed testing Beta version.  Wave 2 </h2><br>  After receiving the first reviews, we stopped testing and plunged into hard work for almost 2 weeks.  Testing on someone else's code revealed even more problems with compilers.  Since  compilers and cross-compilers for various platforms are created on the basis of GCC, then we began to use our analyzer to check anything, even software of different pieces of hardware.  In principle, the analyzer coped with its duties, and we received thank-you reviews, but the analyzer missed some code fragments due to extensions that we had to maintain. <br><br>  False alarms are inherent in any static analyzer, but in Linux their number has increased slightly.  Therefore, we started to work out diagnostics for a new platform and compilers. <br><br>  A big improvement was the creation of Deb / Rpm packages.  After their appearance, discontent with the installation of PVS-Studio disappeared.  There was probably only one person who was outraged by installing a package using sudo.  Although this way put almost all the software. <br><br><h2>  Closed testing Beta version.  Wave 3 </h2><br>  We also made a short break for revision and made the following changes: <br><br><ol><li>  Rejection of configuration files for a quick check - after the introduction of Deb / Rpm packages, the first place was taken by the problem of filling in the configuration file for the analyzer.  It was necessary to modify the quick check mode of projects without a configuration file with only two required parameters: the path to the license file and the path to the analyzer report.  The possibility of advanced settings of this mode remained. <br><br></li><li>  The work with the <i>strace</i> utility log was improved - initially the <i>strace</i> utility log was processed by a Perl script on which the prototype was made.  The script was working slowly and badly parallelizing the analysis.  After rewriting this functionality in C ++ file processing accelerated, it also became easier to maintain all the code in one programming language. <br><br></li><li>  Completion of Deb / Rpm packages - because  For the quick check mode, you need the <i>strace</i> utility and the first packages included Perl / Python scripts, we did not immediately correctly write all the dependencies, and later completely abandoned the scripts.  Later, several people wrote warnings when installing the analyzer through graphical managers, and we quickly eliminated them.  Here I would like to note the benefits of the testing method that we have set up for ourselves: several dozens of Linux distributions are deployed in Docker and installed packages are installed in them.  The ability to run installed programs was also checked.  Such testing allowed us to promptly make new changes to the packages and test them. <br><br></li><li>  Other improvements on the analyzer and documentation.  We reflected all our achievements in the documentation.  Well, the work on finalizing the analyzer never stops: these are new diagnostics and the improvement of existing ones. </li></ol><br><h2>  Closed testing Beta version.  Wave 4 (Release Candidate) </h2><br>  In the last wave of the analyzer's mailing, users already have no problems with installing, running and configuring the analyzer.  We receive thank-you reviews, examples of real errors found and examples of false positives. <br><br>  Also, users have become more interested in the advanced settings of the analyzer.  Therefore, we began to refine the documentation on how to integrate the analyzer into the Makefile / CMake / QMake / QtCreator / CLion.  How it looks, I will show further. <br><br><h2>  Well-developed integration methods </h2><br><h3>  Makefile Integration / Makefile.am </h3><br>  Despite the convenience of verifying a project without integration, there are several advantages directly to direct integration into an assembly system: <br><br><ul><li>  Tweaking analyzer; </li><li>  Incremental analysis; </li><li>  Parallel analysis at the level of the assembly system; </li><li>  Other benefits from the assembly system. </li></ul><br>  When the analyzer is called in the same place as the compiler, then the analyzer has the environment, working directory and all parameters correctly configured.  In this case, all the conditions for proper and qualitative analysis. <br><br>  The integration in the Makefile looks like this: <br><br><pre> <code class="cpp hljs">.cpp.o: $(CXX) $(CFLAGS) $(DFLAGS) $(INCLUDES) $&lt; -o $@ pvs-studio --cfg $(CFG_PATH) --source-file $&lt; --language C++ --cl-params $(CFLAGS) $(DFLAGS) $(INCLUDES) $&lt;</code> </pre> <br><h3>  CMake / CLion Integration </h3><br>  Having studied the integration of the analyzer in CMake, it became possible to use PVS-Studio in CLion.  You can receive both the file with the analyzer report, and display warnings in the IDE to view problem areas. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5a1/057/47e/5a105747e2b8efbdbe0871b19bea1205.png"></a> </div><br><br><h3>  CMake / QtCreator Integration </h3><br>  To work with CMake projects in QtCreator, you can also save a report in the same way or immediately view warnings in the IDE.  Unlike CLine, QtCreator is able to open for viewing reports saved in the TaskList format. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ecc/5e9/e3d/ecc5e9e3df0b8ee2a7ea477720d63a9a.png"></a> </div><br><br><h3>  Integration into QMake / QtCreator </h3><br>  For QMake projects, we also provided a simple integration method: <br><br><pre> <code class="cpp hljs">pvs_studio.target = pvs pvs_studio.output = <span class="hljs-literal"><span class="hljs-literal">true</span></span> pvs_studio.license = /path/to/PVS-Studio.lic pvs_studio.cxxflags = -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c++<span class="hljs-number"><span class="hljs-number">14</span></span> pvs_studio.sources = $${SOURCES} include(PVS-Studio.pri)</code> </pre> <br><h2>  Conclusion </h2><br>  What we came to during the development: <br><br><ol><li>  The analyzer is easy to install from a package or repository; </li><li>  It is easy to get acquainted with the analyzer by running the test without integrating the analyzer into the assembly system; </li><li>  For regular use of the analyzer, you can configure incremental analysis on each developer's machine; </li><li>  Setting up a full scan on the build server; </li><li>  Integration with popular IDEs. </li></ol><br>  This tool can already be shown to people, which we did. <br><br>  Download and try the analyzer can follow the <a href="http://www.viva64.com/ru/pvs-studio-download-linux/">link</a> .  Follow our news and send projects for verification, now in Linux! <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0451/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Svyatoslav Razmyslov: <a href="http://www.viva64.com/en/b/0451/">The Development History of PVS-Studio for Linux</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/315232/">https://habr.com/ru/post/315232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315222/index.html">Apple Pay as a mobile payment engine in Japan</a></li>
<li><a href="../315224/index.html">PwnFest contest results</a></li>
<li><a href="../315226/index.html">DDoS on Russian banks. Chronology of the attack</a></li>
<li><a href="../315228/index.html">The history of one test task</a></li>
<li><a href="../315230/index.html">What is your profession? The difference between Programmer, Software Engineer and Computer Scientist</a></li>
<li><a href="../315234/index.html">The best IT vacancies on My Circle in a week, October 24-30</a></li>
<li><a href="../315236/index.html">How to solve simple optimization problems on python using cvxpy</a></li>
<li><a href="../315240/index.html">Testing Mobile Applications: Interview with Dan Cuellar (Appium)</a></li>
<li><a href="../315242/index.html">The media learned about the new way to intercept passwords and PIN-code from mobile phones</a></li>
<li><a href="../315244/index.html">JetBrains Night in Moscow. Video. Integrating JetBrains server products with each other</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>