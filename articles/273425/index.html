<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quickly raised is not considered to be dropped. Increase resiliency of embedded systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A year ago, he did a rather interesting job of developing an embedded computer for a single electronics company. The computer did not represent anythi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quickly raised is not considered to be dropped. Increase resiliency of embedded systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/054/f4a/a9d/054f4aa9dd7648678e0f2fa37e02c387.png" alt="image"><br><br>  A year ago, he did a rather interesting job of developing an embedded computer for a single electronics company.  The computer did not represent anything fundamentally interesting: a Cortex A-8 processor running at sub-gigahertz frequencies, 512Mb DDR3, 1Gb NAND, a lightweight Linux build.  However, the device into which the computer was built, and therefore he himself, had to work in fairly tough conditions.  Wide temperature range (from -40 to +85 degrees Celsius), moisture resistance, resistance to electromagnetic radiation, kilovolt power pulses, protection against static in 4 kV and many other interesting things that are well described in various state-of-the-art equipment, are all about him  One of the main requirements of the customer is the term of production for failure not less than 10 years.  In this case, the manufacturer provides warranty repair of the product for five years, because the question is not rhetorical, but monetary and serious.  A corresponding element base was laid in the product.  The device passed the tests with honor and received the required certificates, but the conversation is not about that.  The problems started when the installation batch was made, and the devices were divided into departments and design offices for creating application software.  Come back with the wording: "Something does not load." <br><a name="habracut"></a><br><h3>  It was a FAIL </h3><br>  During the inspection, it turned out that in 100% of the failures, the NAND partition with the file system (rootfs) was damaged, and all other partitions were intact, normally mounted and read.  A survey of witnesses showed that the device refused to start, after a hard emergency power failure.  The direction of research is clear.  A file system failure can be caused by turning off the power while writing to the media.  We are building a test bench, the task of which is to supply power to the device, wait for Linux to boot and run the test script (generates files and writes to Flash) and cut off the power.  And so in a circle.  In total, the cycle lasted just over a minute.  We put on the test a few devices.  On average, after 2000 iterations, each device refused to load, the section with rootfs fell!  It seems found. <br><br>  For reasons of durability and reliability, our device uses SLC NAND as a ROM.  Options with eMMC (embedded Multimedia Memory Card) were rejected immediately due to the small number of rewrite cycles.  Today, eMMC is not a standard for industrial applications, probably for this reason such a small number of offers of similar chips with a lower limit of the operating temperature range of -40 ¬∞ C.  The main limitation for use in industrial systems is a small period of warranty data storage.  If for SLC NAND it is about 10 years, then for eMMC - about a year. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unlike the eMMC-based solution (or the usual SD ‚ÄúSecure Digital‚Äù Card), where the software level of interaction with physical media (FTL - Flash Translation Layer) is implemented by the controller built into the memory, FTL should be implemented by means of the central processor.  Despite the increasing complexity of implementation, it provides tangible advantages in the configuration flexibility of the final system, as well as due to the possibility of using special algorithms for aligning the wear of physical memory cells, increases the durability of the carrier.  (Actually, the FTL level built into eMMC also implements wear leveling algorithms, but this is a ‚Äúblack box‚Äù). <br><br>  Linux operating systems use a number of file systems to work with NAND physical media: <b>JFFS2</b> and its evolutionary development - <b>UBI / UBIFS</b> (thanks to Nokia for this), and also the competitor - <b>LogFS</b> .  By the combination of parameters, preference was given to the UBI / UBIFS bundle.  UBI / UBIFS - these are two software layers: UBI (Unsorted Block Images) - provides work directly with physical media, UBIFS (UBI File System) - actually, the file system itself. <br><br>  Main features of UBI: <br><br><ul><li>  works with sections, allows you to create, delete, or resize them; </li><li>  aligns the recording across the entire volume of the medium; <br>  works with bad blocks; </li><li>  minimizes the likelihood of data loss in case of power failure or other failures. </li></ul><br>  UBIFS, among other things, is engaged in logging. <br><br>  Despite the fact that, in general, UBI and UBIFS were developed taking into account the requirements for tolerance to power interruption, as practice has shown during the operation of the device under certain conditions, after an emergency shutdown (in other words, a power failure), the partition is corrupted.  If this is a section with rootfs, then the device loses its functionality as a whole.  The probability of this event is not great, the device can work stably for several months or even several years, successfully going through a single power failure.  However, this factor can not be ignored if the device is designed to work in a hard-to-reach place, with a person‚Äôs limited access or its failure can have fatal consequences. <br><br>  The reason for the failure is in the physical structure of the NAND.  Data recording occurs page by page, previously, the page must be erased - all units are recorded in the area.  Erasing occurs in blocks, such a block is called PEB (physical erase blocks).  In order to erase the page, you need to erase the entire block.  In one block there can be many pages, for example, a 4K page, and a block 256KB.  The developers of the UBI / UBIFS technology are aware of this problem and blame the so-called ‚Äúunstable bits‚Äù for everything.  They point to four major events when data from the media may be lost. <br><br><div class="spoiler">  <b class="spoiler_title">Causes of failure and loss of information in NAND</b> <div class="spoiler_text"><ol><li>  Power was turned off before work on the memory page was completed.  After reloading the page can be read correctly, but when re-reading you can get an error ECC.  This is because a number of unstable bits have appeared, which can be read correctly or not correctly. </li><li>  The power is turned off when you start working with the NAND page.  After reloading, the page can be read correctly: all units are counted (0xFF), but sometimes, after reloading, only zeros can be counted from this area.  In addition, if you then write this page again, sometimes an ECC error may occur.  The reason - again unstable bits. </li><li>  Power failure during block erasure.  After a reboot, again, unstable bits may appear, and the data in the block becomes corrupted. </li><li>  The power is turned off after the block cleaning operation has been started.  And again, after a reboot, the block contains unstable bits: either returns zeroes or damaged data when reading, when trying to write information there. </li></ol><br></div></div><br>  In all cases, after an emergency power outage, the memory area can be read correctly, as a result, the logging system will not see the trick.  But with subsequent access to this area data may be damaged.  The number of such ‚Äúunstable bits‚Äù may be greater than the ECC algorithm can correct.  Therefore, previously read pages become unreadable, or vice versa, a previously unreadable page may suddenly become readable.  The problem is exacerbated by the fact that unstable bits may occur in the file system log, since statistically, this area of ‚Äã‚ÄãNAND is most often modified. <br><br><h3>  Saving the system </h3><br>  To increase the survivability of the file system, we decided to introduce redundancy into the root file system architecture (FSC).  The idea is as follows: we create a ‚Äúvirtual‚Äù section from two physical sections on the media.  One partition contains a rootfs image that is read-only, and while the operating system is running, all changes are recorded in the second partition, which is readable and writeable.  Since the recording is carried out only in the second section, only one can be damaged during a power failure.  The second section will remain the original.  This technology is known as cascade-joint mount. <br><br>  In addition, they decided to post the system software (meaning rootfs, the kernel was originally on a separate read-only section) and application software on different physical partitions.  Due to the specifics of our device (works with massive databases), we have allocated a section for backup.  In this place we are glad that enough memory has been put into the device (1 GiB). <br><br><img align="right" src="https://habrastorage.org/files/17d/399/b30/17d399b308244cf591b15e1c506cd3c5.png" alt="image"><br><br>  Auxiliary file system <b>aufs is</b> used for cascade-merged partition mount.  As mentioned above, two physical sections are merged.  The first section, in which the image of the working CFS was originally written, is available only for reading (RO - read only), the second section, initially empty, serves to store changes, respectively, it is available for both reading and writing (RW - read write ).  In terms of aufs, the first and second sections are called branches (branch).  The merging of branches occurs in the process of mounting.  As a result, the operating system sees the mounted area as a whole.  The data is accessed by the kernel driver.  The driver first sends requests for reading the file to the RW branch;  if the data is present there, they are issued, if there is no data there, the file is read from the RO branch.  When recording, the data fall into the RW branch.  When deleting a file, a label indicating that the file has been deleted is added to the RW branch (a corresponding empty hidden file is created with a certain prefix in the name).  Physically, the file remains in the RO branch.  This approach allows you to avoid write operations in the section with critical information.  In addition, since the RO branch is read-only, it is in principle possible to add additional control over data integrity.  This can be implemented using UBIFS, making the partition created static.  The static section is read-only and the data there is protected by a checksum (CRC-32). <br><br>  Total, we want to get this architecture FSC: <br><br><img src="https://habrastorage.org/files/8b5/a16/e5a/8b5a16e5a2a442b0a7069cca4a6198ac.png" alt="image"><br><br>  The ‚Äúrootfs_‚Äù sections contain the system part of the FSC that ensures the operability of the Linux operating system, and the ‚Äúdata_‚Äù sections are designed to store application software, configuration files, and databases.  The ‚Äúbackup‚Äù section is intended to periodically back up the current system settings and databases.  Backup is provided by application software. <br><br><h3>  Bake aufs </h3><br>  Currently, aufs is not included in the main branch of the Linux kernel, therefore, in addition to the utilities for working with technology, it is necessary to independently apply patches to the kernel sources.  In order to deploy technology aufs on the target platform (target) Linux you need: <br><br><ol><li>  Apply patches to the kernel.  All patches and how-to can be found on the project website. </li><li>  In the core enable aufs. </li><li>  Build the core. </li><li>  Build tools to work with aufs. </li><li>  Move the kernel and utilities to the target. </li></ol><br>  You can check the technology on the target by running: <br><br><pre><code class="bash hljs">mount -t aufs -o br=/tmp/rw=rw:<span class="hljs-variable"><span class="hljs-variable">${HOME}</span></span>=ro none /tmp/aufs</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Command format</b> <div class="spoiler_text"><pre> mount [-fnrsvw] [-t FS_type] [-o parameters] device directory 
 moun -t aufs -o br = / tmp / rw: $ {HOME} none / tmp / aufs 
</pre><br></div></div><br>  As a result, the contents of the home directory will be in / tmp / aufs, you can write there and delete files, the contents of $ {HOME} will not change. <br><br>  Fine!  aufs hooked up, now the most interesting thing: how to make the system boot from it?  By default, when booting, we cannot specify the rootfs partition on aufs via cmdline.  At the start of the kernel, there is no such section yet, it only needs to be created.  This means that during the system startup, before the initialization process starts (the process with PID = 0, in my case it is systemd) we have to mount an auxiliary aufs partition, chroot it, and only after that run / sbin / init.  For such tasks, there is a mechanism for preliminary initialization.  In <i>cmdline</i> specify the path to the script, which will have to work before the start of the initialization daemon.  Add parameter to cmdline: <br><br><pre> <code class="bash hljs">init=/sbin/preinit</code> </pre><br>  The script is written in the <i>shell</i> , because at the time of execution, the system should already have all the utilities necessary for it.  That is, in fact, to execute the script, the partition with rootfs must already be mounted!  For these purposes, you can use rootfs on the RAM disk, or initially boot from the combat partition with rootfs, but in read-only mode, this is our choice.  Edit cmdline accordingly, add a parameter (9 is the number of the mtd section, where I have rootfs_ro): <br><br><pre> <code class="bash hljs">root=ubi0:rootfs_ro ro ubi.mtd=9</code> </pre><br><h3>  Preinit script </h3><br>  Mount the system partitions (needed for the shell): <br><br><pre> <code class="bash hljs">mount -t proc none /proc mount -t tmpfs tmpfs /tmp mount -t sysfs sys /sys</code> </pre><br>  The rootfs_ro section is already mounted, we booted from it, we are mounting rootfs_rw to a temporary folder: <br><br><pre> <code class="bash hljs">ubiattach -m 10 -d 1 &gt; /dev/null mount -t ubifs ubi1:<span class="hljs-variable"><span class="hljs-variable">$rootfs_rw</span></span> /tmp/aufs/rootfs_rw</code> </pre><br>  If something went wrong during the mount, then we can safely format rootfs_rw, and if that didn't work, then delete the partition and create it again.  We try to mount again.  I will not give the code, there are too many ‚Äúmagic numbers‚Äù defined by the NAND architecture.  Let me just say that you will need a set of utilities UBI. <br><br>  Copy the current rootfs mount point to a temporary directory: <br><br><pre> <code class="bash hljs">mkdir -p /tmp/aufs/rootfs_ro mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> / /tmp/aufs/rootfs_ro</code> </pre><br>  We stick together a layer cake - we mount the section aufs: <br><br><pre> <code class="bash hljs">mount -t aufs -o br:/tmp/aufs/rootfs_rw :/tmp/aufs/rootfs_ro=ro none /aufs</code> </pre><br>  After that, the new rootfs section is available in / aufs. <br><br>  Make a feint with ears: transfer the mount points rootfs_ro and rootfs_rw to a new section: <br><br><pre> <code class="bash hljs">mount --move /tmp/aufs/ rootfs_ro /aufs/aufs/ rootfs_ro mount --move /tmp/aufs/ rootfs_rw /aufs/aufs/ rootfs_rw</code> </pre><br>  And at the same time move / dev: <br><br><pre> <code class="bash hljs">mount --move /dev /aufs/dev</code> </pre><br>  It is clear that the directories into which the mount points are transferred must be created in advance. <br><br>  We clean up after ourselves, disable system partitions: <br><br><pre> <code class="bash hljs">umount -l /proc umount -l /tmp umount -l /sys</code> </pre><br>  Change CFS and run initialization: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> /usr/sbin/chroot /aufs /sbin/init</code> </pre><br>  In a combat script, we build a ‚Äúpie‚Äù for / appl on the same principle and mount / backup.  The figure below shows the resulting architecture of the final CFS. <br><br><img src="https://habrastorage.org/files/1fd/823/d8b/1fd823d8b4ef4a12821dcaafb490f049.png" alt="image"><br><br>  To improve reliability, the / backup partition is provided with exclusive access to strictly one utility responsible for backup and restore.  The utility itself is located in the data_ro section. <br><br><h3>  Conclusion </h3><br>  As a result, the overall survival of the system in the event of an emergency power outage increased dramatically.  Although the application of cascade mount CFS technology is shown on the example of NAND, this principle is not limited to the physical type of data carrier and is easily transferred to eMMC, SD, and more.  If during operation the system does not accumulate data, but only works out a specific algorithm (for example, a regular router), then it is advisable to use a RAM disk as the RW branch when mounting the aufs partition. <br><br>  And instead of PS: backup power supply has not yet been canceled. <br><br><div class="spoiler">  <b class="spoiler_title">Read on</b> <div class="spoiler_text"><ul><li><br>  <a href="http://www.linux-mtd.infradead.org/doc/ubifs.html">UBIFS - UBI File-System</a> <br>  <a href="http://aufs.sourceforge.net/">Official site of the project AUFS</a> .  Instructions for make and source codes there. <br><br></li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/273425/">https://habr.com/ru/post/273425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273415/index.html">Artistic approach to downloading images</a></li>
<li><a href="../273417/index.html">Advent of Code</a></li>
<li><a href="../273419/index.html">Myths and illusions of developers regarding playtests</a></li>
<li><a href="../273421/index.html">We become professional PHP developers. Part 1: Missing Link</a></li>
<li><a href="../273423/index.html">Children and parents on the web: the story of hacking services VTech</a></li>
<li><a href="../273427/index.html">Unit Tests in ABAP</a></li>
<li><a href="../273429/index.html">Development of plug-ins for Atlassian JIRA</a></li>
<li><a href="../273431/index.html">Learn English with Scala on Future and Actor</a></li>
<li><a href="../273433/index.html">Primary values ‚Äã‚Äãof the secondary market. Arguments and Facts</a></li>
<li><a href="../273435/index.html">Oracle Database 12c: Performance Tuning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>