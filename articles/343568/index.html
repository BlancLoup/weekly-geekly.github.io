<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS Works: Features and Scope of WebAssembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we present to you the sixth part of a series of materials that are devoted to the peculiarities of the work of all that is associated with JavaS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS Works: Features and Scope of WebAssembly</h1><div class="post__text post__text-html js-mediator-article">  Today we present to you the sixth part of a series of materials that are devoted to the peculiarities of the work of all that is associated with JavaScript.  Here we talk about WebAssembly.  Namely, we will analyze this technology in detail, consider the features of its work, as well as how it relates to the usual JavaScript in terms of performance.  It‚Äôs about code load time, program execution speed, garbage collection, memory usage, access to the platform API, debugging, multithreading and portability of WebAssembly-code.  This technology, although it is now at the very beginning of its development, has already begun to change the views on the development of web applications.  If the developer needs the highest performance browser code, he simply needs to become familiar with WebAssembly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da7/d7a/440/da7d7a440a362d56472c428932270ffa.png" alt="image"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br><h2>  <font color="#3AC1EF">What is WebAssembly</font> </h2><br>  WebAssembly (or wasm for short) is an effective low-level bytecode for web applications.  Wasm enables the development of functional web pages in languages ‚Äã‚Äãother than JavaScript (for example, C, C ++, Rust, and others).  Code in these languages ‚Äã‚Äãis compiled (statically) into WebAssembly.  The result is a web application that loads quickly and has a very high performance. <br><br><h2>  <font color="#3AC1EF">Load time</font> </h2><br>  In order to run a JavaScript program, the browser must first load all .js files that are stored and transmitted over the network in plain text. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Wasm is a low-level language similar to assembler.  WebAssembly-programs are loaded by the browser faster, since through the Internet you need to transfer already compiled files in a very compact binary format. <br><br><h2>  <font color="#3AC1EF">Performance</font> </h2><br>  Today, wasm programs are executed only 20% slower than machine code.  This is without a doubt a decent result.  After all, this is a format that is compiled in a particular environment and is launched using a variety of restrictions that provide a high level of security.  Such a slowdown compared with the machine code in this world does not look so great.  In addition, an increase in the performance of the wasm code is expected in the future.  More interestingly, the wasm is platform independent.  Its support is available in all leading browser engines that demonstrate approximately the same performance when executing a wasm code. <br><br>  In order to compare the features of wasm and javascript, you can refer to <a href="https://habrahabr.ru/company/ruvds/blog/337460/">this material</a> , which deals with the features of JS engines using the example of V8.  And now we will talk about how the wasm code correlates with other V8 mechanisms. <br><br><h2>  <font color="#3AC1EF">Wasm and JS V8 engine</font> </h2><br>  Here is a diagram of the V8 engine device, namely, the path that the JavaScript program traverses from a simple text file to executable code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/127/60b/d0012760b10bdee3745f06ad36b30c20.png"></div><br>  <i><font color="#999999">Dynamic V8 compilation</font></i> <br><br>  On the left is the source code in JavaScript, which contains a certain function.  First, this code is parsed, the strings are turned into tokens and an abstract syntax tree (AST) is generated.  AST is a representation of the logic of a JS program.  After creating AST V8 converts what happened in machine code.  The abstract syntax tree is traversed and what was previously a function that exists as text is converted to its compiled version.  In this case, V8 does not make special efforts to optimize the code. <br><br>  Let's look now at what happens in the next stages of the engine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/820/bbb/128/820bbb12832b23423cef789184d6e432.png"></div><br>  <i><font color="#999999">V8 engine conveyor</font></i> <br><br>  Here it is shown that now comes <a href="https://github.com/v8/v8/wiki/TurboFan">TurboFan</a> time - one of the optimizing V8 compilers.  While the JavaScript application is running, a lot of auxiliary actions are performed in V8.  Namely, TurboFan monitors what is happening in the search for bottlenecks and the most frequently used program fragments in order to optimize the corresponding sections of the code.  After that, TurboFan will process the most critical parts of the program, passing them through an optimizing JIT compiler, which will lead to the fact that those functions that ‚Äúeat up‚Äù most of the processor time will be performed much faster. <br><br>  This approach allows to increase the performance of JavaScript, solves the problem of the speed of the programs, but even here everything is not going smoothly.  The fact is that the operations of analyzing the code and making decisions about what needs to be optimized and what is not needed also consume resources.  This, in turn, means a higher power consumption of systems, which, in the case of mobile devices, leads to a reduction in their lifespan from a single charge. <br><br>  If, however, included in the above scheme wasm, it turns out that this code does not need to be analyzed and in several compilation passes.  It is already optimized and ready to use. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/8ab/6f4/e878ab6f4f821f666d9d7cf8a801add7.png"></div><br>  <i><font color="#999999">Wasm and V8 conveyor</font></i> <br><br>  Wasm-code is optimized during static compilation.  When working with him do not need to parse text files.  Thanks to wasm, we have at our disposal binary files that can only be converted into machine code.  All improvements to this code were made at compilation, which is done before it gets into the browser. <br>  All this makes wasm execution much more efficient, since you can skip a lot of steps to turn a program's text into optimized machine code. <br><br><h2>  <font color="#3AC1EF">Memory model</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8f/b35/373/a8fb353730bc81dd1507cff59ea5fb35.png"></div><br>  <i><font color="#999999">Trusted and Untrusted WebAssembly Memory</font></i> <br><br>  The memory of a program written, for example, in C ++ and compiled into WebAssembly, is a continuous block in which there are no ‚Äúholes‚Äù.  One of the features of the wasm, which contributes to improved security, is to separate the execution stack from the linear address space.  In C ++, there is a bunch of programs; memory for the stack is allocated in its upper part.  With such an organization of working with memory, you can use the pointer to access the stack memory in order to affect the state of variables, interaction with which at the current stage of the program is not provided.  This feature is used by many malicious programs. <br><br>  WebAssembly uses a completely different memory model.  The execution stack is separated from the memory where the wasm program itself is stored, as a result there is no possibility to gain unauthorized access to this memory, and, for example, to change the state of some variables.  In addition, functions do not use pointers, but integer offsets.  It uses an indirect addressing mechanism.  Necessary direct addresses are calculated during the program operation.  This mechanism is designed so that you can simultaneously load several wasm-modules, addresses will be located using offsets, in the end everything will work as it should. <br><br>  More information about the mechanisms of memory management in JavaScript can be read <a href="https://habrahabr.ru/company/ruvds/blog/338150/">here</a> . <br><br><h2>  <font color="#3AC1EF">Garbage collection</font> </h2><br>  In the previous materials of this series, we have already said that the Garbage Collector (GC) participates in managing the memory of JS programs. <br><br>  In the case of WebAssembly, everything looks a little different.  This technology supports languages ‚Äã‚Äãwith manual memory management.  As a result, you can use your own garbage collector with the wasm-modules, but this is not an easy task. <br><br>  Now WebAssembly is focused on the ways of working with memory used in C ++ and Rust.  Since wasm is a low-level technology, it is quite logical that programming languages ‚Äã‚Äãthat are only one step above the assembler will easily be compiled into wasm.  So, when programming in C, you can use the usual command <code>malloc</code> , in C ++ you can use smart pointers.  Rust uses a completely different approach (we will not go into this, as everything is completely different there).  These languages ‚Äã‚Äãdo not use garbage collectors; as a result, they don‚Äôt need complex runtime mechanisms that are responsible for memory management.  WebAssembly fits perfectly with similar memory models. <br><br>  In addition, these languages ‚Äã‚Äãare not designed to perform complex operations that are typically implemented using JavaScript, such as DOM manipulations.  It makes no sense to write an HTML application entirely in C ++, since C ++ is simply not designed for such an application.  In most cases, code for web applications in C ++ or Rust is written to work with WebGL or create highly optimized libraries on it, for example, those that are responsible for mathematical calculations. <br><br>  In the future, however, support is expected for languages ‚Äã‚Äãthat use other memory models. <br><br><h2>  <font color="#3AC1EF">Access to external APIs</font> </h2><br>  Depending on the runtime, the JavaScript program can directly interact with specialized APIs.  For example, if the program is written for the browser, it has at its disposal a set of <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a> that the application uses to control the browser or device, and to work with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSSOM</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API,</a> and so on. <br><br>  WebAssembly modules do not have direct access to the API provided by the platform.  Modules can interact with the API only with the mediation of JavaScript.  If, from a wasm module, you need to access a similar API, this call must be made via JavaScript.  For example, if you need to execute the <code>console.log</code> command, you will have to call it through JS.  Similar appeals to JavaScript tools affect performance. <br><br>  We can not say that it will always be so.  In the future, the appearance of the corresponding API is expected to directly use them in the wasm code.  As a result, you can create wasm applications without using JavaScript calls. <br><br><h2>  <font color="#3AC1EF">Code maps (source maps)</font> </h2><br>  If, after the minification of the JS code, it needs to be debugged, <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a> come into play.  This is a way of mapping between a JS code that is minified or combined from different files and its initial state.  When a project is collected for production, minification and combination of files are made, they also create a code map that stores information about the source files.  When referring to a specific place in the generated code, you can check the fragment of the source program, which looks much more understandable than the packaged version of the program, by checking with the code map. <br><br>  WebAssembly does not support source maps, as long as there is no corresponding specification, but it is quite possible that this possibility will appear very soon. <br><br>  As a result, when debugging a wasm code obtained, for example, from C ++, you can see the source code and set breakpoints in it.  At least that is the purpose of introducing code maps into wasm. <br><br><h2>  <font color="#3AC1EF">Multithreading</font> </h2><br>  JavaScript runs in one thread, although it supports an asynchronous programming model.  Read more about it <a href="https://habrahabr.ru/company/ruvds/blog/340508/">here</a> .  In addition, JS supports Web Workers technology, but it has a rather specific scope. <br><br>  Predominantly computing-intensive processor resources that can block the main flow of the user interface.  However, the Web Workers code cannot work with the DOM. <br><br>  WebAssembly does not currently support multithreading.  However, most likely, this opportunity will appear very soon.  The wasm will be close to low-level threads (that is, those used in C ++).  The ability to work with ‚Äúreal‚Äù streams will create many new opportunities in the development of browser applications.  But, of course, multithreading means the emergence of new difficulties. <br><br><h2>  <font color="#3AC1EF">Code Portability</font> </h2><br>  JavaScript applications can work almost everywhere: in browsers, on servers, even in embedded systems. <br><br>  WebAssembly is designed with security in mind and code portability.  This is very similar to javascript.  It will work in any environment that supports wasm, that is, for example, in any browser. <br><br>  In terms of portability, WebAssembly faces the same goals that Java once tried to achieve through applets. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In early versions of WebAssembly, special attention was paid to heavy calculations, for example, mathematical ones.  An obvious area of ‚Äã‚Äãapplication for such calculations is games in which one has to work with a myriad of pixels.  Such applications can be written in C ++ / Rust using familiar methods of working with OpenGL and compile what happens in wasm.  After that, all this will work in the browser.  As an example, open <a href="http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html">this link</a> in Firefox.  It uses the Unreal Engine. <br><br>  Another use of WebAssembly, which focuses on improving the performance of web applications, is to implement libraries that perform resource-intensive calculations using this technology, for example, libraries for image processing. <br><br>  Using wasm can quite seriously reduce battery consumption on mobile devices (of course, it also depends on the engine), since most of the auxiliary operations of preparing a program for execution will be performed during static code compilation. <br><br>  It is expected that in the future we will have the opportunity to use binary wasm files without even writing code that compiles into them.  In NPM you can find projects that implement this approach. <br><br>  Is it possible to say that wasm will replace JS?  At this stage of development, technology is definitely impossible.  For example, if we are talking about working with DOM or using the API of the platform on which the code is executed, JavaScript does not yet have an alternative, since these APIs are available from JS programs directly, without adding additional levels of abstraction. <br><br>  The author of the material notes that <a href="https://www.sessionstack.com/">SessionStack is watching</a> with interest the WebAssembly, hoping to speed up the most resource-intensive parts of its developments with this technology. <br><br>  Previous parts of a series of articles: <br><br>  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">How JS Works: About V8 Inside and Code Optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">How JS works: memory management, four types of memory leaks and how to deal with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">How JS works: event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">How JS: WebSocket and HTTP / 2 + SSE work.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br><br>  Dear readers!  Do you plan to use WebAssembly in your projects? </div><p>Source: <a href="https://habr.com/ru/post/343568/">https://habr.com/ru/post/343568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343556/index.html">In-Memory Computing Summit 2017 San Francisco</a></li>
<li><a href="../343558/index.html">Scala at EPAM: training and projects</a></li>
<li><a href="../343560/index.html">Zimbra with certificate signed by Active Directory</a></li>
<li><a href="../343562/index.html">Javascript price</a></li>
<li><a href="../343566/index.html">Cost of operations in CPU cycles</a></li>
<li><a href="../343570/index.html">As programmers are not allowed to do anything else</a></li>
<li><a href="../343572/index.html">Docker, as an indicator of maturity</a></li>
<li><a href="../343574/index.html">SOC for beginners. Chapter 3. Using external sources of threat data for the Security Operation Center</a></li>
<li><a href="../343576/index.html">Meet GoLand 2017.3 - new Go IDE from JetBrains</a></li>
<li><a href="../343578/index.html">We start the service of salaries on "My Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>