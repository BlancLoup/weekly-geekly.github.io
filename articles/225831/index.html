<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm for finding the smallest covering capacity of a finite set of its subsets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When examining old papers, I came across a fairly shabby notebook, in which I found sketches of a coating search algorithm. The author of the algorith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm for finding the smallest covering capacity of a finite set of its subsets</h1><div class="post__text post__text-html js-mediator-article"> When examining old papers, I came across a fairly shabby notebook, in which I found sketches of a coating search algorithm.  The author of the algorithm, Viktor Anatolyevich Shcherbanov, is my teacher, under whose guidance I worked in the nineties of the last century.  My humble participation mainly consisted in the fact that I offered in most cases incorrect (and sometimes just delusional) options.  What, in general, did not prevent the Chief (as we called him among themselves) did bring the work on the algorithm to its logical conclusion.  Somewhere in the two thousand years, the algorithm was published in one of the institute editions of Tomsk.  But I think that it will not be superfluous to remember him again.  Actually, in memory of the Chef, I decided to write this post.  Maybe the algorithm will seem interesting to someone or push for some new ideas on the implementation of the algorithm. <br><a name="habracut"></a><br><br>  The algorithm itself is based on two statements and two theorems, the proofs of which are not given here, because of their rather large volume. <br><br>  <i>To begin with, let's define what we are actually looking for.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let be a finite set <img src="https://habrastorage.org/getpro/habr/post_images/f53/2c2/fc7/f532c2fc7a171dde73b17d8382db6a03.gif" alt="image">  and family <img src="https://habrastorage.org/getpro/habr/post_images/95f/35b/2e6/95f35b2e6373aec26c12e10e09d17192.gif">  its subsets <img src="https://habrastorage.org/getpro/habr/post_images/f73/e0a/fa4/f73e0afa4a1db188b4a98871e6e5f3dd.gif">  . <br>  Find subfamily <img src="https://habrastorage.org/getpro/habr/post_images/a1c/008/72c/a1c00872c7ff186faa8a16fdeb6aba43.gif">  (if it exists) such that <img src="https://habrastorage.org/getpro/habr/post_images/221/929/624/221929624f4b51c3a51c0821f1ef4922.gif">  and the cardinality of the subfamily S * (cover of the set V) is the smallest of all possible. <br><br>  <i>The following statements define the concepts of minimum and minimum coverage.</i> <br><br>  <b>Statement 1.</b> <br>  In order for the subfamily <img src="https://habrastorage.org/getpro/habr/post_images/bbd/0f4/fa3/bbd0f4fa33fd9d2d71c3acff981ed35e.gif">  was a covering of a multitude <img src="https://habrastorage.org/getpro/habr/post_images/f53/2c2/fc7/f532c2fc7a171dde73b17d8382db6a03.gif" alt="image">  , it is necessary and sufficient that the condition be fulfilled <br><img src="https://habrastorage.org/getpro/habr/post_images/7d9/d89/e32/7d9d89e323702ef8c36f723e9bdb3731.gif"><br><br>  A covering S ‚Ä≤ is called minimal if there is no covering S ‚Ä≥ such that <img src="https://habrastorage.org/getpro/habr/post_images/607/5c5/b89/6075c5b895dcdc67d31da1665f8b54c5.gif">  . <br>  The coverage S * is called the smallest if for any minimal coverage S 'the condition <br><img src="https://habrastorage.org/getpro/habr/post_images/38e/bc6/d20/38ebc6d20c3052834000f997ba91afb6.gif"><br><br>  <b>Statement 2.</b> <br>  Coating <img src="https://habrastorage.org/getpro/habr/post_images/bbd/0f4/fa3/bbd0f4fa33fd9d2d71c3acff981ed35e.gif">  minimal if and only if for any <img src="https://habrastorage.org/getpro/habr/post_images/e41/7f7/ff6/e417f7ff6ac962117f1ba0d7f15b2b2d.gif">  condition is met <br><img src="https://habrastorage.org/getpro/habr/post_images/dd7/dd5/38c/dd7dd538c79e3fc42de23b114390c873.gif"><br><br><hr><br><br>  <i>And the most basic.</i> <br><br>  Let be a finite set <img src="https://habrastorage.org/getpro/habr/post_images/f53/2c2/fc7/f532c2fc7a171dde73b17d8382db6a03.gif" alt="image">  and family <img src="https://habrastorage.org/getpro/habr/post_images/95f/35b/2e6/95f35b2e6373aec26c12e10e09d17192.gif">  its subsets <img src="https://habrastorage.org/getpro/habr/post_images/f73/e0a/fa4/f73e0afa4a1db188b4a98871e6e5f3dd.gif">  . <br>  Construct a full loaded graph. <img src="https://habrastorage.org/getpro/habr/post_images/78f/989/b15/78f989b15f8e0b261b3b19836f647857.gif">  in which the set <img src="https://habrastorage.org/getpro/habr/post_images/e37/d18/2ea/e37d182ea3dde1f64bcb983c0c80675e.gif">  the vertices of the graph are one-to-one mapped family <img src="https://habrastorage.org/getpro/habr/post_images/5e2/768/79e/5e276879e2a1a019a85a56384f2a1de7.gif">  subsets <img src="https://habrastorage.org/getpro/habr/post_images/8ef/482/82f/8ef48282f3c7b59c60bb4d7d81636c37.gif">  , <br>  and each edge <img src="https://habrastorage.org/getpro/habr/post_images/3fc/cca/359/3fccca3597c1da70a43f7188c755a603.gif">  - subset <img src="https://habrastorage.org/getpro/habr/post_images/d03/7c2/7e4/d037c27e4faa06740d664e0cf95042bf.gif">  . <br><br>  Denote <img src="https://habrastorage.org/getpro/habr/post_images/0c7/ef4/13c/0c7ef413c82a59940fe61ec47a27d074.gif">  the set of all edges incident to the top <img src="https://habrastorage.org/getpro/habr/post_images/279/344/d5e/279344d5e2c8131cb46ce5d98b2fb14b.gif">  , but <img src="https://habrastorage.org/getpro/habr/post_images/c60/628/99f/c6062899f92e3cd19a1d6e0e7f9d3fa7.gif">  - the set of all vertices incident to the edges of the set <img src="https://habrastorage.org/getpro/habr/post_images/0c7/ef4/13c/0c7ef413c82a59940fe61ec47a27d074.gif">  . <br><br>  <b>Theorem 1.</b> <br>  Minimum Power Subset <img src="https://habrastorage.org/getpro/habr/post_images/05f/3cc/855/05f3cc855b722ebc925ea8713ded4d58.gif">  edges incident to arbitrary vertex <img src="https://habrastorage.org/getpro/habr/post_images/279/344/d5e/279344d5e2c8131cb46ce5d98b2fb14b.gif">  in column G, under the conditions <br><img src="https://habrastorage.org/getpro/habr/post_images/a33/dd3/33f/a33dd333f0743447dd07b91852981f0a.gif"><br>  determines the minimum coverage <img src="https://habrastorage.org/getpro/habr/post_images/a1c/008/72c/a1c00872c7ff186faa8a16fdeb6aba43.gif">  uniquely corresponding to the set <img src="https://habrastorage.org/getpro/habr/post_images/bf2/392/586/bf2392586cd578be46e4979339544063.gif">  vertices if <img src="https://habrastorage.org/getpro/habr/post_images/525/95c/b9b/52595cb9bc79ec91b2bf898164925fa0.gif">  or set <img src="https://habrastorage.org/getpro/habr/post_images/0d2/8fe/713/0d28fe7139b7a3f843a9fba573250901.gif">  vertices if <img src="https://habrastorage.org/getpro/habr/post_images/869/80c/bd9/86980cbd9bb7f6dee985f7a56e97cdd2.gif">  . <br><br>  <b>Theorem 2.</b> <br>  Minimum Power Subset <img src="https://habrastorage.org/getpro/habr/post_images/05f/3cc/855/05f3cc855b722ebc925ea8713ded4d58.gif">  edges incident to arbitrary vertex <img src="https://habrastorage.org/getpro/habr/post_images/279/344/d5e/279344d5e2c8131cb46ce5d98b2fb14b.gif">  ribs <img src="https://habrastorage.org/getpro/habr/post_images/3fc/cca/359/3fccca3597c1da70a43f7188c755a603.gif">  in column G, under the conditions <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec9/64b/c08/ec964bc0800976b4d3597f18e36ac17d.gif">  for all <img src="https://habrastorage.org/getpro/habr/post_images/6a1/9ef/2fb/6a19ef2fb82605f009946661e0443c26.gif"><br>  determines the smallest coverage <img src="https://habrastorage.org/getpro/habr/post_images/a1c/008/72c/a1c00872c7ff186faa8a16fdeb6aba43.gif">  uniquely corresponding to the set <img src="https://habrastorage.org/getpro/habr/post_images/bf2/392/586/bf2392586cd578be46e4979339544063.gif">  vertices if <img src="https://habrastorage.org/getpro/habr/post_images/525/95c/b9b/52595cb9bc79ec91b2bf898164925fa0.gif">  or set <img src="https://habrastorage.org/getpro/habr/post_images/0d2/8fe/713/0d28fe7139b7a3f843a9fba573250901.gif">  vertices if <img src="https://habrastorage.org/getpro/habr/post_images/869/80c/bd9/86980cbd9bb7f6dee985f7a56e97cdd2.gif">  . <br><br><hr><br>  <b>Based on the theorems, we propose the following algorithm for finding the smallest coverage.</b> <br><br>  1. Many <img src="https://habrastorage.org/getpro/habr/post_images/f53/2c2/fc7/f532c2fc7a171dde73b17d8382db6a03.gif" alt="image">  and family <img src="https://habrastorage.org/getpro/habr/post_images/95f/35b/2e6/95f35b2e6373aec26c12e10e09d17192.gif">  its subsets <img src="https://habrastorage.org/getpro/habr/post_images/f73/e0a/fa4/f73e0afa4a1db188b4a98871e6e5f3dd.gif">  match family <img src="https://habrastorage.org/getpro/habr/post_images/030/84b/ec1/03084bec1315bea7d88650fd361bc31c.gif">  subsets <img src="https://habrastorage.org/getpro/habr/post_images/b3b/a0c/233/b3ba0c2330fa73dfe6b2d4df84d9574f.gif">  .  If for some <img src="https://habrastorage.org/getpro/habr/post_images/51d/88d/486/51d88d486ef46d6ae5e95fd71fdf5656.gif">  will turn out <img src="https://habrastorage.org/getpro/habr/post_images/406/aeb/d90/406aebd9001cfd84dbf6e0456f568d65.gif">  then there is a trivial covering <img src="https://habrastorage.org/getpro/habr/post_images/b56/d43/0c8/b56d430c8237667fb9d9909e553249d5.gif">  .  The end of the algorithm. <br>  Otherwise, go to step 2. <br><br>  2. Build a full loaded graph <img src="https://habrastorage.org/getpro/habr/post_images/00b/53a/f4f/00b53af4f3d30aa66a63458911ffdb2a.gif">  where <img src="https://habrastorage.org/getpro/habr/post_images/6ef/69e/747/6ef69e747f8e42448f2bc1da5d163e7c.gif">  . <br>  Top of <img src="https://habrastorage.org/getpro/habr/post_images/623/88a/c71/62388ac71dfdda8a0a76a79a255296c3.gif">  load with set <img src="https://habrastorage.org/getpro/habr/post_images/2ff/22e/948/2ff22e948d4054824d99c61d0502addf.gif"><br>  Edge <img src="https://habrastorage.org/getpro/habr/post_images/fae/18c/8d9/fae18c8d9acc19ed28c445a2ac909f58.gif">  load with set <img src="https://habrastorage.org/getpro/habr/post_images/a4b/89b/5cc/a4b89b5cc81392a647db26d896f1ce74.gif">  . <br><br>  3. Check the existence of a coverage: for an arbitrary vertex <img src="https://habrastorage.org/getpro/habr/post_images/623/88a/c71/62388ac71dfdda8a0a76a79a255296c3.gif">  define subset <br><img src="https://habrastorage.org/getpro/habr/post_images/574/97c/b40/57497cb40205ef62b8b01981d04b299a.gif">  , <br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/623/4d5/579/6234d55796cc10a07937c5f490521ccd.gif">  - the set of edges incident to the top <img src="https://habrastorage.org/getpro/habr/post_images/623/88a/c71/62388ac71dfdda8a0a76a79a255296c3.gif">  in the graph <img src="https://habrastorage.org/getpro/habr/post_images/b23/57e/6c5/b2357e6c5ad2e5ee58b626e4326cd1a5.gif">  . <br>  If a <img src="https://habrastorage.org/getpro/habr/post_images/06a/aa3/91b/06aaa391b5b9bb46de7e0c12a4970771.gif">  then the cover does not exist.  The end of the algorithm. <br>  If a <img src="https://habrastorage.org/getpro/habr/post_images/457/b12/b08/457b12b08b0d20b8c8dbd27b567257fb.gif">  then the cover exists.  Go to the procedure for finding the smallest coverage (p. 4). <br><br>  4. Put t: = 0. <br>  5. In the full loaded graph <img src="https://habrastorage.org/getpro/habr/post_images/0d4/f4f/024/0d4f4f0243176b938b91c68a074454fa.gif">  find edge <img src="https://habrastorage.org/getpro/habr/post_images/fbe/438/18f/fbe43818f2f32bb50bbb5cc77961319e.gif">  for which the condition is met <img src="https://habrastorage.org/getpro/habr/post_images/281/f95/8d1/281f958d1205fefcb36d2363b57df873.gif">  . <br>  If a <img src="https://habrastorage.org/getpro/habr/post_images/299/402/f22/299402f2241d20230c04fd2f984dbba0.gif">  then go to step 6, <br>  otherwise, the procedure for constructing the set D of vertices defining the smallest coverage <img src="https://habrastorage.org/getpro/habr/post_images/a1c/008/72c/a1c00872c7ff186faa8a16fdeb6aba43.gif">  (paragraph 7). <br><br>  6. Build a full loaded graph <img src="https://habrastorage.org/getpro/habr/post_images/915/b56/ba3/915b56ba3496e443ac04a0d73b49e957.gif">  believing <img src="https://habrastorage.org/getpro/habr/post_images/c28/a7a/b15/c28a7ab15031bff8350df99e4692cf5c.gif">  , <img src="https://habrastorage.org/getpro/habr/post_images/b23/e64/05e/b23e6405e8ab455beca03751bcffcc31.gif">  - the set of edges incident to the top <img src="https://habrastorage.org/getpro/habr/post_images/bc1/5d4/2ab/bc15d42abb763eb748ef7cf162a13db2.gif">  in the graph <img src="https://habrastorage.org/getpro/habr/post_images/0d4/f4f/024/0d4f4f0243176b938b91c68a074454fa.gif">  . <br>  Put <img src="https://habrastorage.org/getpro/habr/post_images/bd2/ef7/5e6/bd2ef75e698c27e3e47909e7cfe47750.gif">  for all <img src="https://habrastorage.org/getpro/habr/post_images/412/d7b/649/412d7b64997d11a9594feb9f28647f35.gif">  . <br>  Put t: = t + 1 and go to step 5. <br><br>  7. Start building a set of D vertices defining the smallest coverage <img src="https://habrastorage.org/getpro/habr/post_images/a1c/008/72c/a1c00872c7ff186faa8a16fdeb6aba43.gif">  . <br>  Put <img src="https://habrastorage.org/getpro/habr/post_images/534/12c/991/53412c991af637406e885fb4a435d374.gif">  . <br><br>  8. If t = 0, then go to step 11, otherwise, put t: = t-1. <br><br>  9. In the column <img src="https://habrastorage.org/getpro/habr/post_images/0d4/f4f/024/0d4f4f0243176b938b91c68a074454fa.gif">  define subset <img src="https://habrastorage.org/getpro/habr/post_images/ee7/4f9/abb/ee74f9abb1813db22dbc3603326879a9.gif"><br><br>  10. If in the column <img src="https://habrastorage.org/getpro/habr/post_images/0d4/f4f/024/0d4f4f0243176b938b91c68a074454fa.gif">  condition is met <img src="https://habrastorage.org/getpro/habr/post_images/978/7f6/5e7/9787f65e7ab436db948a3bf3a41f64b7.gif">  then put <img src="https://habrastorage.org/getpro/habr/post_images/6b6/796/243/6b67962437e3e34924aa48d991d3009a.gif">  otherwise - D: = D.  Go to paragraph 8. <br><br>  11. Family <img src="https://habrastorage.org/getpro/habr/post_images/d18/6a5/56c/d186a556c34d806273910b460bb4372e.gif">  subsets <img src="https://habrastorage.org/getpro/habr/post_images/05d/6da/c8f/05d6dac8f458174a3b6451115b041fb3.gif">  determines the smallest coverage of sets <img src="https://habrastorage.org/getpro/habr/post_images/f53/2c2/fc7/f532c2fc7a171dde73b17d8382db6a03.gif">  . <br>  The end of the algorithm. <br><hr><br><br>  Let's try to estimate the complexity of the algorithm. <br>  The whole, so to speak, essence of the algorithm (from the point of view of complexity estimation) lies in the phrase ‚Äúwe construct a complete loaded graph‚Äù. <br>  We need to perform n actions to calculate the load at the n vertices of the graph and (n-1) n / 2 calculations (based on the number of edges of the full graph) for the load of the edges of the graph.  And all this, if we consider the worst case, when the subsets do not intersect each other, is performed n-2 times.  Thus, the rough estimate is O (n) = n <sup>3</sup> + n <sup>2</sup> . <br><br>  In conclusion.  I'm not sure that the post deserves an invite, because my involvement in the algorithm is more than dubious.  But the publication, it seems to me, is worth it.  I hope the moderators will understand. <br>  How did the Greeks say?  - Faisse que dois adviegne que peut (do what you must, and come what may). <br>  (or were they Romans?) </div><p>Source: <a href="https://habr.com/ru/post/225831/">https://habr.com/ru/post/225831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225821/index.html">‚ÄúWhere are you, Stepan?‚Äù Or how do Wi-fi bridges help save on the Internet</a></li>
<li><a href="../225823/index.html">Using Pjax in Yii2 (short review)</a></li>
<li><a href="../225825/index.html">Aptly - create your own repository</a></li>
<li><a href="../225827/index.html">Learning to understand the art of programming</a></li>
<li><a href="../225829/index.html">The method of self-determination of the response time of the LCD monitor screen or TV</a></li>
<li><a href="../225837/index.html">Notification during call pickup in Asterisk</a></li>
<li><a href="../225841/index.html">Swift programming language. Russian version</a></li>
<li><a href="../225845/index.html">Hexapod-robot running ROS</a></li>
<li><a href="../225847/index.html">ImEx.js will decorate your code</a></li>
<li><a href="../225849/index.html">Cisco has updated the product line of video communications equipment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>