<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods for detecting "glued" files</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many could hear about files like rarjpeg'i. This is a special kind of file, which is a jpeg image and rar-archive glued together closely. It is an exc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods for detecting "glued" files</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/52a/198/f07/52a198f079124eab867203ff8c120945.png"><br><br>  Many could hear about files like rarjpeg'i.  This is a special kind of file, which is a jpeg image and rar-archive glued together closely.  It is an excellent container for hiding the fact of information transfer.  You can create rarjpeg with the following commands: <br><br>  UNIX: <i>cat image1.jpg archive.rar&gt; image2.jpg</i> <br>  WINDOWS: <i>copy / b image1.jpg + archive.rar image2.jpg</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Or in the presence of a hex editor. <br><br>  Of course, to hide the fact of the transfer of information, you can use not only the JPEG format, but many others.  Each format has its own characteristics, due to which it can be suitable or not for the role of a container.  I will describe how you can find glued files in the most popular formats or point to the fact of gluing. <br><a name="habracut"></a><br>  Methods for detecting glued files can be divided into three groups: <br><br><ol><li>  The method of checking the area after the EOF marker.  Many popular file formats have a so-called end-of-file marker, which is responsible for displaying the necessary data.  For example, photo viewers read all bytes up to this marker, however, the area after it remains ignored.  This method is ideal for formats: JPEG, PNG, GIF, ZIP, RAR, PDF. </li><li>  Method of checking file size.  The structure of some formats (audio and video containers) allows you to calculate the actual file size and compare it with the original size.  Formats: AVI, WAV, MP4, MOV. </li><li>  Method for checking CFB files.  CFB or Compound File Binary Format - a document format developed by Microsoft, which is a container with its own file system.  This method is based on the detection of anomalies in the file. </li></ol><br><h2>  Is there life after the end of the file? </h2><br><h3>  Jpeg </h3><br>  To find the answer to this question, it is necessary to delve into the specification of the format, which is the "ancestor" of the glued files and understand its structure.  Any JPEG starts with a signature of 0xFF 0xD8. <br><br>  After this signature is service information, optionally an image icon and, finally, a compressed image itself.  In this format, the end of the image is marked by a two-byte signature 0xFF 0xD9. <br><br><h3>  PNG </h3><br>  The first eight bytes of the PNG file are occupied by the following signature: 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A.  The end signature that ends the data stream: 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82. <br><br><h3>  Rar </h3><br>  Common signature for all rar archives: 0x52 0x61 0x72 0x21 (Rar!).  After it there is information about the version of the archive and other related data.  It was experimentally established that the archive ends with the signature 0x0A, 0x25, 0x25, 0x45, 0x4F, 0x46. <br><br>  Table of formats and their signatures: <br><table><tbody><tr><th>  Format </th><th>  Initial signature </th><th>  Final signature </th></tr><tr><td>  Jpeg </td><td>  0xFF 0xD8 </td><td>  0xFF 0xD9 </td></tr><tr><td>  PNG </td><td>  0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A </td><td>  0x49 0x45 0x4E 0x44 0xAE 0x42 0x60 0x82 </td></tr><tr><td>  Rar </td><td>  0x52 0x61 0x72 0x21 </td><td>  0x0A 0x25 0x25 0x45 0x4F 0x46 </td></tr></tbody></table>  The check algorithm for gluing in these formats is extremely simple: <br><br><ol><li>  Find the initial signature; </li><li>  Find the final signature; </li><li>  If there is no data after the final signature - your file is clean and does not contain attachments!  Otherwise, you need to look for other formats after the final signature. </li></ol><br><h3>  GIF and PDF </h3><table><tbody><tr><th>  Format </th><th>  Initial signature </th><th>  Final signature </th></tr><tr><td>  Gif </td><td>  0x47 0x49 0x46 0x38 </td><td>  0x00 0x3B </td></tr><tr><td>  PDF </td><td>  0x25 0x50 0x44 0x46 </td><td>  0x0A 0x25 0x25 0x45 0x4F 0x46 </td></tr></tbody></table>  A PDF document may have more than one EOF marker, for example, due to incorrect document generation.  The number of final signatures in the GIF file is equal to the number of frames in it.  Based on the features of these formats, you can improve the algorithm for checking the presence of glued files. <br><br><ol><li>  Paragraph 1 is repeated from the previous algorithm. </li><li>  Paragraph 2 is repeated from the previous algorithm. </li><li>  When finding the final signature, remember its location and look further; </li><li>  If this way we reached the last EOF marker, the file is clean. </li><li>  If the file does not end with the final signature - goto is the location of the last found final signature. </li></ol><br>  The large difference between the file size and the position after the last final signature indicates the presence of an attached attachment.  The difference can be more than ten bytes, although it is possible to set other values. <br><br><h3>  ZIP </h3><br>  A special feature of ZIP archives is the presence of three different signatures: <table><tbody><tr><th>  Signatures </th><th>  Description </th></tr><tr><td>  0x50 0x4B 0x03 0x04 </td><td>  The signature of the usual archive </td></tr><tr><td>  0x50 0x4B 0x05 0x06 </td><td>  Empty archive signature </td></tr><tr><td>  0x50 0x4B 0x07 0x08 </td><td>  The signature of the archive, divided into parts </td></tr></tbody></table>  The archive structure is as follows: <br><table><tbody><tr><td>  Local File Header 1 </td></tr><tr><td>  File Data 1 </td></tr><tr><td>  Data Descriptor 1 </td></tr><tr><td>  Local File Header 2 </td></tr><tr><td>  File Data 2 </td></tr><tr><td>  Data Descriptor 2 </td></tr><tr><td>  ... </td></tr><tr><td>  Local File Header n </td></tr><tr><td>  File data n </td></tr><tr><td>  Data Descriptor n </td></tr><tr><td>  Archive decryption header </td></tr><tr><td>  Archive extra data record </td></tr><tr><td>  Central directory </td></tr></tbody></table>  Most interesting is the central directory, which contains metadata about the files in the archive.  The central directory always starts with the signature 0x50 0x4b 0x01 0x02 and ends with the signature 0x50 0x4b 0x05 0x06, followed by 18 bytes of metadata.  Interestingly, empty archives consist only of a finite signature and 18 zero bytes.  After 18 bytes, the archive comment area follows, which is an ideal container for hiding a file. <br><br>  To check the ZIP archive, you need to find the final signature of the central directory, skip 18 bytes and look for signatures of known formats in the comment field.  The large size of the comment also indicates the fact of gluing. <br><br><h2>  Size matters </h2><br><h3>  Avi </h3><br>  The structure of the AVI file is as follows: each file starts with a RIFF signature (0x52 0x49 0x46 0x46).  On the 8 byte is the format specifying the signature AVI (0x41 0x56 0x49 0x20).  The block at offset 4, consisting of 4 bytes, contains the initial size of the data block (byte order - little endian).  To find out the number of the block containing the next size, you need to add the size of the header (8 bytes) and the size obtained in the block 4-8 ‚Äã‚Äãbytes.  This calculates the total file size.  It is assumed that the calculated size may be smaller than the actual file size.  After the calculated size, the file will contain only zero bytes (it is necessary to align the border with 1 Kb). <br><br>  Size calculation example: <br><br><img src="https://habrastorage.org/web/73c/5c8/80e/73c5c880e8c941c18c096bf5809bf2c3.png"><br><table><tbody><tr><th>  Bias </th><th>  The size </th><th>  Next offset </th></tr><tr><td>  four </td><td>  31442 </td><td>  8 + 31442 = 31450 </td></tr></tbody></table><h3>  Wav </h3><br>  Like AVI, a WAV file starts with a RIFF signature, however, this file has a signature with 8 bytes - WAVE (0x57 0x41 0x56 0x45).  File size is calculated in the same way as AVI.  The real size should coincide completely with the calculated one. <br><br><h3>  Mp4 </h3><br>  MP4 or MPEG-4 - a media container format used for storing video and audio streams, also provides for the storage of subtitles and images. <br>  Signatures are located at 4 bytes offset: file type ftyp (66 74 79 70) (QuickTime Container File Type) and file type mmp4 (6D 6D 70 34).  To recognize hidden files, we are interested in the ability to calculate the file size. <br><br><img src="https://habrastorage.org/web/81f/513/ebc/81f513ebce8f41988e627f5bb3148318.png"><br><br>  Consider an example.  The size of the first block is at zero offset, and it is equal to 28 (00 00 00 1C, Big Endian byte order);  it also indicates the offset, where is the size of the second data block.  At 28 offset we find the next block size equal to 8 (00 00 00 08).  To find the next block size, add the dimensions of the previous blocks found.  Thus, the file size is calculated: <br><table><tbody><tr><th>  Bias </th><th>  Value </th><th>  Next offset </th></tr><tr><td>  0 </td><td>  28 </td><td>  28 + 0 = 28 </td></tr><tr><td>  28 </td><td>  eight </td><td>  28 + 8 = 36 </td></tr><tr><td>  36 </td><td>  303739 </td><td>  36 + 303739 = 303775 </td></tr><tr><td>  303775 </td><td>  6202 </td><td>  303775 + 6202 = 309977 </td></tr></tbody></table><h3>  Mov </h3><br>  This widely used format is also an MPEG-4 container.  MOV uses a proprietary data compression algorithm, has a similar MP4 structure and is used for the same purpose - to store audio and video data, as well as related materials. <br>  Like MP4, any mov-file has a 4-byte signature ftyp at 4 offset, however, the following signature has the value qt__ (71 74 20 20).  The rule for calculating the file size has not changed: starting from the beginning of the file, we calculate the size of the next block and add it. <br><br>  The method of checking this group of formats for the presence of ‚Äúglued‚Äù files is to calculate the size according to the rules specified above and compare it with the size of the file being scanned.  If the current file size is much smaller than the calculated one, then this indicates the fact of splicing.  When checking AVI files, it is assumed that the calculated size may be smaller than the file size due to the presence of added zeros to align the border.  In such a case, it is necessary to check the zeros after the calculated file size. <br><br><h2>  Checking Compound File Binary Format </h2><br>  This file format, developed by Microsoft, is also known as OLE (Object Linking and Embedding) or COM (Component Object Model).  Files DOC, XLS, PPT belong to a group of CFB-formats. <br><br>  The CFB file consists of a 512-byte header and sectors of the same length that store data streams or service information.  Each sector has its own non-negative number, with the exception of special numbers: ‚Äú-1‚Äù - numbers the free sector, ‚Äú-2‚Äù - numbers the sector that closes the chain.  All sector chains are defined in the FAT table. <br><br><img src="https://habrastorage.org/web/3f5/0b4/13b/3f50b413bf8e4e91a84934d9958ea784.png"><br><br>  Suppose that an attacker modified a certain doc-file and pasted another file into its end.  There are several different ways to detect it or point to an anomaly in a document. <br><br><h3>  Abnormal file size </h3><br>  As mentioned above, any CFB file consists of a header and sectors of equal length.  To find out the size of a sector, you need to read a two-byte number at 30 offset from the beginning of the file and raise 2 to the power of this number.  This number must be either 9 (0x0009) or 12 (0x000C), respectively, the size of the file sector is 512 or 4096 bytes.  After finding the sector, check the following equality: <br><br>  (FileSize - 512) mod SectorSize = 0 <br><br>  If this equality does not hold, then you can indicate the fact of the gluing of files.  However, this method has a significant drawback.  If the attacker knows the size of the sector, then it is enough for him to paste his file and n more bytes so that the value of the glued data is a multiple of the size of the sector. <br><br><h3>  Unknown sector type </h3><br>  If the attacker knows about the workaround of the previous check, then this method can detect the presence of sectors with undefined types. <br><br>  We define the equality: <br><br>  FileSize = 512 + CountReal * SectorSize, where FileSize is the file size, SectorSize is the sector size, CountReal is the number of sectors. <br><br>  We also define the following variables: <br><br><ol><li>  CountFat is the number of FAT sectors.  Located at 44 offset from the beginning of the file (4 bytes); </li><li>  CountMiniFAT - the number of MiniFAT sectors.  Located at 64 offset from the beginning of the file (4 bytes); </li><li>  CountDIFAT - the number of sectors DIFAT.  Located at 72 offset from the beginning of the file (4 bytes); </li><li>  CountDE - the number of sectors Directory Entry.  To find this variable, you need to find the first DE sector, which is at 48 offset.  Then you need to get the full DE representation from the FAT and count the number of DE sectors; </li><li>  CountStreams - the number of sectors with datastrims; </li><li>  CountFree - the number of free sectors; </li><li>  CountClassified - the number of sectors with a specific type; </li></ol><br>  CountClassified = CountFAT + CountMiniFAT + CountDIFAT + CountDE + CountStreams + CountFree <br><br>  Obviously, with the CountClassified and CountReal inequalities, it can be concluded that files can be glued together. <br><br><h3>  Used sources: </h3><br>  <a href="http://www.file-recovery.com/mp4-signature-format.htm">Parsing MP4 structure</a> <br>  <a href="http://www.file-recovery.com/avi-signature-format.htm">Parsing AVI structure</a> <br>  <a href="http://www.file-recovery.com/mov-signature-format.htm">Parsing MOV structure</a> <br>  <a href="http://www.file-recovery.com/wav-signature-format.htm">Parsing wav structure</a> <br>  <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Otsubo-O-checker-Detection-of-Malicious-Documents-through-Deviation-from-File-Format-Specifications-wp.pdf">O-checker: Detection of Malicious Documents through Deviation from File Format Specifications</a> <br>  <a href="http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp">GIF format specifications</a> <br>  <a href="http://www.adobe.com/devnet/pdf/pdf_reference.html">PDF format specifications</a> <br>  <a href="https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format">JPEG article on Wikipedia</a> <br>  <a href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html">Zip structure parsing</a> </div><p>Source: <a href="https://habr.com/ru/post/337084/">https://habr.com/ru/post/337084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337072/index.html">PUSH authorization in services using a mobile application</a></li>
<li><a href="../337076/index.html">Experience in the development of a high-loaded system within the HighLoad Cup</a></li>
<li><a href="../337078/index.html">Using Graphviz for flowcharts</a></li>
<li><a href="../337080/index.html">Our rake when starting Calltouch Predict: 365 days of speech recognition and machine learning</a></li>
<li><a href="../337082/index.html">Practical use of the blockchain as a distributed data warehouse</a></li>
<li><a href="../337086/index.html">Corporate communication in Telegram. Migration from WhatsApp at full speed</a></li>
<li><a href="../337088/index.html">Securing Network Security in the Kubernetes Cluster</a></li>
<li><a href="../337092/index.html">Artificial intelligence will save from ransomware</a></li>
<li><a href="../337094/index.html">4 ICO IT startups in September: sale of excess communications, parallel Internet and awards to open-source developers</a></li>
<li><a href="../337096/index.html">Sending an e-mail message in the 3CX Call Flow Designer development environment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>