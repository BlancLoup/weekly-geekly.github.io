<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The case of the maloksky safe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think that many of those present here know the game Space Rangers . Also, I don‚Äôt think that I‚Äôm going to make a big mistake if I say that, to a lar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The case of the maloksky safe</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/4f8/7ae/496/4f87ae4965e383cecbbbee941baefa27.png"><br>  I think that many of those present here know the game <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2581%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B4%25D0%25B6%25D0%25B5%25D1%2580%25D1%258B">Space Rangers</a> .  Also, I don‚Äôt think that I‚Äôm going to make a big mistake if I say that, to a large extent, this game owes its charm to the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2581%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B4%25D0%25B6%25D0%25B5%25D1%2580%25D1%258B">text quests</a> that have actually been revived.  Some of these quests, such as the Citadel or Ski Resort, may well be considered as independent games. <br><br>  My attitude to text quests is twofold.  On the one hand, they are very interesting and incredibly atmospheric.  On the other hand, some of them are not easy to go through.  Quest "Fifteen" immediately put me in a dead end.  I do not solve all sorts of puzzles very well, so I decided to write a program that will find a solution for me. <br><a name="habracut"></a><br>  So, according to the conditions of the assignment, we need to open the safe, which requires solving a puzzle, which painfully resembles the well-known game <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%258F%25D1%2582%25D0%25BD%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">15</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c72/38e/42a/c7238e42a0c4ed0e689801b590c276d2.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Despite the similarities, there are two important differences that should be mentioned: <br><br><ol><li>  The puzzle is required to solve for a limited number of moves. </li><li>  As you can see, the numbers on the chips are repeated. </li></ol><br>  The restriction on the number of moves, as will be shown below, will help us in solving the problem (I note that it is not necessary to search for the shortest solution, it is enough to find any solution not exceeding 59 moves).  With the second item, things are not so simple.  At first glance, it should simplify the decision, but it is not. <br><br>  It is widely known that half of the possible positions in the ‚Äú15‚Äù game have no solutions.  In addition, for part of the positions, the minimum number of moves required for the decision may exceed the number of moves specified in the conditions of the task.  Thus, if we start moving one of the paired chips out of place, we most likely will not be able to solve the puzzle.  In order not to be confused with paired chips, it makes sense to renumber them in a unique way, reducing the puzzle to the classic game "15". <br><br>  Since, according to the conditions of the assignment, there are 7 pairs of matching chips, in fact, it is required to solve one of 2 ^ (7 - 1) = 64 puzzles, some of which will not have a solution.  This undoubtedly complicates the task. <br><br>  Before proceeding to the solution of the problem, we note that it is required to store the state of 16 cells, each of which can be in 16 states (an empty cell will be encoded with a zero).  This allows you to use an 8-byte integer to store the position. <br><br>  Let's start with solving the classic puzzle "15" (with non-repeating chips): <br><br><div class="spoiler">  <b class="spoiler_title">solver.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SOLVER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOLVER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include "common.h" #include "PerfCnt.h" class Solver { public: Solver(Long startPos, Long endPos, int stepCnt): startPos(startPos), endPos(endPos), stepCnt(stepCnt), posCnt(0), perfCnt() {} bool solve(); private: Long startPos; Long endPos; int stepCnt; Long posCnt; PerfCnt perfCnt; static Long pos[MAX_DEEP]; static Byte step[MAX_DEEP]; void dumpSolve(int deep); void dumpPos(int delta); void dumpTotal(); bool checkPos(Long p, int deep); bool solve(int deep, int delta, int startDelta, int X, int Y); Long getStep(Long p, int x, int y, int dx, int dy, int&amp; dd); }; #endif</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">solver.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"solver.h"</span></span></span><span class="hljs-meta"> Long Solver::pos[MAX_DEEP]; Byte Solver::step[MAX_DEEP]; void Solver::dumpPos(int delta) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Distance: %d\n\n"</span></span></span><span class="hljs-meta">, delta); Long mask = 0xFFFF; for (int shift = 48; shift &gt;= 0; shift -= 16) { int x = (int)((startPos &amp; (mask </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; shift)) &gt;&gt; shift); int y = (int)((endPos &amp; (mask &lt;&lt; shift)) &gt;&gt; shift); printf("%04X %04X\n", x, y); } } void Solver::dumpSolve(int deep) { printf("\n"); for (int i = 0; i &lt; deep; i++) { printf("%d", step[i]); } printf("\n"); } void Solver::dumpTotal() { printf("\nCount: %6I64d\n", posCnt); printf("Time: %7.3f\n\n", perfCnt.elapsed()); } bool Solver::checkPos(Long p, int deep) { int j = MAX_LOOP; for (int i = deep - 1; i &gt;=0; i--) { if (pos[i] == p) return true; if (--j &lt;= 0) break; } return false; } bool Solver::solve() { if (stepCnt &gt;= MAX_DEEP) return false; pos[0] = startPos; int delta = getDelta(startPos, endPos); int X = getX(startPos); int Y = getY(startPos); dumpPos(delta); bool r = solve(0, delta, delta, X, Y); dumpTotal(); return r; } Long Solver::getStep(Long p, int x, int y, int dx, int dy, int&amp; dd) { Long digit = getDigit(p, x + dx, y + dy); if (digit == 0) return p; if (dx != 0) { int delta = getDeltaX(startPos, endPos, digit); if (delta * dx &lt;= 0) { dd++; } else { dd--; } } if (dy != 0) { int delta = getDeltaY(startPos, endPos, digit); if (delta * dy &lt;= 0) { dd++; } else { dd--; } } xorDigit(p, x, y, digit); xorDigit(p, x + dx, y + dy, digit); return p; } bool Solver::solve(int deep, int delta, int startDelta, int X, int Y) { if (pos[deep] == endPos) { dumpSolve(deep); return true; } if (delta &gt; stepCnt - deep) { return false; } if (delta - startDelta &gt; MAX_DELTA_DIFF) { return false; } for (int i = 0; i &lt; 4; i++) { int dd = 0; int dx = 0; int dy = 0; switch (i) { case 0: dy--; break; case 1: dx++; break; case 2: dy++; break; case 3: dx--; break; } if ((X + dx &lt; 1)||(Y + dy &lt; 1)||(X + dx &gt; 4)||(Y + dy &gt; 4)) continue; if (deep + 1 &gt;= MAX_DEEP) return false; pos[deep + 1] = getStep(pos[deep], X, Y, dx, dy, dd); if (checkPos(pos[deep + 1], deep)) continue; step[deep] = i; posCnt++; if (solve(deep + 1, delta + dd, startDelta, X + dx, Y + dy)) return true; } return false; }</span></span></span></span></code> </pre><br></div></div><br>  This is an ordinary return search.  We iterate over all possible moves, change the position and call the same function recursively for the new position.  The made moves are encoded with numbers from 0 to 3, indicating the direction of movement of an empty cell (0 - up, 1 - right, 2 - down, 3 - left): <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: dy--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: dx++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: dy++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: dx--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><br>  For the convenience of outputting the solution, we store the sequence of completed moves on the stack (since the number of moves is limited by the conditions of the problem, you can use a regular static array). <br><br>  The main difficulty of this approach is an avalanche increase in the number of viewed positions, depending on the depth of search.  It is necessary to somehow cut the moves, which obviously do not lead to the correct decision.  The following considerations will help: <br><br><ol><li>  For each position it is possible from 2 to 4 possible moves (depending on the position of the empty cell), while it does not make sense to repeat the previously considered positions (positions, as well as moves, can be stored in a static stack). </li><li>  For each position, you can calculate the <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Manhattan distance</a> to the desired position (the total number of moves required to return all the chips to their place, provided that other chips do not interfere with them).  Hereinafter, I will call it simply distance.  If the calculated distance exceeds the number of remaining moves, the position has no solution and further search can be stopped (here we are helped by the knowledge that the puzzle is solved in no more than N moves). </li></ol><br>  Since the calculation of the distance is a relatively resource-intensive operation, it can be calculated once (for the initial position), further incrementing or decrementing this value depending on the direction of movement of the piece, which is another move. <br><br>  We implement auxiliary functions: <br><br><div class="spoiler">  <b class="spoiler_title">common.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> COMMON_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COMMON_H_ typedef unsigned __int64 Long; typedef unsigned __int16 Short; typedef unsigned char Byte; const int MAX_POSITION = 4; const int MAX_DIGIT = 15; const int MAX_DEEP = 100; const int MAX_LOOP = 10; const int MAX_TASKS = 100; const int MAX_DELTA_DIFF = 5; int getPosition(Long part); int getX(Long state); int getY(Long state); int getX(Long state, Long d); int getY(Long state, Long d); int getDeltaX(Long a, Long b, Long d); int getDeltaY(Long a, Long b, Long d); int getDelta(Long a, Long b); Long getDigit(Long p, int x, int y); void xorDigit(Long&amp; p, int x, int y, Long d); void setDigit(Long&amp; p, Long m, Long d); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">common.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; Long digit[MAX_DIGIT + 1] = { 0x0000000000000000L, 0x1111111111111111L, 0x2222222222222222L, 0x3333333333333333L, 0x4444444444444444L, 0x5555555555555555L, 0x6666666666666666L, 0x7777777777777777L, 0x8888888888888888L, 0x9999999999999999L, 0xAAAAAAAAAAAAAAAAL, 0xBBBBBBBBBBBBBBBBL, 0xCCCCCCCCCCCCCCCCL, 0xDDDDDDDDDDDDDDDDL, 0xEEEEEEEEEEEEEEEEL, 0xFFFFFFFFFFFFFFFFL }; int getPosition(Long part) { for (int i = 4; i &gt; 0; i--) { if ((part &amp; 0xF) == 0) return i; part &gt;&gt;= 4; } return 0; } int getX(Long state) { for (int i = 4; i &gt;= 1; i--) { int r = getPosition(state &amp; 0xFFFF); if (r != 0) return r; state &gt;&gt;= 16; } return 0; } int getY(Long state) { for (int i = 4; i &gt;= 1; i--) { int r = getPosition(state &amp; 0xFFFF); if (r != 0) return i; state &gt;&gt;= 16; } return 0; } int getX(Long state, Long d) { state ^= digit[d]; return getX(state); } int getY(Long state, Long d) { state ^= digit[d]; return getY(state); } int getDeltaX(Long a, Long b, Long d) { a ^= digit[d]; b ^= digit[d]; return getX(a) - getX(b); } int getDeltaY(Long a, Long b, Long d) { a ^= digit[d]; b ^= digit[d]; return getY(a) - getY(b); } int getDelta(Long a, Long b) { int r = 0; for (Long d = 1; d &lt;= MAX_DIGIT; d++) { r += abs(getDeltaX(a, b, d)); r += abs(getDeltaY(a, b, d)); } return r; } Long getDigit(Long p, int x, int y) { for (; y &lt;= 4; y++) { if (y == 4) { p &amp;= 0xFFFF; for (; x &lt;= 4; x++) { if (x == 4) { return p &amp; 0xF; } p &gt;&gt;= 4; } break; } p &gt;&gt;= 16; } return -1; } void xorDigit(Long&amp; p, int x, int y, Long d) { for (; x &lt; 4; x++) { d &lt;&lt;= 4; } for (; y &lt; 4; y++) { d &lt;&lt;= 16; } p ^= d; } void setDigit(Long&amp; p, Long m, Long d) { p ^= p &amp; m; m &amp;= digit[d]; p ^= m; }</span></span></span></span></code> </pre><br></div></div><br>  In order to optimize performance, we try to maximize the use of bit operations. <br><br>  To make sure everything works, you can solve a small puzzle: <br><br><pre> <code class="hljs">1 2 3 4 5 1 3 4 5 6 7 8 9 2 B 7 9 ABCD 6 A 8 DEFEFC</code> </pre><br>  Since I myself have prepared this example, I know that 11 moves are enough to solve it. <br><br>  Indeed, with this limitation, the program displays the answer in a thousandth of a second: <br><br><pre> <code class="hljs pgsql">Distance: <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">1234</span></span> <span class="hljs-number"><span class="hljs-number">5134</span></span> <span class="hljs-number"><span class="hljs-number">5678</span></span> <span class="hljs-number"><span class="hljs-number">92</span></span>B7 <span class="hljs-number"><span class="hljs-number">9</span></span>ABC D6A8 DEF0 <span class="hljs-number"><span class="hljs-number">0</span></span>EFC <span class="hljs-number"><span class="hljs-number">00323003222</span></span> Count: <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">0.001</span></span></code> </pre><br>  We see that 18 positions are considered.  In order to assess the increase in complexity, depending on the difference in the limit on the number of moves and the distance to the final position, I will increase the limit on the number of moves, fixing the number of viewed positions. <br><br>  The final schedule is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/023/1e2/1f3/0231e21f339e30e49d2241b233b10f12.png" alt="image"><br><br>  Sawtooth graphics due to the fact that the program finds new (longer) solutions, with increasing restrictions on the number of moves.  As expected, the number of viewed positions increases very quickly. <br><br>  Now it remains to implement the renumbering of pair chips.  This also helps recursion: <br><br><div class="spoiler">  <b class="spoiler_title">initializer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> INITIALIZER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INITIALIZER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"solver.h"</span></span></span><span class="hljs-meta"> struct Task { Long startPos; Long endPos; int delta; bool isProcessed; }; class Initializer { public: Initializer(Long startPos, Long endPos, int stepCnt): startPos(startPos), endPos(endPos), stepCnt(stepCnt), taskCnt(0) {} bool solve(); private: Long startPos; Long endPos; int stepCnt; int taskCnt; static Task tasks[MAX_TASKS]; static int digits[MAX_DIGIT + 1]; bool checkInit(Long s, Long e); bool addPos(Long s, Long e); bool init(Long s, Long e); Long getFreeDigit(); bool checkPos(Long s, Long e); void normalize(Long&amp; p); void dumpPos(Long s, Long e, int delta); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">initializer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"initializer.h"</span></span></span><span class="hljs-meta"> Task Initializer::tasks[MAX_TASKS]; int Initializer::digits[MAX_DIGIT + 1]; bool Initializer::solve() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!init(startPos, endPos)) return false; while (true) { int mn = stepCnt; int ix = -1; for (int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; taskCnt; i++) { if (tasks[i].isProcessed) continue; if (stepCnt - tasks[i].delta &lt; mn) { mn = stepCnt - tasks[i].delta; ix = i; } } if (ix &lt; 0) break; tasks[ix].isProcessed = true; Solver solver(tasks[ix].startPos, tasks[ix].endPos, stepCnt); if (solver.solve()) return true; } return false; } bool Initializer::checkInit(Long s, Long e) { for (int i = 0; i &lt;= MAX_DIGIT; i++) { digits[i] = 0; } for (int i = 0; i &lt;= MAX_DIGIT; i++) { digits[s &amp; 0xF]++; s &gt;&gt;= 4; } if (digits[0] != 1) return false; for (int i = 0; i &lt;= MAX_DIGIT; i++) { digits[e &amp; 0xF]--; e &gt;&gt;= 4; } for (int i = 0; i &lt;= MAX_DIGIT; i++) { if (digits[i] != 0) return false; } return true; } void Initializer::dumpPos(Long s, Long e, int delta) { printf("0x"); Long mask = 0xFFFF; for (int shift = 48; shift &gt;= 0; shift -= 16) { int x = (int)((s &amp; (mask &lt;&lt; shift)) &gt;&gt; shift); printf("%04X", x); } printf(" 0x"); mask = 0xFFFF; for (int shift = 48; shift &gt;= 0; shift -= 16) { int x = (int)((e &amp; (mask &lt;&lt; shift)) &gt;&gt; shift); printf("%04X", x); } printf(" %d\n", delta); } bool Initializer::addPos(Long s, Long e) { if (!checkPos(s, e)) return true; if (taskCnt &gt;= MAX_TASKS) return false; tasks[taskCnt].startPos = s; tasks[taskCnt].endPos = e; tasks[taskCnt].delta = getDelta(s, e); tasks[taskCnt].isProcessed = false; if (tasks[taskCnt].delta == 0) return false; if (tasks[taskCnt].delta &gt; stepCnt) return true; taskCnt++; return true; } Long Initializer::getFreeDigit() { for (Long i = 1; i &lt;= MAX_DIGIT; i++) { if (digits[i] == 0) return i; } return 0; } bool Initializer::init(Long s, Long e) { for (int i = 0; i &lt;= MAX_DIGIT; i++) { digits[i] = 0; } Long x = s; for (int i = 0; i &lt;= MAX_DIGIT; i++) { digits[x &amp; 0xF]++; x &gt;&gt;= 4; } bool f = true; for (int i = 0; i &lt;= MAX_DIGIT; i++) { if (digits[i] != 1) f = false; } if (f) { return addPos(s, e); } Long d = getFreeDigit(); if (d == 0) return false; x = s; Long ms = 0xF; for (int i = 0; i &lt;= MAX_DIGIT; i++) { Long t = x &amp; 0xF; if (digits[t] &gt; 1) { setDigit(s, ms, d); Long y = e; Long me = 0xF; for (int j = 0; j &lt;= MAX_DIGIT; j++) { if ((y &amp; 0xF) == t) { Long k = e; setDigit(k, me, d); if (!init(s, k)) return false; } me &lt;&lt;= 4; y &gt;&gt;= 4; } break; } ms &lt;&lt;= 4; x &gt;&gt;= 4; } return true; } void Initializer::normalize(Long&amp; p) { int x = getX(p); int y = getY(p); for (; x &lt; 4; x++) { Long d = getDigit(p, x + 1, y); xorDigit(p, x + 1, y, d); xorDigit(p, x, y, d); } for (; y &lt; 4; y++) { Long d = getDigit(p, x, y + 1); xorDigit(p, x, y + 1, d); xorDigit(p, x, y, d); } } bool Initializer::checkPos(Long s, Long e) { normalize(s); normalize(e); Long nums[16] = {0}; int ix = 0; for (int y = 1; y &lt; 4; y++) { for (int x = 1; x &lt; 4; x++) { Long d = getDigit(e, x, y); if (d != 0) { nums[d] = ++ix; } } } int cn = 0; for (int y = 1; y &lt; 4; y++) { for (int x = 1; x &lt; 4; x++) { Long d = getDigit(s, x, y); for (Long i = 1; i &lt;= 15; i++) { if (nums[i] &lt; nums[d]) { int Y = getY(s, i); if (Y &lt; y) continue; if (Y &gt; y) { cn++; break; } int X = getX(s, i); if (X &gt; x) { cn++; break; } } } } } return (cn &amp; 1) == 0; }</span></span></span></span></code> </pre><br></div></div><br>  Before adding to the list, we check whether the position has a solution and whether it can be solved for the specified number of moves (it is better to check once more than to perform a costly search for a position that is obviously not having a solution). <br><br>  Here is a list of possible positions, sorted in descending order of distance: <br><br><div class="spoiler">  <b class="spoiler_title">list</b> <div class="spoiler_text"><pre> <code class="hljs">0x763258F4E1DCBA90 0x6CBEDA1F29873450 50 0x763258F4E1DCBA90 0x6CBED81F29A73450 48 0x763258F4E1DCBA90 0x6CBEDA9F21873450 48 0x763258F4E1DCBA90 0x6CBED89F21A73450 46 0x763258F4E1DCBA90 0x6C4EDA1F29873B50 44 0x763258F4E1DCBA90 0x65BEDA12F98734C0 44 0x763258F4E1DCBA90 0x6CBE7A1F298D3450 44 0x763258F4E1DCBA90 0x6C4ED81F29A73B50 42 0x763258F4E1DCBA90 0x65BED812F9A734C0 42 0x763258F4E1DCBA90 0x6CBE781F29AD3450 42 0x763258F4E1DCBA90 0x6CB3DA1F2987E450 42 0x763258F4E1DCBA90 0x6C4EDA9F21873B50 42 0x763258F4E1DCBA90 0x65BEDA92F18734C0 42 0x763258F4E1DCBA90 0x6CBE7A9F218D3450 42 0x763258F4E1DCBA90 0x6CB3D81F29A7E450 40 0x763258F4E1DCBA90 0x6C4ED89F21A73B50 40 0x763258F4E1DCBA90 0x65BED892F1A734C0 40 0x763258F4E1DCBA90 0x6CBE789F21AD3450 40 0x763258F4E1DCBA90 0x6CB3DA9F2187E450 40 0x763258F4E1DCBA90 0x654EDA12F9873BC0 38 0x763258F4E1DCBA90 0x6C4E7A1F298D3B50 38 0x763258F4E1DCBA90 0x65BE7A12F98D34C0 38 0x763258F4E1DCBA90 0x6CB3D89F21A7E450 38 0x763258F4E1DCBA90 0x654ED812F9A73BC0 36 0x763258F4E1DCBA90 0x6C4E781F29AD3B50 36 0x763258F4E1DCBA90 0x65BE7812F9AD34C0 36 0x763258F4E1DCBA90 0x6C43DA1F2987EB50 36 0x763258F4E1DCBA90 0x65B3DA12F987E4C0 36 0x763258F4E1DCBA90 0x6CB37A1F298DE450 36 0x763258F4E1DCBA90 0x654EDA92F1873BC0 36 0x763258F4E1DCBA90 0x6C4E7A9F218D3B50 36 0x763258F4E1DCBA90 0x65BE7A92F18D34C0 36 0x763258F4E1DCBA90 0x6C43D81F29A7EB50 34 0x763258F4E1DCBA90 0x65B3D812F9A7E4C0 34 0x763258F4E1DCBA90 0x6CB3781F29ADE450 34 0x763258F4E1DCBA90 0x654ED892F1A73BC0 34 0x763258F4E1DCBA90 0x6C4E789F21AD3B50 34 0x763258F4E1DCBA90 0x65BE7892F1AD34C0 34 0x763258F4E1DCBA90 0x6C43DA9F2187EB50 34 0x763258F4E1DCBA90 0x65B3DA92F187E4C0 34 0x763258F4E1DCBA90 0x6CB37A9F218DE450 34 0x763258F4E1DCBA90 0x654E7A12F98D3BC0 32 0x763258F4E1DCBA90 0x6C43D89F21A7EB50 32 0x763258F4E1DCBA90 0x65B3D892F1A7E4C0 32 0x763258F4E1DCBA90 0x6CB3789F21ADE450 32 0x763258F4E1DCBA90 0x654E7812F9AD3BC0 30 0x763258F4E1DCBA90 0x6543DA12F987EBC0 30 0x763258F4E1DCBA90 0x6C437A1F298DEB50 30 0x763258F4E1DCBA90 0x65B37A12F98DE4C0 30 0x763258F4E1DCBA90 0x654E7A92F18D3BC0 30 0x763258F4E1DCBA90 0x6543D812F9A7EBC0 28 0x763258F4E1DCBA90 0x6C43781F29ADEB50 28 0x763258F4E1DCBA90 0x65B37812F9ADE4C0 28 0x763258F4E1DCBA90 0x654E7892F1AD3BC0 28 0x763258F4E1DCBA90 0x6543DA92F187EBC0 28 0x763258F4E1DCBA90 0x6C437A9F218DEB50 28 0x763258F4E1DCBA90 0x65B37A92F18DE4C0 28 0x763258F4E1DCBA90 0x6543D892F1A7EBC0 26 0x763258F4E1DCBA90 0x6C43789F21ADEB50 26 0x763258F4E1DCBA90 0x65B37892F1ADE4C0 26 0x763258F4E1DCBA90 0x65437A12F98DEBC0 24 0x763258F4E1DCBA90 0x65437812F9ADEBC0 22 0x763258F4E1DCBA90 0x65437A92F18DEBC0 22 0x763258F4E1DCBA90 0x65437892F1ADEBC0 20</code> </pre><br></div></div><br>  It was in this order that I began to check positions, because I believed that the fastest search would be for positions with the maximum distance.  Indeed, the first elements of the list were checked in a few seconds, but for the first position with a distance of 42, the search had to be stopped after 10 minutes of waiting. <br><br>  At this point, I was a little sad and began to think about introducing heuristics to determine the order of enumeration of possible moves, and generally, about a more careful study of the algorithm <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">A *</a> .  But, just by inertia, I decided to check the last element of the list: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;tchar.h&gt; #include "initializer.h" int _tmain(int argc, _TCHAR* argv[]) { Initializer m(0x763258F4E1DCBA90, 0x65437892F1ADEBC0, 59); m.solve(); return 0; }</span></span></span></span></code> </pre><br>  I did not even immediately realize that the program found a solution: <br><br><pre> <code class="hljs pgsql">Distance: <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">7632</span></span> <span class="hljs-number"><span class="hljs-number">6543</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span>F4 <span class="hljs-number"><span class="hljs-number">7892</span></span> E1DC F1AD BA90 EBC0 <span class="hljs-number"><span class="hljs-number">00032103210321032330111223010323032112233000121221</span></span> Count: <span class="hljs-number"><span class="hljs-number">6117348</span></span> <span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">2.404</span></span></code> </pre><br>  In just two and a half seconds. <br><br>  Quest is passed. <br><br>  Sources, as always, on <a href="https://github.com/GlukKazan/15">github</a> . <br></div><p>Source: <a href="https://habr.com/ru/post/180043/">https://habr.com/ru/post/180043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180023/index.html">GSM Modem M95 from QUECTEL - mastering experience</a></li>
<li><a href="../180027/index.html">Calculation of arithmetic expressions in a text editor</a></li>
<li><a href="../180033/index.html">Google calls for a speedy transition to the VP9 codec</a></li>
<li><a href="../180037/index.html">Avast! removes calc.exe as a virus (2: 0)</a></li>
<li><a href="../180041/index.html">Mobile marketing and application design on AppClub {build, monetize} # 6 Kyiv</a></li>
<li><a href="../180047/index.html">Automated testing of a web application (MS Unit Testing Framework + Selenium WebDriver C #). Part 2.1: Selenium API wrapper - Browser</a></li>
<li><a href="../180049/index.html">Rambler distributes the search for Yandex through trojans on torrents</a></li>
<li><a href="../180051/index.html">A Chinese kidnapped from a family found his home 23 years later, thanks to a service for searching kidnapped people and Google Maps</a></li>
<li><a href="../180057/index.html">HackDay # 27 in St. Petersburg</a></li>
<li><a href="../180059/index.html">Concept of new mail from TIMEWEB!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>