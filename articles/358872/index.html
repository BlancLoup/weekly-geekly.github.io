<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compact serializer for cache using System.Reflection.Emit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modern services without a cache, nowhere: data access in a persistent database is a long and expensive business, so adding intermediate storage for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compact serializer for cache using System.Reflection.Emit</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/77/su/bn/77subnsd-yf1s2uvouvsrcgerdi.jpeg"><br><br>  In modern services without a cache, nowhere: data access in a persistent database is a long and expensive business, so adding intermediate storage for the most frequently used data speeds it up considerably.  Caching information can be very different and in different forms: strings, and lists, and session state, and much more.  In this article we will discuss one of the ways to store in the cache "flat" objects that do not have nested classes and circular references. <br><a name="habracut"></a><br><h3>  Customized flat object serialization </h3><br>  Caches like Redis Cache for Microsoft Azure do not offer built-in serialization of objects, at least as part of the StackExchange.Redis client library.  The cache provides methods that allow you to save an arbitrary sequence of bytes under a given key, and the user remains to choose how to get them from the saved object.  One of the possible options is the standard .Net-ovsky BinaryFormatter, but it is not the only one, and choosing a successful serialization method for a service that stores many objects in the cache can have a positive effect on its performance. <br><br>  The serialization approach described in this article comes from the following assumptions about the system: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  The cache is limited in size and costs more than persistent storage.  In Microsoft Azure, a cache with a large available limit is expected to pay a large amount. </li><li>  A large number of bytes in the serialized view adversely affects the interaction time of the cache, not only because of the cost of writing / reading, but also because of the transmission of data over the network. </li><li>  The composition of the objects being serialized is stable in time and is under the complete control of the owner of the service and the cache.  Unexpected appearance, deletion or reordering of fields does not occur, as can be with serialized data that came from outside. </li><li>  Cache is just a tool for optimization and temporary storage of objects.  If there are discrepancies in the format or problems of deserialization, removing the old object from the cache and replacing it with a new one will not be a big problem. </li></ul><br>  Against this background, an attractive idea seems to be saving a fair amount of bytes due to the exclusion from the serialized view of metadata about fields, classes and assemblies maintained by all regular serializers, including the BinaryFormatter.  In the end, if the owner knows everything about the composition of the fields, what prevents, for example, simply formatting them into lines in a certain order, dividing them with some symbol that is not known to be found in their composition? <br><br><pre><code class="cs hljs"><span class="hljs-string"><span class="hljs-string">"7c9e6679-7425-40de-944b-e07fc1f90ae7|48972|Alice in Wonderland"</span></span></code> </pre> <br>  Although this approach requires some accuracy, you cannot call it disastrous. <br>  If you go further, you can do without a separator, and without formatting into a string: any type is represented in memory as a sequence of bytes, and knowing the type of a particular property, you can simply write and read byte arrays of the required length alternately and convert them from / into the values ‚Äã‚Äãof the desired types.  For types with non-fixed length, such as string or Array, you can precede the serialized value by the number of bytes / elements that it contains.  It is more difficult to deal with properties that have the type of user class or structure, especially if you need to keep track of circular references and in this simplest case they are not considered yet.  (This, however, does not mean that this is unrealizable in principle). <br><br>  When storing a large number of objects in a cache with a large number of fields, writing code to serialize them according to the described principle can be tedious and fraught with errors.  If objects need to be saved entirely, then such an operation can be easily automated by means of the System.Reflection namespace: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject theObject, Stream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _properties) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = property.GetValue(theObject); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)) { stream.WriteByte((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = BitConverter.GetBytes((<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)val); stream.Write(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = BitConverter.GetBytes((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)val); stream.Write(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Guid)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = ((Guid)val).ToByteArray(); stream.Write(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.Length); } ... } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> TObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> theObject = Activator.CreateInstance&lt;TObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _properties) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)) { val = stream.ReadByte(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesCount = TypesInfo.GetBytesCount(type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bytesCount]; stream.Read(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, valueBytes.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)) { val = BitConverter.ToBoolean(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) { val = BitConverter.ToInt32(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Guid)) { val = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Guid(valueBytes); } ... property.SetValue(theObject, val); } }</code> </pre><br><h3>  The composition of the properties of the object and its changes </h3><br>  Although MSDN <a href="https://msdn.microsoft.com/en-us/library/kyaxdd3x(v%3Dvs.110).aspx">does not guarantee that</a> Type.GetProperties () <a href="https://msdn.microsoft.com/en-us/library/kyaxdd3x(v%3Dvs.110).aspx">will</a> return properties in alphabetical or declaration order, there is no reason to believe that the returned array will differ from a call to a call on the same version of the same object type.  For greater reliability, you can call this method once, save the resulting array of properties in a private field and use it further in serialization and deserialization operations.  The cache is usually used by systems that run without stopping for a long time, and a serializer created once with a once initialized list of properties of a serializable type will exist for a long time.  In case if this seems insufficient, it would be possible to additionally implement saving this list to the disk with reinitialization during the service restart, but this seems to be an unnecessary precaution. <br><br>  However, when changing the composition of properties, their name, type or relative position, it is no longer possible to correctly deserialize the old version.  However, since the idea described is intended to store data in a cache, rather than a permanent database, the easiest way to cope with the discrepancy is to disable the old byte representation and replace it with the newly serialized object.  More complex approaches are possible, for example, using a separate AppDomain to load the old type version, deserialize an object, fill it with the properties of a new object, serialize it and save it with the same key;  within the framework of this article, however, no attempts were made to do this. <br><br>  In any case, in order to track changes in the object type, the serialization process should include the possibility of versioning.  For example, before the bytes of the object itself the version of the assembly in which it is declared may be written: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeVersion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TObject).Assembly.GetName().Version.ToString(); }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reflectionSerializer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectionCompactSerializer&lt;Entity&gt;(); typeVersion = reflectionSerializer.GetTypeVersion(); reflectionSerializer.WriteVersion(stream, typeVersion); reflectionSerializer.Serialize(originalEntity, stream); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version = reflectionSerializer.ReadObjectVersion(stream); deserializedEntity = reflectionSerializer.Deserialize(stream);</code> </pre><br>  When serializing a set of different objects, for each of which the GetProperties () method is called only once and the result is stored in memory, it is necessary to somehow match the types of objects with the resulting property lists.  To do this, you can either use the Type ‚Üí PropertyInfo [] dictionary, or select specialized serializers for each serializable type using Generics.  The second approach subjectively looks more convenient: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReflectionCompactSerializer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TObject</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">CompactSerializerBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TObject</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TObject</span></span>: <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">new</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PropertyInfo[] _properties = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TObject).GetProperties(BindingFlags.Instance | BindingFlags.Public); ... }</code> </pre><br><h3>  More productive approach </h3><br>  The next problem that arises when using Reflection in the context of this task is, again, performance: reflection has never been considered a fast mechanism.  In such books on optimizing .Net applications like Sasha Goldshtein, Dima Zurbalev, Ido Flatow <a href="https://www.amazon.com/Pro-NET-Performance-Optimize-Applications-ebook/dp/B009D7630W/ref%3Dmt_kindle%3F_encoding%3DUTF8%26me%3D">‚ÄúPro. Net Performance: Optimize Your C # Applications‚Äù</a> and Ben Watson <a href="https://www.amazon.com/Writing-High-Performance-NET-Code-Watson-ebook/dp/B07BF68842/ref%3Dtmm_kin_swatch_0%3F_encoding%3DUTF8%26qid%3D%26sr%3D">‚ÄúWriting High Performance. NET Code‚Äù</a> as one of the optimization techniques when working with Reflection and creating custom serializers is proposed to generate code, for example using the System.Reflection.Emit namespace tool.  The idea with this approach is to create a code from the resulting property list, that is, a sequence of instructions that will alternately receive the value of each of the properties, write it to the byte stream, read, convert, set the value, and so on. <br><br>  The ILGenerator class from the System.Reflection.Emit namespace contains a number of methods that allow you to create MSIL intermediate language instructions, which can then be compiled at run-time using the DynamicMethod class.  In general terms, it looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> EmitSerializer&lt;TObject&gt; Generate&lt;TObject&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TObject : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">new</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod( <span class="hljs-string"><span class="hljs-string">"WriteProperties"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Stream), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TObject) }, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(EmitSerializer&lt;TObject&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writerIlGenerator = propertiesWriter.GetILGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writerEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CodeEmitter(writerIlGenerator); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod( <span class="hljs-string"><span class="hljs-string">"ReadProperties"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Stream), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TObject) }, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(EmitSerializer&lt;TObject&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readerIlGenerator = propertiesReader.GetILGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readerEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CodeEmitter(readerIlGenerator); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> properties = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TObject) .GetProperties(BindingFlags.Instance | BindingFlags.Public); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> properties) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)) { writerEmitter.EmitWriteBytePropertyCode(property); readerEmitter.EmitReadBytePropertyCode(property); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Guid)) { writerEmitter.EmitWriteGuidPropertyCode(property); readerEmitter.EmitReadGuidPropertyCode(property); } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writePropertiesDelegate = (Action&lt;Stream,TObject&gt;)propertiesWriter .CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Action&lt;Stream, TObject&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readPropertiesDelegate = (Action&lt;Stream, TObject&gt;)propertiesReader .CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Action&lt;Stream, TObject&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmitSerializer&lt;TObject&gt;( writePropertiesDelegate, readPropertiesDelegate); } }</code> </pre><br>  Of course, outside of the ‚Äúcommon features‚Äù, the most complex and interesting part is the implementation of the EmitWriteNNNPropertyCode / EmitReadNNNN PropertyCode methods. <br><br>  MSIL is a ‚Äúhigh-level assembler‚Äù and the code on it is sometimes difficult to read, not just what to write, especially in a mediated way, by calling ILGenerator.Emit (OpCode) methods. <br><br>  Here helps the trick, given in one of the aforementioned books: it is not necessary to write code on IL entirely from scratch.  It is quite possible to create a ‚Äúblank‚Äù in C #, create an assembly with it, disassemble into IL and, looking at the resulting reference implementation, generalize it in accordance with your needs. <br><br>  Disassemblers, which allow to get IL code from .Net assembly, there is a large number of IL-code: ildasm, dotPeek, ILSpy, etc. It happened, however, that this project started under Microsoft OS was already written under Linux (good. NET Core allows), where the choice of disassemblers is not so great.  However, tools are also available for this operating system, in particular <a href="http://www.mono-project.com/docs/tools%2Blibraries/tools/monodis/">monodis</a> .  You can get the text file and IL source code from the dll using monodis with the following command: <br><br><pre> <code class="bash hljs">monodis &lt;  &gt; --output=&lt;   &gt;</code> </pre> <br><h3>  Generic serialization of the simplest types </h3><br>  All actions performed by the generated serializer are similar to the operations of the original Reflection serializer, and repeating them through Emit is easier than it might seem at first glance.  For example, a ‚Äústub‚Äù that gets the value of an int property and writes its bytes to a stream might look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WritePrimitiveTypeProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream, Entity entity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = entity.Index; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = BitConverter.GetBytes(index); stream.Write(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, valueBytes.Length); }</code> </pre><br>  After assembly and decompilation, the corresponding IL code will contain the following instructions: <br><br><pre> <code class="hljs pgsql">.<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> private static hidebysig <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> WritePrimitiveTypeProperty (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [mscorlib]<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.Stream <span class="hljs-string"><span class="hljs-string">'stream'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SourcesForIL.Entity entity) cil managed { // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> begins at RVA <span class="hljs-number"><span class="hljs-number">0x241c</span></span> // Code size <span class="hljs-number"><span class="hljs-number">28</span></span> (<span class="hljs-number"><span class="hljs-number">0x1c</span></span>) .maxstack <span class="hljs-number"><span class="hljs-number">4</span></span> .locals init ( int32 V_0, unsigned <span class="hljs-type"><span class="hljs-type">int8</span></span>[] V_1) IL_0000: nop IL_0001: ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_0002: callvirt instance int32 <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SourcesForIL.Entity::get_Index() IL_0007: stloc<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0008: ldloc<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0009: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> unsigned <span class="hljs-type"><span class="hljs-type">int8</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [mscorlib]<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.BitConverter::GetBytes(int32) IL_000e: stloc<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_000f: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0010: ldloc<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_0011: ldc.i4<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0012: ldloc<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_0013: ldlen IL_0014: conv.i4 IL_0015: callvirt instance <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [mscorlib]<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.Stream::<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(unsigned <span class="hljs-type"><span class="hljs-type">int8</span></span>[], int32, int32) IL_001a: nop IL_001b: ret }</code> </pre><br>  And the code that repeats it using the Reflection.Emit namespace calls the following ILGenerator method sequence: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-comment"><span class="hljs-comment">// load object under serialization onto the evaluation stack _ilGenerator.Emit(OpCodes.Ldarg_1); // get property value _ilGenerator.EmitCall(OpCodes.Callvirt, property.GetMethod, null); // get value's representation in bytes _ilGenerator.EmitCall(OpCodes.Call, BitConverterMethodsInfo.ChooseGetBytesOverloadByType(valueType), null); // save the bytes array from the stack in local variable _ilGenerator.Emit(OpCodes.Stloc, byteArray); // load stream parameter onto the evaluation stack _ilGenerator.Emit(OpCodes.Ldarg_0); // load bytesCount array _ilGenerator.Emit(OpCodes.Ldloc_S, bytesArray); // load offset parameter == 0 onto the stack _ilGenerator.Emit(OpCodes.Ldc_I4_0); // load bytesCount array _ilGenerator.Emit(OpCodes.Ldloc_S, bytesArray); // calculate the array length _ilGenerator.Emit(OpCodes.Ldlen); // convert it to Int32 _ilGenerator.Emit(OpCodes.Conv_I4); // write array to stream _ilGenerator.EmitCall(OpCodes.Callvirt, StreamMethodsInfo.Write, null);</span></span></code> </pre> <br>  It should be noted that the property value is obtained uniformly for all types using property.GetMethod.  In the same way, the conversion of this value into an array of bytes is easily generalized: you just need to use a suitable argument of type MethodInfo.  Thus, the same generator function can create code that serializes properties of different types, depending on the method of receiving an array of bytes transferred to it. <br>  The System.BitConverter class contains several overloaded GetBytes methods for several built-in types, and for all these types, the serialization operation can be performed uniformly by selecting the desired MethodInfo option in BitConverterMethodsInfo.ChooseGetBytesOverloadByType (valueType). <br><br>  Obtaining the MedodInfo object for the corresponding methods has to be done again via Reflection, and for faster access to them, it makes sense to save them in a static dictionary: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MethodInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChooseGetBytesOverloadByType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_getBytesMethods.ContainsKey(type)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _getBytesMethods[type]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(BitConverter).GetMethod(<span class="hljs-string"><span class="hljs-string">"GetBytes"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { type }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"No overload for parameter of type "</span></span> + type.Name); } _getBytesMethods[type] = method; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method; }</code> </pre> <br>  The above code allows you to generate code for several system types: bool, short, int, long, ushort, uint, ulong, double, float, char. <br><br><h3>  Decimal, guid and byte serialization </h3><br>  From the list of primitive types, the decimal type is knocked out, for which System.BitConverter does not have a built-in method for obtaining an array of bytes.  Therefore, the transformation methods must be implemented independently: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDecimalBytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bits = <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>.GetBits((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bitsPart <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bits) { bytes.AddRange(BitConverter.GetBytes(bitsPart)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes.ToArray(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BytesToDecimal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = bytes.Skip(startIndex).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueBytes.Length != <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"A decimal must be created from exactly 16 bytes"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Int32[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bitsPart = <span class="hljs-number"><span class="hljs-number">0</span></span>; bitsPart &lt;= <span class="hljs-number"><span class="hljs-number">15</span></span>; bitsPart += <span class="hljs-number"><span class="hljs-number">4</span></span>) { bits[bitsPart/<span class="hljs-number"><span class="hljs-number">4</span></span>] = BitConverter.ToInt32(valueBytes, bitsPart); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>(bits); }</code> </pre> <br>  For the Guid type, the overload of the BitConverter.GetBytes method is also absent, but getting its byte representation is trivial - using the Guid.ToByteArray method.  To restore the value from the byte array, Guid has a constructor. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteGuidProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream, Entity entity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = entity.Id; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = id.ToByteArray(); stream.Write(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, valueBytes.Length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadGuidProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream, Entity entity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; stream.Read(valueBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, valueBytes.Length); entity.Id = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Guid(valueBytes); }</code> </pre> <br>  With byte, things are quite simple: the Stream class has special methods for writing and reading a single byte. <br><br><h3>  Serialization of date and time </h3><br>  The situation with the DateTime and DateTimeOffset types is a bit more complicated, since they are determined not only by the time value, but also by the Kind and Offset fields, respectively;  these fields must be recorded / counted along with the time itself.  Generating an IL code that saves the value of a DateTimeOffset variable, for example, looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitWriteDateTimeOffsetVariable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LocalBuilder dateTimeOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offset = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TimeSpan)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTimeTicks = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTimeTicksByteArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offsetTicksByteArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-comment"><span class="hljs-comment">// load the variable address to the stack _ilGenerator.Emit(OpCodes.Ldloca_S, dateTimeOffset); // call method to get Offset property _ilGenerator.EmitCall(OpCodes.Call, DateTimeOffsetMembersInfo.OffsetProperty, null); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, offset); // load the variable address to the stack _ilGenerator.Emit(OpCodes.Ldloca_S, offset); // call method to get offset Ticks property _ilGenerator.EmitCall(OpCodes.Call, TimeSpanMembersInfo.TicksProperty, null); // convert it to byte array _ilGenerator.EmitCall(OpCodes.Call, GetInt64BytesMethodInfo, null); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, offsetTicksByteArray); EmitWriteBytesArrayToStream(offsetTicksByteArray); // load the dateTimeOffset variable address to the stack _ilGenerator.Emit(OpCodes.Ldloca_S, dateTimeOffset); // call method to get Ticks property _ilGenerator.EmitCall(OpCodes.Call, DateTimeOffsetMembersInfo.TicksProperty, null); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, dateTimeTicks); // load the variable address to the stack _ilGenerator.Emit(OpCodes.Ldloc, dateTimeTicks); // convert it to byte array _ilGenerator.EmitCall(OpCodes.Call, GetInt64BytesMethodInfo, null); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, dateTimeTicksByteArray); EmitWriteBytesArrayToStream(dateTimeTicksByteArray); }</span></span></code> </pre> <br><h3>  Determining the type length in bytes </h3><br>  Deserialization of all the above types is symmetrical, but to read the corresponding byte array, you need to know its length.  At run time, the property type is available as a value of the Type class, and the sizeof operation cannot be applied to it.  The Marshal.SizeOf method comes to the rescue, which, however, does not apply to all types, and certainly does not return the number of bytes written by custom save implementations.  For them, however, you can simply explicitly return the size: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBytesCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type propertyType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DateTime)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DateTimeOffset)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(propertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Marshal.SizeOf(propertyType); } }</code> </pre> <br><h3>  Nullable &lt;T&gt; Serialization </h3><br>  When serializing Nullable &lt;&gt;, it is logical to first write a flag that determines whether the property contains null, and only if the value is not empty, write the value itself, using already implemented methods. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitWriteNullablePropertyCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PropertyInfo property</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nullableValue = _ilGenerator.DeclareLocal(property.PropertyType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNull = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNullByte = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> underlyingType = property.PropertyType.GetGenericArguments().Single(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = _ilGenerator.DeclareLocal(underlyingType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBytes = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nullableInfo = NullableInfo.GetNullableInfo(underlyingType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nullFlagBranch = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteFlagLabel = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noValueLabel = _ilGenerator.DefineLabel(); EmitLoadPropertyValueToStack(property); <span class="hljs-comment"><span class="hljs-comment">// save nullable value to local variable _ilGenerator.Emit(OpCodes.Stloc, nullableValue); // load address of the variable to stack _ilGenerator.Emit(OpCodes.Ldloca_S, nullableValue); // get HasValue property _ilGenerator.EmitCall(OpCodes.Call, nullableInfo.HasValueProperty, null); // load value '0' to stack _ilGenerator.Emit(OpCodes.Ldc_I4_0); // compare _ilGenerator.Emit(OpCodes.Ceq); // save to local boolean variable _ilGenerator.Emit(OpCodes.Stloc, isNull); // load to stack _ilGenerator.Emit(OpCodes.Ldloc, isNull); // jump to isNull branch, if needed _ilGenerator.Emit(OpCodes.Brtrue_S, nullFlagBranch); // load value '0' to stack _ilGenerator.Emit(OpCodes.Ldc_I4_0); // jump to byteFlagLabel _ilGenerator.Emit(OpCodes.Br_S, byteFlagLabel); _ilGenerator.MarkLabel(nullFlagBranch); // load value '1' to stack _ilGenerator.Emit(OpCodes.Ldc_I4_1); _ilGenerator.MarkLabel(byteFlagLabel); // convert to byte _ilGenerator.Emit(OpCodes.Conv_U1); // save to local variable _ilGenerator.Emit(OpCodes.Stloc, isNullByte); // load stream parameter to stack _ilGenerator.Emit(OpCodes.Ldarg_0); // load byte flag to the stack _ilGenerator.Emit(OpCodes.Ldloc, isNullByte); // write it to the stream _ilGenerator.EmitCall(OpCodes.Callvirt, StreamMethodsInfo.WriteByte, null); // load isNull flag to stack _ilGenerator.Emit(OpCodes.Ldloc, isNull); // load value '0' _ilGenerator.Emit(OpCodes.Ldc_I4_0); // compare _ilGenerator.Emit(OpCodes.Ceq); // jump to tne end, if no value presented _ilGenerator.Emit(OpCodes.Brfalse_S, noValueLabel); // load the address of the nullable to the stack _ilGenerator.Emit(OpCodes.Ldloca_S, nullableValue); // get actual value _ilGenerator.EmitCall(OpCodes.Call, nullableInfo.ValueProperty, null); EmitWriteValueFromStackToStream(underlyingType); _ilGenerator.MarkLabel(noValueLabel); }</span></span></code> </pre> <br><h3>  String type processing </h3><br>  Values ‚Äã‚Äãof type string do not have a fixed size and the number of bytes stored in them is not known in advance.  However, the length of a particular string can be saved to the stream before writing the bytes that constitute it.  When deserializing, you can first read an array of bytes containing an int with a string length, get a value of this length, and then read the corresponding byte number.  In the case of a null string, you can write the value ‚Äú-1‚Äù to be able to distinguish it from an empty string of length 0 <br><br>  Converting a string to a byte array / from it is easily done using the methods of Encoding.GetBytes / Encoding.GetString.  For a change, here is a method for reading a string from a stream, not a record: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitReadStringFromStreamToStack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesCoutArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringBytesCount = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringBytesArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNull = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotNullBranch = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endOfReadLabel = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyBytesCount = TypesInfo.GetBytesCount(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// push the amout of bytes to read onto the stack _ilGenerator.Emit(OpCodes.Ldc_I4, propertyBytesCount); // allocate array to store bytes _ilGenerator.Emit(OpCodes.Newarr, typeof(byte)); // stores the allocated array in the local variable _ilGenerator.Emit(OpCodes.Stloc, bytesCoutArray); // push the stream parameter _ilGenerator.Emit(OpCodes.Ldarg_0); // push the byte count array _ilGenerator.Emit(OpCodes.Ldloc, bytesCoutArray); // push '0' as the offset parameter _ilGenerator.Emit(OpCodes.Ldc_I4_0); // push the byte array again - to calculate its length _ilGenerator.Emit(OpCodes.Ldloc, bytesCoutArray); // get the length _ilGenerator.Emit(OpCodes.Ldlen); // convert the result to Int32 _ilGenerator.Emit(OpCodes.Conv_I4); // call the stream.Read method _ilGenerator.EmitCall(OpCodes.Callvirt, StreamMethodsInfo.Read, null); // pop amount of bytes read _ilGenerator.Emit(OpCodes.Pop); // push the bytes count array _ilGenerator.Emit(OpCodes.Ldloc, bytesCoutArray); // push '0' as the start index parameter _ilGenerator.Emit(OpCodes.Ldc_I4_0); // convert the bytes to Int32 _ilGenerator.EmitCall(OpCodes.Call, BytesToInt32MethodInfo, null); // save bytes count to local variable _ilGenerator.Emit(OpCodes.Stloc, stringBytesCount); // load it to the stack _ilGenerator.Emit(OpCodes.Ldloc, stringBytesCount); // put value '-1' to the stack _ilGenerator.Emit(OpCodes.Ldc_I4_M1); // compare bytes count and -1 _ilGenerator.Emit(OpCodes.Ceq); // save to boolean variable _ilGenerator.Emit(OpCodes.Stloc, isNull); // load to stack _ilGenerator.Emit(OpCodes.Ldloc, isNull); // if false, jump to isNotNullBranch _ilGenerator.Emit(OpCodes.Brfalse_S, isNotNullBranch); // push 'null' value _ilGenerator.Emit(OpCodes.Ldnull); // jump to the end of read fragment _ilGenerator.Emit(OpCodes.Br_S, endOfReadLabel); // not null string value branch _ilGenerator.MarkLabel(isNotNullBranch); // load bytes count to the stack _ilGenerator.Emit(OpCodes.Ldloc, stringBytesCount); // allocate array to store bytes _ilGenerator.Emit(OpCodes.Newarr, typeof(byte)); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, stringBytesArray); // push the stream parameter _ilGenerator.Emit(OpCodes.Ldarg_0); // load string bytes array to stack _ilGenerator.Emit(OpCodes.Ldloc, stringBytesArray); // push '0' as the start index parameter _ilGenerator.Emit(OpCodes.Ldc_I4_0); // load string bytes array to stack to get array length _ilGenerator.Emit(OpCodes.Ldloc, stringBytesArray); // get the length _ilGenerator.Emit(OpCodes.Ldlen); // convert the result to Int32 _ilGenerator.Emit(OpCodes.Conv_I4); // call the stream.Read method _ilGenerator.EmitCall(OpCodes.Callvirt, StreamMethodsInfo.Read, null); // pop amount of bytes read _ilGenerator.Emit(OpCodes.Pop); // load Encoding to stack _ilGenerator.EmitCall(OpCodes.Call, EncodingMembersInfo.EncodingGetter, null); // load string bytes _ilGenerator.Emit(OpCodes.Ldloc, stringBytesArray); // call Encoding.GetString() method _ilGenerator.EmitCall(OpCodes.Callvirt, EncodingMembersInfo.GetStringMethod, null); _ilGenerator.MarkLabel(endOfReadLabel); }</span></span></code> </pre> <br><h3>      </h3><br> ,         :   ()  ,        ,   ()  ,          . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitReadArrayPropertyCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PropertyInfo property</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementType = property.PropertyType.GetElementType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementBytesArray = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lengthBytes = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[])); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayLength = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = _ilGenerator.DeclareLocal(property.PropertyType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = _ilGenerator.DeclareLocal(elementType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = _ilGenerator.DeclareLocal(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNullArrayLabel = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> setPropertyLabel = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loopConditionLabel = _ilGenerator.DefineLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loopIterationLabel = _ilGenerator.DefineLabel(); <span class="hljs-comment"><span class="hljs-comment">// push deserialized object to stack _ilGenerator.Emit(OpCodes.Ldarg_1); EmitAllocateBytesArrayForType(typeof(int), lengthBytes); EmitReadByteArrayFromStream(lengthBytes); EmitConvertBytesArrayToPrimitiveValueOnStack(lengthBytes, typeof(int)); // save it to local variable _ilGenerator.Emit(OpCodes.Stloc, arrayLength); EmitJumpIfNoElements(arrayLength, isNullArrayLabel); // push array length to stack _ilGenerator.Emit(OpCodes.Ldloc, arrayLength); // create new array _ilGenerator.Emit(OpCodes.Newarr, elementType); // save it to the local variable _ilGenerator.Emit(OpCodes.Stloc, array); EmitZeroIndex(index); if (elementType != typeof(string)) { EmitAllocateBytesArrayForType(elementType, elementBytesArray); } // jump to the loop condition check _ilGenerator.Emit(OpCodes.Br_S, loopConditionLabel); _ilGenerator.MarkLabel(loopIterationLabel); if (elementType == typeof(string)) { EmitReadStringFromStreamToStack(); } else { EmitReadValueFromStreamToStack(elementType, elementBytesArray); } // save to local variable _ilGenerator.Emit(OpCodes.Stloc, element); // load array instance to stack _ilGenerator.Emit(OpCodes.Ldloc, array); // load element index _ilGenerator.Emit(OpCodes.Ldloc_S, index); // load the element to stack _ilGenerator.Emit(OpCodes.Ldloc_S, element); // set element to the array _ilGenerator.Emit(OpCodes.Stelem, elementType); EmitIndexIncrement(index); _ilGenerator.MarkLabel(loopConditionLabel); EmitIndexIsLessCheck(index, arrayLength); // jump to the iteration if true _ilGenerator.Emit(OpCodes.Brtrue_S, loopIterationLabel); // push filled array to stack _ilGenerator.Emit(OpCodes.Ldloc, array); // jump to SetProperty label _ilGenerator.Emit(OpCodes.Br_S, setPropertyLabel); _ilGenerator.MarkLabel(isNullArrayLabel); _ilGenerator.Emit(OpCodes.Ldnull); _ilGenerator.MarkLabel(setPropertyLabel); // call object's property setter _ilGenerator.EmitCall(OpCodes.Callvirt, property.SetMethod, null); }</span></span></code> </pre> <br>  ,      Generic-.     List&lt;&gt;,    ,    -,     : <br><br><ul><li>     ; </li><li>   ICollection&lt;T&gt;; </li><li> T   ,  ; </li></ul><br>         ,        Add, Count, GetEnumerator,     ICollection&lt;&gt;,       MoveNext  Current   Enumerator-a. <br><br><h3> , ,  </h3><br>            .       BinaryFormatter  Newtonsoft JsonSerializer,       . Xml-  ,      ¬´¬ª.      1000   /,       .        ,    ,    : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> originalEntity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity { Name = <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, ShortName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty, Description = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, Label = <span class="hljs-string"><span class="hljs-string">'L'</span></span>, Age = <span class="hljs-number"><span class="hljs-number">32</span></span>, Index = <span class="hljs-number"><span class="hljs-number">-7</span></span>, IsVisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Price = <span class="hljs-number"><span class="hljs-number">225.87</span></span>M, Rating = <span class="hljs-number"><span class="hljs-number">4.8</span></span>, Weigth = <span class="hljs-number"><span class="hljs-number">130</span></span>, ShortIndex = <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue, LongIndex = <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.MinValue, UnsignedIndex = <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>.MaxValue, ShortUnsignedIndex = <span class="hljs-number"><span class="hljs-number">25</span></span>, LongUnsignedIndex = <span class="hljs-number"><span class="hljs-number">11</span></span>, Id = Guid.NewGuid(), CreatedAt = DateTime.Now, CreatedAtUtc = DateTime.UtcNow, LastAccessed = DateTime.MinValue, ChangedAt = DateTimeOffset.Now, ChangedAtUtc = DateTimeOffset.UtcNow, References = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, Weeks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt;() { <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">61</span></span> }, PricesHistory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>[] { <span class="hljs-number"><span class="hljs-number">225.8</span></span>M, <span class="hljs-number"><span class="hljs-number">226</span></span>M, <span class="hljs-number"><span class="hljs-number">227.87</span></span>M, <span class="hljs-number"><span class="hljs-number">224.87</span></span>M }, BitMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] { <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, ChildrenIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Guid [] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() }, Schedule = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime [] { DateTime.Now.AddDays(<span class="hljs-number"><span class="hljs-number">-1</span></span>), DateTime.Now.AddMonths(<span class="hljs-number"><span class="hljs-number">2</span></span>), DateTime.Now.AddYears(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, Moments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeOffset [] { DateTimeOffset.UtcNow.AddDays(<span class="hljs-number"><span class="hljs-number">-5</span></span>), DateTimeOffset.Now.AddDays(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, Tags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { <span class="hljs-string"><span class="hljs-string">"The quick brown fox jumps over the lazy dog"</span></span>, <span class="hljs-string"><span class="hljs-string">"Reflection.Emit"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty, <span class="hljs-string"><span class="hljs-string">"0"</span></span> }, AlternativeId = Guid.NewGuid() };</code> </pre> <br><br>  ,      ¬´¬ª Reflection-   ,   , , -        . EmitSerializer      (      ). ,    : <br><br><pre> <code class="bash hljs">Serializer | Average elapsed, ms | Size, bytes ------------------------------------------------------------------------------- EmitSerializer | 9.9522 | 477 ------------------------------------------------------------------------------- ReflectionSerializer | 22.9454 | 477 ------------------------------------------------------------------------------- BinaryFormatter | 246.4836 | 1959 ------------------------------------------------------------------------------- Newtonsoft JsonSerializer | 87.1893 | 1156 EmitSerializer compiled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: 104.5019 ms</code> </pre> <br><h3>  Source </h3><br>      <a href="https://github.com/prickly-u/CompactSerializer">Github</a> . <br><br> , ,  as is,     .  ,      ,     ,      ¬´ ¬ª  . <br><br>    .NET Core 2.0,      Linux Ubuntu 16.04 LTS. </div><p>Source: <a href="https://habr.com/ru/post/358872/">https://habr.com/ru/post/358872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358860/index.html">Angular onPush Complete Change Detection Strategy Guide</a></li>
<li><a href="../358862/index.html">Patenting, desktop for programmers, networks in Kubernetes and scooter as a gift</a></li>
<li><a href="../358864/index.html">Intelligence agencies have problems with interception of messages in all instant messengers except ICQ</a></li>
<li><a href="../358866/index.html">And again: do not use public WiFi</a></li>
<li><a href="../358870/index.html">Saga of options</a></li>
<li><a href="../358874/index.html">Magic link or story about how we simplified the life of the user</a></li>
<li><a href="../358878/index.html">PHDays 8 Summary: Games Over</a></li>
<li><a href="../358880/index.html">The Java Language Specification. Chapter 17. Threads and Locks (Translation. Part 1)</a></li>
<li><a href="../358882/index.html">Less management, more success: the ‚Äúinverted‚Äù structure of Supercell</a></li>
<li><a href="../358886/index.html">Spring mitap (and one summer) from Alfa-Bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>