<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a secure browser extension</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In contrast to the common "client-server" architecture, for decentralized applications it is typical: 


- No need to store a database with usernames ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a secure browser extension</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/nt/7v/c8/nt7vc8scuypj0o2ngtj1n6fqjlw.png"></p><br><p>  In contrast to the common "client-server" architecture, for decentralized applications it is typical: </p><br><ul><li>  No need to store a database with usernames and passwords.  Information for access is stored solely with the users themselves, and confirmation of their authenticity occurs at the protocol level. </li><li>  No need to use a server.  Application logic can run in a blockchain network, where it is possible to store the necessary amount of data. </li></ul><br><p>  There are 2 relatively safe storages for user keys - hardware wallets and browser extensions.  Hardware wallets for the most part are as safe as possible, but difficult to use and far from free, but browser extensions are the perfect combination of security and ease of use, and can still be completely free for end users. </p><br><p>  Considering all this, we wanted to make the most secure extension that simplifies the development of decentralized applications by providing a simple API for working with transactions and signatures. <br>  We will tell you about this experience below. </p><br><p>  <strong>The article will be step by step instructions on how to write a browser extension, with code examples and screenshots.</strong>  All code can be found in the <a href="https://github.com/siemarell/extension-demo">repository</a> .  Each commit logically corresponds to the section of this article. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-brauzernyh-rasshireniy">  Brief history of browser extensions </h2><br><p>  Browser extensions have been around for a long time.  In Internet Explorer, they appeared in 1999, in Firefox - in 2004.  However, for a very long time there was no single standard for extensions. </p><br><p>  We can say that it appeared along with extensions in the fourth version of Google Chrome.  Of course, there was no specification at that time, but it was the Chrome API that became its basis: having conquered most of the browser market and having a built-in application store, Chrome actually set the standard for browser extensions. </p><br><p>  Mozilla had its own standard, but, seeing the popularity of extensions for Chrome, the company decided to make a compatible API.  In 2015, on the initiative of Mozilla, the World Wide Web Consortium (W3C) created a special group to work on the specifications of cross-browser extensions. </p><br><p>  The basis was taken already existing API extensions for Chrome.  The work was conducted with the support of Microsoft (Google refused to participate in the development of the standard), and as a result a draft <a href="https://browserext.github.io/browserext/">specification</a> appeared. </p><br><p>  Formally, the specification is supported by Edge, Firefox and Opera (note that Chrome is missing from this list).  But in fact, the standard is largely compatible with Chrome, since it is actually written on the basis of its extensions.  Learn more about the WebExtensions API <a href="https://wiki.mozilla.org/WebExtensions/FAQ">here</a> . </p><br><h2 id="struktura-rasshireniya">  Expansion structure </h2><br><p>  The only file that is necessary for the extension is the manifest (manifest.json).  It is also the ‚Äúentry point‚Äù to the extension. </p><br><h3 id="manifest">  Manifesto </h3><br><p>  According to the specification, the manifest file is a valid JSON file.  A full description of the manifest keys with information about which keys are supported in which browser can be found <a href="">here</a> . </p><br><p>  Keys that are not in the specification can ‚Äúbe‚Äù ignored (both Chrome and Firefox write errors, but the extensions continue to work). </p><br><p>  And I would like to draw attention to some points. </p><br><ol><li>  <strong>background</strong> - an object that includes the following fields: <br><ol><li>  <strong>scripts</strong> - an array of scripts that will be executed in a background context (let's talk about this a bit later); </li><li>  <strong>page</strong> - instead of scripts that will be executed in a blank page, you can specify html with content.  In this case, the script field will be ignored, and the scripts will need to be inserted into the content page; </li><li>  <strong>persistent</strong> - a binary flag, if not specified, the browser will "kill" the background-process when it considers that it does nothing, and restart if necessary.  Otherwise, the page will be unloaded only when the browser is closed.  Not supported in Firefox. </li></ol></li><li>  <strong>content_scripts</strong> - an array of objects that allows you to upload different scripts to different web pages.  Each object contains the following important fields: <br><ol><li>  <strong>matches</strong> - the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_scripts">url pattern</a> by which it is determined whether a specific content script will be included or not. </li><li>  <strong>js</strong> - list of scripts to be loaded into this match; </li><li> <strong>exclude_matches</strong> - excludes from the <code>match</code> field URLs that match this field. </li></ol></li><li>  <strong>page_action</strong> is actually an object that is responsible for the icon that is displayed next to the address bar in the browser, and interaction with it.  Allows you to also show the popup window, which is set using your HTML, CSS and JS. <br><ol><li>  <strong>default_popup</strong> - the path to the HTML file with a popup interface, may contain CSS and JS. </li></ol></li><li>  <strong>permissions</strong> is an array for managing extension rights.  There are 3 types of rights, which are described in detail <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/permissions">here.</a> </li><li>  <strong>web_accessible_resources</strong> - extension resources that a web page can request, for example, images, JS, CSS, HTML files. </li><li>  <strong>externally_connectable</strong> - here you can explicitly specify the ID of other extensions and domains of web pages from which you can connect.  Domain can be of the second level and higher.  It does not work in Firefox. </li></ol><br><h2 id="kontekst-vypolneniya">  Execution context </h2><br><p>  The extension has three contexts of code execution, that is, the application consists of three parts with different levels of access to the browser's API. </p><br><h3 id="extension-context">  Extension context </h3><br><p>  Most of the API is available here.  In this context, "live": </p><br><ol><li>  <strong>The background page</strong> is the ‚Äúbackend‚Äù part of the extension.  The file is indicated in the manifest by the key ‚Äúbackground‚Äù. </li><li>  <strong>Popup page</strong> - a popup page that appears when you click on the extension icon.  In the <code>browser_action</code> manifest -&gt; <code>default_popup</code> . </li><li>  <strong>Custom page</strong> - the extension page, "living" in a separate tab of the form <code>chrome-extension://&lt;id_&gt;/customPage.html</code> . </li></ol><br><p>  This context exists independently of browser windows and tabs.  <strong>The</strong> background <strong>page</strong> exists in a single copy and always works (the exception is the event page, when the background script runs on an event and "dies" after its execution).  A popup <strong>page</strong> exists when the popup window is open, and a <strong>Custom page page</strong> is open with it.  There is no access to other tabs and their contents from this context. </p><br><h3 id="content-script-context">  Content script context </h3><br><p>  The content script file is launched with each browser tab.  It has access to parts of the extension API and to the web page's DOM tree.  Content scripts are responsible for interacting with the page.  Extensions that manipulate the DOM tree do so in content scripts ‚Äî for example, ad blockers or translators.  Also the content script can communicate with the page via standard <code>postMessage</code> . </p><br><h3 id="web-page-context">  Web page context </h3><br><p>  This is the actual webpage itself.  It has nothing to do with the extension and does not have access there, except when the domain of this page is not explicitly indicated in the manifest (see below). </p><br><h2 id="obmen-soobscheniyami">  Message exchange </h2><br><p>  Different parts of the application should exchange messages with each other.  For this, there is an API <code>runtime.sendMessage</code> for sending a message <code>background</code> and <code>tabs.sendMessage</code> for sending a message to a page (content script, popup or web page if <code>externally_connectable</code> ).  Below is an example when accessing the Chrome API. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     JSON   const msg = {a: 'foo', b: 'bar'}; // extensionId   ,      ''  ( ui   ) chrome.runtime.sendMessage(extensionId, msg); //    chrome.runtime.onMessage.addListener((msg) =&gt; console.log(msg)) //       id chrome.tabs.sendMessage(tabId, msg) //      id , ,   chrome.tabs.query( {currentWindow: true, active : true}, function(tabArray){ tabArray.forEach(tab =&gt; console.log(tab.id)) } )</span></span></code> </pre> <br><p>  For full communication, you can create connections via <code>runtime.connect</code> .  In response, we get a <code>runtime.Port</code> , in which, while it is open, you can send any number of messages.  On the client side, for example, <code>contentscript</code> , it looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   extensionId        .    const port = chrome.runtime.connect({name: "knockknock"}); port.postMessage({joke: "Knock knock"}); port.onMessage.addListener(function(msg) { if (msg.question === "Who's there?") port.postMessage({answer: "Madame"}); else if (msg.question === "Madame who?") port.postMessage({answer: "Madame... Bovary"});</span></span></code> </pre><br><p>  Server or background: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    '' .  , popup    chrome.runtime.onConnect.addListener(function(port) { console.assert(port.name === "knockknock"); port.onMessage.addListener(function(msg) { if (msg.joke === "Knock knock") port.postMessage({question: "Who's there?"}); else if (msg.answer === "Madame") port.postMessage({question: "Madame who?"}); else if (msg.answer === "Madame... Bovary") port.postMessage({question: "I don't get it."}); }); }); //     .     ,      chrome.runtime.onConnectExternal.addListener(function(port) { ... });</span></span></code> </pre> <br><p>  There is also an <code>onDisconnect</code> event and a <code>disconnect</code> method. </p><br><h2 id="shema-prilozheniya">  Application schema </h2><br><p>  Let's make a browser extension that stores private keys, provides access to public information (address, public key communicates with the page and allows third-party applications to request transaction signatures. </p><br><h2 id="razrabotka-prilozheniya">  Application development </h2><br><p>  Our application must both interact with the user and provide an API page for calling methods (for example, for signing transactions).  It will not be possible to do only <code>contentscript</code> , since it has access only to the DOM, but not to the JS page.  We cannot connect via <code>runtime.connect</code> , because the API is needed on all domains, and only specific ones can be specified in the manifest.  As a result, the scheme will look like this: </p><br><p><img src="https://habrastorage.org/webt/fa/b3/gx/fab3gxq823kwybj9yk_kv8wlogy.png"></p><br><p>  There will be another script - <code>inpage</code> , which we will inject into the page.  It will run in its context and provide an API for working with the extension. </p><br><h3 id="nachalo">  Start </h3><br><p>  All browser extension code is available on <a href="https://github.com/siemarell/extension-demo/tree/transactions">GitHub</a> .  During the description there will be links to commits. </p><br><p>  Let's start with the manifest: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//   , .        chrome://extensions/?id=&lt;id &gt; "name": "Signer", "description": "Extension demo", "version": "0.0.1", "manifest_version": 2, // ,     background,     "background": { "scripts": ["background.js"] }, //  html   popup "browser_action": { "default_title": "My Extension", "default_popup": "popup.html" }, //  . //    :   url   http  https   // contenscript context   contentscript.js.         "content_scripts": [ { "matches": [ "http://*/*", "https://*/*" ], "js": [ "contentscript.js" ], "run_at": "document_start", "all_frames": true } ], //    localStorage  idle api "permissions": [ "storage", // "unlimitedStorage", //"clipboardWrite", "idle" //"activeTab", //"webRequest", //"notifications", //"tabs" ], //   ,       .      fetche'   xhr "web_accessible_resources": ["inpage.js"] }</span></span></code> </pre> <br><p>  Create empty background.js, popup.js, inpage.js and contentscript.js.  Add popup.html - and our application can already be downloaded to Google Chrome and make sure that it works. </p><br><p>  To verify this, you can get the code <a href="https://github.com/siemarell/extension-demo/tree/manifest-app-template">from here</a> .  In addition to what we did, the link is configured to build the project using a webpack.  To add an application to the browser, in chrome: // extensions you need to select load unpacked and a folder with the appropriate extension - in our case dist. </p><br><p><img src="https://habrastorage.org/webt/ws/ng/qz/wsngqza3qdcjtxycbcwk4awpfqm.png"></p><br><p>  Now our extension is installed and working.  You can launch developer tools for different contexts as follows: </p><br><p>  popup -&gt; </p><br><p><img src="https://habrastorage.org/webt/m3/pr/9d/m3pr9dww991nvn9jsfwj8mvndqq.png"></p><br><p>  Access to the content script console is through the console of the page itself, on which it is running. <img src="https://habrastorage.org/webt/3t/gn/6v/3tgn6vao3ilxdwyz9zxraegz9vo.png"></p><br><p>  <strong>Message exchange</strong> </p><br><p>  So, we need to establish two communication channels: inpage &lt;-&gt; background and popup &lt;-&gt; background.  You can, of course, just send messages to the port and invent your own protocol, but I prefer the approach that I spied in the open source metamask project. </p><br><p>  This is a browser extension for working with the Ethereum network.  In it, different parts of the application communicate via RPC using the dnode library.  It allows you to quickly and conveniently organize an exchange if you provide nodejs stream as the transport (meaning an object that implements the same interface): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dnode/browser"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//           ,         // C // API,     const dnode = Dnode({ hello: (cb) =&gt; cb(null, "world") }) // ,     dnode.  nodejs .     'readable-stream' connectionStream.pipe(dnode).pipe(connectionStream) //  const dnodeClient = Dnode() //         API    //    world dnodeClient.once('remote', remote =&gt; { remote.hello(((err, value) =&gt; console.log(value))) })</span></span></code> </pre> <br><p>  Now we will create an application class.  It will create API objects for popup and web pages, and also create dnode for them: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API  ui popupApi(){ return { hello: cb =&gt; cb(null, 'world') } } //   API   pageApi(){ return { hello: cb =&gt; cb(null, 'world') } } //  popup ui connectPopup(connectionStream){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(remote) }) } //   connectPage(connectionStream, origin){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(origin); console.log(remote) }) } }</span></span></code> </pre> <br><p>  Hereinafter, instead of the global Chrome object, we use extentionApi, which accesses Chrome in a browser from Google and browser in others.  This is done for cross-browser compatibility, but within the framework of this article one could use just 'chrome.runtime.connect'. </p><br><p>  Create an application instance in the background script: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-comment"><span class="hljs-comment">// onConnect    '' (contentscript, popup,   ) extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); //      ,          ,   ui if (processName === 'contentscript'){ const origin = remotePort.sender.url app.connectPage(portStream, origin) }else{ app.connectPopup(portStream) } }</span></span></code> </pre> <br><p>  Since dnode works with streams, and we get a port, we need an adapter class.  It is made using the readable-stream library, which implements nodejs streams in the browser: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Duplex} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'readable-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortStream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(port){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port = port; port.onMessage.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); port.onDisconnect.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onDisconnect.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } _onMessage(msg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> msg._isBuffer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(msg) } } _onDisconnect() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.destroy() } _read(){} _write(msg, encoding, cb) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = msg.toJSON(); data._isBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(msg) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'PortStream - disconnected'</span></span>)) } cb() } }</code> </pre> <br><p>  Now we create a connection in the UI: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       ,   stream,  dnode const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); const background = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   API    if (DEV_MODE){ global.background = background; } }</span></span></code> </pre> <br><p>  Then we create a connection in the content script: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundPort = extensionApi.runtime.connect({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(backgroundPort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostMessageStream({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'page'</span></span>, }); pageStream.pipe(backgroundStream).pipe(pageStream); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Since we need the API not in the content script, but directly on the page, we do two things: </p><br><ol><li>  Create two streams.  One - in the side of the page, on top of postMessage.  For this we use <a href="https://www.npmjs.com/package/post-message-stream">this package</a> from the creators of metamask.  The second stream - to the background on top of the port received from <code>runtime.connect</code> .  Paypim them.  Now the page will stream to the background. </li><li>  Inject a script into the DOM.  We extort the script (access to it was allowed in the manifest) and create a <code>script</code> tag with its contents inside: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const backgroundPort = extensionApi.runtime.connect({name: 'contentscript'}); const backgroundStream = new PortStream(backgroundPort); //    const pageStream = new PostMessageStream({ name: 'content', target: 'page', }); pageStream.pipe(backgroundStream).pipe(pageStream); } function injectScript(){ try { // inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Now create an api object in inpage and set it to global: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; setupInpageApi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupInpageApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const connectionStream = new PostMessageStream({ name: 'page', target: 'content', }); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); //   API const pageApi = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   window global.SignerApp = pageApi; }</span></span></code> </pre> <br><p>  We have a <a href="https://github.com/siemarell/extension-demo/tree/dnode-setup-callback">Remote Procedure Call (RPC) with a separate API for the page and UI</a> .  When you connect a new page to the background, we can see it: </p><br><p><img src="https://habrastorage.org/webt/cy/r_/pm/cyr_pmgm-u5hes5lefaf85gk91m.png"></p><br><p>  Empty API and origin.  On the side of the page, we can call the hello function like this: </p><br><p><img src="https://habrastorage.org/webt/3p/fd/tv/3pfdtv17ejnjzh94uajezgz0lce.png"></p><br><p>  Working with callback functions in modern JS is a moveton, so we will write a small helper to create a dnode, which allows you to pass an API to the utils. </p><br><p>  API objects will now look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-string"><span class="hljs-string">"world"</span></span> } } ... }</code> </pre> <br><p>  Getting the object from the remote like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../../src/utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageApi = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dnode.once(<span class="hljs-string"><span class="hljs-string">'remote'</span></span>, remoteApi =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      callback  promise resolve(transformMethods(cbToPromise, remoteApi)) }) });</span></span></code> </pre> <br><p>  And the function call returns a promise: </p><br><p><img src="https://habrastorage.org/webt/g7/qq/og/g7qqogo60hrjqm5pre7f5miehs0.png"></p><br><p>  A version with asynchronous functions is available <a href="https://github.com/siemarell/extension-demo/tree/dnode-setup-async">here</a> . </p><br><p>  In general, the approach with RPC and streams seems to be quite flexible: we can use steam multiplexing and create several different APIs for different tasks.  In principle, dnode can be used anywhere, the main thing is to wrap the transport in the form of nodejs stream. </p><br><p>  An alternative is the JSON format, which implements the JSON RPC 2 protocol. However, it works with specific transports (TCP and HTTP (S)), which is not applicable in our case. </p><br><h3 id="vnutrenniy-steyt-i-localstorage">  Internal state and localStorage </h3><br><p>  We will need to store the internal state of the application - at least the keys for the signature.  We can quite easily add a state to the application and methods to change it in the popup API: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store = { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], }; } addKey(key){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.push(key) } removeKey(index){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.splice(index,<span class="hljs-number"><span class="hljs-number">1</span></span>) } popupApi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index) } } ... }</code> </pre> <br><p>  In the background, let's wrap everything into a function and write the application object to the window so that you can work with it from the console: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } extensionApi.runtime.onConnect.addListener(connectRemote); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectRemote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">remotePort</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processName = remotePort.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> portStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(remotePort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processName === <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> origin = remotePort.sender.url; app.connectPage(portStream, origin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { app.connectPopup(portStream) } } }</code> </pre> <br><p>  Add a few keys from the UI console and see what happened with the state: </p><br><p><img src="https://habrastorage.org/webt/n7/xr/eb/n7xrebxybxbquxx8z8uozgwpfqm.png"></p><br><p>  The state needs to be made persistent, so that when restarting, the keys are not lost. </p><br><p>  We will store in localStorage, overwriting with each change.  Subsequently, access to it will also be necessary for the UI, and I also want to subscribe to changes.  Based on this, it will be convenient to make observable storage and subscribe to its changes. </p><br><p>  We will use the mobx library ( <a href="https://github.com/mobxjs/mobx">https://github.com/mobxjs/mobx</a> ).  The choice fell on her, because she did not have to work with her, but really wanted to study her. </p><br><p>  Add initialization of the initial state and make the store observable: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initState = {}) { <span class="hljs-comment"><span class="hljs-comment">//  store      ,       proxy,      this.store = observable.object({ keys: initState.keys || [], }); } // ,   observable    @action addKey(key) { this.store.keys.push(key) } @action removeKey(index) { this.store.keys.splice(index, 1) } ... }</span></span></code> </pre> <br><p>  "Under the hood" mobx replaced all fields of the store with a proxy and intercepts all calls to them.  You can subscribe to these requests. </p><br><p>  In the following, I will often use the term ‚Äúunder change‚Äù, although this is not entirely correct.  Mobx tracks access to the fields.  The getters and setters of the proxy objects that the library creates are used. </p><br><p>  Action decorators serve two purposes: </p><br><ol><li>  In strict mode with the enforceActions flag, mobx prohibits changing the state directly.  It is considered a good form to work in strict mode. </li><li>  Even if the function changes the state several times - for example, we change several fields in several lines of code, - the observers are notified only after its completion.  This is especially important for the frontend, where unnecessary updates to the state lead to unnecessary rendering of elements.  In our case, neither the first nor the second is particularly relevant, but we will follow the best practices.  Decorators decided to hang on all functions that change the state of the observed fields. </li></ol><br><p>  In the background we add initialization and saving the state in localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . /  / localStorage  JSON    'store' import {loadState, saveState} from "./utils/localStorage"; const DEV_MODE = process.env.NODE_ENV !== 'production'; setupApp(); function setupApp() { const initState = loadState(); const app = new SignerApp(initState); if (DEV_MODE) { global.app = app; } // Setup state persistence //  reaction  ,     .    ,    const localStorageReaction = reaction( () =&gt; toJS(app.store), // -  saveState // ,      ,    ); extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>  The reaction function is interesting here.  She has two arguments: </p><br><ol><li>  Data selector </li><li>  The handler that will be called with this data every time it changes. </li></ol><br><p>  Unlike redux, where we explicitly get the state as an argument, mobx remembers which observable we are accessing inside the selector, and only when they change it calls the handler. </p><br><p>  It is important to understand exactly how mobx decides which observable we subscribe to.  If in the code I wrote a selector like this <code>() =&gt; app.store</code> , then the reaction will never be called, since the storage itself is not observable, only its fields are. </p><br><p>  If I wrote like this <code>() =&gt; app.store.keys</code> , then again nothing would have happened, since when adding / deleting elements of an array, the link to it will not change. </p><br><p>  Mobx performs the function of a selector for the first time and monitors only those observables to which we have accessed.  Made it through proxy getters.      <code>toJS</code> .    ,        .         ‚Äì ,  . </p><br><p>   popup    .         localStorage: </p><br><p><img src="https://habrastorage.org/webt/fr/dh/6t/frdh6tc_bt_v3zywmgjrnptngcw.png"></p><br><p>   background-    . </p><br><p>         <a href="https://github.com/siemarell/extension-demo/tree/app-state"></a> . </p><br><h2 id="bezopasnoe-hranenie-privatnyh-klyuchey">     </h2><br><p>       :    ,   ,        .   localStorage        . </p><br><p>       locked,        .        locked  . </p><br><p> Mobx      ,       .  ‚Äî   computed properties.     view   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .  crypto-js import {encrypt, decrypt} from "./utils/cryptoUtils"; export class SignerApp { constructor(initState = {}) { this.store = observable.object({ //     .   null -  locked password: null, vault: initState.vault, //    .     view  . get locked(){ return this.password == null }, get keys(){ return this.locked ? undefined : SignerApp._decryptVault(this.vault, this.password) }, get initialized(){ return this.vault !== undefined } }) } //      @action initVault(password){ this.store.vault = SignerApp._encryptVault([], password) } @action lock() { this.store.password = null } @action unlock(password) { this._checkPassword(password); this.store.password = password } @action addKey(key) { this._checkLocked(); this.store.vault = SignerApp._encryptVault(this.store.keys.concat(key), this.store.password) } @action removeKey(index) { this._checkLocked(); this.store.vault = SignerApp._encryptVault([ ...this.store.keys.slice(0, index), ...this.store.keys.slice(index + 1) ], this.store.password ) } ... //    api // private _checkPassword(password) { SignerApp._decryptVault(this.store.vault, password); } _checkLocked() { if (this.store.locked){ throw new Error('App is locked') } } //   /  static _encryptVault(obj, pass){ const jsonString = JSON.stringify(obj) return encrypt(jsonString, pass) } static _decryptVault(str, pass){ if (str === undefined){ throw new Error('Vault not initialized') } try { const jsonString = decrypt(str, pass) return JSON.parse(jsonString) }catch (e) { throw new Error('Wrong password') } } }</span></span></code> </pre> <br><p>        .   .    locked        .   API     . </p><br><p>    <a href="https://www.npmjs.com/package/crypto-js">   rypto-js</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoJS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto-js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      .        5000  function strengthenPassword(pass, rounds = 5000) { while (rounds-- &gt; 0){ pass = CryptoJS.SHA256(pass).toString() } return pass } export function encrypt(str, pass){ const strongPass = strengthenPassword(pass); return CryptoJS.AES.encrypt(str, strongPass).toString() } export function decrypt(str, pass){ const strongPass = strengthenPassword(pass) const decrypted = CryptoJS.AES.decrypt(str, strongPass); return decrypted.toString(CryptoJS.enc.Utf8) }</span></span></code> </pre> <br><p>    idle API,       ‚Äî  . , ,   <code>idle</code> , <code>active</code>  <code>locked</code> .  idle   ,  locked ,    .        localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {loadState, saveState} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/localStorage"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IDLE_INTERVAL = <span class="hljs-number"><span class="hljs-number">30</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initState = loadState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(initState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } <span class="hljs-comment"><span class="hljs-comment">//     ,    , reaction   reaction( () =&gt; ({ vault: app.store.vault }), saveState ); //  ,    extensionApi.idle.setDetectionInterval(IDLE_INTERVAL); //             extensionApi.idle.onStateChanged.addListener(state =&gt; { if (['locked', 'idle'].indexOf(state) &gt; -1) { app.lock() } }); // Connect to other contexts extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>      <a href="https://github.com/siemarell/extension-demo/tree/secure-keys"></a> . </p><br><h3 id="tranzakcii">  Transactions </h3><br><p> ,     :      .     WAVES   <a href="https://www.npmjs.com/package/%40waves/waves-transactions">waves-transactions</a> . </p><br><p>       ,   ,  ‚Äî    ,    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... @action newMessage(data, origin) { <span class="hljs-comment"><span class="hljs-comment">//       id, ,    . const message = observable.object({ id: uuid(), // ,  uuid origin, // Origin      data, // status: 'new', //   : new, signed, rejected  failed timestamp: Date.now() }); console.log(`new message: ${JSON.stringify(message, null, 2)}`); this.store.messages.push(message); //     mobx   .        return new Promise((resolve, reject) =&gt; { reaction( () =&gt; message.status, //    (status, reaction) =&gt; { //       reaction,        switch (status) { case 'signed': resolve(message.data); break; case 'rejected': reject(new Error('User rejected message')); break; case 'failed': reject(new Error(message.err.message)); break; default: return } reaction.dispose() } ) }) } @action approve(id, keyIndex = 0) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); try { message.data = signTx(message.data, this.store.keys[keyIndex]); message.status = 'signed' } catch (e) { message.err = { stack: e.stack, message: e.message }; message.status = 'failed' throw e } } @action reject(id) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); message.status = 'rejected' } ... }</span></span></code> </pre> <br><p>         ,  <code>observable</code>    <code>store.messages</code> . </p><br><p>    <code>observable</code> ,  mobx        messages.     ,       ,      . </p><br><p>    ,      .    reaction,    ""   . </p><br><p>   <code>approve</code>  <code>reject</code>  :     ,   ,  . </p><br><p> Approve  reject    API UI, newMessage ‚Äî  API : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index), <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lock(), <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unlock(password), <span class="hljs-attr"><span class="hljs-attr">initVault</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initVault(password), <span class="hljs-attr"><span class="hljs-attr">approve</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id, keyIndex) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.approve(id, keyIndex), <span class="hljs-attr"><span class="hljs-attr">reject</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reject(id) } } pageApi(origin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">signTransaction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (txParams) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMessage(txParams, origin) } } ... }</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/jt/bp/nu/jtbpnu9tbhryijukstktnti3wbu.png"></p><br><p>    ,  <a href="https://github.com/siemarell/extension-demo/tree/transactions">  UI</a> . </p><br><h2 id="ui"> UI </h2><br><p>      .   UI   <code>observable</code>     API ,     .  <code>observable</code>   API,   background: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, setupDnode, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {initApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ui/index"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); //   observable   background'a let backgroundState = observable.object({}); const api = { //  ,    observable updateState: async state =&gt; { Object.assign(backgroundState, state) } }; //  RPC  const dnode = setupDnode(connectionStream, api); const background = await new Promise(resolve =&gt; { dnode.once('remote', remoteApi =&gt; { resolve(transformMethods(cbToPromise, remoteApi)) }) }); //   background observable   background.state = backgroundState; if (DEV_MODE) { global.background = background; } //   await initApp(background) }</span></span></code> </pre><br><p>       .  react-. Background-     props. , ,       store  ,       : </p><br><pre> <code class="plaintext hljs">import {render} from 'react-dom' import App from './App' import React from "react"; //    background     props export async function initApp(background){ render( &lt;App background={background}/&gt;, document.getElementById('app-content') ); }</code> </pre><br><p>   mobx       .     observer   <a href="https://www.npmjs.com/package/mobx-react">mobx-react</a>  ,         observable,    .    mapStateToProps  connect,   redux.    " ": </p><br><pre> <code class="plaintext hljs">import React, {Component, Fragment} from 'react' import {observer} from "mobx-react"; import Init from './components/Initialize' import Keys from './components/Keys' import Sign from './components/Sign' import Unlock from './components/Unlock' @observer //          render,    observable     export default class App extends Component { //              , //   observable   background    ,    render() { const {keys, messages, initialized, locked} = this.props.background.state; const {lock, unlock, addKey, removeKey, initVault, deleteVault, approve, reject} = this.props.background; return &lt;Fragment&gt; {!initialized ? &lt;Init onInit={initVault}/&gt; : locked ? &lt;Unlock onUnlock={unlock}/&gt; : messages.length &gt; 0 ? &lt;Sign keys={keys} message={messages[messages.length - 1]} onApprove={approve} onReject={reject}/&gt; : &lt;Keys keys={keys} onAdd={addKey} onRemove={removeKey}/&gt; } &lt;div&gt; {!locked &amp;&amp; &lt;button onClick={() =&gt; lock()}&gt;Lock App&lt;/button&gt;} {initialized &amp;&amp; &lt;button onClick={() =&gt; deleteVault()}&gt;Delete all keys and init&lt;/button&gt;} &lt;/div&gt; &lt;/Fragment&gt; } }</code> </pre> <br><p>       <a href="https://github.com/siemarell/extension-demo/tree/master/src/ui">  UI</a> . </p><br><p>          UI      UI.     <code>getState</code>  <code>reaction</code> ,  <code>remote.updateState</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// public getState() { return { keys: this.store.keys, messages: this.store.newMessages, initialized: this.store.initialized, locked: this.store.locked } } ... // connectPopup(connectionStream) { const api = this.popupApi(); const dnode = setupDnode(connectionStream, api); dnode.once('remote', (remote) =&gt; { //  reaction   ,          ui  const updateStateReaction = reaction( () =&gt; this.getState(), (state) =&gt; remote.updateState(state), //     . fireImmediatly   reaction    . //  ,    . Delay   debounce {fireImmediately: true, delay: 500} ); //      dnode.once('end', () =&gt; updateStateReaction.dispose()) }) } ... }</span></span></code> </pre> <br><p>    <code>remote</code>  <code>reaction</code>   ,      UI. </p><br><p>   ‚Äî       : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Reaction    . reaction( () =&gt; app.store.newMessages.length &gt; 0 ? app.store.newMessages.length.toString() : '', text =&gt; extensionApi.browserAction.setBadgeText({text}), {fireImmediately: true} ); ... }</span></span></code> </pre> <br><p> ,  . -    : </p><br><p><img src="https://habrastorage.org/webt/yo/cz/9b/yocz9bncoevwxrict_3dl_vphek.png"></p><br><p><img src="https://habrastorage.org/webt/ee/8e/uj/ee8eujkmg5iwgfholkyxneqsim4.png"></p><br><p>     <a href="https://github.com/siemarell/extension-demo/tree/ui"></a> . </p><br><p>  <strong>Conclusion</strong> </p><br><p>      ,     ,      <a href="https://github.com/siemarell/extension-demo">  </a> .         . </p><br><p>        ,      <a href="https://github.com/wavesplatform/WavesKeeper"></a> . </p><br><p> <strong>,      <a href="https://habr.com/ru/users/siemarell/" class="user_link">siemarell</a></strong> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/451796/">https://habr.com/ru/post/451796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451784/index.html">Hybrid drives for Enterprise storage. Experience using Seagate EXOS</a></li>
<li><a href="../451786/index.html">Run instrumental tests in the Firebase Test Lab. Part 1: iOS project</a></li>
<li><a href="../451790/index.html">Danger of in-game data collection</a></li>
<li><a href="../451792/index.html">Four JavaScript sniffer that lurk you in online stores</a></li>
<li><a href="../451794/index.html">Pixel padding in a texture scan</a></li>
<li><a href="../451798/index.html">Migrating data with mongoDB and Spring Boot</a></li>
<li><a href="../4518/index.html">Network insults cost the American $ 11 million</a></li>
<li><a href="../45180/index.html">Habra chat</a></li>
<li><a href="../451800/index.html">We make a simple sonar modem</a></li>
<li><a href="../451802/index.html">.Net Community Raiffeisenbank invites you to meet UPD Broadcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>