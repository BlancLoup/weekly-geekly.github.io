<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your swagger and not regret it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once, my colleague in backlog dropped the task ‚Äúwe want to organize interaction with the internal REST-api so that any change to the contract immediat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your swagger and not regret it</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/494/c96/eed/494c96eed737291975b9312218daa778.png" alt="image"><br><br>  Once, my colleague in backlog dropped the task ‚Äúwe want to organize interaction with the internal REST-api so that any change to the contract immediately leads to a compilation error‚Äù.  What could be easier?  - I thought, however, working with the resulting cactus forced us to do many hours of smoking documentation, descending from the usual overining engineering concepts ‚Äústick more interfaces, add a maximum of indirection, and spice up all this DI‚Äù before moving to .Net Core, manual co-generation of the intermediate assembler and learning the new compiler C #.  Personally, I discovered a lot of interesting things for myself both in runtime and in the structure of the compiler itself.  I think some of the people of Khabrovsk already know, and some will be useful food for thought. <a name="habracut"></a><br><br><h2 id="akt-pervyy-kopipasta">  Act one: copy-paste </h2><br><p> Since this was a common type of task, and my friend was not inclined to think long over what was obvious, the result appeared rather quickly.  The REST service was ours, on WCF, respectively, the general assembly <code>MyProj.Abstracitons</code> was introduced, where the service interfaces were moved.  In it, we needed to write classes that implemented the service interface and were engaged in proxying queries to it and deserializing the result.  The idea was simple: for each service we write to the client that implements the same interface, respectively, as soon as we change any method in the service, we get a compilation error.  And we assume that a person, changing the argument of a function, will ensure that it is serialized correctly.  It looked like this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FooClient</span></span> : <span class="hljs-title"><span class="hljs-title">BaseClient</span></span>&lt;<span class="hljs-title"><span class="hljs-title">IFooService</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Uri _<span class="hljs-function"><span class="hljs-function">baseSubUri </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BaseUri, _baseSubUri, LogManager.GetCurrentClassLogger(</span></span></span><span class="hljs-function">))</span></span> {} [MethodImpl(MethodImplOptions.NoInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;Foo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, DateTime b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetFoo&lt;Foo&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;{ {‚Äúa‚Äù, a}, {‚Äúb‚Äù, b.ToString(SerializationConstant.DateTimeFormat)}}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;{ {‚Äúc‚Äù, c.ToString(SerializationConstant.FloatFormat)}}); } }</code> </pre> <br><p>  Where <code>BaseClient&lt;TService&gt;</code> is such a thin wrapper over <code>HttpClient</code> , which determines which method we are trying to call ( <code>GetFoo</code> in this case), calculates its URL, sends a request, takes the answer, deserializes the result (if necessary) and returns it. </p><br><p>  I.e: </p><br><ul><li>  Inherit <code>BaseClient&lt;TService&gt;</code> </li><li>  We implement all the methods </li><li>  We prescribe dictionaries for all arguments everywhere, trying not to be mistaken </li></ul><br><p>  In principle, it is not difficult, it even worked, but after writing the 20th method for the 30th class, which were absolutely the same type, people constantly forgot to write <code>NoInlining</code> , which is why everything broke <strong><em>(Little quiz # 1: what do you think, why?)</em></strong> , I asked myself the question "is it possible to approach this somehow humanly?"  But, the task was already committed to the master, and from above I was told "go and drank the features, and do not suffer from garbage."  However, I didn‚Äôt like the idea of ‚Äã‚Äãspending 3 hours a day writing any wrappers.  Not to mention a bunch of attributes, the fact that people periodically forgot to synchronize serialization with their changes and all such pain.  Therefore, having survived until the next weekend, and having set himself the goal of somehow improving the situation, he outlined an alternative solution for a couple of days. <br></p><br><h2 id="akt-vtoroy-refleksiya">  Act Two: Reflection </h2><br><p>  The idea here was even simpler: what prevents us from doing everything the same, but not with our hands, but dynamically generated?  We have exactly the same type of tasks: take input arguments, convert them to two dictionaries, one for queryString arguments, the rest as arguments to the request body, and just call some typical <code>HttpClient</code> with these parameters.  As a result, all problems with the same <code>SerializationConstant</code> were solved by the fact that they were written only once in this handler, which allowed them to be implemented correctly once and always rejoice at the correct result.  After not very long smoking documentation and stackoverflow, MVP was ready. </p><br><p>  Now, to use the service, simply: </p><br><ol><li>  We create the interface 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISampleClient</span></span> : <span class="hljs-title"><span class="hljs-title">ISampleService</span></span>, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { }</code> </pre> </li><li>  We write a small wrapper (only for convenience of further use): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ISampleClient </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Uri baseUri, TimeSpan? timeout = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BaseUriClient&lt;ISampleClient&gt;.New(baseUri, Constant.ServiceSampleUri, timeout); }</code> </pre> </li><li><p>  We use: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestHelloAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceManager(); manager.RunAll(BaseAddress); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = SampleClient.New(BaseAddress)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hello = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetHello(); Assert.Equal(hello, <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); } manager.CloseAll(); }</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text"><p>  In this test, of course, the real WCF service rises, which makes a real request, so strictly speaking it is not a unit test.  But we all learn from our mistakes, now I‚Äôm locking dependencies and doing everything differently, but at that time I didn‚Äôt know how to do that. </p></div></div><br><p>  Everything is very simple, of course, does not require special magic, such as the inheritance of special classes or the hanging of attributes.  Variables and method names are displayed automatically.  In general, beauty.  Moreover, paragraph 2 can be omitted, if not too lazy to indicate each time a constant string with the name of the service. </p><br><p>  How does it work?  In fact, enough black magic.  Here is the main piece responsible for generating the proxy methods: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplementMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TypeBuilder tb, MethodInfo interfaceMethod</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wcfOperationDescriptor = ReflectionHelper.GetUriTemplate(interfaceMethod); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters = GetLamdaParameters(interfaceMethod); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newDict = Expression.New(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uriDict = Expression.Variable(newDict.Type); <span class="hljs-comment"><span class="hljs-comment">//    queryString var bodyDict = Expression.Variable(newDict.Type); //       var wcfRequest = Expression.Variable(typeof(IWcfRequest)); var dictionaryAdd = newDict.Type.GetMethod("Add"); var body = new List&lt;Expression&gt;(parameters.Length) //      var dict = new Dictionary&lt;...&gt; { Expression.Assign(uriDict, newDict), Expression.Assign(bodyDict, newDict) }; for (int i = 1; i &lt; parameters.Length; i++) { var dictToAdd = wcfOperationDescriptor.UriTemplate.Contains("{" + parameters[i].Name + "}") ? uriDict : bodyDict; //    ,    uri ,        body.Add(Expression.Call(dictToAdd, dictionaryAdd, Expression.Constant(parameters[i].Name, typeof(string)), Expression.Convert(parameters[i], typeof(object)))); //      } var wcfRequestType = ReflectionHelper.GetPropertyInterfaceImplementation&lt;IWcfRequest&gt;(); //    ,     T,      var wcfProps = wcfRequestType.GetProperties(); var memberInit = Expression.MemberInit(Expression.New(wcfRequestType), Expression.Bind(Array.Find(wcfProps, info =&gt; info.Name == "Descriptor"), GetCreateDesriptorExpression(wcfOperationDescriptor)), Expression.Bind(Array.Find(wcfProps, info =&gt; info.Name == "QueryStringParameters"), Expression.Convert(uriDict, typeof(IReadOnlyDictionary&lt;string, object&gt;))), Expression.Bind(Array.Find(wcfProps, info =&gt; info.Name == "BodyPrameters"), Expression.Convert(bodyDict, typeof(IReadOnlyDictionary&lt;string, object&gt;)))); body.Add(Expression.Assign(wcfRequest, Expression.Convert(memberInit, wcfRequest.Type))); var requestMethod = GetRequestMethod(interfaceMethod); //   (GetResult  Execute),      body.Add(Expression.Call(Expression.Field(parameters[0], "Processor"), requestMethod, wcfRequest)); var bodyExpression = Expression.Lambda ( Expression.Block(new[] { uriDict, bodyDict, wcfRequest }, body.ToArray()), parameters ); var implementation = bodyExpression.CompileToInstanceMethod(tb, interfaceMethod.Name, MethodAttributes.Public | MethodAttributes.Virtual); //      tb.DefineMethodOverride(implementation, interfaceMethod); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Little quiz # 2</b> <div class="spoiler_text"><p>  Note the line with <code>ReflectionHelper.GetPropertyInterfaceImplementation&lt;IWcfRequest&gt;()</code> .  What do you think, why did she need it?  Reflection for the sake of reflection, is it more interesting for a person to write code that generates what he wants, instead of just writing it? </p></div></div><br><p>  The main point here is that we use Expression to generate the method body, in which we put all the arguments either into the body or in the queryString, and then using the CompileToInstanceMethod extension we compile it not into the delegate, but immediately into the class method.  This is not very difficult, although several dozens of iterations were carried out before the working version was obtained, until the correct one was crystallized: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XLambdaExpression</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MethodInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompileToInstanceMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> LambdaExpression expression, TypeBuilder tb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> methodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramTypes = expression.Parameters.Select(x =&gt; x.Type).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxyParamTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[paramTypes.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(paramTypes, <span class="hljs-number"><span class="hljs-number">1</span></span>, proxyParamTypes, <span class="hljs-number"><span class="hljs-number">0</span></span>, proxyParamTypes.Length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxy = tb.DefineMethod(methodName, MethodAttributes.Public | MethodAttributes.Virtual, expression.ReturnType, proxyParamTypes); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = tb.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"&lt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{proxy.Name}</span></span></span><span class="hljs-string">&gt;__Implementation"</span></span>, MethodAttributes.Private | MethodAttributes.Static, proxy.ReturnType, paramTypes); expression.CompileToMethod(method); proxy.GetILGenerator().EmitCallWithParams(method, paramTypes.Length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> proxy; } }</code> </pre> <br><p>  The saddest thing is that this is still a relatively readable option, which I had to give up after moving to Core, because they removed the CompileToMethod apishka.  As a result, you can generate an anonymous delegate, but you cannot generate a class method.  And this is what we needed.  Therefore, in the cow version, all this is replaced by the old one. <del>  kind </del>  ILGenerator.  A typical trick that I do in this case - I just write C # code, parse it with ildasm and see how it works, in what places I need to fix it to cover the general case.  If you try to write IL yourself, then in 99% of cases you can get a <strong><em>Common Language Runtime</em></strong> error <strong><em>detected an invalid program</em></strong> :).  But in this case, the final code is much harder to understand than the relatively readable expressions. </p><br><p>  The question of cutting this apish from the bark is discussed <a href="https://github.com/dotnet/corefx/issues/13050">here</a> (we are interested in the first item on the list), although the requester looks pretty dead.  But not everything is so bad, because an even better solution was found! <br></p><br><h2 id="akt-tretiy-pod-pokrovom-kompilyatora">  Act Three: under the cover of the compiler </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c34/10c/821/c3410c8215f6e184c54b5f0c86225636.png" alt="image"><br><br>  After rewriting and debugging the whole thing for the hundredth time, I wondered why it was impossible to do all this at the compilation stage?  Yes, by caching the generated types, the overhead of using clients is insignificant, we pay only for the <code>Activator.CreateInstance</code> call, which is a trifle in the context of making a whole HTTP request, especially since they can be used as a singleton, since  There is no state except the service URL in it.  But still, we have decent restrictions here: </p><br><ol><li>  We cannot look at the generated code and take care of it.  In principle, this is not necessary, because  it is primitive, but so far I have not written the final working code, I had to guess a lot about why it does not work as intended.  In summary: debugging dynamic builds is still fun </li><li>  The customer must always have the same interface as the customer.  When is it uncomfortable?  Well, for example, when the server has a synchronous apish, but on the client it must be asynchronous, for an HTTP request.  And therefore, either you have to block the stream and wait for a response, or make all server methods asynchronous, force the service to set Task.FromResult anywhere, even if it does not need it. </li><li>  It‚Äôs always nice to get rid of reflection in rantayme </li></ol><br><p>  Just at that time, I heard a lot of interesting things about Roslyn - a new modular compiler from Microsoft, which allows you to dig into the process well.  Initially, I really hoped that in it, as in LLVM, you can simply write middleware for the desired transformation, but after reading the documentation, it seemed that Roslyn cannot do full-fledged code generation without any extra gestures from the user: This is done in <a href="https://github.com/antiufo/roslyn-linq-rewrite">the LINQ replacement project for cycles</a> , but for obvious reasons it is not very convenient), or the analyzer in the style of ‚Äúyou forgot the comma here, let me insert it to you‚Äù.  And then I came across an interesting rekvest feature in the gitkhab language repository on this topic ( <a href="https://github.com/dotnet/csharplang/issues/107">tyts</a> ), but then two problems quickly came to light: first, before the release of this feature, for a very long time, and secondly, I was told quite quickly that working form does not help me.  Although it was not so bad, because in the comments I was given a <a href="https://github.com/AArnott/CodeGeneration.Roslyn">link</a> to an interesting project, which seemed to be doing what I needed. </p><br><p>  Having picked a few days and, having mastered the basic project, I understood that it works!  And it works as it should.  Just some kind of magic.  Unlike writing your own compiler on top of the usual one, here we write the usual nuget package, which we can simply plug into the solution, and it will do its dirty work during the build, in our case, it will generate client code for the service.  Full integration with the studio, do not do anything - lepota.  True, the backlight after the first installation of the solution will not work, but after the rebuild and re-opening of the solution there will be both the backlight and IntelliSense!  True, not everything works: for example, I did not understand how to force the display of extended documentation from an interface with &lt;inheritdoc /&gt;, for some reason the studio does not want to do this.  Well, okay, the main thing is done - the classes are generated, they work, and the result of the generation can always be overlooked and corrected, set by one click through the nuget.  Everything we wanted. </p><br><p>  For a user, the usage looks like this: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/c32/d4e/ef2c32d4eaa36729dba5af1276c0c7f8.gif" alt="image"><br><p><br>  Just write the interface, hang up a couple of attributes, compile, and can use the generated class.  PostSharp is not needed!  (joke). </p><br><p>  So how does it all work? <br></p><br><h2 id="akt-chetvertyy-zaklyuchitelnyy">  Act Four: Final </h2><br><p>  Initially, I was not going to go deep, because  there was already a ready-made library that fully met my requirements, it only remained to write the analyzer and make a package.  However, the reality turned out to be more cruel, and catching mistakes, then due to my improper use of the provided API, then due to errors or flaws in the library itself, the inevitable retribution still caught up with me.  I had to understand and contribute to the result that everything started up as in the picture above. </p><br><p>  Virtually all the salt, in fact, lies in the new .Net Core toolchain: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Sdk</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageType</span></span></span><span class="hljs-tag">&gt;</span></span>DotnetCliTool<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageType</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OutputType</span></span></span><span class="hljs-tag">&gt;</span></span>Exe<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OutputType</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span>netcoreapp1.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AssemblyName</span></span></span><span class="hljs-tag">&gt;</span></span>dotnet-codegen<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AssemblyName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  In essence, this is a way to determine middleware when building a project.  After that, the compiler understands what dotnet-codegen is and can call it.  When building the project, you can see something like this: <br></p><br><img src="https://habrastorage.org/getpro/habr/post_images/b62/b35/5e9/b62b355e968a361ddd93cd752f6f872f.png" alt="image"><br><br>  How it all works when you click build (or even just save the file!): <br><br><br><ol><li>  There is a <code>GenerateCodeFromAttributes</code> from the <code>CodeGeneration.Roslyn.Tasks</code> assembly, which inherits <code>Microsoft.Build.Utilities.ToolTask</code> and determines the launch of all this stuff during the project build.  Actually, we saw the work of this task in the output window a little higher. </li><li>  The text file <code>CodeGeneration.Roslyn.InputAssemblies.txt</code> , where the full path to the assembly that we are currently collecting is written </li><li>  It is called <code>CodeGeneration.Roslyn.Tool</code> , which gets a list of files for analysis, input assemblies, etc.  In general, everything you need to work. </li><li>  Well, then everything is simple, we find all the heirs of the <code>ICodeGenerator</code> interface in the project and call the only <code>GenerateAsync</code> method that generates the code for us. </li><li>  The compiler will automatically pick up the new generated files from the obj-directory and add them to the resulting assembly </li></ol><br><p>  As a result, the current version of this library allows you to hang an attribute on a class, to write literally 100 lines of code, which, on the basis of it, will generate everything you need.  There is a restriction that you cannot generate classes for another assembly, that is, the generated classes are always added to the same assembly that compiles, but in principle you can live with it. <br></p><br><h2 id="akt-dopolnitelnyy-podvedenie-itogov">  Additional act: debriefing </h2><br><p>  When I wrote this library, I expected that it would be useful to someone, but then became somewhat disappointed, because  Swagger performs the same task, but cross-platform, and has a user-friendly interface.  But, nevertheless, in my case, you can simply change the type, save the file and immediately get a compilation error.  That for which everything was started: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab5/a0e/6d7/ab5a0e6d7292a39ce333a4d019103220.gif" alt="image"></p><br><p>  And not least, I got a lot of fun realizing the whole thing, and also, as it seems to me, I‚Äôve gotten better knowledge of the language and the compiler.  Therefore, I decided to write an article: maybe the world doesn‚Äôt need a new swagger, but if you need code generation, T4 you despise or it doesn‚Äôt suit you, and reflection is not our option, then this is a great tool that just does its job, great it integrates into the current pipeline and eventually spreads simply as a nuget-package.  Yes, and the lighting from the studio included!  (but only after the first generation and re-opening of the solution). </p><br><p>  I will say right away that I have not tried this process with non-core projects, with an adult framework, maybe there will be some difficulties.  But given that the packages of this package include <code>portable-net45+win8+wpa81</code> , <code>portable-net4+win8+wpa81</code> and even <code>net20</code> , there should not be any special difficulties.  And even if you don‚Äôt like something, unnecessary dependencies or <a href="https://en.wikipedia.org/wiki/Not_invented_here">NIH</a> there - you can always make your own, more kosher, implementation, the benefit of the code is so much.  Another caveat - debugging, how to debug all this stuff I did not understand, the code was written blindly.  But the author of the native library <code>CodeGeneration.Roslyn</code> definitely has the necessary knowledge, just look at the structure of the project, I just ended up doing without them. </p><br><p>  And now I can say with a clear conscience: I absolutely do not regret that I wrote another swagger. </p><br><p>  References: </p><br><ul><li>  <a href="https://gist.github.com/Pzixel/8ba801f24bd82a793797b59edcc07e98">The base class of the very first version with manual writing classes</a> </li><li>  <a href="https://github.com/Pzixel/RemoteClient">My first version of the generation is based on reflection</a> .  Unfortunately, I deleted the initial non-core version, although the first version of the repository gives an idea of ‚Äã‚Äãwhat it was. </li><li>  <a href="https://github.com/Pzixel/RemoteClient.Roslyn">The current version of code generation on Roslyn</a> .  A very compact project that shows the power of both the approach in general and this particular library in particular: </li><li>  <a href="https://github.com/AArnott/CodeGeneration.Roslyn">Basic code generation project on which everything relies</a> </li></ul><br><p>  All my projects are MIT-licensed, forcite-study-break whatever you want, I have no complaints :) </p><br><p>  Initially, all this was planned as a fully working project, which appeared as a result of real requirements, so this can all be used in production, at least after a minor dopilka. </p><br><p>  Well, the answers to the questions, of course: </p><br><ol><li>  MethodImplOptions.NoInlining is used to determine the name of the method we need to call.  Since  Since most methods are quite simple, many are literally single-line, the compiler likes to inline them.  As you know, the compiler inline methods with a body is less than 32 bytes (there are still a lot of conditions, but we will not focus on this, here they are all executed), so you could see a funny bug that methods with a large number of arguments are successfully called, and with a small - throw an error in runtime, because  we reach the very top of the callstack, not finding the right method: <br><br><pre> <code class="cs hljs"> MethodBase method = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_STACKFRAME_NESTING; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempMethod = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackFrame(i).GetMethod(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TService).IsAssignableFrom(tempMethod.DeclaringType)) { method = tempMethod; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </li><li>  The fact is that when I wrote the method with reflection, I didn‚Äôt really think that we add classes not to the current <code>RemoteClient.Core</code> assembly, but to the dynamically created one.  And this is very important.  As a result, after testing all the functionality and getting confidence that it all works, I saw that my <code>WcfRequest</code> class is public.  ‚ÄúDisorder‚Äù - I thought - ‚ÄúImplementation should be private, and only the interface should be visible‚Äù.  And put the attribute internal.  And it broke.  Well, it's enough just to understand why, we generate <code>A.Dynamicalygenerated.dll</code> , which tries to instantiate the internal class in the parent assembly <code>A.dll</code> and naturally falls with an access error.  Well, and this is not counting the fact that we get an unpleasant cyclical dependence between assemblies.  ,   ¬´-¬ª,       ,     ,      ,         <code>A.dll</code>         . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/342566/">https://habr.com/ru/post/342566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342550/index.html">Planning tasks and constraint programming</a></li>
<li><a href="../342556/index.html">Not a simple coordinate system, but a gold one.</a></li>
<li><a href="../342560/index.html">Telegram conference bot (start)</a></li>
<li><a href="../342562/index.html">Vim as an esoteric text editing language</a></li>
<li><a href="../342564/index.html">CubeDB: minimalistic storage of meters with multidimensional keys</a></li>
<li><a href="../342570/index.html">Rewrite the message database VKontakte from scratch and survive</a></li>
<li><a href="../342572/index.html">Classification of the humanities and techies by comments in VK</a></li>
<li><a href="../342574/index.html">We pick a cryptograph, let's call it - ‚Äúnekema‚Äù</a></li>
<li><a href="../342576/index.html">User survey Habra</a></li>
<li><a href="../342578/index.html">Jest and Puppeteer: automation of testing web interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>