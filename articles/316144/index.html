<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ambient Occlusion Volumes for burnt samovars</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wandering around the Internet in search of a lighting algorithm that would satisfy my needs, I came across a very new algorithm developed by NVIDIA, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ambient Occlusion Volumes for burnt samovars</h1><div class="post__text post__text-html js-mediator-article">  Wandering around the Internet in search of a lighting algorithm that would satisfy my needs, I came across a very new algorithm developed by NVIDIA, whose name is AOV ( <b>Ambient Occlusion Volumes</b> ).  Having at my disposal dark autumn nights and several cups of hot coffee, I decided to study this algorithm, which resulted in this article.  Before I begin, I would like to note my surprise at the fact that this algorithm has an undeservedly low popularity in the game development community, in contrast to the familiar SSAO.  The content of this article will, for the most part, consist of theory. <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  In June 2010, <b>Morgan McGuire</b> , a researcher and developer at NVIDIA, developed a lighting algorithm called <b>Ambient Occlusion Volumes</b> .  In developing this algorithm, M. McGuire, set himself the goal of achieving higher performance and quality lighting.  The performance of the algorithm, according to the developer, is largely independent of the complexity of the models, and the quality of the lighting is not inferior to Ray Tracing. <br><br><h2>  A little bit about Ambient Occlusion </h2><br>  AO ( <b>Ambient Occlusion</b> ) is an approximate to GI ( <b>Global Illumination</b> ) algorithm, designed to shade spaces on which, in fact, rays of light do not fall due to the fact that these spaces are conditionally overlapped by other objects, making it inaccessible for rays of light to fall into this space.  The algorithm itself works by calculating the rays emanating from the point, the shading of which we check, followed by checking for the intersection of the object by the ray.  If the beam passes without obstacles, then this point is illuminated, otherwise - is shaded. <br><div style="text-align:center;"><img src="http://frederikaalund.com/wp-content/uploads/2014/03/Graphics_Alchemy.svg" alt="image"></div><br>  But when calculating this algorithm, there are some difficulties.  After some time, SSAO ( <b>Screen Space Ambient Occlusion</b> ) from Crytek developers came to replace the old algorithm.  The algorithm itself worked according to the principle that a certain sphere is determined and in the range of this sphere, points are randomly selected and then the depths (first recorded in the depth buffer) of these points are checked from that for which we calculate the shading.  If the depth of the latter is greater than the depth of a random point, then it is shaded, otherwise it is lit accordingly.  Several such checks are performed, after which their results are summarized and the shading coefficient is calculated.  It looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="http://frederikaalund.com/wp-content/uploads/2014/03/Graphics_Crytek.svg"></div><br>  Due to its simplicity and, comparatively, a small load, this algorithm has become a favorite among many game developers.  However, he has a lot of flaws.  The main problem of this algorithm is that when checking the depth, the selected point may be outside the object that overlaps the point being checked.  This leads to the fact that the point will be considered illuminated. <br><br>  Further, I would like to consider another important topic before the AOV method will be described. <br><br><h2>  Radiosity </h2><br>  Many of those familiar with the name method would frown upon hearing this method in the context of Ambient Occlsuion.  In fact, these methods are closely related to each other. <br><br>  If you are confident in your knowledge, you have the opportunity to skip this section and proceed to the next.  In the meantime, I would like to briefly go through this topic. <br><br>  The <b>radiosity method</b> , also known as <b>the radiance method</b> , is one of the GI methods that relies on form-factor calculation, which, in turn, describe the exchange of energy between pairs of planes in the environment. <br><br>  In short, form factors are some of the energy that is emitted from one plane and taken in by another.  When calculating the form factor, the distance between the centers of the planes and the angle of rotation relative to each other is taken into account. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0e8/d4b/4de/0e8d4b4de47b4b47870ae0f65d4c0cc5.png"></div><br>  Calculate the form factor in this way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ba5/06e/17f/ba506e17f9a24ad7a3b60787b1e42577.png"></div><br>  where Œ∏i, j is the angle between the normal of the plane and Ri, j ,, dA1,2 is the differential region of the plane, Ri, j is the distance vector between dA1,2.  In this equation, the HID is one if dA1.2 are visible to each other and zero if vice versa. <br><br>  At the height of this method, two approaches were used: <b>Full Matrix Radiosity</b> and <b>Progressive Refinement Radiosity</b> . <br><br><h3>  Full Matrix Radiosity </h3><br>  The essence of this approach is that the environment is discretized in small planes.  For each pair of planes, form factors are calculated.  After that, form factors are used to create a system of equations that establishes a connection between the planes in the environment.  Having solved this system, we get the intensity of the light that the plane emits.  Once having calculated the intensity, the environment can be represented in any position without additional lighting calculations. <br><br>  The intensity of the light that radiates a plane is calculated in this way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/760/d74/cea/760d74cea9fd4802b26e1f062c6fa086.png"></div><br>  where pi is the reflection coefficient of the plane i;  Fij is the form factor from the i plane to the j plane;  Ii is the raidosity of the plane i;  Iei is the radiation intensity of the plane i;  N - the number of planes that are surrounded. <br><br>  This approach was not bad, but did not allow to achieve a detailed and accurate image.  In addition, it became very expensive when a large number of planes were present on the scene. <br>  Later, this method was improved by splitting the planes into patches (fragments), and in turn each patch was broken into elements.  Thus, we received a more detailed image. <br><br>  The form factor from patch to patch is calculated as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/573/85f/40f/57385f40ffc84eadae453136db16cd0b.png"></div><br>  where Ei is the number of elements in the patch, Fej is the form factor from element e to patch j, Ai, e are areas of the patch and element. <br><br><h3>  Progressive Refinement Radiosity </h3><br>  This approach is based on the previous one.  The peculiarity of this approach is that after each iteration there is a recalculation, namely an increment of the radiance value of the plane.  It is calculated as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/14b/3e4/930/14b3e49309824caabcd93d69180c7fba.png"></div><br>  where Ii is the already calculated radiance value. <br><br>  The problem of these approaches is the complexity of calculations, even with simple forms of objects.  To calculate the form factor of the plane, we need to perform two integration, not to mention the extra calculations.  <b>Hemi-Cube Radiosity has</b> come to solve this problem. <br><br><h3>  Hemi-cube radiosity </h3><br>  HC is similar to the <b>Nussalt Analog</b> algorithm.  Its essence was that around the point on the plane is located the so-called projection hemisphere with a unit radius.  Another plane is projected onto this hemisphere and placed on the base of the hemisphere.  Thus, the form factor will be equal to the ratio of the region of the projected plane in the base of the hemisphere to the area of ‚Äã‚Äãthe base of the hemisphere itself.  The HC algorithm in its implementation uses, as you might have guessed, a semi-cube. <br><br>  The sides of a semi <b>-cube</b> are broken down into a set of small discretized planes ( <b>hemi-cube pixels</b> ), each of which has its own pre-calculated form factor.  When the second plane is projected onto a semi-cube, the sum of the form factors of discrete areas on which the projected plane was will be equal to the value of the form factor from a point on the first plane to the second plane. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/709/ba2/989/709ba2989beb467e963fc75a9c947724.png"></div><br>  Unfortunately, this decision had a number of its shortcomings, which became the reason for new research in this direction.  If you begin to describe the shortcomings of this method, then the article will be very long, and we do not need this. <br><br><h2>  Ambient Occlusion Volume </h2><br>  During the development of the radiosity method, <b>Baum DR</b> proposed this method for calculating the form factor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dee/a8b/266/deea8b2663fb4edf91a94e304cc443c1.png"></div><br>  where Gi is the set of faces of the plane, Nj is the normal of the differential plane j, Gg is a value equal to the angle of gamma and the direction obtained by the vector product of Rg and R (g + 1), as shown in the figure below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/971/41b/9a4/97141b9a408443a49b53f4a8ddb54f7f.png"></div><br>  M. McGuire was inspired by this approach and based on the latter came up with an AO algorithm.  He described it this way: <br><br>  Let X be a very small patch of a smooth manifold.  Centroid X will be at the point that is the beginning of the normal n.  The polygon P will be a polygon with vertices {p0, ..., pk ‚àí 1}, which is completely located on the positive part of the plane, provided p * n&gt; 0. Thus, the blocking of light rays created by the polygon P will be equal to the form factor emissivity between P and X. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f0f/561/630/f0f5616306be4ac097517c00d6a7450e.png"></div><br>  where j = (i + 1) mod k. <br><br><h4>  AOV's implementation </h4><br>  In this section, I will try to consider the implementation of this algorithm from the point of view of theory.  To work with this algorithm, we still need the depth and normal buffer.  The following operations will occur in a geometric shader. <br><br>  Consider a convex polygon P with vertices {p0, ..., pk ‚àí 1}, which for any combination of 3 vertices does not create collinearity.  First, we need to calculate the damping function that we need to achieve smoothness when moving from near-to far-field lighting.  It is calculated in this way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7d4/e36/f64/7d4e36f64f214ccdb28a2af3e2abef21.png"></div><br>  where a - 1 for solid planes, m (i &lt;k) are the normals to the faces of the polygon P, mk is the negative normal to the polygon P: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4be/a6d/280/4bea6d28026f4405856a4394ae83afe7.png"></div><br><br>  It looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c04/afe/f4b/c04afef4b66146e7bda404d13aaf2267.png"></div><br>  The next item in our implementation will be the construction of the volume around our landfill. <br>  To do this, we need to calculate the displacement vector, which is needed to offset the vertices of our volume relative to the vertices of the polygon. <br><br>  I would like to add another new term called <b>obscurance</b> .  It is responsible for the attenuation of the effect of overlap with the change of distance. <br><br>  We obtain the displacement vector in the following way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/afe/0d9/98f/afe0d998fe4b4e9baada9957ac550d53.png"></div><br>  where Œ¥ is the obescurance at the maximum distance. <br><br>  For clarity: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/993/51d/431/99351d431cb04cdd968f2d7fe3495ded.png"></div><br>  And our last step will be the product of the damping function (g) and the overlap of the polygon P (AOp (n)).  Also, after all operations should be applied so-called.  blending. <br><br>  After all written here it would be a sin not to attach screenshots that demonstrate the work of the AOV algorithm.  These screenshots were made by NVIDIA, and the demo can be found at the bottom of the article (again from NVIDIA). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/f9a/249/b07f9a2494089e1f0a279a783e39a9b4.jpg" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/b90/347/5d2b9034725c9fecfc66991318d8bbf2.jpg" alt="image"></div><br><br>  For comparison with Ray Tracing: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d57/0bd/78d/d570bd78dd0f3d20001040826791ffac.png" alt="image"></div><br><h2>  Conclusion </h2><br>  We looked at the rather difficult way AO.  Many may remain unhappy, because, most likely, they were eager to see the implementation in the form of code.  Unfortunately, too much information would come out for just one article.  However, those who are eager to implement this method can dig deeper from NVIDIA, which I will attach below. <br><br>  <b>PS</b> I have a strong request to you, dear readers.  If you find that the method I described in some places is incorrect or there are simply errors in terms of language, let me know, I will try to correct all my shortcomings.  If you have a need to see this algorithm in the form of a code, I will try to allocate time and make a demo. <br><br>  ‚Üí <a href="">Demo from NVIDIA</a> <br><br><h2>  Literature </h2><br>  I read a sufficient number of sources, but I focused on these particular folders: <br><br>  - M. McGuire "Ambient Occlusion Volumes" <br>  - ‚ÄúImproving radiosity solutions through formulated factors‚Äù <br><br>  I also want to note that most of the images were taken from the last folder. </div><p>Source: <a href="https://habr.com/ru/post/316144/">https://habr.com/ru/post/316144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316134/index.html">How to make the presentation interactive</a></li>
<li><a href="../316136/index.html">Pro Rendering Optimization - With Optimism</a></li>
<li><a href="../316138/index.html">Call Transfer Using Script in Asterisk</a></li>
<li><a href="../316140/index.html">How to test a legacy without pain and fear</a></li>
<li><a href="../316142/index.html">How we built a cloud backend for a mobile shooter</a></li>
<li><a href="../316146/index.html">FlyElephant celebrates its first year of public access and announces cooperation with HPC-HUB</a></li>
<li><a href="../316148/index.html">Monitoring the status of your resource using Telegram-bot</a></li>
<li><a href="../316150/index.html">7 most unpleasant problems in programming</a></li>
<li><a href="../316152/index.html">Release DataGrip 2016.3</a></li>
<li><a href="../316154/index.html">How to become a product manager. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>