<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From dependent types to homotopic type theory on Scala + Shapeless + ProvingGround</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. I want to share my experience using the ProvingGround library written on Rock using Shapeless . The library has documentation , though not very...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From dependent types to homotopic type theory on Scala + Shapeless + ProvingGround</h1><div class="post__text post__text-html js-mediator-article">  Hello.  I want to share my experience using the <a href="https://github.com/siddhartha-gadgil/ProvingGround">ProvingGround</a> library written on Rock using <a href="https://github.com/milessabin/shapeless">Shapeless</a> .  The library has <a href="http://siddhartha-gadgil.github.io/ProvingGround/">documentation</a> , though not very extensive.  The author of the library is <a href="http://math.iisc.ernet.in/~gadgil/">Siddhartha Hajil</a> from the Indian Institute of Science.  The library is experimental.  Siddhartha himself says that this is not a library yet, but ‚Äúwork in progress‚Äù.  The global goal of the library is to take an article from a living mathematician, parse the text, translate natural language with formulas into formal proofs that the compiler could check.  It is clear that this is still very far away.  So far, the library can work with dependent types and the basics of the homotopy type theory ( <a href="https://homotopytypetheory.org/book/">HoTT</a> ), (semi-) automatically proving theorems. <br><a name="habracut"></a><br>  It all started with the fact that I wanted to record an introductory <a href="https://stepik.org/2294">course</a> on dependent types on the Rock for the Stepic competition.  I did not want to repeat myself; a good <a href="http://compsciclub.ru/courses/idrisprogramming/2017-spring/">course</a> had recently appeared on Idris.  Scala was chosen as one of the most popular functional languages.  Googled by githab according to "Scala", "dependent types", "HoTT" and looked most promisingly ProvingGround.  Immediately a disclaimer - I do not claim that certain languages ‚Äã‚Äãor libraries are most suitable for programming with dependent types, automatic proof of theorems, work with HoTT.  It was possible to take other languages ‚Äã‚Äãor libraries - there would be a different course. <br><br>  As is known, Scala is a language with limited support for dependent types.  Dependent types are implemented in it ( <a href="http://stackoverflow.com/questions/12935731/any-reason-why-scala-does-not-explicitly-support-dependent-types">another</a> point of view is emulated) with the help of <a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">path-dependent types</a> , <a href="http://slick.lightbend.com/talks/scalaio2014/Type-Level_Computations.pdf">type-level</a> values ‚Äã‚Äãand <a href="http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html">implications</a> .  Explain dependent types on bare Rock or Rock plus Shapeless and get bogged down in the technical details of <a href="https://www.youtube.com/watch%3Fv%3DR8GksuRw3VI">the</a> type members <a href="https://www.youtube.com/watch%3Fv%3DR8GksuRw3VI">difference</a> from type parameters, implicates, path-dependent types, <a href="http://gigiigig.github.io/posts/2015/09/13/aux-pattern.html">‚ÄúAux‚Äù patterns</a> , type-level calculations, etc.  didn't really want to.  Therefore, part of the course was on bare Rock, but most of the practice was on ProvingGround. <br><br><h4>  Terms and types </h4><br>  To set variables, terms, types, functions, etc.  ProvingGround provides its <acronym>DSL</acronym> . <br>  So you can declare type <code>A</code> and variable <code>a</code> this type: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> = <span class="hljs-string"><span class="hljs-string">"A"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br>  those.  typical ad looks like <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> _ = <span class="hljs-string"><span class="hljs-string">"  "</span></span> :: _</code> </pre> <br>  The term ‚Äúbeautifully‚Äù can be printed using the <code>.fansi</code> method, its type can be <code>.typ</code> using the <code>.typ</code> : <br><br><pre> <code class="scala hljs">println(a) &gt; a : (<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">U_0</span></span>) println(a.fansi) &gt; a println(a.typ) &gt; <span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">U_0</span></span> println(a.typ.fansi) &gt; <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br>  You can set the variable in more detail: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a : <span class="hljs-type"><span class="hljs-type">Term</span></span> = <span class="hljs-string"><span class="hljs-string">"a"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br>  Here <code>A</code> is the type in the ProvingGround library, i.e.  <acronym>HoTT</acronym> is a type, and <code>Term</code> is a type in Scala. <br><br>  So, if we set a variable, then we write the type after <code>::</code> , and if we already have a term, then we can check its type using <code>!:</code> <br><br><pre> <code class="scala hljs">a !: <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br>  The fact that this line is compiled means that the type is specified correctly. <br><br><h4>  Dependent types </h4><br>  A small reminder of the types.  There are values ‚Äã‚Äãand there are types.  Each value has its type.  <a href="https://en.wikipedia.org/wiki/Dependent_type">A dependent type</a> is a type that is dependent on a value (of another type).  For example, a list of two lines and a list of three lines are values ‚Äã‚Äãof the same type ‚Äî a list of lines.  But if we take the information about the number of elements to the level of type, then we get a dependent type - a vector (it depends on the value - a natural number).  Both the vector of two lines and the vector of three lines are different types.  Other examples of dependent types are a non-zero number, a non-empty list, a pair of numbers where the second number is less than the first, equality type <code>1 =:= 2</code> (which has no values), types <code>1 =:= 1</code> , <code>2 =:= 2</code> (in which by one value), etc. <br><br>  So you can set the dependent type of <code>Ba</code> , which depends on the values ‚Äã‚Äãof type <code>A</code> , and a variable of this type: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Ba</span></span> = <span class="hljs-string"><span class="hljs-string">"B(_ : A)"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-string"><span class="hljs-string">"b"</span></span> :: <span class="hljs-type"><span class="hljs-type">Ba</span></span>(a)</code> </pre> <br><h4>  Functions </h4><br>  Now, about the arrows.  There are 4 main types of arrows for functions:: <code>:-&gt;</code> <code>:~&gt;</code> , <code>-&gt;:</code> <code>~&gt;:</code>  With colons on the left - for lambdas (ie, the functions themselves), with colons on the right - for types of functions.  With hyphens - for ordinary functions, with tildes - for dependent functions (that is, for which not only the value, but also the type of the value depends on the argument).  As an example, the identity function <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id = <span class="hljs-type"><span class="hljs-type">A</span></span> :~&gt; (a :-&gt; a) !: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">A</span></span>)</code> </pre> <br>  Part of type checking is done in runtime, but the Scala compiler also sees some type information: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f : <span class="hljs-type"><span class="hljs-type">FuncLike</span></span>[<span class="hljs-type"><span class="hljs-type">Term</span></span>, <span class="hljs-type"><span class="hljs-type">Term</span></span>] = a :~&gt; b !: a ~&gt;: <span class="hljs-type"><span class="hljs-type">Ba</span></span>(a) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f : <span class="hljs-type"><span class="hljs-type">Term</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Term</span></span> = a :~&gt; b !: a ~&gt;: <span class="hljs-type"><span class="hljs-type">Ba</span></span>(a)</code> </pre> <br>  Here the dependent functional type from the ProvingGround / HoTT compiler Scales sees as an ordinary function in Scala. <br><br><h4>  Inductive types </h4><br>  You can set <a href="https://en.wikipedia.org/wiki/Inductive_type">inductive types</a> .  For example, Boolean type with constructors "true" and "false": <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-string"><span class="hljs-string">"Boolean"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BoolInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"true"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"false"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) =: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tru :: fls :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">BoolInd</span></span>.intros</code> </pre> <br>  that is, a typical inductive type assignment looks like <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> _ = (...) |: (...) |: (...) =: _</code> </pre> <br>  where value constructors of this type are separated by <code>|:</code> <br><br>  Another example is the type of natural numbers with the constructors "zero" and "the next number after the natural <code>n</code> ": <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Nat</span></span> = <span class="hljs-string"><span class="hljs-string">"Nat"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">NatInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"0"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nat</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"succ"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nat</span></span> --&gt;&gt;: <span class="hljs-type"><span class="hljs-type">Nat</span></span>) =: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> zero :: succ :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">NatInd</span></span>.intros <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> one = succ(zero) !: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> two = succ(one) !: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br>  The type of integers with the constructors ‚Äúplus a positive integer <code>n</code> ‚Äù and ‚Äúminus positive integer <code>n</code> minus 1‚Äù uses the already defined type of positive integers: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-string"><span class="hljs-string">"Integer"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">IntInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"pos"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;&gt;: <span class="hljs-type"><span class="hljs-type">Int</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"neg"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;&gt;: <span class="hljs-type"><span class="hljs-type">Int</span></span>) =: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pos :: neg :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">IntInd</span></span>.intros</code> </pre> <br>  The type <code>A</code> value list type has ‚Äúempty list‚Äù and ‚Äúlist with type <code>A</code> head and <code>ListA</code> type <code>ListA</code> ‚Äù <code>ListA</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">ListA</span></span> = <span class="hljs-string"><span class="hljs-string">"List(A)"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">ListAInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"nil"</span></span> ::: <span class="hljs-type"><span class="hljs-type">ListA</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"cons"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: <span class="hljs-type"><span class="hljs-type">ListA</span></span> --&gt;&gt;: <span class="hljs-type"><span class="hljs-type">ListA</span></span>) =: <span class="hljs-type"><span class="hljs-type">ListA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nil :: cons :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">ListAInd</span></span>.intros</code> </pre> <br>  The type of a binary tree (for simplicity, without values ‚Äã‚Äãof some type in nodes) has the constructors ‚Äúleaf‚Äù and ‚Äúfork‚Äù (the second accepts a couple of subtrees): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BTree</span></span> = <span class="hljs-string"><span class="hljs-string">"BTree"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BTreeInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"leaf"</span></span> ::: <span class="hljs-type"><span class="hljs-type">BTree</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"fork"</span></span> ::: <span class="hljs-type"><span class="hljs-type">BTree</span></span> --&gt;&gt;: <span class="hljs-type"><span class="hljs-type">BTree</span></span> --&gt;&gt;: <span class="hljs-type"><span class="hljs-type">BTree</span></span>) =: <span class="hljs-type"><span class="hljs-type">BTree</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> leaf :: fork :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">BTreeInd</span></span>.intros</code> </pre> <br>  Alternatively, the constructor "fork" could take a function that translates a lie into one subtree, the truth into another: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BTree</span></span> = <span class="hljs-string"><span class="hljs-string">"BTree"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BTreeInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"leaf"</span></span> ::: <span class="hljs-type"><span class="hljs-type">BTree</span></span>) |: (<span class="hljs-string"><span class="hljs-string">"fork"</span></span> ::: (<span class="hljs-type"><span class="hljs-type">Bool</span></span> -|&gt;: <span class="hljs-type"><span class="hljs-type">BTree</span></span>) --&gt;&gt;: <span class="hljs-type"><span class="hljs-type">BTree</span></span>) =: <span class="hljs-type"><span class="hljs-type">BTree</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> leaf :: fork :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">BTreeInd</span></span>.intros</code> </pre> <br><h4>  Dependent Inductive Types </h4><br>  If the type is dependent ( <a href="https://ncatlab.org/nlab/show/inductive%2Bfamily">indexed inductive type</a> ), for example, <code>Vec</code> vector or equality type <code>Id</code> , then you should use <code>=::</code> instead of <code>=:</code> arrow with a tilde and refer to the type inside constructors <code>(_ -&gt; _(n))</code> in the returned type, <code>(_ :&gt; _(n))</code> in the received type, not just <code>_(n)</code> .  For example, the type of vector of length <code>n</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">VecA</span></span> = <span class="hljs-string"><span class="hljs-string">"Vec(A)"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n = <span class="hljs-string"><span class="hljs-string">"n"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">VecAInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"nil"</span></span> ::: (<span class="hljs-type"><span class="hljs-type">VecA</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">VecA</span></span>(zero) )) |: {<span class="hljs-string"><span class="hljs-string">"cons"</span></span> ::: n ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">VecA</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">VecA</span></span>(n) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">VecA</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">VecA</span></span>(succ(n)) ))} =:: <span class="hljs-type"><span class="hljs-type">VecA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vnil :: vcons :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">VecAInd</span></span>.intros</code> </pre> <br>  Another useful dependent type allows us to formalize the concept of a natural number that does not exceed another natural number: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Fin</span></span> = <span class="hljs-string"><span class="hljs-string">"Fin"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">FinInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"FZ"</span></span> ::: n ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Fin</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Fin</span></span>(succ(n)) )} |: {<span class="hljs-string"><span class="hljs-string">"FS"</span></span> ::: n ~&gt;&gt;: ((<span class="hljs-type"><span class="hljs-type">Fin</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">Fin</span></span>(n) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Fin</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Fin</span></span>(succ(n)) ))} =:: <span class="hljs-type"><span class="hljs-type">Fin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fz :: fs :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">FinInd</span></span>.intros</code> </pre> <br>  Indeed, there is no way to construct a value of type <code>Fin(zero)</code> .  There is exactly one <code>Fin(one)</code> value: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fz0 = fz(zero) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(one)</code> </pre> <br>  There are exactly two <code>Fin(two)</code> values: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fz1 = fz(one) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(two) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fs1 = fs(one)(fz0) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(two)</code> </pre> <br>  There are exactly three <code>Fin(three)</code> values: <br><br><pre> <code class="scala hljs">fz(two) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(three) fs(two)(fz1) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(three) fs(two)(fs1) !: <span class="hljs-type"><span class="hljs-type">Fin</span></span>(three)</code> </pre> <br>  etc. <br><br><h4>  Inductive type families </h4><br>  A few words about the difference between the family of inductive types (family of inductive types) from the indexed inductive type (indexed inductive type).  For example, <code>List(A)</code> is a family, and <code>Vec(A)(n)</code> is a family with respect to type <code>A</code> , but an indexed type with respect to the natural index <code>n</code> .  An inductive type is a type whose constructors for ‚Äúnext‚Äù values ‚Äã‚Äãcan use ‚Äúprevious‚Äù values ‚Äã‚Äã(as with types <code>Nat</code> , <code>List</code> , etc.).  <code>Vec(A)(n)</code> with fixed <code>A</code> is inductive type, but is not with fixed <code>n</code> .  There are currently no inductive type families in ProvingGround, i.e.  it is impossible, having an inductive definition, for example, of the type <code>List(A)</code> , it is easy to obtain an inductive definition of the types <code>List(B)</code> , <code>List(Nat)</code> , <code>List(Bool)</code> , <code>List(List(A))</code> , etc.  But you can emulate families using indexed types: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span> = <span class="hljs-string"><span class="hljs-string">"List"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">ListInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"nil"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">List</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) )} |: {<span class="hljs-string"><span class="hljs-string">"cons"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">List</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">List</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) ))} =:: <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nil :: cons :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">ListInd</span></span>.intros cons(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)(zero)(cons(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)(one)(cons(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)(two)(nil(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)))) !: <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  0, 1, 2</span></span></code> </pre> <br>  and <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Vec</span></span> = <span class="hljs-string"><span class="hljs-string">"Vec"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">VecInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"nil"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Vec</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>)(zero) )} |: {<span class="hljs-string"><span class="hljs-string">"cons"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: n ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Vec</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>)(n) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Vec</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>)(succ(n)) ))} =:: <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vnil :: vcons :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">VecInd</span></span>.intros vcons(<span class="hljs-type"><span class="hljs-type">Bool</span></span>)(two)(tru)(vcons(<span class="hljs-type"><span class="hljs-type">Bool</span></span>)(one)(fls)(vcons(<span class="hljs-type"><span class="hljs-type">Bool</span></span>)(zero)(tru)(vnil(<span class="hljs-type"><span class="hljs-type">Bool</span></span>)))) !: <span class="hljs-type"><span class="hljs-type">Vec</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>)(succ(two)) <span class="hljs-comment"><span class="hljs-comment">// 3-  tru, fls, tru</span></span></code> </pre> <br>  You can also define a heterogeneous list ( <code>HList</code> ): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">HLst</span></span> = <span class="hljs-string"><span class="hljs-string">"HList"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">HLstInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"nil"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">HLst</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">HLst</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) )} |: {<span class="hljs-string"><span class="hljs-string">"cons"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;&gt;: ((<span class="hljs-type"><span class="hljs-type">HLst</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">HLst</span></span>(<span class="hljs-type"><span class="hljs-type">B</span></span>) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">HLst</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">HLst</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) ))))} =:: <span class="hljs-type"><span class="hljs-type">HLst</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hnil :: hcons :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">HLstInd</span></span>.intros</code> </pre> <br>  We have now implemented our own <code>HList</code> in the ProvingGround library, which is written on top of Shapeless, in which the main building <code>HList</code> is <code>HList</code> . <br><br><h4>  Algebraic data types </h4><br>  In the library, you can emulate generalized algebraic data types ( <a href="https://en.wikibooks.org/wiki/Haskell/GADT">GADT</a> ).  Code that looks like Haskell <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# Language GADTs #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> a where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ELit</span></span></span><span class="hljs-class"> :: a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ESucc</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EIsZero</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EIf</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br>  and on a clean rock <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ELit</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">lit: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ESucc</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">num: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EIsZero</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">num: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Boolean</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EIf</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cond: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params">], thenExpr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">], elseExpr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br>  will be written to ProvingGround as <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> = <span class="hljs-string"><span class="hljs-string">"Expr"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">ExprInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"ELit"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Expr</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) ))} |: {<span class="hljs-string"><span class="hljs-string">"ESucc"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Expr</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>) )} |: {<span class="hljs-string"><span class="hljs-string">"EIsZero"</span></span> ::: <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Expr</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>) )} |: {<span class="hljs-string"><span class="hljs-string">"EIf"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt;&gt;: <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt;&gt;: <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Expr</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) ))} =:: <span class="hljs-type"><span class="hljs-type">Expr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eLit :: eSucc :: eIsZero :: eIf :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">ExprInd</span></span>.intros</code> </pre> <br><h4>  Type Classes </h4><br>  You can also emulate <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a> in the library.  For example, the <a href="https://wiki.haskell.org/Functor">functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> = <span class="hljs-string"><span class="hljs-string">"A"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> = <span class="hljs-string"><span class="hljs-string">"B"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">C</span></span> = <span class="hljs-string"><span class="hljs-string">"C"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Functor</span></span> = <span class="hljs-string"><span class="hljs-string">"Functor"</span></span> :: (<span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">F</span></span> = <span class="hljs-string"><span class="hljs-string">"F(_ : U_0)"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Fmap</span></span> = <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: ((<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt;: (<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">B</span></span>) ))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">FunctorInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"functor"</span></span> ::: <span class="hljs-type"><span class="hljs-type">F</span></span> ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Fmap</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Functor</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Functor</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>) ))} =:: <span class="hljs-type"><span class="hljs-type">Functor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> functor :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">FunctorInd</span></span>.intros</code> </pre> <br>  You can, for example, declare a list as an instance of a functor: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> as = <span class="hljs-string"><span class="hljs-string">"as"</span></span> :: <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> indList_map = <span class="hljs-type"><span class="hljs-type">ListInd</span></span>.induc(<span class="hljs-type"><span class="hljs-type">A</span></span> :~&gt; (as :-&gt; (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: ((<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">B</span></span>) )))) <span class="hljs-comment"><span class="hljs-comment">//  ,        val mapas = "map(as)" :: B ~&gt;: ((A -&gt;: B) -&gt;: List(B)) val f = "f" :: A -&gt;: B val map = indList_map(A :~&gt; (B :~&gt; (f :-&gt; nil(B) )))(A :~&gt; (a :-&gt; (as :-&gt; (mapas :-&gt; (B :~&gt; (f :-&gt; cons(B)(f(a))(mapas(B)(f)) )))))) !: A ~&gt;: (List(A) -&gt;: (B ~&gt;: ((A -&gt;: B) -&gt;: List(B) ))) val listFunctor = functor(List)(A :~&gt; (B :~&gt; (f :-&gt; (as :-&gt; map(A)(as)(B)(f) )))) !: Functor(List)</span></span></code> </pre> <br>  You can add laws to the type class: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fmap = <span class="hljs-string"><span class="hljs-string">"fmap"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: ((<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt;: (<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">B</span></span>) ))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Fmap_id</span></span> = <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: ( fmap(<span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-type"><span class="hljs-type">A</span></span>)(id(<span class="hljs-type"><span class="hljs-type">A</span></span>)) =:= id(<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>)) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = <span class="hljs-string"><span class="hljs-string">"f"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g = <span class="hljs-string"><span class="hljs-string">"g"</span></span> :: <span class="hljs-type"><span class="hljs-type">B</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">C</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> compose = <span class="hljs-type"><span class="hljs-type">A</span></span> :~&gt; (<span class="hljs-type"><span class="hljs-type">B</span></span> :~&gt; (<span class="hljs-type"><span class="hljs-type">C</span></span> :~&gt; (f :-&gt; (g :-&gt; (a :-&gt; g(f(a)) ))))) !: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">C</span></span> ~&gt;: ((<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt;: ((<span class="hljs-type"><span class="hljs-type">B</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">C</span></span>) -&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">C</span></span>))))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Fmap_compose</span></span> = <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">C</span></span> ~&gt;: (f ~&gt;: (g ~&gt;: ( fmap(<span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-type"><span class="hljs-type">C</span></span>)(compose(<span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-type"><span class="hljs-type">B</span></span>)(<span class="hljs-type"><span class="hljs-type">C</span></span>)(f)(g)) =:= compose(<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>))(<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">B</span></span>))(<span class="hljs-type"><span class="hljs-type">F</span></span>(<span class="hljs-type"><span class="hljs-type">C</span></span>))(fmap(<span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-type"><span class="hljs-type">B</span></span>)(f))(fmap(<span class="hljs-type"><span class="hljs-type">B</span></span>)(<span class="hljs-type"><span class="hljs-type">C</span></span>)(g)) ))))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">FunctorInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"functor"</span></span> ::: <span class="hljs-type"><span class="hljs-type">F</span></span> ~&gt;&gt;: (fmap ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Fmap_id</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Fmap_compose</span></span> -&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Functor</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Functor</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>) ))))} =:: <span class="hljs-type"><span class="hljs-type">Functor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> functor :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">FunctorInd</span></span>.intros</code> </pre> <br><h4>  Equality Types </h4><br>  The library already has built-in sigma-type (type of dependent pair), pi-type (type of dependent function, we have already seen it above), type-equality (identity type): <br><br><pre> <code class="scala hljs">mkPair(a, b) !: <span class="hljs-type"><span class="hljs-type">Sgma</span></span>(a !: <span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">Ba</span></span>(a)) one.refl !: (one =:= one) one.refl !: <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>, one, one) two.refl !: (two =:= two) (one =:= two) !: <span class="hljs-type"><span class="hljs-type">Type</span></span></code> </pre> <br>  but you can define your own, for example, type-equality: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Id</span></span> = <span class="hljs-string"><span class="hljs-string">"Id"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">IdInd</span></span> = (<span class="hljs-string"><span class="hljs-string">"refl"</span></span> ::: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;&gt;: a ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">Id</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Id</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>)(a)(a) )) =:: <span class="hljs-type"><span class="hljs-type">Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refl :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">IdInd</span></span>.intros refl(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)(two) !: <span class="hljs-type"><span class="hljs-type">Id</span></span>(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)(two)(two)</code> </pre> <br>  Equality types naturally occur when the <a href="https://en.wikipedia.org/wiki/Curry%25E2%2580%2593Howard_correspondence">Curry-Howard correspondence</a> begins.  On the one hand, <code>A -&gt;: B</code> is a function from <code>A</code> to <code>B</code> , on the other hand, it is a logical formula ‚Äúfrom Statement <code>A</code> follows <code>B</code> ‚Äù.  And, on the one hand, <code>(A -&gt;: B) -&gt;: A -&gt;: B</code> is a type of higher order function that takes as input the function <code>A -&gt;: B</code> and a value of type <code>A</code> and returns this function applied to this value, i.e.  value of type <code>B</code>  On the other hand, this is an inference rule in modus ponens logic - ‚Äúif it is true that <code>A</code> follows from <code>A</code> , and <code>A</code> is true, then <code>B</code> is true‚Äù.  From this point of view, types are statements, and type values ‚Äã‚Äãare proofs of these statements.  And the statement is true if the corresponding type is populated, i.e.  There is a value of this type.  The logical ‚Äúand‚Äù corresponds to the product of types, the logical ‚Äúor‚Äù to the sum of the types, the logical ‚Äúnot‚Äù to the type <code>A -&gt;: Zero</code> , i.e.  functions in an empty type.  So in the theory of types logic arises.  True, not any logic, but the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D1%2583%25D0%25B8%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25BC">intuitionistic</a> or constructive, i.e.  logic without the law of elimination of the third.  Indeed, generally speaking, one cannot construct a value of type <code>PlusTyp(A, A -&gt;: Zero)</code> (if one could not prove <code>A</code> , then this does not mean that one could prove non- <code>A</code> ).  Interestingly, the negation to the negation of the law of excluding the third is true: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g = <span class="hljs-string"><span class="hljs-string">"g"</span></span> :: <span class="hljs-type"><span class="hljs-type">PlusTyp</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g1 = a :-&gt; g(<span class="hljs-type"><span class="hljs-type">PlusTyp</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span>).incl1(a)) !: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span> g :-&gt; g(<span class="hljs-type"><span class="hljs-type">PlusTyp</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span>).incl2(g1)) !: (<span class="hljs-type"><span class="hljs-type">PlusTyp</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span>) -&gt;: <span class="hljs-type"><span class="hljs-type">Zero</span></span></code> </pre> <br>  Well, if types are statements, and type values ‚Äã‚Äãare proofs, then the equality of two terms <code>a1 =:= a2</code> is a statement, which means type.  Type dependent, since  depends on the values ‚Äã‚Äãof <code>a1, a2</code> some type <code>A</code>  If <code>a1, a2</code> different, then there should not be a way to construct a value of this type, since  the statement is false.  If they are the same, then there should be a way to construct a value, since the statement is true, so our inductive type has a single constructor <code>refl(A)(a) !: Id(A)(a)(a)</code> (or <code>a.refl !: (a =:= a)</code> for the built-in equality type). <br><br>  Another useful type in proving theorems with inequalities: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">LTE</span></span> = <span class="hljs-string"><span class="hljs-string">"‚â§"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">LTEInd</span></span> = {<span class="hljs-string"><span class="hljs-string">"0 ‚â§ _"</span></span> ::: m ~&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">LTE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LTE</span></span>(zero)(m) )} |: {<span class="hljs-string"><span class="hljs-string">"S _ ‚â§ S _"</span></span> ::: n ~&gt;&gt;: m ~&gt;&gt;: ((<span class="hljs-type"><span class="hljs-type">LTE</span></span> :&gt; <span class="hljs-type"><span class="hljs-type">LTE</span></span>(n)(m) ) --&gt;&gt;: (<span class="hljs-type"><span class="hljs-type">LTE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LTE</span></span>(succ(n))(succ(m)) ))} =:: <span class="hljs-type"><span class="hljs-type">LTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lteZero :: lteSucc :: <span class="hljs-type"><span class="hljs-type">HNil</span></span> = <span class="hljs-type"><span class="hljs-type">LTEInd</span></span>.intros</code> </pre> <br><h4>  Higher inductive types </h4><br>  Even in the library, you can work with <a href="https://homotopytypetheory.org/2011/04/24/higher-inductive-types-a-tour-of-the-menagerie/">higher inductive types</a> .  For example, a circle <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span> = <span class="hljs-string"><span class="hljs-string">"S^1"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = <span class="hljs-string"><span class="hljs-string">"base"</span></span> :: <span class="hljs-type"><span class="hljs-type">Circle</span></span> <span class="hljs-comment"><span class="hljs-comment">//  val loop = "loop" :: (base =:= base) //   </span></span></code> </pre> <br>  and sphere <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Sphere</span></span> = <span class="hljs-string"><span class="hljs-string">"S^2"</span></span> :: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = <span class="hljs-string"><span class="hljs-string">"base"</span></span> :: <span class="hljs-type"><span class="hljs-type">Sphere</span></span> <span class="hljs-comment"><span class="hljs-comment">//  val surf = "surf" :: (base.refl =:= base.refl) //    // val surf = "surf" :: IdentityTyp(base =:= base, base.refl, base.refl) // val surf = "surf" :: IdentityTyp(IdentityTyp(Sphere, base, base), base.refl, base.refl)</span></span></code> </pre> <br><h4>  Recursion and induction </h4><br>  Now how to define (recursive) functions.  The library for each inductive type generates methods <code>.rec</code> , <code>.induc</code> , i.e.  recursion (aka recursor) and induction are eliminators into a permanent and dependent type, respectively, with which you can carry out pattern matching (pattern matching), if necessary - recursive.  For example, you can define a logical "not": <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-string"><span class="hljs-string">"b"</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recBB = <span class="hljs-type"><span class="hljs-type">BoolInd</span></span>.rec(<span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> not = recBB(fls)(tru)</code> </pre> <br>  Here we can assume that we have done pattern matching: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  We check that everything works: <br><br><pre> <code class="scala hljs">not(tru) == fls not(fls) == tru</code> </pre> <br>  You can also define a logical "and": <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recBBB = <span class="hljs-type"><span class="hljs-type">BoolInd</span></span>.rec(<span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> and = recBBB(b :-&gt; b)(b :-&gt; fls)</code> </pre> <br>  Here we can assume that we have made a comparison with the sample of the first argument: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  match { case true =&gt; (b =&gt; b) case false =&gt; (b =&gt; false) }</span></span></code> </pre> <br>  Checking: <br><br><pre> <code class="scala hljs">and(fls)(tru) == fls and(tru)(tru) == tru</code> </pre> <br>  You can determine the doubling of the natural number: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n = <span class="hljs-string"><span class="hljs-string">"n"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> m = <span class="hljs-string"><span class="hljs-string">"m"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recNN = <span class="hljs-type"><span class="hljs-type">NatInd</span></span>.rec(<span class="hljs-type"><span class="hljs-type">Nat</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> double = recNN(zero)(n :-&gt; (m :-&gt; succ(succ(m)) ))</code> </pre> <br>  Here again, we can assume that we have done pattern matching: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  match { case Zero =&gt; Zero case Succ(n) =&gt; val m = double(n) m + 2 }</span></span></code> </pre> <br>  Checking: <br><br><pre> <code class="scala hljs">println(double(two).fansi) &gt; succ(succ(succ(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>))))</code> </pre> <br>  Define the addition of natural numbers: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recNNN = <span class="hljs-type"><span class="hljs-type">NatInd</span></span>.rec(<span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Nat</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> addn = <span class="hljs-string"><span class="hljs-string">"add(n)"</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> add = recNNN(m :-&gt; m)(n :-&gt; (addn :-&gt; (m :-&gt; succ(addn(m)) )))</code> </pre> <br>  Here, similarly, we can assume that we have made a comparison with the sample in the first argument: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  match { case Zero =&gt; (m =&gt; m) case Succ(n) =&gt; val addn = add(n) m =&gt; addn(m) + 1 }</span></span></code> </pre> <br>  Check: <br><br><pre> <code class="scala hljs">println(add(two)(three).fansi) &gt; succ(succ(succ(succ(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>)))))</code> </pre> <br>  We also define the concatenation of vectors: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vn = <span class="hljs-string"><span class="hljs-string">"v_n"</span></span> :: <span class="hljs-type"><span class="hljs-type">VecA</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vm = <span class="hljs-string"><span class="hljs-string">"v_m"</span></span> :: <span class="hljs-type"><span class="hljs-type">VecA</span></span>(m) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> indVVV = <span class="hljs-type"><span class="hljs-type">VecAInd</span></span>.induc(n :~&gt; (vn :-&gt; (m ~&gt;: (<span class="hljs-type"><span class="hljs-type">VecA</span></span>(m) -&gt;: <span class="hljs-type"><span class="hljs-type">VecA</span></span>(add(n)(m)) )))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> concatVn = <span class="hljs-string"><span class="hljs-string">"concat(v_n)"</span></span> :: (m ~&gt;: (<span class="hljs-type"><span class="hljs-type">VecA</span></span>(m) -&gt;: <span class="hljs-type"><span class="hljs-type">VecA</span></span>(add(n)(m)) )) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vconcat = indVVV(m :~&gt; (vm :-&gt; vm))(n :~&gt; (a :-&gt; (vn :-&gt; (concatVn :-&gt; (m :~&gt; (vm :-&gt; vcons(add(n)(m))(a)(concatVn(m)(vm)) ))))))</code> </pre> <br>  Here we use not recursion, but induction, since  we need an eliminator to a dependent type <br>  <code>m ~&gt;: (VecA(m) -&gt;: VecA(add(n)(m)))</code> - indeed, this type depends on <code>n</code> from the vector (the first concatenation argument), which we deconstruct when comparing with the pattern: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  match { case (Zero, Nil) =&gt; (vm =&gt; vm) case (Succ(n), Cons(a)(vn)) =&gt; val concatVn = concat(vn) vm =&gt; Cons(a)(concatVn(vm)) }</span></span></code> </pre> <br>  Testing: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a1 = <span class="hljs-string"><span class="hljs-string">"a1"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a2 = <span class="hljs-string"><span class="hljs-string">"a2"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a3 = <span class="hljs-string"><span class="hljs-string">"a3"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a4 = <span class="hljs-string"><span class="hljs-string">"a4"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vect = vcons(one)(a)(vcons(zero)(a1)(vnil)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vect1 = vcons(two)(a2)(vcons(one)(a3)(vcons(zero)(a4)(vnil))) println(vconcat(two)(vect)(three)(vect1).fansi) &gt; cons(succ(succ(succ(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>)))))(a)(cons(succ(succ(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>))))(a1)(cons(succ(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>)))(a2)(cons(succ(<span class="hljs-number"><span class="hljs-number">0</span></span>))(a3)(cons(<span class="hljs-number"><span class="hljs-number">0</span></span>)(a4)(nil)))))</code> </pre> <br>  Let me show you another example of how theorems are proved in ProvingGround.  We prove that <code>add(n)(n) =:= double(n)</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> indN_naddSm_eq_S_naddm = <span class="hljs-type"><span class="hljs-type">NatInd</span></span>.induc(n :-&gt; (m ~&gt;: ( add(n)(succ(m)) =:= succ(add(n)(m)) ))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hyp1 = <span class="hljs-string"><span class="hljs-string">"n+Sm=S(n+m)"</span></span> :: (m ~&gt;: ( add(n)(succ(m)) =:= succ(add(n)(m)) )) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lemma = indN_naddSm_eq_S_naddm(m :~&gt; succ(m).refl)(n :~&gt; (hyp1 :-&gt; (m :~&gt; <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.extnslty(succ)( add(n)(succ(m)) )( succ(add(n)(m)) )( hyp1(m) ) ))) !: n ~&gt;: m ~&gt;: ( add(n)(succ(m)) =:= succ(add(n)(m)) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lemma1 = <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.extnslty(succ)( add(n)(succ(n)) )( succ(add(n)(n)) )( lemma(n)(n) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> indN_naddn_eq_2n = <span class="hljs-type"><span class="hljs-type">NatInd</span></span>.induc(n :-&gt; ( add(n)(n) =:= double(n) )) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hyp = <span class="hljs-string"><span class="hljs-string">"n+n=2*n"</span></span> :: ( add(n)(n) =:= double(n) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lemma2 = <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.extnslty( m :-&gt; succ(succ(m)) )( add(n)(n) )( double(n) )(hyp) indN_naddn_eq_2n(zero.refl)(n :~&gt; (hyp :-&gt; <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.trans(<span class="hljs-type"><span class="hljs-type">Nat</span></span>)( add(succ(n))(succ(n)) )( succ(succ(add(n)(n))) )( double(succ(n)) )(lemma1)(lemma2) )) !: n ~&gt;: ( add(n)(n) =:= double(n) )</code> </pre> <br>  A circle cannot be defined as an ordinary inductive type through <code>(...) |: (...) =:: ...</code> (indeed, the <code>loop</code> constructor returns not a value of the <code>Circle</code> type, as it would be for an ordinary inductive type).  Therefore, recursion with induction has to be determined manually: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recCirc = <span class="hljs-string"><span class="hljs-string">"rec_{S^1}"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: a ~&gt;: (a =:= a) -&gt;: <span class="hljs-type"><span class="hljs-type">Circle</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> = <span class="hljs-string"><span class="hljs-string">"B(_ : S^1)"</span></span> :: <span class="hljs-type"><span class="hljs-type">Circle</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-string"><span class="hljs-string">"b"</span></span> :: <span class="hljs-type"><span class="hljs-type">B</span></span>(base) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-string"><span class="hljs-string">"c"</span></span> :: <span class="hljs-type"><span class="hljs-type">Circle</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> indCirc = <span class="hljs-string"><span class="hljs-string">"ind_{S^1}"</span></span> :: <span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: b ~&gt;: (( <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.transport(<span class="hljs-type"><span class="hljs-type">B</span></span>)(base)(base)(loop)(b) =:= b ) -&gt;: c ~&gt;: <span class="hljs-type"><span class="hljs-type">B</span></span>(c) )</code> </pre> <br>  with two axioms <code>comp_base</code> and <code>comp_loop</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> l = <span class="hljs-string"><span class="hljs-string">"l"</span></span> :: ( <span class="hljs-type"><span class="hljs-type">IdentityTyp</span></span>.transport(<span class="hljs-type"><span class="hljs-type">B</span></span>)(base)(base)(loop)(b) =:= b ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> comp_base = <span class="hljs-string"><span class="hljs-string">"comp_base"</span></span> :: <span class="hljs-type"><span class="hljs-type">B</span></span> ~&gt;: b ~&gt;: l ~&gt;: ( indCirc(<span class="hljs-type"><span class="hljs-type">B</span></span>)(b)(l)(base) =:= b ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">P</span></span> = <span class="hljs-string"><span class="hljs-string">"P(_ : A)"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt;: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = <span class="hljs-string"><span class="hljs-string">"f"</span></span> :: a ~&gt;: <span class="hljs-type"><span class="hljs-type">P</span></span>(a) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dep_map = <span class="hljs-string"><span class="hljs-string">"dep_map"</span></span> :: <span class="hljs-type"><span class="hljs-type">A</span></span> ~&gt;: (<span class="hljs-type"><span class="hljs-type">P</span></span> ~&gt;: (f ~&gt;: (a ~&gt;: (a1 ~&gt;: (( a =:= a1 ) -&gt;: ( f(a) =:= f(a1) )))))) <span class="hljs-comment"><span class="hljs-comment">// dep_map  IdentityTyp.extnslty(f),    f val comp_loop = "comp_loop" :: B ~&gt;: b ~&gt;: l ~&gt;: ( dep_map(Circle)(B)(indCirc(B)(b)(l))(base)(base)(loop) =:= l )</span></span></code> </pre> <br><br>  A few words on how to run the code on ProvingGround.  There are 3 ways. <br><br><ol><li>  The first and recommended - from the console (loaded <a href="http://www.lihaoyi.com/Ammonite/">Ammonite REPL</a> ) using the command <br>  <b><a href="http://www.scala-sbt.org/">sbt</a> mantle / test: run</b> (from the root of the ProvingGround project after cloning the repository <a href="">github.com/siddhartha-gadgil/ProvingGround.git</a> , in the case of the Ammonite REPL launch error, create an empty <code>ProvingGround/mantle/target/web/classes/test</code> ) directory. <br><br></li><li>  The second is using the <code>sbt server/run</code> command and then opening <a href="http://localhost:8080/">http: // localhost: 8080</a> in the browser. <br><br></li><li>  The third is from the IDE.  In IntelliJ Idea 2017.1.3, the project may be imported after <a href="https://github.com/siddhartha-gadgil/ProvingGround/issues/124">modifying</a> build.sbt, but the code may not run.  The solution is to import into the Idea not the entire project, but only the <code>ProvingGround/core</code> subproject.  To do this, put a <a href="">new build.sbt</a> here: <code>ProvingGround/core/build.sbt</code> . <br><br>  List of imports: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> provingground._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">HoTT</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">TLImplicits</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shapeless._ <span class="hljs-comment"><span class="hljs-comment">//import ammonite.ops._ import FansiShow._</span></span></code> </pre> </li></ol><br>  If anyone is interested in this topic (type theory, homotopy type theory, dependent types, type-level calculations, automatic proof of theorems), welcome to <a href="https://stepik.org/2294">my course</a> .  He is introductory.  According to HoTT, it‚Äôs rather not even an introduction, but an introduction to the introduction, but in other areas, I think, it falls short of the level of an introduction.  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/329176/">https://habr.com/ru/post/329176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329160/index.html">Unreal engine 4. Sequencer instead of Matinee</a></li>
<li><a href="../329166/index.html">Bug in NTFS, or how to hang the whole system</a></li>
<li><a href="../329168/index.html">Pygest # 9. Releases, articles, interesting projects from the world of Python [May 8, 2017 - May 22, 2017]</a></li>
<li><a href="../329170/index.html">Domestic processor from the company ELVIS</a></li>
<li><a href="../329174/index.html">Load testing: where to start and where to look</a></li>
<li><a href="../329178/index.html">PostgreSQL Diagnostic Techniques - Vladimir Borodin and Ildus Kurbangaliev</a></li>
<li><a href="../329180/index.html">We write an analogue of Paint on Objective-C</a></li>
<li><a href="../329182/index.html">Seminar "Modernization of engineering systems in the existing data center", May 31, Moscow</a></li>
<li><a href="../329184/index.html">Bitdefender Hypervisor Introspection: a new means of dealing with hidden cyber threats</a></li>
<li><a href="../329188/index.html">Confronting Positive Hack Days: Hackers won't be bored</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>