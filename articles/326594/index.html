<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bash scripts, part 4: input and output</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bash scripts: start 
 Bash scripts, part 2: loops 
 Bash scripts, part 3: command line options and keys 
 Bash scripts, part 4: input and output 
 Bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bash scripts, part 4: input and output</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="https://habrahabr.ru/company/ruvds/blog/325522/">Bash scripts: start</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/325928/">Bash scripts, part 2: loops</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326328/">Bash scripts, part 3: command line options and keys</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326594/">Bash scripts, part 4: input and output</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326826/">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327248/">Bash scripts, part 6: functions and library development</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327530/">Bash scripts, part 7: sed and word processing</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327754/">Bash scripts, part 8: awk data processing language</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327896/">Bash scripts, part 9: regular expressions</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328346/">Bash scripts, part 10: practical examples</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328436/">Bash scripts, part 11: expect and automate interactive utilities</a> </blockquote><br>  Last time, in the third part of this series of materials on bash scripts, we talked about command line parameters and keys.  Our today's topic is input, output, and everything connected with it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/803/892/bfe/803892bfe548499aa763df324d40fd01.png" alt="image"></div><a name="habracut"></a><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  You are already familiar with the two methods of working with what command line scripts display: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Display the displayed data on the screen. </li><li>  Redirect output to file. </li></ul><br>  Sometimes you have to show something on the screen, and write something to a file, so you need to figure out how input and output is processed in Linux, which means learning how to send the results of the scripts to the right place.  Let's start by talking about standard file descriptors. <br><br><h2>  <font color="#3AC1EF">Standard File Descriptors</font> </h2><br>  Everything in Linux is files, including input and output.  The operating system identifies files using descriptors. <br><br>  Each process is allowed to have up to nine open file descriptors.  The bash shell reserves the first three descriptors with identifiers 0, 1, and 2. This is what they mean. <br><br><ul><li> <code>0</code> , <code>STDIN ‚Äî</code> standard input stream. </li><li>  <code>1</code> , <code>STDOUT ‚Äî</code> standard output stream. </li><li>  <code>2</code> , <code>STDERR ‚Äî</code> standard error stream. </li></ul><br>  These three special descriptors handle the input and output of data in the script. <br>  You need to properly understand the standard streams.  They can be compared with the foundation on which the interaction of scripts with the outside world is built.  Consider the details of them. <br><br><h2>  <font color="#3AC1EF">STDIN</font> </h2><br>  <code>STDIN ‚Äî</code> the standard shell input stream.  For the terminal, the standard input is the keyboard.  When an input redirection character is used in scripts - <code>&lt;</code> , Linux replaces the standard input file descriptor with the one specified in the command.  The system reads the file and processes the data as if they were entered from the keyboard. <br><br>  Many bash commands accept input from <code>STDIN</code> if no file is specified on the command line from which to take data.  For example, this is true for the <code>cat</code> . <br><br>  When you enter the <code>cat</code> command on the command line without specifying any parameters, it accepts input from <code>STDIN</code> .  After you enter the next line, <code>cat</code> simply displays it on the screen. <br><br><h2>  <font color="#3AC1EF">STDOUT</font> </h2><br>  <code>STDOUT ‚Äî</code> standard shell output stream.  By default this is the screen.  Most bash commands output data to <code>STDOUT</code> , which causes it to appear in the console.  The data can be redirected to a file by attaching it to its contents, the <code>&gt;&gt;</code> command serves for this. <br><br>  So, we have a certain data file to which we can add other data using this command: <br><br><pre> <code class="hljs ruby">pwd <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>myfile</code> </pre> <br>  What <code>pwd</code> will print will be added to the file <code>myfile</code> , while the data already in it will not go anywhere. <br><br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/MT_u64e-cQwiS9VlBwtI0AfCRZ7KlpkMOwGpc7Xp6e-ckueCQDeO8cptohQVGRVNz9B5a8oHtqTnUBM9EcXQ7PzGSS3quPbBLNaxNjZum_pTfrOOTYj2ULQr0jlMcaPZCcx-80VO8k1EUL5B8Q"></div><br>  <i><font color="#999999">Redirect command output to file</font></i> <br><br>  So far so good, but what if you try to accomplish something like the one shown below, referring to a non-existent file <code>xfile</code> , conceiving all this so that an error message <code>xfile</code> into the file <code>myfile</code> . <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> ‚Äìl xfile &gt; myfile</code> </pre> <br>  After executing this command, we will see error messages on the screen. <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/xkDHMNwO2v8IG9lBR5GZZ-MuiHIOn9c53-l_XbXvijkCdhM15yCA0Nndl_uHDPif1Y1MxUgy_5JrBv9Wquc6DSrbTRXNzsRf5VsoeFghoVXf8k-NGVdZLhQFYmnr2JeZ5SYDq_BhHacvCXs5nw"></div><br>  <i><font color="#999999">Attempt to access non-existent file</font></i> <br><br>  When trying to access a file that does not exist, an error is generated, but the shell did not redirect the error messages to the file, displaying them on the screen.  But we wanted the error messages to be in the file.  What to do?  The answer is simple - use the third standard descriptor. <br><br><h2>  <font color="#3AC1EF">STDERR</font> </h2><br>  <code>STDERR</code> is a standard shell error stream.  By default, this descriptor points to the same thing as <code>STDOUT</code> , which is why we see a message on the screen when an error occurs. <br><br>  So, suppose we need to redirect error messages, say, to a log file, or somewhere else, instead of displaying them on the screen. <br><br><h3>  <font color="#3AC1EF">‚ñç Error Forwarding</font> </h3><br>  As you already know, the <code>STDERR ‚Äî</code> file descriptor <code>STDERR ‚Äî</code> 2. We can redirect errors by placing this descriptor in front of the redirect command: <br><br><pre> <code class="hljs matlab">ls -l xfile <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;myfile <span class="hljs-built_in"><span class="hljs-built_in">cat</span></span> ./myfile</code> </pre> <br>  The error message is now in the file <code>myfile</code> . <br><br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/2KC8_kWlp5a15ruyBlvN8RkdX9Sncf8RztKz55HgpGesffvbK8wQW2MEoaCjEJRB97Tq3IU4KTzGhmz7oARoisV8ShxFHCAJTb1pkJuZwmLI_bfjeGZyALBQdSPOfFMkyOCVgnk-zDqPN9QFEA"></div><br>  <i><font color="#999999">Redirecting error to file</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Redirecting error and output streams</font> </h3><br>  When writing command line scripts, a situation may arise when you need to organize both the redirection of error messages and the redirection of standard output.  In order to achieve this, you need to use the redirection commands for the corresponding descriptors, indicating the files where the errors and the standard output should fall: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> ‚Äìl myfile xfile anotherfile <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; errorcontent <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; correctcontent</code> </pre> <br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/oqXLEuYY5u6b5m6-FgwkG-YG2DIHOAjFMT-vYFQytzLMZJAxUy7DuCleOHeFZKTeV2kEmoVMdhGMb7MjNTjtVDA-4uYv2RZc8g_kpo5QcSjPIKexL8xLDqK5-aOEoOMaL98D7hao0GOUDerW2Q"></div><br>  <i><font color="#999999">Redirecting errors and standard output</font></i> <br><br>  The shell will redirect what the <code>ls</code> normally sends to <code>STDOUT</code> to the <code>correctcontent</code> file <code>correctcontent</code> to the <code>1&gt;</code> construction.  Error messages that would fall into <code>STDERR</code> appear in the <code>errorcontent</code> file due to the redirection command <code>2&gt;</code> . <br><br>  If necessary, both <code>STDERR</code> and <code>STDOUT</code> can be redirected to the same file using the <code>&amp;&gt;</code> command: <br><br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/2938XZKz95Stm-lttdbvTf6yaz-io5o8Wt5xlCmdsrvQRUcQ27HKX2ETI89QA6wxonMzWiCqdFMlOU0Z8q-hrf0P0EaSXXlx9z0rBLyzszL-6D8IBoXwiVxFXZtayXPiUJ29llCBdOdXp38JMA"></div><br>  <i><font color="#999999">Redirect STDERR and STDOUT to the same file</font></i> <br><br>  After executing the command, what is intended for <code>STDERR</code> and <code>STDOUT</code> is in the <code>content</code> file. <br><br><h2>  <font color="#3AC1EF">Scripting output redirection</font> </h2><br>  There are two methods for output redirection in command line scripts: <br><br><ul><li>  Temporary redirection, or redirection of a single line output. </li><li>  Permanent redirection, or redirection of the entire output in the script or in some part of it. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Temporary output redirection</font> </h3><br>  In the script, you can redirect the output of a separate line in <code>STDERR</code> .  In order to do this, it is enough to use the redirection command, specifying the <code>STDERR</code> descriptor, and you should put the ampersand symbol ( <code>&amp;</code> ) before the descriptor number: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#!/bin/bash echo </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"This is an error"</span></span></span><span class="hljs-meta"> &gt;&amp;2 echo </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"This is normal output"</span></span></span></span></code> </pre> <br>  If you run the script, both lines will appear on the screen, since, as you already know, by default, errors are output to the same place as the usual data. <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/vZui5QFtOOOwTKR5duEthXs3sKEOK31e85_FuQ9ygfVo1GXH3ojQDKYizQSv_XYC7pVXPGAhJRXp9keiz6JEX7ZMYL838xfNQXxrZ-HnlGGuA8iu95mx88pEmwlSWTNNX4vzNrjb2ZQeR68IRw"></div><br>  <i><font color="#999999">Temporary redirection</font></i> <br><br>  Run the script so that the <code>STDERR</code> gets to the file. <br><br><pre> <code class="hljs">./myscript 2&gt; myfile</code> </pre> <br>  As you can see, now the usual output is done to the console, and error messages get into the file. <br><br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/FLgdZTOJynq_Uigre-Mclmf6ESccvVebTBczs-tkDSaeSs6eZQI4i-q4vFqQI9J-2NYva8l2X-tNjQAolqKbvtXhuxHi4ZYadtp1at0eOTstD7mVy13VD6TOPr_mm5NGtiZL57P2eLhL6gKM2A"></div><br>  <i><font color="#999999">Error messages are written to the file.</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Permanent output redirection</font> </h3><br>  If the script needs to redirect a lot of data displayed on the screen, adding the appropriate command to each <code>echo</code> call is inconvenient.  Instead, you can set output redirection to a specific descriptor for the duration of the script execution, using the <code>exec</code> command: <br><br><pre> <code class="hljs smalltalk">#!/bin/bash exec <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;outfile echo <span class="hljs-comment"><span class="hljs-comment">"This is a test of redirecting all output"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"from a shell script to another file."</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"without having to redirect every line"</span></span></code> </pre> <br>  Run the script. <br><br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/bsfDHNdPnsaOMIUZuqpOeUzyiJvmNFqmLFSEnnnKIWAlGsGfMPxxTQclRZcp1IuPtYwfQPB0gePTWAzwhixTPElZfm-0l4u7qlh6s9XghFXDN2ABawkhyd136HO2K1oQCXtPonUxzYbPTCmIsQ"></div><br>  <i><font color="#999999">Redirect all output to file</font></i> <br><br>  If you view the file specified in the output redirection command, it turns out that everything that was output by <code>echo</code> commands got into this file. <br><br>  The <code>exec</code> command can be used not only at the beginning of the script, but also in other places: <br><br><pre> <code class="hljs smalltalk">#!/bin/bash exec <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;myerror echo <span class="hljs-comment"><span class="hljs-comment">"This is the start of the script"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"now redirecting all output to another location"</span></span> exec <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;myfile echo <span class="hljs-comment"><span class="hljs-comment">"This should go to the myfile file"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"and this should go to the myerror file"</span></span> &gt;&amp;<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  This is what happens after running the script and viewing the files to which we redirected the output. <br><br><div style="text-align:center;"><img src="https://lh3.googleusercontent.com/pkDrsO-90p-aoSP2NngxJsK7X1PxdZEAX_SC6xgcz7R_VhIm-kWzm3B-1virrHcZ_uMDBlCPR3vsEpf7_LbSTH1V9V9Vlh8WZxK38ERpgcJGvpz19w6b0cpCdTcGwUEx65FdkIf7r6fzwGiGbA"></div><br>  <i><font color="#999999">Redirect output to different files</font></i> <br><br>  First, the <code>exec</code> command sets the output redirection from <code>STDERR</code> to the file <code>myerror</code> .  Then the output of several <code>echo</code> commands is sent to <code>STDOUT</code> and displayed on the screen.  After that, the <code>exec</code> command sets the sending of what gets into <code>STDOUT</code> to the file <code>myfile</code> , and finally, we use the redirect command to <code>STDERR</code> in the <code>echo</code> command, which causes the corresponding line to be written to the <code>myerror.</code> file <code>myerror.</code> <br><br>  Having mastered this, you can redirect the output to where it should be.  Now let's talk about input redirection. <br><br><h2>  <font color="#3AC1EF">Input redirection in scripts</font> </h2><br>  To redirect input, you can use the same methodology that we used to redirect output.  For example, the <code>exec</code> command allows you to make a file a data source for <code>STDIN</code> : <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; myfile</code> </pre> <br>  This command tells the shell that the input file should be the file <code>myfile</code> , not the usual <code>STDIN</code> .  Let's look at input redirection in action: <br><br><pre> <code class="hljs swift">#!/bin/bash exec <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; testfile <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> read line <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Line #$count: $line"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  This is what will appear on the screen after running the script. <br><br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/eDQbaQ1jCzG8iB-HXt0r2LBtZryyGj3aRdnxjN4hmfDZvDWV1zJqMzlz7hFyCX692MWJTKbDSSt81xTpGPLLqndZwmAvs_rYfPWQMTMOQHKJZ3SqB9pOo9T09dFUr5AD2sZw64D-DK4Hl7DIBg"></div><br>  <i><font color="#999999">Input redirection</font></i> <br><br>  In one of the previous articles, you learned how to use the <code>read</code> command to read user input from the keyboard.  If you redirect the input, making the file a data source, then the <code>read</code> command, when you try to read data from <code>STDIN</code> , will read it from the file, not from the keyboard. <br><br>  Some Linux administrators use this approach to read and post process log files. <br><br><h2>  <font color="#3AC1EF">Creating your own output redirection</font> </h2><br>  Redirecting input and output in scripts is not limited to three standard file descriptors.  As already mentioned, you can have up to nine open handles.  The remaining six, with numbers from 3 to 8, can be used to redirect input or output.  Any of them can be assigned to a file and used in script code. <br><br>  You can assign a handle to the data output using the <code>exec</code> command: <br><br><pre> <code class="hljs smalltalk">#!/bin/bash exec <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;myfile echo <span class="hljs-comment"><span class="hljs-comment">"This should display on the screen"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"and this should be stored in the file"</span></span> &gt;&amp;<span class="hljs-number"><span class="hljs-number">3</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"And this should be back on the screen"</span></span></code> </pre> <br>  After launching the script, part of the output will be displayed on the screen, part - in the file with descriptor <code>3</code> . <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/faCFAF7pvOg4Gb_2u4MHOcUvGsZUj3nmaFNM3I96ohph7I4eG8ax3u2w4Nf3blBSSWTEdrzxTftzyzCafYxDj7aS3LNVMd2sJxAjC9ztn4tFW9OVN8HM0OHXYUvE3WrktWUgWcByzBUAIIo2wQ"></div><br>  <i><font color="#999999">Output redirection using own descriptor</font></i> <br><br><h2>  <font color="#3AC1EF">Creating file descriptors for data entry</font> </h2><br>  You can redirect input in the script in the same way as output.  Save the <code>STDIN</code> in another descriptor before redirecting the input. <br><br>  After you finish reading the file, you can restore <code>STDIN</code> and use it as usual: <br><br><pre> <code class="hljs mel">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>&lt;&amp;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; myfile count=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> read line <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Line #$count: $line"</span></span> count=$(( $count + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;&amp;<span class="hljs-number"><span class="hljs-number">6</span></span> read -p <span class="hljs-string"><span class="hljs-string">"Are you done now? "</span></span> answer <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> $answer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y) echo <span class="hljs-string"><span class="hljs-string">"Goodbye"</span></span>;; n) echo <span class="hljs-string"><span class="hljs-string">"Sorry, this is the end."</span></span>;; esac</code> </pre> <br>  Test the script. <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/ASf0YHSBrC-5W-uhWf8914FSGhA4u5u59NrqTPt2dpifIGNJ-Fpj9OAK_XfauzkpxaOU8729wEr-177L6ujoXnvFv1PiBaOWlXLwleUVzV9IEFdX8rgrMB7D0cto20j1egBlyn5qT0oDg4fLeQ"></div><br>  <i><font color="#999999">Input redirection</font></i> <br><br>  In this example, file descriptor 6 was used to store the reference to <code>STDIN</code> .  Then the input was redirected, the data source for <code>STDIN</code> was the file.  After that, the input to the <code>read</code> command came from the redirected <code>STDIN</code> , that is, from the file. <br><br>  After reading the file, we return <code>STDIN</code> to its original state, redirecting it to handle <code>6</code> .  Now, in order to check that everything works correctly, the script asks the user a question, waits for input from the keyboard and processes what is entered. <br><br><h2>  <font color="#3AC1EF">Closing File Descriptors</font> </h2><br>  The shell automatically closes file handles after the script has completed.  However, in some cases, you need to close the handles manually before the script finishes.  In order to close a handle, it must be redirected to <code>&amp;-</code> .  It looks like this: <br><br><pre> <code class="hljs mel">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; myfile echo <span class="hljs-string"><span class="hljs-string">"This is a test line of data"</span></span> &gt;&amp;<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&amp;- echo <span class="hljs-string"><span class="hljs-string">"This won't work"</span></span> &gt;&amp;<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  After executing the script, we get an error message. <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/-yp803VfhFjaIy1RDFQKeJedQMrbGdJxyvcU_Iikdx8eQoZBET64TioTH4hiejpdx6c4GxauOYTwgal2g1I7O8jX59attXzWAcu3DH2lMAgF7I8QLVfCVS_a9hI3lWKRQX9jayVbG5fJ8EJXzw"></div><br>  <i><font color="#999999">Attempt to access a closed file descriptor</font></i> <br><br>  The thing is, we tried to access a non-existing handle. <br><br>  Be careful when closing file descriptors in scripts.  If you sent data to a file, then closed the descriptor, then opened it again, the shell will replace the existing file with the new one.  That is, everything that was previously written to this file will be lost. <br><br><h2>  <font color="#3AC1EF">Getting information about open handles</font> </h2><br>  To get a list of all open handles in Linux, you can use the <code>lsof</code> command.  On many distributions, like Fedora, the <code>lsof</code> utility is in <code>/usr/sbin</code> .  This command is very useful as it displays information about each descriptor that is open in the system.  This includes what the processes running in the background have opened, and what has been opened by the logged in users. <br><br>  This command has a lot of keys, consider the most important. <br><br><ul><li>  <code>-p</code> Allows you to specify the process <code>ID</code> . </li><li>  <code>-d</code> Allows you to specify the descriptor number to get information about. </li></ul><br>  In order to find out the <code>PID</code> current process, you can use the special <code>$$</code> environment variable in which the shell writes the current <code>PID</code> . <br><br>  The <code>-a</code> switch is used to perform the logical <code></code> operation on the results returned by using two other keys: <br><br><pre> <code class="hljs mel">lsof -a -p $$ -d <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/pZmbYEv-md9wDFqCgKHxOE24vVVhyliwk862ye4V8DAMtXt0JovYi1Eo0QtTE_ruiSZEeTqZmJOze3I_ni1KQfG6SkSs991adZs9zAK-dc77pE1bpSebhyay2FJPBJdck5EPFqSzBXmmn5wVXA"></div><br>  <i><font color="#999999">Displaying open descriptors</font></i> <br><br>  Type of files associated with <code>STDIN</code> , <code>STDOUT</code> and <code>STDERR ‚Äî</code> CHR (character mode).  Since they all point to the terminal, the file name corresponds to the device name assigned to the terminal.  All three standard files are readable and writeable. <br><br>  Let's look at the call to the <code>lsof</code> from a script in which other descriptors are open, in addition to the standard ones: <br><br><pre> <code class="hljs mel">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; myfile1 <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; myfile2 <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>&lt; myfile3 lsof -a -p $$ -d <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre> <br>  That's what happens if you run this script. <br><br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/RPDfGTvjcpMfZKDMMUOrONU3B12jZhXnTzZlcfuFttnojMNrdCenJFrgZMTyZXfdU4Vj2GErTVGXTwvrtEbdYxkpjLoL0gHDfXwv2cX2fHjHEnH0Bnp-bQDHjDG5QU3xXBWAHcU-qYLP_c4f8g"></div><br>  <i><font color="#999999">View the file descriptors opened by the script.</font></i> <br><br>  The script opened two descriptors for output ( <code>3</code> and <code>6</code> ) and one for input ( <code>7</code> ).  The paths to the files used to configure the descriptors are also displayed here. <br><br><h2>  <font color="#3AC1EF">Output suppression</font> </h2><br>  Sometimes you need to make sure that commands in a script, which, for example, can be executed as a background process, do not display anything on the screen.  To do this, you can redirect the output to <code>/dev/null</code> .  This is something like a black hole. <br><br>  Here, for example, how to suppress error messages: <br><br><pre> <code class="hljs javascript">ls -al badfile anotherfile <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br>  The same approach is used if, for example, you need to clear a file without deleting it: <br><br><pre> <code class="hljs cs">cat /dev/<span class="hljs-literal"><span class="hljs-literal">null</span></span> &gt; myfile</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today you learned how input and output work in command line scripts.  Now you know how to handle file descriptors, create, view and close them, know about the redirection of input, output and error streams.  All this is very important in the development of bash-scripts. <br><br>  Next time, we‚Äôll talk about Linux signals, how to handle them in scripts, how to launch tasks on a schedule, and about background tasks. <br><br>  Dear readers!  This material provides the basics of working with input, output, and error streams.  We are sure there are professionals among you who can tell about all this what comes only with experience.  If so, we give you the floor. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/326594/">https://habr.com/ru/post/326594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326582/index.html">The story of how the parser turned into a full-fledged IRCO bot for Telegrams</a></li>
<li><a href="../326584/index.html">Notes on Cisco Catalyst: VLAN setup, password reset, IOS operating system flashing</a></li>
<li><a href="../326588/index.html">How to make your IDEA IDE level</a></li>
<li><a href="../326590/index.html">Mail.Ru Group Online Course News: Restarting Advanced C ++ Programming</a></li>
<li><a href="../326592/index.html">Fat programs - speed factors</a></li>
<li><a href="../326596/index.html">Exoskeleton do it yourself</a></li>
<li><a href="../326600/index.html">Hello, who is calling or determining the number in Asterisk</a></li>
<li><a href="../326602/index.html">Terrible import kraken - how to use ES6-modules and not go crazy</a></li>
<li><a href="../326608/index.html">Personal vDisk in Citrix XenDesktop: what is the advantage and how it works</a></li>
<li><a href="../326610/index.html">Functional components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>