<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruin the performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This note is a written version of my report "How to kill performance with an inefficient code" from the JPoint 2018 conference. You can watch videos a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruin the performance</h1><div class="post__text post__text-html js-mediator-article"><p>  This note is a written version of my report "How to kill performance with an inefficient code" from the JPoint 2018 conference. You can watch videos and slides on <a href="http://2018.jpoint.ru/talks/1smez2ivjmiw0wskqimew0/">the conference page</a> .  In the schedule, the report is marked by an insulting glass of smoothie, so there will be nothing super-complex, it is more likely for beginners. </p><br><p>  Subject of the report: </p><br><ul><li>  how to look at the code to find bottlenecks in it </li><li>  common anti-patterns </li><li>  non-obvious rake </li><li>  bypass rake </li></ul><br><p>  On the sidelines I was pointed out by some inaccuracies / omissions in the report, they are noted here.  Comments are also welcome. </p><a name="habracut"></a><br><h2 id="vliyanie-poryadka-ispolneniya-na-proizvoditelnost">  Performance Impact on Performance </h2><br><p>  There is a user class: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  We need to compare objects with each other, so we will declare the <code>equals</code> and <code>hashCode</code> methods: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.EqualsAndHashCode; <span class="hljs-meta"><span class="hljs-meta">@EqualsAndHashCode</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  The code works, the question is different: will the performance of this code be the best?  To answer it, let us recall the features of the <code>Object::equals</code> method: it returns a positive result only when all the compared fields are equal, otherwise the result will be negative.  In other words, one difference is enough for a negative result. </p><br><p>  Looking at the code created for <code>@EqualsAndHashCode</code> we‚Äôll see something like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object that)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... if (name == null &amp;&amp; that.name != null) { return false; } if (name != null &amp;&amp; !name.equals(that.name)) { return false; } return age == that.age; }</span></span></code> </pre> <br><p>  The order of checking the fields corresponds to the order of their declaration, which in our case is not the best solution, because comparing objects with <code>equals</code> ‚Äúharder‚Äù than comparing simple types. </p><br><p>  Well, let's try creating <code>equals/hashCode</code> methods using Ideas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(name, that.name); }</code> </pre> <br><p>  Idea creates smarter code that knows the difficulty of comparing different kinds of data.  Well, well, we will <code>@EqualsAndHashCode</code> and we will explicitly prescribe <code>equals/hashCode</code> .  Now let's see what happens when the class is expanded: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ List&lt;T&gt; props; String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  Recreate <code>equals/hashCode</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(props, that.props) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- &amp;&amp; Objects.equals(name, that.name); }</span></span></code> </pre> <br><p>  Lists are compared before strings are compared, which is meaningless when the strings are different.  At first glance, there is not much difference, because strings of equal length are cognitively compared (that is, the comparison grows with the length of the string): </p><br><div class="spoiler">  <b class="spoiler_title">There was an inaccuracy</b> <div class="spoiler_text"><p>  The <code>java.lang.String::equals</code> <a href="">method is intrinsicized</a> , so no cognitive comparison occurs during execution. </p></div></div><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // &lt;---- if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }</span></span></code> </pre> <br><p>  Now consider the comparison of two <code>ArrayList</code> (as the most frequently used list implementation).  Examining <code>ArrayList</code> with surprise, we find that it does not have its own <code>equals</code> implementation, but uses the inherited implementation: </p><br><p><img src="https://habrastorage.org/webt/d4/hn/yg/d4hnyguezlpyxz3pgunk22ha1cm.png"></p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//AbstractList::equals public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof List)) { return false; } ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) { // &lt;---- E o1 = e1.next(); Object o2 = e2.next(); if (!(o1 == null ? o2 == null : o1.equals(o2))) { return false; } } return !(e1.hasNext() || e2.hasNext()); }</span></span></code> </pre> <br><p>  The important thing here is the creation of two iterators and a pairwise pass through them.  Suppose there are two <code>ArrayList</code> : </p><br><ul><li>  in one number from 1 to 99 </li><li>  in the second from 1 to 100 </li></ul><br><p>  Ideally, it would be enough to compare the sizes of the two lists and, if there is a discrepancy, immediately return a negative result (as the <code>AbstractSet</code> does), in reality, 99 comparisons will be executed and it will become clear only on the hundredth that the lists are different. </p><br><h4 id="chyo-tam-u-kotlinovcev">  Che there Kotlinovtsev? </h4><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>);</code> </pre> <br><p>  It's all like a broken piece - the order of comparison corresponds to the order of the announcement: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> User) { User u = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Intrinsics.areEqual(name, u.name) &amp;&amp; age == u.age) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- return true; } } return false; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">How to improve the situation?</b>  <b class="spoiler_title">- To complain!</b> <div class="spoiler_text"><p>  IDEA-170178 IDEA-generated equals () <br>  <a href="https://youtrack.jetbrains.com/issue/IDEA-170178">https://youtrack.jetbrains.com/issue/IDEA-170178</a> </p><br><p>  Reordering of comparison in @ EqualsAndHashCode for better performance # 1543 <br>  <a href="https://github.com/rzwitserloot/lombok/issues/1543">https://github.com/rzwitserloot/lombok/issues/1543</a> </p><br><p>  KT-23184 Auto-generated equals () of data class is not optimal <br>  <a href="https://youtrack.jetbrains.com/issue/KT-23184">https://youtrack.jetbrains.com/issue/KT-23184</a> </p></div></div><br><p>  As a crawl, you can manually order the field declarations. </p><br><h4 id="uslozhnim-zadachu">  Complicate the task </h4><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ SomeEntity entity = jpaRepository.findOne(dto.getId()); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; entity.hasGoodRating()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- //do smth } }</span></span></code> </pre> <br><p>  The code assumes access to the database even when the result of checking the condition marked with an arrow is predictable in advance.  If the value of the <code>valid</code> variable is false, then the code in the <code>if</code> block will never be executed, which means you can do without the query: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; hasGoodRating(dto)) { <span class="hljs-comment"><span class="hljs-comment">//do smth } } //       ,    boolean hasGoodRating(Dto dto) { SomeEntity entity = jpaRepository.findOne(dto.getId()); return entity.hasGoodRating(); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note from the Lobby</b> <div class="spoiler_text"><p>  Sinking can be insignificant, when the entity returned from <code>JpaRepository::findOne</code> already in the first level cache, then there will be no request. </p></div></div><br><p>  A similar example without explicit branching: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ Long id = dto.getId(); Entity entity = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dto.isValid() &amp;&amp; entity.hasChild(); }</code> </pre> <br><p>  Quick return allows you to delay the request: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dto.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jpaRepository.findOne(dto.getId()).hasChild(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A rather obvious addition, not included in the report.</b> <div class="spoiler_text"><p>  Imagine that a test uses a similar entity: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = LAZY) <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CHILD_ID"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ChildEntity child; <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.String) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SomeType type;</code> </pre> <br><p>  If the check uses the same entity, then it is worthwhile to ensure that the access to the "lazy" child entities / collections is performed after referring to the fields that are already loaded.  At first glance, one additional request will not have a significant impact on the overall picture, but everything may change when performing an action in a cycle. </p></div></div><br><p>  Conclusion: the chain of actions / checks should be ordered in order of increasing complexity of individual operations, perhaps some of them will not have to be performed. </p><br><h2 id="cikly-i-massovaya-obrabotka">  Cycles and mass processing </h2><br><p>  The following example does not need special explanations: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Student student = jpaRepository.findOne(id); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- O(n) enroll(student); } }</span></span></code> </pre> <br><p>  Due to multiple queries to the database, the code is slow. </p><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text"><p>  Productivity can be even stronger if the <code>enrollStudents</code> method <code>enrollStudents</code> executed outside a transaction: then <strong>every</strong> call to <code>osdjrJpaRepository::findOne</code> will be executed in a new transaction (see <a href="">SimpleJpaRepository</a> ), which means getting and returning the database connection, as well as creating and resetting the first level cache. </p></div></div><br><p>  Correct: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Student student : jpaRepository.findAll(ids)) { enroll(student); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Let's measure the runtime (in ms) for the collection of keys (10 and 100 pieces)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/p2/0b/zq/p20bzq2tlnp3-mj8zlx8c96411e.png"></p></div></div><br><p>  <a href="">Benchmark</a> </p><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text"><p>  If you use Oracle and transfer more than 1000 keys to <code>findAll</code> , then you will get the exception <code>ORA-01795: maximum number of expressions in a list is 1000</code> . <br>  Also, performing a heavy (with multiple keys) <code>in</code> query can be worse than n queries.  It all depends on the specific application, so a mechanical replacement of the cycle for mass processing can degrade performance. </p></div></div><br><h4 id="bolee-slozhnyy-primer-na-tu-zhe-temu">  More complex example on the same topic. </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----  region = new Region(); region.setId(id); } use(region); }</span></span></code> </pre> <br><p>  In this case, we cannot replace the loop with <code>JpaRepository::findAll</code> , <code>JpaRepository::findAll</code> it will break the logic: all values ‚Äã‚Äãobtained from <code>JpaRepository::findAll</code> will not be <code>null</code> and the <code>if</code> block will not work. </p><br><p>  To solve this difficulty we will be helped by the fact that for each key of the database <br>  returns either real value or no value.  That is, in a sense, a database is a dictionary.  Java from the box gives us a ready implementation of the dictionary - <code>HashMap</code> - on top of which we will build the logic for replacing the database: </p><br><pre> <code class="java hljs">Map&lt;Long, Region&gt; regionMap = jpaRepository.findAll(ids) .stream() .collect(Collectors.toMap(Region::getId, Function.identity())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = map.get(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { region = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Region(); region.setId(id); } use(region); }</code> </pre> <br><h4 id="primer-v-obratnuyu-storonu">  Example in the opposite direction </h4><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  This code always creates a new transaction to save the list of entities.  Sinking begins with multiple calls to the method opening a new transaction: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   @Transactional public void audit(List&lt;AuditDto&gt; inserts) { inserts.map(this::toEntities).forEach(saver::save); // &lt;---- } // class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;---- public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  Solution: use the <code>Saver::save</code> method at once for the entire data set: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">audit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;AuditDto&gt; inserts)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;AuditEntity&gt; bulk = inserts .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::toEntities) .flatMap(List::stream) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- .collect(toList()); saver.save(bulk); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Many transactions merge into one, which gives a tangible increase (time in Œºs):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/f7/3r/n9/f73rn9gtjw7fdgiqrfwkq7tfme4.png"></p></div></div><br><p>  <a href="">Benchmark</a> </p><br><p>  An example with multiple transactions is difficult to formalize, which cannot be said about calling <code>JpaRepository::findOne</code> in a loop. </p><br><div class="spoiler">  <b class="spoiler_title">Therefore, take action</b> <div class="spoiler_text"><p>  <a href="https://youtrack.jetbrains.com/issue/IDEA-165730">https://youtrack.jetbrains.com/issue/IDEA-165730</a> <br>  IDEA-165730 Warn about efficient usage of JpaRepository </p><br><p>  <a href="https://youtrack.jetbrains.com/issue/IDEA-165942">https://youtrack.jetbrains.com/issue/IDEA-165942</a> <br><del>  IDEA-165942 </del>  Inspection to replace method call in bulk with bulk operation <br>  <strong>Fixed in 2017.1</strong> </p></div></div><br><p>  The approach is applicable not only to the database, so Tagir <a href="https://habr.com/users/lany/" class="user_link">lany</a> Valeev went further.  And if earlier we wrote this: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : items) { list.add(id); }</code> </pre> <br><p>  and everything was fine, now the "Idea" offers to correct: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.addAll(items);</code> </pre> <br><p>  But even this option does not always satisfy her, because you can make it even shorter and faster: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(items);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Compare (time in ns)</b> <div class="spoiler_text"><p>  For ArrayList, this improvement gives a noticeable increase: </p><br><p><img src="https://habrastorage.org/webt/gi/6j/o8/gi6jo8xwigpdckqz6jtuw4cmane.png"></p><br><p>  For HashSet, everything is not so rosy: </p><br><p><img src="https://habrastorage.org/webt/u9/lo/fy/u9lofyf2wy2hffk8gd0uwvrmmke.png"></p></div></div><br><p>  <a href="">Benchmark</a> </p><br><div class="spoiler">  <b class="spoiler_title">Useful for the developer:</b> <div class="spoiler_text"><p>  <a href="https://youtrack.jetbrains.com/issue/IDEA-138456">https://youtrack.jetbrains.com/issue/IDEA-138456</a> <br><del>  IDEA-138456 </del>  New inspection: Collection.addAll () replaceable with parametrized constructor <br>  <strong>Fixed at 142.1217</strong> </p><br><p>  <a href="https://youtrack.jetbrains.com/issue/IDEA-178761">https://youtrack.jetbrains.com/issue/IDEA-178761</a> <br><del>  IDEA-178761 </del>  Inspection 'Collection.addAll () replaceable with parametrized constructor' should not be turned on by default <br>  <strong>Fixed in 2017.3</strong> </p></div></div><br><h4 id="udalenie-iz-arraylist-a">  Remove from <code>ArrayList</code> </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { list.remove(from); }</code> </pre> <br><p>  The problem with the implementation of the <code>List::remove</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ Objects.checkIndex(index, size); modCount++; E oldValue = elementData(index); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numMoved = size - index - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numMoved &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { System.arraycopy(array, index + <span class="hljs-number"><span class="hljs-number">1</span></span>, array, index, numMoved); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- } array[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> <br><p>  Decision: </p><br><pre> <code class="java hljs">list.subList(from, to).clear();</code> </pre> <br><p>  But what if in the source code the remote value is used? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed); }</code> </pre> <br><p>  Now you need to first go through the cleared sublist: </p><br><pre> <code class="java hljs">List&lt;String&gt; removed = list.subList(from, to); removed.forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::use); removed.clear();</code> </pre> <br><p>  If you really want to delete in the cycle, then changing the direction of passage through the list will help ease the pain.  Its meaning is to move fewer elements after cleaning the cell: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   , . .       for (int i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed, i); } //  , . .    for (int i = to - 1; i &gt;= from; i--) { E removed = list.remove(i); use(removed, reverseIndex(i)); }</span></span></code> </pre> <br><p>  Let's compare all three ways (under the columns there is the% of elements to be deleted from the list of 100): </p><br><div class="spoiler">  <b class="spoiler_title">Java 8</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/4h/ii/tq/4hiitqg5a7d3bk6lxi8od422yky.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Java 9</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ow/mo/ty/owmotysgwdqquagklf1yhlrquz0.png"></p></div></div><br><p>  By the way, did someone notice the anomaly? </p><br><div class="spoiler">  <b class="spoiler_title">To behold</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/ni/s9/xmnis9jllk8rozgh8xacdneyhd8.png"></p><br><p>  If we delete half of all data, moving from the end, the last element is always deleted and no shift occurs: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayList public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) { // &lt;----     System.arraycopy(elementData, index+1, elementData, index, numMoved); } elementData[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> </div></div><br><p>  <a href="">Benchmark</a> </p><br><div class="spoiler">  <b class="spoiler_title">Useful for the developer</b> <div class="spoiler_text"><p>  <a href="https://youtrack.jetbrains.com/issue/IDEA-177466">https://youtrack.jetbrains.com/issue/IDEA-177466</a> <br><del>  IDEA-177466 </del>  Detect List.remove (index) called in a loop <br>  <strong>Fixed in 2018.2</strong> </p></div></div><br><p>  Conclusion: mass operations are often faster than single. </p><br><h2 id="oblast-vidimosti-i-proizvoditelnost">  Scope and performance </h2><br><p>  This code does not need special explanations: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- if (settings.leaveBothCategories()) { leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  We narrow the scope, which gives a minus 1 request: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Settings.leaveBothCategories()) { List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  And here the attentive reader should ask: what about static analysis?  Why did the ‚ÄúIdea‚Äù not tell us about the improvement on the surface? </p><br><p>  The fact is that the possibilities of static analysis are limited: if the method is complex (especially interacting with the database) and affects the general state, then the transfer of its execution can break the application.  A static analyzer is able to report very simple versions, the transfer of which, say, inside the unit will not break anything. </p><br><p>  As an ersatz, you can use the highlighting of variables, but, I repeat, use caution, since side effects are always possible.  You can use the <code>@org.jetbrains.annotations.Contract(pure = true)</code> <a href="http://mvnrepository.com/artifact/org.jetbrains/annotations">annotation</a> , available from the <a href="http://mvnrepository.com/artifact/org.jetbrains/annotations">jetbrains-annotations</a> library, to indicate methods that do not change state: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// com.intellij.util.ArrayUtil @Contract(pure = true) public static int find(@NotNull int[] src, int obj) { return indexOf(src, obj); }</span></span></code> </pre> <br><p>  Conclusion: most often, extra work only degrades performance. </p><br><h2 id="samyy-neobychnyy-primer">  The most unusual example </h2><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractCounter contractCounter; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- public int countContracts(Dto dto) { if (dto.isInvalid()) { return -1; // &lt;---- } return contractCounter.countContracts(dto); } }</span></span></code> </pre> <br><p>  This implementation opens a transaction even when no transaction is needed (quick return -1 from the method). </p><br><p>  All that needs to be done is to remove the transactionism inside the <code>ContractCounter::countContracts</code> , where it is needed, and remove it from the "external" method. </p><br><div class="spoiler">  <b class="spoiler_title">Compare the execution time for the case when -1 (ns) is returned:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8k/uu/lp/8kuulppcl4vli1c5ir-txozcemi.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Compare the memory consumption (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xp/du/ke/xpdukewr4nnooj2vtaktok4ngnm.png"></p></div></div><br><p>  <a href="">Benchmark</a> </p><br><p>  Conclusion: controllers and looking outward services should be freed from transactionalities (this is not their responsibility) and all the logic of input data validation that does not require access to the database and transactional components should be carried out. </p><br><h2 id="preobrazovanie-datyvremeni-v-stroku">  Convert date / time to string </h2><br><p>  One of the eternal tasks is turning a date / time into a string.  Up to the "eight" we did this: </p><br><pre> <code class="java hljs">SimpleDateFormat formatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(date);</code> </pre> <br><p>  With the release of JDK 8, we have <code>LocalDate/LocalDateTime</code> and, accordingly, <code>DateTimeFormatter</code> </p><br><pre> <code class="java hljs">DateTimeFormatter formatter = ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(localDate);</code> </pre> <br><p>  Let's measure its performance: </p><br><pre> <code class="java hljs">Date date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); LocalDate localDate = LocalDate.now(); SimpleDateFormat sdf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleDateFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdf.format(date); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dateTimeFormatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dtf.format(localDate); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Time (ns):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/zq/jq/sx/zqjqsxjevqpmuckdddvu4gysaoa.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memory (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9j/yq/sw/9jyqswjtyiwq3i8fkutenvyuj7g.png"></p></div></div><br><p>  Question: let's say our service receives data from the outside and we cannot refuse <code>java.util.Date</code> .  Will it be profitable for us to convert <code>Date</code> to <code>LocalDate</code> if the latter is faster converted to a string?  Calculate: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureDateConverted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ LocalDate localDate = toLocalDate(data.date); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.dateTimeFormatter.format(localDate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toLocalDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Time (ns):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/j5/ob/mf/j5obmfec_kvfivo46wat9rmf8e8.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memory (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hx/hm/on/hxhmon8ss12qyv9s4is6byoy164.png"></p></div></div><br><p>  Thus, the <code>Date</code> -&gt; <code>LocalDate</code> beneficial when using the "nine".  At the "eight", the costs of conversion will devour all the advantages of <code>DateTimeFormatter</code> -a. </p><br><p>  <a href="">Benchmark</a> </p><br><p>  Conclusion: take advantage of new solutions. </p><br><h2 id="eschyo-vosmyorka">  Another "eight" </h2><br><p>  In this code, we see obvious redundancy: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .collect(toList()) // &lt;----    ? .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><p>  Remove it: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Let's see how the performance has improved:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/un/mp/pf/unmppfr6sd8ybi3k7r7jrdsdfty.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Compare with the nine:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hc/rb/p9/hcrbp98qezjcm5fegv27cywcadu.png"></p></div></div><br><p>  Amazing isn't it?  Above, I argued that excess work degrades performance.  But we remove too much - and (suddenly) it gets worse.  To understand what is happening, take two iterators and look at them under a magnifying glass: </p><br><div class="spoiler">  <b class="spoiler_title">To uncover</b> <div class="spoiler_text"><pre> <code class="java hljs">Iterator iterator1 = items.stream().collect(toList()).iterator(); Iterator iterator2 = items.stream().iterator();</code> </pre> <br><p><img src="https://habrastorage.org/webt/rn/ah/kf/rnahkfz2qdyuw0k_cjeorqawqki.png"></p></div></div><br><p>  The first iterator is the usual <code>ArrayList$Itr</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Passing through it is simple:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cursor != size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkForComodification(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = cursor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= size) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(); } Object[] elementData = ArrayList.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= elementData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentModificationException(); } cursor = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (E) elementData[lastRet = i]; }</code> </pre> <br><p><img src="https://habrastorage.org/webt/ug/yb/pi/ugybpiiwmjj5-fbcazvmfdjd2tq.png"></p></div></div><br><p>  The second is more curious, it is <code>Spliterators$Adapter</code> , based on the <code>ArrayList$ArrayListSpliterator</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Going through it is harder</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// java.util.Spliterators$Adapter public boolean hasNext() { if (!valueReady) spliterator.tryAdvance(this); return valueReady; } public T next() { if (!valueReady &amp;&amp; !hasNext()) throw new NoSuchElementException(); else { valueReady = false; return nextElement; } }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/pf/5p/gj/pf5pgjkfhhfw__h8ie7m6oflxqq.png"></p></div></div><br><p>  Let's look at iterating through the <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> iterator: </p><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">15.64</span></span>% juArrayList$ArrayListSpliterator.tryAdvance <span class="hljs-number"><span class="hljs-number">10.67</span></span>% jusSpinedBuffer.<span class="hljs-keyword"><span class="hljs-keyword">clear</span></span> <span class="hljs-number"><span class="hljs-number">9.86</span></span>% juSpliterators$1Adapter.hasNext <span class="hljs-number"><span class="hljs-number">8.81</span></span>% jusStreamSpliterators$AbstractWrappingSpliterator.fillBuffer <span class="hljs-number"><span class="hljs-number">6.01</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">5.71</span></span>% jusReferencePipeline$3$1.accept <span class="hljs-number"><span class="hljs-number">5.57</span></span>% jusSpinedBuffer.accept <span class="hljs-number"><span class="hljs-number">5.06</span></span>% cllbir.IteratorFromStreamBenchmark.iteratorFromStream <span class="hljs-number"><span class="hljs-number">4.80</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">4.53</span></span>% cllbiIteratorFromStreamBenchmark$$Lambda$8<span class="hljs-number"><span class="hljs-number">.885721577</span></span>.apply</code> </pre> <br><p>  It can be seen that most of the time is spent on passing through the iterator, although by and large, we do not need it, because the search can be done in the following way: </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Compare with the rest:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rf/is/i0/rfisi0vsfoezlcvtd43h2lhlvfi.png"></p></div></div><br><p>  <code>Stream::forEach</code> clearly a winner, but this is strange: the <code>ArrayListSpliterator</code> is still the basis, but the performance of its use has improved significantly. </p><br><div class="spoiler">  <b class="spoiler_title">View profile:</b> <div class="spoiler_text"><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">29.04</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">22.92</span></span>% juArrayList$ArrayListSpliterator.forEachRemaining <span class="hljs-number"><span class="hljs-number">14.47</span></span>% jusReferencePipeline$3$1.accept <span class="hljs-number"><span class="hljs-number">8.79</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">5.37</span></span>% cllbiIteratorFromStreamBenchmark$$Lambda$9.<span class="hljs-number"><span class="hljs-number">617691115</span></span>.accept <span class="hljs-number"><span class="hljs-number">4.84</span></span>% cllbiIteratorFromStreamBenchmark$$Lambda$8.<span class="hljs-number"><span class="hljs-number">1964917002</span></span>.apply <span class="hljs-number"><span class="hljs-number">4.43</span></span>% jusForEachOps$ForEachOp$OfRef.accept <span class="hljs-number"><span class="hljs-number">4.17</span></span>% jusSink$ChainedReference.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">1.27</span></span>% jlInteger.longValue <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">53</span></span>% jusReferencePipeline.map</code> </pre> </div></div><br><p>  In this profile, most of the time is spent on ‚Äúswallowing‚Äù the values ‚Äã‚Äãinside the <code>Blackhole</code> .  Compared to the iterator, much of the time is spent directly on executing a Java code.  It can be assumed that the cause is a smaller proportion of garbage collection, compared with iterator iteration.  Check: </p><br><pre> <code class="java hljs">forEach:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span>,<span class="hljs-number"><span class="hljs-number">001</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">002</span></span> B/op iteratorFromStream:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">416</span></span>,<span class="hljs-number"><span class="hljs-number">004</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">006</span></span> B/op</code> </pre> <br><p>  And indeed, <code>Stream::forEach</code> gives you half the memory consumption. </p><br><div class="spoiler">  <b class="spoiler_title">Why was it faster?</b> <div class="spoiler_text"><p>  The call chain from the beginning to the ‚Äúblack hole‚Äù looks like this: </p><br><p><img src="https://habrastorage.org/webt/2f/5w/1y/2f5w1ydxlo5oomf8bfmhbqtynze.png"></p><br><p>  As you can see, the <code>ArrayListSpliterator::tryAdvance</code> call disappeared from the chain, and <code>ArrayListSpliterator::forEachRemaining</code> appeared <code>ArrayListSpliterator::forEachRemaining</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayListSpliterator public void forEachRemaining(Consumer&lt;? super E&gt; action) { int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) { if ((hi = fence) &lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) { for (; i &lt; hi; ++i) { @SuppressWarnings("unchecked") E e = (E) a[i]; // &lt;---- action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); }</span></span></code> </pre> <br><p>  The high speed of <code>ArrayListSpliterator::forEachRemaining</code> achieved by using the entire array in a <code>ArrayListSpliterator::forEachRemaining</code> method call.  When using an iterator, the passage is limited to one element, so we always run into <code>ArrayListSpliterator::tryAdvance</code> . <br>  <code>ArrayListSpliterator::forEachRemaining</code> has access to the entire array and <code>ArrayListSpliterator::forEachRemaining</code> over it with a counting cycle without additional calls. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Important note</b> <div class="spoiler_text"><p>  Note that mechanical replacement </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items .stream() .map(Long::valueOf) .collect(toList()) .iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterator.hasNext()) { bh.consume(iterator.next()); }</code> </pre> <br><p>  on </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><p>  not always equivalent, since in the first case we use a copy of the data for the passage, without affecting the stream itself, while in the second case the data is taken directly from the stream. </p></div></div><br><p>  <a href="">Benchmark</a> </p><br><p>  Conclusion: in dealing with complex data representations, be prepared for the fact that even the "iron" rules (too much work hurts) stop working.  The example above shows that the seemingly superfluous intermediate list gives an advantage in the form of a faster implementation of the search. </p><br><h4 id="dva-podvoha">  Two tricks </h4><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays .asList(trace) .subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, depth) .toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackTraceElement[newDepth]); <span class="hljs-comment"><span class="hljs-comment">// &lt;----</span></span></code> </pre> <br><p>  The first thing that catches your eye is a foul "improvement", namely, the transfer to the <code>Collection::toArray</code> array of nonzero length.  <a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">Here it is</a> very detailed why it hurts. </p><br><p>  The second problem is not so obvious, and for its understanding it is possible to draw a parallel between the work of the reviewer and the historian. </p><br><div class="spoiler">  <b class="spoiler_title">This is what Robin Collingwood writes about:</b> <div class="spoiler_text"><p> , ,   []       ‚Äì  . <strong>             </strong> .   , <strong>    ,    </strong> ... </p></div></div><br><p>       <strong></strong>      .      : </p><br><p> 1)     <br> 2)    <br> 3)       </p><br><p>      ,      : </p><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays.copyOf(trace, depth); <span class="hljs-comment"><span class="hljs-comment">//    0 //  StackTraceElement[] newTrace = Arrays.copyOfRange(trace, 0, depth); //   0</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xg/ia/-8/xgia-8mdesgh-cpqm1cla0n8zz4.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="strimoz-golovnogo-mozga">    </h4><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.stream().allMatch(set::contains); <span class="hljs-comment"><span class="hljs-comment">//     ?</span></span></code> </pre> <br><p>       ,      ,    : </p><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set.containsAll(list);</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/3c/tc/pr/3ctcprq3scexhaaifc9hiywbj98.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="nenuzhnye-obyortki">   </h4><br><p>  : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNameLoader</span></span></span><span class="hljs-class"> </span></span>{ String[] loadFileNames(); }</code> </pre> <br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : asList(loader.loadFileNames())) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----   use(str); } }</span></span></code> </pre> <br><p>   ,   <code>forEach</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : loader.loadFileNames()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----    use(str); } }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pa/kn/hc/paknhcvrp1cf7g-fw3cn4euxrse.png"></p></div></div><br><p> <a href=""></a> </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <a href="https://youtrack.jetbrains.com/issue/IDEA-182206">https://youtrack.jetbrains.com/issue/IDEA-182206</a> <br><del> IDEA-182206 </del> Simplification for Arrays.asList().subList().toArray() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://youtrack.jetbrains.com/issue/IDEA-180847">https://youtrack.jetbrains.com/issue/IDEA-180847</a> <br><del> IDEA-180847 </del> Inspection 'Call to Collection.toArray with zero-length array argument' brings pessimization <br> <strong>  2018.1</strong> </p><br><p> <a href="https://youtrack.jetbrains.com/issue/IDEA-181928">https://youtrack.jetbrains.com/issue/IDEA-181928</a> <br><del> IDEA-181928 </del> Stream.allMatch(Collection::contains) can be simplified to Collection.containsAll() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://youtrack.jetbrains.com/issue/IDEA-184240">https://youtrack.jetbrains.com/issue/IDEA-184240</a> <br><del> IDEA-184240 </del> Unnecessary array-to-collection wrapping should be detected <br> <strong>  2018.1</strong> </p></div></div><br><p> :       : </p><br><ul><li>  </li><li>  </li><li>    </li></ul><br><p>       ,   ,         ,     .  ,   :         "" (        ),       ""     (      ),        . </p><br><p> ‚Üí <a href="https://github.com/stsypanov/logeek-night-benchmark">   </a> </p><br><p> ‚Üí <a href="https://github.com/stsypanov/logeek-night-benchmark/tree/master/results">  </a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/423305/">https://habr.com/ru/post/423305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423295/index.html">The most useful mobile development conference</a></li>
<li><a href="../423297/index.html">From Android developer to DevOps</a></li>
<li><a href="../423299/index.html">Application Coordinator in iOS applications</a></li>
<li><a href="../423301/index.html">Selective IP ban on cloudy Windows Server 2012 via RDP</a></li>
<li><a href="../423303/index.html">AI, practical course. Emotion Based Musical Transformation</a></li>
<li><a href="../423307/index.html">GitHub Pull Requests in Visual Studio Code</a></li>
<li><a href="../423309/index.html">DBMS transactions</a></li>
<li><a href="../423311/index.html">Partnership Naviaddress and ACTUM</a></li>
<li><a href="../423313/index.html">Attach to I2C. Make a simple logic analyzer</a></li>
<li><a href="../423315/index.html">Universal Links Theory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>