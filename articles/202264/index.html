<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for solutions in logic games on the example of Gomoku</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In general, we are not talking about the classical Gomoku , but about the Russian variation ‚Äúfive in a row‚Äù. You have a piece of paper ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for solutions in logic games on the example of Gomoku</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In general, we are not talking about the classical <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BC%25D0%25BE%25D0%25BA%25D1%2583">Gomoku</a> , but about the Russian variation ‚Äúfive in a row‚Äù.  You have a piece of paper in the box.  The rules of the game are the same as in the tic-tac-toe.  The only difference is that it is necessary to build a line of 5 elements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/571/0a3/040/5710a30403623c4c94a61da196e35f16.png" alt="image"><br><br>  For such a simple game, we listened to more than one lecture.  It always annoyed me that my brilliant strategy was being broken about my own carelessness.  Do not worry, I thought, I'll write a program that will not make mistakes, then I'll show them all!  Just spit!  A couple of cycles, however, it is necessary to tinker with the user interface, but for a couple of evenings I will manage.  10 years have passed since the graduation from the institute, and I have not written the program yet. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Brute force </h4><br>  The idea is that we have no evaluation function, no heuristics.  We simply arrange the elements on the field until we reach five in line.  Immediately it becomes clear that this method is not suitable.  Each turn generates an average of 80 new positions.  By 6 moves, the number of options increases to 80 ^ 6 = 2 ^ 37 options, which is too much. <br><br><h4>  Alpha beta cut </h4><br>  Alpha-beta pruning is what usually limits the course of game theory at the institute.  Applies ... honestly difficult to come up with a game in which it can be applied.  The idea is to use the valuation function as a value criterion.  The problem is that we are only interested in winning or losing.  And we are completely satisfied with the victory for the greater number of steps.  From here comes an important feature: in <b>order to prove victory from a certain position, it is enough to find one move, and in order to prove defeat, it is necessary to go through all possible moves</b> . <br><br><h4>  Solution from the end </h4><br>  The idea is to recognize patterns that lead to victory.  Analogy with chess programs - endgame base. <br><div class="spoiler">  <b class="spoiler_title">This can be done for the game "5 in a row"</b> <div class="spoiler_text">  The game always ends with a line of 5 elements.  If we go back a step, we get the following combinations: <br><img src="https://habrastorage.org/getpro/habr/post_images/6dd/b1a/058/6ddb1a058bf4a7ec40039f77d2362b7f.png" alt="Step to victory"><br><br>  If you go back two steps, we get: <br><img src="https://habrastorage.org/getpro/habr/post_images/89a/3ef/1e3/89a3ef1e3260abe9d635baa938a7d23e.png" alt="Two steps to win"><br><br>  Lines can be combined: <br><img src="https://habrastorage.org/getpro/habr/post_images/446/02c/6d6/44602c6d654b9c7843e7730ba56d66c8.png"><br><br>  The entire set of combinations can be assembled into a search tree, which unfolds around the search point. <br></div></div><br>  This solution was implemented, but it worked slowly.  So slowly that I could not debug the code.  The problem is a lot of combinations.  Two steps back is all that can be stored in memory. <br><br><h4>  Calculation vs.  storage </h4><br>  After such a file, I decided not to store ready-made templates, but to find the lines in one or two moves before winning ‚Äúon the fly‚Äù.  Surprisingly, it worked quite well.  Conclusion: it is <b>sometimes better to decide than to store</b> . <br>  In order to optimize, I limited the number of possible moves to two adjacent cells around existing ones.  In general, it is far from a fact that effective moves are limited to these cells, but so far my assumption is in good agreement with practice. <br><br><h4>  In depth or in width </h4><br>  Search in depth is preferable from the point of view of memory, but often goes too deep, although the victory is located nearby in the next branch.  A wide search does not have this drawback, but requires a lot of memory to store already solved positions.  Usually used forced depth search: the search goes down to a fixed depth, but for promising positions the depth increases. <br><br><h4>  Evaluation function </h4><br>  Search speed is very sensitive to the traversal order.  To do this, they introduce a function that evaluates the ‚Äúattractiveness‚Äù of moves and organizes them by the criterion of such attractiveness. <br><div class="spoiler">  <b class="spoiler_title">Evaluation function of the game "5 in a row"</b> <div class="spoiler_text">  There are lines to which the enemy must respond. <br><br>  Open four.  Guaranteed victory, if the opponent does not win on the next turn. <br><img src="https://habrastorage.org/getpro/habr/post_images/134/d78/e4f/134d78e4f2c9b432bedc4d2bf80359cd.png" alt="image"><br><br>  Closed four.  One move to win. <br><img src="https://habrastorage.org/getpro/habr/post_images/11e/8ef/51c/11e8ef51cb3eb514f6cd2a4103bb8d09.png" alt="image"><br><br>  Open three.  Two moves to win. <br><img src="https://habrastorage.org/getpro/habr/post_images/5f6/8b2/baf/5f68b2baff09d70488f71317879f3747.png" alt="image"><br><br>  Priority lines in that order.  The stroke estimate increases if several lines of different directions converge at one point.  Also taken into account the enemy line and defensive moves on them. <br></div></div><br><br>  Works pretty well.  The program plays at novice level.  These are 2 levels of search in width and 3 levels of the forced search in depth.  Unfortunately, this is completely insufficient to win always.  At this point, my ideas ended, and I already thought that nothing could be improved significantly.  If I had not stumbled upon the work of a certain <a href="http://en.wikipedia.org/wiki/Victor_Allis">Louis Victor Allis</a> . <br><br><h4>  Mr.  Allis and Treat-Space search </h4><br>  In 1992  Mr. Alice (Allis), using 10 SUN SPARC workstations, proved for the classic Gomoku with a field of 15X15 that the crosses always win.  The stations had 64 and 128MB RAM, 200MB swaps.  Since  they used the Vrije Universiteit station in Amsterdam, their processes started only at night.  The processes that did not finish during the night were killed in the morning.  All it took was 1000 CPU / hours and a week of time. <br><br><div class="spoiler">  <b class="spoiler_title">How the hell did he do it?</b> <div class="spoiler_text">  A bit of theory from the original article.  Gomoku is a divergent game with complete information and sudden death. <br><ul><li>  <i>Diverging</i> ( <i>diverging</i> ) is a game in which the number of possible positions increases with the number of pieces on the board. </li><li>  By complete information ( <i>perfect-information</i> ) is meant that both opponents know everything about the current state of the game.  Examples of games with complete information: checkers, chess.  Examples of games with <i>imperfect-information</i> fool, preference. </li><li>  A <i>sudden death</i> means that the game can end suddenly when there are still pieces on the board or there is free space.  Chess is an example of a game of sudden death.  A game where this does not happen - checkers. </li></ul><br>  The upper limit of the number of states ( <i>state-space complexity</i> ) is <sup>3,225</sup> ~ = <sup>10,105</sup> .  10 <sup>70</sup> - the complexity of the decision tree ( <i>game-tree complexity</i> )) if there is an assumption that the game lasts 30 moves on average and has <i>225 - i</i> possible moves on the <i>i-th</i> move. <br>  Watching professional players, Alice concluded that a person is primarily looking for a chain of threats (the <i>threat sequence</i> ) that could lead to victory.  At the same time, the opponent‚Äôs moves are almost completely ignored.  Only if a suitable chain is found, is the possibility of a counterattack checked. <br>  The heuristics of Treat-Space search is built on this fact.  For each offensive line with a attack cell ( <i>gain</i> ), which is based on existing moves ( <i>rest squares</i> ), we respond <b>with all</b> defense moves ( <i>cost squares</i> ) at <b>once</b> .  After this, we check whether it is still possible to build a chain of threats that leads to victory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94c/1cc/cf0/94c1cccf05451f8b54c85c9d59f960ff.png"><br>  <i>The beginning of the chain of threats and its development</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bf/524/2cb/9bf5242cbbcc85cd2c80aa7f66bc8370.png"><br>  <i>Analysis of the chain of threats.</i>  <i>On the first threat, we respond immediately with three defensive moves.</i>  <i>Despite the response moves, it is possible to build an open four.</i> <br><br>  Such heuristics allow us to effectively search for chains of threats that the adversary is no longer able to influence.  The answer at the same time with all the defensive moves makes it possible to make the search almost linear, rather than combinatorial.  Of course, each chain must be checked for the possibility of counterattacks. <br></div></div><br><br>  Unfortunately, how to check the chains for the possibility of a counterattack, <s>I did not understand the</s> author.  So I had to sculpt my decision on my knee.  At the moment, this is the slowest and dirtiest place in the calculation. <br><br><h4>  Zero stroke heuristics </h4><br>  Best described <a href="http://frayn.net/beowulf/theory.html">here</a> . <br>  The idea comes down to the fact that you miss your turn, allowing the opponent to make a move.  If your position is still strong, then this state is probably not the one the enemy will allow you to hit.  This saves one turn in depth when analyzing. <br><br>  Unfortunately, I have not figured out how to safely and effectively use it, so I don‚Äôt use it yet. <br><br><h4>  Crosses win and decision tree </h4><br>  With the Treat-Space search heuristics, the program plays quite strongly, but it still loses to a strong player.  This is because the program is able to ‚Äúsee‚Äù 4 to 16 moves ahead.  Sometimes, especially at the beginning of the game, it is more profitable to set moves for the future, rather than try to develop a local advantage.  A person uses his experience to see directions that will give an advantage in the long term. <br>  So we approach another problem of computer programs - <i>lack of experience</i> .  To compensate for this, a base of openings is used in chess programs.  You can do this kind of game "Five in a row."  The problem is that <s>I did not master the Homoku theory</s> that the theory for this game is not as well developed as for chess. <br><br>  Therefore, there is a natural desire to go over the decision tree entirely to find the best moves.  As a bonus, you can get proof that the crosses win, and the optimal sequence as a bonus.  Actually, this is what Professor Alice did in his research. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d57/412/987/d57412987afb7b6bbf4c813d9d9cf642.png"><br>  <i>The longest chain in a perfect game for gomoku without restrictions</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/de7/a39/9e1de7a39370c3c5ecc55f2ad58c10cd.png"><br>  <i>The longest chain in the perfect game for gomoku with restrictions</i> <br><br>  According to the theory, the 19X19 field gives the crosses a greater advantage than 15X15, so everything should be even easier for an unlimited field. <br><br><h4>  Distributed computing on the knee </h4><br>  Immediately it becomes clear that on one machine this does not count.  On the other hand, the task is very well parallel. <br><div class="spoiler">  <b class="spoiler_title">So, it is necessary to raise the infrastructure for distributed computing.</b> <div class="spoiler_text">  I quickly blinded the server based on nginx, php-fastcgi, wget, scripts and my programs. <br>  I had to tinker with the base, its size was assumed to be very large and access to the elements occurs very often.  I had a significant experience with PostgreSQL, but it did not suit me, because, even if the data fit in the same place on the disk, this DBMS still places them at the end of the table due to transactionality.  Thus, if one element changes frequently, then the table swells up quickly.  It is necessary to vacuum it, but on a loaded server this is problematic.  Instead, I gave birth to my bike, in which the mix of the AVL tree and the directory structure was used as the base.  When a tree exceeds a certain limit, it is divided into two in different directories.  It turns out such a hashodree.  In practice, this was a bad decision.  First, the AVL tree is a bad choice for working with a disk.  At the moment of separation, the data comes in a new tree in sorted order - this is the worst option for balancing.  Secondly, practice has shown that accumulating such a large amount of computing resources to make the base a bottleneck is quite problematic, and PostgeSQL would suit me completely. <br>  As compute nodes, I planned to use "cheap" cloud services.  I used both Scalaxy and Amazon.  Suddenly, I realized that <b>computing costs real money</b> .  Scalaxy gave 16 cores to the server, it seemed to cost me $ 10 / day.  In this case, 16 processes worked somehow very strained.  On Amazon, I tried to start up 2 instances of 8 cores each, and this also cost a substantial amount.  I also tried to take in quantity and start up 50 microinstants, which cost me $ 40 a day.  According to my feelings, they worked worse than 2 servers with 8 cores each.  It made me wonder how much calculations really cost.  At that time, I needed 10,000 cores.  Suppose we got the iron for free.  Suppose we have 2-processor 8-core Xeon, with hyper trading.  Total we need 10,000 / (2 * 8 * 2) = 312.5 servers.  Suppose such a server eats 200W.  Total per day we need to pay 312.5 * 200W * 24h = 1.5MW * h * 0.11875 $ / (kW / h) = 178.125 $ / day. <br>  Therefore, I <s>wanted to get computing resources on the ball</s> turned to the free Internet community.  A year ago, thanks to <a href="http://rsdn.ru/forum/alg/4851738">the RSDN community</a> , a trial launch started. <br>  As I noticed, on private machines the calculation goes much faster than on similar virtual servers in configuration.  So it seems that <s>cloud services make us a little fooled</s> virtualization adds its overhead. <br>  Anticipating the question why I didn‚Äôt use BOINC, I‚Äôll answer this way: it‚Äôs just inconvenient for me to go there with my project.  People are looking for a cure for cancer, looking for the Higgs boson, and here I am with some strange task. <br>  According to the theory, the number of variants expands first, then begins to narrow due to the cutting off of solved branches.  Was considered a position with 7 moves.  The calculation was that by the 8th move the growth in the number of options, if not reduced, then at least the speed of this growth will slow down. <br></div></div><br><br>  The calculation lasted about a month.  Unfortunately, the miracle did not happen.  The number of options grew steadily.  The calculation had to stop.  Even on states with 17-35 moves, the decision tree is also steadily expanding. <br>  The reason for this lies in the search in width.  We started searching in width to find non-obvious solutions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf2/65b/fd3/cf265bfd385e6e056896a561e4a7d241.png"><br><br>  To do this, you have to bypass all the options, even the most idiotic. <br><br><h4>  Algorithm of an ant colony </h4><br>  My ideas ended, and I abandoned the project for almost a year, until my colleague suggested that I use <a href="http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">the ant colony algorithm</a> . <br>  The idea is that we randomly choose the path that we will explore from a certain state.  The probability of a move depends on the ratio of the number of victories / losses of all descendants of a given branch. <br>  It works pretty well.  The only problem is that we are not interested in how likely the opponent is losing, if there is at least one position in which he can win. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/eed/6e1/679eed6e1baa45e87ace363dfa3d83ed.png"><br><br><h4>  Ask your neighbor about winning </h4><br>  Honestly, I do not know the name of this heuristic.  It is based on the fact that for many cases the opponent‚Äôs response moves can not significantly affect the gain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a8/758/75c/5a875875c89bd2c9a04364cd100436ac.png"><br>  <i>We are making a ‚Äúpromising‚Äù move by zero.</i>  <i>Soon we find that it leads to defeat in 17 moves.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b66/0e4/b8d/b660e4b8dd56e0f825aac86415a62110.png"><br>  <i>We make the next ‚Äúpromising‚Äù move by zero from the same state.</i>  <i>We find that the crosses win again, and with the same move</i> <br><br>  For different moves by zero, we have the same reciprocal move with a cross.  You can simply increase the weight of the already known winning moves to reduce the number of moves being sorted. <br>  This heuristic, combined with the ant colony algorithm, gives a huge performance boost.  It is so effective that for the day of work it finds resolved positions starting from the fourth move. <br><br><h4>  Base debuts and man </h4><br>  If we want to prove that the crosses start and win, it is enough for us to make one perfect move with a cross, for each possible move with a zero.  This is equivalent to halving the overall search depth.  In some cases, as in the picture above, the ideal moves are obvious to a person. <br>  I plan to add the ability to selectively force the computation of certain branches in the hope that this will give me a significant increase in performance. <br><br><h4>  And let's rewrite the assembler </h4><br>  In none of the projects I tried to make so many optimizations and did not experience so much disappointment. <br>  The facts are inexorable: the constant has no meaning compared to the overall complexity of the algorithm.  Let me remind you that each position gives an average of 80 new positions.  To go one step further, we must increase the speed of the program by 80 times !!! <br><br>  So, a selective list of what I have undertaken: <br><ul><li>  Incremental search for effective empty cells.  When deepening the search, only empty cells are added around the last turn.  To do this, I had to enter the state of the field in depth and quite a lot of code to support them. </li><li>  Where possible, I have made arrays of the type std :: vector &lt;&gt; static, in order to avoid permanent memory allocation for such arrays. </li><li>  To avoid constant allocation of memory for tree nodes, reference counts for shared_ptr nodes and fields within the structures that implement these nodes, I implemented a pool of nodes.  In order not to break anything, this pool of nodes had to be used very carefully.  No increase in performance was found at all, and with great joy I was able to mow down this code. </li></ul><br>  By incredible tricks and complication of the code I managed to increase the speed by 2.5 times.  Feel the difference between acceleration 2.5 times and 80 times? <br>  Often offer to do the calculation on the video card using CUDA.  The problem is that GPUs are built on SIMD architecture, and they really don‚Äôt like branching, and branching is, in fact, a way of working on a tree.  The only thing for which they can be applied is the search for threatening lines from one or several positions at the same time.  The practical effect of this is still dubious. <br><br>  Although algorithmic optimization itself has not yet been exhausted.  And it is quite possible that one modern smartphone is enough for the task of such complexity. <br>  So the algorithms rule! <br><br><h4>  Thanks </h4><br>  I am grateful to Dr. <a href="http://www.quintiqcareers.com/blog-author/victor-allis.html">Louis Victor Allis</a> for his ability to solve unsolvable problems. <br>  I am immensely grateful to all those people from the RSDN community who helped and continue to help me cheat on this task using my resources. <br>  I am grateful to Rustam for the idea of ‚Äã‚Äãan ant colony algorithm. <br>  I am grateful to Vanya for the stylistic and spelling correction of the article.  I hope I did not miss anything from your edits. <br><br><h4>  References and literature </h4><br>  <a href="http://frayn.net/beowulf/theory.html">Computer Chess Programming Theory</a> <br>  <a href="http://www-public.it-sudparis.eu/~gibson/Teaching/CSC4504/ReadingMaterial/KnuthMoore75.pdf">Knuth DE, Moore RW An Analysis of Alpha-Beta Priming</a> <br>  Allis, LV (1994).  Ph.D.  Thesis, University of Limburg, Maastricht. <br>  Allis, LV, Herik, HJ van den, and Huntjens, MPH Go-Moku and Threat-Space Search <br>  <a href="https://habrahabr.ru/users/gorkoff/" class="user_link">GORKOFF</a> <a href="http://habrahabr.ru/post/143552/">About AI in intellectual games</a> <br>  <a href="https://habrahabr.ru/users/latobco/" class="user_link">Latobco</a> <a href="http://habrahabr.ru/post/111210/">Some ideas for writing artificial intelligence for chess</a> <br>  <a href="https://code.google.com/p/five-in-line/">Project source code</a> <br>  <a href="http://fiveinline.info/">Project website</a> </div><p>Source: <a href="https://habr.com/ru/post/202264/">https://habr.com/ru/post/202264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202252/index.html">aIs Tips</a></li>
<li><a href="../202254/index.html">Google BBS Terminal - how google could look like in the 80s</a></li>
<li><a href="../202258/index.html">How to invest $ 100,000 in your own karma (part 1)</a></li>
<li><a href="../202260/index.html">4 billion years of Mars history in two minutes</a></li>
<li><a href="../202262/index.html">iPad Air with LTE support from MegaFon goes on sale</a></li>
<li><a href="../202268/index.html">Features reinstall preinstalled Windows 8</a></li>
<li><a href="../202272/index.html">iCity is a virtual city that nobody cares about. Post Mortem to an internal startup</a></li>
<li><a href="../202274/index.html">Width of table columns or when browsers lie</a></li>
<li><a href="../202276/index.html">In-ear headphones: all about them</a></li>
<li><a href="../202278/index.html">Video surveillance in the countryside via 3G Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>