<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sending push notifications to Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have been using VKontakte mobile applications for the last year (even if not official ones), then this material will reveal some data on how pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sending push notifications to Go</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/00e/ec7/c71/00eec7c716ec4f78b3bc859870038a44.png" align="right"><br>  If you have been using VKontakte mobile applications for the last year (even if not official ones), then this material will reveal some data on how push notifications work for us.  The gun is implemented in the Go language, and sends up to 9 billion guns per day to four target platforms: GCM, APNS, MPNS, WNS. <br><br>  In this post I decided to talk about the overall architecture of the gun, problems and workarounds, loads and performance solutions.  Many letters and little code. <br><a name="habracut"></a><br>  The architecture is simple: some event occurs, you need to notify N'noe number of recipients about it, and the contents of the push are personalized.  A pack of pushups is formed for each recipient (for all attached devices) and is added to the send queue. <br>  A gun should get these pushes from there, send it to the right place, and update the statistics. <br><br>  From the queues, you can only get through the external API, which gives packs of pushes only for the requested platforms (this will be needed later).  All platforms handles one process, distributing the pushes by handlers who already know what to do with their type and how. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/cce/264/49a/cce26449aaa34cc082961c1f7e64634d.png"><br>  The scheme is simplified: the corresponding number of links should go to and from the grouped blocks, and not like on the diagram one by one. <br><br><h3>  Getting push from API </h3><br>  Since the only way to get push is an external API with access via HTTPS, the receiving works simply via http.Client with an increased MaxIdleConnsPerHost to support keep-alive.  Several gorutin, sharing this common http.Client, constantly knocking on the API for a fresh pack of pushes.  If a full pack arrives (about 1-3k pushing) - the next request leaves immediately, if it is much less than they wanted - the request leaves with a short pause. <br>  Here we catch two birds with one stone: we give queues to accumulate, or, if the problem is in the external node that started to slow down, we reduce the load on it.  If the requests do not pass at all, or freeze, then after a certain period (about a couple of minutes), close all connections and create a new http.Client object. <br><br>  As a result, we obtain a constant stream of fresh data for processing, distributed over the target platform to the appropriate queues (normal buffered channels). <br>  At the same time, the queues are monitored, and if what queue gets clogged up very much (more than 50%), then the dispatcher stops requesting this type from the API. <br><img src="https://habrastorage.org/files/fa3/53b/dd9/fa353bdd937e4d2b877d9c9e052e252e.png"><br><br><h3>  Shippers push </h3><br>  The logic of pushing pushes varies between platforms, but somehow they implement a common interface that unites them into pools of workers. <br><br>  The size of these pools is controlled by the general connection manager, which monitors the size of the channels received by the push.  When the occupancy is exceeded in excess of 10% of the capacity of the channels, the manager expands the pool to the extent allowed in the config for the specific platform and mobile application registered as the recipient of the push. <br>  The more valuable the application is, the more it can be :) This would not have happened if it had not been necessary to send out pushes to a bunch of various third-party applications, yes, not all of whom follow their certificates and current registration of applications. <br><br>  Increasing the capacity of pools is performed in steps (not one at a time, but in batches), with a minimum time between two extensions, so that the newly created ones can enter the working rhythm.  In the config, the maximum limits are very high, in case of massive problems (somehow, ~ 80% of the tillers managed to break down before delivery delays started, as the others pulled more than their limits on themselves). <br><br>  We need a lot of connections, and it was not done without increasing the umilit -n to a level of&gt; 10k descriptors.  Well, in Go, we tighten the limits right up to the allowed maximum, something like this: <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rLimit syscall.Rlimit <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rLimit.Cur &lt; rLimit.Max { rLimit.Cur = rLimit.Max syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit) }</code> </pre> <br><br>  The common channel of a specific target platform (gcm, etc.) is divided into multiple channels (and pools of workers for their processing) for each application registered with us.  Special gorutiny scatter the incoming flow of push through the channels of specific applications, until one of them begins to get clogged.  This is where the scaling of pools comes in, restocking the workers for a particular application.  If there is no place to grow, then there are two options: a problem with a critical application for us or not. <br>  In the case of an important application, we simply stop quitting the incoming channel of the push, it starts to get clogged up, as the workers receive the push from the API, and simply remove the specific platform from their requests.  And the pushes are either redistributed along other fluffs, or the queue begins to grow, and this is already visible in the monitoring. <br>  And if the application is not particularly important, and the limits for it are exhausted, then alas, the fluffs will be discarded without processing (but these drops will appear in the statistics). <br><br>  Internal statistics are also kept (within the application) by the number of problems with specific applications (certificate curves, server connection drops, timeouts when sending, etc.) and if the patience cup is exceeded, such applications get a temporary ban - all push files are discarded without processing all the time of action ban. <br>  This is a very useful feature for the case of third-party applications-one-day or unexpectedly popular applications that do not have normal certificates, and they generate more limits on target platforms.  There were cases when we ourselves wrote to the representatives of these applications and hinted to them that it would be good for them to finish this part in order to receive pushy normally. <br><br>  And, of course, you need to do everything in the name of keep-alive and certificate caching, otherwise the application will instantly be a stake, because there will always be interaction errors and there will be no way to reconnect. <br><br>  All workers have internal re-send buffers in case of failure, which we consider not fatal (request timeout, or 502 response code, for example).  It looks like this: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> push := &lt;-mainChan: send(push) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> push := &lt;-resendChan: send(push) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... } } func send(push Push) { if !doSmth(push) { resendChan &lt;- push } }</span></span></code> </pre><br>  Due to the absence of a guarantee in the order of choosing from several options in select, we obtain an alternate selection of both channels.  Above this, there are still limits on the number of re-shipments, timeouts before re-shipments, but this is already beyond the scope of the material. <br><br><h3>  APNS </h3><br><img src="https://habrastorage.org/files/c28/439/05a/c2843905a6d54ad4bc9861502d2b4af1.png" align="right"><br>  Most of all (for the time being?), Work differs in fluffs for apple products, where communication with the remote side occurs via tls connection with sending binary packages. <br><br>  According to the documentation, an error message (if such an error occurred, for example, an old authorization or an incorrectly formed request) should arrive at the same connection later. <br>  Since  waiting for a response (which is usually not) for each request is too slow, then you have to put all the sent pushes and a little extra information into separate lists of sent, but not confirmed pushes (using list.List).  And wait for an answer.  How long to wait is also not very clear.  In this case, the waiting time is selected in 2 seconds (less, it happened, was not enough). <br><br>  When we receive a response, we will know the push identifier (transmitted with each packet) with which some error occurred, or all is well (yes. There is such an answer).  Accordingly, all the pushes to the specified can be considered confirmed in the delivery, specifically this push is discarded or sent again.  All pushes after the specified one remain in the list until the next error message, or after a timeout.  Pushes that have lain in the queue for more than 2 seconds are considered ‚Äútimed out‚Äù. <br><br>  Plus, there is also a separate connection with Apple servers, through which incoming packets with data on "unsubscribing" applications arrive to us.  It is processed by a separate gorutinka, one for each client application. <br><br>  As a result, we get an endless shifting of push between the receiving channels, the queues of unconfirmed and re-resending (it can occur many times for each push). <br><br>  To this we can add that sometimes errors come that are not described in the documentation.  Or (most popular) the connection is broken without any error notification.  Beauty is the same) <br><br>  The implementation pumps approximately (this is only the number of delivered or discarded, not all) 1.4 billion apns of push a day (~ 30k-33k per second during peaks) on a laptop with a mobile i7-4500U processor (in the name of tests, of course). <br><br>  <i>But, as I recently learned, Apple plans to implement the scheme, like others - through http requests.</i>  <i>We'll see.</i> <br><br><h3>  GCM </h3><br>  The most adequate platform.  The logic of the workers was literally written in 1-2 days and since then has simply worked.  We create http.Client with MaxIdleConnsPerHost more (a few thousand), and send POST requests.  Servers respond quickly, the documentation is good - beauty.  At peak times, it comes close to 100k pushes per second. <br>  I did not try the XMPP option, but there will be time, I will try.  Although, "it works - do not touch". <br><br><h3>  MPNS, WNS </h3><br><img src="https://habrastorage.org/files/f1c/014/475/f1c01447567441eb8cd7a7a506b9ea00.png" align="right"><br>  This is the worst of all options, especially MPNS.  Then you have to wait for a response for 1-2 seconds (there are simply no words!), And getting the setracks instead of xml with an error (and this is after waiting for those 1-2 seconds). <br><div class="spoiler">  <b class="spoiler_title">sample response pieces</b> <div class="spoiler_text">  &lt;! DOCTYPE html&gt; \ r \ n &lt;html&gt; \ r \ n &lt;head&gt; \ r \ n &lt;title&gt; Insufficient memory of the program. &lt;\ / Title&gt; \ r \ n <br>  ... <br>  OutOfMemoryException: System.CodeDom.Compiler.Executor.ExecWaitWithCaptureUnimpersonated (SafeUserTokenHandle userToken, String cmd, String currentDir, TempFileCollection tempFiles, String &amp; TempTileCollection tempFiles, StF &amp; TempTile, TempDile, TempFileCollection tempFiles, String &amp; TempTile CMD, String currentDir, TempFileCollection tempFiles, String &amp; String cmd, String currentDir, TempFileCollection tempFiles, String &amp; String cmd \ r \ n <br>  ... <br>  This is an error page that has been configured to show verbose error messages using &lt;customErrors mode = \ "Off \" \ /&gt;.  Consider using &lt;customErrors mode = \ "On \" \ /&gt; or &lt;customErrors mode = \ "RemoteOnly \" \ /&gt; in production environments. <br>  ... <br></div></div><br>  Worst of all, sometimes this answer does not mean that the push was not accepted and delivered.  And re-sending from our side leads to the arrival on the device of two identical pushi.  And as it turns out, people are more upset by two pushing than their absence in principle. <br><br>  Separately, it is worth telling about TLS Renegotiation, which is required for sending with a certificate (without it, you quickly rest against the limits on sending), but it is not supported in Go, and generally it is drunk everywhere. <br><br>  For this you have to send a push through the cgo wrapper over curl.  But the solution is so-so on stability - every few million requests there is a chance to catch sigsegv somewhere inside the system library.  To work around this problem, working with curl through cgo was moved to a separate small (~ 400 lines) application for the same Go, operating on the principle: gun =&gt; "http server =&gt; https curl tls renego client" =&gt; MS server. <br>  Such applications run a separate small pool with its manager, monitor the fall.  These intermediate proxies respond to the main button with the response of external servers, as well as add grit to the headers for debugging and statistics: response time, proxy response code (in addition to the response code of the external server), and so on.  All this makes it possible to quite reliably send fluffs in an unstable environment. <br><br>  By the way, instead of MaxIdleConnsPerHost, we don‚Äôt forget to set CURLOPT_MAXCONNECTS more, otherwise we will not take off again on the CPU. <br><br>  <i>But it is in this platform that the text of the push and the badge (the number of the application icon) must be set by two different independent requests (and in WNS by three).</i>  <i>Feel free to multiply the above seconds of waiting and glitches by two (three) and move on ...</i> <br><br><h3>  Statistics collection </h3><br>  No matter how it all works, you need statistics.  And the more detailed the better. <br>  It monitors both the queue filling code (the one before the API), the work of the API methods, and the mailing applications themselves. <br><br>  The main characteristic is the dispatch time: how long does it take from the moment of pushing to the confirmed dispatch to the server of a specific site?  For fast GCM and APNS, the average time goes about 60-100ms for the entire processing path, for MPNS / WNS, how lucky: we cannot send MS servers faster than the MS servers work. <br><br>  Statistics are kept on: <br><ul><li>  the number of sent, dropped, returned error when sending, with overdue authorizations (they also need to send the tokens themselves, and drop them while they are still in the send queues, and not to try to send-receive the error again ‚Äî reinstall the connection); </li><li>  processing time: min / max / avg for each platform and each application separately; </li><li>  uptime of the process, use of cpu (divided by user, system, io, idle), number of open file descriptors, memory consumption (rss), time for running gc in total and min / max / avg of recent launches. </li></ul><br>  All this is collected and sent in batches all in the same API. <br><br>  However, it is extremely expensive to keep statistics on each push from each mountain (and there are many thousands of them) in one place.  Therefore, all workers collect their statistics first locally at home, and only occasionally (every few seconds) merge it into a common place.  Sample code: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sync.RWMutex ElapsedTime ... Methods ... AppID ... ... } addStatsTicker := time.Tick(<span class="hljs-number"><span class="hljs-number">5</span></span> * time.Second) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-addStatsTicker: globalStats.Lock() gcm.stats.Lock() mergeStatsToGlobal(&amp;gcm.stats) cleanStats(&amp;gcm.stats) gcm.stats.Unlock() globalStats.Unlock() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> push := &lt;-mainChan: <span class="hljs-comment"><span class="hljs-comment">//   ,      gcm.stats.Lock() statsMethodIncr(&amp;gcm.stats, push.Method) statsAppIDIncr(&amp;gcm.stats, push.AppID) gcm.stats.Unlock() send(push) // ... } }</span></span></code> </pre><br><br><h3>  Selective logging </h3><br>  In addition to the general statistics, the guns allow you to log all key steps in the processing of selective guns. <br><img src="https://habrastorage.org/files/3be/e80/6df/3bee806df01e4ea7bc598144ec47661e.png" align="right"><br>  If a push comes from the queue with special flags, then all actions for processing this push are sent to the debug channel of the logger, which sends these logs to the API.  Not only the success / error facts are collected, but also all the important details: key branches for selection, values ‚Äã‚Äãof variables and buffers, exact time with millisecond accuracy.  All this makes it possible to quite accurately understand what went wrong along with these logs themselves in case of problems like ‚ÄúI didn‚Äôt have someone pushing yesterday at such a time,‚Äù ‚Äútwo of them came,‚Äù and so on. <br>  This is all in addition to the ‚Äúlocal‚Äù logs, which generally do not leave the limits of the machine on which the gun is running. <br><br>  Something like that.  All this works on many tens of thousands of gorutin without any problems, and it's cool) <br><br>  PS A lot of things left behind the scenes, maybe later ... <br><br>  PPS Pictures of gophers taken <a href="https://github.com/hackraft/gophericons">from here</a> . </div><p>Source: <a href="https://habr.com/ru/post/265731/">https://habr.com/ru/post/265731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265715/index.html">The digest of interesting materials for the mobile developer # 118 (August 24-30)</a></li>
<li><a href="../265723/index.html">Navigation between screens using xib files</a></li>
<li><a href="../265725/index.html">How to write a beautiful code and fill up the project</a></li>
<li><a href="../265727/index.html">Grokayem RxJava, Part Three: Reactivity with Benefit</a></li>
<li><a href="../265729/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ174 (August 23 - 30, 2015)</a></li>
<li><a href="../265733/index.html">Life and graphs: a network approach to system modeling</a></li>
<li><a href="../265737/index.html">IBM will help Singapore to solve the problem of increasing sea traffic</a></li>
<li><a href="../265739/index.html">Flash to Html5 or secret api Swiffy</a></li>
<li><a href="../265741/index.html">Habr shell: we build a cross-platform ssh server in java application</a></li>
<li><a href="../265743/index.html">Announcement of the fifth meeting of the Java User Group EKB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>