<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Amazon SQS vs RabbitMQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Any progress and optimization is welcome by anyone. Today I would like to talk about a beautiful thing that makes life much easier - qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Amazon SQS vs RabbitMQ</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Any progress and optimization is welcome by anyone.  Today I would like to talk about a beautiful thing that makes life much easier - queues.  Implementing the best practices in this matter not only improves the performance of the application, but also successfully prepares your application for the architecture ‚Äúin the style‚Äù of Cloud Computing.  Moreover, not using ready-made solutions from cloud providers is just silly. <br><br>  In this article, we will look at Amazon Web Services in terms of designing the architecture of medium and large web applications. <br><br>  Consider the scheme of such an application: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/fae/c2a/aee/faec2aaeedc13df2849803fc6e47d070.png"><br><br><a name="habracut"></a><br>  Examples of such an organization can be various kinds of aggregators: news, exchange rates, stock exchange quotes, etc. <br><br>  External data providers generate a stream of messages that, while undergoing post-processing, are stored in the database. <br>  Users through the web-tier do a sample of information from the database according to certain criteria (filters, grouping, sorting), and then optional processing of samples (various statistical functions). <br><br>  Amazon tries to identify the most typical application components, then automates and provides a component service.  Now there are more than two dozen of such services and the full list can be found on the AWS website: <a href="http://aws.amazon.com/products/">http://aws.amazon.com/products/</a> .  On Habr√© already was an article describing a number of popular services: <a href="http://habrahabr.ru/post/138695/">Popular about Amazon Web Services</a> .  This is attractive primarily because there is no need for independent installation and configuration, as well as higher reliability and piece-rate payment. <br><br>  And if you use AWS, the project layout will look like this: <br><img src="https://habrastorage.org/storage2/903/566/68e/90356668e94431d1fa9bc450fc59a576.png"><br><br>  Undoubtedly, this approach is in demand and it has its own market.  But often there are questions about the financial component: <br><ol><li>  How much can you save using AWS? </li><li>  Is it possible to independently implement a service with the same properties, but for less money? </li><li>  Where is the line that separates AWS from its counterpart? </li></ol><br>  Next we will try to answer these questions. <br><br><h4>  1. Review of analogues </h4><br>  For comparison, we will consider the following components: <br><ul><li>  Message-oriented middleware - RabbitMQ </li><li>  Analogue of the above service from AWS, which is called SQS </li></ul><br>  SQS service is paid based on the number of requests to the API + traffic <br>  Consider each service in more detail. <br><br><h5>  1.1.  SQS </h5><br>  Amazon SQS is a service that allows you to create and work with message queues.  The standard cycle of working with the finished SQS queue is as follows: <br><ol><li>  Producer to send a message to the queue must know its URL.  Then, using the SendMessage command, adds the message. </li><li>  The consumer receives the message using the ReceiveMessag command. </li><li>  As soon as a message is received, it will be blocked to be re-received for a while. </li><li>  After processing the message successfully, Consumer uses the DeleteMessage command to remove the message from the queue.  If an error occurred during processing or the DeleteMessage command was not called, the message will be returned to the queue after the timeout expires. </li></ol><br>  Thus, on average, 3 API calls are required to send and process a single message. <br><br>  Using SQS, you pay for the number of API calls + traffic between regions.  The cost of 10k calls is $ 0.01, i.e.  on average, for 10k messages (x3 API call) you pay $ 0.03.  Pricing in other regions you can see <a href="http://aws.amazon.com/sqs/">here</a> . <br><br>  There are many options for organizing the message sending service: <br><ul><li>  RabbitMQ </li><li>  ActiveMQ </li><li>  ZMQ </li><li>  Openmq </li><li>  ejabbered (XMPP) </li></ul><br>  Each option has its pros and cons.  We will choose RabbitMQ as one of the most popular implementation of the AMQP protocol. <br><br><h5>  1.2.  RabbitMQ </h5><br><h6>  1.2.1.  Deployment Scheme </h6><br>  A server with RabbitMQ installed and defaults provides very good performance.  But this variant of deployment does not suit us, because  in the case of the fall of this node, we can immediately get a number of problems: <br><br><ol><li>  Loss of important data in messages; </li><li>  "Accumulation" of information on Producer, which can lead to an overload of Consumer-s after restoring the work of the queue; </li><li>  Shut down the entire application while the problem is being resolved. </li></ol><br>  In testing, we will use 2 nodes in active-active mode with replication of queues between nodes.  In RabbitMQ, this is called mirrored queues. <br><img src="https://habrastorage.org/storage2/cf1/06f/35c/cf106f35c872a8fba9da8781fa53eccc.png"><br><br>  For each such queue, a master and a set of slaves is defined, where a copy of the queue is stored.  In the case of the fall of the master node, one of the slaves is selected by the master. <br><br>  To create such a queue, the ‚Äúx-ha-policy‚Äù parameter is specified when declaring, which indicates where copies of the queue should be stored.  2 parameter values ‚Äã‚Äãare possible. <br><ul><li>  all: copies of the queue will be stored on all nodes in the cluster.  When adding a new node to the cluster, a copy will be created on it; </li><li>  nodes: copies will be created only on the nodes specified by the ‚Äúx-ha-policy-params‚Äù parameter. </li></ul><br>  You can read more about mirrored queues here: <a href="http://www.rabbitmq.com/ha.html">http://www.rabbitmq.com/ha.html</a> . <br><br><h6>  1.2.2.  Performance Measurement Technique </h6><br>  Earlier we examined how the test environment will be organized.  Now let's consider what and how we will measure. <br>  For all measurements m1.small instances (AWS) were used. <br><br>  We will conduct a series of measurements: <br>  The speed of sending messages to a certain value, then the speed of receiving - thus we will check the degradation of performance with an increase in the queue. <br><br>  1. The speed of sending messages to a certain value, then the speed of receiving - thus we will check the performance degradation with increasing queue. <br>  2. Simultaneous sending and receiving messages from one queue. <br>  3. Simultaneous sending and receiving messages from different queues. <br>  4. Asymmetric queue load: <br><ul><li>  a.  Send in a queue 10 times more threads than they accept; </li><li>  b.  Receive from the queue 10 times more threads than send. </li></ul>  5. Sending and receiving messages of different sizes: <br><ul><li>  a.  16 bytes; </li><li>  b.  1 kilobyte; </li><li>  c.  64 kilobytes (max for SQS). </li></ul><br>  All tests except the first will be conducted in 3 stages: <br><ol><li>  Warming up for 2 seconds; </li><li>  Test run 15 seconds; </li><li>  Cleaning the queue. </li></ol><br>  <b>Message Acknowledgment</b> <br><br>  This property is used to confirm the delivery and processing of a message.  There are two modes of operation: <br><ul><li>  Auto acknowledge - the message is considered successfully delivered immediately after it is sent to the recipient;  in this mode, to receive one message, all you need is a single call to the server. </li><li>  Manual acknowledge - the message is considered successfully delivered after the recipient calls the appropriate command.  This mode allows you to ensure guaranteed processing of the message, if you confirm delivery only after processing.  In this mode, two calls to the server are required. </li></ul><br>  In the test, the second mode is selected, since  it corresponds to the operation of SQS, where the processing of a message is done by two commands: ReceiveMessage and DeleteMessage. <br><br>  <b>Batch processing</b> <br><br>  In order not to waste time on each message to establish a connection, authorization, and other things, RabbitMQ and SQS allow processing messages in batches.  This is available for both sending and receiving a message.  Since  batch processing is disabled by default in both RabbitMQ and SQS, we also will not use it for comparison. <br><br><h6>  1.2.3.  Test results </h6><br>  <b>Load-Unload Test</b> <br><br>  Summary results: <br><table><tbody><tr><td colspan="2" rowspan="2">  Load-Unload Test </td><td rowspan="2">  msg / s </td><td colspan="4">  Request time </td></tr><tr><td>  avg, ms </td><td>  min, ms </td><td>  max, ms </td><td>  90%, ms </td></tr><tr><td rowspan="2">  SQS </td><td>  Consume </td><td>  198 </td><td>  25 </td><td>  17 </td><td>  721 </td><td>  28 </td></tr><tr><td>  Produce </td><td>  317 </td><td>  sixteen </td><td>  ten </td><td>  769 </td><td>  20 </td></tr><tr><td rowspan="2">  RabbitMQ </td><td>  Consume </td><td>  1293 </td><td>  3 </td><td>  0 </td><td>  3716 </td><td>  3 </td></tr><tr><td>  Produce </td><td>  1875 </td><td>  2 </td><td>  0 </td><td>  14785 </td><td>  0 </td></tr></tbody></table><br>  From the table it is clear that SQS works much more stable than RabbitMQ, in which dips can occur when sending a message for 15 seconds!  Unfortunately, we could not immediately find the cause of this behavior, and in the test we try to adhere to the standard settings.  At the same time, the average speed of RabbitMQ is about 6 times higher than that of SQS, and the query execution time is several times lower. <br><br>  The following graphs with the distribution of the average speed depending on time. <br><img src="https://habrastorage.org/storage2/fdc/c01/7a7/fdcc017a71a09117eac9358aff87c2eb.png"><br><br><img src="https://habrastorage.org/storage2/e43/5ed/46f/e435ed46f9dadbb8d8df27211f0eedb6.png"><br><br>  In general, there is no decrease in performance with an increase in the number of messages in the queue, which means you can not be afraid that if the receiving nodes fall, the queue will become a bottleneck. <br><br>  <b>Parallel</b> <br><br>  No less interesting is the test of the dependence of the speed of work on the number of simultaneously running threads.  The results of the SQS test can be easily foreseen: since the work proceeds via the HTTP protocol and most of the time it takes to establish a connection, then, presumably, the results should increase with the number of threads, which is well illustrated by the following table: <br><table><tbody><tr><td rowspan="2">  SQS <br>  msg / s </td><td colspan="4">  Threads </td></tr><tr><td>  <b>one</b> </td><td>  <b>five</b> </td><td>  <b>ten</b> </td><td>  <b>40</b> </td></tr><tr><td>  Produce </td><td>  65 </td><td>  324 </td><td>  641 </td><td>  969 </td></tr><tr><td>  Consume </td><td>  33 </td><td>  186 </td><td>  333 </td><td>  435 </td></tr></tbody></table>  The average time for a single request to send a message is 16 ms, and for receiving 29 ms. <br>  It is also seen that for 1, 5 and 10 flows the dependence is linear, but with an increase to 40 flows, the average speed increases by 50% for sending and 30% for receiving, but the average query time significantly increases: 43ms and 98ms respectively. <br><br>  For RabbitMQ, the saturation in speed occurs much faster; already at 5 streams the maximum is reached: <br><table><tbody><tr><td rowspan="2" colspan="2">  RabbitMQ Threads </td><td colspan="4">  Threads </td></tr><tr><td>  <b>one</b> </td><td>  <b>five</b> </td><td>  <b>ten</b> </td><td>  <b>40</b> </td></tr><tr><td rowspan="2">  Produce </td><td>  speed, msg / s </td><td>  3086 </td><td>  3157 </td><td>  3083 </td><td>  3200 </td></tr><tr><td>  latency ms </td><td>  0 </td><td>  one </td><td>  3 </td><td>  eleven </td></tr><tr><td rowspan="2">  Consume </td><td>  speed, msg / s </td><td>  272 </td><td>  811 </td><td>  820 </td><td>  798 </td></tr><tr><td>  latency ms </td><td>  3 </td><td>  6 </td><td>  12 </td><td>  51 </td></tr></tbody></table><br>  During testing, a feature was discovered: if 1 stream for sending and 1 stream for receiving are working at the same time, the speed of receiving messages drops to almost 0, while the sending stream shows the maximum performance.  The problem is solved by forcibly switching the context after each iteration of the test, while the sending bandwidth drops, but the upper limit of the query execution time is significantly reduced.  From local tests at 1 stream (sending / reading): 11000/25 against 5000/1000. <br><br>  Additionally, we conducted a test for RabbitMQ with several queues for 5 threads: <br><table><tbody><tr><td rowspan="2">  RabbitMQ </td><td colspan="2">  Queues </td></tr><tr><td>  one </td><td>  five </td></tr><tr><td>  Produce </td><td>  3157 </td><td>  3489 </td></tr><tr><td>  Consume </td><td>  811 </td><td>  880 </td></tr></tbody></table><br>  It can be seen that the speed for several queues is slightly higher.  Summary results for 10 streams are presented in the following diagram: <br><img src="https://habrastorage.org/storage2/162/7b9/f5e/1627b9f5e80f098203b9320971e56f8e.png"><br><br>  <b>Size</b> <br><br>  In this test, we consider the dependence of the speed on the size of the transmitted data. <br><br>  Both RabbitMQ and SQS showed an expected decrease in the speed of sending and receiving with increasing message size.  In addition, the queue in RabbitMQ with the size of the message grows more often ‚Äúfreezes‚Äù and does not respond to requests.  This indirectly confirms the conjecture that this is associated with working with a hard disk. <br><br>  Comparative speed results: <br><img src="https://habrastorage.org/storage2/496/b0d/74c/496b0d74c513cbad4bed1a0d98d6dfb6.png"><br><br>  Comparative query time results: <br><img src="https://habrastorage.org/storage2/a67/75e/753/a6775e753676bcf2625c3cdb583e61c8.png"><br><br><h4>  2. Cost calculation and recommendations </h4><br>  From the estimated cost of $ 0.08 for one small instance in the European region, we get a cost of $ 0.16 for RabbitMQ in a two-node configuration + traffic cost.  In SQS, the cost of sending and receiving 10,000 messages is $ 0.03.  We get the following dependency: <br><img src="https://habrastorage.org/storage2/e99/c89/2d8/e99c892d835152441366c2cf3c697350.png"><br><br>  60 thousand messages per hour is about 17 messages per second, which is significantly less than the speed that SQS and RabbitMQ can provide. <br><br>  Thus, if your application requires a speed of on average less than 17 messages per second, then SQS will be preferable.  If the needs of the application become higher, then it is worth considering migration paths to dedicated messaging servers. <br><br>  It is important to understand that these recommendations are valid only for average speeds, and calculations should be carried out throughout the entire cycle of the load oscillation, but if your application needs a much higher speed than the SQS allows, then this is also a reason to think about changing the provider. <br><br>  Another reason to use RabbitMQ may be the latency request requirement, which is an order of magnitude lower than that of SQS. <br><br><h5>  2.1.  Is it possible to reduce the cost of RabbitMQ solution? </h5><br>  There are two ways to reduce the cost: <br><ul><li>  Do not use cluster. </li><li>  Use micro instance. </li></ul><br>  In the first case, the HA cluster is lost in the event of a node falling or the entire active zone, but it is not terrible if the entire application is hosted in only one zone. <br>  In the second case, the micro instance can be cut back resources, if for some time the utilization of resources is close to 100%.  This may affect the performance of the queue when the persistence queue is used. <br><br><h4>  3. Conclusion </h4><br>  Thus, we see that there is simply no unequivocal answer to the question ‚ÄúWhat solution should I use?‚Äù  It all depends on many factors: the size of your wallet, the number of messages per second and the time of sending these messages.  However, based on the metrics given in this material, it is possible to calculate the behavior for a particular case. <br><br>  Thank! <br><br>  The article is written and adapted based on the research of Maxim Bruner ( <a href="http://habrahabr.ru/users/minim/" class="user_link">minim</a> ), for EPAM Cloud Computing Competency Center </div><p>Source: <a href="https://habr.com/ru/post/161787/">https://habr.com/ru/post/161787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161773/index.html">‚ÄúSimple Business‚Äù received new perpetual licenses from the FSB and FSTEC</a></li>
<li><a href="../161775/index.html">Making OpenGL ES LiveWallpaper on Linderdaum Engine for Android</a></li>
<li><a href="../161779/index.html">Curved LCDs can be used as screens in contact lenses.</a></li>
<li><a href="../161783/index.html">Free distance education</a></li>
<li><a href="../161785/index.html">Dart + WebGL do cookies on the dark side taste good?</a></li>
<li><a href="../161793/index.html">‚ÄúIT Infrastructure Under Control‚Äù: Web Conferencing Records Out</a></li>
<li><a href="../161801/index.html">Pre-holiday discount on IM + Pro</a></li>
<li><a href="../161803/index.html">Robot Loader Project: Determine Your Own Location</a></li>
<li><a href="../161805/index.html">Drawing a snowman in PowerShell</a></li>
<li><a href="../161813/index.html">XAircraft x650 and aerial photography</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>