<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The effect of dithering in a three-dimensional game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The creator of Papers, Please, Lukas Pope is working on a new three-dimensional project Return of the Obra Dinn, in which he tries to recreate the fee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The effect of dithering in a three-dimensional game</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58a/8e5/133/58a8e5133680a122a9061b2c4505e67d.jpg" alt="image"></div><br>  <i>The creator of Papers, Please, Lukas Pope is working on a new three-dimensional project Return of the Obra Dinn, in which he tries to recreate the feeling of an old book with the help of the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BD%25D0%25B3">dithering</a> effect.</i> <br><br>  First, a brief explanation: Obra Dinn performs internal rendering in an 8-bit palette in grayscale, and then at the post-processing stage converts the final output data to 1-bit values.  Conversion from 8-bit to 1-bit color is performed by comparing each pixel of the original image with the corresponding point in the dithering tile pattern.  If the pixel value of the image is greater than the value of the dithering pattern point, then the output bit is assigned the value 1, otherwise it is 0. The output data is simplified to 1-bit values, and the viewer's eye combines the pixels, approximating more of them. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/194/78f/43019478f0935551952e4d3479a77295.png"></div><br>  <i>Transforming the original image according to the dithering pattern</i> <br><br>  The two components of this process are the original image and the dithering pattern.  In various cases, Obra Dinn uses two different patterns: the 8x8 Bayer matrix for a smoother hue range and the 128x128 blue noise field for less orderly output. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f5/7da/644/7f57da6449b9c5a847b54dacb38ab770.png"></div><br>  <i>Bayer / Blue Noise</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0b/125/a0d/d0b125a0d643e689b875957746e4c1d2.png"></div><br>  <i>The result is inside the engine without frame lines.</i>  <i>Bayer on the sphere, blue noise on everything else.</i> <br><br>  The classic dithering process works great for static images and looks much worse on moving and animated images.  When the original image changes frame by frame, the static dithering pattern and the output in low resolution become a serious problem.  What should be solid shapes and shades, turns into a flickering chaos of pixels. <br><br><div class="spoiler">  <b class="spoiler_title">Move the sphere</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e69/930/2ee/e699302ee6b47b8520d5523970445796.gif"></div></div></div><br>  Today, dithering is mainly used for static source images or with high resolution output.  The first thing you think, looking at this floating dithering effect, is not ‚Äúyes, dithering works this way,‚Äù but ‚Äúwhat is this twitching effect and how can I turn it off‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">Pattern A. For a more pleasant image, the contrast is reduced.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/65b/96a/fa165b96a570d2ea3f8b9762ac166d00.gif"></div></div></div><br>  Try to focus on any object while it is moving, and you will understand what the main problem Obra Dinn is in full screen.  There are ways to fix this, and most often they come down to "this style does not work, replace it."  I‚Äôve come pretty far on this path, experimenting with different styles, but then I went back and asked myself the question ‚Äî maybe you shouldn‚Äôt let these gadish pixels get in my way. <br><br><h2>  Stabilize dithering </h2><br>  To give your eyes the best opportunity to recombine everything, dithering is best used with points of dithering patterns that have a 1: 1 correlation with output pixels.  But if there is a ‚Äúonly‚Äù correlation with the output data, then when applying post-effects to the scene, there will be no connection between the rendered geometry and the threshold pattern.  In each frame, the moving elements of the scene will have a new threshold value.  Instead, I want the dithering pattern to be ‚Äúglued‚Äù to the geometry and seem stable when moving along with the rest of the scene. <br><br>  This is where the overlap problem arises.  There is a conflict between the ‚Äúperfect‚Äù imposing of the dithering pattern (1: 1 with the screen) and the perfect imposing on the scene (x: 1 with the geometry), so you need to be ready to compromise.  Most of my work is devoted to imposing a dithering input pattern on different spaces, which provides the best match between the pattern and the scene geometry.  Here everything is done at the stage before setting the thresholds. <br><br><h2>  Texel space </h2><br>  My first attempt was to impose a dithering pattern on a texel space.  This is analogous to dithering the textures of objects during scene rendering, instead of performing post-processing of an 8-bit output image.  I didn‚Äôt expect it to work, but I still wanted to see what the overlay would look like perfectly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/a50/97d/102a5097d36f733c80835508d7cc6c8b.png"></div><br>  <i>Texel space dithering pattern</i> <br><br>  Well, in general, the expectations were justified.  The overlay on all objects is done differently, so the scales of the patterns do not match.  They can be unified.  But the real problem is distortion.  Any resampling from one space to another will lead to distortions, and for dithering patterns it is not as easy to perform mip-texturing or filtering as for traditional textures.  However, we will bring this to the end: <br><br><div class="spoiler">  <b class="spoiler_title">Application to the moving scene</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/608/f8b/5a2608f8bbf97c80bd7d451fdc8b11c2.gif"></div></div></div><br>  Everything is not so bad - the pattern is not bad tied to the geometry.  Distortion creates its own floating effect, and unifying or scaling the overlay will not help.  Texels change their size depending on the distance to the camera, so there will always be pixels of the dithering pattern, which when resampling on the screen will be horribly distorted. <br><br><h2>  Movement deformation </h2><br>  If I wanted the dithering pattern to track the movement of geometry under it, then why not just deform the pattern based on the change in position of each rendered pixel in the scene?  Indeed, why not try.  This is a bit like motion blur, in which each pixel tracks its movement relative to the previous frame.  In this case, I update the dithering texture so that its pattern moves along with the scene.  If the pixel of the scene was not present in the previous frame, then the dithering pattern is reloaded in it.  The implementation of this technique was greatly facilitated by the static nature of the game - I had to worry about camera movement, and not individual objects. <br><br><div class="spoiler">  <b class="spoiler_title">Deformation of the dithering pattern to maintain frame-to-frame consistency with the scene</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6d/6ff/6a4/b6d6ff6a4784673b118073a54fcc0481.gif"></div></div></div><br>  It was a pretty ‚Äúquick and dirty‚Äù attempt, but some facts became obvious.  Firstly, it works in some way.  Secondly, the dithering pattern needs to be taken into account by its neighbors ‚Äî it cannot simply be individual pixels.  If we consider each pixel separately, as is done in this method, then it is obvious that we will get gaps and distortions in the pattern.  In this test scene, I moved the camera to show it with the chest as an example.  Looking at the distorted dithering pattern itself, it is easier to notice. <br><br><div class="spoiler">  <b class="spoiler_title">Setting the threshold in solid gray with a deformable dithering pattern</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/829/b05/07d829b053df01a9e46de6e5f64fa32f.gif"></div></div></div><br>  These gaps arise due to the different depth of the pixels and the selected thresholds.  I was thinking about a complex system for correcting a problem based on tracking areas, averaging their depth and shifting all points of the dithering pattern in each area to the same value.  Gaps along the boundaries of areas can be hidden by a sharp change of lighting or wire-frame line.  This would not have been possible due to the fact that the game used colored areas to generate model frameworks.  When I started to implement all of this, I first missed the depth in the equation, which gave me a much simpler alternative: <br><br><h2>  Offset overlay </h2><br>  When formulating equations for a deformable dithering, a very simple transformation fell out of them: <br><br><pre><code class="cs hljs">DitherOffset = ScreenSize * CameraRotation / CameraFov</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Shift of dithering pattern superimposed on screen based on camera rotation</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/bfd/afc/8acbfdafc9f5972bf914f02f2c494d05.gif"></div></div></div><br>  In essence, this expresses what I wanted: the shift of the dithering pattern superimposed on the screen by exactly one screen when the camera is rotated by one viewing area.  This keeps the 1: 1 overlay with the screen, but it also takes into account the simplified transformation of the apparent geometry of the scene.  In fact, this only corresponds to the movement in the center of the screen, but, to my happiness, it looks quite good. <br><br><div class="spoiler">  <b class="spoiler_title">Offset dithering pattern to track rotation exactly on one screen fov camera</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/248/e40/b5c248e406cfd82fdfc120ed45129c98.gif"></div></div></div><br>  Note: it seems that the dithering pixels of the chair basically move with geometry.  The same applies to the realm.  Planes that are more perpendicular to the field of view are not displayed very well - the floor still looks chaotic. <br><br>  Although the approach is not perfect, a simple shift of the dithering superimposed on the screen retains the overall pattern and movement of the scene so that it is more convenient for the eye to track together.  I was very pleased with it.  Being engaged in erasure of the code and commits, having released one or two posts in the devlog, I still could not get rid of the thought of a perfectly stuck dithering: <br><br><h2>  World Space - Cubic Overlay </h2><br>  Previous experiments have shown that any correlation between the dithering pattern and the scene geometry should ignore the depth information received from the scene.  In practice, this means that the dithering can be attached to the geometry during the rotation of the camera, but not its movement.  This is not so bad for Obra Dinn, given the slow pace of the game and the observant role of the player.  Usually in the game he walks around the ship, stops and looks at the objects.  When walking on the screen, there are so many changes that the floating dithering is not particularly obvious. <br><br>  With this in mind, my next attempt was to impose a dithering pattern on a geometry indirectly, by pre-rendering the pattern on the sides of a cube centered around the camera.  The cube moves with the camera, but remains oriented towards the world.  It turns out a mixture: a little screen, a little scene. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/e32/f10/e91e32f1075d56acfeb848c54871a58b.png"></div><br>  <i>The dithering pattern is superimposed on a cube centered relative to the camera.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/920/afa/753920afa3e43877b7cce860b557070d.png"></div><br>  <i>View from camera looking to the corner.</i>  <i>The scale of the overlay for clarity increased.</i> <br><br>  Laying a cube works well when you look at the sides, but not so well when the camera is pointing at an angle.  The dithering pattern is still perfectly captured in 3D space when you rotate the camera.  Even with rough checks, the result looks promising. <br><br><div class="spoiler">  <b class="spoiler_title">Setting a scene threshold using a dithering pattern imposed on a cube</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/a02/5b1/dfda025b1e35029d921f965c165ca30b.gif"></div></div></div><br>  The case finally moved.  Due to the fact that it is a post-processing, this approach is more general than the imposition in the space of texels, which is good.  The problem now comes down to a concrete cubic overlay.  When ideally overlapping, one texel on a cube always corresponds to one pixel on the screen, regardless of the rotation of the camera.  For a cube this is impossible ... <br><br><h2>  Space of the world - spherical overlay </h2><br>  ... but thanks to the sphere, I got close enough. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/269/d2d/cb2/269d2dcb245b33c3da0873d15fe92371.png"></div><br>  <i>Imposing a dithering pattern on the inside of a sphere</i> <br><br>  The search for this particular spherical overlay took time.  There is no way to perfectly pitch a sphere with a square texture.  It would be possible to redefine the dithering matrixes through a grid of hexagons or something similar, which well tones the sphere.  Perhaps it would have, but I did not try.  Instead, I ‚Äúhacked‚Äù the tiling of the sphere, achieving a careful adjustment so that the ‚Äúring‚Äù imposition of the original dithering pattern gave good results. <br><br><div class="spoiler">  <b class="spoiler_title">Effect applied to the scene</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c55/529/e35/c55529e354a3e26501e3f451af260930.gif"></div></div></div><br>  Better than with a cube, but still a lot of distortion.  The size of a spherically superimposed point is very similar to the size of a screen pixel ‚Äî it differs just enough to create a moire pattern.  I felt that I was close to the solution, and it is very easy to correct such distortions with the help of supersampling: apply the dithering threshold at a higher resolution, and then lower it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/91f/b15/df191fb1500cf9b7197b5ab3157bcb55.png"></div><br>  <i>Spherically superimposed dithering pattern at 2x magnification and with resolution reduced to 1x</i> <br><br><div class="spoiler">  <b class="spoiler_title">Setting the threshold at 2x, with a subsequent decrease in resolution to 1x</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/7a0/b9f/ae67a0b9f9b17b819f601b56511c645c.gif"></div></div><br>  This is still the best of my results.  There are several tradeoffs: <br><br><ol><li>  The points of the dithering pattern become larger and less effective around the edges of the screen. </li><li>  The pattern is not aligned in the top-bottom-left-right directions for most camera turns. </li><li>  The output is no longer 1-bit due to the final decrease in resolution. </li></ol><br>  But the benefits are very great: <br><br><ol><li>  Dithering perfectly attaches to all camera turns.  In the game, it feels a bit strange. </li><li>  The discomfort of floating dithering completely disappeared, even in full screen mode. </li><li>  Pixel style of game is saved </li></ol><br>  You can completely get rid of deficiency 3 by again limiting the output to 1-bit values ‚Äã‚Äãusing a simple threshold of 50%.  The result is still better than without supersampling (three examples for comparison are presented below). <br><br><div class="spoiler">  <b class="spoiler_title">Comparison of the three approaches</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3e/803/49c/d3e80349c226387f712627d1fc2e1bef.gif"></div></div></div><br><div class="spoiler">  <b class="spoiler_title">In game with palette by default</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5f/81f/5a8/a5f81f5a8192905cf98e9297e71ce529.gif"></div></div></div><br><h2>  Summarize </h2><br>  It seems a bit strange to spend 100 hours on something that they will not even notice.  No one really thinks "damn, yes this dithering is hellishly stable, it's some kind of magic."  But I didn‚Äôt want people to have problems that should have arisen, so they should have been fixed. <br><br>  An overlay in offset screen space works best with a 1x scale, and a spherical overlay at 2x.  The whole scene is now rendered in 800x450 resolution (raised the resolution from 640x360), which improves legibility, without sacrificing the low-res style.  In the finished game there will be two display modes: <br><br>  <b>DIGITAL</b> - dithering in offset screen space, 1-bit output. <br><br>  <b>ANALOG</b> - fullscreen superimposed dithering on the sphere, a smoothed output. </div><p>Source: <a href="https://habr.com/ru/post/343172/">https://habr.com/ru/post/343172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343156/index.html">Race to Tallinn data centers</a></li>
<li><a href="../343162/index.html">My company did not take off, 6 lessons at the cost of 4 years of life and $ 150,000</a></li>
<li><a href="../343164/index.html">How cheat traders on cryptocurrency exchanges: the investigation of Business Insider</a></li>
<li><a href="../343166/index.html">NRF51822 in brief: Quick start</a></li>
<li><a href="../343168/index.html">// booby, later</a></li>
<li><a href="../343174/index.html">Authorization through Network Policy Server (NPS) for MikroTik</a></li>
<li><a href="../343178/index.html">On fractals, martingales and random integrals. Part one</a></li>
<li><a href="../343180/index.html">Method Lego Serious Play: how to formulate and use the values ‚Äã‚Äãof the team with the help of children's designer</a></li>
<li><a href="../343184/index.html">Facebook Product Development Framework</a></li>
<li><a href="../343186/index.html">Cryptocurrencies and virtual economy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>