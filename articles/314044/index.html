<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding errors in the LLVM project code using the PVS-Studio analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About two months ago I wrote an article about testing the GCC compiler using the PVS-Studio analyzer. The idea of ‚Äã‚Äãthe article was the following: GCC...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding errors in the LLVM project code using the PVS-Studio analyzer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/95a/d29/d4e/95ad29d4e9f307da4d0ea76c33f25f4d.png" alt="PVS-Studio vs LLVM" align="left">  About two months ago I wrote an article about testing the GCC compiler using the PVS-Studio analyzer.  The idea of ‚Äã‚Äãthe article was the following: GCC warnings are good, but not enough.  One should use specialized code analysis tools, for example, PVS-Studio.  As a confirmation, I showed errors that PVS-Studio could find in the GCC code.  A number of readers have noticed that the quality of the GCC code and its diagnostics is so-so, while the Clang compiler is modern, high-quality, fresh and young.  In general, Clang is hoo!  Well, the time has come for me to check the LLVM project with PVS-Studio. <br><a name="habracut"></a><br><h2>  Checking LLVM with the help of Linux version of PVS-Studio </h2><br>  I think there are few who do not know what LLVM is.  However, I will keep the tradition of briefly describing a project that has been verified. <br><br>  <a href="https://ru.wikipedia.org/wiki/Low_Level_Virtual_Machine">LLVM</a> (Low Level Virtual Machine) is a universal system for analyzing, transforming and optimizing programs that implements a virtual machine with RISC-like instructions.  It can be used as an optimizing compiler for this bytecode into machine code for various architectures, or for its interpretation and JIT compilation (for some platforms).  As part of the LLVM project, Clang frontend was developed for C, C ++ and Objective-C languages, translating source codes into LLVM bytecode, and allowing using LLVM as a full-featured compiler. <br><br>  Official site: <a href="http://llvm.org/">http://llvm.org/</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Revision 282481 was checked. The analysis was carried out with a new version of PVS-Studio working under Linux.  Since PVS-Studio for Linux is a new product, below I will describe in more detail how the check was performed.  I‚Äôm sure it will show that using our analyzer in Linux is not at all difficult, and you can, without delay, try to check your own project. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85e/9bf/483/85e9bf483452cd08110a862682eee8e4.png" alt="Penguin on the PVS-Studio unicorn"></p><br><br>  The Linux version of the analyzer is available for download on the following page: <a href="http://www.viva64.com/ru/pvs-studio-download-linux/">http://www.viva64.com/ru/pvs-studio-download-linux/</a> <br><br>  We checked the previous projects with the help of a universal mechanism that keeps track of compiler runs.  This time we will use to check the information that PVS-Studio will take from the JSON Compilation Database.  Details can be found in the documentation section " <a href="http://www.viva64.com/ru/m/0036/">How to run PVS-Studio in Linux</a> ". <br><br>  In LLVM 3.9, they completely abandoned autoconf in favor of CMake, and this was a good reason to test the JSON Compilation Database support in action.  What it is?  This is the format used by the Clang utilities.  It stores the list of compiler calls in the following form: <br><pre><code class="cpp hljs">[ { <span class="hljs-string"><span class="hljs-string">"directory"</span></span>: <span class="hljs-string"><span class="hljs-string">"/home/user/llvm/build"</span></span>, <span class="hljs-string"><span class="hljs-string">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"/usr/bin/c++ .... file.cc"</span></span>, <span class="hljs-string"><span class="hljs-string">"file"</span></span>: <span class="hljs-string"><span class="hljs-string">"file.cc"</span></span> }, .... ]</code> </pre> <br>  For CMake projects, getting such a file is very simple - just generate a project with an additional option: <br><pre> <code class="cpp hljs">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=On ../llvm</code> </pre> <br>  After that, compile_commands.json will appear in the current directory.  We need it for verification.  Since some projects use code generation, we first do the build. <br><pre> <code class="cpp hljs">make -j8</code> </pre> <br>  Now everything is ready for analysis.  It starts with one line: <br><pre> <code class="cpp hljs">pvs-studio-analyzer analyze -l ~/PVS-Studio.lic -o PVS-Studio.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> -j</code> </pre> <br>  For projects not using CMake, you can get compile_commands.json using the Bear utility.  But for complex build systems that actively use environment variables or cross-compilation, the commands received do not always provide detailed information about the translation unit. <br><br>  <b>Note N1.</b>  <a href="http://www.viva64.com/ru/b/0444/">How to work with PVS-Studio report in Linux</a> . <br><br>  <b>Note N2.</b>  We provide quality and quick support to our customers and potential users.  Therefore, if you do not understand something or something does not work, write to us in <a href="http://www.viva64.com/ru/about-feedback/">support</a> .  You will enjoy our service. <br><br><h2>  Test results </h2><br>  By the way, this is not the first LLVM check.  Articles written based on previous checks: <ul><li>  <a href="http://www.viva64.com/ru/b/0108/">PVS-Studio vs Clang</a> (2011); </li><li>  <a href="http://www.viva64.com/ru/b/0155/">Static analysis should be applied regularly</a> (2012). </li></ul><br>  Unfortunately, I can not say anything about the number of false positives and the density of errors found.  The project is big, there are a lot of warnings, and I studied them very superficially.  In my defense, I can say that the preparation for the release of PVS-Studio for Linux took a lot of time, and I managed to work on the article only with fits and starts. <br><br>  Everything, the lyrics are over, let's move on to the most interesting.  Let us examine the suspicious places in the LLVM code that PVS-Studio pointed to me. <br><br><h3>  Unbit Fields </h3><br>  In the code there is such an enumeration: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { ST_Unknown, <span class="hljs-comment"><span class="hljs-comment">// Type not specified ST_Data, ST_Debug, ST_File, ST_Function, ST_Other };</span></span></code> </pre> <br>  This, if I may say so, is the ‚Äúclassical listing‚Äù.  Each name in the enumeration is assigned an integer value that corresponds to a specific place in the order of values ‚Äã‚Äãin the enumeration: <ul><li>  ST_Unknown = 0 </li><li>  ST_Data = 1 </li><li>  ST_Debug = 2 </li><li>  ST_File = 3 </li><li>  ST_Function = 4 </li><li>  ST_Other = 5 </li></ul><br>  Once again, I stress that this is just an enumeration, not a set of masks.  If these constants could be combined with each other, then they would be a power of 2. <br><br>  Now it's time to look at the code where this enumeration is used incorrectly: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MachODebugMapParser::loadMainBinarySymbols(....) { .... SymbolRef::Type Type = *TypeOrErr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Type &amp; SymbolRef::ST_Debug) || (Type &amp; SymbolRef::ST_Unknown)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V616/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V616/">V616</a> The 'SymbolRef :: ST_Unknown' is used in the bitwise operation.  MachODebugMapParser.cpp 448 <br><br>  Recall that the <i>ST_Unknown</i> constant is zero.  Therefore, the expression can be abbreviated: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type &amp; SymbolRef::ST_Debug)</code> </pre> <br>  There is obviously something wrong here.  Apparently the programmer who wrote this code decided that it works with an enumeration representing flags.  That is, he expected that one constant or another bit corresponds to each constant.  But it is not.  I think the correct check in the code should look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Type == SymbolRef::ST_Debug) || (Type == SymbolRef::ST_Unknown))</code> </pre> <br>  To avoid such errors, I think, one should use the <i>enum class</i> .  In this case, the incorrect expression simply would not compile. <br><br><h3>  One-time cycles </h3><br>  The function is not very complicated, so I decided to bring it entirely.  Before reading the article further, I propose to independently guess what is suspicious here. <br><pre> <code class="cpp hljs">Parser::TPResult Parser::TryParseProtocolQualifiers() { assert(Tok.is(tok::less) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Expected '&lt;' for qualifier list"</span></span>); ConsumeToken(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tok.isNot(tok::identifier)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TPResult::Error; ConsumeToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tok.is(tok::comma)) { ConsumeToken(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tok.is(tok::greater)) { ConsumeToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TPResult::Ambiguous; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TPResult::Error; }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V696/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V696/">V696</a> The 'continue' operator will terminate 'do {...} while (FALSE)' loop because the condition is always false.  Check lines: 1642, 1649. ParseTentative.cpp 1642 <br><br>  The developers of LLVM, of course, will immediately be able to understand whether there is an error here or not.  I have to play detective.  Considering this code, I reasoned as follows.  The function should read the opening '&lt;' bracket, then it reads identifiers and commas in a loop.  If there is no comma, then a closing bracket is expected.  If something went wrong, the function returns an error code.  I think that the following function algorithm (pseudocode) was conceived: <ul><li>  Cycle start: </li><li>  Read id.  If it is not an identifier, then return the error status. </li><li>  Read the comma.  If it is a comma, go to the beginning of the cycle. </li><li>  Yeah, we don't have a comma.  If it is a closing parenthesis, then everything is fine, we exit the function. </li><li>  Otherwise, we return the error status. </li></ul><br>  The trouble is that the cycle is trying to resume using the operator <i>continue</i> .  It transfers control at all not to the beginning of the cycle body, but to checking the conditions for continuing the cycle.  And the condition is always <i>false</i> .  As a result, the cycle immediately ends and the algorithm is as follows: <ul><li>  Cycle start: </li><li>  Read id.  If it is not an identifier, then return the error status. </li><li>  Read the comma.  If it is a comma, end the loop and return the error status from the function. </li><li>  Yeah, we don't have a comma.  If it is a closing parenthesis, then everything is fine, we exit the function. </li><li>  Otherwise, we return the error status. </li></ul><br>  Thus, only a sequence of one element enclosed in square brackets can be correct.  If there are several elements in the sequence separated by a comma, the function will return the error status <i>TPResult :: Error</i> . <br><br>  We now consider another case where no more than 1 iteration of the loop is performed: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkMachOAndArchFlags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArchFlags.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArchFlags[i] == T.getArchName()) ArchFound = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V612/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V612/">V612</a> An unconditional 'break' within a loop.  MachODump.cpp 1206 <br><br>  Pay attention to the <i>break</i> statement.  It will break the loop immediately after the first iteration.  It seems to me that the <i>break</i> statement should relate to the condition, and then the correct code will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArchFlags.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArchFlags[i] == T.getArchName()) { ArchFound = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  There are two more similar places, but in order not to get the article too big, I‚Äôll only give analyzer warnings: <ul><li>  V612 An unconditional 'return' within a loop.  R600OptimizeVectorRegisters.cpp 54 </li><li>  V612 An unconditional 'break' within a loop.  llvm-size.cpp 525 </li></ul><br><h3>  The mixed operator ||  and &amp;&amp; </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsNoDependence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharMatrix &amp;DepMatrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Column)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Column; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DepMatrix[Row][i] != <span class="hljs-string"><span class="hljs-string">'='</span></span> || DepMatrix[Row][i] != <span class="hljs-string"><span class="hljs-string">'S'</span></span> || DepMatrix[Row][i] != <span class="hljs-string"><span class="hljs-string">'I'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V547/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V547/">V547</a> Expression is always true.  Probably the '&amp;&amp;' operator should be used here.  LoopInterchange.cpp 208 <br><br>  The expression does not make sense.  I will simplify the code to highlight the essence of the error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X != <span class="hljs-string"><span class="hljs-string">'='</span></span> || X != <span class="hljs-string"><span class="hljs-string">'S'</span></span> || X != <span class="hljs-string"><span class="hljs-string">'I'</span></span>)</code> </pre> <br>  The variable <i>X</i> will always be something not equal.  As a result, the condition is always true.  Most likely, instead of the operators <i>"||"</i>  should have used the operators <i>"&amp;&amp;"</i> , then the expression becomes meaningful. <br><br><h3>  The function returns a reference to a local object. </h3><br><pre> <code class="cpp hljs">SingleLinkedListIterator&lt;T&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { SingleLinkedListIterator res = *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V558/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V558/">V558</a> Function returns temporary reference: temporary object: res.  LiveInterval.h 679 <br><br>  The function represents the traditional implementation of the postfix increment: <ul><li>  The current state is stored in a temporary object; </li><li>  The current state of the object changes; </li><li>  The old state of the object is returned. </li></ul><br>  The error is that the function returns a link.  This link is not valid, since when exiting the function, the temporary <i>res</i> object will be destroyed. <br><br>  To fix the situation, you need to return the value, not the link: <br><pre> <code class="cpp hljs">SingleLinkedListIterator&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { .... }</code> </pre> <br><h3>  Reassignment </h3><br>  I'll give the whole function, so that no one would think that before re-assigning the variable <i>ZeroDirective</i> is somehow used. <br><pre> <code class="cpp hljs">HexagonMCAsmInfo::HexagonMCAsmInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT) { Data16bitsDirective = <span class="hljs-string"><span class="hljs-string">"\t.half\t"</span></span>; Data32bitsDirective = <span class="hljs-string"><span class="hljs-string">"\t.word\t"</span></span>; Data64bitsDirective = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ZeroDirective = <span class="hljs-string"><span class="hljs-string">"\t.skip\t"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= CommentString = "//"; LCOMMDirectiveAlignmentType = LCOMM::ByteAlignment; InlineAsmStart = "# InlineAsm Start"; InlineAsmEnd = "# InlineAsm End"; ZeroDirective = "\t.space\t"; // &lt;= AscizDirective = "\t.string\t"; SupportsDebugInformation = true; MinInstAlignment = 4; UsesELFSectionDirectiveForBSS = true; ExceptionsType = ExceptionHandling::DwarfCFI; }</span></span></code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V519/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V519/">V519</a> The 'ZeroDirective' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 25, 31. HexagonMCAsmInfo.cpp 31 <br><br>  The variable <i>ZeroDirective</i> is a simple pointer of type <i>const char *</i> .  At the beginning, he points to the string "\ t.skip \ t", and just below he is assigned the address of the string "\ t.space \ t".  It is strange and does not make sense.  There is a high probability that one of the assignments should change a completely different variable. <br><br>  Consider another case of reassignment. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ELFT</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GNUStyle</span></span></span><span class="hljs-class">&lt;ELFT&gt;:</span></span>:printFileHeaders(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ELFO *Obj) { .... Str = printEnum(e-&gt;e_ident[ELF::EI_OSABI], makeArrayRef(ElfOSABI)); printFields(OS, <span class="hljs-string"><span class="hljs-string">"OS/ABI:"</span></span>, Str); Str = <span class="hljs-string"><span class="hljs-string">"0x"</span></span> + to_hexString(e-&gt;e_version); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Str = to_hexString(e-&gt;e_ident[ELF::EI_ABIVERSION]); // &lt;= printFields(OS, "ABI Version:", Str); Str = printEnum(e-&gt;e_type, makeArrayRef(ElfObjectFileType)); printFields(OS, "Type:", Str); .... }</span></span></code> </pre> <br>  <b>PVS-Studio</b> warning <b>:</b> V519 The 'Str' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 2407, 2408. ELFDumper.cpp 2408 <br><br>  Apparently we are dealing with a typo.  Instead of reassignment, it was necessary to concatenate two strings using the <i>+ =</i> operator.  Then the correct code should look like this: <br><pre> <code class="cpp hljs">Str = <span class="hljs-string"><span class="hljs-string">"0x"</span></span> + to_hexString(e-&gt;e_version); Str += to_hexString(e-&gt;e_ident[ELF::EI_ABIVERSION]);</code> </pre> <br>  There are some more code fragments where reassignment occurs.  In my opinion, these reassignments do not pose any danger, so I‚Äôll simply list the corresponding warnings: <ul><li>  V519 The variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 55, 57. coff2yaml.cpp 57 </li><li>  V519 The 'O' variable is assigned twice successively.  Perhaps this is a mistake.  Check lines: 394, 395. llvm-pdbdump.cpp 395 </li><li>  V519 The 'servAddr.sin_family' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 63, 64. server.cpp 64 </li></ul><br><h3>  Suspicious work with smart pointers </h3><br><pre> <code class="cpp hljs">Expected&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;PDBFile&gt;&gt; PDBFileBuilder::build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;msf::WritableStream&gt; PdbFileBuffer) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> File = llvm::make_unique&lt;PDBFile&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(PdbFileBuffer), Allocator); File-&gt;ContainerLayout = *ExpectedLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Info) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ExpectedInfo = Info-&gt;build(*File, *PdbFileBuffer); .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V522/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V522/">V522</a> Dereferencing of the null pointer 'PdbFileBuffer' might take place.  PDBFileBuilder.cpp 106 <br><br>  I don‚Äôt understand the code, because, for example, I didn‚Äôt study what <i>llvm :: make_unique is</i> and how it all works.  Nevertheless, the analyzer and I am alarmed by the fact that at first glance the possession of an object from the smart pointer <i>PdbFileBuffer</i> goes to <i>File</i> .  After that, the smart pointer <i>PdbFileBuffer</i> is dereferenced, which, in theory, at this moment already contains <i>nullptr</i> inside itself.  That is, the following is alarming: <br><pre> <code class="cpp hljs">.... llvm::make_unique&lt;PDBFile&gt;(::move(PdbFileBuffer), Allocator); .... .... Info-&gt;build(*File, *PdbFileBuffer);</code> </pre> <br>  If this is a mistake, then it should be corrected in 3 more places in the same file: <ul><li>  V522 Dereferencing of the null pointer 'PdbFileBuffer' might take place.  PDBFileBuilder.cpp 113 </li><li>  V522 Dereferencing of the null pointer 'PdbFileBuffer' might take place.  PDBFileBuilder.cpp 120 </li><li>  V522 Dereferencing of the null pointer 'PdbFileBuffer' might take place.  PDBFileBuilder.cpp 127 </li></ul><br><h3>  A typo in the condition </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">areExclusiveRanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryOperatorKind OpcodeLHS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> APSInt &amp;ValueLHS, BinaryOperatorKind OpcodeRHS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> APSInt &amp;ValueRHS)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Handle cases where the constants are different. if ((OpcodeLHS == BO_EQ || OpcodeLHS == BO_LE || // &lt;= OpcodeLHS == BO_LE) // &lt;= &amp;&amp; (OpcodeRHS == BO_EQ || OpcodeRHS == BO_GT || OpcodeRHS == BO_GE)) return true; .... }</span></span></code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V501/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V501/">V501</a> There are identical sub-expressions 'OpcodeLHS == BO_LE'  operator.  RedundantExpressionCheck.cpp 174 <br><br>  This is a classic typo.  The variable <i>OpcodeLHS is</i> twice compared with the constant <i>BO_LE</i> .  It seems to me that one of the constants <i>BO_LE</i> should be replaced by <i>BO_LT</i> .  As you can see the names of the constants are similar to each other and easy to confuse. <br><br>  The following example demonstrates how static analysis complements other methodologies for writing high-quality code.  Consider the error code: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Function *, Function *&gt; llvm::createSanitizerCtorAndInitFunctions( .... ArrayRef&lt;Type *&gt; InitArgTypes, ArrayRef&lt;Value *&gt; InitArgs, ....) { assert(!InitName.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Expected init function name"</span></span>); assert(InitArgTypes.size() == InitArgTypes.size() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Sanitizer's init function expects "</span></span> <span class="hljs-string"><span class="hljs-string">"different number of arguments"</span></span>); ....</code> </pre> <br>  } <br><br>  <b>PVS-Studio</b> warning <b>:</b> V501 There are identical sub-expressions 'InitArgTypes.size ()' to the left.  ModuleUtils.cpp 107 <br><br>  One good way to increase code reliability is to use <a href="https://ru.wikipedia.org/wiki/Assert.h"><i>assert ()</i></a> macros.  This and similar macros help to identify many errors during the development and debugging of the program.  However, I will not go into the detailed descriptions of the benefits brought by such macros, since this is beyond the scope of the article. <br><br>  What matters to us is that the <i>createSanitizerCtorAndInitFunctions ()</i> function uses <i>assert ()</i> macros to check the correctness of the input values.  That's just because of a typo second <i>assert () is</i> useless. <br><br>  Fortunately, we are helped by a static analyzer, which notices that the size of the array compares with itself.  As a result, we can fix the check, and the correct condition in <i>assert ()</i> over time can help prevent some other error. <br><br>  Apparently, the condition should compare the sizes of the <i>InitArgTypes</i> and <i>InitArgs arrays</i> : <br><pre> <code class="cpp hljs">assert(InitArgTypes.size() == InitArgs.size() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Sanitizer's init function expects "</span></span> <span class="hljs-string"><span class="hljs-string">"different number of arguments"</span></span>);</code> </pre> <br><h3>  Confusion between release () and reset () </h3><br>  In the class <i>std :: unique_ptr</i> there are two consonant functions: <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr/release"><i>release</i></a> and <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr/reset"><i>reset</i></a> .  As my observations show, they are sometimes confused.  Apparently it happened here: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;DiagnosticConsumer&gt; takeClient() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Owner); } VerifyDiagnosticConsumer::~VerifyDiagnosticConsumer() { .... SrcManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; CheckDiagnostics(); Diags.takeClient().release(); }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V530/">warning</a> <b>:</b> V530.  VerifyDiagnosticConsumer.cpp 46 <br><br>  Perhaps there is no mistake here and there is some kind of special cunning logic.  But it‚Äôs more like a resource drain.  In any case, this code does not hurt to once again check the developers. <br><br><h3>  Excess conditions </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ARMDAGToDAGISel::tryT1IndexedLoad(SDNode *N) { LoadSDNode *LD = cast&lt;LoadSDNode&gt;(N); EVT LoadedVT = LD-&gt;getMemoryVT(); ISD::MemIndexedMode AM = LD-&gt;getAddressingMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AM == ISD::UNINDEXED || LD-&gt;getExtensionType() != ISD::NON_EXTLOAD || AM != ISD::POST_INC || LoadedVT.getSimpleVT().SimpleTy != MVT::i32) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V590/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V590/">V590</a> Consider inspecting this expression.  The expression is misprint.  ARMISelDAGToDAG.cpp 1565 <br><br>  The condition is long, so I will highlight the most important thing: <br><pre> <code class="cpp hljs">AM == ISD::UNINDEXED || AM != ISD::POST_INC</code> </pre> <br>  This condition is redundant and can be requested to: <br><pre> <code class="cpp hljs">AM != ISD::POST_INC</code> </pre> <br>  So here we see just redundancy in the condition or some kind of error.  Perhaps redundancy indicates to us that they wanted to write some other condition.  I do not presume to judge how dangerous this place is, but it‚Äôs worth checking out.  At the same time I want to draw the attention of developers to 2 more warnings of the analyzer: <ul><li>  V590 Consider inspecting this expression.  The expression is misprint.  ASTReader.cpp 4178 </li><li>  V590 Consider inspecting this expression.  The expression is misprint.  BracesAroundStatementsCheck.cpp 46 </li></ul><br><h3>  My Favorite Warnings V595 </h3><br>  Pointers in C and C ++ are an endless programmer headache.  Check them to zero, check, and somewhere - once!  - and again null pointer dereference.  Diagnostics <a href="http://www.viva64.com/ru/w/V595/">V595</a> detects situations when checking a pointer to zero equality is too late.  Before this check, the pointer is already used.  This is one of the most typical errors that we find in the code of various applications ( <a href="http://www.viva64.com/ru/examples/V595/">proof</a> ).  However, in defense of C / C ++ I‚Äôll say that the situation in C # is not much better.  From the fact that pointers in C # were called links, such errors did not disappear ( <a href="http://www.viva64.com/ru/examples/V3095/">proof</a> ). <br><br>  Let's return to the LLVM code and consider a simple version of the error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> PPCDarwinAsmPrinter::doFinalization(Module &amp;M) { .... MachineModuleInfoMachO &amp;MMIMacho = MMI-&gt;getObjFileInfo&lt;MachineModuleInfoMachO&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MAI-&gt;doesSupportExceptionHandling() &amp;&amp; MMI) { .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V595/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V595/">V595</a> The 'MMI' pointer was used before it was verified against nullptr.  Check lines: 1357, 1359. PPCAsmPrinter.cpp 1357 <br><br>  The case is simple and everything is immediately clear.  The check <i>(... &amp;&amp; MMI)</i> tells us that the <i>MMI</i> pointer can be zero.  If so, the program flow will not get to this check.  It will be interrupted earlier due to null pointer dereferencing. <br><br>  Consider another code snippet: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::CodeCompleteObjCProtocolReferences( ArrayRef&lt;IdentifierLocPair&gt; Protocols) { <span class="hljs-function"><span class="hljs-function">ResultBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Results</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, CodeCompleter-&gt;getAllocator(), CodeCompleter-&gt;getCodeCompletionTUInfo(), CodeCompletionContext::CCC_ObjCProtocolName)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CodeCompleter &amp;&amp; CodeCompleter-&gt;includeGlobals()) { Results.EnterNewScope(); .... }</code> </pre> <br>  <b>PVS-Studio</b> warning <b>:</b> V595 The 'CodeCompleter' pointer was used against nullptr.  Check lines: 5952, 5955. SemaCodeComplete.cpp 5952 <br><br>  The <i>CodeCompleter</i> pointer <i>is</i> first dereferenced, and below is a check for the equality of this pointer to zero.  The same code is found three more times in the same file: <ul><li>  V595 The 'CodeCompleter' pointer was used before it was verified against nullptr.  Check lines: 5980, 5983. SemaCodeComplete.cpp 5980 </li><li>  V595 The 'CodeCompleter' pointer was used before it was verified against nullptr.  Check lines: 7455, 7458. SemaCodeComplete.cpp 7455 </li><li>  V595 The 'CodeCompleter' pointer was used before it was verified against nullptr.  Check lines: 7483, 7486. SemaCodeComplete.cpp 7483 </li></ul><br>  These were simple cases, but there is also more confusing code, where I cannot tell right away how dangerous it is.  Therefore, I suggest that developers independently verify the following sections of the LLVM code: <ul><li>  V595 The Receiver  Check lines: 2543, 2560. SemaExprObjC.cpp 2543 </li><li>  V595 The 'S' pointer has been verified against nullptr.  Check lines: 1267, 1296. SemaLookup.cpp 1267 </li><li>  V595 The 'TargetDecl' pointer was used before it was verified against nullptr.  Check lines: 4037, 4046. CGExpr.cpp 4037 </li><li>  V595 The 'CurrentToken' pointer was used before it was verified against nullptr.  Check lines: 705, 708. TokenAnnotator.cpp 705 </li><li>  V595 The 'FT' pointer has been verified against nullptr.  Check lines: 540, 554. Expr.cpp 540 </li><li>  V595 The 'II' pointer has been verified against nullptr.  Check lines: 448, 450. IdentifierTable.cpp 448 </li><li>  V595 The 'MF' pointer was used before it was verified against nullptr.  Check lines: 268, 274. X86RegisterInfo.cpp 268 </li><li>  V595 The 'External' pointer was used against nullptr.  Check lines: 40, 45. HeaderSearch.cpp 40 </li><li>  V595 The 'TLI' pointer was used before it was verified against nullptr.  Check lines: 4239, 4244. CodeGenPrepare.cpp 4239 </li><li>  V595 The 'SU-&gt; getNode ()' pointer was used before it was verified against nullptr.  Check lines: 292, 297. ResourcePriorityQueue.cpp 292 </li><li>  V595 The 'BO0' pointer was used before it was verified against nullptr.  Check lines: 2835, 2861. InstCombineCompares.cpp 2835 </li><li>  It was verified against nullptr.  Check lines: 2090, 2092. ObjCARCOpts.cpp 2090 </li></ul><br><h3>  Strange code </h3><br>  I apologize for presenting a hard-to-read snippet of code.  Suffer it, until the end of the article there is not much. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_class_ro64_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *r; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> offset, xoffset, left; .... r = get_pointer_64(p, offset, left, S, info); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || left &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;cro, <span class="hljs-string"><span class="hljs-string">'\0'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;cro, r, left); outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" (class_ro_t entends past the .......)\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;cro, r, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)); .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V649/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V649/">V649</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains function return.  This means that the statement is senseless.  Check lines: 4410, 4413. MachODump.cpp 4413 <br><br>  Pay attention to the check: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || left &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  If the value contained in the variable <i>left</i> is smaller than the class size, then the function will exit.  It turns out that this choice of behavior does not make sense: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;cro, r, left); outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" (class_ro_t entends past the .......)\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;cro, r, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">class_ro64_t</span></span>));</code> </pre> <br>  The condition is always false, and therefore the else-branch is always executed.  It is very strange.  Perhaps the program contains a logical error, or we are dealing with a typo. <br><br>  At the same time you should check this place: <ul><li>  V649 There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains function return.  This means that the statement is senseless.  Check lines: 4612, 4615. MachODump.cpp 4615 </li></ul><br><h3>  Different trifle </h3><br>  Inside the template <i>RPC</i> class, the <i>SequenceNumberManager</i> class is declared.  It has this move assignment operator: <br><pre> <code class="cpp hljs">SequenceNumberManager &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(SequenceNumberManager &amp;&amp;Other) { NextSequenceNumber = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Other.NextSequenceNumber); FreeSequenceNumbers = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Other.FreeSequenceNumbers); }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V591/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V591/">V591</a> Non-void function should return a value.  RPCUtils.h 719 <br><br>  As you can see at the end forgot to write return: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  In fact, there is nothing wrong with that.  Compilers, as a rule, do not work with bodies of functions of template classes, if these functions are not used.  Here, apparently, is such a case.  Although I did not check, but I‚Äôm sure: if you call such a move statement, the compiler will generate a compilation error or a loud warning.  So there is nothing wrong here, but I decided to point out this flaw. <br><br>  We met several strange sections of the code where the value of the pointer that returned the <i>new</i> operator is checked for equality to zero.     ,       ,     <i>std::bad_alloc</i> .     : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LLVMDisasmContextRef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLVMCreateDisasmCPUFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Set up the MCContext for creating symbols and MCExpr's. MCContext *Ctx = new MCContext(MAI, MRI, nullptr); if (!Ctx) return nullptr; .... }</span></span></code> </pre> <br> <b> PVS-Studio:</b> <a href="http://www.viva64.com/ru/w/V668/">V668</a> There is no sense in testing the 'Ctx' pointer against null, as the memory was allocated using the 'new' operator.  The exception will be generated in the case of memory allocation error. Disassembler.cpp 76 <br><br>   2 : <ul><li> V668 There is no sense in testing the 'DC' pointer against null, as the memory was allocated using the 'new' operator.  The exception will be generated in the case of memory allocation error. Disassembler.cpp 103 </li><li> V668 There is no sense in testing the 'JITCodeEntry' pointer against null, as the memory was allocated using the 'new' operator.  The exception will be generated in the case of memory allocation error. GDBRegistrationListener.cpp 180 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code does not look dangerous, so I decided to describe them in the non-essential warnings section. </font><font style="vertical-align: inherit;">Most likely, all these three checks can be simply deleted.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, compiler warnings are good, but not enough. </font><font style="vertical-align: inherit;">Specialized static analysis tools, such as PVS-Studio, will always be ahead of the compilers in diagnostic capabilities and configuration flexibility when working with warnings. </font><font style="vertical-align: inherit;">Actually, this is where analyzer developers make their money.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also important to note that the main effect of applying the methodology of static analysis is achieved with the regular use of static code analyzers. Many errors will be detected at the earliest stage, and they will not need to be debugged or the user be asked to describe in detail the sequence of actions leading to the crash of the program. Here is a complete analogy with the compiler warnings (in fact, these are the same warnings, but more intelligent). You see the compiler warnings constantly, not once a month? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We invite you to download and try </font></font><a href="http://www.viva64.com/ru/pvs-studio/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the code of your project.</font></font><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0446/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey karpov. </font></font><a href="http://www.viva64.com/en/b/0446/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding bugs in the code of LLVM project with the help of PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/314044/">https://habr.com/ru/post/314044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314032/index.html">Setting up the environment for PHP developers</a></li>
<li><a href="../314034/index.html">We are creating a news site using Flexbox</a></li>
<li><a href="../314038/index.html">How to turn a smartphone into a microphone (ideas and questions)</a></li>
<li><a href="../314040/index.html">How to find a vector of software development? Planning as a science</a></li>
<li><a href="../314042/index.html">Time is money, or arguments for and against hourly pay.</a></li>
<li><a href="../314046/index.html">How I went to the first in Russia "Testathon", hackathon for testers</a></li>
<li><a href="../314048/index.html">Safety when using PostgreSQL</a></li>
<li><a href="../314050/index.html">As I wrote the application on Elm</a></li>
<li><a href="../314054/index.html">Editing a hopeless support letter</a></li>
<li><a href="../314056/index.html">Optimization by example. Ant algorithm (ACS) vs Annealing Method. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>