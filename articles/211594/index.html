<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Toothpick-detective reveals the secret of the radio protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a small sketch to the story about " Convenient Home ". Just an illustration of the fact that even with not too much knowledge and experience s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Toothpick-detective reveals the secret of the radio protocol</h1><div class="post__text post__text-html js-mediator-article">  This is a small sketch to the story about " <a href="http://habrahabr.ru/post/210664/">Convenient Home</a> ".  Just an illustration of the fact that even with not too much knowledge and experience something can be achieved.  In other words, a sufficiently persistent woodpecker zadolbit any tree. <br><br>  It all started with a simple desire to control the light in the house with the help of Arduino.  Including - switches <a href="http://www.aliexpress.com/store/500715">Livolo</a> , bought before this crazy undertaking with home automation.  But, unlike radio sockets, ‚Äúclicking‚Äù them with the help of my favorite library RC-Switch did not work, and the search for other ready-made solutions showed their complete absence. <br><br>  Yes, and the Chinese manufacturers, vendors to the question about the protocol answered that this thing works at a frequency of 433 MHz.  Not too useful information.  However, I will not depict the holy innocence.  After all, I, along with Arduino, bought a couple of blocks of four relays so that, if anything, it is trite to close the remote control buttons.  And this, by the way, is quite a popular decision, because it is fast, relatively cheap and very angry. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But in my heart I strove for beauty.  Strangely enough, the usual toothpick, two resistors and one capacitor helped. <br><a name="habracut"></a><br><br><h5>  Epic dips </h5><br>  At first, however, I did not think about toothpicks.  But in the process of reading any more or less simple decoding of radio protocols, I came across a wonderful resource NetHome.  And there, the author publishes, firstly, <a href="http://wiki.nethome.nu/doku.php/analyzer/hardware">a divider circuit</a> that allows you to record a demodulated signal from the receiver to a computer via a normal microphone input and at the same time - a simple <a href="http://wiki.nethome.nu/doku.php/analyzer/start">Protocol Analyzer</a> utility for recording and analyzing the signal. <br><br>  .  heroes of the day <br><img src="https://habrastorage.org/getpro/habr/post_images/d95/c08/3be/d95c083be9c16dc1855620a970a4aa2d.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/cc8/321/4b9/cc83214b9f8ef8ad92426058b0748d0e.jpg" alt="image"><br><br>  So I assembled the divider, connected it to the laptop, pressed the remote control button, and looked at the results - fortunately, the (amplitude) modulation of the console coincided with the modulation of the receiver.  Protocol Analyzer is generally a pretty cool thing.  The program identifies the most popular protocols, and if it encounters the unknown, you can see an ‚Äúoscillogram‚Äù with a layout by impulses.  Unfortunately, she did not know the Livolo protocol.  And even confused me a little, since it did not quite clearly show the true form of the Livolo remote control signal. <br><br>  It turned out by chance when it occurred to me to see the signal also in <a href="http://audacity.sourceforge.net/%3Flang%3Dru">Audacity</a> .  Here the pulses became clearly visible and, as it seems to me, the reason for the troubles of the Protocol Analyzer is obvious: the extremely short duration of these pulses is from 100 to 500 microseconds.  In the same editor, I decided to go a simple way - to record the received signal in WAV, and then reproduce it using the Arduino on the pin to which the transmitter is connected.  After all, I also had an Ethernet-shield with a microSD slot, which was quite suitable for a ‚Äúplayer‚Äù.  With a bit of searching, the ‚Äúmusic‚Äù library <a href="https://github.com/TMRh20/TMRpcm">TMRpcm was also found</a> . <br><br>  .  this is what protocol analyzer showed <br><img src="https://habrastorage.org/getpro/habr/post_images/319/5d1/424/3195d142444bcbb2cea1ae6e6c3f0fea.jpg"><br><br>  .  compare with Audacity <br><img src="https://habrastorage.org/getpro/habr/post_images/3da/2e9/d3a/3da2e9d3a7319b46d4fbbd1996665f8e.jpg"><br><br>  The idea was based on the fact that IR protocols similar in their essence are successfully and fairly simply simulated by connecting the IR LED to the computer‚Äôs audio output or other gadget capable of reproducing sound with suitable parameters.  No sooner said than done.  And put aside: the switches did not understand the joke, and a viewing of the signal emitted in this way in Audacity showed that the pulse shape was too distorted. <br><br><h5>  Shape repetition </h5><br>  Then I decided on extreme measures.  Namely - stupidly repeat the waveform, without going into a logical level.  To do this, it is necessary and rather hard to encode the code parcels in the Arduino sketch.  And here I am very lucky. <br><br>  If we consider the code parcel of the Livolo console, we can see that it consists of a set (about 100) of multiple repetitive pulse packets.  So, all the packets in the code message are exactly the same - this is a kind of protection from interference: an excessive number of packets ensures, firstly, reliable capture of the receiver's AGC signal, and, secondly, the reception of the command itself. <br><br>  .  Here's a picture, if you press the buttons in a row <br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/dc4/662/e6adc46629b38fdeecc8e4fc1c76c8f2.jpg"><br><br>  .  understand where the signal, and where the noise is quite simple.  Here you can estimate the scale of the disaster: the signal is just one button. <br><img src="https://habrastorage.org/getpro/habr/post_images/bf1/cdf/72a/bf1cdf72a3acfbd66647e8667fa3f646.jpg" alt="image"><br><br>  But not only the impulse packets within the same code package turned out to be the same.  Livolo also uses a system of fixed codes, that is, the same pulse packet always corresponds to a single button on the console.  It is easy to verify this: you only need to press the same button several times and compare the results.  In my case, they were all completely identical. <br><br>  .  repetition is not only the mother of learning, but also a guarantee of a confident signal reception <br><img src="https://habrastorage.org/getpro/habr/post_images/793/2e8/658/7932e86587293f13a94e49154fb41570.jpg"><br><br>  This is what I call luck: fixed code without any frills. <br><br>  Thus, it was required to consistently press and record the signal of all the necessary buttons on the console in Audacity, and then calculate the number of pulses in the packet of each button, find out their duration and transfer it all to the Arduino code.  This required a tool that is thin enough not to close the signal review in Audacity and neutral enough so as not to scratch the laptop display during the process. <br><br>  And here came the high point of the toothpick.  In fact, the art of counting impulses only through my eyes is not available to me, but if you use a pointer, nothing at all.  In one hand - a toothpick, the other immediately recorded the results. <br><br>  With sufficient magnification, it can be seen that the packet consists of five types of pulses (conditionally: long down, short up, short down, middle up, middle down). <br><br>  . <br><img src="https://habrastorage.org/getpro/habr/post_images/681/92d/110/68192d11017c7a7132247f5c5ea2163e.jpg" alt="image"><br><br>  If you increase it even further, you can estimate by eye the length of the pulses along the Audacity line, which I did for all five.  In addition, each pulse has been assigned a sequence number ‚Äî this is based on using byte variables to save Arduino memory.  I just now thought that it would be possible to divide by 10 and not suffer with ‚Äúabbreviations‚Äù. <br><br>  .  The theoretical limits of the pulses are highlighted in blue and red, since ideally the fronts should be vertical, but that is if there is no radio channel <br><img src="https://habrastorage.org/getpro/habr/post_images/2b1/35c/4c0/2b135c4c030f6bbab550da6c34594d6d.jpg" alt="image"><br><br>  The work was not so much intellectual as dreary.  The number of individual pulses "floated" from button to button.  And although I assumed that from a reasonable point of view it should not be so, I did not reach the logical level analysis.  Just coded the result and tried it in work. <br><br>  From the first, nothing happened.  However, it was expected.  What I did not expect was the fact that everything would work the second time.  But the thing turned out to be that with direct encoding (i.e. if the pulse is up, we encode OUTPUT / HIGH) the signal turned out to be inverted - obviously, this is a feature of the transmitter.  It was easy to solve this: we invert the levels in the code (i.e. the impulse upwards we encode OUTPUT / LOW).  A comparison of the imitation and the original signal (in Audactiy, by eye) also showed a slight discrepancy in the length of the pulses - I also corrected it. <br><br><div class="spoiler">  <b class="spoiler_title">The first version, the great and terrible</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> txPin = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pin connected to RF transmitter int i; // counter to send command pulses int pulse; // count pulse repetitions int incomingByte = 0; // for incoming serial data // hard coded commands (see txButton): 1 - pulse start, 2 - zero, 3 - one, 4 - pause, 5 - low int button1[45]={44, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; int button2[43]={43, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; int button3[41]={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 5, 3, 4, 2, 4, 2, 4, 2}; int button4[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2}; int button5[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2}; int button6[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2, 4, 2}; int button7[41]={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 5, 3, 4, 2, 4, 2}; int button8[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2}; int button9[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2}; int button10[43]={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 2, 4, 3, 4, 2, 4, 2, 4, 2}; int button11[41]={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 5, 2, 4, 3, 4, 2}; void setup () { pinMode(txPin, OUTPUT); Serial.begin(9600); Serial.println("Number = button; a to press 0; b to shut off all"); } void loop(){ if (Serial.available() &gt; 0) { // read the incoming byte: incomingByte = Serial.read(); switch(incomingByte) { case 49: txButton(button1); Serial.println("Switching on 1"); break; case 50: txButton(button2); Serial.println("Switching on 2"); break; case 51: txButton(button3); Serial.println("Switching on 3"); break; case 52: txButton(button4); Serial.println("Switching on 4"); break; case 53: txButton(button5); Serial.println("Switching on 5"); break; case 54: txButton(button6); Serial.println("Switching on 6"); break; case 55: txButton(button7); Serial.println("Switching on 7"); break; case 56: txButton(button8); Serial.println("Switching on 8"); break; case 57: txButton(button9); Serial.println("Switching on 9"); break; case 97: txButton(button10); Serial.println("Switching on 0"); break; case 98: txButton(button11); Serial.println("Switching All off"); break; } } // end if serial available }// end void loop // transmit command. Due to transmitter (or something, I don't know) transmission code should be INVERTED. Ex: one is coded as LOW-delay-&gt;HIGH instead of HIGH-delay-LOW void txButton(int cmd[]) { Serial.print("Processing. Array size is "); Serial.println(cmd[0]); digitalWrite(txPin, HIGH); // not sure if its required, just an attempt to start transmission to enable AGC of the receiver delay(1000); for (pulse= 0; pulse &lt;= 100; pulse=pulse+1) { // repeat command 100 times for (i = 1; i &lt; cmd[0]+1; i = i + 1) { // transmit command switch(cmd[i]) { case 1: // start digitalWrite(txPin, HIGH); delayMicroseconds(550); digitalWrite(txPin, LOW); // Serial.print("s"); break; case 2: // "zero", that is short high spike digitalWrite(txPin, LOW); delayMicroseconds(110); digitalWrite(txPin, HIGH); // Serial.print("0"); break; case 3: // "one", that is long high spike digitalWrite(txPin, LOW); delayMicroseconds(303); digitalWrite(txPin, HIGH); // Serial.print("1"); break; case 4: // pause, that is short low spike digitalWrite(txPin, HIGH); delayMicroseconds(110); digitalWrite(txPin, LOW); // Serial.print("p"); break; case 5: // low, that is long low spike digitalWrite(txPin, HIGH); delayMicroseconds(290); digitalWrite(txPin, LOW); // Serial.print("l"); break; } } } }</span></span></code> </pre> <br></div></div><br><br>  The final touch of this stage was the insertion of code sequences into the Arduino flash memory (PROGMEM), so as not to occupy precious operational data.  In this form, the travel code, in my opinion, is more than half a year, and then I became bored, and in general I again wanted something beautiful. <br><br><div class="spoiler">  <b class="spoiler_title">The second version with PROGMEM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/pgmspace.h&gt; // needed to use PROGMEM #define txPin 8 // pin connected to RF transmitter (pin 8) byte i; // command pulses counter for Livolo (0 - 100) byte pulse; // counter for command repeat // commands stored in PROGMEM arrays (see on PROGMEM use here: http://arduino.cc/forum/index.php?topic=53240.0) // first array element is length of command const prog_uchar button1[45] PROGMEM ={44, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; const prog_uchar button2[43] PROGMEM ={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; const prog_uchar button3[41] PROGMEM ={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 5, 3, 4, 2, 4, 2, 4, 2}; const prog_uchar button4[43] PROGMEM ={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2}; const prog_uchar button5[43] PROGMEM ={42, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2}; const prog_uchar button7[41] PROGMEM ={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 5, 3, 4, 2, 4, 2}; const prog_uchar button11[41] PROGMEM ={40, 1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 5, 3, 4, 2, 5, 2, 4, 3, 4, 2}; // pointers to command arrays PROGMEM const prog_uchar *buttonPointer[] = {button1, button2, button3, button4, button5, button7, button11}; void setup() { // sipmle example: send button "button2" once. Note that array elements numbered starting from "0" (so button1 is 0, button2 is 1 and so on) txButton(1); } void loop() { } // transmitting part // zeroes and ones here are not actual 0 and 1. I just called these pulses for my own convenience. // also note that I had to invert pulses to get everything working // that said in actual command "start pulse" is long low; "zero" = short high; "one" = long high; "pause" is short low; "low" is long low. void txButton(byte cmd) { prog_uchar *currentPointer = (prog_uchar *)pgm_read_word(&amp;buttonPointer[cmd]); // current pointer to command array passed as txButton(cmd) argument byte cmdCounter = pgm_read_byte(¬§tPointer[0]); // read array length for (pulse= 0; pulse &lt;= 180; pulse = pulse+1) { // how many times to transmit a command for (i = 1; i &lt; cmdCounter+1; i = i + 1) { // counter for reading command array byte currentCmd = pgm_read_byte(¬§tPointer[i]); // readpulse type from array switch(currentCmd) { // transmit pulse case 1: // start pulse digitalWrite(txPin, HIGH); delayMicroseconds(550); digitalWrite(txPin, LOW); break; case 2: // "zero" digitalWrite(txPin, LOW); delayMicroseconds(110); digitalWrite(txPin, HIGH); break; case 3: // "one" digitalWrite(txPin, LOW); delayMicroseconds(303); digitalWrite(txPin, HIGH); break; case 4: // "pause" digitalWrite(txPin, HIGH); delayMicroseconds(110); digitalWrite(txPin, LOW); break; case 5: // "low" digitalWrite(txPin, HIGH); delayMicroseconds(290); digitalWrite(txPin, LOW); break; } } } digitalWrite(txPin, LOW); }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  Highlighting common </h5><br>  Once again, looking at the WAV, I did not really hope for anything.  However, more careful than before, the comparison of the code parcels gave a pleasant surprise.  Part of the sequence at the beginning of each packet of pulses turned out to be common for all packets of one code parcel, and for all buttons on the console in general. <br><br>  .  cutting different buttons - and it‚Äôs immediately obvious that part of the package does not change <br><img src="https://habrastorage.org/getpro/habr/post_images/ced/819/31a/ced81931ae8c5bca5dcf1f68980875f2.jpg"><br><br>  Understanding the protocol was still far away, but this small discovery made it possible to further save controller memory.  I simply brought a single part of the package into a separate array, which was automatically ‚Äúplayed back‚Äù before each unique part. <br><br><div class="spoiler">  <b class="spoiler_title">The common part is now settled in a separate array.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/pgmspace.h&gt; // needed to use PROGMEM #define txPin 8 // pin connected to RF transmitter (pin 8) byte i; // command pulses counter for Livolo (0 - 100) byte pulse; // counter for command repeat // commands stored in PROGMEM arrays (see on PROGMEM use here: http://arduino.cc/forum/index.php?topic=53240.0) // first array element is length of command const prog_uchar start[30] PROGMEM = {1, 2, 4, 2, 4, 2, 4, 3, 5, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; // remote ID - no need to store it with each command const prog_uchar button1[15] PROGMEM ={14, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; // only command bits const prog_uchar button2[13] PROGMEM ={12, 5, 3, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2}; const prog_uchar button3[11] PROGMEM ={10, 5, 3, 5, 3, 4, 2, 4, 2, 4, 2}; const prog_uchar button4[13] PROGMEM ={12, 4, 2, 4, 2, 5, 3, 4, 2, 4, 2, 4, 2}; const prog_uchar button5[13] PROGMEM ={12, 5, 2, 4, 3, 4, 2, 4, 2, 4, 2, 4, 2}; const prog_uchar button7[11] PROGMEM ={10, 5, 3, 4, 2, 5, 3, 4, 2, 4, 2}; const prog_uchar button11[11] PROGMEM ={10, 5, 3, 4, 2, 5, 2, 4, 3, 4, 2}; // pointers to command arrays PROGMEM const prog_uchar *buttonPointer[] = {start, button1, button2, button3, button4, button5, button7, button11}; void setup() { // sipmle example: send button "button2" once. Note that array elements numbered starting from "0" (so button1 is 0, button2 is 1 and so on) // Serial.begin(9600); } void loop() { txButton(3); delay(1000); } // transmitting part // zeroes and ones here are not actual 0 and 1. I just called these pulses for my own convenience. // also note that I had to invert pulses to get everything working // that said in actual command "start pulse" is long low; "zero" = short high; "one" = long high; "pause" is short low; "low" is long low. void txButton(byte cmd) { prog_uchar *currentPointer = (prog_uchar *)pgm_read_word(&amp;buttonPointer[cmd]); // current pointer to command array passed as txButton(cmd) argument byte cmdCounter = pgm_read_byte(¬§tPointer[0]); // read array length prog_uchar *currentPointerStart = (prog_uchar *)pgm_read_word(&amp;buttonPointer[0]); // current pointer to start command array for (pulse= 0; pulse &lt;= 180; pulse = pulse+1) { // how many times to transmit a command for (i = 0; i&lt;30; i=i+1) { byte currentCmd = pgm_read_byte(¬§tPointerStart[i]); sendPulse(currentCmd); // Serial.print(currentCmd); // Serial.print(", "); } for (i = 1; i &lt; cmdCounter+1; i = i + 1) { // counter for reading command array byte currentCmd = pgm_read_byte(¬§tPointer[i]); // readpulse type from array sendPulse(currentCmd); // Serial.print(currentCmd); // Serial.print(", "); } } } void sendPulse(byte txPulse) { switch(txPulse) { // transmit pulse case 1: // start pulse digitalWrite(txPin, HIGH); delayMicroseconds(550); digitalWrite(txPin, LOW); break; case 2: // "zero" digitalWrite(txPin, LOW); delayMicroseconds(110); digitalWrite(txPin, HIGH); break; case 3: // "one" digitalWrite(txPin, LOW); delayMicroseconds(303); digitalWrite(txPin, HIGH); break; case 4: // "pause" digitalWrite(txPin, HIGH); delayMicroseconds(110); digitalWrite(txPin, LOW); break; case 5: // "low" digitalWrite(txPin, HIGH); delayMicroseconds(290); digitalWrite(txPin, LOW); break; } digitalWrite(txPin, LOW); }</span></span></span></span></code> </pre><br></div></div><br><br>  Despite some success and the fact that the code worked quite well and did not ask for bread, I continued to be vaguely disturbed by the fact that the number of pulses in the packages was different.  On the one hand, nothing prevented the protocol from having such a feature, but on the other hand, there were many examples of similar protocols at hand (from sockets, for example, weather stations), where there was a tendency to a 24-bit message. <br><br><h5>  Search for patterns </h5><br>  The third approach to the machine was that I tried to solve the logic of the protocol developer.  From the very beginning it was more comfortable for me to assume that short impulses denote ‚Äú0‚Äù, and of medium duration - ‚Äú1‚Äù.  At the same time, I took the longest impulse in the package as the starting one, and did not burden it with a different meaning. <br><br>  It remained to figure out why impulses are combined up and down (for different durations this does not seem necessary), and how to understand this in general.  The process ended with the following conclusions: <br><br>  1. There is a clear rule of impulse following: the impulse "up" always goes the impulse "down", regardless of the duration of the impulse. <br>  2. Two short pulses in a row in my coordinate system mean "0". <br>  3. Similarly, each pulse of average duration means ‚Äú1‚Äù. <br>  4. The longest impulse of the parcel - start or stop, which does not matter and depends only on the point of view. <br><br>  If we apply these rules to a pulse train, it becomes clear that its total length is always 24 bits, including the start-stop.  Of these, 16 bits are the previously ‚Äúfixed‚Äù part and 7 bits are the part unique for each digital button on the remote.  Actually, the constant length of the packet led me to the conclusion that the identification of the logical level was successful. <br><br>  .  by all the rules <br><img src="https://habrastorage.org/getpro/habr/post_images/901/29d/2d3/90129d2d304ca20da0b53746157345db.jpg"><br><br>  From the ‚Äúformat‚Äù of the package, it naturally followed that the 16-bit fragment is most likely an identifier of the console, allowing the use of several consoles in the same apartment, or not interfering with the neighbors if they have the same switches.  Fortunately, I also had in my hands a recording of another remote control, from which it followed that the codes of the numeric buttons were the same for both remotes. <br><br>  All together it means that there is a great opportunity to imitate an almost unlimited number of Livolo remotes, depending on your own fantasies and needs.  The main thing is to follow the rule: 16 bits - the remote control ID, and use either known buttons, or generate them according to the 7-bit principle - the ‚Äúbutton‚Äù. <br><br>  Practice, however, has shown that not all 16-bit remote identifiers are suitable.  But it is not too scary: according to the same practice, finding a suitable identifier is not difficult. <br><br>  It remains only to rewrite the code, and finally get rid of these terrible clumsy arrays. <br><br><div class="spoiler">  <b class="spoiler_title">And here is the result</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> txPin 8 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pin connected to RF transmitter (pin 8) byte i; // just a counter byte pulse; // counter for command repeat boolean high = true; // pulse "sign" // keycodes #1: 0, #2: 96, #3: 120, #4: 24, #5: 80, #6: 48, #7: 108, #8: 12, #9: 72; #10: 40, #OFF: 106 // real remote IDs: 6400; 19303 // tested "virtual" remote ID: 8500, other IDs could work too, as long as they do not exceed 16 bit // known issue: not all 16 bit remote ID are valid // have not tested other buttons, but as there is dimmer control, some keycodes could be strictly system // use: sendButton(remoteID, keycode); // see void loop for an example of use void setup() { } void loop() { sendButton(6400, 120); // blink button #3 every 3 seconds using remote with remoteID #6400 delay(3000); } void sendButton(unsigned int remoteID, byte keycode) { for (pulse= 0; pulse &lt;= 180; pulse = pulse+1) { // how many times to transmit a command sendPulse(1); // Start high = true; // first pulse is always high for (i = 16; i&gt;0; i--) { // transmit remoteID byte txPulse=bitRead(remoteID, i-1); // read bits from remote ID selectPulse(txPulse); } for (i = 7; i&gt;0; i--) { // transmit keycode byte txPulse=bitRead(keycode, i-1); // read bits from keycode selectPulse(txPulse); } } digitalWrite(txPin, LOW); } // build transmit sequence so that every high pulse is followed by low and vice versa void selectPulse(byte inBit) { switch (inBit) { case 0: for (byte ii=1; ii&lt;3; ii++) { if (high == true) { // if current pulse should be high, send High Zero sendPulse(2); } else { // else send Low Zero sendPulse(4); } high=!high; // invert next pulse } break; case 1: // if current pulse should be high, send High One if (high == true) { sendPulse(3); } else { // else send Low One sendPulse(5); } high=!high; // invert next pulse break; } } // transmit pulses // slightly corrected pulse length, use old (commented out) values if these not working for you void sendPulse(byte txPulse) { switch(txPulse) { // transmit pulse case 1: // Start digitalWrite(txPin, HIGH); delayMicroseconds(500); // 550 digitalWrite(txPin, LOW); break; case 2: // "High Zero" digitalWrite(txPin, LOW); delayMicroseconds(100); // 110 digitalWrite(txPin, HIGH); break; case 3: // "High One" digitalWrite(txPin, LOW); delayMicroseconds(300); // 303 digitalWrite(txPin, HIGH); break; case 4: // "Low Zero" digitalWrite(txPin, HIGH); delayMicroseconds(100); // 110 digitalWrite(txPin, LOW); break; case 5: // "Low One" digitalWrite(txPin, HIGH); delayMicroseconds(300); // 290 digitalWrite(txPin, LOW); break; } }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  We pass to the library </h5><br>  In principle, it would be possible to stop on the new code, but it still cluttered the main program, and others who would like to use it would have to resort to unnecessary copy-paste.  So I decided to practice a little ‚Äúon cats‚Äù and turn it into a separate library. <br><br>  In this process, the <a href="http://arduino.cc/en/Hacking/LibraryTutorial">instruction on the website Arduino.cc</a> provided invaluable assistance.  In Russian, the <a href="http://arduino.ru/Hacking/LibraryTutorial">instruction is published on Arduino.ru</a> . <br><br>  It turned out exactly the recipe (no step to the side, no jumps on the spot).  File h, cpp, readme and a small example showing how to use all this happiness. <br><br><div class="spoiler">  <b class="spoiler_title">Lilvolo.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Livolo.h - Library for Livolo wireless switches. Created by Sergey Chernov, October 25, 2013. Released into the public domain. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> Livolo_h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Livolo_h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Arduino.h"</span></span></span><span class="hljs-meta"> class Livolo { public: Livolo(byte pin); void sendButton(unsigned int remoteID, byte keycode); private: byte txPin; byte i; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// just a counter byte pulse; // counter for command repeat boolean high; // pulse "sign" void selectPulse(byte inBit); void sendPulse(byte txPulse); }; #endif</span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Lilvolo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Livolo.cpp - Library for Livolo wireless switches. Created by Sergey Chernov, October 25, 2013. Released into the public domain. 01/12/2013 - code optimization, thanks Maarten! http://forum.arduino.cc/index.php?topic=153525.msg1489857#msg1489857 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Arduino.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Livolo.h"</span></span></span><span class="hljs-meta"> Livolo::Livolo(byte pin) { pinMode(pin, OUTPUT); txPin = pin; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// keycodes #1: 0, #2: 96, #3: 120, #4: 24, #5: 80, #6: 48, #7: 108, #8: 12, #9: 72; #10: 40, #OFF: 106 // real remote IDs: 6400; 19303 // tested "virtual" remote IDs: 10550; 8500; 7400 // other IDs could work too, as long as they do not exceed 16 bit // known issue: not all 16 bit remote ID are valid // have not tested other buttons, but as there is dimmer control, some keycodes could be strictly system // use: sendButton(remoteID, keycode), see example blink.ino; void Livolo::sendButton(unsigned int remoteID, byte keycode) { for (pulse= 0; pulse &lt;= 180; pulse = pulse+1) { // how many times to transmit a command sendPulse(1); // Start high = true; // first pulse is always high for (i = 16; i&gt;0; i--) { // transmit remoteID byte txPulse=bitRead(remoteID, i-1); // read bits from remote ID selectPulse(txPulse); } for (i = 7; i&gt;0; i--) { // transmit keycode byte txPulse=bitRead(keycode, i-1); // read bits from keycode selectPulse(txPulse); } } digitalWrite(txPin, LOW); } // build transmit sequence so that every high pulse is followed by low and vice versa void Livolo::selectPulse(byte inBit) { switch (inBit) { case 0: for (byte ii=1; ii&lt;3; ii++) { if (high == true) { // if current pulse should be high, send High Zero sendPulse(2); } else { // else send Low Zero sendPulse(4); } high=!high; // invert next pulse } break; case 1: // if current pulse should be high, send High One if (high == true) { sendPulse(3); } else { // else send Low One sendPulse(5); } high=!high; // invert next pulse break; } } // transmit pulses // slightly corrected pulse length, use old (commented out) values if these not working for you void Livolo::sendPulse(byte txPulse) { switch(txPulse) { // transmit pulse case 1: // Start digitalWrite(txPin, HIGH); delayMicroseconds(500); // 550 // digitalWrite(txPin, LOW); break; case 2: // "High Zero" digitalWrite(txPin, LOW); delayMicroseconds(100); // 110 digitalWrite(txPin, HIGH); break; case 3: // "High One" digitalWrite(txPin, LOW); delayMicroseconds(300); // 303 digitalWrite(txPin, HIGH); break; case 4: // "Low Zero" digitalWrite(txPin, HIGH); delayMicroseconds(100); // 110 digitalWrite(txPin, LOW); break; case 5: // "Low One" digitalWrite(txPin, HIGH); delayMicroseconds(300); // 290 digitalWrite(txPin, LOW); break; } }</span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">readme.txt</b> <div class="spoiler_text"><pre> <code class="cpp hljs">This is a library to control Livolo branded wireless switches. Features: - emulates buttons <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ALL OFF of Livolo remote controller Usage: Basically you need two things to get it to work: <span class="hljs-number"><span class="hljs-number">1</span></span>) Create Livolo instance <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-function">Use </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendButton</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remoteID, byte keycode)</span></span></span><span class="hljs-function"> function to "push" the buttons sendButton function uses to arguments: remote ID </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> keycode. Typically, remote IDs are 16 bit </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> values, but </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">not</span></span></span><span class="hljs-function"> all of them are </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valid</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(maybe there are some IDs reserved only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> system use </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">or</span></span></span></span><span class="hljs-function"><span class="hljs-params"> there is something I don</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'t know). Tested remote IDs: - read from real remote IDs: 6400; 19303 - "virtual" remote IDs: 10550; 8500; 7400 You can try and find new IDs as well: put your switch into learning mode and start sendButton with remote ID you wish to use. If it is a valid ID, switch will accept it. Keycodes read from real remote: #1: 0, #2: 96, #3: 120, #4: 24, #5: 80, #6: 48, #7: 108, #8: 12, #9: 72; #10: 40, #OFF: 106 Keycodes are 7 bit values (actually I use 8 bit values, just skip most significant (leftmost) bit), but other keycodes could be reserved for system use (dimmer, for example). For an example sketch see blink.ino under examples folder.</span></span></span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">blink.ino</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Simple blink example of Livolo.h library for Livolo wireless light switches #include &lt;livolo.h&gt; Livolo livolo(8); // transmitter connected to pin #8 void setup() { } void loop() { livolo.sendButton(6400, 120); // blink button #3 every 3 seconds using remote with remoteID #6400 delay(3000); }</span></span></code> </pre><br></div></div><br><br>  Or <a href="https://drive.google.com/file/d/0B0DQ7La4EBHlU2ltTmlmeHhya3M/edit%3Fusp%3Dsharing">all in one archive</a> . <br><br><h5>  What I could not </h5><br>  Actually, I managed to solve the main task - an imitation of an arbitrary Livolo console for controlling switches, but I could not ‚Äúread‚Äù the identifier of an existing one.  To do this, anyone who wants to imitate his console (to use it in parallel with the Arduino) would have to record his signal in Audacity (or something similar) and calculate the identifier by code message. <br><br>  Not too nice, but I couldn‚Äôt do anything about it (that time was not enough, then I didn‚Äôt mind), and a little later the necessity disappeared.  <a href="http://forum.arduino.cc/index.php%3FPHPSESSID%3D0tq6dfkft7iun064gkum4mhcn1%26topic%3D153525.msg1560970">The code was written by</a> one of the comrades who got acquainted with my sufferings about Livolo. <br><br>  That's all.  Report on the laboratory work finished. </div><p>Source: <a href="https://habr.com/ru/post/211594/">https://habr.com/ru/post/211594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211580/index.html">What exactly do I hate for some individual marketers - or as an IT pros go shopping</a></li>
<li><a href="../211582/index.html">Results of CES 2014: Samsung AV News</a></li>
<li><a href="../211584/index.html">Dr.Web for licensed content</a></li>
<li><a href="../211588/index.html">Live webcast ALM Summit</a></li>
<li><a href="../211590/index.html">Repeatable, another way to render lists</a></li>
<li><a href="../211606/index.html">Downloading Phonebooks to Polycom IP Phones</a></li>
<li><a href="../211608/index.html">Work with usb video camera in Linux. Part 1</a></li>
<li><a href="../211610/index.html">Neural networks, "bad" tips</a></li>
<li><a href="../211612/index.html">‚ÄúFont-weight: bolder‚Äù for fonts with a variety of styles</a></li>
<li><a href="../211614/index.html">Games under threat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>