<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AMD APP SDK: Intermediate Language (IL)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ATI Stream SDK was renamed to AMD Accelerated Parallel Processing (APP) SDK, OpenCL replaced the main GPGPU computing programming language. However, n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AMD APP SDK: Intermediate Language (IL)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0b1/efd/1f9/0b1efd1f9889a4d5688c3d6910ff3701.png" alt="AMD APP" title="AMD Accelerated Parallel Processing" align="left"><br>  ATI Stream SDK was renamed to AMD Accelerated Parallel Processing (APP) SDK, OpenCL replaced the main GPGPU computing programming language.  However, not many people guess that it is possible to write code for ATI cards with the help of another technology: AMD Compute Abstraction Layer (CAL) / Intermediate Language (IL).  The <abbr title="Compute Abstraction Layer">CAL</abbr> technology is designed to write code that interacts with the GPU and runs on the CPU, while the <abbr title="Intermediate Language">IL</abbr> technology allows you to write code that will run directly on the GPU. <br><br>  This article will consider the technology <abbr title="Intermediate Language">IL</abbr> , its scope, limitations, advantages compared with OpenCL.  Who cares, I ask under the cat. <br><br><a name="habracut"></a><h2>  Introduction </h2><br>  For starters, here are some comparisons with the Nvidia CUDA SDK: <br><ol><li>  High level programming language: <br><ul><li>  Nvidia: CUDA C ++ Extension </li><li>  AMD: OpenCL 1.1 or Compute Abstraction Layer (CAL) </li></ul><br></li><li>  Low level programming language (pseudo assembler *): <br><ul><li>  Nvidia: Parallel Thread Execution (PTX) </li><li>  AMD: Intermediate Language (IL) </li></ul><br></li><li>  The ratio of ‚Äúnumber of parrots per second‚Äù (for example, the number of hashes per second per second) to ‚ÄúGPU price‚Äù: <br><ul><li>  Nvidia: x </li><li>  AMD: ~ 2x using CAL / IL bundle </li></ul><br></li></ol>  * means that the language, although similar to an assembler, is still optimized by the compiler and converted to different code for different GPUs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So how can you get such a performance gain? <br><br><h2>  Features of the AMD GPU architecture </h2><br>  If you carefully read the Nvidia <abbr title="Parallel Thread Execution">PTX</abbr> specification and AMD <abbr title="Intermediate Language">IL</abbr> specification, you will notice that the operands in Nvidia <abbr title="Parallel Thread Execution">PTX</abbr> are one-component vectors (that is, simple n-bit registers), while AMD <abbr title="Intermediate Language">IL</abbr> operands are 4 component vectors of n-bit registers .  This will become clearer if we consider the multiplication operation in both languages: <br><br><pre><code class="hljs css"># <span class="hljs-selector-tag"><span class="hljs-selector-tag">Nvidia</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTX</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.u32</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, %<span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, %<span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">AMD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">umul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzw</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzw</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzw</span></span></code> </pre> <br>  Thus, for one (almost one) operation, an AMD GPU can change up to 4 n-bit registers, and an Nvidia GPU can only change one n-bit register (meaning within one GPU stream).  But OpenCL also allows you to declare multicomponent vectors and work with them!  Then what's the difference and why do we need this <abbr title="Intermediate Language">IL</abbr> ? <br><br><h2>  Difference from OpenCL </h2><br>  And all the differences are banal in that the developers of the AMD APP SDK were either difficult or technically impossible to create a compiler that translates code written according to the OpenCL specification to code written in AMD <abbr title="Intermediate Language">IL</abbr> .  Hence the <a href="http://developer.amd.com/sdks/AMDAPPSDK/pages/DriverCompatibility.aspx">restrictions</a> on the support of the OpenCL standard: <br><ul><li>  OpenCL 1.0 is supported starting around Radeon HD 4000 Series (Beta Level Support) (perhaps there is no support for an image object, i.e. texture memory) </li><li>  OpenCL 1.1 is supported starting around Radeon HD 5000 Series. </li><li>  OpenCL 1.2 is supported starting around Radeon HD 7000, but the SDK that supports this version of the standard has not even been released yet. </li></ul><br>  It is worth noting that AMD <abbr title="Intermediate Language">IL</abbr> allows you to use for GPGPU computing some cards from the Radeon HD 3000 Series and even from the Radeon HD 2000 Series!  (To be completely precise, this is a GPU on R600, RV610, RV630 and RV670 chips) <br>  Further, for brevity, we will designate all GPUs, starting with the Radeon HD 5000 Series, as Evergreen GPUs (this is the Radeon HD 5700 chip), because only these cards support some interesting operations. <br><br>  Before proceeding to explain the principles of writing code for AMD <abbr title="Intermediate Language">IL</abbr> , I would like to draw your attention to <br><br><h2>  Features of working with memory </h2><br>  As I already mentioned, AMD GPU works with 4 component vectors of n-bit registers, where n = 32 (how to work with 64-bit registers, further).  This imposes a basic restriction on memory: memory can only be allocated in multiples of 16 bytes.  It should be remembered that when loading data from memory the minimum amount of transmission is again these 16 bytes.  That is, it does not matter at all that you specify that your memory consists of 4 component vectors of 1 byte (char4), that of the 4 component vectors of 4 bytes (int4), the result will be one - from memory in one exchange operation will load 16 bytes <br><br>  Further, unlike the Nvidia GPU, the AMD GPU allocates local memory in the global area (which means a very slow data transfer rate), so forget about the local memory.  Use registers and global memory. <br><br>  And lastly: again, unlike the Nvidia GPU, there is only one global memory operating in read-write (hereinafter, it will be ‚Äúg []‚Äù), and many different sources of texture memory (hereinafter, it will be ‚Äúi0‚Äù, ‚Äúi1 ", Etc.) and constant memory (hereinafter, it will be" cb0 "," cb1 ", etc.), working only for reading. <br>  A feature of constant memory is the presence of caching when all GPU threads access one data area (it works as fast as registers). <br>  The peculiarity of the texture memory is reading caching (from 8 KB, if memory serves me, per one stream processor) and the ability to access memory by real coordinates.  When going beyond the boundaries of the texture, you can either read the boundary element, or loop and read first (the coordinate is taken modulo the width / length of the texture). <br><br>  Now let's get to the most interesting part: <br><br><h2>  Code structure for AMD IL </h2><br><h3>  Work with registers </h3><br>  First, a small explanation of how the exchange takes place between registers in operations. <br>  The output register in place of the vector component may contain either the name of the component or the "_" sign, which means that the component will not be changed. <br>  Each input register in place of each component can contain <b>any</b> name of the four components, either "0" or "1".  This means that either an input register component or a constant is involved in the operation on the corresponding component of the output register.  Let me explain this with an example: <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># r0.x = r1.z # r0.y = r1.w # r0.w = r1.y mov r0.xy_w, r1.zwyy # r0.y = 1 # r0.z = 0 mov r0._yz_, r1.x100</span></span></code> </pre><br><br><h3>  Shaders </h3><br>  The code for AMD GPU is made in the form of shaders.  It is possible to run both a computer shader (Compute Shader, CS) and a pixel shader (Pixel Shader, PS).  However, CS is supported starting only with the Radeon HD 4000 Series.  The speed of their work is almost the same. <br><br>  It is known that the number of simultaneously launched threads on a GPU is determined by the launch parameters: the number of blocks, the number of threads per block.  Each multiprocessor (from 8 pieces) GPU takes one block for execution.  Then divides the requested number of threads into a block into pieces (warp, a multiple of 32) and gives each of its streamlined processor to execute one warp.  Thus, the real number of simultaneously running threads is: <br><br>  &lt;multiprocessors_count&gt; * &lt;stream_processors_per_multiprocessor_count&gt; * &lt;warp_size&gt; <br><br>  That is why for the fastest work it is required that within one warp'a the streams perform the same operation, without branching.  Then this operation will be executed at once. <br><br>  In order not to consider a spherical horse in a vacuum, we consider a simple task: each thread calculates its local identifier within a block (32 bits), the global identifier (32 bits), reads constants (64 bits) from the command memory and from the data memory, reads element from texture (128 bits).  He writes all this into the output memory, for which each stream will need 256 bits. <br>  <b>Note:</b> each texture line contains data for streams of one block. <br><br><h4>  Pixel shader </h4><br><pre> <code class="hljs 1c">il_ps_2_0 ;   (cb0): ; cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].x -   ; cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].y -   ; cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].zw -  dcl_cb cb0[<span class="hljs-number"><span class="hljs-number">1</span></span>] ;     (i0) ; <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  -  ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ),  (<span class="hljs-keyword"><span class="hljs-keyword"></span></span>     float  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>) ;         <span class="hljs-built_in"><span class="hljs-built_in"></span></span> (   uint) dcl_resource_id(<span class="hljs-number"><span class="hljs-number">0</span></span>)_type(<span class="hljs-number"><span class="hljs-number">2</span></span>d,unnorm)_fmtx(uint)_fmty(uint)_fmtz(uint)_fmtw(uint) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ;   (g[]) ; ,     dcl_literal l0, <span class="hljs-number"><span class="hljs-number">0</span></span>xFFFFFFFF, <span class="hljs-number"><span class="hljs-number">0</span></span>xABCDEF01, <span class="hljs-number"><span class="hljs-number">0</span></span>x3F000000, <span class="hljs-number"><span class="hljs-number">2</span></span> ;         ; r0.x -  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> x <span class="hljs-keyword"><span class="hljs-keyword"></span></span> i0 <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  (float) (     ) ; r0.y -  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> y <span class="hljs-keyword"><span class="hljs-keyword"></span></span> i0 <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  (float) (   ) ftoi r0.xyzw, vWinCoord0.xyxy ;  r0.z -    (uint) umad r0.__z_, r0.wwww, cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].yyyy, r0.zzzz ;       ftoi r1.x___, vWinCoord0.xxxx mov r1._y__, r0.zzzz mov r1.__z_, cb[<span class="hljs-number"><span class="hljs-number">0</span></span>].xxxx mov r1.___w, l0.yyyy ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   g[] umul r0.__z_, r0.zzzz, l0.wwww ;       mov g[r0.z+<span class="hljs-number"><span class="hljs-number">0</span></span>].xyzw, r1.xyzw ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  i0 ;     float   <span class="hljs-number"><span class="hljs-number">0.5</span></span> itof r0.xy__, r0.xyyy add r0.xy__, r0.xyyy, l0.zzzz sample_resource(<span class="hljs-number"><span class="hljs-number">0</span></span>)_sampler(<span class="hljs-number"><span class="hljs-number">0</span></span>)_aoffimmi(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) r1, r0 ; sample_resource(<span class="hljs-number"><span class="hljs-number">0</span></span>) -  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> i0 ; _sampler(<span class="hljs-number"><span class="hljs-number">0</span></span>) -   sampler'a #0 ; _aoffimmi(0,0,0) -   x, y, z ;        ,  _aoffimmi(1,0,0);   - _aoffimmi(0,1,0) ;       mov g[r0.z+1].xyzw, r1.xyzw ;     endmain ;    end</code> </pre><br><br><h4>  Compute shader </h4><br>  All the difference will be only in the calculation of the flow identifiers, the rest is the same. <br><br><pre> <code class="hljs cs">il_cs_2_0 dcl_num_thread_per_group <span class="hljs-number"><span class="hljs-number">64</span></span> ;   (cb0): ; cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].x -   ; cb0[<span class="hljs-number"><span class="hljs-number">0</span></span>].yzw -  dcl_cb cb0[<span class="hljs-number"><span class="hljs-number">1</span></span>] ;     (i0) ;   -  (   ),  (     <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>) ;          (   <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) dcl_resource_id(<span class="hljs-number"><span class="hljs-number">0</span></span>)_type(<span class="hljs-number"><span class="hljs-number">2</span></span>d,unnorm)_fmtx(<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)_fmty(<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)_fmtz(<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)_fmtw(<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) ;   (g[]) ; ,     dcl_literal l0, <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xABCDEF01</span></span>, <span class="hljs-number"><span class="hljs-number">0x3F000000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ;   mov r0._y__, vThreadGrpIDFlat.xxxx ;     mov r0.x___, vTidInGrpFlat.xxxx ;    mov r0.__z_, vAbsTidFlat.xxxx ;       mov r1.x___, vTidInGrpFlat.xxxx mov r1._y__, vAbsTidFlat.xxxx mov r1.__z_, cb[<span class="hljs-number"><span class="hljs-number">0</span></span>].xxxx mov r1.___w, l0.yyyy ;      g[] umul r0.__z_, r0.zzzz, l0.wwww ;       mov g[r0.z+<span class="hljs-number"><span class="hljs-number">0</span></span>].xyzw, r1.xyzw ;     i0 ;     <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>   <span class="hljs-number"><span class="hljs-number">0.5</span></span> itof r0.xy__, r0.xyyy <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r0.xy__, r0.xyyy, l0.<span class="hljs-function"><span class="hljs-function">zzzz </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sample_resource</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)_</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sampler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)_</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aoffimmi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) r1, r0</span></span> ; sample_resource(<span class="hljs-number"><span class="hljs-number">0</span></span>) -   i0 ; _sampler(<span class="hljs-number"><span class="hljs-number">0</span></span>) -   sampler<span class="hljs-string"><span class="hljs-string">'a #0 ; _aoffimmi(0,0,0) -   x, y, z ;        ,  _aoffimmi(1,0,0);   - _aoffimmi(0,1,0) ;       mov g[r0.z+1].xyzw, r1.xyzw ;     endmain ;    end</span></span></code> </pre><br><br><h3>  Shader Differences </h3><br>  In addition to support on different cards, the main difference of shaders is in the storage location of the number of threads launched per block.  For PS, this value can be stored in memory, for CS, this value needs to be punched in the code.  In addition, it is easier for CS to calculate thread identifiers. <br><br><h2>  Conclusion </h2><br>  I tried to tell in this article how to write a simple code on AMD <abbr title="Intermediate Language">IL</abbr> for execution on the GPU itself.  As a conclusion a few words about optimizing the speed of work: <br><ul><li>  Do not try to use optimization techniques specific to the assembler (prediction of operations with constants, permutation of independent operations).  Do not forget that this is still a pseudo assembler, so the compiler will optimize for you.  Better think about the algorithm. </li><li>  Load as much data as possible on the card.  It is advisable to use all 32 bits of all 4 components of the vector. </li><li>  If you have the same type of calculations on the input data (for example, hash calculation), then you should experiment on the number of components in operations: sometimes r0.x ___ will work, sometimes r0.xy ___, and sometimes r0.xyzw will work faster. </li><li>  Although AMD claims that the number of threads in the block can be any multiple of &lt;warp_size&gt; and at the same time the GPU will behave correctly, in fact it is not.  In nature, I saw only &lt;warp_size&gt; = 32 or 64, and my GPU worked correctly only with the number of threads in the block equal to &lt;warp_size&gt;.  Moreover, the Radeon HD 4650 at the start with 32 threads in the block (and for technical data, for this card &lt;warp_size&gt; = 32) on one of my algorithms produced incorrect data, but with 64 threads in the block it worked with a bang.  Conclusion: run the algorithm with only 64 threads in the block (and the number of blocks can already be varied). </li><li>  GPU Evergreen support several cool features: cyclic shift, support for overflow flags, support for 64-bit operations (2 components are reserved for this).  Unfortunately, the GPU of a family younger than Evergreen does not support all these buns.  If someone tells you how to write 64-bit operations on them, I will be grateful. </li></ul><br>  How to transfer data to the card and take data from it is written in the <a href="http://habrahabr.ru/blogs/hi/139049/" title="AMD Compute Abstraction Layer (CAL)">second part</a> about the AMD Compute Abstraction Layer (CAL). <br><br><h2>  Links for information </h2><br><ul><li>  <a href="http://developer.amd.com/sdks/AMDAPPSDK/documentation/Pages/default.aspx" title="AMD Accelerated Parallel Processing SDK">AMD Accelerated Parallel Processing SDK</a> </li><li>  <a href="http://developer.amd.com/sdks/AMDAPPSDK/assets/AMD_Intermediate_Language_(IL)_Specification_v2.pdf" title="AMD Intermediate Language (IL)">AMD Intermediate Language (IL)</a> </li><li>  <a href="http://developer.amd.com/sdks/amdappsdk/assets/AMD_CAL_Programming_Guide_v2.0.pdf" title="AMD Compute Abstraction Layer (CAL)">AMD Compute Abstraction Layer (CAL)</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/138954/">https://habr.com/ru/post/138954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138947/index.html">Implementing a hierarchy ‚Äî combining the Adjacency List and Materialized Path through one-to-many</a></li>
<li><a href="../138948/index.html">WikiLeaks begins publishing letters "shadow CIA"</a></li>
<li><a href="../138949/index.html">Multi-table models in Ruby on Rails</a></li>
<li><a href="../138952/index.html">Google creates a panoramic service "Google SeaView"</a></li>
<li><a href="../138953/index.html">The miracle did not happen: Neutrinos do not overcome the speed of light</a></li>
<li><a href="../138955/index.html">Youtube recognized bird songs as "copyright material"</a></li>
<li><a href="../138957/index.html">What you need to remember about the decimal separator</a></li>
<li><a href="../138958/index.html">Trojan.Tenagour.9 helps attackers in DDoS attacks</a></li>
<li><a href="../138959/index.html">If we want replicable science, the program code must be open.</a></li>
<li><a href="../138960/index.html">Unusual WebKit bug with CSS selector</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>