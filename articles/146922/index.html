<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UDP and response delivery problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Below is a translation of an article about the problem of working with udp in network applications. The translator allowed himself to change the examp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UDP and response delivery problem</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/377/06f/a74/37706fa741d53cdc2b969eff9ebfd515.png" alt="image"><br>  Below is a translation of an article about the problem of working with udp in network applications.  The translator allowed himself to change the examples: in the source text, other network addresses and ruby ‚Äã‚Äãcode.  The translation used a simple script on the pearl.  The essence of the problem and the solution does not change. <br>  In addition, my comments have been added in some places (in brackets, in italics). <br>  The picture for attracting attention is taken from the text of the wonderful book ‚Äú <a href="http://learnyousomeerlang.com/">learnyousomeerlang.com</a> ‚Äù <br><br><h4>  Heavy work light protocols </h4><br><a name="habracut"></a><br>  Sometimes it begins to seem that protocols without setting up the connection do not justify all the commotion that is caused. <br><br>  For example, let us analyze the situation with the response when a UDP datagram with the initial request is sent to an additional IP address on the interface (alias or secondary IP). <br>  There is an eth1 interface: <br><pre><code class="bash hljs">$ ip a add 192.168.1.235/24 dev eth1 &amp;&amp; ip a ls dev eth1 2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:30:84:9e:95:60 brd ff:ff:ff:ff:ff:ff inet 192.168.1.47/24 brd 192.168.1.255 scope global eth1 inet 192.168.1.235/24 scope global secondary eth1 inet6 fe80::230:84ff:fe9e:9560/64 scope link valid_lft forever preferred_lft forever</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How does the code usually look for getting a package by udp?  Well, the echo server may look like something very similar to what is under the cut: <br><div class="spoiler">  <b class="spoiler_title">echo_server.pl</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use IO::Socket::INET; # flush after every write $| = 1; my ($socket,$received_data); my ($peeraddress,$peerport); $socket = new IO::Socket::INET ( MultiHomed =&gt; '1', LocalAddr =&gt; $ARGV[0], LocalPort =&gt; defined ($ARGV[1])?$ARGV[1]:'5000', Proto =&gt; 'udp' ) or die "ERROR in Socket Creation : $! \n"; print "Waiting for data..."; while(1) { $socket-&gt;recv($recieved_data,1024); $peer_address = $socket-&gt;peerhost(); $peer_port = $socket-&gt;peerport(); chomp($recieved_data); print "\n($peer_address , $peer_port) said : $recieved_data"; #send the data to the client at which the read/write operations done recently. $data = "echo: $recieved_data\n"; $socket-&gt;send("$data"); } $socket-&gt;close();</span></span></code> </pre><br></div></div><br><br>  This is a fairly simple script on pearl, which will show from whom the udp package came from, the contents of the package and send this package back to the sender.  There is simply no place.  Now let's start our server: <br><pre> <code class="bash hljs">$ ./echo_server.pl Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data...</code> </pre><br>  Let's see what he listens to: <br><pre> <code class="bash hljs">$ netstat -unpl | grep perl udp 0 0 0.0.0.0:5000 0.0.0.0:* 9509/perl</code> </pre><br>  And after that, we connect from a remote machine to our server by the main IP: <br><pre> <code class="bash hljs">-bash-3.2$ nc -u 192.168.1.47 5000 test1 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: test1 test2 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: test2</code> </pre><br>  How it looks in tcpdump on our machine (well, or should look like): <br><pre> <code class="bash hljs">-bash-3.2$ tcpdump -i eth1 -nn port 5000 tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> full protocol decode listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes 17:41:00.517186 IP 192.168.3.11.44199 &gt; 192.168.1.47.5000: UDP, length 6 17:41:00.517351 IP 192.168.1.47.5000 &gt; 192.168.3.11.44199: UDP, length 12 17:41:02.307634 IP 192.168.3.11.44199 &gt; 192.168.1.47.5000: UDP, length 6 17:41:02.307773 IP 192.168.1.47.5000 &gt; 192.168.3.11.44199: UDP, length 12</code> </pre><br>  Just fantastic - I send the package and get the package back.  In netcat, we get back what we would not print (funny effect if typing "arrows"). <br><br>  And now the same to the secondary address on the same interface: <br><pre> <code class="bash hljs">-bash-3.2$ nc -u 192.168.1.235 5000 test1 test2</code> </pre><br>  How crazy it looks in tcpdump this time: <br><pre> <code class="bash hljs">-bash-3.2$ tcpdump -i eth1 -nn port 5000 tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> full protocol decode listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes 17:48:32.467167 IP 192.168.3.11.34509 &gt; 192.168.1.235.5000: UDP, length 6 17:48:32.467292 IP 192.168.1.47.5000 &gt; 192.168.3.11.34509: UDP, length 12 17:48:33.667182 IP 192.168.3.11.34509 &gt; 192.168.1.235.5000: UDP, length 6 17:48:33.667332 IP 192.168.1.47.5000 &gt; 192.168.3.11.34509: UDP, length 12</code> </pre><br><br>  And of course, no self-respecting network stack is going to accept packets from a completely unfamiliar address, even if the ports are correct.  Thus, the client will never receive reverse packets and will think that the server simply discards its requests. <br><br>  What is happening at first glance seems complete nonsense.  But in fact, this is a common flaw for a protocol without setting up a session, such as UDP.  You see, our socket listens to any address (the empty LocalAddr parameter when creating a socket is passed to the system as an address like "0.0.0.0", any available, which causes the socket to listen on all available addresses. And no, I also don‚Äôt know why This is not a particularly intuitive action).  When we receive a packet in our application using socket-&gt; recv (), we do not receive information about the specific address to which the packet was sent.  We only know that the operating system decided that the package was for us (here you have encapsulation).  All we know is where the package came from.  And due to the fact that the kernel does not store any information about connections for the socket (the kernel is logical, asked without connections ‚Äî it will be without connections), when it comes time to send the package back, all we can do is tell ‚Äúwhere‚Äù to send the package.  (In Perl, this is done implicitly. The address and port of the sender of the datagram are associated with the object $ socket, so you do not need to specify it in the send call). <br>  But the real brainwash begins when we try to put the sender's address in the response datagram.  Once again: the kernel does not store any information about the sender or recipient, since we work without connections.  And since we listen to "any" interface, the operating system thinks that it has a blank check to send a packet from the address that it "likes."  In Linux, it seems, the main address of the interface from which the packet will be sent is selected.  <i>(Actually, the address is determined in accordance with <a href="http://tools.ietf.org/html/rfc1122">RFC1122, 3.3.4.2 ‚ÄúMultihoming Requirements‚Äù</a> , according to the routing table - the note of the translator)</i> .  So for the common case ‚Äúone address - one interface‚Äù - everything works.  But as soon as it comes to less common situations, nuances begin to appear. <br>  The solution is to create sockets that listen to specific addresses.  And send a packet from these sockets: the kernel will know from which address you want to send packets and everything will be fine.  Looks simple enough, huh?  And of course, any sane network application already does that, huh?  So it is obvious that the implementation of UDP in Ruby is just crap <i>(in the original Ruby sources, - the note of the translator;)</i> .  That is how I thought at the beginning, and I do not blame you if you thought the same.  But while the RUBICON of the war with Ruby's UDPSocket authors has not been transferred, let's do a little experiment with other frequently used applications.  For example, SNMPd.  The daemon from the net-snmpd package in ubunt is subject to the same problem as our test application above.  It does not seem that this is some kind of new rake, which has only been stepped on and scattered with a bunch of patches to correct. <br>  So in general, everyone suffers the same "disease."  By ‚Äúall‚Äù is meant ‚Äúsome UDP servers.‚Äù  There is a certain amount of software that is not subject to a similar problem with aliases on interfaces.  Bind comes to mind immediately and NTPd works fine, if running after you have configured all interfaces.  What is the difference?  The difference is that these services are somewhat ‚Äúsmarter‚Äù and bind to all addresses in the system separately.  On the example of bind: <br><pre> <code class="bash hljs">$ netstat -lun |grep :53 udp 0 0 192.168.1.47:53 0.0.0.0:* udp 0 0 192.168.1.47:53 0.0.0.0:* udp 0 0 127.0.0.1:53 0.0.0.0:*</code> </pre><br>  This is very cool and solves the problem.  The exception is when you add an extra alias after the demon has started.  Bind will not pick up a new address and you will have to restart the server.  In addition, it complicates the code somewhat, since you have to deal with a bunch of sockets inside the program (for example, use select () instead of simply blocking on the reception attempt.) In general, no one likes the extra complexity, but you can cope with this .  However, the real problem is the rule ‚Äúdo not add addresses after the start of the daemon‚Äù.  The need to check whether the system has ip-addresses added, and restarting the service after adding the address will become a real problem. <br>  However, there is some workaround for this problem.  Here we recall the ntpd.  The ports that he listens are as follows: <br><pre> <code class="bash hljs">$ netstat -nlup | grep 123 udp 0 0 192.168.1.235:123 0.0.0.0:* udp 0 0 192.168.1.47:123 0.0.0.0:* udp 0 0 127.0.0.3:123 0.0.0.0:* udp 0 0 127.0.0.1:123 0.0.0.0:* udp 0 0 0.0.0.0:123 0.0.0.0:* udp6 0 0 fe80::230:84ff:fe9e:123 :::* udp6 0 0 ::1:123</code> </pre><br><br>  NTPd listens to each address individually and additionally listens to any address available to the system.  I do not know exactly why this is necessary.  If you just listen to each address separately, then everything will be fine, as is the case with the bind.  But if you add another address to the interface after the start of ntpd, then the same problem begins to appear as in the case with the udp-echo server.  So I do not think that listening to "any" interface gives any plus.  However, this causes ntpd to behave somewhat differently from Bind: when you send a packet to an interface added after Bind starts, it simply ignores you (it does not have a socket that would listen to your requests).  Ntpd tries to send a response and suffers from the problem of the wrong address in the answers.  <i>(But you can change the primary addresses on the interfaces and create new interfaces, a translator's note).</i> <br><br>  At the moment, the best solution seems to follow the path of Bind and ntpd and listen to all addresses individually with the ‚Äúfocus‚Äù from ntpd: listen additionally and at 0.0.0.0.  At the same time, if I received the package at 0.0.0.0, then I need to run scans of the addresses available in the system and bind more on them.  This should solve the problem. <br>  It remains only to make it work (and solve a bunch of problems that will surely come out on the way).  Wish me good luck.  The cries of pain and torment that you hear (it doesn't matter where you are) are certainly mine. <br><br>  <b>UPD: an</b> interesting explanation from <a href="https://habrahabr.ru/users/quasar_ru/" class="user_link">Quasar_ru</a> appeared in the <a href="http://habrahabr.ru/post/146922/">comments</a> .  All the same, the implementation of UDP in scripting languages ‚Äã‚Äãis ambiguous: on pure C you can write a client application that can receive a response from the server from another address.  The benefits of such an implementation are controversial, but implementation is still possible. </div><p>Source: <a href="https://habr.com/ru/post/146922/">https://habr.com/ru/post/146922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146916/index.html">Google I / O - ADK 2012 Presentation</a></li>
<li><a href="../146917/index.html">From engineer to manager. Part 1: Sense of Justice</a></li>
<li><a href="../146918/index.html">Apple will have to buy rights to the iPad brand in China for $ 60 million</a></li>
<li><a href="../146919/index.html">GNU / Linux and Microsoft Windows Integration</a></li>
<li><a href="../146921/index.html">Intellectual video gadget OViVO will appear on the market in July</a></li>
<li><a href="../146924/index.html">Car Navigator Lexand ST 5650 Pro HD</a></li>
<li><a href="../146925/index.html">The blogger is trying to sue Yandex 10 million for poor indexing</a></li>
<li><a href="../146927/index.html">Algorithm for an IT interview</a></li>
<li><a href="../146928/index.html">How to create a business intelligence system and do not break the wood</a></li>
<li><a href="../146929/index.html">App-blog Tanya Misyutinoy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>