<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Debugging algorithms on graphs - now with pictures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's imagine a typical situation in the first year: you read about the Dinits algorithm , implemented it, but it didn‚Äôt work, and you don‚Äôt know why....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Debugging algorithms on graphs - now with pictures</h1><div class="post__text post__text-html js-mediator-article">  Let's imagine a typical situation in the first year: you read <a href="https://e-maxx.ru/algo/dinic">about the Dinits algorithm</a> , implemented it, but it didn‚Äôt work, and you don‚Äôt know why.  The standard solution is to start debugging in steps, each time drawing the current state of the graph on a piece of paper, but this is terribly inconvenient.  I tried to correct the situation as part of a semester project on Software Engineering, and in a post I will tell you how I ended up with a plug-in for Visual Studio.  You can download it <a href="https://marketplace.visualstudio.com/items%3FitemName%3DOlgaLupuleac.graphrenderer2019">here</a> , the source code and documentation can be found <a href="https://github.com/olgalupuleac/GraphAlgorithmRenderer">here</a> .  Here is a screenshot of the graph obtained for the Dinitsa algorithm. <br><br><img src="https://habrastorage.org/webt/mq/m_/bg/mqm_bgawuvqn8v0wwqb9-jgm4cm.png"><a name="habracut"></a><br><br><h2>  About myself </h2><br>  My name is Olga, I graduated from the third year of the direction "Applied Mathematics and Computer Science" at the St. Petersburg HSE with a degree in Software Engineering.  Before entering the university, I was not involved in programming. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Research: requirements </h2><br>  At our faculty practice semester research work.  Usually this happens like this: at the beginning of the semester, a presentation of research works takes place - representatives of different companies offer all kinds of projects.  Then students choose their favorite projects, supervisors choose their favorite students, and so on.  In the end, each student finds a project for himself. <br><br>  But there is another way: you can independently find a supervisor and a project, and then convince the curator that this project can really be a full-fledged R&amp;D.  To do this, prove that: <br><br><ol><li>  You are going to do something new.  Of course, the project may have analogues, but your option should have some advantages over them. <br></li><li>  The task should be quite difficult, that is, the work there should be for a semester, and not for a day.  At the same time, it is necessary that the project really be done in a semester. <br></li><li>  Your project should be useful to the world.  That is, when asked why this is necessary, you should not answer: "Well, I need to do some kind of research." <br></li></ol><br>  I chose the second way.  The first thing to do after I agreed with the supervisor was to find the topic of the project.  The list of ideas included: code style checker for Lua, a debugger that allows you to calculate expressions in parts, and a tool for olympiads / programming training, which allows you to visualize what is happening in the code.  That is, a visualizer for arbitrary data structures combined with a debugger.  For example, a person writes a <a href="https://e-maxx.ru/algo/treap">Cartesian tree</a> , and in the process peaks, edges, the current peak and so on are drawn.  In the end, I decided to stay on this option. <br><br><h2>  Project work plan </h2><br>  My work on the project consisted of the following stages: <br><br><ol><li>  <b>The study of the subject area was</b> required to understand whether this problem had already been solved (then the project topic would have to be changed), what are their analogues, what are their advantages and disadvantages, which I could take into account in my work. <br></li><li>  <b>Defining the specific functionality</b> that the created tool will have.  The theme of the project was stated quite abstractly, and this was necessary in order to make sure that the task is quite complicated, but at the same time it is realistic to complete it in a semester. <br></li><li>  <b>Creating a prototype user interface was</b> required to demonstrate how the created tool can be used.  It added even more specificity than a set of features described by words. <br></li><li>  <b>Choice of dependencies</b> - you need to understand how everything will be arranged from the point of view of the developer and decide on the tools that will be used in the process of writing code. <br></li><li>  <b>Creating a prototype (proof-of-concept)</b> , that is, a minimal example in which most would be hardcoded.  With this example, I had to figure out all the tools that I was going to use, and also learn how to solve all the difficulties that arose along the way, so that the final version would already be written ‚Äúclean‚Äù. <br></li><li>  <b>Work on the content part</b> , that is, the development and implementation of the logic of the tool. <br></li><li>  <b>Project protection is</b> required in order to quickly talk about the work done and to give an opportunity to evaluate it to everyone, even people who do not rummage in the subject.  It is a training before graduation.  At the same time, a well-made project does not guarantee that the report will turn out to be good, since it requires other skills, for example, the ability to speak to the public. <br></li></ol><br>  I have always carried out planning with my supervisor.  We also always came up with and discussed all ideas that arose along the way.  In addition, the supervisor advised me on the code and helped with time management.  About all technical problems (incomprehensible bugs, etc.) I also always reported, but most often I managed to solve them myself. <br><br><h2>  Subject research </h2><br>  To begin with, our leadership should have been convinced that this topic deserves to be my research work.  And you should start from the first point: the search for analogues. <br><br>  As it turned out, there are many analogues.  But most of them were designed for visualization of memory.  That is, they would have done a great job with the visualization of the Cartesian tree, but they cannot understand that a <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2583%25D1%2587%25D0%25B0">bunch on an array</a> should not be drawn as an array, but as a tree.  Among these analogues were <a href="https://www.gdbgui.com/">gdbgui</a> , <a href="https://www.gnu.org/software/ddd/">Data Display Debugger</a> , a plug-in for Eclipse <a href="https://www.jgrasp.org/eclipse_plugin.html">jGRASP,</a> and a plug-in for Visual Studio <a href="https://marketplace.visualstudio.com/items%3FitemName%3DEvgeniyAkimov.DataStructuresVisualizer">Data Structures Visualizer</a> .  The latter was also created for the problems of olympiad programming, but was able to visualize only data structures on pointers. <br><br>  There were several more tools: <a href="https://github.com/ChrisKnott/Algojammer">Algojammer</a> for python (and we wanted pluses, as the most popular language among olympiadniki) and the <a href="https://www.cc.gatech.edu/gvu/ii/softvis/visdebug/visdebug.html">Lens</a> tool developed in 1994.  The latter, judging by the description, did almost what it needed, but, unfortunately, it was created under Sun OS 4.1.3 (an operating system from 1992).  So, despite the availability of source codes, it was decided not to waste time on this dubious archeology. <br><br>  So, after some research it was found that Tula, which would do exactly what we wanted, and at the same time work on modern machines, is not in nature yet. <br><br><h2>  Functionality Definition </h2><br>  The second step was to prove that this task is quite complicated, but doable.  To do this, it was necessary to propose something more specific than ‚ÄúI want a beautiful picture, and that everything becomes clear from it immediately‚Äù. <br><br>  In this project, we decided to concentrate on visualizing only graphs: there are many algorithms on graphs that can be implemented in different ways, and even when narrowed, the task still remains non-trivial. <br><br>  It is also more or less obvious that the tool must somehow be integrated with the debugger.  We need to be able to view the values ‚Äã‚Äãof variables and expressions, and draw a finished picture from these values. <br><br>  After that, it was necessary to come up with a certain language that allows us to build a graph according to the current state of the program the way we want.  In addition to the graph itself, it was necessary to provide for the ability to change the color of the vertices and edges, add arbitrary labels to them and change other properties.  Accordingly, the first idea was: <br><br><ol><li>  Determine what we have vertices, for example, numbers from 0 to n. <br></li><li>  Determine the presence of an edge between the vertices using the Boolean condition.  In this case, the edges are of different types, and each type has its own set of properties. <br></li><li>  Further, we can define vertex properties such as color, also using the Boolean condition. <br></li><li>  Walk through the steps with the debugger: all expressions are calculated, all conditions are checked, and, depending on this, a graph is drawn. <br></li></ol><br><h2>  User Interface Prototyping </h2><br>  The user interface prototype I drew in <a href="https://ninjamock.com/">NinjaMock</a> .  This was required to better understand how the interface will look from the point of view of the user, and what actions he will need to perform.  If there were problems with the prototype, we would understand that there are some logical inconsistencies, and this idea should be discarded.  For fidelity, I took a few algorithms.  The picture below shows examples of how I imagined the <a href="https://e-maxx.ru/algo/dfs">DFS</a> visualization settings and <a href="https://e-maxx.ru/algo/floyd_warshall_algorithm">the Floyd algorithm</a> . <br><br><img src="https://habrastorage.org/webt/_c/kw/q9/_ckwq9qv_z5-4_wayyxxb0m8sro.png"><br><br>  <i>As I imagined settings for DFS.</i>  <i>The graph is stored as an adjacency list, so the edge between the vertices i and j is determined by the condition <code>g[i].find() != g[i].end()</code> (in fact, in order not to duplicate the edges, we need to check that <code>i &lt;= j</code> ).</i>  <i>The DFS path is shown separately: <code>p[j] == i</code> .</i>  <i>These edges will be oriented.</i> <i><br><br><img src="https://habrastorage.org/webt/1n/rv/28/1nrv283bilq1cslyq9urbrymgzm.png"><br><br></i>  <i>I assumed that for Floyd's algorithm, it would be necessary to draw black the real edges stored in array <code>c</code> , and gray - the shortest paths found at this stage, stored in array <code>d</code> .</i>  <i>For each edge and shortest path, its weight is written.</i> <br><br><h2>  Dependency Selection </h2><br>  For the next step, it was necessary to understand exactly how to do all this.  First of all, integration with a debugger was required.  The first thing that comes to mind when the word "debugger" is gdb, but then you would have to create the entire graphical interface from scratch, which is really difficult for a student to do in a semester.  The second obvious idea is to make a plugin for some existing development environment.  As options I considered QTCreator, CLion and Visual Studio. <br><br>  The CLion option was dropped almost immediately, because, firstly, it has closed source code, and secondly, everything is very bad with the documentation (and no one needs additional difficulties).  QTCreator, unlike Visual Studio, is cross-platform and open source, and therefore, at first we decided to dwell on it. <br><br>  It turned out, however, that QTCreator is poorly adapted for extension using plugins.  The first step in creating a plugin for QTCreator is to build from source.  It took me a week and a half.  In the end, I sent two bug reports ( <a href="https://bugreports.qt.io/browse/QTCREATORBUG-22101">here</a> and <a href="https://bugreports.qt.io/browse/QTCREATORBUG-22103">there</a> ) regarding the assembly process.  Yes, that‚Äôs how much effort was put into building QTCreator just to discover that the debugger in QTCreator does not have a public API.  I returned to another option, namely Visual Studio. <br><br>  And this turned out to be the right decision: Visual Studio has not only a great API, but also excellent documentation for it.  Expression <code>_debugger.GetExpression(...).Value</code> simplified by calling <code>_debugger.GetExpression(...).Value</code> .  Visual Studio also provides the ability to iterate over the frames, and evaluate the expression in the context of any of them.  To do this, change the property <code>CurrentStackFrame</code> to the required one.  You can also track updates to the debugger contest to redraw the image when changing. <br><br>  Of course, it was not supposed that I would be engaged in visualization of graphs from scratch - there are a lot of special libraries for this.  The most famous of them is <a href="https://www.graphviz.org/">Graphviz</a> , and we planned to use it at first.  But for a plug-in for Visual Studio, it would be more logical to use the library for C #, since I was going to write on it.  I googled a little and found the <a href="https://github.com/Microsoft/automatic-graph-layout">MSAGL</a> library: it had all the required functionality and had a simple and intuitive interface. <br><br><h2>  Proof-of-concept </h2><br>  Now, having a mechanism for calculating arbitrary expressions on the one hand and a library for visualizing graphs on the other, it was necessary to make a prototype.  The first prototype was made for DFS, then the Dinits <a href="https://e-maxx.ru/algo/kuhn_matching">algorithm</a> , <a href="https://e-maxx.ru/algo/kuhn_matching">the Kuhn algorithm</a> , the <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%259F%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582_%25D1%2580%25D0%25B5%25D0%25B1%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B4%25D0%25B2%25D1%2583%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">search for doubly connected components</a> , the Cartesian tree, and the <a href="https://e-maxx.ru/algo/dsu">SNM</a> were taken as examples.  I took my old implementations of these algorithms from the first to second year, created a new plug-in, drew a graph corresponding to this task (all variable names were hardcoded).  Here is an example of a graph that I got for the Kuhn algorithm: <br><br><img src="https://habrastorage.org/webt/dr/bz/c1/drbzc1kb3yf0d2vkesimolwhhda.png"><br>  <i>On this graph, the current matching edges are shown in purple, the current dfs vertex is shown in red, the visited vertices are gray, the edges of an alternating chain not from the matching are shown in red.</i> <br><br>  I considered it permissible to slightly modify the algorithm code to make it easier to visualize.  For example, in the case of the Cartesian tree, it turned out that it is easier to add all the created nodes into a vector than to bypass the tree inside the plugin. <br><br>  An unpleasant discovery was that the debugger in Visual Studio does not support calling methods and functions from the STL.  This meant that it was not possible to check for the presence of an element in the container using <code>std::find</code> , as originally assumed.  This problem can be solved either by creating a user-defined function, or by duplicating the property "the element is contained in the container" in a Boolean array. <br><br>  In my trial plugins, something like this happened (if the graph was stored as an adjacency list): <br><br><ol><li>  First comes the <code>for</code> loop from <code>0</code> to <code>_debugger.GetExpression("n").Value</code> , which added all the vertices to the graph, each with its own number. <br></li><li>  Then there are two nested <code>for</code> <code>_debugger.GetExpression($"g[{i}].size()").Value</code> , the first for <code>i</code> - from <code>0</code> to <code>n</code> , the second for <code>j</code> - from <code>0</code> to <code>_debugger.GetExpression($"g[{i}].size()").Value</code> , and the edge <code>{i, _debugger.GetExpression($"g[{i}][{j}]").Value}</code> . <br></li><li>  If required, some additional information was added to the labels of the vertices and edges.  For example, the value of the array <code>d</code> , which is responsible for the distance to the selected vertex. <br></li><li>  If the algorithm was based on dfs, then after that a cycle went through all the glass frames, and all the vertices on the stack ( <code>stackFrame.FunctionName.Equals("dfs") &amp;&amp; stackFrame.Arguments.Item(1) == v</code> ) were highlighted in gray. <br></li><li>  Then, for each <code>i</code> from <code>0</code> to <code>n</code> , denoting the numbers of the vertices, some conditions were checked, and if they were satisfied, then some properties changed at the vertex, most often the color. <br></li></ol><br>  At that time, I wrote the code ‚Äúas necessary‚Äù, without trying to come up with a general scheme for all the algorithms, or write the code at least somehow beautifully.  The creation of each new plugin began with the copy-paste of the previous one. <br><br><h2>  Graph configuration </h2><br>  After the research, it was necessary to draw up a general scheme that could be applied to all algorithms.  The first thing that was introduced was the indexes for the vertices and edges.  Each index has a unique name and range ends, calculated using <code>_debugger.GetExpression</code> .  To access an index value, use its name surrounded by __ (i.e. __x__).  Expressions with places to substitute index values, as well as the name of the current function (__CURRENT_FUNCTION__) and the values ‚Äã‚Äãof its arguments (__ARG1__, __ARG2__, ...), are called templates. <br><br>  For each vertex or edge, index values ‚Äã‚Äãare substituted, and after that it is calculated in the debugger.  Templates were used to filter out some index values ‚Äã‚Äã(if the graph is stored as the adjacency matrix <code>c</code> , then the indices will be a and b from 0 to n, and the template for validation is <code>c[__a__][__b__]</code> ).  The boundaries of the index range are also templates, as they may contain previous indexes. <br><br>  A graph can have different types of vertices and edges.  For example, in the case of searching for the maximum matching in a bipartite graph, each share can be indexed separately.  Therefore, the concept of a family was introduced for vertices and edges.  For each family, indexing and all properties are determined independently.  In this case, edges can connect vertices from different families. <br><br>  You can assign specific properties to a vertex or edge family that will be selectively applied to elements in the family.  The property is applied if the condition is met.  The condition consists of a template that evaluates to <code>true</code> or <code>false</code> , and a regular expression for the function name.  The condition is checked either only for the current glass frame, or for all glass frames (and then it is considered fulfilled if it is satisfied for at least one). <br><br>  Properties are very diverse.  For vertices: label, fill color, border color, border width, shape, border style (for example, dotted line).  For edges: label, color, width, style, orientation (you can set two arrows - from beginning to end or vice versa; in this case, there can be two arrows at the same time). <br><br>  It is important that each time the graph is drawn from scratch, and the previous state is not taken into account in any way.  This can be a problem if the graph dynamically changes during the algorithm - the vertices and edges can dramatically change their position, and then it is difficult to understand what is happening. <br><br>  A detailed description of the graph configuration can be found <a href="https://github.com/olgalupuleac/GraphAlgorithmRenderer">here</a> . <br><br><h2>  User interface </h2><br>  With the interface, I decided not to bother much.  The main window with the settings ( <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.modeling.shell.toolwindow">ToolWindow</a> ) contains textarea for the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.modeling.shell.toolwindow">config</a> serialized in JSON and a list of vertex and edge families.  Each family has its own window with settings, and each property in the family has one more window (three levels of nesting are obtained).  The graph itself is drawn in a separate window.  It did not work to put it in ToolWindow, so I sent a <a href="https://github.com/microsoft/automatic-graph-layout/issues/204">bug report</a> to the MSAGL developers, but they answered that this is not the target use case.  <a href="https://developercommunity.visualstudio.com/content/problem/627810/implementing-a-vs-extension-text-is-sometimes-type.html">Another bug report</a> was sent to Visual Studio, as TextBoxes sometimes hung in additional configuration windows. <br><br><img src="https://habrastorage.org/webt/n2/jo/-b/n2jo-buqxeq40a03zs0wochfrl0.png"><br><br><h2>  Plugin </h2><br>  In order to configure the graph, the plugin has a user interface and the ability to (de) serialize the config in JSON.  The general scheme of interaction of all components is as follows: <br><br><img src="https://habrastorage.org/webt/yv/kz/rx/yvkzrx4fglqdelkutvbdqzgqlj0.png"><br><br>  Blue shows the components that existed originally, gray - which I created.  When Visual Studio starts, the extension is initialized (here the main component is designated as Main).  The user gets the opportunity to specify the configuration through the interface.  Each time the debugger context is changed, the main component is notified.  If the configuration is defined and the program being debugged is executed, GraphRenderer is launched.  He receives a config input and with the help of a debugger builds a graph on it, which is then displayed in a special window. <br><br><h2>  Examples </h2><br>  As a result, I created a tool that allows you to visualize graph algorithms and requires small changes in the code.  It has been tested on eight different tasks.  Here are some resulting pictures: <br><br><img src="https://habrastorage.org/webt/a1/lw/z6/a1lwz6jlyloms0dfmzddoxx9gxk.png"><br>  <i><a href="https://e-maxx.ru/algo/ford_bellman">Ford-Bellman algorithm</a> : the vertex to which we count the shortest paths is indicated by a house, the current shortest distance found for the vertices is d, red indicates the edge along which relaxation passes.</i> <br><br><img src="https://habrastorage.org/webt/5k/5h/rk/5k5hrko_liqr2kgbctgdeznbc44.gif"><br>  <i>Animation with DFS - the current vertex is shown in red, the vertices in the stack are gray, and the other visited vertices are green.</i>  <i>Raspberry ribs indicate the direction of the bypass.</i> <br><br>  More sample algorithms are available <a href="https://github.com/olgalupuleac/GraphAlgorithmRenderer/tree/master/GraphAlgorithmRenderer/Samples">here.</a> <br><br><h2>  NIR protection </h2><br>  To protect research work, students are required to talk about their work in a semester in seven minutes.  In this case, regardless of whether the topic was proposed as part of the presentation of research work or the student found it on their own, you need to be able to answer to justify why the topic of the project falls under the requirements described at the beginning.  Typically, a report is structured as follows: first there is motivation, then a review of analogues, it is said about why they do not suit us, then goals and objectives are formulated, and then each of the tasks is described how it was solved.  At the end there is a slide with the results, which once again says that the goal has been achieved and all tasks are solved. <br><br>  Since I decided on the motivation and review of analogues at the initial stage, I just needed to collect all the information together and compress it to seven minutes.  As a result, I succeeded, the defense went smoothly, and I was given the maximum score for research. <br><br><h2>  References </h2><br><ul><li>  <a href="https://github.com/olgalupuleac/GraphAlgorithmRenderer">GitHub repository</a> </li><li>  <a href="https://marketplace.visualstudio.com/items%3FitemName%3DOlgaLupuleac.graphrenderer2019">Visual studio marketplace</a> </li><li>  <a href="https://codeforces.com/blog/entry/67116">Post on Codeforces</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/461473/">https://habr.com/ru/post/461473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461463/index.html">Business processes in enterprise companies: speculation and reality. Shed light with R</a></li>
<li><a href="../461465/index.html">Measurement Guide</a></li>
<li><a href="../461467/index.html">An example of creating a Makefile for Go applications</a></li>
<li><a href="../461469/index.html">What is it like listening to code at 1000 words per minute</a></li>
<li><a href="../46147/index.html">Selected: Grouping</a></li>
<li><a href="../461475/index.html">AMA with Habr. 1011</a></li>
<li><a href="../461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../461487/index.html">Mini CTF Tests</a></li>
<li><a href="../461493/index.html">Django 3.0 will be asynchronous</a></li>
<li><a href="../461497/index.html">Modern text rendering on Linux: part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>