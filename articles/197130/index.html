<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Coro and another implementation of rouse-callback</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is such a wonderful family of modules in CPAN - Coro . These modules allow you to program on pearl using corutin. 

 Small introduction 
 Imagin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Coro and another implementation of rouse-callback</h1><div class="post__text post__text-html js-mediator-article">  There is such a wonderful family of modules in CPAN - <a href="http://search.cpan.org/dist/Coro/">Coro</a> .  These modules allow you to program on pearl using corutin. <br><a name="habracut"></a><br><h5>  Small introduction </h5><br>  Imagine that at any moment anywhere in the program (for example, inside the function body or at the next iteration of the cycle) you can save the current state and temporarily "switch" to another point in the program.  Having done some useful work in this ‚Äúother‚Äù point, you come back, restore the saved state, and then all the work happens as if this ‚Äúswitch‚Äù was not at all.  Well, of course, apart from the changes in general data that occurred at the new point.  Having several ‚Äúheavy‚Äù functions, each of which does not depend on the results of the work of the others, such ‚Äúswitching‚Äù can simulate their parallel execution.  That is, from the outside it will look as if the functions are executed in parallel, but, in fact, at each moment of time only one of them is executed ‚Äúslice‚Äù, and you define the size of this ‚Äúslice‚Äù.  In other words, it turns out that each function is executed in its thread, all threads use only one processor core (regardless of their number in the system), and in order for each thread to get its processor time, they all must share this time among themselves .  Due to the lack of real parallelism, all changes in general data that have occurred in any stream become immediately available in all other streams, and since you set the switching points between the streams, the need for synchronization decreases sharply (basically, it is necessary for working with external resources ). <br>  All this and more can be implemented in a pearl with the help of a family of modules called Coro.  The main module of this family allows you to perform functions, or code blocks in separate streams (below I will call these streams coro-streams), and auxiliary modules add synchronization tools, message queues, integration with event loops, etc. <br><br><h5>  Creating coro streams </h5><br>  In order to create a coro stream, you must use one of the following constructs: <br><br><pre><code class="perl hljs">Coro::async { ... } @args;</code> </pre> <br>  notice the absence of a comma between the block and its arguments, or 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $coro = new Coro(\&amp;code_ref, @args); $coro-&gt;ready();</code> </pre><br>  In the first case, the block passed to the <code>Coro::async</code> function becomes a stream, while the arguments specified immediately after the block become available inside the block as function arguments (via <code>@_</code> ).  In the second case, you create a stream using the function reference and arguments for that function.  The second construct returns a reference to the created stream, for which the <code>ready()</code> method is then called.  This is the main difference between the second and the first constructions - the created thread will be inactive until it is placed in the ready-turn (more on this later). <br>  In both cases, the thread "lives" as long as the corresponding function or block of code is executed.  By the way, the program itself is also running in a separate coro stream - the main thing. <br><br><h5>  Switch between coro streams </h5><br>  Unlike system streams, switching between which is carried out somewhere in the depths of the operating system, it is necessary to switch between coro streams manually.  The most obvious switching points (you can think of more or less obvious): <br><ul><li>  Each n-th iteration of the "long-playing" cycle </li><li>  Each blocking operation (work with a network, disk, etc.) </li></ul><br>  In the second case, the processor is still not used until the data comes over the network, or is read from the disk (as well as transmitted over the network, or written to disk). <br>  How to transfer control using Coro?  In order to save the current state and interrupt the execution of the current coro stream, you must use the static method <code>schedule()</code> ; in addition, this method extracts the next coro stream from the ready queue and starts it to run.  Accordingly, in order for the coro flow calling <code>schedule()</code> to get processor time again in the future, it must first place itself at the end of the ready queue using the <code>ready()</code> method (or any other thread must do it for it) ).  The interrupted thread remains blocked (does not receive CPU time) until it is placed at the end of the ready queue;  if this does not happen by the time other active threads have completed their work, Coro will detect this and abort the program.  Since the <code>ready()</code> and <code>schedule()</code> calls are used quite often together, the Coro module provides for convenience the call to <code>cede()</code> , which is analogous to the following pair of lines: <br><br><pre> <code class="perl hljs">$Coro::current-&gt;ready(); Coro::schedule;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Consider an example</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl $| = 1; use strict; use warnings; use Coro; #  coro-   Coro::async Coro::async { my $thread_id = shift; #    coro- $Coro::current-&gt;desc("Thread #$thread_id"); for (my $i = 0; $i &lt; 1_000_000; $i++) { if ($i % 1000 == 0) { print "$Coro::current-&gt;{desc} - Processed: $i items\n"; #   coro-   ready- $Coro::current-&gt;ready(); #      ready- Coro::schedule(); } } } 0; #       coro- sub my_thread { my $thread_id = shift; $Coro::current-&gt;desc("Thread #$thread_id"); for (my $i = 0; $i &lt; 1_000_000; $i++) { if ($i % 1000 == 0) { print "$Coro::current-&gt;{desc} - Processed: $i items\n"; #     coro- Coro::cede(); } } } my @threads = (); for (my $thread_id = 1; $thread_id &lt; 5; $thread_id++) { #   coro-   Coro::new() my $thread = new Coro(\&amp;my_thread, $thread_id); #   coro-   ready- $thread-&gt;ready(); push @threads, $thread; } while (my $thread = shift @threads) { #   coro-   ,   coro-   $thread-&gt;join(); }</span></span></code> </pre><br>  Result: <br><pre> Thread # 0 - Processed: 0 items
 Thread # 1 - Processed: 0 items
 Thread # 2 - Processed: 0 items
 Thread # 3 - Processed: 0 items
 Thread # 4 - Processed: 0 items
 Thread # 0 - Processed: 1000 items
 Thread # 1 - Processed: 1000 items
 Thread # 2 - Processed: 1000 items
 Thread # 3 - Processed: 1000 items
 Thread # 4 - Processed: 1000 items
 ...
 Thread # 0 - Processed: 999000 items
 Thread # 1 - Processed: 999000 items
 Thread # 2 - Processed: 999000 items
 Thread # 3 - Processed: 999000 items
 Thread # 4 - Processed: 999000 items
</pre><br></div></div><br>  In the example, coro threads are created in different ways and in different ways pass each other processor time.  All coro-threads perform the same work - every 1000 iterations, report on the progress of work and interrupt their execution, giving the opportunity to work the rest of the coro-streams, first placing themselves at the end of the ready-queue (explicitly, or using <code>cede()</code> ).  The program continues to run until the main coro stream completes, and the main coro stream is busy waiting for the end of 4 of the 5 created coro streams (the call to the <code>join()</code> method blocks that coro stream from which the call is made until until the coro flow for which this method was called is completed). <br><br><h5>  Integration with event loops </h5><br>  The above example demonstrates how coro-threads share CPU time, taking a break from a long-running job.  As noted above, a good reason to share processor time is also to perform blocking operations (usually I / O operations). <br>  When we face the problem of effective work with many blocking operations, we usually solve this problem with the help of event loops.  For example, we translate sockets into a non-blocking mode and ‚Äúhang‚Äù watchers on them that monitor the readiness of a socket to write or read and create a timer to interrupt timeout operations.  As events of interest occur, from the depths of the event cycle, callbacks are invoked that are associated with the corresponding ‚Äúvsecher‚Äù.  As the project becomes more complex, it is clear what kind of callback, when and why it is called, it becomes more and more difficult.  With the use of Coro, the situation is noticeably improved and the program code becomes more linear and clear (purely my opinion). <br>  First of all, it should be noted that in the Coro family of modules there are three modules for integrating coro flows into event loops - these are <a href="http://search.cpan.org/perldoc%3FCoro%253A%253AAnyEvent">Coro :: AnyEvent</a> , <a href="http://search.cpan.org/perldoc%3FCoro%253A%253AEvent">Coro :: Event</a> and <a href="http://search.cpan.org/perldoc%3FCoro%253A%253AEV">Coro :: EV</a> (the code pieces below will be for Coro :: EV).  In order to integrate the event loop into your program, you need to run the loop itself in any coro stream (for example, in the main one): <br><br><pre> <code class="perl hljs">Coro::async { EV::run() };</code> </pre><br>  For ease of event handling, the Coro module provides two useful functions ‚Äî <code>rouse_cb()</code> and <code>rouse_wait()</code> : <br><ul><li>  <code>rouse_cb()</code> generates and returns a callback that, when called, saves the arguments passed to it and notifies Coro internals of the fact of the call. </li><li>  <code>rouse_wait()</code> blocks the current coro stream until the last <code>rouse_cb()</code> created by the <code>rouse_cb()</code> function is called (you can also specify the call of which callback to wait for as an argument);  the function returns what was passed to the callback as arguments </li></ul><br>  Thus, the following code snippets are equivalent: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment"># 1.   rouse_cb()  rouse_wait() my $timer = EV::timer(5, 5, sub { my ($watcher, $revents) = @_; print "Timer $wathcer: timeout\n"; }); #2.   rouse_cb()  rouse_wait() my $timer = EV::timer(5, 5, rouse_cb()); my ($watcher, $revents) = rouse_wait(); print "Timer $wathcer: timeout\n";</span></span></code> </pre><br><br><h5>  Another implementation of rouse callbacks </h5><br>  The above code <code>rouse_cb()</code> does not convey all the power of <code>rouse_cb()</code> and <code>rouse_wait()</code> , but its understanding comes as we work on real projects.  However, for myself I discovered the main minus of the built-in rouse-callbacks - if you save the callback returned by the <code>rouse_cb()</code> function and try to reuse it (which is logical for cyclic operations, because why create a new object at each iteration the same job?), nothing will come of it.  Being called at least once, the callback retains its state and all subsequent <code>rouse_wait()</code> calls for this callback immediately return the previously saved arguments. <br>  Therefore, I decided to write my own implementation of the rouse-callback.  In this implementation, the callback is an object, and the <code>rouse_wait()</code> method of callback is used instead of the <code>rouse_wait()</code> <code>wait()</code> function: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $cb = new My::RouseCallback; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $timer = EV::timer(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, $cb); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($watcher, $revents) = $cb-&gt;<span class="hljs-keyword"><span class="hljs-keyword">wait</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Timer $wathcer: timeout\n"</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Implementing My :: RouseCallback</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> My::RouseCallback; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Coro; <span class="hljs-comment"><span class="hljs-comment"># ""      My::RouseCallback my %STORAGE = (); #  : my $cb = new My::RouseCallback; sub new { my ($class) = @_; my $context = {args =&gt; [], done =&gt; 0, coro =&gt; undef}; my $self = bless sub { #     $context-&gt;{args} = \@_; #   ,     $context-&gt;{done} = 1; if ($context-&gt;{coro}) { #   coro- $context-&gt;{coro}-&gt;ready(); } }, $class; $STORAGE{"$self"} = $context; return $self; }; #   : $cb-&gt;wait(); sub wait { my $self = shift; my $context = $STORAGE{"$self"}; #   ,  coro-   $context-&gt;{coro} = $Coro::current; #   coro-   ,      while ($context-&gt;{done} == 0) { Coro::schedule(); } #        my @args = @{ $context-&gt;{args} }; $context-&gt;{args} = []; $context-&gt;{done} = 0; return @args; } sub DESTROY { my $self = shift; $self-&gt;(); delete $STORAGE{"$self"}; }; 1; __END__</span></span></code> </pre><br></div></div><br><br>  If you see the possibility of using Coro in your task, be sure to try it, you might like it.  Study the documentation, share the knowledge gained in practice. <br><br>  Ps.  If you use modules from the EV and Coro families together, be careful.  Both the first and second export the async () function by default.  Therefore, when creating coro streams, it is always better to explicitly specify Coro :: async. </div><p>Source: <a href="https://habr.com/ru/post/197130/">https://habr.com/ru/post/197130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197110/index.html">Tree mapping in qml</a></li>
<li><a href="../197122/index.html">Online LaTeX Editor Papeeria: Results of the Year and New Year's Gifts</a></li>
<li><a href="../197124/index.html">Separation of news and articles on Habr√©</a></li>
<li><a href="../197126/index.html">Yandex limits its liability to 10% of the cost of services under the contracts</a></li>
<li><a href="../197128/index.html">Stay Awhile and Listen</a></li>
<li><a href="../197134/index.html">KolibriOS: SVN commit # 4000</a></li>
<li><a href="../197136/index.html">Little tips for older kids</a></li>
<li><a href="../197138/index.html">Lenovo Thinkpad Tablet 2 and my unsuccessful attempt to install Linux</a></li>
<li><a href="../197140/index.html">Looking for a UI designer?</a></li>
<li><a href="../197146/index.html">Pick up languages, whose longer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>