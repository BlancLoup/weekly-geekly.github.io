<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a simple Lisp translator - III</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Previous article 

 Errors, Errors, Errors ... 
 A good program should be protected from user errors. This is absolutely indisputable. Errors need to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a simple Lisp translator - III</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habr.com/post/421445/">Previous article</a> <br><br><h3>  Errors, Errors, Errors ... </h3><br>  A good program should be protected from user errors.  This is absolutely indisputable.  Errors need to be processed, and even better - to prevent (prevention is always better than treatment!).  Aerobatics - to build a dialogue with the user, so that the latter simply could not make a mistake. <br><a name="habracut"></a><br>  For example, if a user needs to enter a positive integer in the input field, you can, of course, analyze the answer, and, finding non-numeric characters, issue a warning and ask the user to repeat the input.  But it is much better just to prohibit the input of non-numeric characters! <br><br>  Unfortunately, this technique can not be applied by far.  In particular, the variety of constructions arriving at the input of the translator is too large to simply ‚Äúcut off the wrong‚Äù by specifying an input mask. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A person has the privilege of making mistakes, and the translator should, in the case of entering incorrect language constructs, produce a clear diagnosis and, if possible, continue to analyze the source text in order to identify all errors.  The user will probably not like it very much if the translator will catch errors one by one.  And it is absolutely unacceptable to recognize the situation in which the program ‚Äúfalls‚Äù with a system error message. <br>  In this article we will go through the code that has been worked out earlier critically, and will try to prevent (handle) possible errors. <br><br>  Let's start with the first start function.  What she does?  It takes the name of the input file, opens it, and processes it line by line.  For such programs, the user interaction script is already ‚Äúsettled‚Äù - it can be considered canonical: <br><br><ul><li>  If the file name is not specified, call the standard ‚ÄúOpen‚Äù dialog; </li><li>  If the user has clicked the ‚Äúreject‚Äù button in the ‚ÄúOpen‚Äù dialog, exit; </li><li>  Check if the file with the specified / entered name exists.  If it does not exist, issue a message and exit; </li><li>  If the specified file exists, process it. </li></ul><br>  Our version of the start procedure does not satisfy this scenario.  In fact, look at the code above: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) <span class="hljs-comment"><span class="hljs-comment">;;      (when (zerop (strLen fname)) (setq fname (sysGetOpenName (sysHome) "-|*.mbs"))) (let ((fi (gensym 'fi))) (filOpen fi fname _INPUT) (loop (let ((curr-proc (action-proc fi))) (when *flagerr* (return t)) (when (filEOF fi) (return t)) (eval curr-proc))) (filClose fi)) (when *flagerr* (printsline "****   ")))</span></span></code> </pre> <br>  The negative response of the user is not analyzed, so if the ‚Äúreject‚Äù button is pressed, the program will ‚Äúfall‚Äù.  The existence of the file is also not analyzed.  Unfortunately, this flaw does not exhaust the shortcomings.  Obviously, if the procedure of the mini-basic is the last in the input file, then the analysis of the end of the file will cause the loop to break before the generated function is loaded into the Lisp environment. <br><br>  Fix these flaws: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶ ) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">when</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*))</code> </pre><br>  If the file name is given and the file exists, then processing is performed.  Otherwise, one of the messages is printed: ‚ÄúFile does not exist‚Äù or ‚ÄúFile name omitted‚Äù. <br>  In the body of the main loop, the following actions are performed sequentially: <br><br><ul><li>  Executes the action-proc function.  The result of her work is stored in a local variable curr-proc; </li><li>  If the * flagerr * flag is raised, the loop is broken; </li><li>  If the action-proc function returns a non-empty result, the generated function is loaded into the Lisp environment; </li><li>  If the end of the file is reached, the loop is also broken. </li></ul><br>  The code seemed to be better ... But one more serious flaw remained unresolved - after completing the processing of the procedure containing one or more errors, the main loop will be interrupted and the program will finish without viewing the part of the original year located after the procedure with errors.  This is bad - I would like the translator to produce all the errors that can be detected at each launch. <br><br>  To correct this shortcoming, let's introduce a global variable ‚Äúerror counter‚Äù, while processing the procedure with errors, we will increase this counter.  And the error flag will be reset after processing each procedure: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filCloseAll</span></span>) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *errcount*))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">not</span></span> *flagerr*)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*errcount*))</code> </pre><br>  Now the start function will work acceptable.  Let's see this.  Create the following source file: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> bla-bla end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> bla-bla-bla print x end_proc</code> </pre><br>  And ‚Äúlet it through‚Äù through our translator.  We get: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0007</span></span> bla-bla ****  (BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0008</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-number"><span class="hljs-number">0010</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0011 * 0012 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0013</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0014</span></span> input x <span class="hljs-number"><span class="hljs-number">0015</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0016</span></span> print y <span class="hljs-number"><span class="hljs-number">0017</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-number"><span class="hljs-number">0019</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0020 * 0021 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0022</span></span> bla-bla-bla ****  (BLA - BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0023</span></span> print x <span class="hljs-number"><span class="hljs-number">0024</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0025</span></span> ****   </code> </pre><br>  We assume that we have coped with the start function.  But the ‚Äúwork on the bugs‚Äù has just begun.  Let us take a closer look at the syntax of that part of the language that we have already implemented. <br><br>  Probably the most common syntax mistake that people most often make is the wrong bracket structure (unbalanced or standing parentheses in the wrong order).  Recall what happens to the line of the source code of the program on the mini-BASIC after it is read.  The line is parsed (broken into lexemes), and then the list of tokens is translated into an internal list form.  In the list of tokens, parentheses are separate tokens and we do not check their balance.  This could be done as a separate function, but the list of tokens is passed to the input of the function input, which translates the list of strings into the Lisp list.  If an incorrect string expression is passed to the input of the function, the function will return an error. <br><br>  Let's process this error. <br><br>  In HomeLisp, error handling is a construct (try Expression-1 except Expression-1).  It works as follows: <br><br><ul><li>  An attempt is made to calculate Expression-1.  If the attempt is successful, the result of the calculation is returned as the result of the entire form try; </li><li>  If an error occurs, Expression-2 is calculated.  At the same time, the system function is available without parameters (errormessage), which returns the text of the error message. </li></ul><br>  With that said, the transfer to the list form can be arranged as follows: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  In case of a conversion error, a system message will be displayed, and a list of one element will be returned as the result - the original line of code.  Further, this list will fall (as a regular operator) into the action-proc procedure.  And, of course, will not be recognized.  This will generate another error message, and the translator will continue to work.  Let's prepare the following source code, and try to translate it: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> print x end_proc</code> </pre><br>  We get the expected result: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"y=(x^2))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0007</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0008</span></span> * <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0010 * 0011 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0012</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0013</span></span> input x <span class="hljs-number"><span class="hljs-number">0014</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0015</span></span> print y <span class="hljs-number"><span class="hljs-number">0016</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0017</span></span> * <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0019 * 0020 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0021</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"x=3+)x^2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0022</span></span> print x <span class="hljs-number"><span class="hljs-number">0023</span></span> end_proc ****   </code> </pre><br>  And now let's take a critical look at the code that converts arithmetic expressions into a prefix notation.  This code does not contain any means of fixing user errors.  Unfortunately, these errors can be quite a lot.  Let's fix this mistake.  To begin with, we will try to broadcast a completely innocent (seemingly) code: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=6 y=-x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y end_proc</code> </pre><br>  The broadcast will end with the ‚Äúfall‚Äù of the translator!  The fall will cause the operator y = -x.  What is the matter?  In unary minus!  Transforming the formula from the infix form into the prefix form, we somehow did not think that a minus is a ‚Äútwo-faced‚Äù - there is a binary minus (a sign of the operation), and there is a unary minus (a sign of a number).  Our parser does not know this difference - it considers all cons to binary ... What now to do?  In order not to tear down an already working code, let's turn all unary minuses into binary ones.  How?  A very simple.  After all, it is quite obvious that the unary minus "lives" only in such constructions: <br><br>  "(-something" <br>  ‚Äú&gt; Something‚Äù <br>  ‚Äú&lt;-No‚Äù <br>  ‚Äú= Something‚Äù <br>  well, and at the very beginning of the formula, he can also meet.  Therefore, if, before breaking into lexemes, we make the following substitutions: <br><br>  ‚Äú(- something‚Äù =&gt; ‚Äú(0-something‚Äù <br>  ‚Äú&gt; Something‚Äù =&gt; ‚Äú&gt; 0-something‚Äù <br>  ‚Äú&lt;-No‚Äù =&gt; ‚Äú&lt;0-something‚Äù <br>  ‚Äú= -No‚Äù =&gt; ‚Äú= 0-something‚Äù <br><br>  and if the formula starts with a minus, we add a zero to the beginning of the formula, then all the minuses will become binary and the error will be eliminated radically.  Let's call the function that will do the above conversion, the name ‚Äúprepro‚Äù.  Here is what it might look like: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prepro (<span class="hljs-name"><span class="hljs-name">s</span></span>) (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">s0</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> s <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> s) s)) (<span class="hljs-name"><span class="hljs-name">s1</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s0 <span class="hljs-string"><span class="hljs-string">"(-"</span></span> <span class="hljs-string"><span class="hljs-string">"(0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s2</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s1 <span class="hljs-string"><span class="hljs-string">"=-"</span></span> <span class="hljs-string"><span class="hljs-string">"=0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s3</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s2 <span class="hljs-string"><span class="hljs-string">"&gt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s4</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s3 <span class="hljs-string"><span class="hljs-string">"&lt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;0-"</span></span>))) s4))</code> </pre><br>  Special comments are not required here.  But our simple parser has another not quite obvious at first glance misfortune - double signs of operations.  When working with formulas, the signs ‚Äú&gt;‚Äù and ‚Äú=‚Äù next to each other, mean one operation ‚Äú&gt; =‚Äù (and must constitute one lexeme!).  The parser does not want to know this - it will make each of the characters a separate lexeme.  You can cope with this problem by reviewing the list of received lexemes, and if the corresponding characters are next to each other, by performing the union.  Let's call the function that will perform the merge named ‚Äúpostpro‚Äù.  Here is the code for a possible implementation: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> postpro (<span class="hljs-name"><span class="hljs-name">lex-list</span></span>) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)) lex-list) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">c1</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> lex-list)) (<span class="hljs-name"><span class="hljs-name">c2</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> lex-list))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"="</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"!"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"/"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> c1 (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)))))))))</code> </pre><br>  Also, as we see, nothing special.  But now the final transfer function of the operator in the internal list form will look like this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> (<span class="hljs-name"><span class="hljs-name">prepro</span></span> txt) <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>))) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  And now let's take a critical look at the inf2ipn function.  What user errors can it ‚Äúdump‚Äù?  The imbalance of the brackets we have already cut off above.  What could be more?  Two signs of operation or two operands standing in a row.  One could analyze this in the code inf2ipn (and those who wish can do it themselves).  We ‚Äúcatch‚Äù these errors at the stage of transforming a formula from an SCR to a prefix one.  And let us (just in case) intercept all errors that may occur in the process of converting a formula from an infix form to a prefix one.  The best place for this is the i2p wrapper function.  Now it may look like this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> i2p (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> f)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  And now let's prevent the appearance in formulas of two characters of an operation or two operands in a row.  The previous article describes the algorithm for converting a formula from an SCR to a prefix form.  A sign of the correctness of the completion of this algorithm is that the last step in the stack should contain a single value.  If this is not the case, then a mistake was made.  And one more error situation occurs in the case when the function is called with the wrong (more or less) number of parameters.  These situations should be ‚Äúcaught‚Äù: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> ipn2pref (<span class="hljs-name"><span class="hljs-name">f</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> f) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s)) (<span class="hljs-name"><span class="hljs-name">car</span></span> s) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>))) ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) ((<span class="hljs-name"><span class="hljs-name">is-op</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">ar</span></span> (<span class="hljs-name"><span class="hljs-name">arity</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> s) ar) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))))) ((<span class="hljs-name"><span class="hljs-name">atom</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">car</span></span> s)) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s))))))</code> </pre><br>  Now let's take a critical look at the proc operator handler.  We clearly missed two points.  The first thing to do is to remember, when processing the procedure, to calculate its arity (the number of arguments) and modify the global variable * oplist * accordingly.  And the second is that the functions we generate do not return the correct value!  More precisely, as the result of the functions generated by our translator, the value of the last form, computed before return, will be returned.  To guarantee the return of the desired value, I propose to transfer the result variable from Pascal.  Now, if it is necessary to return the desired value, it is enough for the user to assign the desired value to this variable before exiting the function, and we need to insert the name result into the function body with the last expression when generating the function body.  All this brings the action-proc function to mind: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> '((result <span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">length</span></span> proc-parm)) *oplist*))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) '=) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">action-set</span></span> stmt))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) (<span class="hljs-name"><span class="hljs-name">if</span></span> proc-name `(defun ,proc-name ,proc-parm (let ,lv ,@body result)) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  We‚Äôll stop at this for now (although we‚Äôll still encounter problems, and the code will have to be refined; but such is the programmer‚Äôs lot ...) And now we‚Äôll consider two improvements to our language that are appropriate now. <br><br><h3>  Minor improvements ... </h3><br>  In the previous article I wrote that it is inconvenient for a programmer if in a language one statement occupies exactly one line.  It is necessary to provide the ability to write bulky operators on multiple lines.  Let's implement it.  Make it completely easy.  In the getLine procedure, we will create a local variable in which we will accumulate the read text (provided that this is not a comment and ends with a pair of ‚Äú_‚Äù characters. Once the significant line with a different ending is fixed, we return the accumulated value as a value. Here is the code: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> stri) <span class="hljs-number"><span class="hljs-number">2</span></span>)))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">return</span></span> res))))))</code> </pre><br>  And the last improvement.  In many programming languages, it is possible to use logical operands in arithmetic expressions (which in this case are calculated to zero or one).  This gives the language additional expressiveness and, by the way, is quite in line with the basic spirit.  In our mini-BASIC, an attempt to calculate the following expression, for example: <br><br><pre> <code class="hljs lisp">z=(<span class="hljs-name"><span class="hljs-name">x&gt;y</span></span>)*5+(<span class="hljs-name"><span class="hljs-name">x&lt;=y</span></span>)*10</code> </pre><br>  will cause a runtime error.  And this is understandable: in Lisp, the expression (&gt; xy) is calculated to Nil or T. And Nil / T cannot be multiplied by 5 ... However, this trouble is easy to help.  Let's write a few simple macros that will replace the result of comparison expressions with 0/1 (instead of Nil / T): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $== (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $/= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre><br>  Now let's take a look at the line in the ipn2pref function that performs the processing of the operation.  Here is this line: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Here (car f) is the name of the operation.  Let's write the tiny function of replacing comparison codes: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> chng-comp (<span class="hljs-name"><span class="hljs-name">op</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">member</span></span> op '(= == /= &lt;&gt; &gt; &lt; &gt;= &lt;=)) (<span class="hljs-name"><span class="hljs-name">implode</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> '$ (<span class="hljs-name"><span class="hljs-name">explode</span></span> op))) op))</code> </pre><br>  The function checks whether its argument is a comparison operation, and, if necessary, adds the ‚Äú$‚Äù character to the beginning.  Now let's call it in the right place of the ipn2pref function: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">chng-comp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  What is the result?  Comparison operations will be replaced by calls to the corresponding macro, and all other operations will not change.  If you translate just such a function: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=1 y=2 result=(x&gt;y)*5+(x&lt;=y)*10 end_proc</code> </pre><br>  and then call it, we get the expected result. <br><br>  For today - everything. <br><br>  The code for this article is located <a href="https://yadi.sk/d/BrEyvX7mM3VqAA"><b>here.</b></a> <br>  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/423663/">https://habr.com/ru/post/423663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423649/index.html">‚ÄúKubernetes in all fields!‚Äù - an interview with the DevOops conference program committee</a></li>
<li><a href="../423651/index.html">We invite everyone to hackathon SmartMail Hack: Pro Welcome</a></li>
<li><a href="../423653/index.html">PsRealVehicle, or the Open Source plugin for tank physics in Armored Warfare: Assault</a></li>
<li><a href="../423655/index.html">Generics + Spring: May the Force be with you</a></li>
<li><a href="../423657/index.html">I don‚Äôt respect encapsulation, or use another type of table of methods to quickly call private methods.</a></li>
<li><a href="../423667/index.html">The history of the first microprocessor video games</a></li>
<li><a href="../423669/index.html">How is it to be a team leader in Avito?</a></li>
<li><a href="../423671/index.html">Tesla's competitors received investments of $ 1 billion from Saudi Arabia</a></li>
<li><a href="../423673/index.html">Risks in software development</a></li>
<li><a href="../423675/index.html">Security Week 35: Winter Is Near, How to Assemble a Tesla Trojan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>