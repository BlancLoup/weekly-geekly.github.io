<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two approaches to software design for embedded</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to tell a little about two approaches of designing software in embedded. These two approaches are with the use of a super-cycle or with the use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two approaches to software design for embedded</h1><div class="post__text post__text-html js-mediator-article">  I want to tell a little about two approaches of designing software in embedded.  These two approaches are with the use of a super-cycle or with the use of RTOS (Real-Time Operation System, real-time operating system). <br><br>  I think that in the course of the story it will be clear also in which cases the first should be applied, and in which it is impossible to do without the second. <br><br>  I hope it will be interesting to all those who want to look into the world of development for embedded systems.  For those who are already embedded in the dog ate, most likely, there will be nothing new. <br><a name="habracut"></a><br><h5>  Quite a bit of theory (for those who take the very first steps). </h5><br>  We have a microcontroller, which is the actual processor, some memory and various peripherals, for example: analog-digital converters, timers, Ethernet, USB, SPI - all this depends strongly on the controller and the tasks to be solved. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can, for example, connect some sensor to the ADC input, say, a temperature sensor, which, when energized, transforms the temperature into a voltage measured by this ADC. <br><br>  And to the controller's output, called GPIO (General Purpose Input-Output), you can, for example, connect an LED (or something more powerful like a motor, but through an amplifier). <br><br>  Via SPI, RS232, USB, etc.  the controller can communicate with the outside world in a more complex way - by receiving and sending messages using a predetermined protocol. <br><br>  In 90% of cases software is written in C, sometimes C ++ or assembler can be used.  Although more and more opportunities to write at something higher level, if it does not apply to the direct work with the periphery and does not require the maximum possible speed. <br><br>  To better imagine what you have to deal with, here are a couple of examples of environments with which you have to work: the size of the FLASH controller (hard drive analog) is 16-256 kilobytes, the size of RAM is 64-256 kilobytes!  And in such an environment, it is really possible to launch not only the application, but also the real-time operating system with full-fledged multitasking support! <br><br>  The examples below are in pseudo-code, in some places very similar to C. Without implementation details, where this is not essential for understanding. <br><br><h5>  So, the "super cycle" approach. </h5><br>  The program in this approach looks easy: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { doSomething(); doSomethingElse(); doSomethingMore(); } }</code> </pre> <br><br>  An infinite loop in which the controller consistently does everything it needs to do. <br><br>  The most interesting, of course, in embedded systems is the work with the periphery (by the very same ADC, SPI, GPIO, etc.).  With external peripherals, the controller can work in two ways: polling or using interrupts.  In the first case, if we want, for example, to read a symbol from the RS232 console, then we will periodically check whether there is a symbol there until we receive it.  In the second case, we configure the RS232 controller so that it generates an interrupt when a new symbol appears. <br><br>  Demonstration of the first approach.  For example, we want to monitor the temperature, and if it exceeds the set limit - light the LED.  It will look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ init_adc(); init_gpio_as_out(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperature = readTemperature(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temperature &gt; TEMPERATURE_LIMIT) { turnLedOn(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { turnLedOff(); } }</code> </pre><br>  So far everything should be simple and clear.  (I will not give the functions of reading the temperature and manipulations with the LED - this is not the purpose of this article). <br><br>  But what if we need to do something at a given frequency?  In the example above, the temperature will be checked as often as possible.  And if we, for example, need to flash the LED once a second?  Or interrogate the sensor strictly at intervals of 10 milliseconds? <br><br>  Then timers come to the rescue (which practically any microcontroller has).  They work in such a way that they generate an interrupt with a given frequency.  The flashing LED will then look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interrupt_happened = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer_int_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ interrupt_happened = <span class="hljs-number"><span class="hljs-number">1</span></span>; clear_interrupt_condition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ init_timer(<span class="hljs-number"><span class="hljs-number">1</span></span>_SECOND_INTERVAL, timer_int_handler); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interrupt_happened) { ledToggle(); interrupt_happened = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br><br>  The peculiarity of working with interrupts is such that the interrupt handler (the code that will be called directly at the moment when the interrupt occurs) should be as short as possible.  Therefore, the most common solution is to set a global flag variable in the handler (yes, yes, without global variables nowhere, alas), but to check it in the main loop, and when it changes, perform the main work required to handle the event. <br><br>  This global variable must be declared with the identifier volatile - otherwise the optimizer may tritely discard unused code from its point of view. <br><br>  And if you need to flash two LEDs, so that one blinked once a second, and the second - three times?  You can, of course, use two timers, but with this approach we will not have enough timers for a long time.  Instead, we will make the timer work with a much higher frequency, and in the program we will use a divider. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint millisecond_counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer_int_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++millisecond_counter; clear_interrupt_condition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ init_timer(<span class="hljs-number"><span class="hljs-number">1</span></span>_MILLISECOND_INTERVAL, timer_int_handler); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { uint timestart1 = millisecond_counter; uint timestart2 = millisecond_counter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (millisecond_counter ‚Äì timestart1 &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1 second interval { led1Toggle(); timestart1 = millisecond_counter; } if (millisecond_counter ‚Äì timestart2 &gt; 333) // 1/3 second interval { led2Toggle(); timestart2 = millisecond_counter; } } }</span></span></code> </pre><br>  Note that we do not need to monitor the millisecond counter overflow, as the unsigned type is used. <br><br>  Imagine now that we have a debugging console implemented on top of the RS232 interface (the most common solution in the embedded world!).  And we want to display debug messages there (which will be visible if our controller is connected to a computer via a COM port).  And at the same time we need to interrogate the sensor connected to the controller with a strictly set (high) frequency. <br><br>  And here the question arises - how to implement such a banal thing, as the output line to the console?  An obvious solution like <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * str)</span></span></span><span class="hljs-function"> </span></span>{ foreach (ch in str) { put_ch(ch); } }</code> </pre><br><br>  in this case will be invalid.  It will output a string, but at the same time it will irreversibly violate the requirement to interrogate the sensor with a strictly specified frequency.  We do all this in one big cycle, where all actions are performed sequentially, remember?  And the console is a slow device, and the output of a string can take much longer than the required interval between successive polls of the sensor.  The example below is how not to do it! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (something) { send_string(<span class="hljs-string"><span class="hljs-string">"something_happened"</span></span>); } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>_millisecond_timeout()) { value = readADC(); } } }</code> </pre><br><br>  Another example - you want to implement software overload protection.  Add a current meter, connect it to the ADC controller, control the safety relay will turn on one of the input-output pins.  And naturally, you want the protection to work as soon as possible after the occurrence of the overload event (otherwise everything will just burn out).  And you have the same general cycle, in which all actions are performed strictly in order.  And the guaranteed reaction time to an event can never be less than the time it takes to execute one iteration of the loop.  And if in this cycle there will be operations that require a long time to complete, then everything will be the actual, it is they who will set the system response time to everything else. <br><br>  And if suddenly, somewhere in this cycle, an error creeps in, then the whole system will fall down.  Including the reaction to overload (which I really would not want to allow, wouldn‚Äôt it?). <br><br>  Although with the first problem it is theoretically possible to do something else.  For example, replace the simplest, but long line printing function with something like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &lt; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str) { put_ch(str[position]; ++position; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br>  And a simple call to this function for something like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (something) { do_print = <span class="hljs-number"><span class="hljs-number">1</span></span>; position = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (do_print) { do_print = send_string(<span class="hljs-string"><span class="hljs-string">"something_happened"</span></span>); } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>_millisecond_timeout()) { value = readADC(); } } }</code> </pre><br><br>  As a result, we have reduced the time taken to go through one cycle from the time needed to print a whole line to the time needed to print one character.  But for this, instead of primitive and understandable at first glance, the line output function in the console had to add two state machines to the code ‚Äî one for printing (to memorize the position), and the other for printing, to remember that we are now printing a line on over the next few cycles.  Long live global variables, ‚Äúdirty‚Äù functions, storing states, and other such wonderful things that easily and very quickly can turn code into unaccompanied spaghetti. <br><br>  Now imagine that the system should simultaneously poll a dozen sensors, respond to several critical events requiring immediate response, process commands ‚Äúarriving‚Äù from a user or computer, output debug messages, manage a dozen indicators or manipulators.  And for each of the actions given their own limitations on the reaction time and the frequency of the survey or control.  And try to stuff it all in one successive common cycle. <br><br>  Of course, this is all real.  But the one who will have to accompany all this after at least a year after writing, I will not envy. <br><br>  Another common design cycle problem is the complexity of measuring system load.  Suppose you have a code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_interrupt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ interrupt_happened = <span class="hljs-number"><span class="hljs-number">1</span></span>; clear_interrupt_condition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interrupt_happened) { doSomething(); interrupt_happened = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br><br>  The system somehow reacts to the interruption coming from the outside.  And the question is how many such interruptions per second can the system handle?  How busy will the processor be when processing 100 events per second? <br><br>  It will be very difficult for you to measure how much time was spent on event processing, and how much - on polling the variable ‚ÄúDid the interruption occur?‚Äù.  After all, everything is performed in one cycle! <br><br>  And here comes the second approach. <br><br><h5>  The use of real-time operating system. </h5><br>  The easiest way to illustrate its application is to use the same example: simultaneous interrogation of a sensor with a given frequency and output to the console of a long debug line. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SensorPollingTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { value = SensorRead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; LIMIT) { doSomething(); } taskDelay(<span class="hljs-number"><span class="hljs-number">10</span></span>_MILLISECOND_DELAY); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_task_queue = os_queue_create(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * str = os_queue_read(dbg_task_queue); foreach (ch in str) { put_ch(ch); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ other_task_init(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// we want to do a dbg_printout here os_queue_put("Long Debug Output String"); ‚Ä¶ } } int main() { os_task_create(SensorPollingTask, HIGH_PRIORITY); os_task_create(DebugTask, LOW_PRIORITY); os_task_create(OtherTask, OTHER_PRIORITY); os_start_sheduler(); }</span></span></code> </pre><br><br>  As you can see, there is no longer one main infinite loop in the main function.  Instead, a separate infinite loop in each task.  (Yes, the function os_start_sheduler (); never returns control!).  And most importantly, these tasks have priorities.  The operating system itself will provide what we need - so that the task with high priority is performed first of all, and with low priority - only when there is time for it. <br><br>  And if the reaction time to, for example, an interrupt in a super-cycle design is equal in the worst case to the entire cycle (interruption happens, of course, right away, but not always the necessary actions can be done directly in the handler), then the reaction time in the case of a real-time OS, it will be equal to the switching time between tasks (which is small enough to assume that this happens right away!).  Those.  the interruption will occur in one task, and immediately upon its completion we will switch to another task, awaiting the event ‚Äúlaunched‚Äù from the interruption. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overcurrent_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ os_semaphore_give(overcurrent_semaphore); clear_interrupt_condition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OvercurrentTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ os_sem_create(overcurrent_semaphore); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { os_semaphore_take(overcurrent_semaphore); DoOvercurrentActions(); } }</code> </pre><br><br>  As for measuring CPU usage, this task using the OS becomes trivial.  By default, each OS has the most voracious (but also the lowest priority) Idle task, which performs an empty infinite loop and gets control only when all other tasks are inactive.  And counting the time spent in Idle is usually already implemented.  It remains only to display it in the console. <br><br>  Also, if all of a sudden you ‚Äúdo not notice‚Äù any mistake, then only the task in which the error will be present ‚Äúfalls‚Äù (it is also possible that all tasks with a lower priority will also continue), but tasks with a higher priority will continue to be executed, providing at least minimal vital functions of the device, for example, protection against overload. <br><br>  And summing up: if the system is very simple and undemanding by the reaction time, it is easier to do it on the model of a ‚Äúsuper cycle‚Äù.  If the system is going to become big, uniting in itself many different actions and reactions, which are also time critical, then there is no alternative to using a real-time OS. <br><br>  In addition, plus the use of the OS - a simpler and more understandable code (since we can group the code by task, avoiding global variables, state machines and other garbage necessary when using the design with a supercycle). <br><br>  Minus the use of the OS - for its use requires more space, memory, experience and knowledge (although there is nothing complicated there, yet multitasking is a priori more complicated and unpredictable than consistently running code).  Be sure to have a good understanding of the principles of working in a multitasking environment, the principles of thread-safe code, data synchronization, and much more. <br><br>  For the "play" you can take FreeRTOS - a free open source project, while quite stable and easy to learn.  Although not uncommon, and commercial projects using this particular OSes. </div><p>Source: <a href="https://habr.com/ru/post/148805/">https://habr.com/ru/post/148805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148796/index.html">9gag received almost $ 3 million investment</a></li>
<li><a href="../148798/index.html">VMA - smart flash memory for database</a></li>
<li><a href="../148800/index.html">How to make a web service for converting Excel, Word, TXT and other files to PDF in the "as I see" mode</a></li>
<li><a href="../148801/index.html">Peak Android passed? Google‚Äôs share of the US market has decreased by 5%</a></li>
<li><a href="../148804/index.html">We invite you on August 9 and 10 to Kiev for a free seminar on ITIL</a></li>
<li><a href="../148806/index.html">The most important motivation</a></li>
<li><a href="../148808/index.html">The stock hackers again came "breaking" ...</a></li>
<li><a href="../148809/index.html">The problem of "two or more teachers." First touches</a></li>
<li><a href="../148810/index.html">Koding.com - localhost in the cloud</a></li>
<li><a href="../148812/index.html">Diagnostics in pictures: we understand the state of the product using tables and graphs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>