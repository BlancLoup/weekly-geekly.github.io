<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QNX RTOS: Inter-Task Interaction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the cycle of QNX real-time operating system notes. This time, I would like to talk about cross-tasking interaction in QNX Neutrino (we will...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QNX RTOS: Inter-Task Interaction</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/c0282b2b/b59b5db4/ff601799/63643823.jpg" align="left">  Continuing the cycle of <a href="http://habrahabr.ru/blogs/nix/124656/">QNX real-time operating system</a> notes.  This time, I would like to talk about cross-tasking interaction in QNX Neutrino (we will consider QNX 6.5.0).  In RTOS, there is a wide range of inter-tasking mechanisms ‚Äî from QNX-specific messaging to familiar signals to developers of UNIX and POSIX and shared memory.  And although most of the notes will be devoted to messaging, the features of using signals, POSIX messages and shared memory will also be described.  And those who read to the end will get two buns for tea. <br><br><img src="https://habrastorage.org/storage1/5e534e30/d364c9b4/de30fc2d/d00bd65b.jpg" align="right">  Understanding the messaging principle is essential for a QNX system programmer, since  This mechanism plays a fundamental role in the RTOS.  Many familiar and familiar to the developers of the functions of the operating system are only add-ons and implemented through messaging (for example, <code>read()</code> and <code>write()</code> ). <a name="habracut"></a><br><br><h4>  Qtx RTOS Interaction Forms </h4><br>  As mentioned above, messaging is a fundamental mechanism for inter-task interaction in QNX, on which several other mechanisms are based.  All forms of inter-task interaction considered in this note are listed in the table below, indicating who is responsible for implementing this or that mechanism. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Table 1. Forms of inter-task interaction.</i> <br><table><tbody><tr><th>  Mechanism </th><th>  Scope of implementation </th></tr><tr><td>  Message exchange </td><td>  microkernel </td></tr><tr><td>  Signals </td><td>  microkernel </td></tr><tr><td>  Shared memory </td><td>  <code>procnto</code> process <code>procnto</code> </td></tr><tr><td>  POSIX Message Queues </td><td>  <code>mqueue</code> manager </td></tr><tr><td>  Unnamed (pipe) and named (FIFO) program channels </td><td>  <code>pipe</code> manager </td></tr></tbody></table><br>  In QNX RTOS 6.5.0, another form of inter-task interaction appeared - Persistent Publish / Subscribe (PPS).  This is quite an interesting technology, which I will try to write about another time.  Those interested can read the translation <a href="http://www.kpda.ru/QNX6/PPS">of the PPS section</a> of the QNX Neutruno System Architecture. <br><br><h4>  Message exchange </h4><br>  This is a synchronous mezhzadachny interaction mechanism implemented in the QNX Neutrino micronucleus.  When developing the RTOS, this form of inter-task interaction was not accidentally chosen as the main one.  Firstly, the mechanism itself is quite simple.  Secondly, the synchronous transmission and reception of messages facilitates debugging.  Third, testing of high-level forms of interaction (for example, software channels) based on QNX Neutrino messaging and implemented in a monolithic core revealed approximately the same performance characteristics. <br><br>  The messaging mechanism in QNX is also called the SRR mechanism, after the first letters of the three main functions used in messaging <a href="https://habr.com/ru/post/127173/"><sup>1</sup></a> .  <code>MsgSend()</code> is for sending a message, <code>MsgReceive()</code> is for receiving a message, and <code>MsgReply()</code> is for transmitting a response to the caller.  First, consider each function separately to understand how they work, and then combine them in one example.  All the arguments of the functions will not be intentionally cited so as not to be distracted and first understand the principle of operation. <br><br>  <code>MsgSend()</code> is used to send a message from the <i>client</i> to the <i>server</i> and receive a response.  The concepts of <i>client</i> and <i>server</i> are quite arbitrary here, because  the same program can be a server for some tasks and, at the same time, a client of others.  For example, a database server is a server for database clients <a href="https://habr.com/ru/post/127173/"><sup>2</sup></a> .  And at the same time, the database server will be the client for the file system manager.  When the <code>MsgSend()</code> function is <code>MsgSend()</code> client is blocked in one of two states: <code>SEND</code> or <code>REPLY</code> .  <code>SEND</code> status means that the <i>client has</i> sent a message, and the <i>server has</i> not yet received it.  After the <i>server</i> receives the message, the <i>client</i> enters the <code>REPLY</code> state.  When the <i>server</i> returns a response message, the <i>client is</i> unlocked. <br><br>  <code>MsgReceive()</code> is used to receive messages from <i>clients</i> .  <i>The server</i> calls <code>MsgReceive()</code> and is blocked in the <code>RECEIVE</code> state if none of the <i>clients have</i> yet sent him a message, i.e.  did not call the <code>MsgSend()</code> function.  After this happened (a message was sent to the <i>server</i> ).  <i>The server</i> unlocks and continues its execution.  <i>The server</i> usually needs to perform some actions to process the received message and prepare to receive a new one.  If the <i>server is</i> working in several threads, then another thread can execute the message processing and response to the <i>client</i> .  Most often, the thread receiving the message works in the "perpetual" cycle and after processing the received message, it calls <code>MsgReceive()</code> again. <br><br>  <code>MsgReply()</code> used to send a response message to <i>client</i> <a href="https://habr.com/ru/post/127173/"><sup>3</sup></a> .  When the <code>MsgReply()</code> function is <code>MsgReply()</code> lock does not occur, i.e.  <i>the server</i> will continue to work.  This is done because the <i>client is</i> already in a locked state ( <code>REPLY</code> ) and no additional synchronization is required. <br><br>  What else needs to be learned in order to make up from those building blocks of knowledge that we have, a bridge to understanding the QNX messaging mechanism?  Not so much.  Be patient, now the picture will begin to take shape. <br><br>  The QNX Neutrino microkernel does not care about the contents of the transmitted message.  Messages do not have any format.  The message makes sense only for the <i>client</i> and <i>server</i> .  The microkernel only copies the message (i.e., just the data buffer) from the <i>client</i> 's address space to the <i>server's</i> address space (and vice versa when responding) and there is no intermediate buffer for storing messages.  And that means there is no intermediate copy, because  the microkernel copies data directly from the <i>client</i> ‚Äôs memory to the <i>server‚Äôs</i> memory (and vice versa when responding).  As a result, the speed of the message passing mechanism increases. <br><br>  To synchronize the transmission, reception, and response to a message, the microkernel blocks the threads involved in exchanging messages in one of three states: <code>SEND</code> , <code>RECIEVE</code> and <code>REPLY</code> .  <i>The client is</i> blocked in the <code>SEND</code> state until the <i>server</i> accepts its message.  <i>The server is</i> locked in the <code>RECEIVE</code> state if none of the <i>clients</i> sent a message to it.  After receiving the message by the <i>server</i> , it is unlocked, and the <i>client</i> enters the locked state <code>REPLY</code> .  After the <i>server</i> returns a response to the <i>client</i> , the latter is unlocked.  That's all. <br><br>  So, we figured out how the QNX messaging engine works.  Fig.  1 simply illustrates the above. <br><br><img src="https://habrastorage.org/storage1/1917fe5e/c05fff1f/fe3d8bd0/2dc04d37.jpg"><br>  <i>Fig.</i>  <i>1. Messaging in QNX Neutrino.</i> <br><br><h4>  How does the <i>client</i> find the <i>server</i> ? </h4><br>  If you understand how the messaging mechanism works in the QNX RTOS, you can move on.  Probably, you should have one question, without deciding which, you will not be able to exchange messages in QNX.  How does the <i>client</i> find the <i>server</i> ? <br><br>  Messages are not transmitted directly between threads.  Instead, channels and connections are used.  <i>The server</i> creates a channel using the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/c/channelcreate.html"><code>ChannelCreate()</code></a> function.  Now, finally, the <i>server</i> can call <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgreceive.html"><code>MsgReceive()</code></a> and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgreply.html"><code>MsgReply()</code></a> with a clear conscience.  A piece of code below illustrates the operation of the <i>server</i> : <br><br><pre> <code class="cpp hljs">chid = ChannelCreate( flags ); <span class="hljs-comment"><span class="hljs-comment">/*    chid  -1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { rid = MsgReceive( chid, &amp;msg, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( msg ), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/*    rid  -1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( msg.type ) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } MsgReply( rid, EOK, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> }</code> </pre> <br>  In turn, the <i>client</i> creates a connection to the <i>server</i> channel using <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/c/connectattach.html"><code>ConnectAttach()</code></a> , and then calls <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsend.html"><code>MsgSend()</code></a> .  <i>Client</i> code <i>is</i> very simple: <br><br><pre> <code class="cpp hljs">coid = ConnectAttach( nd, pid, chid, _NTO_SIDE_CHANNEL, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/*    coid  -1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> MsgSend( coid, smsg, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( smsg ), rmsg, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( rmsg ) ); <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre> <br>  Now the last question remains.  Where <code>chid</code> <i>client</i> find out the <i>server</i> parameters: <code>nd</code> , <code>pid</code> , <code>chid</code> ?  These parameters are the <i>server</i> address or even the phone number with the city code and extension number.  Half of the answer to this question is that the <i>server</i> itself knows all these parameters.  But how can the <i>server</i> report them to the <i>client</i> ? <br><br>  There are various ways to get this information from the <i>server</i> .  You can use <code>.pid</code> files or global variables.  But the right way for small applications is to use the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/n/name_attach.html"><code>name_attach()</code></a> function in the <i>server</i> , and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/n/name_open.html"><code>name_open()</code></a> in the <i>client</i> .  An even more correct way is to implement the <i>server</i> as a <i>resource manager</i> <a href="https://habr.com/ru/post/127173/"><sup>4</sup></a> , when it is responsible for the namespace element. <br><br><h4>  Composite messages </h4><br>  As already mentioned, one of the main advantages of the QNX Neutrino messaging engine is its high performance.  This is achieved by the fact that there is no intermediate copying of data, i.e.  The message is copied directly from the <i>client</i> ‚Äôs memory to the <i>server‚Äôs</i> memory.  It often happens that these messages are in different places.  A typical case is when the data is a raw buffer received from the hardware and a structure with information about the data (message header).  The raw data itself may be located in a circular buffer.  Is it really necessary in this case to prepare a separate buffer and copy the header and data from the ring buffer there?  Wouldn't it be overkill?  This unnecessary copying of data before sending a message can be avoided in the QNX RTOS by using composite messages. <br><br>  To form composite messages in QNX Neutrino, you need to declare an array of type <code>iov_t</code> , with the number of elements equal (or more) to the number of messages, and initialize each element using the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/s/setiov.html"><code>SETIOV()</code></a> macro, i.e.  specify the address and size of each buffer.  Fig.  2 illustrates the principle of operation of composite messages. <br><br><img src="https://habrastorage.org/storage1/805e630e/da5032e5/b42fd779/550d8d67.jpg"><br>  <i>Fig.</i>  <i>2. An example of a composite message.</i> <br><br>  To work with composite messages, the familiar functions of <code>MsgReceive()</code> and <code>MsgReply()</code> , but with the end of v, i.e.  <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgreceivev.html"><code>MsgReceivev()</code></a> and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgreplyv.html"><code>MsgReplyv()</code></a> .  Since the function of sending a message <code>MsgSend()</code> also receives the result, it acquires a whole family: <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsendv.html"><code>MsgSendv()</code></a> , <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsendsv.html"><code>MsgSendsv()</code></a> and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsendvs.html"><code>MsgSendvs()</code></a> .  Now the microkernel will do all the extra work for us, and no additional copying and buffer with the whole message.  I like that! <br><br><h4>  Impulses </h4><br>  Sometimes it is only required to inform another thread that something has happened, and no response is required.  So it is not necessary and blocking on <code>MsgSend()</code> .  In this case, the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsendpulse.html"><code>MsgSendPulse()</code></a> function comes to the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgsendpulse.html"><code>MsgSendPulse()</code></a> .  The pulse contains 8 bits of code and 32 bits of data.  Very often, pulses are used in interrupt handlers.  For pulses, queues are used, i.e.  impulses will not be lost if the flow for some time did not accept them.  But be prepared, sooner or later, to get an <code>EAGAIN</code> error if you send impulses to a stream that does not have time to read them. <br><br><h4>  Signals </h4><br>  The QNX Neutrino RTOS supports a signaling mechanism that should be familiar to UNIX developers.  Both standard POSIX and real-time POSIX signals are supported.  To work with both types of signals, the same microkernel code is used.  As a result, the microkernel itself becomes more compact, and POSIX signals (at the request of an application) can be queued, just like their colleagues from the POSIX real-time signal group.  Among other things, QNX Neutrino extends the POSIX standard and allows you to send signals to a specific stream.  And this is sometimes very useful. <br><br>  By the way, POSIX real-time signals contain 8 bits of code and 32 bits of data.  Nothing like?  Precisely, the same code that implements the signal mechanism is also used in the transmission of pulses.  Convenient and reliable. <br><br>  Signals use the familiar functions <code>kill()</code> , <code>sigaction()</code> , <code>sigprocmask()</code> , etc., as well as more interesting functions, for example, <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/p/pthread_kill.html"><code>pthread_kill()</code></a> and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/p/pthread_sigmask.html"><code>pthread_sigmask()</code></a> . <br><br><h4>  Programming channels </h4><br>  Software channels should be familiar to UNIX users and developers.  In QNX, all the familiar commands, functions and techniques also exist.  For example, this is how an unnamed program pipe (pipe) is created on the command line: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l | less</span></span></code> </pre> <br>  To create a named pipe (FIFO), you must use the <code>mkfifo</code> command or the <code>mkfifo()</code> function. <br><br>  There is only one feature.  In order for QNX Neutrino to work with software channels, it is necessary to start the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_utilities/p/pipe.html"><code>pipe</code></a> manager. <br><br><h4>  POSIX Message Queues </h4><br>  Message queues are similar to named programmatic channels (FIFOs), but are more complex mechanisms because  support message priorities.  To work with POSIX message queues in QNX Neutrino, you must run the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_utilities/m/mqueue.html"><code>mqueue</code></a> manager. <br><br>  Note that message queues in the QNX RTOS can contain more than one slash '/', which means you can create directories.  This extends the POSIX standard, which requires that the queue name begin with a slash and no longer contain this character.  A rather convenient feature, since  You can group the queues of one software package or one company in one directory. <br><br><h4>  Shared memory </h4><br>  Working with shared memory in QNX Neutrino is the same as in other UNIX systems.  Since the shared memory mechanism is implemented in the <code>procnto</code> process <code>procnto</code> , which also contains the microkernel, you do not need to run anything else.  You can read more in the documentation on the functions <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/s/shm_open.html"><code>shm_open()</code></a> and <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/mmap.html"><code>mmap()</code></a> . <br><br>  Separately, it should be noted that the shared memory itself is not suitable for inter-task interaction.  Even if the <i>server</i> only writes to the shared memory, and the <i>client</i> only reads from it, it may happen that the client subtracts partially modified data.  Such an error can be difficult to catch later, so it is better not to make it at all.  To eliminate such a situation, it is necessary to apply one of the synchronization primitives, for example, mutexes or semaphores. <br><br>  Not least of interest is the method of inter-task interaction, with the simultaneous use of the messaging mechanism and shared memory.  This is especially useful if you plan to build a distributed system, because  shared memory is not available over the network.  This solution has a very high performance due to the use of shared memory, and also has the ability to synchronize and network transparency through the exchange of messages. <br><br>  You should not try to build any interaction using shared memory, based on the fact that this is the fastest way.  If synchronization primitives are used, then the speed can be comparable to the speed of the messaging mechanism.  Significant gain will be only in the exchange of data of a very large amount. <br><br><h4>  Promised buns </h4><br>  Since I promised that there will be buns, they will.  I did not forget, and I do not mind.  The first thing is that when sending a message, you can use the same buffer for the message itself and the response to it.  I would even say that they do it quite often.  To make it more convenient, all structures describing various messages and the answers to them are grouped into one union.  Normally, the message sent is not required by the <i>client</i> after receiving a response from the <i>server</i> .  This way you can save on the buffer. <br><br>  The second thing is that the POSIX file descriptor in QNX Neutrino is the same as the connection (for sending messages).  And this means that functions that use file descriptors ( <code>write()</code> , <code>read()</code> , etc.) are just wrappers with minor overheads that convert their arguments into messages to the <i>server</i> .  Serious enough optimization.  So, if you want to develop system software for QNX, then learn to write a resource manager. <br><br><h4>  Bibliography </h4><ol><li>  QNX Neutrino Real-Time Operating System 6.3.  System architecture  ISBN 5-94157-827-X </li><li>  QNX Neutrino Real-Time Operating System 6.3.  User's manual.  ISBN 978-5-9775-0370-9 </li><li>  Rob Krten, ‚ÄúAn Introduction to QNX Neutrino 2. A Guide for Real-Time Application Developers,‚Äù 2nd Edition.  ISBN 978-5-9775-0681-6 </li></ol><br><hr> <i><a name="ref1"></a></i>  <i><sup>1</sup> The prefix <code>Msg</code> in the name of the functions <code>MsgSend()</code> and others appeared only in QNX Neutrino, and in QNX4 these functions were called simply <code>Send()</code> , <code>Receive()</code> and <code>Reply()</code> .</i>  <i>Hence the name SRR.</i> <br><br> <i><a name="ref2"></a></i>  <i><sup>2</sup> In the example, the database server and clients do not use messaging functions directly, but we already know that in QNX, under each <code>read()</code> , <code>write()</code> , <code>sendto()</code> and others, the SRR mechanism is hidden.</i> <br><br> <i><a name="ref3"></a></i>  <i><sup>3</sup> If the server should return only an error code, for example, if the message is not supported, it is more convenient to use the <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp%3Ftopic%3D/com.qnx.doc.neutrino_lib_ref/m/msgerror.html"><code>MsgError()</code></a> function.</i> <br><br> <i><a name="ref4"></a></i>  <i><sup>4 A</sup> description of resource managers is beyond the scope of this note.</i>  <i>It is possible that I will write about this some other time.</i> </div><p>Source: <a href="https://habr.com/ru/post/127173/">https://habr.com/ru/post/127173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127168/index.html">Diamond Dash again</a></li>
<li><a href="../127169/index.html">TURNKEY INTRODUCTION: mutual understanding of the parties</a></li>
<li><a href="../127170/index.html">Record labels are suing a site that allows you to download videos from YouTube</a></li>
<li><a href="../127171/index.html">Convenient device for cloning hard drives</a></li>
<li><a href="../127172/index.html">SignalGuru program for predicting traffic signals</a></li>
<li><a href="../127176/index.html">Interview with Sergey Archipenkov - About the upcoming Software Project Management Conference</a></li>
<li><a href="../127179/index.html">Authorization via VKontakte, Mail.ru and others - 3 (VKontakte and OAuth)</a></li>
<li><a href="../127180/index.html">The article "PD for an ordinary person" - debriefing</a></li>
<li><a href="../127182/index.html">How free software contributed to the success of Steve Jobs and Apple</a></li>
<li><a href="../127183/index.html">Updated firmware for HTC HD2. Windows Phone 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>