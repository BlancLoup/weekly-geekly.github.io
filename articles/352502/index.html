<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in Swift 4.1?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Xcode 9.3 and Swift 4.1 are finally no longer beta! This release contains long-awaited improvements to the standard library and the language itself. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in Swift 4.1?</h1><div class="post__text post__text-html js-mediator-article">  Xcode 9.3 and Swift 4.1 are finally no longer beta!  This release contains long-awaited improvements to the standard library and the language itself.  If you do not follow the <a href="https://github.com/apple/swift-evolution">Swift Evolution process</a> , then this article is for you. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/da1/bb9/5a9da1bb94c55a3084ddabcef722cd30.jpg" alt="Swift 4.1"></div><br>  In this article you will learn about the most significant changes made in <b>Swift 4.1</b> . <br><br>  This article requires Xcode 9.3, so make sure that this version of Xcode is installed. <br><a name="habracut"></a><br><h3>  The first steps </h3><br>  Swift 4.1 is compatible with Swift 4 source code, so new features do not violate your code if you have already migrated your project to Swift 4 with <b>Swift Migrator</b> in Xcode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the following sections, you will see related tags, such as [SE-0001].  These are the <a href="https://apple.github.io/swift-evolution/">Swift Evolution</a> offer numbers.  I added a link to each proposal so that you can understand the full information about each particular change.  I recommend that you try out the functions in practice using the Playground in order to better understand exactly what will change in your work. <br><br>  To get started, launch Xcode 9.3 and select <b>File ‚ñ∏ New ‚ñ∏ Playground</b> .  Select <b>iOS</b> as the platform and <b>Blank</b> as the template.  Name and save it on your own.  To get the most out of this article, try to practice each function in the Playground. <br><br>  <b>Note:</b> <i>If you missed what was changed in Swift 4 and are going to catch up?</i>  <i>No problems!</i>  <i>Check out Swift 4 by reading <a href="https://www.raywenderlich.com/163857/whats-new-swift-4">What's New in Swift 4</a> .</i> <br><br><h3>  Language enhancements </h3><br>  This release contains a number of language enhancements, including conditional matching, recursive constraints on related types in protocols, and more. <br><br><h4>  Conditional match </h4><br>  Conditional matching allows protocol matching for generic types, where type arguments satisfy certain conditions <a href="">[SE-0143]</a> .  This is a powerful feature that makes code more flexible.  You can see how it works with a few examples. <br><br><h4>  Conditional match in the standard library </h4><br>  In Swift 4, you can compare arrays, dictionaries, and optionals if their elements conform to the <b>Equatable</b> protocol.  This worked perfectly fine for basic scenarios, such as: <br><br><pre><code class="hljs erlang">// Arrays <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Int <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameArray = firstArray == secondArray // Dictionaries with Int values <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstDictionary = [<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"George"</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondDictionary = [<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"George"</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameDictionary = firstDictionary == secondDictionary // Comparing Int? <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstOptional = firstDictionary[<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondOptional = secondDictionary[<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameOptional = firstOptional == secondOptional</code> </pre> <br>  Using the <b>==</b> operator to check for equality in these examples was quite fair, since <b>Int</b> is <b>Equatable</b> in Swift 4. However, comparing option sets is a common situation you might encounter in Swift 4, because the <b>options</b> do not comply with the <b>Equatable</b> protocol.  Swift 4.1 corrects this problem using conditional correspondence, allowing you to compare additional types with those types that underlie <b>Equatable</b> : <br><br><pre> <code class="hljs erlang">// Array <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Int? <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, nil, <span class="hljs-number"><span class="hljs-number">2</span></span>, nil, <span class="hljs-number"><span class="hljs-number">3</span></span>, nil] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, nil, <span class="hljs-number"><span class="hljs-number">2</span></span>, nil, <span class="hljs-number"><span class="hljs-number">3</span></span>, nil] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameArray = firstArray == secondArray // Dictionary with Int? values <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstDictionary = [<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"George"</span></span>: nil] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondDictionary = [<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"George"</span></span>: nil] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameDictionary = firstDictionary == secondDictionary // Comparing Int?? (Optional <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Optional) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstOptional = firstDictionary[<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondOptional = secondDictionary[<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameOptional = firstOptional == secondOptional</code> </pre><br>  <b>Int?</b>  is <b>Equatable</b> in Swift 4.1, so the <b>==</b> operator works for <b>[Int?], [String: Int?]</b> and <b>Int ??</b>  . <br><br>  A similar problem was solved when comparing arrays (for example, [[Int]]).  In Swift 4, you can compare arrays of sets (for example, [Set &lt;/ Int /&gt;]), since sets correspond to the <b>Equatable</b> protocol.  Swift 4.1 solves this, because arrays (and dictionaries), as well as their basic values, are <b>Equatable</b> . <br><br><pre> <code class="hljs lua">let firstArrayOfSets = [Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])] let secondArrayOfSets = [Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])] // Will work <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Swift <span class="hljs-number"><span class="hljs-number">4.1</span></span> // since Set&lt;Int&gt; is Equatable firstArrayOfSets == secondArrayOfSets let firstArrayOfArrays = <span class="hljs-string"><span class="hljs-string">[[1, 2, 3], [3, 4, 5]]</span></span> let secondArrayOfArrays = <span class="hljs-string"><span class="hljs-string">[[1, 2, 3], [3, 4, 5]]</span></span> // Caused an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">4</span></span>, but works <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">4.1</span></span> // since Arrays are Equatable <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">4.1</span></span> firstArrayOfArrays == secondArrayOfArrays</code> </pre><br>  As a rule, <b>Optional</b> , <b>Array</b> and <b>Dictionary</b> in Swift 4.1 now conform to <b>Equatable</b> and <b>Hashable</b> , whenever their base values ‚Äã‚Äãor elements conform to these protocols. <br><br>  Here is an example of how conditional matches work in the standard library.  Then you implement it in your code. <br><br><h4>  Conditional correspondence in practice </h4><br>  Now we use conditional correspondence to create our own group of musical instruments.  Add the following code block to the <i>Playground</i> . <br><br><pre> <code class="hljs cmake">// <span class="hljs-number"><span class="hljs-number">1</span></span> class LeadInstrument: Equatable { let brand: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> init(brand: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) { self.brand = brand } func tune() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Standard tuning."</span></span> } static func ==(lhs: LeadInstrument, rhs: LeadInstrument) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.brand == rhs.brand } } // <span class="hljs-number"><span class="hljs-number">2</span></span> class Keyboard: LeadInstrument { override func tune() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Keyboard standard tuning."</span></span> } } // <span class="hljs-number"><span class="hljs-number">3</span></span> class Guitar: LeadInstrument { override func tune() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Guitar standard tuning."</span></span> } }</code> </pre><br>  Here is what this code does step by step: <br><br><ol><li>  The LeadInstrument class conforms to the Equatable protocol.  It has a specific brand and tune () method that you will use to configure the tool. </li><li>  You override the tune () method in the Keyboard class to return the default settings for the object. </li><li>  You do the same for the Guitar class. </li></ol><br>  Then declare a group of tools: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Band&lt;LeadInstrument&gt; { let <span class="hljs-type"><span class="hljs-type">name</span></span>: String let lead: LeadInstrument init(<span class="hljs-type"><span class="hljs-type">name</span></span>: String, lead: LeadInstrument) { self.name = <span class="hljs-type"><span class="hljs-type">name</span></span> self.lead = lead } } // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> Band: Equatable <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> LeadInstrument: Equatable { static func ==(lhs: Band&lt;LeadInstrument&gt;, rhs: Band&lt;LeadInstrument&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.name == rhs.name &amp;&amp; lhs.lead == rhs.lead } }</code> </pre><br>  Here is what you are doing step by step: <br><br><ol><li>  You create a class of the Band type - LeadInstrument.  Each group has a unique name and a lead instrument. </li><li>  You use where the Band conforms to the Equatable protocol, just like LeadInstrument performs certain actions.  This is where conditional correspondence manifests itself - you can assign compliance to Equatable protocol for the generic LeadInstruments. </li></ol><br>  Then create your favorite groups of tools and compare them: <br><br><pre> <code class="hljs lisp">// <span class="hljs-number"><span class="hljs-number">1</span></span> let rolandKeyboard = Keyboard(<span class="hljs-name"><span class="hljs-name">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"Roland"</span></span>) let rolandBand = Band(<span class="hljs-name"><span class="hljs-name">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Keys"</span></span>, lead: rolandKeyboard) let yamahaKeyboard = Keyboard(<span class="hljs-name"><span class="hljs-name">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"Yamaha"</span></span>) let yamahaBand = Band(<span class="hljs-name"><span class="hljs-name">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Keys"</span></span>, lead: yamahaKeyboard) let sameBand = rolandBand == yamahaBand // <span class="hljs-number"><span class="hljs-number">2</span></span> let fenderGuitar = Guitar(<span class="hljs-name"><span class="hljs-name">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"Fender"</span></span>) let fenderBand = Band(<span class="hljs-name"><span class="hljs-name">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Strings"</span></span>, lead: fenderGuitar) let ibanezGuitar = Guitar(<span class="hljs-name"><span class="hljs-name">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"Ibanez"</span></span>) let ibanezBand = Band(<span class="hljs-name"><span class="hljs-name">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Strings"</span></span>, lead: ibanezGuitar) let sameBands = fenderBand == ibanezBand</code> </pre><br>  In this code snippet, you create two Keyboards and Guitar along with their respective Bands.  Then you compare Bands directly, thanks to the conditional match that you identified earlier. <br><br><h4>  Conditional match in JSON parsing </h4><br>  In Swift 4.1, arrays, dictionaries, sets and additional modules correspond to the Codable protocol, if their elements also conform to this protocol.  Add the following code to the playground: <br><br><pre> <code class="hljs coffeescript">struct Student: Codable, Hashable { let firstName: String let averageGrade: Int } let cosmin = Student(firstName: <span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>, averageGrade: <span class="hljs-number"><span class="hljs-number">10</span></span>) let george = Student(firstName: <span class="hljs-string"><span class="hljs-string">"George"</span></span>, averageGrade: <span class="hljs-number"><span class="hljs-number">9</span></span>) let encoder = JSONEncoder() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Encode an Array <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> students let students = [cosmin, george] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(students) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed encoding students array: \(error)"</span></span>) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Encode a Dictionary with student values let studentsDictionary = [<span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>: cosmin, <span class="hljs-string"><span class="hljs-string">"George"</span></span>: george] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(studentsDictionary) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed encoding students dictionary: \(error)"</span></span>) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Encode a Set <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> students let studentsSet: Set = [cosmin, george] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(studentsSet) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed encoding students set: \(error)"</span></span>) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Encode an Optional Student let optionalStudent: Student? = cosmin <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(optionalStudent) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed encoding optional student: \(error)"</span></span>) }</code> </pre><br>  Do you use this code for encode <b>[Student]</b> , <b>[String: Student]</b> , Set &lt;/ Student /&gt; and <b>Student?</b>  .  This code works well in Swift 4.1, since Student is <b>Codable</b> , which makes these types of collections also <b>Codable compliant</b> . <br><br><h4>  Conversion between CamelCase and Snake_Case when working with JSON </h4><br>  Swift 4.1 allows you to convert <b>CamelCase</b> properties to <b>snake_case</b> keys during JSON parsing: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-type"><span class="hljs-type">Data</span></span>() encoder.keyEncodingStrategy = .convertToSnakeCase encoder.outputFormatting = .prettyPrinted <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { jsonData = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(students) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonString = <span class="hljs-type"><span class="hljs-type">String</span></span>(data: jsonData, encoding: .utf8) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(jsonString) }</code> </pre><br>  When you create an <b>encoder</b> object, you set the <b>keyEncodingStrategy</b> property to <b>.convertToSnakeCase</b> .  Looking at the console, you should see: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"first_name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"average_grade"</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"first_name"</span></span> : <span class="hljs-string"><span class="hljs-string">"George"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"average_grade"</span></span> : <span class="hljs-number"><span class="hljs-number">9</span></span> } ]</code> </pre><br>  You can also convert back from snake_case to CamelCase while working with JSON: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> studentsInfo: [<span class="hljs-type"><span class="hljs-type">Student</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() decoder.keyDecodingStrategy = .convertFromSnakeCase <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { studentsInfo = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Student</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> studentInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> studentsInfo { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(studentInfo.firstName) \(studentInfo.averageGrade)"</span></span>) }</code> </pre><br>  This time, for the <b>keyDecodingStrategy</b> property <b>,</b> you assign the value <b>.convertFromSnakeCase</b> . <br><br><h4>  Equatable and Hashable protocol compliance and compatibility </h4><br>  In Swift 4, it was required to write template code so that the structures conform to the <b>Equatable</b> and <b>Hashable protocols</b> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Country</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> capital: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Country, rhs: Country)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.name == rhs.name &amp;&amp; lhs.capital == rhs.capital } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashValue: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name.hashValue ^ capital.hashValue &amp;* <span class="hljs-number"><span class="hljs-number">16777619</span></span> } }</code> </pre><br>  Using this code, you implement <b>== (lhs: rhs :)</b> and <b>hashValue</b> to support both <b>Equatable</b> and <b>Hashable</b> .  You can compare <i>Country</i> objects, add them to <i>Set‚Äôs</i> and even use them as keys for a dictionary: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> france = Country(name: <span class="hljs-string"><span class="hljs-string">"France"</span></span>, capital: <span class="hljs-string"><span class="hljs-string">"Paris"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> germany = Country(name: <span class="hljs-string"><span class="hljs-string">"Germany"</span></span>, capital: <span class="hljs-string"><span class="hljs-string">"Berlin"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameCountry = france == germany <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countries: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> = [france, germany] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetings = [france: <span class="hljs-string"><span class="hljs-string">"Bonjour"</span></span>, germany: <span class="hljs-string"><span class="hljs-string">"Guten Tag"</span></span>]</code> </pre><br>  Swift 4.1 adds default implementations for the structures of the corresponding <b>Equatable</b> and <b>Hashable</b> , since all its properties are <b>Equalable</b> and <b>Hashable</b> [ <a href="">SE-0185</a> ]. <br><br>  This greatly simplifies your code, which you can simply rewrite as: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Country</span></span></span></span>: Hashable { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> capital: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }</code> </pre><br>  Enumerations with related values ‚Äã‚Äãalso require additional code to work with <b>Equatable</b> and <b>Hashable</b> in Swift 4: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlogPost</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tutorial(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> article(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: BlogPost, rhs: BlogPost)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lhs, rhs) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (.tutorial(lhsTutorialTitle, lhsTutorialAuthor), .tutorial(rhsTutorialTitle, rhsTutorialAuthor)): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhsTutorialTitle == rhsTutorialTitle &amp;&amp; lhsTutorialAuthor == rhsTutorialAuthor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (.article(lhsArticleTitle, lhsArticleAuthor), .article(rhsArticleTitle, rhsArticleAuthor)): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhsArticleTitle == rhsArticleTitle &amp;&amp; lhsArticleAuthor == rhsArticleAuthor <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashValue: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> .tutorial(tutorialTitle, tutorialAuthor): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tutorialTitle.hashValue ^ tutorialAuthor.hashValue &amp;* <span class="hljs-number"><span class="hljs-number">16777619</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> .article(articleTitle, articleAuthor): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> articleTitle.hashValue ^ articleAuthor.hashValue &amp;* <span class="hljs-number"><span class="hljs-number">16777619</span></span> } } }</code> </pre><br>  You used enumeration cases to write implementations <b>== (lhs: rhs :)</b> and <b>hashValue</b> .  This allowed you to compare blog posts and use them in sets and dictionaries: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swift3Article = BlogPost.article(<span class="hljs-string"><span class="hljs-string">"What's New in Swift 3.1?"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cosmin PupƒÉzƒÉ"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swift4Article = BlogPost.article(<span class="hljs-string"><span class="hljs-string">"What's New in Swift 4.1?"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cosmin PupƒÉzƒÉ"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameArticle = swift3Article == swift4Article <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftArticlesSet: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> = [swift3Article, swift4Article] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftArticlesDictionary = [swift3Article: <span class="hljs-string"><span class="hljs-string">"Swift 3.1 article"</span></span>, swift4Article: <span class="hljs-string"><span class="hljs-string">"Swift 4.1 article"</span></span>]</code> </pre><br>  Unlike <b>Hashable</b> , the size of this code is significantly smaller in Swift 4.1, thanks to the <b>Equatable</b> and <b>Hashable implementations</b> : <br><br><pre> <code class="hljs vbscript">enum BlogPost: Hashable { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tutorial(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> article(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) }</code> </pre><br>  You just saved yourself from working with 20 lines of template code! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/0db/e14/edd0dbe14cde5ca78a0bd2ad6fb67c57.png" alt="image" width="320" height="320"></div><br><h4>  Hashable Index Types </h4><br>  Key paths could use indices if the index parameter type was Hashable in Swift 4. This allowed them to work with double arrays;  eg: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftVersions = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3.1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4.1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = \[<span class="hljs-type"><span class="hljs-type">Double</span></span>].[swiftVersions.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latestVersion = swiftVersions[keyPath: path]</code> </pre><br>  You use <b>keyPath</b> to get the current Swift version number from <b>swiftVersions</b> . <br><br>  Swift 4.1 adds matching <b>Hashable</b> to all types of subscripts in the standard library [ <a href="">SE-0188</a> ]: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">me</span></span> = <span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newPath = \<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.[<span class="hljs-keyword"><span class="hljs-keyword">me</span></span>.startIndex] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myInitial = <span class="hljs-keyword"><span class="hljs-keyword">me</span></span>[keyPath: newPath]</code> </pre><br>  By index is returned the first letter of the string.  It works because String index types are <b>Hashable</b> in Swift 4.1. <br><br><h4>  Recursive constraints on related types in protocols </h4><br>  Swift 4 did not support the definition of recursive constraints on related types in protocols: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPhone</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Version</span></span> = <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span> = <span class="hljs-type"><span class="hljs-type">IPhone</span></span> }</code> </pre><br>  In this example, you have identified the type associated with the SmartPhone, but it might be useful to limit it to the Phone, since all smartphones are phones.  This is now possible in Swift 4.1 [ <a href="">SE-0157</a> ]: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span>: <span class="hljs-type"><span class="hljs-type">Phone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span>.<span class="hljs-type"><span class="hljs-type">Version</span></span> == <span class="hljs-type"><span class="hljs-type">Version</span></span>, <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span>.<span class="hljs-type"><span class="hljs-type">SmartPhone</span></span> == <span class="hljs-type"><span class="hljs-type">SmartPhone</span></span> }</code> </pre><br>  You use, where to limit both Version and SmartPhone so that they are the same as on the phone. <br><br><h4>  Weak and not busy links in the protocols </h4><br>  Swift 4 supports <i>weak</i> and <i>unowned</i> protocol properties: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pitch</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tune</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key: <span class="hljs-type"><span class="hljs-type">Key</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pitch: <span class="hljs-type"><span class="hljs-type">Pitch?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Instrument</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tune</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key: <span class="hljs-type"><span class="hljs-type">Key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pitch: <span class="hljs-type"><span class="hljs-type">Pitch?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(key: <span class="hljs-type"><span class="hljs-type">Key</span></span>, pitch: <span class="hljs-type"><span class="hljs-type">Pitch?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.key = key <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pitch = pitch } }</code> </pre><br>  You set up the instrument in a specific key and pitch.  The pitch may have been zero, so you'll be modeling it as weak in the Tune protocol. <br><br>  But both weak and unowned are practically meaningless if they are defined in the protocol itself, therefore Swift 4.1 removes them and you will receive a warning using these keywords in the protocol [ <a href="">SE-0186</a> ]: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tune</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key: <span class="hljs-type"><span class="hljs-type">Key</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pitch: <span class="hljs-type"><span class="hljs-type">Pitch?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } }</code> </pre><br><h4>  Index Distances in Collections </h4><br>  Swift 4 used <b>IndexDistance</b> to declare the number of items in the collection: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeOfCollection</span></span></span><span class="hljs-function">&lt;C: Collection&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collection: C)</span></span></span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">C</span></span>.<span class="hljs-type"><span class="hljs-type">IndexDistance</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionType: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> collection.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">100</span></span>: collectionType = <span class="hljs-string"><span class="hljs-string">"small"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">101</span></span>...<span class="hljs-number"><span class="hljs-number">1000</span></span>: collectionType = <span class="hljs-string"><span class="hljs-string">"medium"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>...: collectionType = <span class="hljs-string"><span class="hljs-string">"big"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: collectionType = <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (collectionType, collection.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) }</code> </pre><br>  The <i>typeOfCollection (_ :)</i> method returns a tuple that contains the type and number of the collection.  You can use it for any collections, such as arrays, dictionaries or sets;  eg: <br><br><pre> <code class="hljs lisp">typeOfCollection(<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">800</span></span>) // (<span class="hljs-string"><span class="hljs-string">"medium"</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>) typeOfCollection(<span class="hljs-name"><span class="hljs-name">greetings</span></span>) // (<span class="hljs-string"><span class="hljs-string">"small"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  You can improve the return type of the function by limiting <b>IndexDistance</b> to <b>Int</b> with the <b>where</b> clause: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeOfCollection</span></span></span><span class="hljs-function">&lt;C: Collection&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collection: C)</span></span></span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">C</span></span>.<span class="hljs-type"><span class="hljs-type">IndexDistance</span></span> == <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,       }</span></span></code> </pre><br>  Swift 4.1 replaces <b>IndexDistance</b> with Int in the standard library, so in this case you do not need the <b>where</b> clause [ <a href="">SE-0191</a> ]: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeOfCollection</span></span></span><span class="hljs-function">&lt;C: Collection&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collection: C)</span></span></span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,       }</span></span></code> </pre><br><h4>  Structure initializers in modules </h4><br>  Adding properties to <b>public</b> structures can lead to initial changes in Swift 4. In this article, make sure that the Project Navigator is visible in Xcode by going to the <b>View \ Navigators \ Show</b> menu of the <b>Project Navigator.</b>  Then right-click ‚ÄúSources‚Äù and select ‚ÄúNew File‚Äù in the menu.  Rename the file <i>DiceKit.swift</i> .  Replace its contents with the following code block: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dice { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstDie: Int <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondDie: <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Int</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> finalValue: Int <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ..&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>: finalValue = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6.</span></span>..: finalValue = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: finalValue = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> } firstDie = finalValue secondDie = <span class="hljs-number"><span class="hljs-number">7</span></span> - finalValue } }</code> </pre><br>  The structure initializer ensures that both dice have valid values ‚Äã‚Äãbetween 1 and 6. Return to the <i>Playground</i> and add this code at the end: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-number"><span class="hljs-number">1</span></span> let dice = Dice(<span class="hljs-number"><span class="hljs-number">0</span></span>) dice.firstDie dice.secondDie // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> Dice { init(_ firstValue: <span class="hljs-type"><span class="hljs-type">Int</span></span>, _ secondValue: <span class="hljs-type"><span class="hljs-type">Int</span></span>) { firstDie = firstValue secondDie = secondValue } } // <span class="hljs-number"><span class="hljs-number">3</span></span> let newDice = Dice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) newDice.firstDie newDice.secondDie</code> </pre><br>  Here is what you did with this code: <br><br><ol><li>  You have created a valid pair of dice. </li><li>  You have added Dice through another initializer that has direct access to its properties. </li><li>  You have defined an invalid pair of dice with a new structure initializer. </li></ol><br>  In Swift 4.1, <b>cross-target initializers</b> should cause a default value.  Change the Dice extension to: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> firstValue: <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> secondValue: <span class="hljs-type"><span class="hljs-type">Int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(firstValue - secondValue)) } }</code> </pre><br>  This change leads to the fact that the structures behave like classes: the initializers of the cross-modules must be convenience initializers in Swift 4.1 [ <a href="">SE-0189</a> ]. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cce/b10/bc6/cceb10bc6e06882cbc5f878988b10f0f.png" alt="image" width="320" height="320"></div><br>  In Swift 4.1, you can no longer fool the dice! <br><br><h4>  Platform Settings and Configuration Updates </h4><br>  Swift 4.1 adds some necessary platform functions and builds to test the code: <br><br><h4>  Build Imports / Build Imports </h4><br>  In Swift 4, you tested the module if it is available on a specific platform, determining the operating system itself: for example: <br><br><pre> <code class="hljs lua">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>(iOS) || <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>(tvOS) import UIKit <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"UIKit is available on this platform."</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"UIKit is not available on this platform."</span></span>) #endif</code> </pre><br>  UIKit is available on <b>iOS</b> and <b>tvOS</b> , so you imported it if the test was successful.  Swift 4.1 simplifies this process by allowing you to verify the module itself: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> canImport(UIKit) print("UIKit is available </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> this is printed!") #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  In Swift 4.1, you use <b>#if canImport (UIKit)</b> to confirm that a certain structure is available for import [ <a href="">SE-0075</a> ]. <br><br><h4>  Target Environments </h4><br>  When writing code in Swift 4, the most famous way to verify the execution of code on a simulator or physical device was to check the architecture and operating system: <br><br><pre> <code class="hljs lisp">#if (<span class="hljs-name"><span class="hljs-name">arch</span></span>(<span class="hljs-name"><span class="hljs-name">i386</span></span>) || arch(<span class="hljs-name"><span class="hljs-name">x86_64</span></span>)) &amp;&amp; (<span class="hljs-name"><span class="hljs-name">os</span></span>(<span class="hljs-name"><span class="hljs-name">iOS</span></span>) || os(<span class="hljs-name"><span class="hljs-name">tvOS</span></span>) || os(<span class="hljs-name"><span class="hljs-name">watchOS</span></span>)) print(<span class="hljs-string"><span class="hljs-string">"Testing in the simulator."</span></span>) #else print(<span class="hljs-string"><span class="hljs-string">"Testing on the device."</span></span>) #endif</code> </pre><br>  Whether your processor architecture was based on Intel, and your operating system was iOS, tvOS or watchOS, you tested it in a simulator.  Otherwise, you tested the device. <br>  This test was very cumbersome, and it also did not fully describe the type of errors.  Swift 4.1 makes this test easier;  just use targetEnvironment (simulator) [SE-0190] as follows: <br><br><pre> <code class="hljs lisp">#if targetEnvironment(<span class="hljs-name"><span class="hljs-name">simulator</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Testing in the simulator."</span></span>) #endif</code> </pre><br><h3>  Miscellaneous Bits and Pieces </h3><br>  Swift 4.1 has a few more updates worth knowing: <br><br><h4>  Compacting Sequences </h4><br>  In Swift 4, the use of <b>flatMap (_ :)</b> to filter nil values ‚Äã‚Äãfrom a sequence was quite common: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pets = [<span class="hljs-string"><span class="hljs-string">"Sclip"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">"Nori"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> petNames = pets.flatMap { $<span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">// ["Sclip", "Nori"]</span></span></code> </pre><br>  Unfortunately, <b>flatMap (_ :)</b> was overloaded in various ways and, in this particular scenario, the <b>flatMap (_ :)</b> assignment did not really describe the actions taken. <br><br>  For these reasons, Swift 4.1 introduces the renaming of <b>flatMap (_:)</b> to <b>compactMap (_ :)</b> , to make its meaning clearer and more unique [ <a href="">SE-0187</a> ]: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> petNames = pets.compactMap {$ <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br><h4>  Unsafe Pointers / Unsafe Pointers </h4><br>  Swift 4 used temporary unsafe editable pointers to create and modify unsafe mutable pointer pointers: <br><br><pre> <code class="hljs lisp">let buffer = UnsafeMutableBufferPointer&lt;Int&gt;(<span class="hljs-name"><span class="hljs-name">start</span></span>: UnsafeMutablePointer&lt;Int&gt;.allocate(<span class="hljs-name"><span class="hljs-name">capacity</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>), count: <span class="hljs-number"><span class="hljs-number">10</span></span>) let mutableBuffer = UnsafeMutableBufferPointer(<span class="hljs-name"><span class="hljs-name">start</span></span>: UnsafeMutablePointer(<span class="hljs-name"><span class="hljs-name">mutating</span></span>: buffer.baseAddress), count: buffer.count)</code> </pre><br>  Swift 4.1 allows you to work with unsafe mutable pointer pointers directly, using the same approach as with unsafe mutable pointers [ <a href="">SE-0184</a> ]: <br><br><h3>  New Playground Features </h3><br>  Swift 4 let you customize type descriptions in the <i>Playground</i> Xcode: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tutorial</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tutorial</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPlaygroundQuickLookable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> customPlaygroundQuickLook: <span class="hljs-type"><span class="hljs-type">PlaygroundQuickLook</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .text(<span class="hljs-string"><span class="hljs-string">"raywenderlich.com tutorial"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tutorial = <span class="hljs-type"><span class="hljs-type">Tutorial</span></span>()</code> </pre><br>  You have implemented <b>CustomPlaygroundQuickLookable</b> for the <b>Tutorial</b> and return a brief description.  The description type in <b>customPlaygroundQuickLook</b> was limited to <b>PlaygroundQuickLook</b> instances.  there is no such pun in Swift 4.1: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tutorial</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPlaygroundDisplayConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> playgroundDescription: <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"raywenderlich.com tutorial"</span></span> } }</code> </pre><br>  This time you are implementing a <b>CustomPlaygroundDisplayConvertible</b> .  The description type is <b>Any</b> , so you can return anything from playgroundDescription.  This simplifies your code and makes it more flexible [ <a href="">SE-0198</a> ]. <br><br><h3>  What next? </h3><br>  Swift 4.1 improves on some of the features of Swift 4 in preparation for more serious changes that will appear in Swift 5 this year.  These include ABI stability, improved generics and strings, new memory ownership and concurrency models, and more. <br><br>  If you feel like an adventurer, go and look at <a href="https://developer.apple.com/documentation/swift%3Fchanges%3Dlatest_minor%2520rel%3D">the Swift standard library</a> or on the <a href="">Swift CHANGELOG</a> official website, where you can read more information about all the changes in this version. <br><br>  If you're wondering what changes will be in Swift 5, we also recommend that you familiarize yourself with <a href="https://github.com/apple/swift-evolution/tree/master/proposals">Swift Evolution's offers</a> , where you can see new features, changes and additions. </div><p>Source: <a href="https://habr.com/ru/post/352502/">https://habr.com/ru/post/352502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352492/index.html">Using the Python Control Systems Library for designing automatic control systems</a></li>
<li><a href="../352494/index.html">Eternal photo archive for home</a></li>
<li><a href="../352496/index.html">Google closes goo.gl. Replaced by Firebase Dynamic Links</a></li>
<li><a href="../352498/index.html">Learning is light, or how to organize a master class in 2 days</a></li>
<li><a href="../352500/index.html">For beginners: 5 tips on github</a></li>
<li><a href="../352508/index.html">Heading "We read articles for you." December 2017 - January 2018</a></li>
<li><a href="../352510/index.html">Security Trends: why attackers attack non-financial accounts to steal money</a></li>
<li><a href="../352512/index.html">As we in Smart Engines taught Sailfish OS recognition</a></li>
<li><a href="../352514/index.html">What's new in Swift 4.1</a></li>
<li><a href="../352516/index.html">Alternative approaches to the development of new IT products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>