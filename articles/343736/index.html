<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Avtomatny workshop - 2. Example "Crossing", the mathematical transformations of TK in OA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To invent a bicycle - not to cross the river. The ‚ÄúCrossing‚Äù task has been raised twice in a couple of months, but I want to mention this decision , b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Avtomatny workshop - 2. Example "Crossing", the mathematical transformations of TK in OA</h1><div class="post__text post__text-html js-mediator-article">  To invent a bicycle - not to cross the river.  The ‚ÄúCrossing‚Äù task has been raised twice in a couple of months, but I want to mention <a href="https://habrahabr.ru/post/340124/">this decision</a> , because it illustrates the successful objective view, and gives the successful OA model, which can only be logically developed, which ultimately will give a more perfect solution than with other views on the problem. <br><a name="habracut"></a><br><p>  <a href="https://habrahabr.ru/post/331556/">Table of contents</a> <br></p><p>  <a href="https://habrahabr.ru/post/342048/">Previous article</a> <br><br></p><p>  Often, a successful subject image of the process that needs to be carried out is equivalent to obtaining a solution to the problem in general, this is almost half the success in choosing OA.  This is so important that I want to illustrate what the <i>objective view is</i> meant by the term and how the choice of a successful OA naturally follows from a view of the subject, and already the choice of a successful OA pushes one to find the optimal solution.  Thus, it is possible to put a sign of an approximate equality between the choice of the optimal OA and the determination of the optimal solution.  In the last article I demonstrated the choice of OA on the example of the module "Display".  Further work on the "Display" is another topic: the <i>modification of auto-implemented programs</i> , I will return to it a little later.  Today's task still more clearly shows the procedure for developing an optimal OA. <br><br></p><p>  Statement of the problem in the form of ‚Äúwolf, goat and cabbage‚Äù is just an excuse, and we will focus on solving the problem in general, for any number of participants and their food addictions, and any number of places in boats.  The task is to obtain such an algorithm that will allow us to find the shortest way to implement the crossing, or to show that the problem in this formulation has no solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><h2>  Identical transformations TK </h2><br><p>  I will begin with the quotations from the previous article <i>‚Äúthere are cases when the subject image of the conditions of the problem does not even hint with what operational automaton to process them.</i>  <i>In this case, the conditions of the problem can be subjected to mathematical processing, and to solve not the original problem, but a mathematically identical, but more convenient one ‚Äù.</i> <br><br></p><p>  Literally, the shipping process will consist of the following steps. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/pl/iz/ge/plizgefvjhcmjtxda8eqlu_ujo0.png"></div><br>  <i><font color="#888888">Figure 1. Initial presentation of the transport process</font></i> <br><br><p>  If you look at it as a mathematician, and completely abstract from the logistics of river transport, you can see that steps 1, 3, 5, 7 are superfluous.  In those moments when the farmer is on the shore, there can be no problems, only cases need to be considered when the farmer is on the way.  The case of a peasant moored to the shore simply means the exchange of the contents of the boat and the shore.  The peasant in this case is strongly associated with the boat and it can no longer be considered at all.  Since there are no excesses in the boat according to the condition of the problem, it can also not be considered at all, along with the contents.  If something is currently in the boat, then there will be one smaller object on the banks.  Everything described above created information noise, not allowing to see the essence of what is happening.  In this case, the transportation process is depicted as shown in Fig.  2 <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/gs/wd/zx/gswdzx-ie-v6a0pnoh-5slfzrqq.png"></div><br>  <i><font color="#888888">Figure 2. The process of transportation after identical transformations</font></i> <br><br><p>  The fact that I did this is essentially the same transformation.  Mathematical experience and mathematical intuition help to see the identity of the tasks shown in Figures 1 and 2.  Not so long ago there was a survey in which the author was interested in whether mathematics is necessary for programmers.  In my experience, for the development of mathematical experience and intuition, I would strongly advise programmers to study probability theory.  It is the theory of probability that teaches combinatorics, and the fact that it is necessary to take into account not only the variants of interest (called <i>test outcomes</i> ), but also all possible variants.  This is actually a reinforcement of the advice from the previous article that <i>‚Äúit is important to depict not only the ideal case, but also the‚Äú inconvenient ‚Äùvariants that are associated with the boundary conditions.</i>  <i>... Such an approach shifts the program development resources from the debugging stage (when dealing with a bunch of implemented modules) to the design phase (when dealing with a blank canvas). "</i> In this case, the" convenient "and" inconvenient "options are not a direct reference to probability theory , we are talking about an appropriate way of thinking, which is remarkably trained by the mentioned section of mathematics.  This is just a tip, you can not listen to him, as well as to the majority of tips in this world. <br><br></p><h2>  TK analysis </h2><br><p>  Since the task in its current form, as stated above, is rather trite, consider its more complex modification. <br><br>  <i>It is required to transport a goat, cabbage, a dog and a wolf in a boat from one bank to another.</i>  <i>There are only two places in the boat (one for the peasant).</i>  <i>It is known that if you leave a wolf alone with a dog, they will have ‚Äúarmed neutrality‚Äù, but if a goat remains with them, the carnivorous wolf will leap up, the dog will rush to goat protection, in general, the three of them cannot be left.</i>  <i>How to transport?</i> <br><br></p><p>  I will say that the image of fig.  2 gives a consistent picture and does not give clarity, and this is its main drawback.  To depict the problem in the form of a table - solution number 1, the best solution of all possible, because now all the outcomes of events at a glance.  The row and column marked with the symbol 0 mean empty shore. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/hg/54/wf/hg54wfskbn07ksiexe5vwsaoepi.png"></div><br>  <i><font color="#888888">Figure 3. Object Image</font></i> <br><br><p>  This allows you to cover the whole picture, and connect the right hemisphere, which specializes in information processing, expressed not in words, but in symbols and images.  The main area of ‚Äã‚Äãspecialization of the right hemisphere is intuition.  Of course, one intuition is not enough, but for ‚Äútechies‚Äù, intuition does not dominate logic, but complements it.  With the right approach, the right hemisphere (creative, intuitive) will give food for thought to the left, which is responsible for logic and analyzes the facts obtained.  Information is processed by the left hemisphere sequentially in stages.  Since the whole cycle is dedicated to software automata, the following analogy fits into this channel: the right hemisphere can be compared with an <i>operational machine</i> that provides solutions, and the left hemisphere can be compared with the <i>control machine</i> that tests selected solutions, eliminates the invalid ones and gives the following task to the right one "Insight" gives the following thought.  That is, to depict the task is essentially important in order for the right hemisphere, covering the whole picture, to have that food for thought that suits him better, and this in turn will allow to generate more relevant trial solutions that will become food for thought to the left hemisphere. <br><br></p><p> Image pic.  3 is mathematically identical to the image of the problem, which is shown in Fig.  2, and it in turn is identical to the complete step-by-step process image with loading and unloading similar to that shown in Figure 1. <br><br></p><p>  With this image, the task is reduced to finding a path from the lower left to the upper right square, which are marked in blue.  However, not all combinations (intersections of columns and rows) are valid.  For example, a combination marked with a cross cannot exist, because in this situation the goat ends up on two banks at once. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/aq/ok/xvaqokxab-ndsk7gxl_qlq_ha44.png"></div><br>  <i><font color="#888888">Figure 4. Splitting characters</font></i> <br><br><p>  If we exclude all situations associated with bifurcation, the number of remaining options is significantly less. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/ns/zo/hknszoky_6lladruhaizvqbvulq.png"></div><br>  <i><font color="#888888">Figure 5. Elimination of splitting situations</font></i> <br><br><p>  The next step, dictated by logic, is to remove states like the one shown in fig.  6. The meaning of this is that one goat on the left bank and no one on the right means (if we exclude the fact that the wolf ran into the forest), that there are cabbage and a wolf in addition to the peasant in the boat.  But according to the conditions of the problem in the boat one place. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xq/gm/wi/xqgmwikgorjbhgpyf2gpptplmey.png"></div><br>  <i><font color="#888888">Figure 6. Boat overload</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ym/l_/k-/yml_k-jrlndou_wgkklpkhl93dy.png"></div><br>  <i><font color="#888888">Figure 7. Exclusion of situations with boat overload</font></i> <br><br><p>  There are variations of this task when the boat has two passenger seats.  Such varieties are identical to the variant being solved, just in this case there will be a smaller number of cells excluded by overloading. <br><br></p><p>  Next, you need to exclude all prohibited situations associated with eating some characters by others. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/g5/l1/82/g5l182ffna5wpqt7nymq51k4n3e.png"></div><br>  <i><font color="#888888">Figure 8. Exclusion of prohibited states</font></i> <br><br><p>  It is impossible to further reduce the number of cells, all remaining states are allowed.  But how to use this table? <br><br></p><p>  You can see that the movement along the vertical is associated with the manipulation of objects on the left bank, and the movement horizontally is associated with the manipulation of objects on the right bank.  For example, the movement shown by the arrow means unloading cabbage from the boat (on the left bank) and loading a wolf.  Goat on the right bank. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/jb/q0/xbjbq07o6ntxxanqvwctmkvacgk.png"></div><br>  <i><font color="#888888">Figure 9. Explanations for the manipulation of objects</font></i> <br><br><p>  At the same time, it is possible to move to any number of cells horizontally or vertically, but it is not allowed to move diagonally. <br><br></p><p>  This is the operating machine.  If you do not take the word ‚Äúmachine‚Äù literally, then OA is a method of processing, a scheme for manipulating data, objects, etc.  In this case, OA is a table from which all ‚Äúimpossible‚Äù and inadmissible states are removed, in which you can move vertically or horizontally.  Now it remains only to find the shortest path in this labyrinth, and this is exactly what the control machine will do. <br><br></p><p>  I‚Äôll express the idea that programmers often view programming languages ‚Äã‚Äãas an intermediate language into which you want to translate the original TZ written in human language before the compiler translates it into machine language.  For many problems, such an approach is indeed justified and natural, but only when manipulations with OA are described by an obvious sequence of actions, for example: <br>  <i>1. Read data from the Edit window.</i> <i><br></i>  <i>2. Convert text to function coefficients.</i> <i><br></i>  <i>3. Plot the function on the Chart.</i> <br><br></p><p>  However, in this case, an attempt to find a solution to the original TK, literally embodying the conditions of the problem, would lead to approximately the following sequence of actions: <br><br>  <i>1. Get another character,</i> <i><br></i>  <i>2. To transport, to the other side,</i> <i><br></i>  <i>3. If you can't leave him there, pick up another character and bring him back.</i>  <i>go to step 1.</i> <br><br></p><p>  Despite the fact that even a child armed with a pencil can perform the task of finding a way in the labyrinth shown in Fig. 8, if solved using the above method, a parallelization of the problem can occur at any stage, since you can take one character or another case will be its own scenario of subsequent events. Such an approach is really fraught with recursion with increasing computational complexity. <br><br></p><p>  A few words about the computational complexity of such a solution.  For this task, a <i>full search</i> is not a traversal of the entire table, because a full search for this task implies not just going through all possible combinations, but <i>all possible sequences for all possible combinations</i> . <br><br><br></p><h2>  Control machine. </h2><br><p>  The resulting scheme assumes a simple algorithm for finding the path. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/s_/no/m3/s_nom3gnvy8vxnm-pz8ix1xeij0.png"></div><br>  <i><font color="#888888">Figure 10. Pathfinding algorithm in the maze without dead ends and cycles</font></i> <br><br><p>  However, presumably such an option is possible that a movement down or to the right is required <a href="http://www.smekalka.pp.ru/node/1349">(for example, when solving this task)</a> .  I will use my own advice "to consider inconvenient cases." <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/i6/sz/ihi6szui7xlx53chbpg3mwtqckm.png"></div><br>  <i><font color="#888888">Figure 11. An example, with the need for multidirectional movement when bypassing free cells</font></i> <br><br><p>  To eliminate the objection that the real lower right subdiagonal half should be completely excluded by the rule of duplication of characters, suppose that this is just a fragment from the upper half diagonal and there are no more free cells in the whole table. <br><br></p><p>  Such a maze is not circumvented if you move all the time up or to the right.  Obviously, a serious path finding algorithm is needed here.  Search for the path "in the forehead" for the version of fig.  11 will lead to enumeration of all possible paths, and although the number of combinations is relatively small, this is fraught with recursion again and has the same disadvantages as the full brute force option.  It is better to use the so-called.  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259B%25D0%25B8">wave algorithm or Lie algorithm.</a>  I will not describe it here, you can quickly glance at the link. <br><br></p><p>  Let us return, however, to the crossing, fig.  8. Wave propagation starts from the upper right corner, which is assigned the number 0. Note that a vertical search downwards for this column is not possible, since all cells in this column are excluded by the duplication rule.  The only possible movement is to the left.  There is only one ‚Äúwhite‚Äù cell in the row.  Mark it with the number 1. After this, cell 2 is marked in the same way. <br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/u6/ir/h9u6irp7n96w8t4gfrbojnvovyq.png"></div><br>  <i><font color="#888888">Figure 12. The first two steps of the wave calculation.</font></i> <br><br><p>  Next, an important point.  From the cell labeled 2, you can move to any of the cells horizontally in one move, all of them should be marked with the number 3. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vd/y7/n2/vdy7n2ie_gujwfdeqap6uvwt4so.png"></div><br>  <i><font color="#888888">Figure 13. Equivalent cells</font></i> <br><br><p>  The consistent application of this algorithm results in the following picture. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/qb/id/bgqbidydsogrxewcricm1dlrgha.png"></div><br>  <i><font color="#888888">Figure 14. The labeled field for finding the shortest path, and the path found (green cells)</font></i> <br><br><p>  The criterion for successful completion of the search - in the vertical with the index 0 there must be at least one "uncollected" cell, and it must be marked with a number.  The search for the path is conducted in the classical way: being in each cell, the next cell is searched (in our case, any in the same row or in the same column), which has a smaller number.  The cells that make up the path are highlighted in green. <br><br></p><p>  Using my own advice to consider uncomfortable options, I propose to consider an illustration <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/jn/xx/r4jnxxzfz7c1wlpn_rrxa--1exg.png"></div><br>  <i><font color="#888888">Figure 15. Ambiguity</font></i> <br><br><p>  In this case, it seems that when going around the maze in different ways, a contradiction arises.  However, in fact, there is no contradiction, it is enough to put the numbers only in the cells that are not yet occupied.  Then, bypassing the path that would lead to the value 4, the disputed cell already contains 3 and simply does not get into consideration. <br><br></p><p>  One of the options for constructing a wave involves the recursive nature of the algorithm for sorting points.  However, I offer another solution.  It allows you to do without recursion, and is based on the following rationalization. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/r6/qz/rlr6qzsjvaih9dudn3gnpp8wweq.png"></div><br>  <i><font color="#888888">Figure 16. Wave calculation step 1</font></i> <br><br><p>  The wave calculation will consist of alternating bypassing the rows and bypassing the columns.  The review starts from the top row, in which all cells are placed 1. Next, the row is re-run (‚Äúsearch‚Äù stage), and for each cell containing 1, a cycle is held down the column (‚Äúscan-fill‚Äù stage), during which all free cells are marked with a number 1 larger than the previous one. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/1e/rz/af/1erzaf4r9rz3wm61rvkchsbsun0.png"></div><br>  <i><font color="#888888">Figure 17. Wave calculation step 2</font></i> <br><br><p>  After that, the columns and rows are swapped, and now the columns containing the number 2 are <i>searched</i> , and the corresponding row is <i>scanned</i> from each column. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/iy/p7/tpiyp7azpu7j7ubgmy-zeyoxova.png"></div><br>  <i><font color="#888888">Figure 18. Wave calculation step 3</font></i> <br><br><p>  This operation is repeated until at least one cell in column 0 is marked. Given that there may not be a complete traversal path, the traversal is stopped if at the next traversal (search + scanfill) none are found new cell. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/6p/q2/3t/6pq23tltw1m6rtxoxnobnvk4ija.png"></div><br>  <i><font color="#888888">Figure 19. The result of building a wave</font></i> <br><br><p>  With such a detour, each line is traversed 2 times - during the <i>search</i> and during the <i>scan-fill</i> .  More precisely, since after scanning horizontally, scanning begins vertically, it would be better to list in a different order: during the <i>scan-fill</i> and during the subsequent <i>search</i> . <br><br></p><p>  But since at the time of each iteration it is not known which line contains a number, for example 3, and which does not contain it, to search for each line you need to look through all the lines, and this leads to the fact that each line is viewed once during the search for number 3 and more many times when searching for the remaining numbers (which are not there). <br><br></p><p>  I draw your attention that the ‚Äúsearch + scan-fill‚Äù iterations alternate for rows and columns, so during the search in rows, even ones will not be searched for, and vice versa.  In this case, the number of views of each cell is reduced by half. <br><br></p><p>  But pay attention to one characteristic thing.  By the fill algorithm, each line will have the form. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/m2/no/7lm2nons8tqbspu0oftsqskod8w.png"></div><br>  <i><font color="#888888">Figure 20. Typical row contents</font></i> <br><br><p>  I pay attention that the algorithm is not recursive.  If it were recursive, it would mean that one path is explored to a maximum depth, after which the algorithm goes back (one position at a time, but it may turn out that it goes to the very beginning), after which the next path is explored.  As a result of this kind of crawling, adding numbers to the table does not go in ascending order, but lower numbers can be added to a field that is already full of higher ones. <br><br></p><p>  When traversing the table in the manner described above, each row will contain a number <br>  <b>N-1</b> obtained by scanning-filling the previous iteration, and the number <b>N</b> that will be entered into it when scanning-filling the current iteration.  Moreover, the <b>N-1</b> numbers may be several, due to the fact that each iteration implies scanning-filling a number of lines, but there will not be a single number in the line other than <b>N-1</b> , <b>N.</b> <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/bn/54/cfbn540-wzho7ecdcssc-j1s92e.png"></div><br>  <i><font color="#888888">Figure 21. Illustration of the features for filling rows and columns</font></i> <br><br><p>  Moreover, in the case of fig.  20, the number 4 refers not to the row, but to the column, so if we consider only the numbers related to the row, it turns out that the row contains only numbers 5. The situation is similar with the columns. <br><br></p><p>  This is more than just observation; this is the basis for further development.  Illustrated rice.  The 16-19 algorithm implies a preview of the cells of each row in order to determine whether it contains the required number (for example, for Fig. 21 we take the search for the number 7).  Given that the lines contain a pair of numbers <b>N-1</b> and <b>N,</b> you can stop viewing the first line by reaching the cell with the unit.  The second line can also not be considered to the end, having met the number 5, but it will have to be scrolled almost to the end.  At the same time, since, as I have shown, only one number is associated with each filled row and one number with each column, the task can be interpreted as follows.  In addition to the table, a pair of arrays is created - one for the rows and one for the columns. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/xo/0k/qjxo0kywb3vqbxtz7e73zbh825w.png"></div><br>  <i><font color="#888888">Figure 22. OA wave construction</font></i> <br><br><p> Since you can only move horizontally from the upper right blue square (the entire vertical line is excluded by the duplication rule), the search starts from the line marked by the <b><code>NH</code></b> arrow.  In cell <b><code>H_header[0]</code></b> 1 is entered during initialization.  The following is the procedure that can be described by the state diagram shown in Figure.  23 <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/vc/hp/qevchpxlqusq3qc6ukcbtpweax8.png"></div><br>  <i><font color="#888888">Figure 23. Wave construction algorithm</font></i> <br><br><p>  Why do I think that the state diagram is an alternative, more convenient form of writing software algorithms?  It is a convenient tool for ‚Äúshorthanding‚Äù of thoughts, as they come to mind, because it is built from identical blocks that can be connected with any imaginable lines. <br><br></p><p>  How to create an algorithm according to this diagram?  In general, elementary, even simpler and more mechanistic than if I described everything in words.  Those actions that are marked as <i>iterate ...</i> correspond to the cycles, the remaining arrows are conditions, the arrows on the left, labeled <b>1</b> and <b>2</b> imply a <b><code>while(1)</code></b> . <br><br></p><div class="spoiler">  <b class="spoiler_title">Such code turned out</b> <div class="spoiler_text"><pre> <code class="cpp hljs">uint tCalculator::Make_wave() { u1x N = <span class="hljs-number"><span class="hljs-number">1</span></span>; Horizontals_header[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//////////////////////////// //   bool Found = false; for(u1x Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) { if(Horizontals_header[Horizontal_N] == N) { //////////////////////////// //    for(u1x Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) { if( (Cases_table[Horizontal_N * Line_size + Vertical_N] == 0) &amp;&amp; (Verticals_header[Vertical_N] == 0 ) ) { Found = true; Verticals_header[Vertical_N] = N + 1; if( Vertical_N == 0 ) return(N+1); } }//for(u1x Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) }//if(Horizontals_header[Horizontal_N] == N) }//for(u1x Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) if(!Found) return(0); Found = false; N++; //////////////////////////// //   for(u1x Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) { if(Verticals_header[Vertical_N] == N) { //////////////////////////// //    for(u1x Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) { if( (Cases_table[Horizontal_N * Line_size + Vertical_N] == 0) &amp;&amp; (Horizontals_header[Horizontal_N] == 0 ) ) { Found = true; Horizontals_header[Horizontal_N] = N + 1; if( Horizontal_N == Line_size - 1 ) return(N+1); } }//for(u1x Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) }//if(Verticals_header[Vertical_N] == N) }//for(u1x Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) if(!Found) return(0); N++; }//while(1) }//uint tCalculator::Make_wave()</span></span></code> </pre> <br></div></div><br><br><p>  The result of the algorithm is shown in Fig. 24. No notes are entered in the table itself.  In addition, for convenience, the Make_wave method returns a number starting from which the trace is being built, in this case 10. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/ph/y0/nephy0iockcgtz-kalymhcb-e3y.png"></div><br>  <i><font color="#888888">Figure 24. Built wave</font></i> <br><br><p>  After the wave is received, the line is under construction.  The algorithm for constructing the route can be described by a state diagram. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/pr/-q/bxpr-qtlome9zjv9dlw_prc-34k.png"></div><br>  <i><font color="#888888">Figure 25. Algorithm for building a route</font></i> <br><br><div class="spoiler">  <b class="spoiler_title">Such a diagram is just as elementary embodied in the code.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// void tCalculator::Make_trace(u1x N) { u1x Horizontal_N = 0; u1x Vertical_N = 0; while(1) { ////////////////////////////// //   Horizontals_header //    N          N--; for(Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) { if((Horizontals_header[Horizontal_N] == N)&amp;&amp;(Cases_table[Horizontal_N * Line_size + Vertical_N] == 0) ) { Cases_table[Horizontal_N * Line_size + Vertical_N] = N; break; } }//for(u1x Horizontal_N = 0; Horizontal_N &lt; Line_size; Horizontal_N++) N--; if(!N) return; ////////////////////////////// //   Verticals_header for(Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) { if( ( Verticals_header[Vertical_N] == N) &amp;&amp; (Cases_table[Horizontal_N * Line_size + Vertical_N] == 0) ) { Cases_table[Horizontal_N * Line_size + Vertical_N] = N; break; } }//for(Vertical_N = 0; Vertical_N &lt; Line_size; Vertical_N++) }//while(1) }//void tCalculator::Make_trace()</span></span></code> </pre> <br></div></div><br><br><p>  The project itself can be seen on <a href="https://bitbucket.org/dashingresearches/wolf_goat_cabbage/src">bitbucket.</a> <br>  The Table_calculator module contains the description of the tCalculator class, which carries all the functionality. <br><br>  <a href="">Program</a> <br><br></p><p>  A few words about ways to further improve the described program.  Consider the task: <br><br></p><blockquote>  You need to transport a goat, cabbage, a dog and two wolves in a boat from one bank to another.  In the boat, only three places (one for the peasant).  It is known that a wolf should not be left unattended with a goat and with a dog, a dog should not be left with a goat and, of course, the goat is not indifferent to cabbage.  How to transport? </blockquote><br><br><p>  In this form, to find a solution to the problem with the help of the program described, one of the wolves will have to be designated by the letter w and the other by W, because the parser character ignores duplicate names.  Accordingly, the prohibition rules must be set as wd, Wd. <br><br></p><p>  It is relatively easy to make it possible to solve a problem for an arbitrary number of participants of the same name, listing them in the form 2w, 3g, 5c and setting the ban rules in a simple form wd for any wolf, or g5c (prohibition to leave the goat alone with 5 bags of cabbage, and it will eat at once and die), but the difference will be in the details, but the essence of the decision will remain the same.  Therefore, I will not do it yet. <br><br></p><p>  In conclusion, I will add that earlier I showed the process of practical decomposition as. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/_j/to/ws_jtoatxi8sxegvbdazmx4ckww.png"></div><br>  <i><font color="#888888">Figure 26. Multi-level decomposition of automata</font></i> <br><br><p>  The variant considered today is also an example of decomposition, but another kind is the conveyor of operating machines. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/r7/mb/k0r7mbazlxiucinvlslmjhb0ah8.png"></div><br>  <i><font color="#888888">Figure 27. Machine conveyor decomposition</font></i> <br><br><p>  Since the choice of OA is so important, I will give more examples of solving problems by automaton design.  That's all for today. </p></div><p>Source: <a href="https://habr.com/ru/post/343736/">https://habr.com/ru/post/343736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343724/index.html">PLATO: the history of the world's first e-learning system</a></li>
<li><a href="../343726/index.html">Hinton's capsule nets</a></li>
<li><a href="../343728/index.html">Unity game, open source</a></li>
<li><a href="../343730/index.html">We write DSL in Koltin</a></li>
<li><a href="../343732/index.html">Corporate "stuffing" for small networks</a></li>
<li><a href="../343738/index.html">We understand what was discovered there in the problem of queens</a></li>
<li><a href="../343740/index.html">Security Week 48: Root Access for Diligence, Miner Consultant and Trial Macro Malware</a></li>
<li><a href="../343744/index.html">We integrate smartcontract into the web application on Nodejs</a></li>
<li><a href="../343748/index.html">Garbage collection and lifetime of objects</a></li>
<li><a href="../343750/index.html">Release of the second version of the Nodejs plugin for Sublime Text</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>