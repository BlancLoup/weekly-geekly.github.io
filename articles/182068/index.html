<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wireless Arduino Network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The micro controller on the Arduino platform is an excellent platform for hobby projects of varying degrees of complexity and utility. I will not argu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wireless Arduino Network</h1><div class="post__text post__text-html js-mediator-article">  The micro controller on the Arduino platform is an excellent platform for hobby projects of varying degrees of complexity and utility.  I will not argue that the Arduino platform is the best choice for professional solutions (I would rather agree with the opposite), but for my amateur "crafts" in the field of home automation this is the best option.  Those.  the controller is good on its own, but if it also ceases to be ‚Äúon its own‚Äù, but will be able to ‚Äúcommunicate‚Äù with its own kind, while not overgrowing with additional wires, its usefulness and applicability can grow many times over.  So, let's start building our home SkyNet ... <br><a name="habracut"></a><br><h5>  Low cost radio modules </h5><br>  The basis of our network will take the budget radio modules operating at a frequency of 433.90MHz.  The cost of one such module is about $ 2.5, so the costs are small in order to organize communication with the outside world.  Of course, you can also use ready-made ethernet modules for communication and even <a href="http://smartliving.ru/Main.DlinkHub">create a</a> symbiosis with <a href="http://smartliving.ru/Main.DlinkHub">wireless routers</a> based on alternative firmware, but in many cases it is easier and cheaper to do everything on such radio modules. <br><br>  Transmitter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/967/d2f/00e967d2f5b946480e30390c0e20b4b2.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Receiver: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/655/6ab/25d/6556ab25dc020e65a40f728b10d83ccf.png"><br><br>  The quality of work and range of communication of these modules leaves much to be desired, and I would not believe the optimistic statements of sellers about the range of "&gt; 500m".  At best, 100 meters in open areas, well, much less in the presence of concrete partitions.  However, for an apartment or a small suburban area they will be enough.  You can use higher-quality (and, accordingly, more expensive) radio modules, so the article can be considered as an ideological concept applicable to many possible variants of implementation. <br><br>  <b>Important point:</b> in this manual I will not consider the option of creating a network with quality control of data transfer.  If the comparison with ethernet protocols can be considered appropriate, then we will not build a network for transmitting TCP packets, but rather, UDP. <br><br>  Each of the modules is connected to the controller in an elementary manner - the power is supplied via the Vcc / Gnd and the Data pin is connected to the free digital input on the micro controller.  To improve the quality of reception / transmission, it is recommended to additionally connect an antenna in the form of a wire of 10-15 cm in size. By the way, the communication distance also depends on the power supplied to the power supply module - if they are powered from 12V, the communication range and reliability of communication increases significantly. <br><br>  Receiver and transmitter connected to the Arduino UNO R3 micro controller: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/224/1ca/225/2241ca225f37f7a18d479763146bf11f.png"><br><br>  Thus, we made two devices: the first is a transmitter that will ‚Äúbroadcast‚Äù some information on the air;  the second is the receiver, which, accordingly, will air "listen".  Further, the matter is that the transmission and reception would be meaningful and useful for us. <br><br><h5>  VirtualWire Library </h5><br>  What is good about the Arduino platform is the presence of a huge number of ready-made libraries for working with various devices.  You can, of course, work with radio modules without any libraries, but then you need to develop your own communication protocol with checksums and other things.  Fortunately, there is a wonderful <a href="http://www.airspayce.com/mikem/arduino/">VirtualWire</a> library that supports data (and similar) radio modules.  With the help of this library it is very easy to organize the transmission and reception of small packets of information. <br><br>  Usage principle: on the transmitter we form a data set for sending (in the form of a string of characters or byte codes), and on the receiver, when we receive the "correct" data packet, we display them.  The easiest way to see this is with examples that come with the library itself. <br><br>  Transmitter code using VirtualWire (from library use examples): <br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre><code class="hljs pgsql">// transmitter.pde // // Simple example <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> how <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use VirtualWire <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> transmit messages // Implements a simplex (one-way) transmitter <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> an TX-C1 module #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;VirtualWire.h&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">9600</span></span>); // Debugging <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println("setup"); // Initialise the IO <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ISR vw_set_ptt_inverted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); // Required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> DR3100 vw_setup(<span class="hljs-number"><span class="hljs-number">2000</span></span>); // Bits per sec } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { const <span class="hljs-type"><span class="hljs-type">char</span></span> *msg = "hello"; digitalWrite(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); // Flash a light <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> transmitting vw_send((uint8_t *)msg, strlen(msg)); vw_wait_tx(); // Wait <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> the whole message <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> gone digitalWrite(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); delay(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> </div></div><br><br>  Receiver code: <br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// receiver.pde // // Simple example <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> how <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use VirtualWire <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> receive messages // Implements a simplex (one-way) receiver <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> an Rx-B1 module #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;VirtualWire.h&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">9600</span></span>); // Debugging <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println("setup"); // Initialise the IO <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ISR vw_set_ptt_inverted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); // Required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> DR3100 vw_setup(<span class="hljs-number"><span class="hljs-number">2000</span></span>); // Bits per sec vw_rx_start(); // <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> the receiver PLL running } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { uint8_t buf[VW_MAX_MESSAGE_LEN]; uint8_t buflen = VW_MAX_MESSAGE_LEN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vw_get_message(buf, &amp;buflen)) // Non-blocking { <span class="hljs-type"><span class="hljs-type">int</span></span> i; digitalWrite(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); // Flash a light <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> received good message // Message <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a good checksum received, dump it. <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("Got: "); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buflen; i++) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(buf[i], HEX); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(" "); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println(""); digitalWrite(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre></div></div><br><br><h5>  Communication protocol </h5><br>  The next step will be to reach a new level of abstraction, namely the development of a typical package structure, which all our devices will exchange.  This will allow in the future to connect to our network new equipment that can use signals from existing devices. <br><br>  I will give the data structure that seemed optimal to me with the available hardware capabilities.  So, here is a list of the main parameters that are broadcast with each package: <br><br>  <b>device_id</b> - identifier of the device that sent the packet.  Data type: unsigned int (length 2 bytes, value range from 0 to 65535) - as it seems to me, it is quite enough for a home network. <br><br>  <b>destination_id</b> is the device identifier to whom the packet is intended.  The data type is the same as device_id.  It is important to note that packets will still be received by all receivers, but already the program at the receiver itself can be used to ‚Äúcut off‚Äù packets that are not intended for the device.  It is also possible to accept as a rule that the value ‚Äú0‚Äù in this field means a broadcast packet. <br><br>  <b>packet_id</b> is the packet identifier.  Type the same unsigned int.  According to the plan, when sending, a packet is ‚Äúmarked‚Äù with a random number, which can be used to resend the same packet several times at some intervals - due to the unreliability of the protocol, this makes sense, but the receiving device must filter repeated commands in order not to execute one and the same action in response to the data packet. <br><br>  <b>command</b> - type of command.  Data type is byte (1 byte length, value range from 0 to 255).  This is the so-called ‚Äúteam class‚Äù, and in fact information that we are sending for data.  For example, we can create our own table of commands, relegating number 10 for the command to control the opening / closing, and the command for transmitting data on temperature number 15. The main thing is that we have a constant table.  And you can do more cunning - to look at possible commands in the same ZWave protocol and use <a href="http://wiki.micasaverde.com/index.php/ZWave_Command_Classes">their table</a> in <a href="http://wiki.micasaverde.com/index.php/ZWave_Command_Classes">them</a> so that everything is ‚Äúas in adults‚Äù and you do not have to worry about the safety of this valuable information. <br><br>  <b>data</b> - the actual data.  The data type is int (length is 2 bytes, value range is from -32,768 to 32,767. In this field we transmit data directly as a single number. Not enough? Well, it seemed to me sufficient. The temperature can be transferred (for example, it is multiplied by 100), status A motion sensor is easy, a command for a receiver with a relay is simpler. Text data cannot be sent to an external display, but such a goal was not set, and for my current and future devices, it‚Äôs enough for my eyes and a couple of dozen numbers to describe everything possible commands. <br><br>  As a result, we have a packet length of 9 bytes.  The short package is, in fact, very good - firstly, there is less chance that it will ‚Äúbreak‚Äù on the way;  secondly, less time for shipment, which reduces the likelihood of sharing of the air by several devices.  By the way, the latter circumstance will require "sparingly", i.e.  do not often send information.  In this case, it is desirable that when periodically sending readings the interval between sessions varied somewhat.  But all this should already be provided for in the integration of a specific device.  Be that as it may, I would not advise too much on the universality of the structure to the detriment of the minimum size of the packet of transmitted data. <br><br>  So, we have decided on the package structure, now we need to implement the exchange.  This is <a href="http://www.billporter.info/2011/05/30/easytransfer-arduino-library/">where</a> another useful library called <a href="http://www.billporter.info/2011/05/30/easytransfer-arduino-library/">EasyTransfer comes to our rescue</a> .  Actually, it works ‚Äúon top of‚Äù VirtualWire, allowing you to describe the data structure at the receiver / transmitter and to exchange not the set of byte codes, but the entire structure. <br><br>  In our case, the data structure will be as follows: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SEND_DATA_STRUCTURE</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> device_id; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> destination_id; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> packet_id; byte command; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; };</code> </pre><br><br>  It is extremely important that the structure on the receiver and the transmission be one-to-one, otherwise we will receive incorrect information.  Actually, it is therefore important to determine in advance the structure of the package. <br><br>  A few words about the device_id field.  It can be set manually for each device, but I went along a simpler path - when I first start, I generate these values ‚Äã‚Äãrandomly and write them to an energy-independent EEPROM.  The probability that different devices get the same identifiers from the range of values ‚Äã‚Äãof the unsigned int field is extremely small and, again, in my case, the risk is quite justified. <br><br>  Let's apply the gained knowledge to write an example implementation on our exchange protocol.  The transmitter will send the value of the internal counter, and the receiver will display it. <br><br>  Transmitter Code: <br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;VirtualWire.h&gt; #include &lt;EasyTransferVirtualWire.h&gt; #include &lt;EEPROM.h&gt; //       -  const int led_pin = <span class="hljs-number"><span class="hljs-number">13</span></span>; const int transmit_pin = <span class="hljs-number"><span class="hljs-number">2</span></span>; unsigned int unique_device_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; unsigned int count = <span class="hljs-number"><span class="hljs-number">1</span></span>; //<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> object EasyTransferVirtualWire ET; struct SEND_DATA_STRUCTURE{ //  .          // ,      <span class="hljs-number"><span class="hljs-number">26</span></span>  ( VirtualWire) unsigned int device_id; unsigned int destination_id; unsigned int packet_id; <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> command; int data; }; //     SEND_DATA_STRUCTURE mydata; //       unsigned int  EEPROM void EEPROMWriteInt(int p_address, unsigned int p_value) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address, lowByte); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>, highByte); } unsigned int EEPROMReadInt(int p_address) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((lowByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) + ((highByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF00</span></span>); } void setup() { //   pinMode(led_pin, OUTPUT); ET.begin(details(mydata)); vw_set_tx_pin(transmit_pin); // ,    data-  vw_setup(<span class="hljs-number"><span class="hljs-number">2000</span></span>); //  Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); randomSeed(analogRead(<span class="hljs-number"><span class="hljs-number">0</span></span>)); // / Device ID Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Getting Device ID... "</span></span>); unique_device_id=EEPROMReadInt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unique_device_id&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span> || unique_device_id&gt;<span class="hljs-number"><span class="hljs-number">60000</span></span>) { Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"N/A, updating... "</span></span>); unique_device_id=<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">60000</span></span>); EEPROMWriteInt(<span class="hljs-number"><span class="hljs-number">0</span></span>, unique_device_id); } Serial.println(unique_device_id); } void loop() { mydata.device_id = unique_device_id; mydata.destination_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; mydata.packet_id = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">65535</span></span>); mydata.command = <span class="hljs-number"><span class="hljs-number">0</span></span>; mydata.data = count; digitalWrite(led_pin, HIGH); //       Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Transmitting packet "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.packet_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" device id "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.device_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" data: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.data); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" ... "</span></span>); ET.sendData(); //   digitalWrite(led_pin, LOW); Serial.println(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); count = count + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre></div></div><br><br>  In our case, the receiver will simply listen to the broadcast and show all commands sent by the transmitters.  For each device that accepts commands, the code will need to be modified, adding, if necessary, filters by destination device and command class. <br><br>  Receiver code: <br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;VirtualWire.h&gt; #include &lt;EasyTransferVirtualWire.h&gt; #include &lt;EEPROM.h&gt; const int led_pin = <span class="hljs-number"><span class="hljs-number">13</span></span>; const int receive_pin = <span class="hljs-number"><span class="hljs-number">2</span></span>; unsigned int unique_device_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; //<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> object EasyTransferVirtualWire ET; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">120</span></span>]; struct SEND_DATA_STRUCTURE{ //  .          // ,      <span class="hljs-number"><span class="hljs-number">26</span></span>  ( VirtualWire) unsigned int device_id; unsigned int destination_id; unsigned int packet_id; <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> command; int data; }; //     SEND_DATA_STRUCTURE mydata; //       unsigned int  EEPROM void EEPROMWriteInt(int p_address, unsigned int p_value) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address, lowByte); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>, highByte); } unsigned int EEPROMReadInt(int p_address) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((lowByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) + ((highByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF00</span></span>); } void setup() { pinMode(led_pin, OUTPUT); Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); // Debugging only ET.begin(details(mydata)); // Initialise the IO <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ISR vw_set_rx_pin(receive_pin); vw_setup(<span class="hljs-number"><span class="hljs-number">2000</span></span>); //   vw_rx_start(); //    // Device ID Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Getting Device ID... "</span></span>); unique_device_id=EEPROMReadInt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unique_device_id&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span> || unique_device_id&gt;<span class="hljs-number"><span class="hljs-number">60000</span></span>) { Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"N/A, updating... "</span></span>); unique_device_id=<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">60000</span></span>); EEPROMWriteInt(<span class="hljs-number"><span class="hljs-number">0</span></span>, unique_device_id); } Serial.println(unique_device_id); } void loop() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ET.receiveData()) //   ,  { digitalWrite(led_pin, HIGH); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Got: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Device ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.device_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Destination ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.destination_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Packet ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.packet_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Command: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.command); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Data: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.data); Serial.println(); digitalWrite(led_pin, LOW); } }</code> </pre></div></div><br><br>  Hooray!  Our Skynet is on the air!  You can already do a lot of useful things, but there is no limit to perfection ... Moving on <br><br><h5>  Integration into MajorDoMo </h5><br>  The next stage is the embedding of our entire ‚Äúfarm‚Äù into a more complex management environment of the Smart Home.  In this case, the <a href="http://smartliving.ru/Main/HomePage">MajorDoMo</a> platform is <a href="http://smartliving.ru/Main/HomePage">used</a> , but integration with any other system can be organized in the same way. <br><br>  Actually, the principle of integration in the organization of the "bridge" between the computer and our radio network.  Below I give an example of the creation of a ‚Äúlistening bridge‚Äù, the task of which is to ‚Äúlisten‚Äù to the broadcast and broadcast all received packets to the MajorDoMo environment.  The latter, in turn, will already be engaged in their processing - to react with some actions or just to display the received data in various interfaces. <br><br>  In the script control panel, create a message receiving script called <b>easyRF</b> . <br>  Script code: <br><br><pre> <code class="php hljs">$device_id=$params[<span class="hljs-string"><span class="hljs-string">'did'</span></span>]; $destination_id=$params[<span class="hljs-string"><span class="hljs-string">'dest'</span></span>]; $packet_id=$params[<span class="hljs-string"><span class="hljs-string">'pid'</span></span>]; $command_id=$params[<span class="hljs-string"><span class="hljs-string">'c'</span></span>]; $data=$params[<span class="hljs-string"><span class="hljs-string">'d'</span></span>]; say(<span class="hljs-string"><span class="hljs-string">"  $device_id   $packet_id   $command_id   $data"</span></span>);</code> </pre><br><br>  After adding this code, you can immediately call via http-link: <br> <code><a href="http://192.168.0.17/objects/%3Fscript%3DeasyRF"></a> 192.168.0.17/objects/?script=easyRF <br></code> <br>  (instead of 192.168.0.17 address of your server) <br><br>  The next step is to transfer received data from the Arduino to the MajorDoMo system.  There are options - you can add an ethernet module to the Arduino receiver and immediately send http requests over the network, or you can connect a micro controller via USB and use the <a href="http://smartliving.ru/Main/ArduinoDirect">ArduinoGW</a> program, which ‚Äúlistens‚Äù to the COM port even if there is a key sequence corresponding to sending http -query itself redirects it to the network. <br><br>  We use the second method, since  It does not require additional equipment.  In this case, the receiver code will look like this: <br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;VirtualWire.h&gt; #include &lt;EasyTransferVirtualWire.h&gt; #include &lt;EEPROM.h&gt; const int led_pin = <span class="hljs-number"><span class="hljs-number">13</span></span>; const int receive_pin = <span class="hljs-number"><span class="hljs-number">2</span></span>; unsigned int unique_device_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; //<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> object EasyTransferVirtualWire ET; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">120</span></span>]; struct SEND_DATA_STRUCTURE{ //  .          // ,      <span class="hljs-number"><span class="hljs-number">26</span></span>  ( VirtualWire) unsigned int device_id; unsigned int destination_id; unsigned int packet_id; <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> command; int data; }; //     SEND_DATA_STRUCTURE mydata; //       unsigned int  EEPROM void EEPROMWriteInt(int p_address, unsigned int p_value) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = ((p_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address, lowByte); EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>, highByte); } unsigned int EEPROMReadInt(int p_address) { <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> lowByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> highByte = EEPROM.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(p_address + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((lowByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) + ((highByte &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF00</span></span>); } void setup() { pinMode(led_pin, OUTPUT); Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); // Debugging only ET.begin(details(mydata)); // Initialise the IO <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ISR vw_set_rx_pin(receive_pin); vw_setup(<span class="hljs-number"><span class="hljs-number">2000</span></span>); // Bits per sec vw_rx_start(); // Start the receiver PLL <span class="hljs-built_in"><span class="hljs-built_in">running</span></span> // Device ID Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Getting Device ID... "</span></span>); unique_device_id=EEPROMReadInt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unique_device_id&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span> || unique_device_id&gt;<span class="hljs-number"><span class="hljs-number">60000</span></span>) { Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"N/A, updating... "</span></span>); unique_device_id=<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">60000</span></span>); EEPROMWriteInt(<span class="hljs-number"><span class="hljs-number">0</span></span>, unique_device_id); } Serial.println(unique_device_id); } void loop() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ET.receiveData()) //   ,  { digitalWrite(led_pin, HIGH); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Got: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Device ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.device_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Destination ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.destination_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Packet ID: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.packet_id); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Command: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.command); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" Data: "</span></span>); Serial.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mydata.data); Serial.println(); digitalWrite(led_pin, LOW); sprintf(buf, <span class="hljs-string"><span class="hljs-string">"GET /objects/?script=easyRF&amp;did=%u&amp;dest=%u&amp;pid=%u&amp;c=%u&amp;d=%i HTTP/1.0"</span></span>, (int)mydata.device_id, (int)mydata.destination_id, (int)mydata.packet_id, (int)mydata.command, (int)mydata.data); Serial.println(buf); //      HTTP- (     ethernet-shield- Serial.println(); } }</code> </pre></div></div><br><br>  That's all!  We create devices, add radio modules and set up the interaction of everything and everyone. <br><br><h5>  Further development </h5><br>  As I wrote above, this article can be considered as a concept of an idea, which can be developed in many directions, and without even changing the initial structure of the package. <br><br>  I will cite a few thoughts that came to mind: <br><br>  * Creating nodes of "reliable" exchange (using the same device and the receiver and transmitter, and organizing the exchange of packages with the control of delivery, to control the delivery of a separate class of commands) <br>  * We use more expensive and reliable radio modules <br>  * We implement the procedure of ‚Äúbinding‚Äù of one device to another without the need to change the code (transfer to the mode of ‚Äúbinding‚Äù of two devices and write to the EEPROM of a paired device) <br><br>  This is all.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/182068/">https://habr.com/ru/post/182068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182056/index.html">From 4 mayors of cities in Denmark, Universal Music requires a payment of 42 thousand dollars for a musical parody of Gangnam Style</a></li>
<li><a href="../182058/index.html">Analysis of the tasks of the competition to analyze the security of the network infrastructure NetHack</a></li>
<li><a href="../182060/index.html">Eidos Montreal showed teaser Deus Ex: The Fall</a></li>
<li><a href="../182062/index.html">IBM uses Roomba robots to control temperature in data centers</a></li>
<li><a href="../182064/index.html">Downshifting by Microsoft</a></li>
<li><a href="../182070/index.html">Threat rating in May 2013: increased activity of Zeus modifications</a></li>
<li><a href="../182072/index.html">VPN for regular users. Real need or useless option?</a></li>
<li><a href="../182078/index.html">Organizational principles in website design</a></li>
<li><a href="../182080/index.html">Siloviki propose to prohibit software that hides the user on the web</a></li>
<li><a href="../182082/index.html">Yota network jammers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>