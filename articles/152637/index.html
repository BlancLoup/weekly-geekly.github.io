<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>First steps with Chromium Embedded Framework and .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chromium Embedded Framework (CEF) is an open source project created in 2008 as a Web browser control operating on Google‚Äôs Chromium. 
 At the moment, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>First steps with Chromium Embedded Framework and .NET</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://code.google.com/p/chromiumembedded/">Chromium Embedded Framework (CEF)</a> is an open source project created in 2008 as a Web browser control operating on Google‚Äôs Chromium. <br>  At the moment, it is quite a powerful tool for developing desktop applications, with a list of solutions that use this control can be found <a href="http://en.wikipedia.org/wiki/Chromium_Embedded_Framework">here</a> .  But suffice it to say that well-known products like Evernote and Steam use it. <br><br>  <b>So what does this framework do?</b> <br><a name="habracut"></a><br><ul><li>  CEF allows you to create your own protocol handlers, thus implementing your ‚Äúprivate‚Äù encryption algorithm (yes <br>  yes, unfortunate users of old Internet Explorer and corporate web solutions, down with ActiveX).  This can also be used to load data from static program resources. </li><li>  CEF allows you to make a wrapper on native functions in the object space of the Javascript virtual machine.  Resource-intensive processing of large data arrays can be shifted to more stringent and faster programming languages. </li><li>  CEF allows you to handle navigation events, file downloads, and so on. </li></ul><br>  In general, everything that allows you to make your own browser like google chrome (just why?).  But we will need it in order to create our own applications with HTML5 / CSS3 interface and hardware accelerated graphics. <br><br><h4>  And now about the sad </h4><br>  The <b>chromiumembedded</b> library, referenced at the beginning of the article, is implemented in C ++.  But what if your solution is already working on another, controlled programming language?  Especially for us there are wrappers for Java, Delphi, Python and .NET.  On the use of the library CefSharp for .NET and will be discussed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Meet CefSharp </h5><br>  <a href="https://github.com/chillitom/CefSharp">CefSharp</a> is a wrapper library for chromiumembedded.  However, its functionality is <i>somewhat inferior</i> in its capabilities. <br>  What is available to us: <br><ol><li>  Creating an unlimited number of WebView class components </li><li>  Event handling on page loading, navigation events </li><li>  Own protocol handlers. </li><li>  Implementing js code at page time </li><li>  Creating global [native code] objects with static methods </li></ol><br>  What is missing: <br><ol><li>  Normal event model.  No, seriously, it does not look like a .NET library: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Window</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Url, CefSharp.BrowserSettings settings = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... _Browser = new WebView(Url, settings ?? new CefSharp.BrowserSettings { DefaultEncoding = "UTF-8" }); _Browser.PropertyChanged += _Browser_PropertyChanged; // ... } void _Browser_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) { if (e.PropertyName == "IsBrowserInitialized" &amp;&amp; !isInitialized) doSomeStuff(); //   }</span></span></code> </pre> <br><br></li><li>  Implementing various objects for different instances of the WebView class.  You will have to accept the fact that anyone can call absolutely any method you have registered. </li><li>  Type conversion from CLR to JS and back.  The crutch for a visual solution to this problem will be discussed further. </li><li>  You cannot associate the called method with a specific form where the WebView is located. </li><li>  Not really a minus, but the environment for compiling CefSharp should be Visual Studio 2008. </li></ol><br>  As a reward, you can note that you can start working with the library fairly quickly (provided that you have a compiled version), as well as the fact that the bar for understanding HTML + JS solutions is lower than that of WPF, and for those afraid to go to the months-long study of complex technology, you can simply use your favorite HTML. <br><br><h4>  First meeting </h4><br>  The three main things that are needed for work are the local protocol handler, the global object and the object that we will have to manage the framework. <br><br><h5>  Local Protocol Handler </h5><br>  A pair of classes is implemented: a factory (implements the CefSharp.ISchemeHandlerFactory interface) and, in fact, the handler itself (implementing the CefSharp.ISchemeHandler interface). <br>  The first is clear: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LocalSchemeHandlerFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ISchemeHandlerFactory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ISchemeHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocalSchemeHandler(); } }</code> </pre><br>  The second will not be more difficult: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LocalSchemeHandler</span></span> : <span class="hljs-title"><span class="hljs-title">ISchemeHandler</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ,      ,      public bool ProcessRequest(IRequest request, ref string mimeType, ref Stream stream) { //  IRequest     //  mimeType    MIME- .  ,  Chromium    text/javascript  text/plain  image/png //  Stream   ,   - MemoryStream ,           return true; //     .  false } }</span></span></code> </pre><br>  In order to connect the js-file of the application, you can use the GetStream method or GetString method of the ResourceManager class.  Of the benefits - the source code of your application will be located inside the .exe or .dll file.  Of the minuses - when changing the js-code, you will have to re-compile the application each time. <br><br><h5>  Bridge object between .NET and JS </h5><br>  It is even simpler with it - it is a regular object containing methods and fields.  One minus - for the whole project you will have one copy of each such class. <br><br><h5>  CEF Initialization </h5><br>  I decided to make the class a successor to ApplicationContext.  For windowing, WinForms runs faster, and WPF is not necessary to pull <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ApplicationController</span></span> : <span class="hljs-title"><span class="hljs-title">ApplicationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; registeredObjects; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CefSharp.Settings settings = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { registeredObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> resources = Path.Combine(Directory.GetCurrentDirectory(), <span class="hljs-string"><span class="hljs-string">"cache"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Directory.Exists(resources)) Directory.CreateDirectory(resources); CefSharp.CEF.Initialize(settings ?? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CefSharp.Settings() { Locale = <span class="hljs-string"><span class="hljs-string">"ru"</span></span>, CachePath = resources }); CefSharp.CEF.RegisterScheme(<span class="hljs-string"><span class="hljs-string">"local"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocalSchemeHandlerFactory()); registerJsObject(<span class="hljs-string"><span class="hljs-string">"Form"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WindowObject()); <span class="hljs-comment"><span class="hljs-comment">//     -. } public void registerJsObject(string Name, object Object) { if (!registeredObjects.ContainsKey(Name)) { registeredObjects.Add(Name, Object); CefSharp.CEF.RegisterJsObject(Name, Object); } } }</span></span></code> </pre><br><br>  On this, in fact, everything.  You can create a form, add a WebView component to it, and work as you please. <br>  <i>If you have read this far, then you are a patient person and I am grateful to you.</i> <br><br><h4>  But this is not enough for us </h4><br>  As I noted earlier, there are some drawbacks to CefSharp.  For example, you cannot associate a WebView component with a form that contains it.  For this, a kind of <b>cruel crutch</b> was born, which I will present to the public. <br>  In order not to litter the article with code patches, I will give some excerpts from the listing. <br><br><h5>  1 New Window class inherited from Form </h5><br><ul><li>  It contains a subclass of FormEnumerator, which assigns each window its own unique string identifier and stores references to all Window objects.  You can get a form using the getWindowById method. </li><li>  Static JSInvoke method that receives a call from the browser environment and calls the form function </li><li>  CSInvoke method that calls the JS environment method from .NET </li><li>  Private method getFormRefrection, which creates a wrapper for the CLR form methods.  The string is formed by StringBuilder based on the reflection data.  It looks like this: </li></ul><br><br><h5>  2 Common Call Bridge Object </h5><br>  It performs a call operation from JS to C #: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WindowObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> JSONData</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> x = JSON.JsonDecode(JSONData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ArrayList) { ArrayList y = (ArrayList)x; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[y.Count]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args.Length; i++) args[i] = y[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JScripter.CreateString(Window.JSInvoke(Id, Method, args)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JScripter.CreateString(Window.JSInvoke(Id, Method, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { x })); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Id</span></span></span><span class="hljs-function">)</span></span> { Window.FormEnumerator.getWindow(Id).Close(); } }</code> </pre><br>  The attentive reader will notice something amiss: instead of normal objects, CefSharp allows you to exchange only simple types, such as int, double, bool, string.  But in real life it is usually just the opposite.  Therefore, this crutch uses data packing / unpacking in JSON.  The solution is not ideal, a lot of time is wasted, but these are the limitations of the library. <br>  Since DataContractJsonSerializer only works with certain types, it is problematic to use it.  Therefore, a 100% managed parser was used in the project.  Also a crutch. <br><br>  The code can be found <a href="">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/152637/">https://habr.com/ru/post/152637/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152621/index.html">Connecting "self-made" devices via bluetooth with iOS</a></li>
<li><a href="../152625/index.html">Quest to configure an alternative port ADFS 2.0</a></li>
<li><a href="../152629/index.html">User Experience Versus Interface Innovations</a></li>
<li><a href="../152631/index.html">How to choose an SSL certificate</a></li>
<li><a href="../152635/index.html">Briefly about duplicating Windows 8 Tiles</a></li>
<li><a href="../152639/index.html">Automatic download of movies</a></li>
<li><a href="../152641/index.html">Code Venture: Man-hours Investment</a></li>
<li><a href="../152643/index.html">Pillow that allows you to fall asleep anywhere and not notice others</a></li>
<li><a href="../152645/index.html">Case study: Diary.ru and Windows Azure</a></li>
<li><a href="../152647/index.html">Organization of the Internet broadcast of the event by budgetary funds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>