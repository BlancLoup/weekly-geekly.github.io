<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 6: Language Extension: User Defined Operators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents: 
 Part 1: Introduction and Lexical Analysis 
 Part 2: Implementing Parser and AST 
 Part 3: LLVM IR Code Generation 
 Part 4: Addin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 6: Language Extension: User Defined Operators</h1><div class="post__text post__text-html js-mediator-article">  Table of contents: <br>  <a href="https://habrahabr.ru/post/119850/">Part 1: Introduction and Lexical Analysis</a> <br>  <a href="https://habrahabr.ru/post/120005/">Part 2: Implementing Parser and AST</a> <br>  <a href="https://habrahabr.ru/post/120424/">Part 3: LLVM IR Code Generation</a> <br>  <a href="https://habrahabr.ru/post/120516/">Part 4: Adding JIT and Optimizer Support</a> <br>  <a href="https://habrahabr.ru/post/120881/">Part 5: Language Expansion: Control Flow</a> <br>  <b>Part 6: Language Extension: User Defined Operators</b> <br>  <a href="https://habrahabr.ru/post/336468/">Part 7: Language Expansion: Variable Variables</a> <br>  <a href="https://habrahabr.ru/post/336876/">Part 8: Compile to Object Code</a> <br>  <a href="https://habrahabr.ru/post/336980/">Part 9: Add Debugging Information</a> <br>  <a href="https://habrahabr.ru/post/337240/">Part 10: Conclusion and other goodies LLVM</a> <br><br><img src="https://habrastorage.org/web/6e5/879/803/6e58798030874db09d00f2c502b3b104.png"><br><br><h3>  6.1.  Introduction </h3><br>  Welcome to chapter 6 of the guide ‚ÄúCreating a programming language using LLVM‚Äù.  At the moment we have a fully functional language, although minimal, but nonetheless useful.  But there is still one problem.  There are few useful operators in our language (no, for example, division, logical negation, and even comparisons, with the exception of the ‚Äúless‚Äù comparison operator). <br><a name="habracut"></a><br>  Our language, Kaleidoscope, is simple and beautiful, but in this chapter we deviate from these principles.  The retreat is that we get a simple, but ugly, in some way, language, but at the same time powerful.  One of the great things about creating your own language is that you decide what is good and what is bad.  In this tutorial, we decided that this is normal and will demonstrate some interesting parsing techniques. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the end of this chapter, we will look at an example of a Kaleidoscope application that displays the Mandelbrot set.  This will be an example of what you can do with the Kaleidoscope and its feature set. <br><br><h3>  6.2.  User-Defined Operators: Basic Thought </h3><br>  ‚ÄúOperator Overloading‚Äù, which we introduce into the Kaleidoscope, is more generalized than in languages ‚Äã‚Äãlike C ++.  In C ++, you can only override existing operators, you cannot programmatically change their syntax, enter new operators, change priority levels, and so on.  In this chapter, we will add all these features to the Kaleidoscope, which will allow the user to determine for himself the set of supported operators. <br><br>  The purpose for which we consider the user-defined operators in this guide is to show the power and flexibility of using a ‚Äúself-written‚Äù parser.  The parser that we did uses recursive descent for most of the grammar, and parsing operators with priorities for expressions (see <a href="https://habrahabr.ru/post/120005/">part 2</a> ).  Using the parsing of operators with priorities, it is very easy to allow the programmer to introduce new operators into the grammar: the grammar is dynamically expanded with JIT. <br><br>  Two specific features that we add are unary operators (the Kaleidoscope does not currently have unary operators) and binary operators.  For example: <br><br><pre><code class="cpp hljs">#   . def unary!(v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v then <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; #  &gt;    ,   &lt;. def binary&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> (LHS RHS) RHS &lt; LHS; #   <span class="hljs-string"><span class="hljs-string">" "</span></span> def binary| <span class="hljs-number"><span class="hljs-number">5</span></span> (LHS RHS) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LHS then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RHS then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; #  =     ,  . def binary= <span class="hljs-number"><span class="hljs-number">9</span></span> (LHS RHS) !(LHS &lt; RHS | LHS &gt; RHS);</code> </pre> <br>  Many languages ‚Äã‚Äãtend to implement the functions of the standard library in the language itself.  In the language of Kaleidoscope, we can implement a significant part of the language as a library! <br><br>  Let us divide the implementation of these possibilities into two parts: the implementation of support for custom binary operators and unary operators. <br><br><h3>  6.3.  User-defined binary operators </h3><br>  Adding support for user-defined binary operators in our framework is very simple.  First, add support for the keywords "unary" and "binary": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Token { ... <span class="hljs-comment"><span class="hljs-comment">// operators tok_binary = -11, tok_unary = -12 }; ... static int gettok() { ... if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; return tok_identifier;</span></span></code> </pre> <br>  This code adds support for the keywords "unary" and "binary" to the lexical analyzer, just as we did in the previous parts.  One good thing about our AST implementation is that we represent binary operators completely generalized, using their ASCII code as an opcode.  For our additional operators, we will use the same representation, and we do not need additional support from the AST or parser. <br><br>  On the other hand, we can present the definitions of these new operators as a function definition.  In our grammar, the ‚Äúname‚Äù in the definition of a function is parsed as the production of a function prototype and falls into an AST node of the PrototypeAST type.  To present our new user-defined operators as prototypes, we need to extend the PrototypeAST node in this way: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// PrototypeAST -    ""  ///       class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; bool IsOperator; unsigned Precedence; //    public: PrototypeAST(const std::string &amp;name, std::vector&lt;std::string&gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string &amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } };</span></span></code> </pre> <br>  The bottom line is that, in addition to the well-known name of the prototype, we also keep information about whether it was an operator, and, if so, what level of priority it has.  The priority level is used only for binary operators (as we will see later, it does not apply to unary operators).  Now we have a way to present a prototype user operator, and we need to be able to parse it: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = , 1 =  , 2 =   unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected binary operator"); FnName = "binary"; FnName += (char)CurTok; Kind = 2; getNextToken(); //  ,    if (CurTok == tok_number) { if (NumVal &lt; 1 || NumVal &gt; 100) return LogErrorP("Invalid precedence: must be 1..100"); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP("Expected ')' in prototype"); // . getNextToken(); //  ')'. // ,     if (Kind &amp;&amp; ArgNames.size() != Kind) return LogErrorP("Invalid number of operands for operator"); return llvm::make_unique&lt;PrototypeAST&gt;(FnName, std::move(ArgNames), Kind != 0, BinaryPrecedence); }</span></span></code> </pre> <br>  A fairly straightforward parsing code, we have already seen a lot of similar code earlier.  One interesting part of this code is a pair of lines, in which FnName is assigned to a binary operator.  For the user operator "@", the prototype will be given the name "binary @".  Here the advantages of the fact that the names of characters in the LLVM symbol table can have any characters, including zero, are manifested. <br>  The next interesting thing to add is code generation support for binary operators.  In our existing structure, it is simply adding a ‚Äúdefault‚Äù to our existing node of a binary operator: <br><br><pre> <code class="cpp hljs">Value *BinaryExprAST::codegen() { Value *L = LHS-&gt;codegen(); Value *R = RHS-&gt;codegen(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!L || !R) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'+'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFAdd(L, R, <span class="hljs-string"><span class="hljs-string">"addtmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFSub(L, R, <span class="hljs-string"><span class="hljs-string">"subtmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFMul(L, R, <span class="hljs-string"><span class="hljs-string">"multmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: L = Builder.CreateFCmpULT(L, R, <span class="hljs-string"><span class="hljs-string">"cmptmp"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  bool 0/1  double 0.0  1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp"); default: break; } //      ,   .  //    . Function *F = getFunction(std::string("binary") + Op); assert(F &amp;&amp; "binary operator not found!"); Value *Ops[2] = { L, R }; return Builder.CreateCall(F, Ops, "binop"); }</span></span></code> </pre> <br>  As we can see above, the new code is very simple.  It simply finds the appropriate operator in the symbol table and generates a function call for it.  Since custom operators are implemented simply as normal functions, everything falls into place. <br><br>  The last piece of code we need is just a piece of high-level magic: <br><br><pre> <code class="cpp hljs">Function *FunctionAST::codegen() { <span class="hljs-comment"><span class="hljs-comment">//     FunctionProtos map,   //    . auto &amp;P = *Proto; FunctionProtos[Proto-&gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; //  ,  . if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); //       . BasicBlock *BB = BasicBlock::Create(TheContext, "entry", TheFunction); ...</span></span></code> </pre> <br>  Before generating the function code, if it is a custom operator, register it in the priority table.  This allows the logic of parsing a binary operator, which we already have, to handle the operator.  Since we are developing a fully generalized parser with operator priorities, we need to extend the grammar. <br>  We now have user-defined binary operators.  They are built mainly on the basis of the framework that we have made for other operators.  Adding unary operators will be a little more difficult, because we don't have a framework for this yet.  Let's see how to do this. <br><br><h3>  6.4.  Unary operators, user-defined </h3><br>  Since we do not yet support unary operators in the Kaleidoscope language, we need to add their support.  Above, we added simple support for the ‚Äúunary‚Äù keyword to the lexical analyzer.  Now we need an AST node. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// UnaryExprAST -      class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr&lt;ExprAST&gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; };</span></span></code> </pre> <br>  The AST node is very simple and obvious.  It is similar to the AST node of a binary operator, except that it has one descendant.  Now we need to add the logic of parsing.  Parsing unary operators is very simple; add a function that does this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// unary /// ::= primary /// ::= '!' unary static std::unique_ptr&lt;ExprAST&gt; ParseUnary() { //      ,     if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); //    ,   int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return llvm::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand)); return nullptr; }</span></span></code> </pre> <br>  The grammar we added here is very simple.  If we see a unary operator when the primary operator is parsed, we eat this operator as a prefix and parse the remaining piece as another unary operator.  This allows us to handle multiple unary operators (such as "!! x").  Note that unary operators cannot have ambiguous parsing, like binary operators, and do not need priority information. <br>  The problem with this function is that we may need to call ParseUnary from anywhere.  To do this, we replace the previous call to ParsePrimary with ParseUnary: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// binoprhs /// ::= ('+' unary)* static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS) { ... //       auto RHS = ParseUnary(); if (!RHS) return nullptr; ... } ///  /// ::= unary binoprhs /// static std::unique_ptr&lt;ExprAST&gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); }</span></span></code> </pre> <br>  With these two simple changes, you can now parse unary operators and build AST for them.  Then you need to add parser support for prototypes to parse the prototypes of the unary operator.  Expand the binary operator code above, as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected unary operator"); FnName = "unary"; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: ...</span></span></code> </pre> <br>  As with binary operators, we call unary operators a name that includes the operator symbol.  This will help us in code generation.  Now you need to add support for generating code for the unary operator.  It looks like this: <br><br><pre> <code class="cpp hljs">Value *UnaryExprAST::codegen() { Value *OperandV = Operand-&gt;codegen(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OperandV) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Function *F = getFunction(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"unary"</span></span>) + Opcode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LogErrorV(<span class="hljs-string"><span class="hljs-string">"Unknown unary operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateCall(F, OperandV, <span class="hljs-string"><span class="hljs-string">"unop"</span></span>); }</code> </pre> <br>  The code is similar to the implementation of a binary operator, but simpler, mainly because it does not need to support priorities. <br><br><h3>  6.5.  Kick tires </h3><br>  It is hard to believe, but by introducing a few simple extensions discussed in the last parts, we have grown a real language.  Many interesting things can be done with it, including I / O, math, and many other things.  For example, you can enter a sequence operator (the printd function prints the value of the argument and translates the string): <br><br><pre> <code class="cpp hljs">ready&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span>; Read <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span>: declare <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @printd(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) ready&gt; def binary : <span class="hljs-number"><span class="hljs-number">1</span></span> (xy) <span class="hljs-number"><span class="hljs-number">0</span></span>; #  ,    ... ready&gt; printd(<span class="hljs-number"><span class="hljs-number">123</span></span>) : printd(<span class="hljs-number"><span class="hljs-number">456</span></span>) : printd(<span class="hljs-number"><span class="hljs-number">789</span></span>); <span class="hljs-number"><span class="hljs-number">123.000000</span></span> <span class="hljs-number"><span class="hljs-number">456.000000</span></span> <span class="hljs-number"><span class="hljs-number">789.000000</span></span> Evaluated to <span class="hljs-number"><span class="hljs-number">0.000000</span></span></code> </pre> <br>  We can also define a variety of ‚Äúsimple‚Äù operators, for example: <br><br><pre> <code class="cpp hljs">#    def unary!(v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v then <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; #  . def unary-(v) <span class="hljs-number"><span class="hljs-number">0</span></span>-v; #  &gt;    ,   &lt;. def binary&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> (LHS RHS) RHS &lt; LHS; #   <span class="hljs-string"><span class="hljs-string">""</span></span> def binary| <span class="hljs-number"><span class="hljs-number">5</span></span> (LHS RHS) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LHS then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RHS then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; #   <span class="hljs-string"><span class="hljs-string">""</span></span> def binary&amp; <span class="hljs-number"><span class="hljs-number">6</span></span> (LHS RHS) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !LHS then <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> !!RHS; #  =    ,   def binary = <span class="hljs-number"><span class="hljs-number">9</span></span> (LHS RHS) !(LHS &lt; RHS | LHS &gt; RHS); #  <span class="hljs-string"><span class="hljs-string">':'</span></span>  :   ,   #    RHS. def binary : <span class="hljs-number"><span class="hljs-number">1</span></span> (xy) y;</code> </pre><br>  By taking if / then / else support, we can define interesting I / O functions.  For example, the following code displays a character whose "density" reflects the value passed to it: the smaller the value, the darker the character. <br><br><pre> <code class="cpp hljs">ready&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ... ready&gt; <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printdensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> d &gt; 8 then </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> # ' ' </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> d &gt; 4 then </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">46</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> # '.' </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> d &gt; 2 then </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">43</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> # '+' </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">42</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; # <span class="hljs-string"><span class="hljs-string">'*'</span></span> ... ready&gt; printdensity(<span class="hljs-number"><span class="hljs-number">1</span></span>): printdensity(<span class="hljs-number"><span class="hljs-number">2</span></span>): printdensity(<span class="hljs-number"><span class="hljs-number">3</span></span>): printdensity(<span class="hljs-number"><span class="hljs-number">4</span></span>): printdensity(<span class="hljs-number"><span class="hljs-number">5</span></span>): printdensity(<span class="hljs-number"><span class="hljs-number">9</span></span>): putchard(<span class="hljs-number"><span class="hljs-number">10</span></span>); **++. Evaluated to <span class="hljs-number"><span class="hljs-number">0.000000</span></span></code> </pre> <br>  Based on these simple operations, we can begin to identify more interesting things.  For example, here is a small function that determines the number of iterations for which the function diverges on the complex plane: <br><br><pre> <code class="cpp hljs"># ,       #   z = z^<span class="hljs-number"><span class="hljs-number">2</span></span> + c    def mandelconverger(real imag iters creal cimag) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> iters &gt; <span class="hljs-number"><span class="hljs-number">255</span></span> | (real*real + imag*imag &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) then iters <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mandelconverger(real*real - imag*imag + creal, <span class="hljs-number"><span class="hljs-number">2</span></span>*real*imag + cimag, iters+<span class="hljs-number"><span class="hljs-number">1</span></span>, creal, cimag); #    <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mandelconverge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(real imag)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mandelconverger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(real, imag, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, real, imag)</span></span></span></span>;</code> </pre> <br>  This function (z = z2 + c) is a beautiful little creation, the basis of the calculation of the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> .  Our mandelconverge function returns the number of iterations that a complex orbit needs to go to infinity.  The function ‚Äúsaturates‚Äù with a value of 255. By itself, this function is not very useful, but if you plot its values ‚Äã‚Äãon a two-dimensional plane, you will see a set of Mandelbrot.  Since we are limited here using the putchard function, our wonderful graphics output is also limited, but we can use the ‚Äúdensity‚Äù output function given above. <br><br><pre> <code class="cpp hljs">#          #    <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mandelhelp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xmin xmax xstep ymin ymax ystep)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> y </span></span>= ymin, y &lt; ymax, <span class="hljs-function"><span class="hljs-function">ystep </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = xmin, x &lt; xmax, xstep in printdensity(mandelconverge(x,y))) : putchard(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">) )</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># mandel -        #       def mandel(realstart imagstart realmag imagmag) mandelhelp(realstart, realstart+realmag*78, realmag, imagstart, imagstart+imagmag*40, imagmag);</span></span></span></span></code> </pre> <br>  Now we can try to build Mandelbrot set: <br><br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"> <code>ready&gt; mandel(-2.3, -1.3, 0.05, 0.07); <br> *******************************+++++++++++************************************* <br> *************************+++++++++++++++++++++++******************************* <br> **********************+++++++++++++++++++++++++++++**************************** <br> *******************+++++++++++++++++++++.. ...++++++++************************* <br> *****************++++++++++++++++++++++.... ...+++++++++*********************** <br> ***************+++++++++++++++++++++++..... ...+++++++++********************* <br> **************+++++++++++++++++++++++.... ....+++++++++******************** <br> *************++++++++++++++++++++++...... .....++++++++******************* <br> ************+++++++++++++++++++++....... .......+++++++****************** <br> ***********+++++++++++++++++++.... ... .+++++++***************** <br> **********+++++++++++++++++....... .+++++++**************** <br> *********++++++++++++++........... ...+++++++*************** <br> ********++++++++++++............ ...++++++++************** <br> ********++++++++++... .......... .++++++++************** <br> *******+++++++++..... .+++++++++************* <br> *******++++++++...... ..+++++++++************* <br> *******++++++....... ..+++++++++************* <br> *******+++++...... ..+++++++++************* <br> *******.... .... ...+++++++++************* <br> *******.... . ...+++++++++************* <br> *******+++++...... ...+++++++++************* <br> *******++++++....... ..+++++++++************* <br> *******++++++++...... .+++++++++************* <br> *******+++++++++..... ..+++++++++************* <br> ********++++++++++... .......... .++++++++************** <br> ********++++++++++++............ ...++++++++************** <br> *********++++++++++++++.......... ...+++++++*************** <br> **********++++++++++++++++........ .+++++++**************** <br> **********++++++++++++++++++++.... ... ..+++++++**************** <br> ***********++++++++++++++++++++++....... .......++++++++***************** <br> ************+++++++++++++++++++++++...... ......++++++++****************** <br> **************+++++++++++++++++++++++.... ....++++++++******************** <br> ***************+++++++++++++++++++++++..... ...+++++++++********************* <br> *****************++++++++++++++++++++++.... ...++++++++*********************** <br> *******************+++++++++++++++++++++......++++++++************************* <br> *********************++++++++++++++++++++++.++++++++*************************** <br> *************************+++++++++++++++++++++++******************************* <br> ******************************+++++++++++++************************************ <br> ******************************************************************************* <br> ******************************************************************************* <br> ******************************************************************************* <br> Evaluated to 0.000000 <br> ready&gt; mandel(-2, -1, 0.02, 0.04); <br> **************************+++++++++++++++++++++++++++++++++++++++++++++++++++++ <br> ***********************++++++++++++++++++++++++++++++++++++++++++++++++++++++++ <br> *********************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++. <br> *******************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++... <br> *****************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++..... <br> ***************++++++++++++++++++++++++++++++++++++++++++++++++++++++++........ <br> **************++++++++++++++++++++++++++++++++++++++++++++++++++++++........... <br> ************+++++++++++++++++++++++++++++++++++++++++++++++++++++.............. <br> ***********++++++++++++++++++++++++++++++++++++++++++++++++++........ . <br> **********++++++++++++++++++++++++++++++++++++++++++++++............. <br> ********+++++++++++++++++++++++++++++++++++++++++++.................. <br> *******+++++++++++++++++++++++++++++++++++++++....................... <br> ******+++++++++++++++++++++++++++++++++++........................... <br> *****++++++++++++++++++++++++++++++++............................ <br> *****++++++++++++++++++++++++++++............................... <br> ****++++++++++++++++++++++++++...... ......................... <br> ***++++++++++++++++++++++++......... ...... ........... <br> ***++++++++++++++++++++++............ <br> **+++++++++++++++++++++.............. <br> **+++++++++++++++++++................ <br> *++++++++++++++++++................. <br> *++++++++++++++++............ ... <br> *++++++++++++++.............. <br> *+++....++++................ <br> *.......... ........... <br> * <br> *.......... ........... <br> *+++....++++................ <br> *++++++++++++++.............. <br> *++++++++++++++++............ ... <br> *++++++++++++++++++................. <br> **+++++++++++++++++++................ <br> **+++++++++++++++++++++.............. <br> ***++++++++++++++++++++++............ <br> ***++++++++++++++++++++++++......... ...... ........... <br> ****++++++++++++++++++++++++++...... ......................... <br> *****++++++++++++++++++++++++++++............................... <br> *****++++++++++++++++++++++++++++++++............................ <br> ******+++++++++++++++++++++++++++++++++++........................... <br> *******+++++++++++++++++++++++++++++++++++++++....................... <br> ********+++++++++++++++++++++++++++++++++++++++++++.................. <br> Evaluated to 0.000000 <br> ready&gt; mandel(-0.9, -1.4, 0.02, 0.03); <br> ******************************************************************************* <br> ******************************************************************************* <br> ******************************************************************************* <br> **********+++++++++++++++++++++************************************************ <br> *+++++++++++++++++++++++++++++++++++++++*************************************** <br> +++++++++++++++++++++++++++++++++++++++++++++********************************** <br> ++++++++++++++++++++++++++++++++++++++++++++++++++***************************** <br> ++++++++++++++++++++++++++++++++++++++++++++++++++++++************************* <br> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++********************** <br> +++++++++++++++++++++++++++++++++.........++++++++++++++++++******************* <br> +++++++++++++++++++++++++++++++.... ......+++++++++++++++++++**************** <br> +++++++++++++++++++++++++++++....... ........+++++++++++++++++++************** <br> ++++++++++++++++++++++++++++........ ........++++++++++++++++++++************ <br> +++++++++++++++++++++++++++......... .. ...+++++++++++++++++++++********** <br> ++++++++++++++++++++++++++........... ....++++++++++++++++++++++******** <br> ++++++++++++++++++++++++............. .......++++++++++++++++++++++****** <br> +++++++++++++++++++++++............. ........+++++++++++++++++++++++**** <br> ++++++++++++++++++++++........... ..........++++++++++++++++++++++*** <br> ++++++++++++++++++++........... .........++++++++++++++++++++++* <br> ++++++++++++++++++............ ...........++++++++++++++++++++ <br> ++++++++++++++++............... .............++++++++++++++++++ <br> ++++++++++++++................. ...............++++++++++++++++ <br> ++++++++++++.................. .................++++++++++++++ <br> +++++++++.................. .................+++++++++++++ <br> ++++++........ . ......... ..++++++++++++ <br> ++............ ...... ....++++++++++ <br> .............. ...++++++++++ <br> .............. ....+++++++++ <br> .............. .....++++++++ <br> ............. ......++++++++ <br> ........... .......++++++++ <br> ......... ........+++++++ <br> ......... ........+++++++ <br> ......... ....+++++++ <br> ........ ...+++++++ <br> ....... ...+++++++ <br> ....+++++++ <br> .....+++++++ <br> ....+++++++ <br> ....+++++++ <br> ....+++++++ <br> Evaluated to 0.000000 <br> ready&gt; ^D</code> <br> </div></div><br>  At this stage, we can consider the Kaleidoscope a real, powerful language.  It is not self-similar :), but can be used to draw things that are! <br><br>  This concludes the ‚Äúadding user-defined operators‚Äù part of our guide.  We have successfully completed our language by adding the ability to extend the language using the library, and have shown how this can be used to build a simple but interesting user application in the Kaleidoscope language.  At this stage, on the Kaleidoscope, you can write various applications that can call functions with side effects, but cannot define and change variables themselves. <br><br>  Strictly speaking, changeable variables are an important feature of some languages, and it‚Äôs not quite obvious how to add their support without putting the SSA design phase into your frontend.  In the next section, we describe how to add mutable variables to the frontend without building an SSA. <br><br><h3>  6.6.  Full code listing </h3><br>  Below is a complete listing of the code for our working example, extended by the support of user-defined operators. <br>  Build example: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy #  ./toy</span></span></code> </pre> <br>  On some platforms, you will need to link with -rdynamic or -Wl, ‚Äìexport-dynamic.  Then the characters defined in the executable file will be exported to the dynamic linker and available in runtime.  This is not necessary if you compile the support code into a shared library, although this can cause problems under Windows. <br><br>  Code: <br><br><div class="spoiler">  <b class="spoiler_title">Chapter Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/APFloat.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/STLExtras.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/BasicBlock.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Constants.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Function.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Instructions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetMachine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar/GVN.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../include/KaleidoscopeJIT.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;cassert&gt; #include &lt;cctype&gt; #include &lt;cstdint&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;map&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// //     [0-255]    ,    //  enum Token { tok_eof = -1, //  tok_def = -2, tok_extern = -3, //   tok_identifier = -4, tok_number = -5, //  tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, //  tok_binary = -11, tok_unary = -12 }; static std::string IdentifierStr; //   tok_identifier static double NumVal; //   tok_number /// gettok -       static int gettok() { static int LastChar = ' '; //   while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; if (IdentifierStr == "if") return tok_if; if (IdentifierStr == "then") return tok_then; if (IdentifierStr == "else") return tok_else; if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   .   EOF. if (LastChar == EOF) return tok_eof; // ,     ascii-. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// //    ( ) //===----------------------------------------------------------------------===// namespace { /// ExprAST -    . class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST -      "1.0". class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST -   , , "a". class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;Name) : Name(Name) {} Value *codegen() override; }; /// UnaryExprAST -      class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr&lt;ExprAST&gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST -      class BinaryExprAST : public ExprAST { char Op; std::unique_ptr&lt;ExprAST&gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST -      class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; public: CallExprAST(const std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST -    if/then/else. class IfExprAST : public ExprAST { std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then, std::unique_ptr&lt;ExprAST&gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST -    for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body; public: ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start, std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step, std::unique_ptr&lt;ExprAST&gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST -    "" , ///    ,    (, ,  /// ,  ),   . class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string &amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST -      class FunctionAST { std::unique_ptr&lt;PrototypeAST&gt; Proto; std::unique_ptr&lt;ExprAST&gt; Body; public: FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } //     //===----------------------------------------------------------------------===// //  //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -  /// ,    . getNextToken     ///     CurTok  . static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -     , ///   static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -       . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -     . std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) { fprintf(stderr, "Error: %s\n", Str); return nullptr; } std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr&lt;ExprAST&gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() { auto Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal); getNextToken(); //   return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() { getNextToken(); //  (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError("expected ')'"); getNextToken(); //  ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //   return llvm::make_unique&lt;VariableExprAST&gt;(IdName); // Call. getNextToken(); //  ( std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return llvm::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() { getNextToken(); // eat the if. //  auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError("expected then"); getNextToken(); //  then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError("expected else"); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return llvm::make_unique&lt;IfExprAST&gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() { getNextToken(); //  for. if (CurTok != tok_identifier) return LogError("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //   if (CurTok != '=') return LogError("expected '=' after for"); getNextToken(); //  '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError("expected ',' after for start value"); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; //    std::unique_ptr&lt;ExprAST&gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError("expected 'in' after for"); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() { switch (CurTok) { default: return LogError("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr&lt;ExprAST&gt; ParseUnary() { //      ,     . if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); //    ,   int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return llvm::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS) { //    ,    while (true) { int TokPrec = GetTokPrecedence(); //   ,    //  ,   if (TokPrec &lt; ExprPrec) return LHS; //   ,     int BinOp = CurTok; getNextToken(); // eat binop //       auto RHS = ParseUnary(); if (!RHS) return nullptr; //  BinOp    RHS,    RHS,  //    RHS   LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } //  LHS/RHS. LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr&lt;ExprAST&gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = , 1 = , 2 = . unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected unary operator"); FnName = "unary"; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected binary operator"); FnName = "binary"; FnName += (char)CurTok; Kind = 2; getNextToken(); //  ,    if (CurTok == tok_number) { if (NumVal &lt; 1 || NumVal &gt; 100) return LogErrorP("Invalid precedence: must be 1..100"); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP("Expected ')' in prototype"); // . getNextToken(); // eat ')'. // ,     if (Kind &amp;&amp; ArgNames.size() != Kind) return LogErrorP("Invalid number of operands for operator"); return llvm::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { //    auto Proto = llvm::make_unique&lt;PrototypeAST&gt;("__anon_expr", std::vector&lt;std::string&gt;()); return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// static LLVMContext TheContext; static IRBuilder&lt;&gt; Builder(TheContext); static std::unique_ptr&lt;Module&gt; TheModule; static std::map&lt;std::string, Value *&gt; NamedValues; static std::unique_ptr&lt;legacy::FunctionPassManager&gt; TheFPM; static std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT; static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // , ,       . if (auto *F = TheModule-&gt;getFunction(Name)) return F; // I ,         // . auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-&gt;second-&gt;codegen(); //    ,  null. return nullptr; } Value *NumberExprAST::codegen() { return ConstantFP::get(TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // ,       Value *V = NamedValues[Name]; if (!V) return LogErrorV("Unknown variable name"); return V; } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-&gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string("unary") + Opcode); if (!F) return LogErrorV("Unknown unary operator"); return Builder.CreateCall(F, OperandV, "unop"); } Value *BinaryExprAST::codegen() { Value *L = LHS-&gt;codegen(); Value *R = RHS-&gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //  bool 0/1  double 0.0 or 1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp"); default: break; } //      ,     .  //    . Function *F = getFunction(std::string("binary") + Op); assert(F &amp;&amp; "binary operator not found!"); Value *Ops[] = {L, R}; return Builder.CreateCall(F, Ops, "binop"); } Value *CallExprAST::codegen() { //       Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV("Unknown function referenced"); // ,    . if (CalleeF-&gt;arg_size() != Args.size()) return LogErrorV("Incorrect # arguments passed"); std::vector&lt;Value *&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder.CreateCall(CalleeF, ArgsV, "calltmp"); } Value *IfExprAST::codegen() { Value *CondV = Cond-&gt;codegen(); if (!CondV) return nullptr; //          0.0. CondV = Builder.CreateFCmpONE( CondV, ConstantFP::get(TheContext, APFloat(0.0)), "ifcond"); Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //    then  else.   'then'  //   BasicBlock *ThenBB = BasicBlock::Create(TheContext, "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(TheContext, "else"); BasicBlock *MergeBB = BasicBlock::Create(TheContext, "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB); //  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;codegen(); if (!ThenV) return nullptr; Builder.CreateBr(MergeBB); //    'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock(); //   "else" TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;codegen(); if (!ElseV) return nullptr; Builder.CreateBr(MergeBB); //    'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock(); //    TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; } //  for-loop : // ... // start = startexpr // goto loop // loop: // variable = phi [start, loopheader], [nextvariable, loopend] // ... // bodyexpr // ... // loopend: // step = stepexpr // nextvariable = variable + step // endcond = endexpr // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { //    ,  . Value *StartVal = Start-&gt;codegen(); if (!StartVal) return nullptr; //        ,     //  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); BasicBlock *PreheaderBB = Builder.GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(TheContext, "loop", TheFunction); //          LoopBB. Builder.CreateBr(LoopBB); //    LoopBB. Builder.SetInsertPoint(LoopBB); //   PHI   . PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName); Variable-&gt;addIncoming(StartVal, PreheaderBB); //    ,   PHI.   //   ,    ,   . Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; //   . ,    ,   //  BB. ,    ,   ,   //  . if (!Body-&gt;codegen()) return nullptr; //    Value *StepVal = nullptr; if (Step) { StepVal = Step-&gt;codegen(); if (!StepVal) return nullptr; } else { //   ,  1.0. StepVal = ConstantFP::get(TheContext, APFloat(1.0)); } Value *NextVar = Builder.CreateFAdd(Variable, StepVal, "nextvar"); //    Value *EndCond = End-&gt;codegen(); if (!EndCond) return nullptr; //          0.0. EndCond = Builder.CreateFCmpONE( EndCond, ConstantFP::get(TheContext, APFloat(0.0)), "loopcond"); //   " "    BasicBlock *LoopEndBB = Builder.GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(TheContext, "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB); //      PHI. Variable-&gt;addIncoming(NextVar, LoopEndBB); //    . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //    0.0. return Constant::getNullValue(Type::getDoubleTy(TheContext)); } Function *PrototypeAST::codegen() { //   : double(double,double) etc. std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); //    unsigned Idx = 0; for (auto &amp;Arg : F-&gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { //      FunctionProtos,   //    . auto &amp;P = *Proto; FunctionProtos[Proto-&gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; //   ,   if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); //        BasicBlock *BB = BasicBlock::Create(TheContext, "entry", TheFunction); Builder.SetInsertPoint(BB); //      NamedValues. NamedValues.clear(); for (auto &amp;Arg : TheFunction-&gt;args()) NamedValues[Arg.getName()] = &amp;Arg; if (Value *RetVal = Body-&gt;codegen()) { //   Builder.CreateRet(RetVal); //    verifyFunction(*TheFunction); //     TheFPM-&gt;run(*TheFunction); return TheFunction; } //    ,   TheFunction-&gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// //     JIT //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { //    TheModule = llvm::make_unique&lt;Module&gt;("my cool jit", TheContext); TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout()); //       TheFPM = llvm::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get()); //   "peephole"-. TheFPM-&gt;add(createInstructionCombiningPass()); //   TheFPM-&gt;add(createReassociatePass()); //    TheFPM-&gt;add(createGVNPass()); //    (    ..). TheFPM-&gt;add(createCFGSimplificationPass()); TheFPM-&gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-&gt;codegen()) { fprintf(stderr, "Read function definition:"); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); TheJIT-&gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); } } else { //       getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-&gt;codegen()) { fprintf(stderr, "Read extern: "); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST); } } else { //       getNextToken(); } } static void HandleTopLevelExpression() { //       if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-&gt;codegen()) { // JIT  ,    //    auto H = TheJIT-&gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); //  JIT   __anon_expr auto ExprSymbol = TheJIT-&gt;findSymbol("__anon_expr"); assert(ExprSymbol &amp;&amp; "Function not found"); //         (  // ,  double)      . double (*FP)() = (double (*)())(intptr_t)cantFail(ExprSymbol.getAddress()); fprintf(stderr, "Evaluated to %f\n", FP()); //     JIT. TheJIT-&gt;removeModule(H); } } else { //       getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': //       getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,        //===----------------------------------------------------------------------===// #ifdef LLVM_ON_WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar,  double,  0. extern "C" DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf,  double   "%f\n",  0. extern "C" DLLEXPORT double printd(double X) { fprintf(stderr, "%f\n", X); return 0; } //===----------------------------------------------------------------------===// //  main //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); //     // 1 -    BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. //    fprintf(stderr, "ready&gt; "); getNextToken(); TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;(); InitializeModuleAndPassManager(); //    MainLoop(); return 0; }</span></span></span></span></code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/336080/">https://habr.com/ru/post/336080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336070/index.html">How to ensure the performance of Microsoft SQL Server databases hosted in the cloud</a></li>
<li><a href="../336072/index.html">Gamers in life: what we know about generation Y</a></li>
<li><a href="../336074/index.html">Modern methods of web application security research: toolkit</a></li>
<li><a href="../336076/index.html">Reefs settings Mikrotik SXT LTE</a></li>
<li><a href="../336078/index.html">A brief history of Connected Cars: what is considered ‚Äúconnected machines‚Äù and why the near future is not in drones?</a></li>
<li><a href="../336082/index.html">Angular - Implementing secure queries to the GraphQL API via JWT tokens</a></li>
<li><a href="../336084/index.html">Zabbix 3.4 released</a></li>
<li><a href="../336086/index.html">How to build a storage system with rocket on a standard hardware? SDS RAIDIX hardware platform architecture</a></li>
<li><a href="../336088/index.html">The future of web technologies: creating an intelligent chat bot that can hear and speak</a></li>
<li><a href="../336090/index.html">Why learn Spark?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>