<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET in an unmanaged environment - use and generic problems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Managed code and the .NET Framework are absolutely wonderful things from the point of view of a programmer who needs to get the most stable working pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET in an unmanaged environment - use and generic problems</h1><div class="post__text post__text-html js-mediator-article">  Managed code and the .NET Framework are absolutely wonderful things from the point of view of a programmer who needs to get the most stable working programs out of his nose.  Using .NET allows you to greatly reduce the cost of developing, testing and maintaining software products, especially compared to C ++ or Delphi. <br><br>  However, the managed code has one very serious birth injury, which directly results from its merits - it is initially incompatible with the unmanaged environment in which it is forced to work.  Boxing, memory fields, the lack of direct addressing and other tricks designed to make life easier for the programmer, make the interaction of a managed and unmanaged code a problem. <br><br>  However, there is no such problem that cannot be solved (even with the help of an ax and a scrap).  Today we have a brief overview of the possibilities of organizing the interaction between managed and unmanaged code.  Many C # and especially VB.NET programmers are afraid of this, but in reality there is nothing to worry about.  We will start with the most primitive methods, which will be interesting only to beginners (therefore, experienced .NET wolves can skip the first part of the article with a clear conscience), and finish with a description of what to do if you want to write a program in .NET, but this is impossible ( and this also happens).  Naturally, specific examples will be given for each case, perhaps the habrecheloveki will tell me about my own cycling.  In parallel, I will say a few words about the pitfalls when working with VSTO and Windows Shell. <br><a name="habracut"></a><br><h2>  Work with unmanaged-code from managed. </h2><br>  Standard for this situation from the point of view of .NET are three mechanisms offered by Microsoft - this is platform invoke (P / Invoke), COM interop and unsafe. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  General warnings </h3><br>  All methods of working with unmanaged-code have a set of common flaws, quite serious, which should be paid attention to and should be considered. <br><ol><li>  Calling unmanaged code is a dangerous operation that requires determining the validity of this operation in the application manifest.  This sometimes creates problems with deploing, especially with ClickOnce methods. </li><li>  Unmanaged code is not secure, does not pass the CLR checks and does not follow the rules of the embedded .NET security system.  If you define a ‚Äúdeny access to files‚Äù security rule in the method and use the unmanaged function that works with files, it will work without problems. </li></ol><br>  Keeping in mind this information, we proceed to consider the methods of working with it. <br><br><h3>  P / Invoke </h3><br>  The procedure procedure invoke is intended for accessing functions contained in DLL files. <br><br><h4>  When is it necessary? </h4><br>  Despite the abundance of functions in the .NET Framework libraries, it is still impossible to do some things with it.  Personally, I needed the P / Invoke ability to control the mandatory level for files and named pipes.  The problem was that the .NET access control classes did not understand the SDDL strings that contain the mandatory level descriptors, and I had to access these functions directly. <br><br><h4>  What does this look like? </h4><br>  Simple enough.  We declare a static class, in it we prescribe a static function with the name of the one to be exported, compile the appropriate list of parameters, hang the DllImport attribute with the name of the DLL and enjoy life. <br><br>  <strong>Example:</strong> import PlaySound function <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> Win32 <br> { <br> [DllImport( <font color="#A31515">"winmm"</font> )] <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">extern</font> <font color="#0000ff">int</font> PlaySound( <font color="#0000ff">string</font> szSound, <font color="#2B91AF">IntPtr</font> hModule, <font color="#0000ff">int</font> flags); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Main problems </h4><br><ol><li>  The transfer of various descriptors (handles).  The problem is solved as follows.  Most objects have a Handle field that can be passed to a function.  If not, you can try to take the SafeHandle object and request IntPtr from it via Dangerous operation. </li><li>  Passing structures, function pointers, and other non-trivial things.  Indeed, for a non-expert who does not understand how to marshall data, this is a very big problem.  Fortunately, there is a site <a href="http://www.pinvoke.net/">pinvoke.net/</a> , which contains the basic definitions for frequently used functions.  The site is built on a wiki engine, and if you need a system function - by 99%, that you will find its correct definition there. </li></ol><br><br><h3>  COM Interop </h3><br>  Really powerful mechanism that allows using COM components in managed code. <br><br><h4>  When is it necessary? </h4><br>  In serious projects - quite often.  The fact is that certain parts of the system can be written (or already be written) in C ++, Delphi, or even (holy-holy) Visual Basic (the one that is not .NET).  In addition, Win32 itself is built on COM, and therefore provides access to the functionality including through this mechanism.  In order to use it without problems - you should use the component model and COM Interop. <br><br><h4>  What does this look like? </h4><br>  Simple enough.  If your object supports automation, then the interop process will pass without problems, if not, you may have to suffer. <br><br>  To add a COM object to the assembly, simply connect it via project References.  A library that marshals the parameters from unmanaged to managed and back will be created automatically.  Naturally, for complex objects, such as MAPI or AD, this interop will not work, in this case, you should use the approach I will write about later. <br><br>  After you have connected the component, simply create a new instance of the object and use it as if it were a native .NET object. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">IComExampleInterface iInt = <font color="#0000ff">new</font> ComExampleInterface();</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  No, we are not creating an interface object.  In fact, this interface (as seen in the metadata) has an attribute called default coclass, and it is this object that will be created. <br>  As you can see, it is very simple and not at all scary. <br><br><h4>  Main problems </h4><br><ol><li>  Errors in the interopa of complex objects.  .NET is not all-powerful, and can not always correctly determine how certain data are marshalling.  In this case, again we find ourselves in a situation where it is necessary to prescribe the marshall explicitly. </li><li>  Absence in .NET of many definitions of standard interfaces.  For example, IUnknown, IDispatch, IDictionary, or IStream.  These definitions can be written with your hands or ripped out using the Reflector from the core of the .NET kernel (they are there). </li><li>  Incompatibility of similarly named .NET and Win32 objects.  For example, a Dictionary in .NET is not at all the same as a Win32 Scripting.Dictionary object.  Similarly with IStream and others, so for successful and fruitful work you will have to write wrappers and export them.  How?  For example, creating wrappers and exporting them using ComExport methods, which will be discussed later. </li></ol><br><br><h3>  Unsafe context. </h3><br>  Personally, it seems to me an unnecessary atavism, but this is my personal opinion. <br><br><h4>  When is it necessary? </h4><br>  Most often, the use of unsafe methods is motivated by the fact that such an approach reduces the execution time of the code, especially in the case of working with large amounts of data of simple types - in this case, the costs for boxing / unboxing become quite large.  However, as practice shows, in reality, programmers working with .NET increasingly operate with complex objects like the DataSet, moreover, unsafe requires the definition in the application manifest of special powers to execute unsafe code.  Personally, I never needed to use unsafe - even marshalling tasks of complex data types are easily performed using the Marshal static class using IntPtr. <br><br><h4>  What does this look like? </h4><br>  The unsafe keyword is added to the method description. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">unsafe</font> <font color="#0000ff">void</font> UnsafeMethod( <font color="#0000ff">char</font> * chararray)</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  At the same time, in the method, the operations of taking the address and the mechanism of working with links become available, just as in C ++. <br>  It should be remembered that the unsafe-code remains managed, the number of execution time checks is simply reduced.  Thus, it does not quite relate to our topic, but it will not be superfluous to mention this way of working. <br><br><h4>  Main problems </h4><br><ol><li>  The appearance of many inherited unmanaged code problems, including the main one, is a buffer overflow. </li></ol><br><br><h2>  Work with managed code from unmanaged. </h2><br>  If the work with unmanaged code is organized more or less well, then the reverse process - accessing .NET assemblies from unmanaged code creates a huge number of problems.  To understand their essence, consider the mechanism proposed by Microsoft to implement such an approach. <br><br>  This mechanism is called <strong>ComExport</strong> and allows you to export objects in a managed environment as if they were ordinary COM objects.  To export an object, define the attribute ComVisible (true) for it, set the CLSID, ProgID, DefaultInterface, perform a similar operation for all exported interfaces.  Especially important is the definition of CLSID and IID for all exported interfaces, as well as their versions, hard in the code - otherwise when developing an application, any interface change will lead to the definition of a new CLSID and IID, and the version will constantly jump. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">[ComVisible( <font color="#0000ff">true</font> )] <br> [InterfaceType(ComInterfaceType.InterfaceIsDual)] <br> [ <font color="#2B91AF">Guid</font> ( <font color="#A31515">"5095474B-5273-44ae-A220-9E3820D2EEDC"</font> )] <br> [ProgId( <font color="#A31515">"COM.Export.Test.1"</font> )] <br> [ComDefaultInterface( <font color="#0000ff">typeof</font> (IDefaultInterface))] <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> Coclass {...}</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  However, if everything was so rosy - there would be no problems.  The reality is much more sad and there are a number of problems that can make it difficult to use such an approach. <br><ol><li>  COM written using .NET is not required to register using regsvr32, but using regasm, which makes the development of installers somewhat difficult. </li><li>  The created components need to be signed (at least with a temporary key), or registered in the GAC using gacutil.  Registration with the GAC requires administrator privileges in Windows Vista. </li><li>  With the ComExport mechanism, Out-Process COM cannot be created. </li><li>  When using such components, the CLR is loaded into the address space of the process that invokes it. </li></ol><br>  Let us dwell on the last two points in more detail.  Why can't out-process COM be created? <br><br>  Speaking quite simply, the fact is that any .NET application is also an assembly, and allows you to connect yourself as a simple assembly DLL, without performing the one when it is directly registered in the main function.  And if when writing out-process COM, for example, in C ++, the characteristic behavior of the system is to wait for the application to load, then wait until it registers the exported objects in ROT, and then access it with a request from the class factory, then in the case of .NET application does not start - the assembly simply fits into the current process as a DLL through an intermediary.  Thus, even if you define a singleton or static class in the assembly, it will be different for each process, since the processes in win32 are isolated from each other. <br><br>  As far as I know, DCOM can be used to solve this problem, but the creation of such components on .NET is associated with considerable difficulties, many other problems appear, and therefore I personally did not use this approach. <br><br>  And what is the problem of loading CLR into the address space of the process, you ask?  After all, .NET supports versioning of builds, and in any case, the version of mscorlib that corresponds to the library will be used. <br><br>  Not so simple.  The problems will start when you try to load COM written using the .NET Framework 1.1 in an application written in the .NET Framework 3.5.  Two version of the same library can not simultaneously exist in the same address process.  Most likely, everything will just fall. <br><br>  This moment, in particular, directly prohibits writing such things as a shell extension or namespace extension using .NET.  After all, the file saving or opening dialog box can be called from any code - unmanaged or managed, written using any version of the Framework. <br><br>  In addition, in all honesty, ComExport is not the fastest mechanism.  CLR loading is a long process.  This is especially obvious in the case of developing add-in to Microsoft Office applications using Visual Studio Tools for Office.  The tool, which was planned as a panacea for all development problems, got stuck in one simple problem - with the connected VSTO add-in, the application load time increases on average from 20 to 100 seconds.  And if for MS Outlook it is not too critical, then for an increase in download time of Word or Excel, customers will chase you with pissing rags for a long time :) <br><br>  Just remember - you can't implement shell extensions using .NET.  Do not listen to Microsoft, which, in MSDN, doesn‚Äôt gently recommend it - it‚Äôs impossible.  Never.  Point. <br><br>  There are two solutions to this problem: <br><ol><li>  Using proxy objects that do not release their own CLR limits. </li><li>  Using custom transports for communication between managed and unmanaged code. </li></ol><br>  When I had the task of writing a namespace extension that would appeal to a server written in ASP.NET, which exported the API through the WCF mechanism, the problem for me was really acute.  There was no desire to establish connections through sockets, to implement Windows authentication and Windows SOAP parsing, and Managed C ++ prohibited the use of the problems described above.  Then the following architecture was born: namespace extension, written in C ++, which implements all the interfaces of the Windows Shell, and for data it calls the application running on the local (or remote) machine using the named pipe.  From this approach, a common architecture of this kind of applications was born, called .NET Pipe RPC.  The approach is really quite general, but I have already 5 pages in Word, so I‚Äôm finishing, and if Habracheloveks are interested in this topic, write down in the comments, and I will tell you in detail about this approach with examples of implementation. <br><br></div><p>Source: <a href="https://habr.com/ru/post/58031/">https://habr.com/ru/post/58031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../58022/index.html">Campaign of Kaspersky Lab, 30% of the license cost</a></li>
<li><a href="../58023/index.html">8 Characteristics of a successful user interface</a></li>
<li><a href="../58025/index.html">Copenhagen User Experience</a></li>
<li><a href="../58026/index.html">The first netbook based on Google Android</a></li>
<li><a href="../58028/index.html">LDAP for internet project. Part 5</a></li>
<li><a href="../58034/index.html">nanoHabr is here,% username%</a></li>
<li><a href="../58036/index.html">Office monitors Eizo Nanao with a presence sensor</a></li>
<li><a href="../58038/index.html">IFPI boycott</a></li>
<li><a href="../58041/index.html">The meeting of the Ural user group .NET</a></li>
<li><a href="../58044/index.html">Bird designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>