<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intercepting Linux system calls using LSM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently there were such tasks: to assemble the Linux kernel, write a module for it and use it to intercept system calls. And if I did the first two w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intercepting Linux system calls using LSM</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2b5/2e7/bfb/2b52e7bfba324bd4916f9a8d17fc0330.jpg"><br><br>  Recently there were such tasks: to assemble the Linux kernel, write a module for it and use it to intercept system calls.  And if I did the first two without any problems, then in the process of doing the third, I had the impression that working with system calls went out of fashion 10 years ago. <br><br>  Periodically, I found articles on the Internet that were close to what I was looking for, some were even very well written, but everyone had a significant drawback - they were outdated. <br><a name="habracut"></a><br><h4>  Initial conditions </h4><br><ul><li>  4 cores Intel Core i7 </li><li>  4 GB of RAM + 4 GB of swap </li><li>  Ubuntu 16.10 x64 on a virtual machine VirtualBox 5.1.10 </li><li>  Linux kernel 4.9.0 </li><li>  gcc 6.2.0 </li></ul><br>  To edit the kernel configuration in pseudographic mode, you need ncurses: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install libncurses5-dev</code> </pre> <br><h2>  Building a clean kernel </h2><br>  I recommend building a clean kernel before starting the development of modules.  There are 2 reasons for this: <br><br><ol><li>  The first kernel build is a fairly long process.  Most often it lasts from 20 minutes to 3 hours.  If you build in advance, you will get most of the kernel binaries that will not need to be recompiled.  This will allow to concentrate fully on the development of the module, without suffering, waiting for the answer to the question ‚ÄúWill my first Hello World start?‚Äù <br><br></li><li>  Having successfully assembled a clean core, you will see that at this stage there are no problems and that you can proceed to the next one.  Sometimes booting with a freshly assembled kernel can be unsuccessful, and if you compiled it with the module, it will be difficult to understand what the system put. </li></ol><br>  So, the kernel build: <br><br><ol><li>  Download the source archive: <br><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/cdn.kernel.org/pub</span></span><span class="hljs-regexp"><span class="hljs-regexp">/linux/kernel</span></span><span class="hljs-regexp"><span class="hljs-regexp">/v4.x/linux</span></span>-xxxtar.xz</code> </pre> <br>  where xxx is the kernel version. <br><br>  Or you can download the archive with your hands from <a href="https://kernel.org/">kernel.org</a> <br><br></li><li>  Extract data from the archive: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">tar</span></span> -xpJf linux-xxxtar.xz</code> </pre> <br></li><li>  Go to the newly unzipped folder: <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> linux-xxx</code> </pre> <br></li><li>  We generate the default kernel configuration: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">make</span></span> defconfig</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">For advanced:</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">make</span></span> menuconfig</code> </pre> <br>  The pseudo graphic kernel configuration interface opens.  Most options are not difficult to understand, but without an understanding of each variable parameter it is very easy to break everything.  For the first build, I recommend using the default parameters. <br></div></div><br></li><li>  We start directly the assembly of a kernel and modules: <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">make</span></span> modules</code> </pre> <br>  The assembly will last from 20 minutes to 3 hours. <br><br><div class="spoiler">  <b class="spoiler_title">Life hacking:</b> <div class="spoiler_text"><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> -jx &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">make</span></span> modules -jx</code> </pre> <br>  Where x is the number of processor cores + 1. That is, in my case x = 5. <br>  This value is recommended to be installed in all manuals, but in fact you can set any value.  I decided to ‚Äúdouble the number of cores‚Äù, that is, to start the assembly with the -j 9 parameter. This does not speed up the assembly by 2 times, but increases the competitiveness of the assembly processes in relation to all other processes in the system. <br><br>  In addition, in the system monitor (gnome-system-monitor) to all make-processes, I set the maximum priority.  The system literally hung up after that, but the assembly was completed in 6 minutes.  Use this method at your own risk. <br></div></div><br>  After a successful build, you need to install everything that we have collected.  This requires root rights. <br><br></li><li>  Setting Headers: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> make headers_install</code> </pre> <br></li><li>  Installation of modules: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> make modules_install</code> </pre> <br></li><li>  Installing the kernel directly: <br><br><pre> <code class="hljs sql">sudo make <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre> <br></li><li>  Installation commands must generate an initial RAM disk and update grub.  If suddenly the initial RAM disk is not generated - the system with the new kernel will not start. <br><br>  You can check this by the presence of the file "/boot/initrd.img-xxx" (xxx is the kernel version) <br>  If the file is not found, generate it with your hands: <br><br><pre> <code class="hljs swift">sudo update-initramfs ‚Äì<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> ‚Äìk xxx</code> </pre> <br></li><li>  Update grub bootloader: <br><br><pre> <code class="hljs pgsql">sudo <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>-grub</code> </pre> </li></ol><br>  Done!  After restarting, the system will start with the new kernel.  Check current kernel version: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uname</span></span> -r</code> </pre> <br>  If suddenly something went wrong, and the system does not boot with a new kernel, reboot the computer, go to advanced options in the grub menu and select a different kernel version (the one you used to boot before, usually the default version is added to the versions ) <br><br><h2>  Module creation </h2><br>  Creating a kernel module is a lot like writing a regular C user program, except for some differences related to the kernel: <br><br><ul><li>  The kernel does not have access to the standard C libraries. The reason for this is the speed of execution and the amount of code.  Some functions, however, can be found in the kernel source.  For example, the usual functions for working with strings are described in the file lib / string.c. <br><br></li><li>  Lack of memory protection.  If a regular program attempts to incorrectly access memory, the kernel may crash the process.  If the <i>kernel</i> attempts an incorrect memory access, the results will be less controlled.  In addition, the kernel does not use page replacement: every byte used in the kernel is one byte of physical memory. <br><br></li><li>  You cannot use floating-point calculations in the kernel.  Activating the floating-point mode requires storing and registering the floating-point device support registers, in addition to other routine operations. <br><br></li><li>  Fixed stack (and rather small).  That is why it is not recommended to use recursion in the kernel. <br></li></ul><br><h3>  Hello world! </h3><br>  Let's take a concrete example to consider ‚ÄúHello world‚Äù as a kernel module.  Create a file hello.c in any folder convenient for you: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// hello.c #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; static int __init myinit(void) { printk("%s\n","&lt;my_tag&gt; hello world"); return 0; } static void __exit myexit(void) {} module_init(myinit); module_exit(myexit); MODULE_LICENSE("GPL");</span></span></code> </pre><br>  A regular user program starts with a call to the main () function and works until it returns a value to the system. <br><br>  The module is essentially a part of the code of the kernel itself, which contains handler functions for some events.  The simplest example of such an event is loading or unloading the module itself. <br><br>  The functions that handle these events are, respectively. <br><br>  <b>static int __init myinit (void)</b> <b><br></b>  <b>static void __exit myexit (void)</b> <br><br>  They are marked with the __init, __exit macros and are registered using module_init and module_exit as event handlers.  The name of these functions can be any, but should not conflict with other functions in the kernel. <br><br>  Since the kernel does not use the standard C library, we cannot use stdio.h.  Instead, we include the file kernel.h, in which the printk function is implemented.  This function is similar to printf with the only difference that it displays messages not in the terminal window, but in the system log (/ var / log / syslog). <br><br>  A lot of messages from the entire system are written to this log, so we need to mark ours with some kind of original <abbr title="For example, <my_tag>">tag</abbr> , so that later with the help of the <b>grep</b> utility we could select only the messages of our module. <br><br>  Another incomprehensible line is <b>MODULE_LICENSE ("GPL");</b> <br><br>  It indicates that our module complies with the GPL license.  Without this, some of the capabilities inside the kernel will not be available. <br><br><h3>  Assembly </h3><br>  In order to assemble this module in the same folder as the source code of the module, create a Makefile: <br><br><pre> <code class="hljs pgsql">#       KERNEL_PATH = /<span class="hljs-type"><span class="hljs-type">path</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-your-kernel/linux-xxx #  ,       obj-m += hello.o <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>: #  make   -C ,       # KERNEL_PATH.    ,     #    # SUBDIRS -  ,      , #    -   make -C $(KERNEL_PATH) SUBDIRS=$(PWD) modules #   ,      make clean #  ,      clean: rm -f *.o *.mod* Module.symvers modules.<span class="hljs-keyword"><span class="hljs-keyword">order</span></span></code> </pre><br>  After creating the Makefile, go directly to the build: <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span></code> </pre> <br>  After a couple of seconds, the hello.ko file will appear in our folder - a ready-made compiled module. <br><br><h3>  Loading and unloading </h3><br>  There are 2 ways to load a module into the kernel: <br><br><ol><li>  <u>Building the module with the kernel.</u>  In this case, the module is loaded as part of the system startup, and the module itself becomes part of the kernel code. <br><br></li><li>  <u>Dynamic loading in an already running system.</u>  The above method of creating a module implies just such a method of loading.  In this case, loading the module is more like launching a regular user program. </li></ol><br>  Download module: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> insmod hello.ko</code> </pre> <br>  The insmod command loads a module into kernel space, thereby calling the initialization function. <br><br>  After that, the module is listed as downloaded.  You can check this with the <b>lsmod</b> command: <br><br><img src="https://habrastorage.org/files/825/e34/96f/825e3496fd4c49918e9960cf8c8d3b57.png" alt="image"><br><br>  In the initialization function, we added a call to <b>printk</b> , which displays our message to the system log. <br><br>  To view the system log, there is a <b>dmesg</b> utility: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;my_tag&gt;'</span></span></code> </pre> <br>  The above command will output <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my_tag</span></span></span><span class="hljs-tag">&gt;</span></span> hello world</code> </pre> <br>  After we load the module, it will remain hanging in the kernel until it is unloaded.  To do this: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> rmmod hello.ko</code> </pre> <br>  This command will call the __exit event handler, but since we have an empty function there, nothing will happen except unloading the module from the kernel. <br><br><div class="spoiler">  <b class="spoiler_title">Life hacking</b> <div class="spoiler_text">  In order not to enter 2 commands each time for loading and unloading the module during debugging, the value -1 is returned in the initialization function.  Such a module, when trying to load, displays an error to the terminal, after which it stops working, but at the same time, the initialization function works completely and correctly, turning, in essence, into an analogue of the main () function of user programs. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ printk(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>,<span class="hljs-string"><span class="hljs-string">"&lt;my_tag&gt; hello world"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br></div></div><br>  Next, we will look at the first way to load the module, as well as what this article was originally written for. <br><br><h2>  Interception of system calls </h2><br><h3>  Unsafe way </h3><br>  Once upon a time, even before the kernel version 2.6, in order to intercept the system call, they wrote a function hook that replaced it: it was executed by another code + it was called directly by the syscall itself (so as not to disrupt the performance of the system). <br><br>  Since each system call, like a function, has its own address, and in Linux there is a special table where these addresses are stored, the task was reduced to replacing the address of the system call with the address of our function in this table itself. <br><br>  Later, Linux developers tried to eliminate the possibility of this method, but there are still hacks that allow you to implement this method. <br><br>  However, it is very unsafe, and I will not describe it.  Moreover, to solve the problem at the same time came up with a more elegant and safe solution. <br><br><h3>  LSM </h3><br>  <abbr title="Linux security modules">LSM</abbr> is a framework for developing kernel security modules.  It was created in order to extend the standard <abbr title="Discretionary Access Control">DAC</abbr> security model, to make it more flexible.  This framework uses the well-known SELinux security module, as well as several others built into the kernel. <br><br>  The most valuable thing for us in this framework is that it is implemented through a set of <abbr title="In this case, a hook is a function that intercepts system calls.">hooks</abbr> pre-installed into the kernel (in fact, the way I described above, but safe, because the kernel is pre-calculated for the presence of such hooks). <br><br>  LSM allows you to insert <i>user</i> calls into <i>your</i> hook code, which allows you to safely work with system calls without changing the symbol table. <br><br>  Everything is very simple.  Consider an example of creating a security module <b>foobar</b> that intercepts the <b>mk_dir</b> system call. <br><br><h4>  Code writing </h4><br><ol><li>  We find the folder <b>security</b> in the source code for the kernel, create a folder for our module in it, and in it its source code foobar.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// /security/foobar/foobar.c //---INCLUDES #include &lt;linux/module.h&gt; #include &lt;linux/lsm_hooks.h&gt; //---HOOKS //mkdir hook static int foobar_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mask) { printk("%s\n","&lt;my_tag&gt; mkdir hook"); return 0; } //---HOOKS REGISTERING static struct security_hook_list foobar_hooks[] = { LSM_HOOK_INIT(inode_mkdir, foobar_inode_mkdir), }; //---INIT void __init foobar_add_hooks(void) { security_add_hooks(foobar_hooks, ARRAY_SIZE(foobar_hooks)); }</span></span></code> </pre><br>  The lsm_hooks.h file contains the headers of those most predefined hooks, LSM_HOOK_INIT registers the correspondence of foobar_inode_mkdir () to the hook inode_mkdir (), and security_add_hooks () adds our function to the general list of LSM user hooks. <br><br>  Thus, each time <b>mkdir</b> is called, our function <b>foobar_inode_mkdir ()</b> will be called. <br><br></li><li>  <u>Add the</u> title of our function to the file ‚Äú/include/linux/lsm_hooks.h‚Äù: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_SECURITY_FOOBAR extern void __init foobar_add_hooks(void); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> static inline void __init foobar_add_hooks(void) { } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  All calls occur in the source security.c file (below), with this step we notify it of the existence of our function. <br><br></li><li>  In the file ‚Äú/security/security.c‚Äù we find the function ‚Äúint __init security_init (void)‚Äù and add the following call to its body: <br><br><pre> <code class="hljs lisp">foobar_add_hooks()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li></ol><br>  Everything, dependences in the code are configured correctly.  It remains only to notify the kernel configuration files that we want to assemble it together with our module. <br><br><h4>  Build Configuration </h4><br><ol><li>  In the folder with our module (/ security / foobar /) create the Kconfig file: <br><br><pre> <code class="hljs pgsql">config SECURITY_FOOBAR <span class="hljs-type"><span class="hljs-type">bool</span></span> "FooBar security module" <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> y help <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span> help <span class="hljs-type"><span class="hljs-type">text</span></span> here</code> </pre><br>  This will create a menu item with our module. <br><br></li><li>  Open the file / security / Kconfig and add the following text immediately after the line ‚Äúmenu‚Äú Security options ‚Äù": <br><br><pre> <code class="hljs pgsql">source <span class="hljs-keyword"><span class="hljs-keyword">security</span></span>/foobar/Kconfig</code> </pre><br>  This will add our menu item to the global kernel settings menu. <br><br></li><li>  Create a Makefile in the folder with our module: <br><br><pre> <code class="hljs mel">obj-$(CONFIG_SECURITY_FOOBAR) += foobar.o</code> </pre><br></li><li>  Open the Makefile of the entire security section (/ security / Makefile) and add the following lines to it (by analogy with the same lines for other modules): <br><br><pre> <code class="hljs mel">subdir-$(CONFIG_SECURITY_FOOBAR) += foobar obj-$(CONFIG_SECURITY_FOOBAR) += foobar/</code> </pre><br></li><li>  Run the configuration in pseudographic mode: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">make</span></span> menuconfig</code> </pre> <br>  If you go to the ‚ÄúSecurity options‚Äù submenu, the first item will be our module, marked with the ‚Äúy‚Äù symbol (we set this default value when we created the Kconfig file), which means that we integrate our module directly into the kernel code. </li></ol><br><h4>  Assembly </h4><br>  At this stage we carry out the most ordinary assembly of the kernel, as it was described at the beginning of the article.  But since we have already pre-assembled a clean core, the process is a bit simpler: <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">make</span></span> modules</code> </pre> <br>  make does not require the -j option, as it rebuilds the kernel with our module in a few seconds. <br><br><pre> <code class="hljs sql">sudo make <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre> <br>  Installation of headers and modules is not required; this was done earlier. <br><br>  Everything! <br><br>  It remains to reboot the system, after which our module with the interception mkdir will hang in the kernel.  As mentioned earlier, we check this: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;my_tag&gt;'</span></span></code> </pre> <br>  Consider that in the system, hiding from your eyes, a lot of processes occur, so do not be surprised when you see there are many interceptions. <br><br>  I hope that this manual will be useful to someone (if someone wrote it instead of me before I started digging into the core, it would save me 2-3 weeks of life). <br><br>  Any criticism is welcome. <br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/318106/">https://habr.com/ru/post/318106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318096/index.html">Ember - Best Practices: Avoid Leaking Condition into the Factory</a></li>
<li><a href="../318098/index.html">Yandex mobile experience in three video courses: design, development, interfaces</a></li>
<li><a href="../318100/index.html">Christmas Easter eggs</a></li>
<li><a href="../318102/index.html">Yii2-advanced: Making internationalization with a source in Redis</a></li>
<li><a href="../318104/index.html">Elixir in bioinformatics</a></li>
<li><a href="../318110/index.html">SPI Flash Programming with Arduino and SD Card</a></li>
<li><a href="../318112/index.html">How IT professionals work. Ilya Kosmodemyansky, PostgreSQL-Consulting LLC</a></li>
<li><a href="../318116/index.html">Three more online Mail.Ru Group courses in open mode</a></li>
<li><a href="../318118/index.html">An example of using the RabbitMQ Delayed Message Exchange in the Java Spring Framework</a></li>
<li><a href="../318120/index.html">Generating dummy data with Mimesis: Part I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>