<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nginx cache: all new - well forgotten old</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the life of each project, the time comes when the server no longer meets the requirements of the SLA and literally begins to choke with the amount ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nginx cache: all new - well forgotten old</h1><div class="post__text post__text-html js-mediator-article">  In the life of each project, the time comes when the server no longer meets the requirements of the SLA and literally begins to choke with the amount of incoming traffic.  Then a long process of finding bottlenecks, heavy queries, incorrectly created indexes, uncached data, or vice versa, too often updated data in the cache and other dark sides of the project begins. <br><br>  But what to do when your code is ‚Äúperfect‚Äù, all heavy requests are brought into the background, all that can be cached, and the server still does not reach the SLA indicators we need?  If there is a possibility, then of course you can buy new cars, distribute some of the traffic and forget about the problem for a while. <br><br>  But if the feeling that your server is capable of more, or if there is a magic parameter that accelerates the work of the site 100 times, then you can recall the built-in feature of nginx, which allows you to cache responses from the backend.  Let's sort through what it is and how it can help increase the number of requests being processed by the server. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What is Nginx cache and how does it work? </h3><br>  Nginx cache can significantly reduce the number of requests for the backend.  This is achieved by storing the HTTP response, for a certain time, and when re-accessing the resource, retrieving it from the cache without proxying the request for the backend.  Caching, even for a short period, will give a significant increase in the number of requests processed by the server. <br><br>  Before proceeding with the nginx configuration, you need to make sure that it is built with the ‚Äúngx_http_proxy_module‚Äù module, since with this module we will configure. <br><br>  For convenience, you can put the configuration in a separate file, for example ‚Äú/etc/nginx/conf.d/cache.conf‚Äù.  Let's take a look at the ‚Äúproxy_cache_path‚Äù directive, which allows you to configure cache storage options. <br><br><pre><code class="hljs swift">proxy_cache_path /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> keys_zone=proxy_cache:15m max_size=1G;</code> </pre> <br>  ‚Äú/ Var / lib / nginx / proxy_cache‚Äù indicates the cache storage path on the server.  It is in this directory that nginx will save those files with the response from the backend.  At the same time, nginx will not create a cache directory on its own, you need to take care of this yourself. <br><br>  ‚ÄúLevels = 1: 2‚Äù - sets the nesting level of cache directories.  Nesting levels are indicated by ‚Äú:‚Äù, in this case 2 directories will be created, in total 3 levels of nesting are permissible.  For each nesting level, values ‚Äã‚Äãfrom 1 to 2 are available, indicating how to form the directory name. <br><br>  The important point is that the directory name is not chosen randomly, but is created based on the file name.  The file name in turn is the result of the md5 function of the cache key; the cache key will be discussed a little later. <br><br>  Let's take a practical look at how the path to the cache file is built: <br><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache/<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">49</span></span>/07edcfe6974569ab4da6634ad4e5d492</code> </pre> <br>  The ‚Äúkeys_zone = proxy_cache: 15m‚Äù parameter sets the name of the zone in shared memory where all active keys and information on them are stored.  The ‚Äú:‚Äù indicates the size of the allocated memory in MB.  As stated by nginx, 1 MB is enough to store 8 thousand keys. <br><br>  ‚ÄúMax_size = 1G‚Äù determines the maximum cache size for all pages, above which nginx will take care of deleting less needed data. <br><br>  It is also possible to control the lifetime of the data in the cache, for this it is sufficient to define the ‚Äúinactive‚Äù parameter of the ‚Äúproxy_cache_path‚Äù directive, which by default is 10 minutes.  If during the time specified in the ‚Äúinactive‚Äù parameter there were no accesses to the cache data, then this data is deleted even if the cache is not yet ‚Äúsour‚Äù. <br><br>  What is this cache?  In fact, this is a regular file on the server, the contents of which are written: <br><br>  ‚Ä¢ cache key; <br>  ‚Ä¢ cache headers; <br>  ‚Ä¢ content response from the backend. <br><br>  If everything is clear with the headers and response from the backend, then there are a number of questions about the ‚Äúcache key‚Äù.  How is it built and how can it be managed? <br><br>  To describe the cache key building pattern in nginx, there is a ‚Äúproxy_cache_key‚Äù directive, in which the string is specified as a parameter.  A string can consist of any variables available in nginx. <br><br>  For example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$request_method</span></span><span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$orig_uri</span></span>:<span class="hljs-variable"><span class="hljs-variable">$cookie_some_cookie</span></span>:<span class="hljs-variable"><span class="hljs-variable">$arg_some_arg</span></span>;</code> </pre> <br>  The ‚Äú:‚Äù symbol between the cookie parameter and the get-parameter is used to prevent collisions between cache keys, you can choose any other symbol to your liking.  By default, nginx uses the following line to generate a key: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>;</code> </pre> <br>  The following directives should be noted to help manage caching more flexibly: <br><br>  <i>proxy_cache_valid</i> - Sets the response caching time.  It is possible to specify a specific response status, for example, 200, 302, 404, etc., or specify everything at once using the ‚Äúany‚Äù construct.  If you specify only the caching time, by default, nginx will cache only 200, 301 and 302 statuses. <br><br>  Example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">15m</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">15s</span></span>;</code> </pre><br>  In this example, we set the cache lifetime to 15 minutes, for status 200, 301, 302 (their nginx uses the default, since we did not specify a specific status).  The next line set the caching time to 15 seconds, only for responses with status 404. <br><br>  <i>proxy_cache_lock</i> - This directive will help to avoid several passes on the backend after a cache set, it is enough to set the value in the ‚Äúon‚Äù position.  All other requests will wait for a response in the cache, or the timeout blocking the request to the page.  Accordingly, all timeouts can be configured. <br><br>  <i>proxy_cache_lock_age</i> - Allows you to set a timeout limit for a response from the server, after which the next request for a set of cache will be sent to it.  The default is 5 seconds. <br><br>  <i>proxy_cache_lock_timeout</i> - Sets the wait time for the lock, after which the request will be transferred to the backend, but the response will not be cached.  The default is 5 seconds. <br><br>  <i>proxy_cache_use_stale</i> - Another useful directive that allows you to configure when it is possible to use an outdated cache. <br><br>  Example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_use_stale</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout updating;</code> </pre> <br>  In this case, it will use the outdated cache in case of a connection error, transfer of the request, reading the response from the server, exceeding the time limit for sending the request, reading the response from the server, or if the data in the cache is updated at the time of the request. <br><br>  <i>proxy_cache_bypass</i> - Sets the conditions under which nginx will not take a response from the cache, but immediately redirect the request to the backend.  If at least one of the parameters is not empty and is not equal to ‚Äú0‚Äù.  Example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_bypass</span></span> <span class="hljs-variable"><span class="hljs-variable">$cookie_nocache</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_nocache</span></span>;</code> </pre> <br>  <i>proxy_no_cache</i> - Sets the condition under which nginx will not save the response from the backend to the cache.  The principle of operation is the same as that of the ‚Äúproxy_cache_bypass‚Äù directive. <br><br><h3>  Possible problems with caching pages </h3><br>  As mentioned above, along with caching the HTTP response, nginx stores the headers received from the backend.  If your site uses a session, then the session cookie will also be cached.  All users who come to the page that you were lucky to cache will receive your personal data stored in the session. <br><br>  The next task to be faced is caching control.  Of course, you can set a small cache time in 2-5 minutes and this will be enough in most cases.  But not in all situations this is applicable, so we will reinvent our bicycle.  Now about everything in order. <br><br>  <b>Cookie Preservation Management</b> <br><br>  Nginx caching imposes some restrictions on development.  For example, we cannot use sessions on cached pages, since the user does not reach the backend, another limitation would be the return of cookies to the backend.  Since nginx caches all headers, in order to avoid saving someone else's session in the cache, we need to prohibit the return of cookies for cached pages.  This is where the ‚Äúproxy_ignore_headers‚Äù directive will help us.  Headers that should be ignored from the backend are listed as an argument. <br><br>  Example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_ignore_headers</span></span> <span class="hljs-string"><span class="hljs-string">"Set-Cookie"</span></span>;</code> </pre> <br>  In this line we ignore the installation of cookies from the proxied server, that is, the user will receive a response without the ‚ÄúSet-Cookies‚Äù header.  Accordingly, everything that the backend tried to write to the cookie will be ignored on the client side, since he will not even know that something was intended for him.  This cookie setting restriction should be considered when developing an application.  For example, for an authorization request, you can disable ignoring the header so that the user gets a session cookie. <br><br>  You should also consider the session lifetime, you can see it in the ‚Äú <i>session.gc_maxlifetime</i> ‚Äù parameter of the php.ini config.  Imagine that a user has logged into the site and has started viewing the news feed, all the data is already in the nginx cache.  After some time, the user notices that his authorization has disappeared and he needs to go through the authorization process again, although all this time he was on the site, looking through the news.  This happened because for all its requests, nginx returned the result from the cache without sending the request to the backend.  Therefore, the backend decided that the user is inactive and after the time specified in ‚Äú <i>session.gc_maxlifetime</i> ‚Äù deleted the session file. <br><br>  To prevent this from happening, we can emulate requests for a backend.  For example, via ajax to send a request that will be guaranteed to pass to the backend.  To go to the backend past the nginx cache, just send a POST request, you can also use the rule from the ‚Äúproxy_cache_bypass‚Äù directive, or simply disable the cache for this page.  The request does not have to give something, it can be a file with a single line starting the session.  The purpose of such a request is to extend the life of the session while the user is on the site, and nginx faithfully gives the cached data to all of its requests. <br><br>  <b>Cache Reset Control</b> <br><br>  First you need to decide on the requirements, what goal we are trying to achieve.  For example, on our site there is a section with text translation of popular sporting events.  When loading the page is given from a cache, further all new messages come on sockets.  In order for the user to see the current messages for the first time at the current time, rather than 15 minutes ago, we need to be able to reset the nginx cache on our own at any time.  In this case, nginx may not be located on the same machine as the application.  Also, one of the requirements for resetting will be the ability to delete the cache on several pages at once. <br><br>  Before you start writing your solution, let's see what nginx offers from the ‚Äúbox‚Äù.  To reset the cache, nginx has a special directive ‚Äúproxy_cache_purge‚Äù, in which the condition of resetting the cache is written.  The condition is actually a regular string, which, with a non-empty value and not a ‚Äú0‚Äù value, will delete the cache using the transferred key.  Consider a small example. <br><br><pre> <code class="hljs perl">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-keyword"><span class="hljs-keyword">m</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> $request_method $purge_method { PURGE <span class="hljs-number"><span class="hljs-number">1</span></span>; default <span class="hljs-number"><span class="hljs-number">0</span></span>; } server { ... location / { proxy_pass http:<span class="hljs-regexp"><span class="hljs-regexp">//backend</span></span>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }</code> </pre><br>  <i>The example is taken from the official site of nginx.</i> <br><br>  The $ purge_method variable is responsible for resetting the cache, which is a condition for the ‚Äúproxy_cache_purge‚Äù directive and is set to ‚Äú0‚Äù by default.  This means that nginx works in ‚Äúnormal‚Äù mode (saves answers from the backend).  But if you change the request method to ‚ÄúPURGE‚Äù, then instead of proxying the request for the backend with saving the answer, you will delete the cache entry by the corresponding caching key.  It is also possible to specify a deletion mask by indicating a ‚Äú*‚Äù sign at the end of the caching key.  Thus, we do not need to know the location of the cache on the disk and the principle of key formation; nginx assumes these responsibilities.  But there are downsides to this approach. <br><br><ul><li>  The ‚Äúproxy_cache_purge‚Äù directive is available as part of a commercial subscription </li><li>  Only a cache point removal is possible, either by a mask of the form {cache key} ‚Äú*‚Äù </li></ul><br>  Since the addresses of cached pages can be completely different, without common parts, the approach with the mask ‚Äú*‚Äù and the directive ‚Äúproxy_cache_purge‚Äù does not suit us.  It remains to recall a bit of theory and discover your favorite ide. <br><br>  We know that nginx cache is a regular file on the server.  We independently specified the directory for storing cache files in the ‚Äúproxy_cache_path‚Äù directive, we even specified the logic of forming the path to the file from this directory using ‚Äúlevels‚Äù.  The only thing we lack is the correct generation of the caching key.  But we can also see it in the ‚Äúproxy_cache_key‚Äù directive.  Now all we have to do is: <br><br><ul><li>  create a full path to the page, exactly as specified in the ‚Äúproxy_cache_key‚Äù directive; </li><li>  encode the resulting string in md5; </li><li>  create subdirectories using the rule from the ‚Äúlevels‚Äù parameter. </li><li>  And here we already have the full path to the cache file not the server.  Now all we have to do is delete the file itself.  From the introductory part, we know that nginx may not be located on the application machine, so you need to be able to delete several addresses at once.  Let us describe the algorithm again: </li><li>  We will write the generated paths to the cache files to a file; </li><li>  We write a simple script on bash, which we put on the machine with the application.  Its task will be to connect via ssh to the server, where we have a caching nginx and delete all cache files specified in the generated file from step 1; </li></ul><br>  Let's move from theory to practice, write a small example illustrating our algorithm of work. <br><br>  Step 1. Creating a file with paths to the cache. <br><br><pre> <code class="hljs perl">$urls = [ <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/111/1:2'</span></span>, <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/112/3:4'</span></span>, ]; function to_nginx_cache_path(url) { $nginxHash = md5($url); $firstDir = <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>($nginxHash, -<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); $secondDir = <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>($nginxHash, -<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/var/lib/nginx/proxy_cache/$firstDir/$secondDir/$nginxHash"</span></span>; } //        tmp $filePath = tempnam(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'nginx_cache_'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      $fileStream = fopen($filePath, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($urls as $url) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      $cachePath = to_nginx_cache_path($url); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       fwrite($fileStream, $cachePath . PHP_EOL); } //     fclose($fileStream); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  bash       <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>(<span class="hljs-string"><span class="hljs-string">"/usr/local/bin/cache_remover $filePath"</span></span>);</code> </pre><br>  Please note that the $ urls variable contains the urls of the cached pages, already in the proxy_cache_key format specified in the nginx config.  Url acts as a kind of tag for the displayed entities on the page.  For example, you can create a regular table in the database, where each entity will be associated with a specific page on which it is displayed.  Then, if we change any data, we can sample the table and delete the cache of all the pages we need. <br><br>  Step 2. Connect to a caching server and delete cache files. <br><br><pre> <code class="hljs smalltalk">#      ,      <span class="hljs-type"><span class="hljs-type">FILE_LIST</span></span>=`cat <span class="hljs-string"><span class="hljs-string">$1</span></span> | tr <span class="hljs-comment"><span class="hljs-comment">"\n"</span></span> <span class="hljs-comment"><span class="hljs-comment">" "</span></span>` #   ssh  <span class="hljs-type"><span class="hljs-type">SSH</span></span>=`which ssh` <span class="hljs-type"><span class="hljs-type">USER</span></span>=<span class="hljs-comment"><span class="hljs-comment">"root"</span></span> #         nginx <span class="hljs-type"><span class="hljs-type">HOST</span></span>=<span class="hljs-comment"><span class="hljs-comment">"10.10.1.0"</span></span> #   <span class="hljs-type"><span class="hljs-type">KEY</span></span>=<span class="hljs-comment"><span class="hljs-comment">"/var/keys/id_rsa"</span></span> # <span class="hljs-type"><span class="hljs-type">SSH</span></span> ,          <span class="hljs-string"><span class="hljs-string">$S</span></span>SH -i <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">KEY</span></span>} <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">USER</span></span>}@<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">HOST</span></span>} <span class="hljs-comment"><span class="hljs-comment">"rm -f ${FILE_LIST}"</span></span> #       rm -rf rm -f <span class="hljs-string"><span class="hljs-string">$1</span></span> #  </code> </pre><br>  The above examples are exploratory in nature, you should not use them in production.  In the examples, input parameter checks and command restrictions are omitted.  One of the problems you may encounter is limiting the length of the ‚Äúrm‚Äù command argument.  When testing in a dev environment on small volumes, this can be easily missed, and in production you can get the error ‚Äúrm: Argument list too long‚Äù. <br><br><h3>  Caching custom blocks </h3><br>  Let's summarize what we managed to do: <br><br><ul><li>  reduced the load on the backend; </li><li>  learned how to manage caching; </li><li>  learned how to flush the cache at any time. </li></ul><br>  But not everything is as good as it might seem at first glance.  Now, probably, if not every first, then exactly every second site has a registration / authorization functionality, after passing which we want to display the user name somewhere in the header.  The block with the name is unique and must display the name of the user under which we are authorized.  Since nginx saves the response from the backend, and in the case of the page it is the html content of the page, the block with personal data will also be cached.  All site visitors will see the name of the first user who passed to the backend after dialing the cache. <br>  Consequently, the backend should not give blocks in which personal information is located so that this information does not fall under the nginx cache. <br><br>  It is necessary to consider alternative loading of such parts of the page.  As always, this can be done in many ways, for example, after loading the page, send an ajax request, and display a loader in the place of personal content.  Another way that we will consider today is the use of ssi tags.  Let's first understand what SSI is, and then how we can use it in conjunction with the nginx cache. <br><br><h3>  What is SSI and how does it work </h3><br>  SSI (Server-Side Includes, server-side inclusions) is a set of commands embedded in the html page that tell the server what to do. <br><br>  Here is a list of such commands (directives): <br><br>  ‚Ä¢ if / elif / else / endif - branching operator; <br>  ‚Ä¢ echo - Displays the values ‚Äã‚Äãof variables; <br>  ‚Ä¢ include - Allows you to insert the contents of another file into the document. <br>  Just about the last directive and will be discussed.  The include directive has two parameters: <br>  ‚Ä¢ file - Indicates the path to the file on the server.  Regarding the current directory; <br>  ‚Ä¢ virtual - Specifies the virtual path to the document on the server. <br><br>  We are interested in the ‚Äúvirtual‚Äù parameter, since it is not always convenient to specify the full path to the file on the server, or in the case of a distributed architecture, there is simply no file on the server.  Example directive: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/user/personal_news/"--&gt;</span></span></code> </pre> <br>  In order for nginx to start processing ssi inserts, it is necessary to modify the location as follows: <br><br><pre> <code class="hljs cs">location / { ssi <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ... }</code> </pre><br>  Now all requests processed by the location ‚Äú/‚Äù will be able to perform ssi inserts. <br><br>  How in all this circuit will pass our request? <br><br><ul><li>  customer requests page; </li><li>  Nginx proxies the request for the backend; </li><li>  backend gives page with ssi inserts; </li><li>  the result is stored in the cache; </li><li>  Nginx ‚Äúdozaprashivaet‚Äù the missing blocks; </li><li>  the summary page is sent to the client. </li></ul><br>  As you can see from the steps, the ssi constructions will get into the nginx cache, which will allow not to cache personal blocks, and the ready-made html page with all the inserts will be sent to the client.  Here our podgruzka works, nginx independently requests the missing blocks of the page.  But like any other solution, this approach has its pros and cons.  Imagine that there are several blocks on a page that should be displayed differently depending on the user, then each such block will be replaced by an ssi insert.  Nginx, as expected, will request each such block from the backend, that is, one request from the user will generate several requests for the backend at once, which we would not like at all. <br><br><h3>  We get rid of constant requests to the backend via ssi </h3><br>  To solve this problem, the nginx ‚Äúngx_http_memcached_module‚Äù module will help us.  The module allows you to receive values ‚Äã‚Äãfrom the memcached server.  Writing through the module will not work, the application server should take care of this.  Consider a small example of configuring nginx in conjunction with a module: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /page { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$memcached_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uri</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:11211</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">502</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> = <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; } }</code> </pre><br>  In the $ memcache_key variable, we specified the key by which nginx will try to get data from memcache.  The parameters for connecting to the memcache server are specified in the ‚Äúmemcached_pass‚Äù directive.  Connection can be specified in several ways: <br><br>  ‚Ä¢ Domain name; <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">memcached_pass</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cache</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span>;</code> </pre> <br>  ‚Ä¢ IP address and port; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> localhost:<span class="hljs-number"><span class="hljs-number">11211</span></span>;</code> </pre> <br>  ‚Ä¢ unix socket; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> unix:/tmp/memcached.socket;</code> </pre> <br>  ‚Ä¢ upstream directive. <br><br><pre> <code class="hljs axapta">upstream cachestream { hash $request_uri consistent; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; } location / { ... memcached_pass cachestream; ... }</code> </pre><br>  If nginx managed to get a response from the cache server, then it gives it to the client.  In the case when there is no data in the cache, the request will be transferred to the backend via ‚Äú@fallback‚Äù.  This small configuration of the memcached module under nginx will help us reduce the number of requests for the backend from ssi inserts. <br><br>  We hope this article was useful and we were able to show one of the ways to optimize server load, to review the basic principles of configuring nginx caching and to close the problems that arise when using it. </div><p>Source: <a href="https://habr.com/ru/post/428127/">https://habr.com/ru/post/428127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428117/index.html">Google's free tensor processors in the cloud laboratory</a></li>
<li><a href="../428119/index.html">Class-fields-proposal or What went wrong on the tc39 committer</a></li>
<li><a href="../428121/index.html">Stan Drapkin. High-level cryptography hooks in .NET</a></li>
<li><a href="../428123/index.html">Security Week 41: Good News</a></li>
<li><a href="../428125/index.html">Who are the product analysts and why are they needed in the team?</a></li>
<li><a href="../428129/index.html">Simple fuzzy logic blinded "from what it was" for a gas turbine engine</a></li>
<li><a href="../428131/index.html">The whole truth about the RTOS. Article # 17. Event flag groups: introduction and basic services</a></li>
<li><a href="../428133/index.html">Hasura. High-Performance GraphQL to SQL Server Architecture</a></li>
<li><a href="../428135/index.html">How to configure or disable lint in the built-in code editor</a></li>
<li><a href="../428137/index.html">Olympiad, idea competition, lectures on IT project management and film screenings: 10 upcoming events at ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>