<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tarantool: how to save a million dollars on a database on a high-load project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anikin Denis ( danikin , Mail.Ru ) 


 Today I will tell you how to save a lot of money on databases, for example, a million dollars, as we did. To be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tarantool: how to save a million dollars on a database on a high-load project</h1><div class="post__text post__text-html js-mediator-article"><h2>  Anikin Denis ( <a href="https://habrahabr.ru/users/danikin/" class="user_link">danikin</a> , <a href="https://habrahabr.ru/company/mailru/">Mail.Ru</a> ) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/2c8/293/c162c82937e82b6bbfcee6318da298cd.jpg" alt="Denis anikin"><br><br>  Today I will tell you how to save a lot of money on databases, for example, a million dollars, as we did.  To begin with, the question is: why are databases using more often, and not files? <br><br>  A database is a repository that is more structured than a file and has some features that the file does not have. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/308/ab6/0df/308ab60df7fc8c989a2f29b83bbb3c38.png"><br><br>  There you can make queries, there are transactions, indexing, tables, stable, more or less reliable storage.  In fact, databases are more convenient than files. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/150101571" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Imagine you have an application, it works with a database, it loads this database only for reading so far, i.e.  there is not a very large number of records, but a large number of selektov. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b24/fd6/337/b24fd63373089599c83908e41a729257.png"><br><br>  In the end, your database is overloaded and cannot handle the load. <br><br>  What usually do in such cases?  Another server.  This is replication.  That is, in fact, you deliver replicas exactly in such quantity that they hold your load. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/5ab/2b1/9ef5ab2b11efe551ac1c34c1399746e2.png"><br><br>  You take all the load on reading to the replicas.  Accordingly, the load on the record you leave on the master.  This scheme can, in principle, scale the load on reading almost to infinity. <br><br>  Then we have a load on the record. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f7/b85/729/5f7b85729cf597981951c576f97641d7.png"><br><br>  And the load on the record, again, reaches a certain limit, when the database can no longer hold it.  Will replication help in this case?  Not.  Whatever the replication ‚Äî master slave or master-master ‚Äî it does not help the load on the records, because each record must go through to all servers.  Even if there is a master-master there, it means that how many requests you have in total for your entire cluster, exactly the same amount will go to each of the servers, i.e.  you won‚Äôt win. <br><br>  What other ideas are there? <br><br>  Sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ee/0b8/bb3/3ee0b8bb3c2de496dbc3b6466637fb72.png"><br><br>  In fact, sharding can solve the problem of the load on the record and scale almost indefinitely. <br><br>  There are many different ways of sharding - you can cut through databases, you can cut into tables, you can cut inside a single table.  Ways - a million.  Everyone uses the method that is more convenient for him. <br><br>  In fact, you get such a two-dimensional cluster of databases, i.e.  you have many, many shards, and each has several cues.  You deliver shards, cues, and vary completely any load. <br><br>  But then you have a problem.  Your next problem is your boss.  What he might not like about it?  It seems like everything is working, everything is being shaded, replicated, but what does he not like?  Money.  He likes everything, except that it is very expensive, because you deliver, deliver, deliver the server, and he pays for it. <br><br>  You say to him: ‚ÄúDude, you do not understand, I have technology here, I have sharding, replication ... It scales endlessly - this is a very cool system.‚Äù <br><br>  He tells you: ‚ÄúYes, yes, but we lose money, if it goes on like this, we simply will not have money to buy a database server.  We will have to close. " <br><br>  What to do? <br><br>  In fact, the load on the database is often arranged in such a way that some data elements for reading are loaded very, very much - they are called ‚Äúhot data‚Äù. <br><br>  Caching is something that partially solves our problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/900/cb6/3ec/900cb63ecb24dcb23d4afacf8e3a9e25.png"><br><br>  You can remove some of the replicas and thus slightly satisfy your boss.  By the way, you get the best lietensi, i.e.  queries work faster because the cache is faster than databases. <br><br>  But ... what's the problem?  The inconsistency problem is one of the biggest problems with the cache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98d/ef0/67e/98def067e0c220b632bcc10262a5346d.png"><br><br>  This is the very first problem that is immediately visible. <br><br>  See, you have an application separately writes to the cache, for example, to Memcached and separately writes to the database.  Those.  the cache is not a replica of the base, the cache is a separate entity.  There are arrows between the cache and the base, which are actually virtual, i.e.  there is no replication between them.  Everything is done at the application level.  Accordingly, this leads to inconsistency of data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d7/a3e/279/8d7a3e2797b839c5802028fdeb14f7b9.png"><br><br>  And, by the way, you still have sharding, because the write cache does not optimize, because nothing can be stored in the cache, everything flies through it into the database.  Well, not through, but to the side of it, but it flies by. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c1/079/aab/8c1079aaba2ca3872f2a393e41d9f1a8.png"><br><br>  There is a picture to show you that you can write first to the base, then to the cache, or first to the cache, then to the base.  In both cases you will have an inconsistency.  Look: you write the data to the cache, then your application safely drops and does not have time to write them into the database.  The application rises and works with data that is already in the cache, but not in the database, but no one knows about it.  When the cache reloads (and it ever reboots), you get outdated data from the database when the cache is empty. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/883/1fc/d74/8831fcd741959f6c2b9bc818701caa89.png"><br><br>  Strangely enough, if you write in the reverse order - first to the database, then to the cache, there will be exactly the same problem: we recorded the database, the application fell, the old data is in the cache, everything works with the old data, the cache rebooted, pulled new data from the database , as if another data branch, which are not complete, which do not correspond to the changes that were made on top of another copy ... <br><br>  Those.  There are at least two problems with the cache: there is no data integrity, and you still need sharding. <br><br>  What other problems with the cache?  What problems did you have with the cache the moment your boss started to get angry?  The problem is this: the cache is not a database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b4/c1d/755/4b4c1d7555e58f082f93b9666863ce7c.png"><br><br>  You had a database before the cache, there were requests, transactions, and all these things from the cache almost all disappear, your application is already working with the cache.  Indices and tables remain, not all caches have secondary indexes, not all caches have tables, but somehow crookedly obliquely over the key-value, both of them can be supported, so we believe that these properties are observed, and the rest is not. <br><br>  Now, regarding the problem of incompleteness of data.  What to do with it?  How to make the data updated in the cache and database holistically?  Smart cache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/481/0ca/962/4810ca962658e8ca85fcd673f1755a23.png"><br><br>  What is smart cache?  In fact, many of you are most likely doing this - in fact, this is the cache that communicates with the database itself.  Those.  This is not a separate Memcached daemon, but some kind of your own samopisny daemon, which inside itself caches everything and writes to the database itself.  The application does not write to the database, it works completely through the cache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c80/c62/b7f/c80c62b7f816fe0b1fe41fdf9305ba86.png"><br><br>  This solves the problem of incompleteness, because the cache first writes to the database, and then writes to itself.  If he did not write to the database, he gave an error - everything is fine.  This is certainly not good, but the data is complete.  After the cache is written to the database, it will write the data in itself, because it writes to the memory, such that the data are not written to the memory almost never happens.  Rather, it happens when the memory is beating on the server and at that moment everything drops, and you still lose the entire cache, at least the data integrity is not lost. <br><br>  But there is one case when you can lose data even with such a smart cache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31b/5af/305/31b5af3059b2d6c276e67d57574da5e2.png"><br><br>  The application writes to the cache, the cache writes to the database, the database internally applies this entry, then it gives the answer to the cache, and at that moment the network breaks.  The cache considers that the entry to the database failed, does not write data to itself, gives the user an error.  After that, the cache begins to work with the data that is in it, and after reloading it, it picks up the outdated data from the database again. <br><br>  This is a rare case, but this also happens.  Those.  smart cache does not completely solve the problem of data integrity.  And you still need sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/727/d9a/d9f727d9a704c57c2e5b0a8a586bed84.png"><br><br>  A sharding is when you have a database that is on the same server and you just cut it.  You cut it into pieces and put these pieces on different servers, physical servers.  This reduces the load on the record, because the load on the record goes to a specific piece.  Those.  you have, in fact, all the CPUs, for example, all servers are involved in processing this load, and not the CPU of just one server. <br><br>  You still have a sharding, and you remember that your boss does not like sharding, because it is very expensive, because there are many, many servers and everyone has replicas. <br><br>  So, the non-integrity of the data, unfortunately, remains with the cache, sharding is still needed, there are no database properties. <br><br>  What else is a very unpleasant problem with the cache?  Cold start. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/113/de1/153/113de1153d268e519436bdc0b0131498.png"><br><br>  This is a super unpleasant problem when the cache rises from scratch, clean, naked, without data ... It is useless, just like a car completely covered with snow - you first need to climb into it, and still have to start it.  A cold start completely kills the cache, all requests go directly to the database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/85d/5af/a5085d5af3fac5ef4eb87a446aa30ef5.png"><br><br>  You have to do an action that, again, your boss does not approve, but what can you do?  You have to deliver replicas just to warm up the cache.  In fact, this layer of replicas - for each shard you deliver by replica - just to warm up the cache.  You can not disable these servers or throw out when the cache is warmed up, because suddenly the server with the cache will restart at night?  Anyway, everything should work at night, these servers should immediately go to workload and ensure the cache warms up.  The cache warmed up, and they are no longer needed, but again they will not put them anywhere. <br><br>  Four cache issues: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc6/df5/6b3/bc6df56b3145f35810bd0f3bdb9d841a.png"><br><br>  Question: how to warm up the cache?  The cache should always be heated to make sense.  It is somehow not neatly warmed up through the database, because there are many, many replicas, and they all warm it ‚Äî warm it ‚Äî they heat it too much. <br><br>  Persistence is the right word.  It is better to simply not cool the cache, it needs to be persistent, because the cache is a good and fast solution, except for a few problems, including the problem of cold start, including the fact that it is sometimes underheated, so let it always be warmed.  Like, for example, in Siberia some people do not jam their cars so that they are always running, because otherwise you will not start it later - approximately from the same opera. <br><br>  What is the easiest way to cache persist? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/822/051/942/8220519429025c9003a5b91f8fb3744e.png"><br><br>  This is just a dump of data.  That is, in fact, every time we, maybe, in a minute, or, for example, once every 5 minutes, we dump the entire cache completely to disk, completely right.  How do you like this solution?  Sucks because consistency is lost.  You dump every 5 minutes, your server seems to be rising, and it loses its change in 5 minutes.  It is impossible to warm them through the database, and it is not even clear where these changes come from.  And this is not the only problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/565/a16/ec1/565a16ec1f79d24d0559f89705be8833.png"><br><br>  The second problem is that according to IOPS it will be bad, i.e.  You will constantly load the disk.  Dumps, dumps and again dumps, permanent.  The more you want more complete data, the more often you dump.  Some not very pleasant way. <br><br>  What is the best persistence cache? <br><br>  Log  You just need to keep a log. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/90f/9f7/d7f90f9f71c8f872b4d49e2556e985da.png"><br><br>  Those.  why should we dump, let's keep a log, let's every cache change be logged to disk, every. <br><br>  If you think that it is slow (there is always an opinion that the cache is something so fast, and when a disk appears there, then it becomes somehow slow), and so, in fact, it is not slow, because even the most usual spinning magnetic disk, not SSD, writes at a speed of 100 Mb / s, writes sequentially.  If the transaction size is, say, 100 bytes, then it is 1 million transactions per second.  This is an incredible speed that will satisfy almost everyone in this audience, maybe even me.  Therefore, even one disk copes with this task perfectly, but there is another problem that this log grows very strongly, because, for example, there are 10 inserts, then 10 delites of the same data, they should all collapse, but they do not collapse in the log .  Or there are 100 updates of the same data item, again, only the last one is needed, and everything is stored in the log.  How to solve this problem?  Snaps do. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d80/02a/c9dd8002ac76a00ef032ef7f2847fd1e.png"><br><br>  It is necessary to combine these two methods - Dump and Log together.  Those.  we dump once a week, or when we want it, and the rest of the time we just write a log.  In the dump, we still remember the id of the last applied record from the log or the last record from the log, which is still in this snapshot.  And when our server reboots, we bring up the dump from the disk, restore it in memory and roll above the piece of log that is after this recording.  All cache restored and warmed up immediately. <br><br>  By the way, this warming up is faster than from the database.  This kind of warming up during a reboot will then completely fall into the disk, because this linear reading of the file is 100 MB / s.  Even on magnetic disks it is very fast. <br><br>  Everything, the problem of cold start is solved, but this is only one problem, unfortunately.  Although the cache is warm, there are 3 more problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a07/def/cf8/a07defcf84590b229002837b05339639.png"><br><br>  Let's think about how to solve the first two - problems of inconsistency and sharding? <br><br>  The idea of ‚Äã‚Äãusing a cache as a database is a very good direction.  Indeed, why do we have our main database in this place?  MySQL or Oracle - why do we need it?  Let's think about it. <br><br>  Need, probably, for 2 things: <br><br><ol><li>  we believe that the database reliably stores data, not as a cache, but reliably, i.e.  there must be some magic there; </li><li>  That there is replication in the database.  Caches do not usually have replication.  Accordingly, the server's cache failed or simply rebooted, and until it picks up everything from the disk, it is faster than warming up, but it will still be down time - this is also bad, and there is no replication there. </li></ol><br>  On the first point - reliable storage.  If you figure out what the database stores?  The database stores hot and cold data ‚Äî essentially all that it stores.  Hot data is usually small, small, and very, very hot, with 10-100 thousand RPS, and cold data are so large and cold, and there are very few references to them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/655/633/e10/655633e10f48e15b5b7521ffcdd228e1.png"><br><br>  It always happens that the cold data is big and the hot data is small.  This is the law of life. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc7/c0a/976/dc7c0a976606a20873f5c9a13c85125b.png"><br><br>  In fact, you replicate and shard your database in a large number of copies only to process this small piece of hot data, because there is not a lot of queries to the rest of the cold data, it feels fine.  But you only replicate all this for the sake of hot data. <br><br>  Why do we do all this copying?  Can we probably copy only hot data? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7a/5c4/9d1/d7a5c49d1739e52ffa63f4a5f8eb07d5.png"><br><br>  But even here, the same problem - because the load goes exactly to the hot data and therefore, if you replicate and shard only them, the problem will not disappear anywhere, you need exactly the same number of servers to handle all this huge load. <br><br>  And your boss is still angry because you still have sharding. <br><br>  In fact, we say that databases reliably store data, but our cache now also reliably stores data, because it has a transaction log file in which all changes are written.  This is nothing more than a transaction log, this is the same as any database, it is exactly what ensures reliable storage in any database, no magic, and the cache has the same thing. <br><br>  No replication.  This, of course, is bad, but let's think about why a cache cannot be the primary source of data?  Because there is no replication?  Well, we will do it. <br><br>  Why can't the cache be the primary data source?  Because it does not have database properties?  We can also do this, we can support all these properties of databases, and the cache will have them.  Remember the picture ‚ÄúCache is not a database‚Äù? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ca/32f/d99/1ca32fd9978c63794d150cc6b98767c4.png"><br><br>  Cache can be a database.  He can have all these properties. <br><br>  You need to keep only hot data in the cache, where there are many, many hits, because you shard and replicate this cold data along with the entire database just to serve the hot data.  But if you only shard hot data, this will not solve the problem, because it all the same rests on the number of requests for hot data, that is, the cache can be a database. <br><br>  Actually, what we did and called this database Tarantool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffe/146/fbb/ffe146fbb36294e3b17d88be78c5aa11.png"><br><br>  We have developed a special database for hot data, which is a cache, but it also has persistents, transactions (the same as adult databases), replication, it even has stored procedures.  Those.  Tarantool has all the basic properties of the database.  And so we use it as the primary source for hot data.  We do not duplicate this data anywhere.  We have Tarantool, it has a replica, this data is backed up, as well as for any database, but they are not duplicated anywhere, in any other databases.  This is always a hot cache with a persistent and with database properties, i.e.  He solves all these problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f1/994/f0f/0f1994f0f092636d865717a374a531d6.png"><br><br>  In fact, we do not need now all these hundreds of servers with sharding and replicas, we just have our task divided, <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/3b6/90c/6103b690c6c0e326d6a3968e337ef57b.png"><br><br>  We simply use the right tool for the right task, i.e.  cold data is stored in storage.  For example, in SQL repositories that were created decades ago for cold data, because then there were no such number of requests per second for data, no one thought about it.  And the hot data is stored in the storage, which is specially designed for hot data in Tarantool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/c0f/3ef/7dac0f3ef55e6135376115f56ccd7873.png"><br><br>  Here, in principle, everything is written on the slide - our way through which we went, but the fact is that for most tasks 2 instances of the whole Tarantool were enough - one master, the second - a replica, because the load that goes to one of databases, on one instance, it will most likely provide your entire bandwidth, which used to go all your SQL Server cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf6/1a5/7a9/bf61a57a9200f4f188031a639853dd07.png"><br><br>  And here is another psychological point - I don‚Äôt really want to leave the cozy world of databases in the uncomfortable new world of caches.  In a transaction database, etc.  Then, when your boss is angry, you delivered the cache and somehow immediately became uncomfortable.  And just Tarantool returns this comfort, i.e.  he, moreover, solves the problems of inconstancy and cold start.  He, as it were, takes you back to the world of databases for hot data. <br><br>  Now the case in the mail Mail.ru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d0/e91/60d/8d0e9160d5d6f0609b0b986aff0cdaa5.png"><br><br>  The case was this: we needed to store user profiles.  User profiles are such small pieces of information - from 500 bytes to 1 KB per user.  We initially began to use MySQL for this business.  And they began to duplicate all the load on the profiles that we previously had in the old repository, for reading and writing to the farm from MySQL.  We set up a farm of 16 MySQL, we all went ahead and put a load in there.  And it turned out that at 1/8 of our entire load, these 16 servers rested on the shelves.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basically, they rested on the shelf on the processor. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c0/d49/4b4/1c0d494b4dbb2d72ca9168d91cf97dc5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We tried to tune them this way and that, but in fact, all that we have achieved is 16 servers at 1/8 of the load, i.e. for the entire cluster, 128 MySQL servers would be required for the entire load. We thought it was a little expensive - more than 1 million dollars. And we just put several servers with Tarantool and let all the load go there. For test purposes, duplicated. And it turned out that they are pulling it all without any problems. Even one server was enough. Put just 4, because the master, replica + a couple more, just in case. We usually relocate always on load.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, here it is saving a million dollars - we just 60 times reduced the number of servers we need. In this case, even the user has become better, because the caches usually work with the best leytensi. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/94a/96b/18a94a96b76db59ef4efa2b6e112153d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a total of more than 120 Tarantool instances in the cloud and mail, servers directly from Tarantool, which are used for different features, for a very large number of features. If we all stored it in MySQL or in any other SQL, then it would be hundreds of millions of dollars, simply if you extrapolate the available figures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The moral of my entire speech: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to use the right tool to work properly</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. You need to use databases for cold data and persistent caches, like Tarantool, for hot data. And save on this $ 1 million.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/e6d/bf0/28be6dbf088c54929fb56068bd6ebd10.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a brief summary of what we have done. </font><font style="vertical-align: inherit;">We sharpened, replicated, rested against money, started caching, lost consistency and one more thing ... We made a persistent cache, it is not a database, but it can be a database, separated hot from cold data, cold in MySQL, hot in Tarantool, saved $ 1 million and, as a bonus, got the best user experience, because everything became faster.</font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anikin@corp.mail.ru</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/users/danikin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">danikin</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/company/mailru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru company blog</font></font></a> <br><br><blockquote> <font color="gray">  ‚Äî           <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad++</a> .      2016  ‚Äî    HighLoad++   , 7  8 . <br><br>         " <a href="http://www.highload.ru/2016/abstracts/2268.html"> Tarantool  ?</a> ".    :)       ‚Äî ¬´  ,     !¬ª :) , ! <br><br>    HighLoad++     <a href="https://tarantool.org/">Tarantool</a> .      ()  ,  ,  . <br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/310690/">https://habr.com/ru/post/310690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310678/index.html">Digital Agency 2.0 - How to become a boutique agency out of the pipeline</a></li>
<li><a href="../310680/index.html">The book "Multiplayer games. Network Application Development</a></li>
<li><a href="../310684/index.html">Freeform real-time speech recognition and call recording recognition</a></li>
<li><a href="../310686/index.html">Launch of Azure Pack Infrastructure cloud from InfoboxCloud</a></li>
<li><a href="../310688/index.html">How we did a search in elasticsearch on vulners.com</a></li>
<li><a href="../310692/index.html">Review of the best reports from the conference "Around the Cloud"</a></li>
<li><a href="../310694/index.html">System scripts in php for linux, we write a screenshot</a></li>
<li><a href="../310696/index.html">On-demand synchronization implementation</a></li>
<li><a href="../310698/index.html">How the server works with a screwdriver in the power supply</a></li>
<li><a href="../310702/index.html">DBMS era of the Internet of things</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>