<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of pseudo-3D in racing games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Why pseudo-3d? 

 Why would anyone want to create roads in the old school style today, when every computer can draw graphics consisting...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of pseudo-3D in racing games</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/885/034/247/8850342476fe46648474d819ba082581.gif"></div><br><h2>  Introduction </h2><br>  <u><b>Why pseudo-3d?</b></u> <br><br>  Why would anyone want to create roads in the old school style today, when every computer can draw graphics consisting of millions of polygons on the fly?  Are polygons not the same, only better?  Not really.  Polygons do create less distortion, but it is the deformations in the old game engines that give such a surreal, dizzying sense of speed, felt in many additional poly games.  Imagine that the scope is controlled by a camera.  When moving along a curve in a game using one of these engines, it looks like it is looking at a curve.  Then, when the road becomes straight, the view also straightens.  When driving in a corner with a poor view, the camera seems to be looking behind the ledge.  And since such games do not use the traditional format of tracks with exact spatial ratios, you can easily create tracks on which the player will ride at breathtaking speed.  You do not need to worry about the fact that objects appear on the track faster than the player can react, because the physical reality of the game can be easily changed according to the gameplay style. <br><br>  But in such a system there are many shortcomings.  The depth of physics used in simulation games will be lost, so these engines are not adapted for these games.  However, they are simple to implement, work fast, and games based on them are usually very interesting! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is worth noting that not every old racing game uses these techniques.  In fact, the method described in the article is only one of the ways to create a pseudo-three-dimensional road.  In other cases, projected and scaled sprites or various ways of actually projecting the road are used.  The degree of mixing real mathematics with tricks depends on the creators.  I hope you enjoy exploring the special effect I proposed. <br><a name="habracut"></a><br>  <u><b>How well do you need to understand math?</b></u> <br><br>  If you‚Ä¶ <br><br>  ... you know trigonometry, then it will be quite enough to understand the whole tutorial <br>  ... you know only algebra and geometry, then skip the ‚Äúscope‚Äù explanation <br>  ... you want to avoid mathematical explanations, then read the sections ‚ÄúThe Simplest Road‚Äù, ‚ÄúCurves and Turns‚Äù, ‚ÄúSprites and Data‚Äù and ‚ÄúHills‚Äù. <br><br>  This is a universal technique, and you can understand in more detail simply by adding the appropriate sections.  If you know complicated math, then you will be interested, but if you know only arithmetic, you can reach the level of detail created in games such as the Pole Position or the first OutRun. <br><br>  <u><b>How well do you need to know programming?</b></u> <br><br>  If you understand raster graphics, this will greatly help: it is enough to know what a scanline is, and that each line consists of a number of pixels.  Examples of programs are written in pseudocode, so knowledge of a particular language is not required. <br><br>  Ready?  Let's get started! <br><br>  <u><b>Raster effects: short introduction</b></u> <br><br>  The pseudo-three-dimensional road is one of the cases of a more general class of effects, called raster effects.  The most famous of the raster effects are used in Street Fighter II: when moving the fighters left or right, the surface of the earth changes in perspective.  But this is not really 3D.  Surface graphics are stored as a very wide angle shot.  When scrolling, lines of the screen that are ‚Äúfarther away‚Äù move more slowly than closer ones.  That is, each line on the screen moves independently of the other.  Below is the final result and how the graphics of the earth's surface are stored in memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5cc/95f/424/5cc95f424a9ffc1659373ea4eaa333b0.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c29/7d5/10e/c297d510e1737d0433596042a7f78b5a.png"><br><br><h2>  Basics of creating roads </h2><br>  <u><b>Introduction to raster roads</b></u> <br><br>  We are accustomed to perceive 3D-effects in the framework of polygons, whose peaks are suspended in three-dimensional space.  However, old computers were not powerful enough to cope with a large number of three-dimensional calculations.  Therefore, raster effects were used most often in old games.  These are special effects created by line-by-line change of a variable.  This is well suited for the operation of old graphics hardware, which had hardware acceleration of scrolling and used the mode of indexed colors. <br><br>  The pseudo-road raster effect was actually created in much the same way as the perspective effect in Street Fighter II, where the static image was deformed to add the illusion of three-dimensionality.  Here is how it was implemented: <br><br>  Most raster roads begin with a flat road image.  In essence, this is a graphic depiction of two parallel lines on the ground, stretching into the distance.  At distance, these lines seem to be connecting to the observer.  This is the basic rule of perspective.  In addition, to create the illusion of movement, most of the arcade racing games on the road were drawing stripes.  The movement of these lanes on the road was achieved either by cyclically switching colors or changing the palette of each row.  Curves and turns were performed by scrolling each line independently, as in Street Fighter II. <br><br>  We will look at curves and turns in the next section.  In the meantime, let's concentrate on scrolling the road forward. <br><br>  <u><b>Simplest road</b></u> <br><br>  Take the image of the road described above: two parallel lines denoting the right and left side of the road, stretching into the distance.  Moving away from the observer, they are getting closer.  Here is an example of what this might look like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/f5d/1ae/c41f5d1ae9b31657a6d9d94979972f2f.png"><br><br>  This image lacks road markings that create a good sense of perspective.  For this effect, in games, in addition to other road markings, alternating dark and light stripes are used.  To add them, let's define the ‚Äútexture position‚Äù variable.  This variable is zero at the bottom of the screen and increases its value with each line up.  When its value is below a certain number, the road is drawn in one shade.  When the value is above this number, it is drawn in a different shade.  After the maximum value is exceeded, the position variable is again equal to zero, creating a repeating pattern. <br><br>  However, changing it for each line is not enough, because then you will get only a few bands of different colors, which do not decrease with the removal of the road.  So, we need another variable that will change by a specified amount.  It needs to be added to another variable each line, and then add the last to the change in the position of the texture. <br><br>  Here is an example of how the value of Z changes for each line when moving into the distance.  After the variables, I wrote what I need to add to get the values ‚Äã‚Äãfor the next line.  I called the values ‚Äã‚ÄãDDZ (delta-Z), DZ (delta-Z), and Z. DDZ remains constant, DZ varies linearly, and Z - along the curve.  It is possible to consider the Z coordinate of the Z position, DZ the position velocity, and DDZ the position acceleration (change in acceleration).  Note that the value "4" is chosen arbitrarily, because it is convenient for this example. <br><br> <code>DDZ = 4 DZ = 0 Z = 0 : dz += 4, z += 4&lt;br&gt; <br> DDZ = 4 DZ = 4 Z = 4 : dz += 4, z += 8&lt;br&gt; <br> DDZ = 4 DZ = 8 Z = 12 : dz += 4, z += 12&lt;br&gt; <br> DDZ = 4 DZ = 12 Z = 24 : dz += 4, z += 16&lt;br&gt; <br> DDZ = 4 DZ = 16 Z = 40 :  ..</code> <br> <br>  Notice that DZ changes first, and then it is used to change Z. This can be explained as follows: let's say we are moving in texture at speed 4. This means that after the first line we read the texture in position 4. The next line will be in position 12. After it is 24. Thus, the passage through the texture is going faster and faster.  That's why I call these variables the ‚Äútexture position‚Äù (the place of the texture that we read), the ‚Äútexture speed‚Äù (how fast we go through the texture) and the ‚Äútexture acceleration‚Äù (how fast the texture speed changes). <br><br>  We use a similar method for drawing curves and hills without too many calculations.  Now, to create the illusion of texture movement, you just need to change the beginning of the texture position at the bottom of the screen for each frame. <br><br>  You may notice the disadvantage of this trick: the scaling factor is not accurate.  This leads to a distortion, which I will call the "oatmeal effect."  Such a deformation effect was present in early pseudo-three-dimensional games, for example, in OutRun: objects, including stripes on the road, seemed to slow down when moving from the center of the screen to the outside. <br><br>  This method of finding the value of Z has another drawback: it is not easy to predict what the value will be at each distance, especially when using hills.  We will learn a more complicated way, which I call the Z-map (Z-map).  This is a table that calculates the distance Z for each raster line of the screen.  But first, we need some more mathematics ... <br><br>  <u><b>Excursion into mathematics: a projection of a three-dimensional perspective</b></u> <br><br>  There are ways to get rid of the effect of oatmeal.  However, their implementation requires knowledge of traditional three-dimensional mathematics.  We need to find a way to translate the 3D coordinates so that they can be positioned on a 2D surface. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/5c1/d80/0305c1d80c52fbc1e66b8fa03ad7232d.png"><br><br>  In the figure above, the eye (in the lower left corner) looks through the screen (blue vertical line) at an object in our three-dimensional world (‚Äúy_world‚Äù).  The eye is at a distance of "dist" from the screen, and at a distance of "z_world" from the object.  If you were engaged in geometry or trigonometry, you might have noticed that there are not two triangles in the picture.  The first triangle is large, from the eye to the surface to the right and up to the object that the eye is looking at.  I painted the second triangle yellow.  It is formed by the eye, a point on the screen in which we see an object, and a surface. <br><br>  The hypotenuses of these two triangles (the lines from the eye to the object) are at one angle, although one is longer than the other.  In essence, it is the same triangle, only scaled down.  This means that the ratio of horizontal and vertical sides will be the same!  In a mathematical notation: <br><br> <code>y_screen/dist = y_world/z_world</code> <br> <br>  Now we need to convert the equation to get y_screen.  We get: <br><br><p> <code>y_screen = (y_world*dist)/z_world</code> <br> <br>  That is, to find the y coordinate of the object on the screen, we take the y coordinate of the world, multiply it by the distance from the eye to the screen, and then divide by the distance in the world.  Of course, if we do this, then the center of the look will be in the upper left corner of the screen!  To verify this, it suffices to substitute y_world = 0.  For centering, you need to add half the screen resolution to the result.  The equation can be slightly simplified if we imagine that the nose is pressed against the screen.  In this case, dist = 1.  It turns out the following equation: <br><br> <code>y_screen = (y_world/z_world) + (y_resolution/2)</code> <br> <br>  There is a relationship between the ratios and viewing angle, as well as image scaling, so that it does not depend on the screen resolution.  But to solve the problem with the road, we will not need it.  If you're interested, look at the diagram in top view: the angle to the edge of the screen is the scope, and the same connection is maintained. <br><br>  <u><b>More math: adding scope to a three-dimensional projection</b></u> <br><br>  In general, this is <b>usually not necessary</b> for most "road" engines.  But this is useful so that the projection parameters do not depend on the resolution, or for objects that need to be rotated, or to integrate with genuine 3D effects. <br><br>  Let's go back to the original projection formula.  The ‚Äúdist‚Äù value of the equations above will be called ‚Äúscaling‚Äù here: <br><br> <code>y_screen = (y_world*scaling)/z_world + (y_resolution/2)</code> <br> <br>  The idea is that we need to scale all the points on the screen by a certain amount, which will allow the points to remain visible within the field of view (field-of-view, FOV).  For the x axis of the FOV and the y axis of the FOV, two constants will be needed. <br><br>  For example, suppose we are working in a resolution of 640x480 and want the FOV to be 60 degrees.  We saw the scheme of a three-dimensional projection in the side view.  For this case, let's look at the diagram of the projected space in the top view: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/334/9d6/883/3349d68837b1ab25186533112860560c.png"><br>  One way to solve the problem is to assume that if the object is on the right side of our FOV, it should be displayed on the screen at x = 640 (because the screen resolution is 640x480).  If you look at the scheme, you can see that FOV can be divided into two right triangles, in which the angle of each is equal to fov_angle / 2 (a / 2).  And since our FOV is a cone, the object located on the right edge of the FOV, i.e.  x = R * sin (a / 2) and <br>  z = R * cos (a / 2), where R is any radius value.  We can, for example, take R = 1.  And we need the object to be displayed on the screen at x_screen = 640.  We get the following (taking into account the basic projection formula): <br><br> <code>x_screen=640 fov_angle=60 y_world=sin(60/2) z_world=(60/2) x_resolution/2=320 scaling=? <br> <br> x_screen = (y_world*scaling)/z_world + (x_resolution/2) <br> <br> 640 = (sin(30)*scaling/cos(30)) + 320 <br> <br> 320 = tan(30)*scaling <br> <br> 320/tan(30) = scaling <br> <br>   : scaling = (x_resolution/2) / tan(fov_angle/2)</code> <br> <br>  We replaced a / 2 with 30 (half of 60 degrees), denoted as sin / cos = tan, and voila!  You can check this by placing the object at the right end of the scope, substituting these values ‚Äã‚Äãinto the original projection equation and making sure that X takes the value 640. For example, the point (x, z) with coordinates (20, 34.64) will be at X = 640, because that 20 is 40 * sin (30), and 34.64 is 40 * cos (30). <br><br>  It should be noted that the FOV values ‚Äã‚Äãfor the horizontal (x) and vertical (y) axes will be different for a standard and widescreen monitor in a horizontal position. <br><br>  <u><b>More accurate road: using the Z-card</b></u> <br><br>  To solve the perspective problem, we need to create a pre-computed list of distances for each line of the screen.  In short, the problem is in describing the plane in 3D. <br><br>  To understand how this works, imagine first a two-dimensional analog: the line!  To describe the horizontal line in 2D, we can say that for each pair of coordinates (x, y) the y coordinate will be the same. <br><br>  If we bring it into three-dimensional space, the line will become a plane: for each distance x and z, the coordinate y will remain the same!  If we consider a flat horizontal surface, it does not matter how far the camera is located, y will be constant.  It also does not matter how far the point is to the left or right, the value of y will always be the same. <br><br>  Let us return to clarifying the distance to each of the lines of the screen: let's call our list a Z-card.  The question of calculating the Z-map is to convert the three-dimensional projection formula to find the value of Z for each screen Y! <br><br>  First, take the equation from the previous section: <br><br> <code>Y_screen = (Y_world / Z) + (y_resolution / 2)</code> <br> <br>  Since we have Y_screen (each line), we transform the equation to find Z: <br><br> <code>Z = Y_world / (Y_screen - (height_screen / 2))</code> <br> <br>  Y_world as a whole is the difference between the ground level and the height of the camera, which will be negative.  It is the same for each line, because, as stated in the introductory paragraph, we are still interested in a flat road.  Besides the fact that the road will look more clearly and avoid the ‚Äúoatmeal effect‚Äù, there is another advantage: the simplicity of calculating the maximum rendering distance. <br><br>  The road is located on the screen by reading this buffer: for each distance, you need to find out what part of the road texture belongs to it, noting how many units each line or pixel of the texture takes. <br><br>  Although we know the distance for each row of the screen, it may be useful to cache for each row or the width of the road, or the scaling factor.  The scaling factor is opposite to the distance chosen in such a way that the value on the line in which the graphic image of the player‚Äôs machine is the most is 1. It can be used to scale the sprites on a given line or to determine the width of the road. <br><br></p><h2>  Curves and turns </h2><br>  <u><b>Create bends</b></u> <br><br>  To make the road curve, you just need to change the position of the center line in the shape of the curve.  For this you can use a couple of ways.  One way is the same way that the Z positions were created in the ‚ÄúSimplest Road‚Äù section: using three variables.  That is, starting from the bottom of the screen, the amount by which the center of the road moves to the left or right of each line is steadily increasing.  As with texture reading, we can consider these variables as the position of the center line (curve), the speed of the curve, and the acceleration of the curve. <br><br>  However, this method has problems.  One of them is that it is not very convenient to create S-shaped curves.  Another limitation: the entrance to the turn looks exactly the same as the way out of it: the road is bent, and then just unbent. <br><br>  To improve the situation, you can introduce the concept of road segments.  The road segment is a part invisible to the player.  It can be considered an invisible horizontal separator, which sets the curvature of the road above this line.  At any point in time, one of these segment dividers is at the bottom of the screen, and the other goes down at a constant rate to the very bottom.  Let's call the lower segment the base segment, because it sets the initial curvature of the road.  Here's how it works: <br><br>  When we start to draw the road, we start by looking at the base point and, accordingly, set the drawing parameters.  As the turn of his segment approaches, the line of the segment is at a distance and approaches the player almost like any other road object, except that it has to descend down the screen at a constant pace.  That is, at a specific speed with which the player moves, the segment divider descends down the screen by the same number of lines per frame.  Or, if a Z-map is used, for the same number of z-map elements per frame.  If the segment ‚Äúaccelerated‚Äù towards the player, as they do 3d-objects on the track, the road would be bent too sharply. <br><br>  Let's see how it works.  Suppose the line segment for the left curve is down halfway down, and the base segment is just a straight road.  When drawing the road, it will not start to bend until it collides with the ‚Äúleft curve‚Äù segment.  Then the road curve begins to change with the pace indicated by this point.  When the moving segment reaches the bottom of the screen, it becomes the new base segment, and the previous base segment rises to the top of the road. <br><br>  Two roads are shown below: one straight, followed by a left turn, and the other with a bend to the left, followed by a straight.  In both these cases, the position of the segment is halfway down the Z-map (or halfway down the screen).  In other words, the road starts to bend or become straight halfway down the road.  In the first picture, the camera enters a turn, and in the second it goes out of it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76d/bcd/86b/76dbcd86be230013cd468bc0950c6070.png"><img src="https://habrastorage.org/getpro/habr/post_images/965/d98/12e/965d9812ea39600d45712fc938205e3d.png"><br><br>  But the same technique and the same position of the segment, applied to the S-shaped curve: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fd/9de/fc5/6fd9defc50713b76c84ad00b1087aa73.png"><br><br>  The best way to track the position of a segment is to determine where it is on the Z map.  That is, do not tie the position of the segment to the position Y on the screen, but tie it to the position on the Z-map.  Thus, it will still begin on the horizon of the road, but it will be much more convenient to work with hills.  It should be noted that on a flat road without changing heights, these two methods of tracking the position of a segment are similar. <br><br>  Let's illustrate the above with the code: <br><br><pre> <code class="hljs ruby">current_x = <span class="hljs-number"><span class="hljs-number">160</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/    320 dx = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    ddx = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      ,  :      Z-  segment.position:    dx = bottom_segment.dx       Z -  segment.position:    dx = segment.dx   ""  ddx += dx  current_x += ddx  this_line.x = current_x  "" /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   segment_y += constant * speed /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,         segment.position &lt; 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 0 -   bottom_segment = segment  segment.position = zmap.length - 1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         segment.dx = GetNextDxFromTrack() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         ""</span></span></code> </pre> <br>  One of the great advantages of realizing curves in this way is that if there is a curve followed by a straight road, then the player will be able to see the straight road when exiting the curve.  Similarly, if a curve is followed by a curve in a different direction (or even a more curved curve in the same direction), then the player can see this next section of the course before falling on it. <br><br>  For the illusion to be complete, you need to add horizon graphics.  With the approach of the curve the horizon does not change (or moves slightly).  Then, when the curve is completely drawn, it is assumed that the machine turns along it, and the horizon quickly scrolls in the opposite direction of the curve.  When the curve straightens again, the background continues to scroll until the curve ends.  If you use segments, you can simply scroll (scroll) the horizon in accordance with the settings of the base segment. <br><br>  <u><b>The general formula for curves</b></u> <br><br>  Having studied the technique of curves, described in detail in the ‚ÄúSimplest Road‚Äù section, we can make an interesting conclusion.  This conclusion is more relevant to mathematics than to the material presented above, and you can safely skip it if your graphics engine should not be resolution independent or use the ‚Äú3d-projected segments‚Äù technique discussed in the section on hills. <br><br>  Considering an example of a curve using ‚ÄúZ‚Äù from the ‚ÄúSimplest Road‚Äù section, you can see that the z-position (or x-position) of a given string is the sum of an increasing series of numbers (for example, 1 + 2 + 3 + 4).  Such a series is called an arithmetic series or an arithmetic progression.  If you use instead of 1 + 2 + 3 + 4, for example 2 + 4 + 6 + 8 or 2 * 1 + 2 * 2 + 2 * 3 + 2 * 4, you can get a sharper curve.  ‚Äú2‚Äù in this case is the variable segment.dx.  It can also be factorized by getting 2 (1 + 2 + 3 + 4)!  Now all you have to do is find a formula describing 1 + 2 + ... + N, where N is the number of lines that make up the curve.  It is known that the sum of an arithmetic progression is equal to N (N + 1) / 2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the formula can be written as s = A * [N (N + 1) / 2], where A is the sharpness of the curve, and s is the sum. This equation can still be converted to add a starting point, for example, the center of the road below the screen. If we denote it by ‚Äúx‚Äù, then we get s = x + A * [N (N + 1) / 2]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have a formula to describe the curve. We want to get an answer to the question ‚Äúknowing the starting point x and N lines of the curve, what should A be, so that the curve reaches s at the end of the x-position?‚Äù Transforming the equation to find A, we get A = 2 (s - x) / [n (n + 1)]. This means that the sharpness of a given curve can be stored relative to the X position, which makes the graphics engine independent of resolution. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turns in perspective style</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is much less interesting when, when turning in the game, only the sprite of the car moves. </font><font style="vertical-align: inherit;">Therefore, instead of moving the sprite of the player‚Äôs car, we will leave it in the center of the screen and move the road, and more importantly, move the position of the center line in the front (i.e., lower) part of the screen. </font><font style="vertical-align: inherit;">Now we assume that the player will always look at the road, so we will make the road end in the center of the screen. </font><font style="vertical-align: inherit;">To do this, you will need a variable angle of the road. </font><font style="vertical-align: inherit;">Therefore, we calculate the difference between the center of the screen and the position of the front of the road, and then we divide the road schedules into heights. </font><font style="vertical-align: inherit;">This will give us the amount to move the center of the road on each line.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites and data </font></font></h2><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Positioning objects and scaling</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites need to be drawn from behind in front. Sometimes this method is called</font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D1%2585%25D1%2583%25D0%25B4%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the artist's algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To do this, you must determine in advance where on the screen each object should be drawn, and then draw objects at different stages.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done in the following way: when we go over the Z-map while drawing the road, we also need to note which line of the screen each sprite should be associated with. If the sprites were sorted by Z, this is trivial: each time you read a new Z-map value, you need to check whether the Z position of the next sprite is closer to the camera than the current Z-map value, or if they are equal. If this is the case, then you should mark the sprite's Y screen position as belonging to the current line. Then check out the next sprite in the same way. Continue this process until we get a sprite from the list, whose Z position is further than the current one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The position of the X object must be tracked relative to the center of the road. Then the simplest method of horizontal positioning of the sprite is to multiply the value by the scale factor of the current line (the reciprocal of Z) and add the result to the center of the road. </font></font><br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storing route data</font></font></u></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When I did my first demo with the road, I stored the level information in the list of events that should occur at certain distances. Of course, distances were indicated in units of the position of the texture. Events consisted of commands start and end curves. As I recall, the speed at which the road begins and ends to bend is arbitrary. The only rule is that it should correspond to the speed of the player‚Äôs car.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if you are using a system with segmentation, you can simply use a list of commands. The distance each team takes is similar to the speed at which the invisible segment moves to the bottom of the screen. It also allows you to create a route format that works for a tile map that allows you to transfer a fairly realistic track geography. That is, each tile can be one segment. A sharp turn can turn the track 90 degrees, and smoother - 45 degrees. </font></font><br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road texturing</font></font></u></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you may want to use on the road a real graphic texture instead of the changing lines that we have created at the moment. For this you can use a couple of ways. Cheap and easy way: prepare a couple of textures for the road (for the effect of changing lines). When drawing each horizontal line of the road, you need to stretch the texture to match the width of this line. Or, if stretching is not possible, you must select a string from one of two full bit images of the road (the approach used by the Outrunners). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want the road to look more accurate, make it so that Z for each line corresponds to the line number of the graphic texture. And voila! A single over-the-road road!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if you only need stripes of alternating colors, the answer is even simpler, especially when using a fixed point. For each Z you need to make one of the bits represent the shade of the road (dark or light). Then just draw the appropriate road drawing from the flowers for that bit.</font></font><br><br><h2>  The hills </h2><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variations of the hills</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that there are an almost infinite number of ways to create the effects of the hills. Hill effects can be created with a wide range of geometric precision, with some less accurate techniques creating more convincing results. We will consider two possible ways.</font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fake Hills</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After a lot of experiments, I came to a flexible way to mimic the hills, which uses few calculations. In addition, it accurately tracks objects below the horizon. This is the effect of scaling and distortion, vertically stretching and compressing the road. To generate the curvature of the hill, it uses the same summation trick used to draw the curves.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's how to do it: first, the draw cycle should start from the beginning of the Z-card (nearest) and stop when it reaches the end (farthest). If we decrease the position of rendering each line by 1, the road will be drawn flat. However, if you reduce the position of rendering each line by 2, doubling the lines in the aisle, then the road will be drawn twice as high. And, finally, by varying the value of the decrement of the position of drawing each line, you can draw a hill, starting as a plane and rising up. If the next drawing position is farther from the current drawing position by more than one line, then the current Z-map line is repeated until we reach it, creating a scaling effect.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descents from the hills are made in a similar way: if the position of the drawing increases, not decreases, then we will sink below the last drawn line. Of course, the lines below the horizon will not be visible on the screen. Only lines that are one or more pixels above the last row are drawn. However, we still need to track objects below the horizon. To do this, you need to take into account the position Y of each sprite when walking around the Z-map. Creating a Z-card, more than is necessary for a flat road, can help. Thus, when stretching the buffer, it will not become too pixelated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to move the horizon so that the picture is convincing for the player. </font><font style="vertical-align: inherit;">I love to use the background in the style of the game ‚ÄúLotus‚Äù: in it the horizon not only consists of the outlines of the sky, but also of the graphics of a distant land. </font><font style="vertical-align: inherit;">When the hill goes up (increasing the field of view), the horizon should descend slightly down from the top of the road. </font><font style="vertical-align: inherit;">When the hill goes down and the camera "rests" on the hill (limiting the field of view), the horizon should rise up. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's what the effect looks like for descending from a hill and climbing onto it, of course, without horizon charts:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8e/d28/0ff/c8ed280ffbcbfea7f6d95116977f787a.png"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7d5/5d0/a997d55d01376e6bec870f99f56f8042.png"><br><br>  <b>pros</b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Low calculation load: no multiplication or division required </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objects on the back of the hill are tracked. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that the viewing angle follows the player passing through the hills. </font></font></li></ul><br>  <b>Minuses</b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accurate 3D geometry is not possible. </font></font></li><li>        </li></ul><br><h2>  :     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such formulas of curves with accumulation can be used flexibly if you do not need insane curves or huge hills. In many games that use such tricks, the road scrolls so fast that even a small curve looks convincing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, to create a more impressive road you may need to exaggerate the effect. You can use high ddx or ddy in any of these curve formulas, but dx or dy should not exceed reasonable values. YouTube user Foppygames found another trick creating steeper curves from these formulas with accumulation: for each row, multiply the value of dx or dy by the value of z! This makes the curve more steep at a distance than it is in the foreground, and creates a </font></font><a href="http://www.youtube.com/watch%3Fv%3DmL5yJ5K13po"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rather convincing effect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the experiments don't end there. In fact, the best thing about these engines is that there are no ‚Äúright‚Äù ways to implement them. Anything that creates nice looking curves and bends, is strongly encouraged! In my first road engine, I used a sine wave lookup table to bend the road. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also use multiplication: to shift the road to the right, you can, for example, multiply the x position by 1.01 for each row. To shift to the left by the same amount, multiply by 0.99 or 1 / 1.01 (the reciprocal of 1.01). However, armed with the knowledge that many old processors did not have multiplication operations or were weak in it, I stopped on the accumulation technique, because it only uses addition. It seemed to me a more "authentic" way to create the bends of the road.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some games, for example, in OutRun, even the system of simple splines is used (at least judging by the excellent port on C ++ </font></font><a href="http://reassembler.blogspot.com/p/cannonball-open-source-outrun-engine.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cannonball</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> made on the basis of reverse engineering </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, playing and experimenting, you can choose the most suitable technique for you! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... or continue reading to find out the tricky trick mixing 3d-polygons. It is almost as fast, even more convincing and can be reproduced on the same old raster equipment. Intrigued?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Real 3d projected segments </font></font></h2><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparing 3d projected segments and raster roads</font></font></u></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raster roads are beautiful, but they can be made even more impressive by using a simple polygon rendering method. This rendering method can ‚Äúpull‚Äù even the same weak raster equipment. However, it uses more computation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This trick is known to be used in games like</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Road Rash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test Drive II: The Duel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">That's what it is: the track consists of polygonal segments. </font><font style="vertical-align: inherit;">However, instead of moving in full 3d-space, they only move relative to the camera. </font><font style="vertical-align: inherit;">For curves, the road still leans to the left or right, almost the same as on raster roads: there is no real rotation that would be present when turning on a curve in a fully polygonal engine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a brief explanation of the principle:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since the curves and angles of the roads are still simulated, costly rotation calculations will not be needed. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In essence, the road is a strip of quadrangles: each section of the road is connected to the next section. </font><font style="vertical-align: inherit;">This means that we can calculate the visibility of a part of the road only on the basis of its screen position Y relative to the previous neighbor.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The relationship between these quadrilaterals never changes. </font><font style="vertical-align: inherit;">That is, the angle never actually changes, so the quadrangles are always and automatically sorted by Z.</font></font></li></ul><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple 3d-road</font></font></u></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, we divide the road into polygonal quadrangles. </font><font style="vertical-align: inherit;">Each of them will be called a segment. </font><font style="vertical-align: inherit;">Like a segment in a fully raster road, here each segment still has a curve (ddx), and either a hill (ddy), or a position y, which determines its height. </font><font style="vertical-align: inherit;">Of course, they may have other attributes, such as a change in surface graphics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below shows a segmented road made up of a small number of polygons. </font><font style="vertical-align: inherit;">Therefore, we can easily see the boundaries between the segments and how they affect the curvature of the road:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/37d/0f5/46a/37d0f546a805c5e6f06060682ef78c2e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When rendering, we first find the position of y on the screen of each 3d segment using the formula screen_y = world_y / z. Or if the division is too slow, then you can find the height above the ground of a given segment by multiplying the height of the segment by the scaling factor for this row. Then it can be subtracted from the reverse z-map (this map is the answer to the question: what will y be for each z position of the flat road?) To find the final position on the screen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then you need to linearly interpolate the width of the road and the texture (if required) between these heights. Understanding which 3d segments need to be drawn and which are not can be very simple: a three-dimensional segment will not be drawn from the front to the back of the screen, whose screen_y value is projected as less than the last three-dimensional segment drawn (however, its sprites can still be visible because they are issued - do not forget about it). </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrolling road</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to learn how to scroll through these segments, move the entire volume of polygons moving towards the camera. When the nearest polygon segment passes through the camera, you need to move all the way back to the starting point so that it closes. This is similar to how you can implement scrolling of a two-dimensional tile field by scrolling up one tile, and when it is reached, all tiles are shifted and new data of the tile map is loaded. Here we scroll up one segment, and when it is reached, we move the road back and load the new road data.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is another very important detail: for example, the road has a sharp curve. You may have noticed that when it bends around this polygonal curve, it fluctuates at the moment of crossing the border of the segments and the road is then cleared. This happens for an obvious reason: when passing through a curved segment, the center of the camera is associated with changes in the road. That is, by the time we reach the end of this segment, the road will no longer be centered. It looks as if we are driving at an angle. You may be tempted to correct this by moving the road to the center by simply interpolating the positions of x objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However this </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and does not solve the problem completely: if the road is curved in a straight line, everything will be fine. The problem is that the road is curving, so the polygons are not built at a distance! In other words, we approximate a curve using polygonal segments. We want the shape of the curve to be more or less constant, even when scrolling. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jake on </font></font><a href="http://www.codeincomplete.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codeincomplete.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a </font></font><a href="http://codeincomplete.com/posts/2012/6/24/javascript_racer_v2_curves/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">great solution to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this problem. Instead of changing the position of the x road while moving along a segment, it is worth changing the initial dx value from 0 to something that keeps the road in the center when driving along the segment. To do this, use the following formula: The </font></font><br><br> <code>dx = -percentage_of_segment_traversed * ddx</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">percentage of the segment can be in the range from 0 to 1.0 and returns to its original value when the camera crosses the segments.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of mathematics, this makes X expensive as a function of its Z. In other words, we maintain the same curve shape, regardless of how the approximation points scroll. </font><font style="vertical-align: inherit;">The frontmost segment is ‚Äúdragged into place‚Äù with the rest of the road, and this means that the subsequent position of the X segments is placed correctly. </font><font style="vertical-align: inherit;">You will notice this clearly if you test the way with a road of several polygons. </font><font style="vertical-align: inherit;">This solves the following problems during the passage of the segment (assuming that the shape of the curve does not change):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The center of the road (position x) remains constant </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The dx is adjusted so that the next segment starts at the correct x position regardless of the scrolling position of the road. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The video illustrates this technique. </font><font style="vertical-align: inherit;">I used a small number of segments and a very sharp curve to demonstrate the method. </font><font style="vertical-align: inherit;">Note that when moving polygons to the player, they create the perfect curve shape. </font><font style="vertical-align: inherit;">This is more obvious if you follow the right side of the road.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E1PEOg50Zn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprites placement</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, sprites on this three-dimensional segment should still be displayed and properly cropped - if you accept that you are doing your own renderer and do not use the Z-buffer. </font><font style="vertical-align: inherit;">In fact, the sprites can be drawn at the last stage: if the sprite is on a fully visible segment, it does not need to be cut off, because it comes straight from the ground, which is our only polygon.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if the sprite is on a segment that is invisible or partially visible, then we can easily cut it off. First find the top of the sprite. Then each line of the sprite will be drawn until it collides with the last visible screen position of the Y segment. That is, if there is a segment behind the sprite that should cover its part, then we stop rendering the sprite when we reach this line. And if the top of the sprite is below the Y position of the last segment, then the sprite will be completely invisible and can be skipped. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variations and rendering technology</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After we have introduced the term </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polygons</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it may be tempting to believe that polygon rendering procedures are needed to work with them. Technologies such as OpenGL or a simple trapezoid rendering procedure will do just fine. But even tile and sprite two-dimensional equipment will be quite enough for this.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that each beginning and each end of the road segment is completely horizontal. This means that they always begin and end on a single scan line. Almost the same way as a fully pseudo-three-dimensional road is rendered on tile equipment by scrolling flat road graphics, you can repeat this technique for three-dimensional segments. For more on this, see the section ‚ÄúSpecial Road Equipment‚Äù. Although it considers the equipment of arcade machines, originally intended for drawing the effects of the road, the same technique can be recreated in simple two-dimensional sprite systems using vertical scrolling of the road graphics along with the horizontal one. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional reading about three-dimensional projected segments</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since my demonstration of such a variation is not yet ready, I recommend studying the </font></font><a href="http://codeincomplete.com/posts/2012/6/23/javascript_racer_v1_straight/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amazing Code inComplete manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you are interested in the details of this technique.</font></font><br><br>  <b>pros</b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For hills, you can use real three-dimensional geometry, which significantly increases the number of possible parts. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A more holistic system: changes in the width of the earth and the road do not need to be performed in different techniques </font></font></li></ul><br>  <b>Minuses</b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Need more calculations </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You need to use a decent number of segments, otherwise the road will look like a deformed and polygonal one. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accomplishment </font></font></h2><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiple roads</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Most arcade racing games handle many roads at once. </font><font style="vertical-align: inherit;">Although the most obvious reason for this is the presence of several roads on the screen at the same time, but in this way other effects can be achieved. </font><font style="vertical-align: inherit;">For example, in OutRun, several roads are used to create a six-lane highway. </font><font style="vertical-align: inherit;">This allows the game to easily expand and narrow the road, as well as create convenient ramifications. </font><font style="vertical-align: inherit;">In this case, two roads are superimposed on each other, and one of them is given priority for drawing. </font><font style="vertical-align: inherit;">Here is the famous beginning of the OutRun with and without two roads (look at the right side of the bushes):</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/6de/a54/4ea6dea54522a336ffe2f05e186d9ca5.png"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/430/057/1ae430057d34b320fafcdd56568d7fe8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, more importantly, below is an example of a highway on which two roads are laid to create six lanes, with and without the second road:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d03/77b/cfb/d0377bcfbcebda74a1a26b5010c0277e.png"><img src="https://habrastorage.org/getpro/habr/post_images/b89/255/07f/b8925507f939c6afa26f6678d785abc0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Similar effects </font></font></h2><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infinite ‚Äúchessboard‚Äù The</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> infinite ‚Äúchessboard‚Äù in the Space Harrier arcade game is a simple variation of the road creation technique. As in the case of roads, the game contains graphics of lines approaching the player in a perspective projection. In fact, Space Harrier uses the same equipment as the Hang-On.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The pictures below show the Space Harrier chessboard effect with palette changes and no changes. To turn it into a chessboard, you just need to change the color palette every few lines. This is similar to the light and dark stripes on the road.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/89e/44f/09d/89e44f09d3176fef0574cab57a2e1df6.png"><img src="https://habrastorage.org/getpro/habr/post_images/051/9e5/de9/0519e5de97703bf7cee4f521e557aca7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about scrolling left and right? </font><font style="vertical-align: inherit;">This is just a variation of the turns in a perspective style: when a player moves to the left or right, the graphics of the earth are warped. </font><font style="vertical-align: inherit;">After a few pixels slip, the earth "resets" or "collapses" its position. </font><font style="vertical-align: inherit;">Therefore, it seems that it scrolls to the left or the right indefinitely.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Case study </font></font></h2><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special equipment for roads</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despite the fact that there are many ways to render roads, it is interesting that many arcade games used equipment designed specifically for this purpose. </font><font style="vertical-align: inherit;">These chips automate the principles of drawing roads, but not the road calculations themselves. </font><font style="vertical-align: inherit;">A typical example is Sega's OutRun road chip used in games such as Super Hang-on, Outrun, and Space Harrier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the chip had its own graphics memory. In this road ROM, a perspective view of the road was practically kept, flat, centered and without curvature. The programmer approximately indicated for each line of the screen that line of perspective graphics that needs to be drawn. Each line also had an X offset (for the curvature of the road) and each line had a different color palette (for drawing road markings and motion simulations). To demonstrate the example, here are some road graphics from the Sega racing game along with the road that was displayed in the game (special thanks to Charles MacDonald for his road viewing application):</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea6/33c/0de/ea633c0de9e0e205a2429e4a88949d87.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b5/052/59a/2b505259a93a5ccb305a1aecb9411bf3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/68f/f9f/89968ff9f8e1079b7e84f073901d9b4d.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/6de/a54/4ea6dea54522a336ffe2f05e186d9ca5.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/257/0c7/92f/2570c792f2a7b5e6e2b8c1651c03dc77.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/89e/44f/09d/89e44f09d3176fef0574cab57a2e1df6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing you might notice is that the road graphics have a much higher resolution than the game graphics. In these examples, the road has a resolution of up to 512x256, and the resolution of the game display is only 320x224. This gives the graphics engine a sufficient amount of graphics to reduce the amount of distortion. You may also notice that the perspective of the road stored in the ROM is completely different from the perspective displayed in the game. This happened because the graphics in the ROM only stores how the road may look at different widths of the road. The choice of the necessary lines for each line of the screen from a large graphic image is the task of the program.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The equipment supports two roads at the same time, so you can assign priority to the left or right road. This is necessary for those parts of the game in which the road forks, or when the central divider is located between the lanes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are hacking a ROM, you can study examples of ‚Äúroad‚Äù chips in the MAME files src / mame / video / segaic16.c and src / mame / video / taitoic.c. Note that the Sega road graphics is stored in a two-bit planar format, and the center of the graphics may have a fourth color (the yellow line shown in the figures above). </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enduro</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enduro is a great game. It was released in 1983 for an incredibly weak gaming console of the 70s. But she still manages to create a convincing effect of the road, complemented by changes in the weather and the alternation of day and night. In addition, this game is exciting even today! </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/ad4/522/60fad4522f5fcd06239f1f1a802693b9.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enduro Screenshot</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As we can see, Enduro is a little different from the road engines we reviewed. Immediately it becomes obvious that the road is drawn only by contours: the land on the sides of the road is not drawn in a different color. There are also no obstacles on the sides. If you play Enduro, you may notice that the road does not move in perspective. Instead, the sprite of the player‚Äôs cars and the road are shifted left and right, creating the illusion of turns.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To better understand why Enduro looks that way, let's look at the limitations of the Atari 2600. The Atari 2600 console was designed for Combat (tank game) and Pong games. Therefore, it could only display two sprites, two squares denoting the projectiles of each player, a square representing the ball, and a low-resolution background.</font></font> And it's all. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what is remarkable about Atari video equipment is that it is essentially one-dimensional: the program must update the graphics for each scan line itself. For example, to draw a sprite, the programmer needed to load a new line of graphics to display at the beginning of each development line. To draw a ball object, the programmer needed to turn on the ball when the TV beam was on the desired line, and turn off the ball when the beam approached a line on which the ball is no longer visible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This led to an important side effect: a solid vertical line could be drawn down the screen, turning on the ball or projectile, and then not turning it off! If the programmer moved these objects on each line, then diagonal lines could be drawn.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now back to our topic. You can draw a road using background blocks, but the resolution is too low to be effective. Therefore, in Atari racing games, two graphic objects of a projectile or ball were used to draw the left and right sides of the road, almost the same way they could be used to draw lines. Enduro, in particular, used the sprit of the projectile of the first player and the sprite of the ball to draw the left and right sides. In the Pole Position, both projectile sprites were used to draw the sides of the road, and then the ball sprite was used to draw the dotted line in the center. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d94/3f0/0d4/d943f00d48f1736d125c04a7046aaecd.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshots of the Pole Position at 2600 for comparison</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not discuss how objects moved on the Atari 2600 line by line. The Atari graphics chip had a function called HMOVE (horizontal move, horizontal shift). He allowed the programmer to very easily set the offset of each line for all objects. The programmer needed only to indicate how many pixels different objects need to move, then call HMOVE, and voila - they all moved according to the desired values!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Enduro, this function was used to draw curves. In short, Enduro created a table in memory of how the HMOVE values ‚Äã‚Äãof the left and right sides change when the screen is drawn. It occupied almost half of the available memory of the Atari 2600. Since the memory of the Atari was so small, this value was read only for every four lines. For the left and right sides of the road two different tables were used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the road is straight, all the array values ‚Äã‚Äãfor the right side of the road were equal to 8. HMOVE uses only the top 4 bits, so the value 8 loaded in HMOVE did not move the sides of the road. The lower 4 bits were used as an approximate fixed-point form. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, here‚Äôs what a curve looks like in memory as it approaches (the horizon is the end of the array): </font></font><br><br> <code>08,08,08,08,08,08,0a,0a,0b,0c,0e,0d,0e,0e,0f,10,13,11,12,13,14,17,16,17</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the next frame:</font></font><br><br> <code>08,08,09,09,0a,0a,0b,0b,0c,0d,0d,0e,0f,0f,10,11,12,12,13,14,15,16,17,18</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the increasing values ‚Äã‚Äãof the curve gradually overwrite the smaller values, shifting to the front of the screen to create the illusion that the curve is approaching the player. </font><font style="vertical-align: inherit;">And what does Enduro do with this data? </font><font style="vertical-align: inherit;">Here is the part when used to record the curve for the right side of the road. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each line of a road sweep:</font></font><br><br><pre> <code class="hljs mel">LDA $be ;     $be AND #$0f ;   <span class="hljs-number"><span class="hljs-number">4</span></span>  (   HMOVE) ADC $e4,x ;      (X -        ) STA $be ;    (         ,     ) STA HMBL ;      Horizontal Motion - Ball (  )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does this code do? </font><font style="vertical-align: inherit;">So, $ be is a counter for an increasing curve value. </font><font style="vertical-align: inherit;">When it loads, the upper 4 bits are discarded, leaving a range from 0 to 16 ($ 0-F). </font><font style="vertical-align: inherit;">Then the curve table entry corresponding to this scan line is loaded and added. </font><font style="vertical-align: inherit;">At the end, it is stored in the counter and loaded into the horizontal shift register for the ball object (right side of the road).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this way we achieve several actions. First, the sides of the road move every two lines only when the road is straight: if the array consists only of the values ‚Äã‚Äã8 and $ be on the first line contains 0, then the next line will contain 8 (the upper nibble is still 0). The next line after it will contain $ 10. But when $ 10 is loaded again into register A on the next sweep line, the upper nibble is discarded, leaving 0 again! As a result, the counter alternately takes values ‚Äã‚Äãof $ 10 and 8. Since HMOVE values ‚Äã‚Äãuse only the upper 4 bytes, the string is alternately shifted to 0 or 1 position.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, okay, what if the whole array consists of nines, and not eights? Here's what happens: the first line of the sweep 9 is saved to the ball's HMOVE register and written back to the counter. On the next line, 9 is again added to the value from the table, resulting in $ 12 (decimal 18). This will move the ball to 1 (the top 4 bits are 1). On the line after it, the upper nibble is discarded, leaving 2. Adding 9 from the table, we get $ B. Let's look at another scan line. The value B is loaded. There is no high nibble. Adding 9, we get $ 14 (20).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sequence described above is 09,12,0b, 14. It will cause the ball to move every second line to these 4 lines. But gradually the lower nibble will be big enough for the procedure to shift the ball sprite two lines in the column to the left. The template will then collapse, but after a few more lines, the side of the road will again shift to two lines in the column. In essence, this is an example of simple and extremely fast fixed-point math.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another obstacle in the implementation of the road system on such weak equipment: the positioning of sprites. In more complex systems, sprites can be positioned horizontally on the road as a percentage of the road width. But this requires multiplication with a fixed or floating point, and these operations are performed very slowly in the processor 6502. For comparison, Enduro has only three possible positions for machines, which saves computational resources. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road rash</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both Road Rash and Road Rash on 3do have awesome graphics engines. The original version of the game for Genesis provided a feeling of relatively accurate three-dimensionality on the Genesis 68000 processor with a frequency of 7.25 MHz, and also coped with scaling objects on the road in real time. The 3do version was no less surprising, because it turned out to be a mixture of 3D and pseudo-3D techniques. They were expertly combined, giving the player an amazing sense of speed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned above, the Road Rash and Road Rash engines for 3do were a mix of 3D tricks and pseudo-3D tricks. They used a technique similar to that described in the section ‚ÄúReal 3d-projected segments‚Äù: hills are in 3D space, and road curves are not. Road Rash curves use the same method described in this article, and each road segment has its own DDX or x-acceleration value. Each segment also has a height relative to the height of the last segment. There are 50 segments on the screen at the same time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But Road Rash for 3do is really interesting because the programmers added a collapse that reinforces the sensation of speed: objects away from the camera move slower, and objects near the camera move faster.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roadside Rash for 3do also added polygonal objects on the sidelines, whose X coordinates are still relative to the road. They are used to create hills, buildings, and other complex elements. It takes a large amount of data, so the geometry and textures are loaded from disk in the process of passing the road. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STUN Runner: The arcade machines against the Lynx</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STUN Runner at the time of release on the arcade machines in 1989 was an amazing game. It used the technology of a fully three-dimensional polygons with a fill. She invited the player to take control of a futuristic racing machine, flying through the winding corridors at breakneck speed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little later, I saw a version for the Atari Lynx. </font><font style="vertical-align: inherit;">The Atari Lynx was a portable system that was released around the same time as the original Game Boy. </font><font style="vertical-align: inherit;">As in the Game Boy, it has an 8-bit processor at 4 MHz. </font><font style="vertical-align: inherit;">So the port was terrible, right? </font><font style="vertical-align: inherit;">Well, watch the video for yourself:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_7tv5gtjun8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the port was fantastic! </font><font style="vertical-align: inherit;">He became almost perfect and grabbed everything that made the game on arcade machines so amazing. </font><font style="vertical-align: inherit;">And this is on the portable equipment era Game Boy. </font><font style="vertical-align: inherit;">How did they do it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out that the Lynx had an important weapon in its arsenal: hardware scaling. </font><font style="vertical-align: inherit;">But it didn‚Äôt help much when rendering polygonal graphics. </font><font style="vertical-align: inherit;">It turns out that not only Lynx had aces up his sleeve: the author of the port also invented his own tricks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To recreate the speed of the arcade machine Lynx-version STUN Runner returned to the pseudo-3D engine. The pieces of polygons that make up the walls are actually sprites. In essence, these are the objects on the side of the road that are glued to the road, almost the same as the objects on the side in any other pseudo three-dimensional racing game. They are drawn using the artist's algorithm (back to front). This creates a convincing illusion of polygonal graphics and allows you to take advantage of the strengths of the equipment. And to save space in the cartridge, one sprite did not make up the full ring of the tunnel graphics. This not only saves space on the absence of empty, transparent pixels, but also allows you to use the horizontal reflection function of graphics hardware.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another interesting problem that the port author had to solve was the branching of the tunnel. It can be seen in the above video. The branching tunnel is in fact a large sprite, the scale of which increases when approaching the player. After the player chooses a new path, the fork pattern disappears. According to the author, sometimes you can see how the transport flies right through this sprite! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in learning more about this, then read the interview with the original author at </font></font><a href="http://atariage.com/forums/topic/194231-lynx-stun-runner-3d-techniques/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtariAge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads on Commodore 64</font></font></b></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This information belongs </font></font><a href="http://caspianit.co.uk/index.cfm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to Simon Nicol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who has found a great technique for fast roads on the C64.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a start, a small preface: on many console systems, pseudo-three-dimensional roads were created by drawing a straight road with tiles and line-by-line scrolling to create the appearance of a curvature. However, for a game with a normal level of frames per second, this method was too fast on the Commodore 64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simon's engine instead uses the C64 bitmap mode and the fast fill algorithm. Its fast fill algorithm uses self-modifying code to speed up rendering: each line is a sequence of pixel-by-pixel save operations that indicate the address in the video memory. However, at the moment when the color should change, the code changes. The save command is turned into a load command and the save address is turned into a new color number.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main advantage of this technique is that it can still use the sprite combining technique, which allows you to display more than eight sprites on the screen. According to Simon: ‚ÄúTo offset the horizontal scrolling, in order to get a stable raster effect, manipulations with the $ D011 register are necessary. Otherwise, the raster IRQ at $ D012 will flicker terribly depending on the number of sprites in a particular raster line. For a smooth display, it is necessary to ensure the necessary synchronism in the processor, or not to use on-screen graphics and simply change the border color. It will be solid and without flicker, but the road will not be displayed on the screen, because it will have to be turned off. Such smooth line-by-line color changes to the border were used to raster down the screen, and they can be used to pause there,where you need to display the top of the screen. This technique was called hold-off $ D011 or sometimes FLD (flexible line distancing) (it was used to get rid of bad lines on the Commodore VIC).</font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other</font></font></b></u> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Power Drift </font></font></b> <font style="vertical-align: inherit;"><u><b><font style="vertical-align: inherit;">engines</font></b></u><b><font style="vertical-align: inherit;"> Power Drift is</font></b></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2e/201/9b6/a2e2019b636dd6da1a00d689f8880698.png"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/13f/c08/7d513fc0804ab2a57ad5b53a248360fd.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interesting because it is one of the few games I know of that used sprite-based 3D. Each fragment of the track is a small piece of the sprite, and the created Sega camera circling showed this. I have no evidence, but I think a similar system was used in games like the F1 Exhaust Heat and RadMobile. It is also worth noting that the Power Drift booth could tilt almost 45 degrees, so it was important to fasten it with a belt. Screenshots taken from system16.com.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Racin 'force</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28f/7cf/530/28f7cf530d187cbf5815c308de8f209f.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/e3d/b28/a09/e3db28a097ee89603ea48ffff5369f17.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reverse engineering of Racin 'Force was performed by Chalz Macdonald. </font><font style="vertical-align: inherit;">Racin 'Force runs on a Konami GX PCB, which has a daughter board with voxel engine features. </font><font style="vertical-align: inherit;">This hardware is based on old hardware that could only draw floor cards in the mode 7 style of the SNES console. </font><font style="vertical-align: inherit;">Its capabilities have been expanded and allowed to create a height map using smart technology: it projects not only a tile map on a flat 3D surface, but also height information for each pixel onto its own separate 3D plane. </font><font style="vertical-align: inherit;">Then, for each pixel of the screen, it searches for information about the heights on the projected height map and, if necessary, extrudes each pixel upwards. </font><font style="vertical-align: inherit;">Screenshots taken from system16.com.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Further research </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here are interesting sites that may be useful for a deeper study of pseudo-three-dimensional roads: </font></font><br><br><ul><li> <a href="http://reassembler.blogspot.com/p/cannonball-open-source-outrun-engine.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cannonball: Open source OutRun port</font></font></a> </li><li> <a href="http://codeincomplete.com/posts/2012/6/23/javascript_racer_v1_straight/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code inComplete JavaScript Racer</font></font></a> </li></ul><br><h2>  Code </h2><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulas and tips</font></font></u></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3D projection</font></font></b> <br><br><pre> <code class="hljs lisp">y_screen = (<span class="hljs-name"><span class="hljs-name">y_world*scale</span></span> / z) + (<span class="hljs-name"><span class="hljs-name">screen_height</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  or: <br><br><pre> <code class="hljs lisp">z = (<span class="hljs-name"><span class="hljs-name">y_world*scale</span></span>) / (<span class="hljs-name"><span class="hljs-name">y_screen</span></span> - (<span class="hljs-name"><span class="hljs-name">screen_height</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This formula takes the x or y world coordinates of the object, the z z of the object, and returns the x or y coordinate of the pixel. </font><font style="vertical-align: inherit;">Or, with known world and screen coordinates, it returns the location by z. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scale determines the field of view (field-of-view, FOV) and can be found as follows:</font></font><br><br><pre> <code class="hljs lisp">scale_x = x_resolution/tan(<span class="hljs-name"><span class="hljs-name">x_angle/2</span></span>) scale_y = y_resolution/tan(<span class="hljs-name"><span class="hljs-name">y_angle/2</span></span>)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast linear interpolation</font></font></b> <br><br><pre> <code class="hljs lisp">o(<span class="hljs-name"><span class="hljs-name">x</span></span>) = y1 + ((<span class="hljs-name"><span class="hljs-name">d</span></span> * (y2-y1)) &gt;&gt; 16)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here it is assumed that all numbers are represented as 16.16 with a fixed comma. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are two values ‚Äã‚Äãbetween which interpolation needs to be performed, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a 16-bit fractional distance between two points. For example, if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = $ 7fff, then it will be the middle between two values. This is useful for determining where the value is between the two segments. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fixed-point arithmetic</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floating-point operations are very costly on older systems that do not have specialized mathematical devices. Instead, a fixed-point system is used. In it, a certain number of bits are allocated to the fractional part of the number. For the test, let's assume that we allocated only one bit to the fractional part and left the remaining seven bits to the integer part. This bit of the fractional part will represent half (because half plus half is equal to the whole). To obtain the integer value of the number stored in this byte, the number is shifted one position to the right. This method can be extended and use any number of bits for the fractional and integer parts of a number.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fixed-point multiplication is smarter than addition. In this operation, two numbers are multiplied, and then shifted to the right by the number of bits reserved for the fractional parts. Due to overflow, offset may sometimes be needed before multiplication, not after. See the fixed-point multiplication example in the ‚ÄúFast Linear Interpolation‚Äù section. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turning point</font></font></b> <br><br><pre> <code class="hljs matlab">x' = x*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(a) - y*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) y' = x*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) + y*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(a)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a simple point rotation formula. In the article I briefly mentioned it as a very costly operation. As you can see, it uses at least two searches on the table, four multiplication operations, and two additions, but the sine and cosine values ‚Äã‚Äãcan be reused for each point. Rotation for hills means rotation along the Z and Y coordinates, rather than X and Y. For the derivation of this formula, see the section </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turning axes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elimination of division</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of dividing the object into the z coordinate in standard projection formulas, you can use the properties of the road to speed up the calculations. Suppose we have the z and y position of a 3D segment, and we need to find which line of the screen it corresponds to. First, we read the z-card until we reach the z-position of the 3D segment. Then multiply the height of the segment by the corresponding scaling value. The result will be the number of pixels above the road to which the segment belongs. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using Z as scaling value</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling procedures consist in increasing or decreasing the reading speed of the graphic data drawing procedure. For example, if you set a half-reading speed, the sprite will be twice the size. This happens because with each pixel rendering, the read position of the sprite data increases only by half, which leads to an increase in the read position by an integer number only for every two pixels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typically, the scaling procedure has parameters, such as x, y, and scaling factor. But since the coefficient is 1 / z, you can reuse the value Z of this sprite! However, we still need a scaling factor to determine the sprite's borders in order to center it when scaling. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glossary </font></font></u> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- in the C64 VIC II graphics chip on the first pixel of each background tile, the VIC replaces the processor to insert more data, such as colors. Because the program still has fewer cycles to calculate, this is called bad lines. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The elevation map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an array of elevation values. In a polygonal or voxel landscape engine, this can be a two-dimensional array (imagine the landscape in top view). However, in the road engine the height map is enough to be one-dimensional (imagine the landscape in the side view). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indexed color mode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In older systems with a small number of colors on the screen, indexed color modes were usually used. One of the most popular indexed color modes is the 256-color VGA mode. In these modes, each pixel was represented by a byte. Each byte kept the index value from 0 to 255. When drawing the screen, the index number for each pixel was in the palette. Each entry in the palette could be one of 262,144 possible VGA colors. As a result, even though at the same time there could be only 256 colors on the screen, the user could choose each color from a much larger palette. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linear interpolation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the process of obtaining intermediate values ‚Äã‚Äãfrom a set of data by drawing lines between points. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithm of the artist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- is a way to draw overlapping objects from distant objects to the close ones. It ensures that closer objects will always be on top of distant ones. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planar graphics</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mode is a mode in which an N-bit image was composed of N single-bit images combined to produce the final image. It is the opposite of most graphics modes (sometimes called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chunky</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), in which an N-bit image is composed of N-bit pixel values. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The raster effect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a graphical trick that uses the nature of most computer (raster) displays based on the scanning lines. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling factor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the reciprocal of Z. The number by which to multiply the scale of the object at a given distance along the Z axis. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segment (roads)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I use the term </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segment</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to indicate the position at which the road behaves in one way and above in another. For example, a segment may separate the left turn in the lower half of the screen from the right turn in the upper half. As the segment approaches the player, it seems that the road bends first to the left and then to the right. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three-dimensional segment (roads)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- I use this term to refer to a horizontal line having both a distance in Z, and a height in Y in world coordinates. Unlike the vertex, which can be a 3D point, the 3D segment will be a 3D line, whose left and right end points on the X axis are plus and minus infinity. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a three-dimensional pixel. Voxel landscape engines and ray tracing engines became popular thanks to the game Commanche: Maximum Overkill. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a lookup table that links each line of the screen to a distance of Z.</font></font><br><br><h2>  Gallery </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a set of screenshots showing different ways to create custom road engines. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cisco Heat</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/878/13b/aa3/87813baa384f7b07da257aca123f29ec.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The hills in this game are approaching like a solid wall. Turns also look very exaggerated. The engine seems to be quite flexible and handles several roads at the same time, and can also show the height of one road relative to another. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pole Position</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/19a/e8c/71b/19ae8c71b725fcd373613211e88d34f0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the first smooth motion pseudo three-dimensional game that I remember. Today it is not very impressive graphically. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hydra</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/928/44c/c5e/92844cc5e04b0307368e7b7d3e39fa2e.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Another shoot em up for Atari in the style of Roadblasters. It has a very beautiful jump effect, in which the perspective of the road layer shifts, which is why the nearest objects disappear from the screen. In this game, objects are projected interestingly at different distances to the ground.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outrunners</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/3b1/6d5/fad3b16d5a1d7a7273fa5ea65003a9d9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This sequel to Outrun is a great example of hills similar to roller coasters. Everything is quite exaggerated, resulting in a super-fast racing game, but with good handling. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road rash</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/1c4/816/2b91c4816da4f3ee1176dcfafdedcdae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Road Rash version for the 32-bit generation of consoles, everything was textured, and the buildings were cleverly painted near the curb. Therefore, many people had the impression that this is a completely polygonal game that quickly works on 3do. However, the way objects are bent around the edges, the collapse of buildings and the fact that it was impossible to turn back, proves that this is not a completely polygonal game. The harsh lines on the pavement give a hint of a system of projected segments. Trails are very detailed and varied. The 16-bit Road Rash is also of high quality, it has a flexible engine with a small amount of fake texturing (but it was slow). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turbo</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1fe/ddd/d02/1fedddd0251dccc875d8dab3584d0cf9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preceded by the Pole Position with hills and bridges. Are there any disadvantages? In the game there are no transitions from the hills to bridges and curves. For it used analog graphics scaling equipment. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spy Hunter II</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bad/af3/c2e/badaf3c2e0ae67ce6d27114e73527186.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I do not know what the creators of Spy Hunter II thought. Good idea, bad performance. The effects of the road are very similar to the Turbo, but the transitions are made a little better. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pitstop II</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7c/980/7f2/c7c9807f219c2b9a09d73c9d6115f09d.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This technique is so fast that even on a weak Commodore 64 you could play a split screen racing game. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enduro</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/249/cbb/e1d/249cbbe1d364dbdfb16ec2b4f2953f33.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enduro demonstrates the use of pseudo-3D on the Atari 2600. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enduro Racer</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aab/e03/6fe/aabe036fe52a92221d527c39f6dd63d9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not to be confused with Enduro: it was a 3D similar to Excitebike. The screenshot shows the hill making technique. The hills are quite sharp, flexible, but in general do not affect the position of the horizon, so I think that interpolated points were used. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lotus</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ca/548/47a/2ca54847a84bdba98e36d85dbd5a7f7a.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Lotus used a technique of rather curved hills. Interestingly, Lotus painted the top of the road above the horizon, and then filled the gap with a solid color to simulate the descent from the hill. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test Drive II</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/31b/da8/d3a31bda8cb954c580d5e4a0f3ef79dc.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I don‚Äôt know exactly how Test Drive 2 graphics were created. Although it‚Äôs obvious that the race is not polygonal, it really tries to reproduce realistically a lot of roads. The game is similar to the Need for Speed ‚Äã‚Äãseries, but has overtaken it by several years in time of release. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speed ‚Äã‚Äãbuggy</font></font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/230/d49/420230d490a10014249fecbe48fd944d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When cornering in this game, not only is the perspective shifted, but the road also slides a little to the left or right. </font></font><p></p></div><p>Source: <a href="https://habr.com/ru/post/325482/">https://habr.com/ru/post/325482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325470/index.html">How to understand and make friends with transactions and JPA</a></li>
<li><a href="../325472/index.html">Decorating life with gdb PrettyPrinting API</a></li>
<li><a href="../325476/index.html">Flexible release planning for 101 releases (based on Excel)</a></li>
<li><a href="../325478/index.html">Composition or inheritance: how to choose?</a></li>
<li><a href="../325480/index.html">Matreshka.js 2 - tl; dr</a></li>
<li><a href="../325484/index.html">The influence of ambient music on the process of writing code</a></li>
<li><a href="../325486/index.html">Is there life after 30: history of CiscoSystems</a></li>
<li><a href="../325488/index.html">Different approaches to balancing traffic</a></li>
<li><a href="../325490/index.html">"Man in the middle" using revoked certificates. Part 1</a></li>
<li><a href="../325492/index.html">Human face design patterns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>