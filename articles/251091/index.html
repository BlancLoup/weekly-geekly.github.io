<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pointers, references, and arrays in C and C ++: dots above i</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I will try to finally understand such subtle concepts in C and C ++, as pointers, references and arrays. In particular, I will answer the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pointers, references, and arrays in C and C ++: dots above i</h1><div class="post__text post__text-html js-mediator-article">  In this post I will try to finally understand such subtle concepts in C and C ++, as pointers, references and arrays.  In particular, I will answer the question whether the arrays are C pointers or not. <br><br><h1>  Legend and Assumptions </h1><br><ul><li>  I will assume that the reader understands that, for example, there are links in C ++, but not in C, therefore I will not constantly remind which language (C / C ++ or C ++) I am talking about now, the reader will understand this from context; </li><li>  Also, I assume that the reader already knows C and C ++ at a basic level and knows, for example, the syntax of a link declaration.  In this post I will be engaged in precisely the meticulous analysis of trifles; </li><li> I will designate types as it would look like a TYPE variable declaration of the corresponding type.  For example, the type ‚Äúarray of length 2 ints‚Äù I will denote as <code>int TYPE[2]</code> ; </li><li>  I will assume that we mainly deal with ordinary data types, such as <code>int TYPE</code> , <code>int *TYPE</code> , etc., for which the operations =, &amp;, * and others are not redefined and denote ordinary things; </li><li>  ‚ÄúObject‚Äù will always mean ‚Äúeverything that is not a link‚Äù, and not ‚Äúan instance of a class‚Äù; </li><li>  Everywhere, unless otherwise indicated, C89 and C ++ 98 are implied. </li></ul><br><br><h1>  Pointers and links </h1><br>  <b>Pointers</b> .  What pointers, I will not tell.  :) We will assume that you know this.  I will remind only the following things (all code examples are assumed to be inside some function, for example, main): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x; <span class="hljs-type"><span class="hljs-type">int</span></span> *y = &amp;x; //            "&amp;".     <span class="hljs-type"><span class="hljs-type">int</span></span> z = *y; //        "*".     ,    </code> </pre><br><a name="habracut"></a><br>  I also recall the following: char is always exactly one byte and in all C and C standards <code>sizeof (char) == 1</code> (but standards do not guarantee that the byte contains exactly 8 bits :)).  Further, if we add a number to a pointer to a type T, then the real numerical value of this pointer will increase by that number multiplied by <code>sizeof (T)</code> .  That is, if p is of type <code>T *TYPE</code> , then <code>p + 3</code> equivalent to <code>(T *)((char *)p + 3 * sizeof (T))</code> .  Similar considerations apply to subtraction. <br><br>  <b>References</b>  Now about the links.  Links are the same as pointers, but with a different syntax and some other important differences, which will be discussed further.  The following code is no different from the previous one, except for the fact that it contains links instead of pointers: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;y = x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = y;</code> </pre><br><br>  If a link is to the left of the assignment sign, then there is no way to understand whether we want to assign the link itself or the object to which it refers.  Therefore, such an assignment always assigns an object, not a link.  But this does not apply to the initialization of the link: the link itself, of course, is initialized.  Therefore, after initializing the link, there is no way to change it itself, that is, the link is always constant (but not its object). <br><br>  <b>Lvalue</b>  Those expressions that can be assigned are called lvalues ‚Äã‚Äãin C, C ++, and many other languages ‚Äã‚Äã(this is short for ‚Äúleft value‚Äù, i.e., to the left of the equal sign).  The remaining expressions are called rvalue.  Variable names are obviously lvalues, but not only them.  The expressions <code>a[i + 2]</code> , <code>some_struct.some_field</code> , <code>*ptr</code> , <code>*(ptr + 3)</code> are also lvalue. <br><br>  The amazing fact is that references and lvalues ‚Äã‚Äãare in one sense the same thing.  Let's argue.  What is lvalue?  This is something to assign.  That is, it is a kind of fixed place in memory where you can put something.  Ie address.  That is, a pointer or a link (as we already know, pointers and links are two syntactically different ways in C ++ to express the concept of an address).  Moreover, a link is more likely than a pointer, since the link can be placed to the left of the equal sign and this will mean assignment to the object referenced.  So lvalue is a link. <br><br>  And what is the link?  This is one of the syntaxes for the address, i.e., again, something to put.  And the link can be put to the left of the equal sign.  So the link is lvalue. <br><br>  Okay, but after all (almost any) variable can also be to the left of the equal sign.  So (such) variable is a link?  Nearly.  The expression that represents the variable is a link. <br><br>  In other words, suppose we declare <code>int x</code> .  Now x is a variable of type <code>int TYPE</code> and no other.  This is int and that's it.  But if I now write <code>x + 2</code> or <code>x = 3</code> , then in these expressions the subexpression <code>x</code> is of type <code>int &amp;TYPE</code> .  Because otherwise, this x would be no different from, say, 10, and he (like the top ten) could not be assigned anything. <br><br>  This principle ("an expression that is a variable - a link") is my invention.  That is, in no textbook, standard, etc., I did not see this principle.  Nevertheless, it simplifies a lot and is conveniently considered correct.  If I implemented a compiler, I would simply consider the variables in the expressions as references, and, quite possibly, this is exactly what is expected in real compilers. <br><br>  Moreover, it is convenient to assume that a special data type for lvalue (i.e. reference) exists even in C. That is how we will continue to assume.  Just the concept of a link cannot be expressed syntactically in C, a link cannot be declared. <br><br>  The principle ‚Äúany lvalue - link‚Äù is also my invention.  But the principle ‚Äúany reference is lvalue‚Äù is a completely legitimate, generally accepted principle (of course, the reference must be a reference to the object being changed, and this object must allow assignment). <br><br>  Now, taking into account our agreements, we formulate strictly the rules for working with links: if, say, <code>int x</code> declared, then the expression x has the type <code>int &amp;TYPE</code> .  If now this expression (or any other expression of the link type) is to the left of the equal sign, then it is used as a link, in almost all other cases (for example, in the situation <code>x + 2</code> ) x is automatically converted to the type <code>int TYPE</code> (another operation , next to which the link is not converted into its object, is &amp;, as we will see later).  To the left of the equal sign can only be a link.  Only a link can initialize a (non-constant) link. <br><br>  <b>Operations * and &amp;</b> .  Our agreements allow us to take a fresh look at operations * and &amp;.  Now the following becomes clear: the * operation can only be applied to the pointer (specifically, it was always known) and it returns a reference to the same type.  &amp; always applies to the link and returns a pointer of the same type.  Thus, * and &amp; turn pointers and links into each other.  That is, in fact, they do nothing at all and only replace the essence of one syntax with the essence of another!  Thus, &amp; generally not quite correctly called the operation of taking the address: it can only be applied to an already existing address, it just changes the syntactic embodiment of this address. <br><br>  Note that pointers and references are declared as <code>int *x</code> and <code>int &amp;x</code> .  Thus, the principle of ‚Äúannouncement prompts the use of‚Äù is once again confirmed: the declaration of the pointer reminds how to turn it into a link, and the declaration of the link is the opposite. <br><br>  Also note that <code>&amp;*EXPR</code> (here EXPR is an arbitrary expression, not necessarily a single identifier) ‚Äã‚Äãis equivalent to EXPR whenever it makes sense (that is, always when EXPR is a pointer), and <code>*&amp;EXPR</code> also equivalent to EXPR whenever it has meaning (i.e., when EXPR is a link). <br><br><h1>  Arrays </h1><br>  So, there is such a data type - an array.  Arrays are defined, for example, as follows: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre><br>  The expression in square brackets must necessarily be a compile-time constant in C89 and C ++ 98.  At the same time in square brackets should be a number, empty square brackets are not allowed. <br><br>  Just as all local variables (recall, we assume that all code examples are inside functions) are on the stack, arrays are also on the stack.  That is, the above code led to the allocation right on the stack of a huge memory block of <code>5 * sizeof (int)</code> size, in which our entire array is located.  No need to think that this code declared a pointer, which points to a memory located somewhere far away, in a heap.  No, we declared an array, the real one.  Here on the stack. <br><br>  What will be <code>sizeof (x)</code> ?  Of course, it will be equal to the size of our array, i.e. <code>5 * sizeof (int)</code> .  If we write <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; };</code> </pre><br>  then, again, the space for the array will be completely allocated directly inside the structure, and the sizeof from this structure will confirm this. <br><br>  From the array, you can take the address ( <code>&amp;x</code> ), and it will be a real pointer to the place where this array is located.  The type of the <code>&amp;x</code> expression, as is easily understood, will be <code>int (*TYPE)[5]</code> .  At the beginning of the array its zero element is located, therefore the address of the array itself and the address of its zero element are numerically the same.  That is, <code>&amp;x</code> and <code>&amp;(x[0])</code> numerically equal (here I famously wrote the expression <code>&amp;(x[0])</code> , in fact, it is not so simple, we'll return to this).  But these expressions have a different type - <code>int (*TYPE)[5]</code> and <code>int *TYPE</code> , so comparing them with == will not work.  But you can use the trick with <code>void *</code> : the following expression will be true: <code>(void *)&amp;x == (void *)&amp;(x[0])</code> . <br><br>  Well, let's assume, I convinced you that an array is an array, and not something else.  Where does all this confusion between pointers and arrays come from?  The fact is that the name of an array in almost any operation is converted to a pointer to its zero element. <br><br>  So, we declared <code>int x[5]</code> .  If we now write <code>x + 0</code> , then this will convert our x (which was of type <code>int TYPE[5]</code> , or, more precisely, <code>int (&amp;TYPE)[5]</code> ) to <code>&amp;(x[0])</code> , i.e. pointer to the zero element of the array x.  Now our x is of type <code>int *TYPE</code> . <br><br>  Converting an array name to <code>void *</code> or applying == to it also leads to a preliminary conversion of this name into a pointer to the first element, therefore: <br><pre> <code class="hljs ruby">&amp;x == x /<span class="hljs-regexp"><span class="hljs-regexp">/  ,  : int (*TYPE)[5]  int *TYPE (void *)&amp;x == (void *)x /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  x == x + 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  x == &amp;(x[0]) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ </span></span></code> </pre><br><br>  <b>Operation []</b> .  The <code>a[b]</code> record is always equivalent to <code>*(a + b)</code> (recall that we do not consider overriding <code>operator[]</code> and other operations).  Thus, <code>x[2]</code> means the following: <br><ul><li>  <code>x[2]</code> equivalent to <code>*(x + 2)</code> </li><li>  <code>x + 2</code> refers to those operations in which the array name is converted to a pointer to its first element, so this happens </li><li>  Further, in accordance with my explanations above, <code>x + 2</code> equivalent to <code>(int *)((char *)x + 2 * sizeof (int))</code> , i.e. <code>x + 2</code> means "move the pointer x to two ints" </li><li>  Finally, a dereferencing operation is taken from the result, and we retrieve the object that is located along this shifted pointer. </li></ul><br><br>  The types of expressions involved are as follows: <br><pre> <code class="hljs pgsql">x // <span class="hljs-type"><span class="hljs-type">int</span></span> (&amp;<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>)[<span class="hljs-number"><span class="hljs-number">5</span></span>],   : <span class="hljs-type"><span class="hljs-type">int</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> // <span class="hljs-type"><span class="hljs-type">int</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> *(x + <span class="hljs-number"><span class="hljs-number">2</span></span>) // <span class="hljs-type"><span class="hljs-type">int</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> x[<span class="hljs-number"><span class="hljs-number">2</span></span>] // <span class="hljs-type"><span class="hljs-type">int</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span></code> </pre><br><br>  Also note that to the left of the square brackets it does not have to be an array, there can be any pointer.  For example, you can write <code>(x + 2)[3]</code> , and this will be equivalent to <code>x[5]</code> .  I also note that <code>*a</code> and <code>a[0]</code> always equivalent, as in the case when a is an array, and when a is a pointer. <br><br>  Now, as I promised, I return to <code>&amp;(x[0])</code> .  It is now clear that in this expression, first x is converted to a pointer, then <code>[0]</code> is applied to this pointer in accordance with the above algorithm and the result is a value of type <code>int &amp;TYPE</code> , and finally, using &amp; it is converted to type <code>int *TYPE</code> .  Therefore, to explain with the help of this complex expression (inside which an array is converted to a pointer) a slightly simpler notion of converting an array to a pointer is done - it was a bit mulling. <br><br>  <b>And now the question of backfilling</b> : what is <code>&amp;x + 1</code> ?  Well, <code>&amp;x</code> is a pointer to the entire array, <code>+ 1</code> leads to a step to the whole array.  That is, <code>&amp;x + 1</code> is <code>(int (*)[5])((char *)&amp;x + sizeof (int [5]))</code> , i.e. <code>(int (*)[5])((char *)&amp;x + 5 * sizeof (int))</code> (here, <code>int (*)[5]</code> is <code>int (*TYPE)[5]</code> ).  So <code>&amp;x + 1</code> numerically equal to <code>x + 5</code> , not <code>x + 1</code> , as one might think.  Yes, as a result, we point to a memory that is outside the array (immediately after the last element), but who cares?  After all, C still does not check whether the array goes beyond the bounds.  Also note that the expression <code>*(&amp;x + 1) == x + 5</code> true.  You can also write it like this: <code>(&amp;x)[1] == x + 5</code> .  It will also be true <code>*((&amp;x)[1]) == x[5]</code> , or, equivalently, <code>(&amp;x)[1][0] == x[5]</code> (unless we seize the segmentation fault, of course for trying to turn beyond our memory :)). <br><br>  <b>An array cannot be passed as an argument to a function</b> .  If you write <code>int x[2]</code> or <code>int x[]</code> in the function header, it will be equivalent to <code>int *x</code> and a pointer will always be passed to the function (the sizeof from the passed variable will be the same as the pointer).  In this case, the size of the array specified in the header will be ignored.  You can easily specify <code>int x[2]</code> in the header and pass an array of length 3 there. <br><br>  However, in C ++ there is a way to pass a function reference to an array: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> f (<span class="hljs-type"><span class="hljs-type">int</span></span> (&amp;x)[<span class="hljs-number"><span class="hljs-number">5</span></span>]) { // sizeof (x)   <span class="hljs-number"><span class="hljs-number">5</span></span> * sizeof (<span class="hljs-type"><span class="hljs-type">int</span></span>) } <span class="hljs-type"><span class="hljs-type">int</span></span> main (<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> x[<span class="hljs-number"><span class="hljs-number">5</span></span>]; f (x); // OK f (x + <span class="hljs-number"><span class="hljs-number">0</span></span>); //  <span class="hljs-type"><span class="hljs-type">int</span></span> y[<span class="hljs-number"><span class="hljs-number">7</span></span>]; f (y); // ,    }</code> </pre><br>  With such a transfer, you still transmit only the link, not the array, that is, the array is not copied.  But still you get a few differences compared to the usual pointer passing.  The link to the array is passed.  You cannot pass a pointer instead.  It is necessary to transfer an array of the specified size.  Inside the function, the link to the array will behave exactly as a link to the array, for example, it will have sizeof like an array. <br><br>  And what is most interesting, this program can be used as follows: <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename t, size_t n&gt; size_t len (t (&amp;a)[n]) { return n; }</span></span></code> </pre><br>  Similarly, the std :: end function is implemented in C ++ 11 for arrays. <br><br>  <b>"Pointer to an array</b> . <b>"</b>  Strictly speaking, a ‚Äúpointer to an array‚Äù is exactly a pointer to an array and nothing else.  In other words: <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*a)[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .  .    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*TYPE)[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *c = b; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     .   .       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *d = new <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .  </code> </pre><br>  However, sometimes the phrase ‚Äúpointer to an array‚Äù informally means a pointer to the memory area in which the array is located, even if the type of this pointer is unsuitable.  According to this informal understanding, c and d (and <code>b + 0</code> ) are pointers to arrays. <br><br>  <b>Multidimensional arrays</b> .  If <code>int x[5][7]</code> declared, then x is not an array of length 5 of some pointers pointing somewhere far away.  No, x now is a single monolithic block of size 5 x 7 placed on the stack.  <code>sizeof (x)</code> is <code>5 * 7 * sizeof (int)</code> .  The elements are located in the memory as follows: <code>x[0][0]</code> , <code>x[0][1]</code> , <code>x[0][2]</code> , <code>x[0][3]</code> , <code>x[0][4]</code> , <code>x[0][5]</code> , <code>x[0][6]</code> , <code>x[1][0]</code> and so on.  When we write <code>x[0][0]</code> , events happen like this: <br><pre> <code class="hljs markdown">x // int (&amp;TYPE)[<span class="hljs-string"><span class="hljs-string">5</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">7</span></span>],  : int (<span class="hljs-emphasis"><span class="hljs-emphasis">*TYPE)[7] x[0] // int (&amp;TYPE)[7],  : int *</span></span>TYPE x[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0</span></span>] // int &amp;TYPE</code> </pre><br>  The same applies to <code>**x</code> .  I note that in expressions, say, <code>x[0][0] + 3</code> and <code>**x + 3</code> in reality, retrieving from memory occurs only once (despite the presence of two asterisks), at the time of converting the final reference like <code>int &amp;TYPE</code> just <code>int TYPE</code> .  That is, if we looked at the assembler code that is generated from the expression <code>**x + 3</code> , we would see in it that the operation of extracting data from memory is performed there only once.  <code>**x + 3</code> can also be written differently as <code>*(int *)x + 3</code> . <br><br>  Now look at this situation: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { y[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">7</span></span>]; }</code> </pre><br><br>  What is y now?  y is a pointer to an array (in an informal sense!) of pointers to arrays (again, in an informal sense).  Nowhere there is a single block of size 5 x 7, there are 5 blocks of size <code>7 * sizeof (int)</code> , which can be far from each other.  What is <code>y[0][0]</code> ? <br><pre> <code class="hljs markdown">y // int <span class="hljs-emphasis"><span class="hljs-emphasis">**&amp;TYPE y[0] // int *</span></span>&amp;TYPE y[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0</span></span>] // int &amp;TYPE</code> </pre><br>  Now, when we write <code>y[0][0] + 3</code> , retrieving from memory occurs two times: retrieving from the array y and then retrieving from the array <code>y[0]</code> , which may be far from the array y.  The reason for this is that there is no conversion of the array name to a pointer to its first element, unlike the example with the multidimensional array x.  Therefore <code>**y + 3</code> is not equivalent here <code>*(int *)y + 3</code> . <br><br>  I will explain one more time.  <code>x[2][3]</code> equivalent to <code>*(*(x + 2) + 3)</code> .  And <code>y[2][3]</code> equivalent to <code>*(*(y + 2) + 3)</code> .  But in the first case, our task is to find the ‚Äúthird element in the second row‚Äù in a single block of size 5 x 7 (of course, the elements are numbered from zero, so this third element will be in some sense the fourth :)).  The compiler calculates that in fact the necessary element is located at <code>2 * 7 + 3</code> th place in this block and extracts it.  That is, <code>x[2][3]</code> is equivalent to <code>((int *)x)[2 * 7 + 3]</code> , or, equivalently, <code>*((int *)x + 2 * 7 + 3)</code> .  In the second case, first retrieves the 2nd element in the array y, and then the 3rd element in the resulting array. <br><br>  In the first case, when we do <code>x + 2</code> , we immediately shift by <code>2 * sizeof (int [7])</code> , i.e. by <code>2 * 7 * sizeof (int)</code> .  In the second case, <code>y + 2</code> is a shift by <code>2 * sizeof (int *)</code> . <br><br>  In the first case <code>(void *)x</code> and <code>(void *)*x</code> (and <code>(void *)&amp;x</code> !) Is the same pointer, in the second it is not. </div><p>Source: <a href="https://habr.com/ru/post/251091/">https://habr.com/ru/post/251091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251081/index.html">Developing a simple game in Code :: blocks using Direct3D 9</a></li>
<li><a href="../251083/index.html">Chat VKontakte as a terminal</a></li>
<li><a href="../251085/index.html">Quantum sandbox: part 2</a></li>
<li><a href="../251087/index.html">Tube amplifier</a></li>
<li><a href="../251089/index.html">Anti-design patterns: Functional Decomposition</a></li>
<li><a href="../251093/index.html">Liquidation of the Association of users of cryptocurrency in the Russian Federation</a></li>
<li><a href="../251095/index.html">We write the simulator of slow connections on Go</a></li>
<li><a href="../251097/index.html">Settings panel without programming</a></li>
<li><a href="../251099/index.html">Mom said: do not trust the phone with a SIM-card</a></li>
<li><a href="../251101/index.html">Billiard bot: the history of creation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>