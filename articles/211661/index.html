<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cross-platform https server with non-blocking sockets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of my article The simplest cross-platform server with ssl support . 
 Therefore, in order to read further it is highly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cross-platform https server with non-blocking sockets</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of my article <a href="http://habrahabr.ru/post/211474/">The simplest cross-platform server with ssl support</a> . <br>  Therefore, in order to read further it is highly desirable to read at least a part of the previous article.  But if you don‚Äôt want it, here‚Äôs a brief summary: I took the ‚Äúserv.cpp‚Äù file from the OpenSSL sources and made it the simplest cross-platform server that can receive one character from the client. <br>  Now I want to go further and force the server: <br>  1. Accept the entire http header from the browser. <br>  2. Send the browser html page that will display the http header. <br>  3. In addition, I want the sockets not to block the server process and for this I will transfer them to the so-called ‚Äúnon-blocking mode‚Äù. <br><a name="habracut"></a><br>  To begin, I will need the serv.cpp file modified in the previous article. <br>  The first thing to do is to write cross-platform macros to put sockets into non-blocking mode: <br><br>  for this line of code <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> WIN32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> closesocket close #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><br>  change to the following: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_NONBLOCK(socket) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (true) \ { \ DWORD dw = true; \ ioctlsocket(socket, FIONBIO, &amp;dw); \ } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fcntl.h&gt; #define SET_NONBLOCK(socket) \ if (fcntl( socket, F_SETFL, fcntl( socket, F_GETFL, 0 ) | O_NONBLOCK ) &lt; 0) \ printf("error in fcntl errno=%i\n", errno); #define closesocket(socket) close(socket) #endif</span></span></span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Done!  Now, to translate the "listening" socket to the non-blocking mode, it suffices immediately after the line <br><pre> <code class="cpp hljs">listen_sd = socket (AF_INET, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>); CHK_ERR(listen_sd, <span class="hljs-string"><span class="hljs-string">"socket"</span></span>);</code> </pre><br><br>  insert line: <br><pre> <code class="cpp hljs">SET_NONBLOCK(listen_sd);</code> </pre><br><br>  Now the "listening" socket is non-blocking and the accept function will return control to the program immediately after the call. <br>  Instead of a socket handle, accept will now return a value (-1). <br>  Thus, in non-blocking mode, we need to call the accept function in an infinite loop until it returns a socket descriptor. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sd = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(sd == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 sd = accept (listen_sd, (struct sockaddr*) &amp;sa_cli, (int *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> sd = accept (listen_sd, (struct sockaddr*) &amp;sa_cli, &amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  So that the program does not load the processor at 100%, I added in the Sleep (1) cycle.  In Windows, this means a break of 1 millisecond.  To make it work in Linux, add at the beginning of the file: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> WIN32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Sleep(a) usleep(a*1000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  Theoretically, instead of an infinite loop, you can use the select function and its more powerful counterparts to wait until the listen_sd socket is available for reading, and only then call accept once.  But personally, I don‚Äôt see any special flaws in my loop method. <br><br>  So, the program will exit the cycle when the client connects.  The sd socket in theory should automatically become non-blocking, but practice shows that for reliability it is better to call the macro at the end of the cycle <br><pre> <code class="cpp hljs">SET_NONBLOCK(sd);</code> </pre><br><br>  Now that the socket to communicate with the client is non-blocking, the function <br><pre> <code class="cpp hljs">err = SSL_accept (ssl);</code> </pre><br>  will not suspend the process, but will return immediately after the call with the value err = SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE <br>  in order to receive an encrypted message, we need another endless loop: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); err = SSL_accept (ssl); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nCode = SSL_get_error(ssl, err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } CHK_SSL(err);</code> </pre><br><br>  Only when the program leaves this cycle, you can be sure that the encrypted connection is established and you can begin receiving and sending messages. <br>  We will connect to the server using a browser, so the client's messages consist of the http header and the request body. <br>  At the same time, the http header should end with the string "\ r \ n \ r \ n". <br>  We fix our code so that the server reads the entire http header, and not just its first letter. <br><br>  In order to shorten the code, I suggest using the excellent STL library: <br>  1. Add three header files: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt;</span></span></span></span></code> </pre><br><br>  2. Replace strings <br><br><pre> <code class="cpp hljs"> err = SSL_read (ssl, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>); CHK_SSL(err); buf[err] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Got %d chars:'%s'\n"</span></span>, err, buf);</code> </pre><br><br>  on the following code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; vBuffer(<span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     memset(&amp;vBuffer[0], 0, vBuffer.size()); //   size_t nCurrentPos = 0; while (nCurrentPos &lt; vBuffer.size()-1) { err = SSL_read (ssl, &amp;vBuffer[nCurrentPos], vBuffer.size() - nCurrentPos - 1); //        if (err &gt; 0) { nCurrentPos += err; const std::string strInputString((const char *)&amp;vBuffer[0]); if (strInputString.find("\r\n\r\n") != -1) //   http ,     break; continue; } const int nCode = SSL_get_error(ssl, err); if ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) break; }</span></span></code> </pre><br>  In this loop, the server reads data from the client until it receives the end characters of the http header "\ r \ n \ r \ n", or until the buffer space runs out. <br>  It is convenient for me to allocate a buffer as std :: vector, if only because it does not need a separate variable to remember its length. <br>  After exiting the loop, the entire http header and possibly part of the request body should be stored in the buffer. <br><br>  3. Send the browser html page in which we write the http header of its request. <br>  Replace string <br><pre> <code class="cpp hljs">err = SSL_write (ssl, <span class="hljs-string"><span class="hljs-string">"I hear you."</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-string"><span class="hljs-string">"I hear you."</span></span>)); CHK_SSL(err);</code> </pre><br><br>  on the following code: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      const std::string strInputString((const char *)&amp;vBuffer[0]); // html     const std::string strHTML = "&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello! Your HTTP headers is:&lt;/h2&gt;&lt;br&gt;&lt;pre&gt;" + strInputString.substr(0, strInputString.find("\r\n\r\n")) + "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"; //    http  std::ostringstream strStream; strStream &lt;&lt; "HTTP/1.1 200 OK\r\n" &lt;&lt; "Content-Type: text/html; charset=utf-8\r\n" &lt;&lt; "Content-Length: " &lt;&lt; strHTML.length() &lt;&lt; "\r\n" &lt;&lt; "\r\n" &lt;&lt; strHTML.c_str(); //    . nCurrentPos = 0; while(nCurrentPos &lt; strStream.str().length()) { err = SSL_write (ssl, strStream.str().c_str(), strStream.str().length()); if (err &gt; 0) { nCurrentPos += err; continue; } const int nCode = SSL_get_error(ssl, err); if ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) break; }</span></span></code> </pre><br><br>  Since we have non-blocking sockets, there is no guarantee that the answer will go completely the first time.  Therefore, you need to call SSL_write in a loop. <br>  That's all.  Now you can start our server and type in the browser <code><a href="https://localhost/"></a> localhost:1111</code> <br>  In response, the browser will show the page with its http request. <br><br>  Project for Visual Studio 2012 in the archive <a href="http://3_.3s3s.org/">3_.3s3s.org</a> . <br>  To compile for Linux, copy the files ‚Äúca-cert.pem‚Äù and ‚Äúserv.cpp‚Äù into one directory and run the compiler: ‚Äúg ++ -L / usr / lib -lssl -lcrypto serv.cpp‚Äù <br><br>  PS: <a href="http://habrahabr.ru/post/211853/">wrote a continuation of this article</a> </div><p>Source: <a href="https://habr.com/ru/post/211661/">https://habr.com/ru/post/211661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211651/index.html">E-commerce trends: What is most important for an online store? Part 2</a></li>
<li><a href="../211653/index.html">Buffer for buffers or write a virtual clipboard in C # not in 30 lines of code</a></li>
<li><a href="../211655/index.html">Artificial intelligence in flight simulators</a></li>
<li><a href="../211657/index.html">ASUS Fonepad Note 6 Review</a></li>
<li><a href="../211659/index.html">Three rules for designing interfaces with high-speed user interaction</a></li>
<li><a href="../211663/index.html">Overview of the Android core features</a></li>
<li><a href="../211665/index.html">Support in JetBrains</a></li>
<li><a href="../211667/index.html">Google calendar as free sms gate</a></li>
<li><a href="../211669/index.html">How to use the function of processing incoming mail in SharePoint 2010 - a practical example</a></li>
<li><a href="../211675/index.html">The biggest problem with web development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>