<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SaltStack: using salt-ssh</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I would like to share my experience of using the SaltStack configuration management system, and, in particular, its use in Masterless mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SaltStack: using salt-ssh</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/81f/f33/025/81ff3302545748ed90c9580d5f90c12e.png" alt="salt-ssh" align="left">  In this post I would like to share my experience of using the <a href="https://saltstack.com/">SaltStack</a> configuration management system, and, in particular, its use in <em>Masterless</em> mode using the <strong>salt-ssh</strong> component. </p><br><p>  In fact, <a href="https://docs.saltstack.com/en/latest/topics/ssh/">salt-ssh</a> is analogous to the <a href="https://www.ansible.com/">Ansible</a> system. </p><br><pre><code class="hljs cs">salt-ssh <span class="hljs-string"><span class="hljs-string">'*-ec2.mydomain.com'</span></span> test.ping</code> </pre> <br><p>  The following topics will be covered: </p><br><ul><li>  Why SaltStack, Key Features </li><li>  Basic SaltStack Concepts </li><li>  Salt-ssh installation and use <a name="habracut"></a></li></ul><br><h3>  <strong>Why SaltStack, Key Features</strong> </h3><br><p>  When I several years ago, having enough of puppet (multiple environments, 100+ nodes), chose a new configuration management system for a new project, then <em>Masterless</em> mode of operation was a key requirement.  But I also wanted to keep the opportunity <em>Master-Slave</em> mode of operation.  I wanted good, extensive documentation and flexibility.  I wanted to be able to manage cloud infrastructures. </p><br><p>  I also wanted to build a system in which a variety of environments would be easy to get along with.  All this was done with salt-ssh. </p><br><p>  <a href="https://docs.saltstack.com/en/latest/topics/ssh/">Salt-ssh</a> is a component of <a href="https://saltstack.com/">SaltStack</a> , which, like <a href="https://www.ansible.com/">Ansible</a> , uses ssh to connect to remote machines and does not require any preliminary configuration on the part of remote machines.  No agents.  Pure ssh! </p><br><p>  Of course, when choosing a system, I considered Ansible.  But the scale then leaned toward SaltStack. </p><br><p>  Unlike Ansible, SaltStack uses <a href="https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.jinja.html">Jinja2</a> for both template processing and logic building. </p><br><p>  Moreover, this logic can be built almost by any means.  What is good and bad on the one hand.  Good tk  gives flexibility.  But bad, because  There is no one standard way and approach to implementation.  It even seems to me that SaltStack is more of a constructor in this regard. </p><br><p>  Also, the rendering of patterns and logic occurs during the startup phase.  The resulting package of templates, settings and instructions is copied to a remote server and executed.  Upon completion, salt-ssh issues a report to the console, what was executed, and what errors occurred with, if any.  Here the difference with ansible is very striking.  The latter performs tasks \ playbooks alternately, in shell script mode.  I will not deny that it is more pleasant to watch the progress of the execution of ansible scripts, but gradually it all fades into the background when the number of hosts exceeds a few dozen.  Also, in comparison with ansible, SaltStack has a higher level of abstraction. <br>  Anyway, both ansible and salt-ssh are two very interesting tools, each of which has its own advantages and disadvantages. </p><br><h3>  <strong>Basic SaltStack Concepts</strong> </h3><br><p>  SaltStack is a configuration and infrastructure management system.  Both at the level of individual servers, and in various cloud platforms ( <a href="https://docs.saltstack.com/en/latest/topics/cloud/">SaltCloud</a> ).  It is also a remote command execution system.  Written in python.  Very rapidly developing.  It has many different modules and features, including even such as <a href="https://docs.saltstack.com/en/latest/ref/cli/salt-api.html">Salt-Api</a> and <a href="https://docs.saltstack.com/en/latest/topics/topology/syndic.html">Salt-Syndic</a> (master of masters or a system that allows you to build a hierarchy of master servers, tobish a syndicate). </p><br><p>  By default, SaltStack implies a Master-Slave mode of operation.  Messaging between nodes takes place via the <a href="https://docs.saltstack.com/en/latest/topics/transports/zeromq.html">ZeroMQ</a> protocol.  Able to scale horizontally using MultiMaster settings. </p><br><p>  But best of all, Salt can still work in <em>Agentless</em> mode.  What can be implemented with the help of the local launch of the state or with the help of salt-ssh, the hero of this topic. </p><br><p>  <em>Salt master</em> is a process running on a machine with which the connected agents are managed.  In the case of salt-ssh, we can call the master that node where our state and pillar data lie <br>  <em>Salt minion</em> is a process running on managed machines, i.e.  slave  In the case of salt-ssh minion, this is any remote server. <br>  <em>State</em> - a declarative representation of the state of the system (analog playbooks in ansible) <br>  <em>Grains</em> - static information about a remote minion (RAM, CPUs, OS, etc) <br>  <em>Pillar</em> - variables for one or more minions <br>  <em>top.sls</em> - central files that implement logic which state and pillar data to which minion to assign <br>  <em>highstate</em> - all defined state data for minion <br>  <em>SLS</em> - all configuration files for pillar \ states in SaltStack are so called, YAML is used </p><br><p>  One of the drawbacks of the SaltStack system is a higher entry threshold.  Next, I will show examples, so getting started with this great system was easier. </p><br><h3>  <strong>Salt-ssh installation and use</strong> </h3><br><p>  Setting salt-ssh is trivial. </p><br><p>  The site <a href="https://repo.saltstack.com/">https://repo.saltstack.com/</a> has all the necessary repositories and instructions for connecting them to various systems. </p><br><p>  Only salt-ssh is needed for installation. </p><br><p>  <code>sudo apt-get install salt-ssh</code> (For example, Deb systems) </p><br><h4>  <strong>Preparation of the test environment and Vagrant</strong> </h4><br><p>  To start using salt-ssh, we just need to install it.  At a minimum, you can manage your local machine, or any remote server, which is much clearer. </p><br><p>  In this example, for the tests, I will use two virtual machines created using <a href="https://www.vagrantup.com/">Vagrant</a> .  The salt-ssh itself will be installed on one of them, the other will be clean, not counting the connected public key from the first machine. </p><br><p>  The Vagrantfile itself and the necessary salt states are uploaded to the repository <a href="https://github.com/skandyla/saltssh-intro">https://github.com/skandyla/saltssh-intro</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Vagrantfile</b> <div class="spoiler_text"><pre> <code class="hljs lua"># -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>| # VM with salt-ssh <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.define :<span class="hljs-string"><span class="hljs-string">"saltsshbox"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>| <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.box = <span class="hljs-string"><span class="hljs-string">"ubuntu/trusty64"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.hostname = <span class="hljs-string"><span class="hljs-string">"saltsshbox"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.network <span class="hljs-string"><span class="hljs-string">"private_network"</span></span>, ip: <span class="hljs-string"><span class="hljs-string">"192.168.33.70"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.provider <span class="hljs-string"><span class="hljs-string">"virtualbox"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |vb| vb.memory = <span class="hljs-string"><span class="hljs-string">"512"</span></span> vb.cpus = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.synced_folder <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"/srv"</span></span> # Deploy vagrant insecure private key inside the VM <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.provision <span class="hljs-string"><span class="hljs-string">"file"</span></span>, source: <span class="hljs-string"><span class="hljs-string">"~/.vagrant.d/insecure_private_key"</span></span>, destination: <span class="hljs-string"><span class="hljs-string">"~/.ssh/id_rsa"</span></span> # Install salt-ssh <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.provision <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, inline: &lt;&lt;-SHELL wget -O - https://repo.saltstack.com/apt/ubuntu/<span class="hljs-number"><span class="hljs-number">14.04</span></span>/amd64/latest/SALTSTACK-GPG-KEY.pub | sudo apt-key add - sudo echo <span class="hljs-string"><span class="hljs-string">'deb http://repo.saltstack.com/apt/ubuntu/14.04/amd64/latest trusty main'</span></span> &gt; /etc/apt/sources.list.d/saltstack.list sudo apt-get update sudo apt-get install -y salt-ssh SHELL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # VM <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testing <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.define :<span class="hljs-string"><span class="hljs-string">"testserver"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>| <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.box = <span class="hljs-string"><span class="hljs-string">"ubuntu/trusty64"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.hostname = <span class="hljs-string"><span class="hljs-string">"testserver"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.network <span class="hljs-string"><span class="hljs-string">"private_network"</span></span>, ip: <span class="hljs-string"><span class="hljs-string">"192.168.33.75"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.provider <span class="hljs-string"><span class="hljs-string">"virtualbox"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |vb| vb.memory = <span class="hljs-string"><span class="hljs-string">"512"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # Deploy vagrant public key <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.vm.provision <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, inline: &lt;&lt;-SHELL curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &gt;&gt; ~/.ssh/authorized_keys2 <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;/dev/null curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &gt;&gt; /home/vagrant/.ssh/authorized_keys2 <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;/dev/null SHELL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  I assume that the audience is familiar with Vagrant, but just in case: <a href="https://www.vagrantup.com/">Vagrant</a> is a kind of virtualization framework designed to simplify the development process and make it replicable.  To run the virtual machines, we will need the Vagrant and Virtualbox installed. </p><br><p>  Next we clone the repository: </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/skandyla/saltssh-intro</code> </pre> <br><p>  and in it we initialize the Vagrant virtual machines: </p><br><pre> <code class="bash hljs">vagrant up</code> </pre> <br><p>  After the launch of the latter, go to the saltsshbox: </p><br><pre> <code class="bash hljs">vagrant ssh saltsshbox</code> </pre> <br><p>  All further work will be carried out from this virtual machine.  By default, SaltStack assumes that we will act as root, so we immediately do: </p><br><pre> <code class="bash hljs">vagrant@saltsshbox:~$ sudo -i</code> </pre> <br><h4>  <strong>Understanding salt roster</strong> </h4><br><p>  Target hosts are written to the <strong>/ etc / salt / roster file</strong> , however, you can specify any third-party roster file.  In a sense, you can draw analogies with <em>inventory</em> files ansible.  Roster file, is a YAML, with many different options.  Below are several ways to record the same host. </p><br><div class="spoiler">  <b class="spoiler_title">/ srv / saltstack / saltetc / roster_test</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">testserver: host: <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.33</span></span><span class="hljs-number"><span class="hljs-number">.75</span></span> priv: /home/vagrant/.ssh/id_rsa thesametestserver: host: <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.33</span></span><span class="hljs-number"><span class="hljs-number">.75</span></span> user: vagrant sudo: <span class="hljs-literal"><span class="hljs-literal">True</span></span> thesametestserver2: host: <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.33</span></span><span class="hljs-number"><span class="hljs-number">.75</span></span> user: vagrant passwd: vagrant sudo: <span class="hljs-literal"><span class="hljs-literal">True</span></span></code> </pre> </div></div><br><p>  Now we will try to execute the <code>test.ping</code> command for all the hosts specified in our roster. </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh -i --roster-file=/srv/saltstack/saltetc/roster_test '*' test.ping Permission denied for host thesametestserver, do you want to deploy the salt-ssh key? (password required): [Y/n] n thesametestserver: ---------- retcode: 255 stderr: Permission denied (publickey,password). stdout: testserver: True thesametestserver2: True</span></span></code> </pre> <br><p>  As you can see, salt-ssh slightly cursed that he could not go to the remote server and offered to deploy the key there, but I canceled it.  The remaining two servers (in fact, one under different names) responded positively.  This happened because we are running as root, for which no ssh keys are defined.  Therefore, you can simply add the key through the <a href="https://en.wikipedia.org/wiki/Ssh-agent">ssh-agent</a> and repeat the command again. </p><br><div class="spoiler">  <b class="spoiler_title">repeat:</b> <div class="spoiler_text"><pre> <code class="hljs mel">root@saltsshbox:~# <span class="hljs-keyword"><span class="hljs-keyword">eval</span></span> <span class="hljs-string"><span class="hljs-string">`ssh-agent`</span></span>; ssh-add /home/vagrant/.ssh/id_rsa Agent pid <span class="hljs-number"><span class="hljs-number">2846</span></span> Identity added: /home/vagrant/.ssh/id_rsa (/home/vagrant/.ssh/id_rsa) root@saltsshbox:~# salt-ssh -i --roster-<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>=/srv/saltstack/saltetc/roster_test <span class="hljs-string"><span class="hljs-string">'*'</span></span> test.ping testserver: True thesametestserver: True thesametestserver2: True</code> </pre> </div></div><br><p>  Now everything is good!  Moreover, you can easily add a key with a password via ssh-agent.  But if you decide to deploy a key that the salt itself suggests, then it will take it by default here: <em>/etc/salt/pki/master/ssh/salt-ssh.rsa</em> </p><br><p>  Here, for the test, I deliberately worked with a separate roster file to show interesting nuances.  For further work, we will not need to specify the roster, because it is already indicated through symlink to the required place ( <em>/ etc / salt / roster</em> ).  The <strong>-i</strong> switch is necessary when we start working with new hosts; it simply disables StrictHostKeyChecking, giving the opportunity to accept a new host key.  For further work, we also will not need it. </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh '*' test.ping testserver: True</span></span></code> </pre> <br><p>  Let me remind you that by default salt looks at roster here: <em>/ etc / salt / roster</em> in which we now have only one host defined. </p><br><h4>  <strong>Remote command execution</strong> </h4><br><p>  Now that we‚Äôve seen that our salt-ssh machine perfectly sees the test server specified in the roster, we‚Äôll work with it in ad-hoc style. </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver cmd.run "uname -a" testserver: Linux testserver 3.13.0-87-generic #133-Ubuntu SMP Tue May 24 18:32:09 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span></code> </pre> <br><p>  <em>cmd.run</em> is essentially the equivalent of the <code>-a</code> key in ansible. </p><br><p>  You can also use the built-in module saltstack, for example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">service</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get_enabled</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">pkg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.install</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">git</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">network</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.interfaces</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">disk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.usage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sys</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.doc</span></span></code> </pre> <br><p>  The last command will issue documentation about the modules and, most importantly, examples of their use.  Additionally, you can view a <a href="https://docs.saltstack.com/en/latest/ref/modules/all/">complete list of available Saltstack modules</a> . </p><br><h4>  <strong>Salt Grains or facts about the system</strong> </h4><br><p>  <a href="https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.grains.html">Grains</a> is a powerful mechanism representing a collection of facts about a remote system.  In the future, on the basis of the Grains, you can also build different logic. </p><br><p>  But first, let's see how to start working with them: </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver grains.items testserver: ---------- SSDs: biosreleasedate: 12/01/2006 biosversion: VirtualBox cpu_flags: - fpu - vme - de - pse - tsc ... cpu_model: Intel(R) Core(TM) i7-2620M CPU @ 2.70GHz cpuarch: x86_64 disks: - sda ...</span></span></code> </pre> <br><p>  Command output is trimmed. </p><br><p>  The desired Grains branch can be accessed by directly specifying it: </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver grains.get 'ip4_interfaces' testserver: ---------- eth0: - 10.0.2.15 eth1: - 192.168.33.75 lo: - 127.0.0.1</span></span></code> </pre> <br><p>  Or even more specifically: </p><br><pre> <code class="bash hljs">root@saltsshbox:~<span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver grains.get 'ip4_interfaces:eth1' testserver: - 192.168.33.75</span></span></code> </pre> <br><h4>  <strong>Salt master file and top.sls</strong> </h4><br><p>  Now it's time to tell about another important file <em>/ etc / salt / master</em> .  In general, it comes bundled with the <em>salt-master</em> package and defines some important logging options and directories in which the salt will look for our states and pillar data.  The default for states is the <em>/ srv / salt</em> directory.  But in practice it is often more rational to use a different structure, including for these examples. </p><br><p>  <strong>/ etc / salt / master:</strong> </p><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">state_verbose:</span></span> False <span class="hljs-symbol"><span class="hljs-symbol">state_output:</span></span> mixed <span class="hljs-symbol"><span class="hljs-symbol">file_roots:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">base:</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/srv/saltstack</span></span><span class="hljs-regexp"><span class="hljs-regexp">/salt pillar_roots: base: - /srv</span></span><span class="hljs-regexp"><span class="hljs-regexp">/saltstack/pillar</span></span></code> </pre> <br><p>  <em>state_verbose</em> and <em>state_output</em> are variables that are responsible for displaying the execution status on the screen.  In my opinion, this combination is the most practical, but I recommend to experiment. </p><br><p>  <em>file_roots</em> and <em>pillar_roots</em> indicate the paths to our state and pillar data, respectively. </p><br><p>  Important!  These paths may be several.  According to the principle of different environments, different data, etc.  etc., but this is a topic for a separate article on setting up a multi-environment environment, for a start, we just need to know where to put our state files for salt to find. </p><br><p>  Further, in each of these directories ( <em>file_roots</em> and <em>pillar_roots</em> ), salt will look for the files <em>top.sls</em> , which define the further logic of processing salt files. </p><br><p>  In our case: </p><br><p>  <strong>/srv/saltstack/salt/top.sls:</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">base</span></span>: <span class="hljs-string"><span class="hljs-string">'*'</span></span>: - common - timezone <span class="hljs-string"><span class="hljs-string">'testserver'</span></span>: - chrony</code> </pre> <br><p>  Which means for all hosts to apply state common and timezone, and for testserver to apply also <a href="http://chrony.tuxfamily.org/">chrony</a> (time synchronization service). </p><br><p>  For pillar, the top.sls file is also required.  Which will determine in what order and how variables will be assigned. <br>  <strong>/srv/saltstack/pillar/top.sls:</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">base</span></span>: <span class="hljs-string"><span class="hljs-string">'*'</span></span>: - timezone <span class="hljs-string"><span class="hljs-string">'testserver'</span></span>: - hosts/testserver</code> </pre> <br><p>  In our case, this file is extremely simple, it is indicated only to connect all the variables from the timezone.sls file and also connect the variables from the <em>hosts / testserver file</em> for our testserver, however, behind this simplicity is a powerful concept, since  variables can be assigned as you please and for any environment.  True, overlapping and merging of variables (Variables Overriding and Merging) is a separate topic, for now I‚Äôll say that priority is set from top to bottom.  Those.  if we had variables with timezone here in the hosts / testserver.sls file, they would have an advantage. </p><br><p>  In the files <em>top.sls</em> everything is indicated without the <em>.sls</em> extension. </p><br><h4>  <strong>Working with salt states</strong> </h4><br><p>  Let's get down to a simple state: </p><br><p>  <strong>/srv/saltstack/salt/packages.sls</strong> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Install some basic packages for Debian systems {% if grains['os_family'] == 'Debian' %} basepackages: pkg.installed: - pkgs: - lsof - sysstat - telnet {% endif %}</span></span></code> </pre> <br><p>  As you can see, here we used both jinja and grains and the pkg module itself. </p><br><p>  Let's try to apply this state in test mode: </p><br><pre> <code class="hljs pgsql">root@saltsshbox:/srv/saltstack# salt-ssh testserver state.sls packages test=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> ] Fetching file <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> saltenv <span class="hljs-string"><span class="hljs-string">'base'</span></span>, ** done ** <span class="hljs-string"><span class="hljs-string">'packages.sls'</span></span> testserver: <span class="hljs-type"><span class="hljs-type">Name</span></span>: basepackages - <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>: pkg.installed - Result: Differs <span class="hljs-keyword"><span class="hljs-keyword">Summary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testserver <span class="hljs-comment"><span class="hljs-comment">------------ Succeeded: 1 (unchanged=1) Failed: 0 ------------ Total states run: 1</span></span></code> </pre> <br><p>  And then in the real: </p><br><pre> <code class="hljs delphi">root@saltsshbox:/srv/saltstack# salt-ssh testserver state.sls packages [INFO ] Fetching <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> from saltenv <span class="hljs-string"><span class="hljs-string">'base'</span></span>, ** skipped ** latest already <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cache <span class="hljs-string"><span class="hljs-string">'salt://packages.sls'</span></span> testserver: <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: basepackages - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function">:</span></span> pkg.installed - Result: Changed Summary <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testserver ------------ Succeeded: <span class="hljs-number"><span class="hljs-number">1</span></span> (changed=<span class="hljs-number"><span class="hljs-number">1</span></span>) Failed: <span class="hljs-number"><span class="hljs-number">0</span></span> ------------ Total states run: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h4>  <strong>Salt Pillar or Variables</strong> </h4><br><p>  The next important link is <a href="https://docs.saltstack.com/en/latest/topics/pillar/">Pillar</a> .  So in SaltStack is called variables, or everything that is set by the wizard for remote systems.  In part, they are already familiar to you from the above, therefore, immediately to the point. </p><br><p>  Get all the pillar variables defined for the host: </p><br><pre> <code class="hljs ruby">root@saltsshbox<span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver pillar.items testserver: ---------- chrony: ---------- lookup: ---------- custom: # some custom addons # if you need it timezone: ---------- name: Europe/Moscow</span></span></code> </pre> <br><p>  As with Grains, you can request a single variable: </p><br><pre> <code class="hljs cs">salt-ssh testserver pillar.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-string"><span class="hljs-string">'timezone:name'</span></span></code> </pre> <br><h4>  <strong>Using state with pillar</strong> </h4><br><p>  Consider the following state: </p><br><p>  <strong>/srv/saltstack/salt/timezone.sls:</strong> </p><br><pre> <code class="python hljs">{%- set timezone = salt[<span class="hljs-string"><span class="hljs-string">'pillar.get'</span></span>](<span class="hljs-string"><span class="hljs-string">'timezone:name'</span></span>, <span class="hljs-string"><span class="hljs-string">'Europe/Dublin'</span></span>) %} {%- set utc = salt[<span class="hljs-string"><span class="hljs-string">'pillar.get'</span></span>](<span class="hljs-string"><span class="hljs-string">'timezone:utc'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) %} timezone_settings: timezone.system: - name: {{ timezone }} - utc: {{ utc }}</code> </pre> <br><p>  Here we set a variable based on data from pillar.  And in this design: </p><br><pre> <code class="hljs markdown">{%- set timezone = salt[<span class="hljs-string"><span class="hljs-string">'pillar.get'</span></span>](<span class="hljs-link"><span class="hljs-link">'timezone:name', 'Europe/Dublin'</span></span>) %}</code> </pre> <br><p>  <em>Europe / Dublin</em> is the default value if for some reason the salt cannot get the value from Pillar. </p><br><div class="spoiler">  <b class="spoiler_title">Perform:</b> <div class="spoiler_text"><pre> <code class="hljs delphi">root@saltsshbox:/srv/saltstack# salt-ssh testserver state.sls timezone [INFO ] Fetching <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> from saltenv <span class="hljs-string"><span class="hljs-string">'base'</span></span>, ** skipped ** latest already <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cache <span class="hljs-string"><span class="hljs-string">'salt://timezone.sls'</span></span> testserver: <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: Europe/Moscow - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function">:</span></span> timezone.system - Result: Changed Summary <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testserver ------------ Succeeded: <span class="hljs-number"><span class="hljs-number">1</span></span> (changed=<span class="hljs-number"><span class="hljs-number">1</span></span>) Failed: <span class="hljs-number"><span class="hljs-number">0</span></span> ------------ Total states run: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  <strong>Real life example</strong> </h4><br><p>  And finally, we have already reached a real life example.  Consider state time synchronization - chrony.  It is here with us: </p><br><p>  <em>/srv/saltstack/salt/chrony/init.sls</em> </p><br><p>  Moreover, <em>init.sls</em> is the default index, salt looks for it automatically, but you can use any other file. </p><br><p>  Here we will introduce another typical construction for salt - this is <em>map.jinja</em> . </p><br><p>  <strong>/srv/saltstack/salt/chrony/map.jinja:</strong> </p><br><pre> <code class="python hljs">{% set chrony = salt[<span class="hljs-string"><span class="hljs-string">'grains.filter_by'</span></span>]({ <span class="hljs-string"><span class="hljs-string">'RedHat'</span></span>: { <span class="hljs-string"><span class="hljs-string">'pkg'</span></span>: <span class="hljs-string"><span class="hljs-string">'chrony'</span></span>, <span class="hljs-string"><span class="hljs-string">'conf'</span></span>: <span class="hljs-string"><span class="hljs-string">'/etc/chrony.conf'</span></span>, <span class="hljs-string"><span class="hljs-string">'service'</span></span>: <span class="hljs-string"><span class="hljs-string">'chronyd'</span></span>, }, <span class="hljs-string"><span class="hljs-string">'Debian'</span></span>: { <span class="hljs-string"><span class="hljs-string">'pkg'</span></span>: <span class="hljs-string"><span class="hljs-string">'chrony'</span></span>, <span class="hljs-string"><span class="hljs-string">'conf'</span></span>: <span class="hljs-string"><span class="hljs-string">'/etc/chrony/chrony.conf'</span></span>, <span class="hljs-string"><span class="hljs-string">'service'</span></span>: <span class="hljs-string"><span class="hljs-string">'chrony'</span></span>, }, }, merge=salt[<span class="hljs-string"><span class="hljs-string">'pillar.get'</span></span>](<span class="hljs-string"><span class="hljs-string">'chrony:lookup'</span></span>)) %}</code> </pre> <br><p>  Its purpose is to create the necessary set of static variables for our system, but with the possibility of merging with variables from pillar, if you suddenly need to specify those. </p><br><p>  Next, <strong>/srv/saltstack/salt/chrony/init.sls</strong> itself <strong>:</strong> </p><br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"chrony/map.jinja"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chrony <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> context %} chrony: pkg.installed: - name: {{ chrony.pkg }} service: - name: {{ chrony.service }} - enable: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> - running - require: - pkg: {{ chrony.pkg }} - file: {{ chrony.conf }} {{ chrony.conf }}: file.managed: - name: {{ chrony.conf }} - source: salt://chrony/files/chrony.conf.jinja - template: jinja - user: root - group: root - mode: <span class="hljs-number"><span class="hljs-number">644</span></span> - watch_in: - service: {{ chrony.service }} - require: - pkg: {{ chrony.pkg }}</code> </pre> <br><p>  Here, the <em>salt</em> pattern deserves special attention <em>: //chrony/files/chrony.conf.jinja of the jinja</em> format. </p><br><p>  <strong>/srv/saltstack/salt/chrony/files/chrony.conf.jinja:</strong> </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># managed by SaltStack {%- set config = salt['pillar.get']('chrony:lookup', {}) -%} {%- set vals = { 'bindcmdaddress': config.get('bindcmdaddress','127.0.0.1'), 'custom': config.get('custom', ''), }%} ### chrony conf server 0.centos.pool.ntp.org iburst server 1.centos.pool.ntp.org iburst server 2.centos.pool.ntp.org iburst server 3.centos.pool.ntp.org iburst stratumweight 0 driftfile /var/lib/chrony/drift rtcsync makestep 10 3 bindcmdaddress {{ vals.bindcmdaddress }} bindcmdaddress ::1 keyfile /etc/chrony.keys commandkey 1 generatecommandkey noclientlog logchange 0.5 logdir /var/log/chrony {% if vals.custom -%} {{ vals.custom }} {%- endif %}</span></span></code> </pre> <br><p>  In this template, we also request variables from Pillar and process them.  You can see how this state was perceived by salt using <em>state.show_sls</em> : </p><br><div class="spoiler">  <b class="spoiler_title">Output salt-ssh testserver state.show_sls chrony</b> <div class="spoiler_text"><pre> <code class="bash hljs">root@saltsshbox:/srv/saltstack<span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver state.show_sls chrony [INFO ] Fetching file from saltenv 'base', ** done ** 'chrony/init.sls' [INFO ] Fetching file from saltenv 'base', ** done ** 'chrony/map.jinja' testserver: ---------- /etc/chrony/chrony.conf: ---------- __env__: base __sls__: chrony file: |_ ---------- name: /etc/chrony/chrony.conf |_ ---------- source: salt://chrony/files/chrony.conf.jinja |_ ---------- template: jinja |_ ---------- user: root |_ ---------- group: root |_ ---------- mode: 644 |_ ---------- watch_in: |_ ---------- service: chrony |_ ---------- require: |_ ---------- pkg: chrony - managed |_ ---------- order: 10002 chrony: ---------- __env__: base __sls__: chrony pkg: |_ ---------- name: chrony - installed |_ ---------- order: 10001 service: |_ ---------- name: chrony |_ ---------- enable: True - running |_ ---------- require: |_ ---------- pkg: chrony |_ ---------- file: /etc/chrony/chrony.conf |_ ---------- order: 10000 |_ ---------- watch: |_ ---------- file: /etc/chrony/chrony.conf</span></span></code> </pre> </div></div><br><p>  Next, just execute it: </p><br><pre> <code class="hljs delphi">root@saltsshbox:/srv/saltstack# salt-ssh testserver state.sls chrony testserver: <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: chrony - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function">:</span></span> pkg.installed - Result: Changed <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: /etc/chrony/chrony.conf - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>.managed - Result: Changed <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: chrony - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function">:</span></span> service.running - Result: Changed Summary <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testserver ------------ Succeeded: <span class="hljs-number"><span class="hljs-number">3</span></span> (changed=<span class="hljs-number"><span class="hljs-number">3</span></span>) Failed: <span class="hljs-number"><span class="hljs-number">0</span></span> ------------ Total states run: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Here, salt reports 3 completed state by the total number of modules involved.  If you rerun, you can see that no changes were made: </p><br><pre> <code class="hljs ruby">root@saltsshbox<span class="hljs-symbol"><span class="hljs-symbol">:/srv/saltstack</span></span><span class="hljs-comment"><span class="hljs-comment"># salt-ssh testserver state.sls chrony testserver: Summary for testserver ------------ Succeeded: 3 Failed: 0 ------------ Total states run: 3</span></span></code> </pre><br><p>  You can immediately see how the configuration file for chrony was formed: </p><br><pre> <code class="hljs cs">salt-ssh testserver cmd.run <span class="hljs-string"><span class="hljs-string">'cat /etc/chrony/chrony.conf'</span></span></code> </pre> <br><p>  Finally, it is worth mentioning another command <em>state.highstate</em> . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">salt-ssh</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testserver</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">state</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.highstate</span></span></code> </pre> <br><p>  It applies all the prescribed state for our test server. </p><br><h4>  <strong>Conclusion</strong> </h4><br><p>  So, we learned what salt-ssh from SaltStack is and how to use it.  We learned the key features of building the environment necessary for salt-ssh to work.  Set up a test environment using Vagrant.  And systematically conducted experiments with the fundamental concepts of SaltStack, such as: Grains, States, Pillar.  We also learned how to write state from simple to complex, reaching real examples that allow building further automation on our base. </p><br><p>  That's all for now.  There are still many interesting topics left overboard, but I hope that this information will help to start working with this wonderful configuration management system. </p><br><p>  <strong>Useful information:</strong> </p><br><p>  <a href="https://docs.saltstack.com/en/latest/topics/best_practices.html">best_practices</a> <br>  <a href="https://docs.saltstack.com/en/latest/topics/tutorials/walkthrough.html">walkthrough</a> <br>  <a href="https://docs.saltstack.com/en/latest/topics/tutorials/starting_states.html">starting_states</a> <br>  <a href="https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html">pillar</a> <br>  <a href="https://docs.saltstack.com/en/latest/topics/development/conventions/formulas.html">formulas</a> <br>  <a href="https://docs.saltstack.com/en/latest/topics/tutorials/">tutorials</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/303418/">https://habr.com/ru/post/303418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303406/index.html">Several useful tricks for developing on Yii 2</a></li>
<li><a href="../303408/index.html">Intuit has accelerated the site almost 5 times and increased conversion by 20%</a></li>
<li><a href="../303410/index.html">Adopted a law on Google tax</a></li>
<li><a href="../303412/index.html">Fake Ferrari or why camel hump. How systems with circumcised functionality try to take over the world</a></li>
<li><a href="../303416/index.html">Congratulations to the winners of the "Summer Sprint" PETAMelon</a></li>
<li><a href="../303420/index.html">Interview with the author of Flask Armin Rahner</a></li>
<li><a href="../303422/index.html">Salary negotiations - how not to burn</a></li>
<li><a href="../303424/index.html">Errors and problems of the Big Three servers: part three. Ibm</a></li>
<li><a href="../303426/index.html">Debugging php functions using phpdbg, as an alternative to Xdebug via IDE</a></li>
<li><a href="../303428/index.html">New L4 Load Balancer with native SRV record service discovery and Docker API service Discovery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>