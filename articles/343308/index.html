<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quantum versus classical: why do we need so many digits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Because of the general boom of the blockchain and every bigdata, another promising topic came down from the first lines of technical news - quantum co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quantum versus classical: why do we need so many digits</h1><div class="post__text post__text-html js-mediator-article">  Because of the general boom of the blockchain and every bigdata, another promising topic came down from the first lines of technical news - quantum computing.  And they, by the way, are able to turn several IT areas at once, starting with the notorious blockchain and ending with information security.  In the next two articles, Sberbank and Sberbank-Technologies will tell you what quantum computations are cool with and what they generally do with them now. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaa/d45/5f3/eaad455f3b9a90766d47f7aa6422b79a.jpg"><br><a name="habracut"></a><br><h2>  Classical calculations: AND, OR, NOT </h2><br>  To deal with quantum computing, it is worth to begin to refresh the knowledge of classical ones.  Here the unit of information processed is the bit.  Each bit can only be in one of two possible states - 0 or 1. A register of N bits can contain one of 2 <sup>N</sup> possible combinations of states and is represented as their sequence. <br><br>  To process and transform information, bitwise operations from Boolean algebra are used.  Basic operations are single-bit NOT and double-bit AND and OR.  Bit operations are described through truth tables.  They match the input arguments with the resulting value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The algorithm of classical calculations is a set of consecutive bit operations.  It is most convenient to reproduce it graphically, in the form of a diagram of functional elements (SFE), where each operation has its own designation.  Here is an example of an SFE to test two bits for equivalence. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ad/ade/2fd/2adade2fd956d2678a733063b2b9fdb7.png"><br><br><h2>  Quantum computing  Physical basis </h2><br>  Now let's move on to a new topic.  Quantum computing is an alternative to classical algorithms based on the processes of quantum physics.  It says that without interaction with other particles (that is, until the time of measurement), the electron does not have unambiguous coordinates on the orbit of the atom, but is simultaneously located in all points of the orbit.  The region in which the electron is located is called the electron cloud.  In a known experiment with two slits, one electron passes simultaneously through both slits, interfering with itself.  Only when measuring this uncertainty collapses and the coordinates of the electron become unambiguous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a24/ab9/b61/a24ab9b61f7bb6d7367eea29d939a36b.gif"><br><br>  The probabilistic nature of measurements inherent in quantum computation underlies many algorithms ‚Äî for example, searching in an unstructured database.  Algorithms of this type incrementally increase the amplitude of the correct result, allowing you to get it at the output with the maximum probability. <br><br><h2>  Qubits </h2><br>  In quantum computing, the physical properties of quantum objects are implemented in the so-called qubits (q-bit).  A classic bit can only be in one state - 0 or 1. A qubit before measurement can be in both states at the same time; therefore, it is usually denoted by the expression a | 0‚ü© + b | 1‚ü©, where A and B are complex numbers that satisfy the condition | A |  <sup>2</sup> + | B |  <sup>2</sup> = 1.  The measurement of a qubit instantly ‚Äúcollapses‚Äù its state into one of the basic ones, 0 or 1. At the same time, the ‚Äúcloud‚Äù collapses into a point, the initial state is destroyed, and all information about it is irretrievably lost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ede/535/598/ede535598d745c9ff695c3d4c21f7b1c.jpg"><br><br>  One of the uses of this property is <s>Schr√∂dinger's cat, a</s> generator of truly random numbers.  A qubit is entered into a state in which the result of measurement can be 1 or 0 with the same probability.  This state is described as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/of/tm/xy/oftmxygapw-wdhhcasfua5tq7mg.png"></div><br><br><h2>  Quantum and classical calculations.  First round </h2><br>  Let's start with the basics.  There is a set of input data for calculations, represented in binary format by vectors of length N. <br><br>  In classical calculations, only one of the <sup>2n</sup> data options is loaded into the computer's memory, and the function value is calculated for this variant.  As a result, only <i>one</i> of the 2 <sup>n</sup> possible data sets is processed simultaneously. <br><br>  All 2 <sup>n</sup> combinations of the initial data are simultaneously presented in the memory of a quantum computer.  Conversions are applied to all of these combinations at once.  As a result, in one operation, we calculate the function <i>for all</i> 2 <sup>n</sup> possible variants of the data set (the measurement will eventually only give one solution, but more on that later). <br><br>  Both classical and quantum computing use logical transformations - <i>gates</i> .  In classical calculations, the input and output values ‚Äã‚Äãare stored in different bits, which means that the number of inputs in gates can differ from the number of outputs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7e/e6b/34b/b7ee6b34b58e920ca1fb29455ae67459.png"><br><br>  Consider the real problem.  It is necessary to determine whether two bits are equivalent. <br><br>  If in classical calculations at the output we get one, then they are equivalent, otherwise there isn‚Äôt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/222/e68/d39/222e68d390d7dec230b05505890377f9.png"><br><br>  Now imagine this problem using quantum computing.  In them, all conversion gates have as many outputs as inputs.  This is due to the fact that the result of the transformation is not a new value, but a change in the state of the current. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/3c5/b24/5d03c5b2405dec5fcee9ea3d24b45f72.png"><br><br>  In the example, we compare the values ‚Äã‚Äãof the first and second qubits.  The result will be in the zero qubit - the qubit-flag.  This algorithm is applicable only to the base states - 0 or 1. Here is the order of quantum transformations. <br><br><ol><li>  We act on the qubit-flag with the ‚ÄúHe‚Äù gate, exposing it to 1. <br></li><li>  Two times we use the two-bit gate ‚ÄúControlled Not‚Äù.  This gate changes the value of the qubit flag to the opposite only if the second qubit involved in the transformation is in state 1. <br></li><li>  We measure the zero qubit.  If the result is 1, then both the first and second qubits are either both in state 1 (the qubit-flag has changed its value twice), or in state 0 (the qubit-flag has remained in state 1).  Otherwise, qubits are in different states. <br></li></ol><br><h2>  Next level.  Quantum single qubit gates of Pauli </h2><br>  Let's try to compare classical and quantum calculations in more serious problems.  For this we need a little more theoretical knowledge. <br><br>  In quantum computing, the processed information is encoded in quantum bits, the so-called qubits.  In the simplest case, a qubit, like the classic bit, can be in one of two basic states: | 0‚ü© (a short designation for the vector 1 | 0‚ü© + 0 | 1‚ü©) and | 1‚ü© (for the vector 0 | 0‚ü© + 1 | 1‚ü©).  The quantum register is a tensor product of the qubit vectors.  In the simplest case, when each qubit is in one of the basic states, the quantum register is equivalent to the classical one.  The register of two qubits in the state | 0&gt; can be described as follows: <br><br>  (1 | 0‚ü© + 0 | 1‚ü©) * (1 | 0‚ü© + 0 | 1‚ü©) = 1 | 00‚ü© + 0 | 01‚ü© + 0 | 10‚ü© + 0 | 11‚ü© = | 00‚ü©. <br><br>  For processing and transforming information in quantum algorithms, so-called quantum gates (gates) are used.  They are represented as a matrix.  To obtain the result of applying the gate, we need to multiply the vector characterizing the qubit by the gate's matrix.  The first coordinate of the vector is the factor in front of | 0, the second coordinate is the factor in front of | 1‚ü©.  The matrix of basic single-qubit gates looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7b/155/655/a7b155655e956231a9f0937cc5a3794e.png"><br><br>  Here is an example of using the gate Not: <br><br>  X * | 0‚ü© = X * (1 | 0‚ü© + 0 | 1‚ü©) = 0 | 0‚ü© + 1 | 1‚ü© = | 1‚ü© <br><br>  The multipliers before the base states are called amplitudes and are complex numbers.  The modulus of a complex number is equal to the root of the sum of the squares of the real and imaginary parts.  The square of the amplitude module facing the baseline state is equal to the probability of obtaining this baseline state when measuring the qubit, therefore the sum of squares of the amplitude modules is always 1. We could use arbitrary matrices for transformations over qubits, but due to the fact that the norm (length) vectors should always be equal to 1 (the sum of the probabilities of all outcomes is always 1), our transformation must preserve the norm of the vector.  So the transformation must be unitary and the corresponding matrix is ‚Äã‚Äãunitary.  Recall that the unitary transformation is reversible and UU <sup>‚Ä†</sup> = I. <br><br>  For more visual work with qubits, they are represented by vectors on the Bloch sphere.  In this interpretation, single-qubit gates represent the rotation of the qubit vector around one of the axes.  For example, the gate Not (X) rotates the qubit vector on Pi relative to the X axis. Thus, the state | 0&gt;, represented by a vector directed strictly upwards, changes to the state | 1&gt;, directed strictly downwards.  The state of a qubit on the Bloch sphere is defined by the formula cos (Œ∏ / 2) | 0‚ü© + e <sup>iœï</sup> sin (Œ∏ / 2) | 1‚ü© <br><br><img src="https://habrastorage.org/getpro/habr/post_images/684/0e7/7ed/6840e77ed0c6fc572bf94fb258c77a17.png"><br><br><h2>  Quantum two-qubit gates </h2><br>  To build algorithms, it is not enough for us to have single-qubit gates.  Gates are needed that carry out transformations depending on certain conditions.  The main such tool is the two-qubit gate CNOT.  This gate is applied to two qubits and inverts the second qubit only if the first qubit is in the | 1‚ü© state.  The CNOT gate matrix looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/ff2/7be/e66ff27bec26d7234d96e8da4e116e39.png"><br><br>  Here is an example of application: <br><br>  CNOT * | 10‚ü© = CNOT * (0 | 00‚ü© + 0 | 01‚ü© + 1 | 10‚ü© + 0 | 11‚ü©) = 0 | 00‚ü© + 0 | 01‚ü© + 1 | 11‚ü© + 0 | 10‚ü© = | 11‚ü© <br><br>  Using the CNOT gate is equivalent to performing the classic XOR operation with writing the result to the second qubit.  Indeed, if you look at the truth table of the operator XOR and CNOT, you will see a match: <br><br><table><tbody><tr><td colspan="3">  XOR <br></td><td colspan="2">  CNOT <br></td></tr><tr><td>  0 <br></td><td>  0 <br></td><td>  0 <br></td><td>  00 <br></td><td>  00 <br></td></tr><tr><td>  0 <br></td><td>  one <br></td><td>  one <br></td><td>  01 <br></td><td>  01 <br></td></tr><tr><td>  one <br></td><td>  0 <br></td><td>  one <br></td><td>  ten <br></td><td>  eleven <br></td></tr><tr><td>  one <br></td><td>  one <br></td><td>  0 <br></td><td>  eleven <br></td><td>  ten <br></td></tr></tbody></table><br><br>  The gate of CNOT has an interesting property - after its application, qubits are entangled or unraveled, depending on the initial state.  This will be shown in the next article, in the section on quantum parallelism. <br><br><h2>  Algorithm construction - classical and quantum implementation </h2><br>  Having a full arsenal of quantum gates, we can begin to develop quantum algorithms.  In the graphical representation, qubits are represented by straight lines - ‚Äústrings‚Äù, on which gates overlap.  The single qubit Pauli gates are denoted by the usual squares inside which the axis of rotation is depicted.  Gate CNOT looks a bit more complicated: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85e/8b9/227/85e8b922710d9aa0083fe79699847190.png"><br><br>  An example of the application of the gate CNOT: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/09f/b36/b9c/09fb36b9c84f7fa5bf380a1f46f9f04e.png"><br><br>  One of the most important actions in the algorithm is to measure the result.  Measurement is usually indicated by an arc scale with an arrow and the designation of which axis is being measured. <br><br>  So, let's try to build a classical and quantum algorithm, which adds 3 to the argument. <br><br>  Summing ordinary numbers with a bar implies performing two actions on each digit ‚Äî the sum of the digits themselves and the sum of the result with the transfer from the previous operation, if such transfer was. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/b65/18b/d34b6518b3b26024c05b6353a8105166.png" width="199" height="250"><br><br>  In the binary representation of numbers, the summation operation will consist of the same actions.  Here is the python code: <br><br><pre><code class="python hljs">arg = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]                     <span class="hljs-comment"><span class="hljs-comment">#  result = [0,0,0]                #  carry1 = arg[1] &amp; 0x1           #  0b11,          ,      = 1 result[2] = arg[1] ^ 0x1        #   carry2 = carry1 | arg[0]        #  0b11,          ,      = 1       result[1] = arg[0] ^ 0x1        #   result[1] ^= carry1             #     result[0] ^= carry2             #     print(result)</span></span></code> </pre> <br>  Now let's try to develop a similar program for a quantum calculator: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df2/b9c/aa2/df2b9caa2348b4f3f003a678be4fb0b8.png"><br><br>  In this scheme, the first two qubits are the argument, the next two are hyphens, the remaining 3 are the result.  This is how the algorithm works. <br><br><ol><li>  The first step before the barrier we put the argument in the same state as in the classic case - 0b11. <br></li><li>  Using the CNOT operator, we calculate the value of the first transfer ‚Äî the result of the operation arg &amp; 1 is equal to one only when arg is 1, in this case we invert the second qubit. <br></li><li>  The next 2 gates implement addition of the lower bits - we transfer the qubit 4 to the state | 1‚ü© and write the XOR result to it. <br></li><li>  The large rectangle indicates the gate CCNOT, an extension of the CNOT gate.  In this gate, there are two control qubits and the third is inverted only if the first two are in the | 1 state.  The combination of 2 gate CNOT and one CCNOT gives us the result of the classic operation carry2 = carry1 |  arg [0].  The first 2 gates set a carry to unit if one of them is equal to 1, and the CCNOT gate handles the case when they both are equal to one. <br></li><li>  We add higher qubits and carry qubits. <br></li></ol><br><h2>  Intermediate conclusions </h2><br>  By running both examples, we get the same result.  On a quantum computer, this will take more time, because it is necessary to conduct an additional compilation into a quantum-assembler code and send it to execution to the cloud.  The use of quantum computing would make sense if the speed of performing their elementary operations ‚Äî gates ‚Äî would be many times less than in the classical model. <br><br>  Measurements of experts show that the execution of one gate takes about 1 nanosecond.  So the algorithms for a quantum computer must not copy the classical ones, but rather use the unique properties of quantum mechanics to the maximum.  In the next article we will examine one of the main such properties - quantum parallelism - and talk about quantum optimization in general.  Then we determine the most appropriate areas for quantum computing and discuss their application. <br><br>  <i>Based on materials by <a href="https://habrahabr.ru/users/dsapaev/">Dmitry Sapayev</a> , senior director of IT development in the development department of Sberbank Technologies, and Dmitry Bulychkov, project director at the Center for Technological Innovations of Sberbank.</i> <i><br></i> <br><br>  <b>UPD</b> : We published the <a href="https://habrahabr.ru/company/sberbank/blog/344830/">second part of the article</a> , where we dive into quantum computations more deeply and talk about their practical application. </div><p>Source: <a href="https://habr.com/ru/post/343308/">https://habr.com/ru/post/343308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343298/index.html">Integration tests for Java using TestContainers. Less madness, more order, all automatically</a></li>
<li><a href="../343300/index.html">We compare what is impossible: cheap hosting and cloud on the VMware stack</a></li>
<li><a href="../343302/index.html">ScadaPy JSON server</a></li>
<li><a href="../343304/index.html">Binary Matrix Neural Network</a></li>
<li><a href="../343306/index.html">How to deal with cheaters and not rewrite all code</a></li>
<li><a href="../343310/index.html">Regular expressions for the smallest</a></li>
<li><a href="../343312/index.html">Setting up an environment for web development in Windows based on VMware Player virtual machine</a></li>
<li><a href="../343314/index.html">Atomic icebreaker Lenin - almost like a spaceship, only an icebreaker</a></li>
<li><a href="../343316/index.html">What is hidden behind the term modeling</a></li>
<li><a href="../343318/index.html">How to describe layout in code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>