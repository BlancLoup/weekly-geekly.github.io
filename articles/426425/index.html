<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 14. Memory sections: introduction and basic services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The memory sections were mentioned earlier in one of the previous articles (# 6), where a comparison was made with the standard C function of the mall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 14. Memory sections: introduction and basic services</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br>  The memory sections were mentioned earlier in one of the previous articles (# 6), where a comparison was made with the standard C function of the <b>malloc ()</b> language.  A partition is a region of memory derived from the partition pool (memory pool).  Memory sharing provides a flexible way to reliably and deterministically allocate and free memory. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Using sections </h2><br>  In the Nucleus SE, partition pools are configured during creation.  Up to 16 partition pools can be in one application.  If they are not configured, data structures and service calls related to these pools will not be included in the application. <br><br>  A partition pool is a memory area divided into a fixed number of fixed-size blocks.  The developer fully controls the size and number of partitions in each pool.  Tasks can request allocated sections of memory and receive a pointer to the storage area and should not record data outside the allocated section.  A section can be freed by any task when passing an API function pointer.  A request to allocate a partition when there are no free partitions may result in an error or suspension of the request, depending on the selected API call parameters and the configuration of the Nucleus SE. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Configuring memory sections </h2><br><h3>  Number of partition pools </h3><br>  As with most Nucleus SE objects, partition pool configuration is mainly done using the <b>#define</b> directive in <b>nuse_config.h</b> .  The main parameter is <b>NUSE_PARTITION_POOL_NUMBER</b> , which determines how many partition pools are defined in the application.  The default value is 0 (i.e. partition pools are not used), the developer can set any value from 0 to 16. A different value will result in a compilation error that was detected during the check in <b>nuse_config_check.h</b> (it is included in <b>nuse_config.c</b> , and therefore compiles with this module), which results in the compilation of the <b>#error</b> directive. <br><br>  The choice of a non-zero value is a priority way to activate partition pools.  This leads to the definition of data structures and the assignment of the appropriate size.  The data structures in the ROM must be initialized with appropriate values ‚Äã‚Äãdescribing each partition pool.  More details about the data structures will be in the next article.  This selection also activates the API settings. <br><br><h3>  Activate API calls </h3><br>  Each API function (service call) in the Nucleus SE is activated by the <b>#define</b> directive in <b>nuse_config.h</b> .  For partition pools, these include: <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br>  By default, they are all set to <b>FALSE</b> , thus disabling every service call and preventing the implementation code from being included.  To configure partition pools in the application, you need to select the necessary API calls and set the corresponding directives to <b>TRUE</b> . <br><br>  The following is an excerpt from the default <b>nuse_config.h</b> file: <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br>  If the partition pool API function is activated, but the pools are not configured, a compilation error occurs (except for <b>NUSE_Partition_Pool_Count ()</b> , which is always allowed).  If your code uses an API call that has not been activated, a build error will occur because the implementation code was not included in the application. <br><br><h2>  Partition Pool Utility Calls </h2><br>  Nucleus RTOS supports seven service calls related to partition pools, which provide the following functionality: <br><br><table><tbody><tr><th>  <b>Description of the functional</b> </th><th>  <b>Nucleus RTOS</b> </th><th>  <b>Nucleus SE</b> </th></tr><tr><td>  Section selection </td><td>  <b>NU_Allocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Allocate ()</b> </td></tr><tr><td>  Release section </td><td>  <b>NU_Deallocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Deallocate ()</b> </td></tr><tr><td>  Provision of information <br>  about a specific partition pool </td><td>  <b>NU_Partition_Pool_Information ()</b> </td><td>  <b>NUSE_Partition_Pool_Information ()</b> </td></tr><tr><td>  Returning the value of the quantity (currently) configured <br>  partition pools in the application </td><td>  <b>NU_Established_Partition_Pools ()</b> </td><td>  <b>NUSE_Partition_Pool_Count ()</b> </td></tr><tr><td>  Add (create) new partition pool to application </td><td>  <b>NU_Create_Partition_Pool ()</b> </td><td>  Not implemented. </td></tr><tr><td>  Change (delete) partition pool from application </td><td>  <b>NU_Delete_Partition_Pool ()</b> </td><td>  Not implemented. </td></tr><tr><td>  Return pointers to all partition pools that currently exist in the application. </td><td>  <b>NU_Partition_Pool_Pointers ()</b> </td><td>  Not implemented. </td></tr></tbody></table><br>  The implementation of each call will be discussed in detail. <br><br>  It is worth noting that neither the Nucleus RTOS nor the Nucleus SE has a reload function.  This is intentional.  Very often, one task allocates a section and passes a pointer to another task (which may later release it).  If you reboot the partition pool, all partitions will be marked as unused; however, there is no mechanism for tracking and notifying all tasks that the partitions can use. <br><br><h2>  Partition allocation and release services </h2><br>  Fundamental partition pooling operations ‚Äî allocating partitions in a pool (that is, marking a partition as used and returning its address) and freeing a partition (that is, marking a partition as unused).  Nucleus RTOS and Nucleus SE provide two basic API calls for these operations, described below. <br><br><h3>  Section selection </h3><br>  Calling the Nucleus RTOS API to allocate a partition is very flexible, which allows developers to suspend tasks for an indefinite period of time or without a timeout if the operation cannot be completed immediately, for example, when you try to allocate a partition from a pool in which all partitions are already distributed.  Nucleus SE provides the same service, only the suspension of tasks in it is optional, and the timeout is not implemented. <br><br><h3>  Calling the Nucleus RTOS API to highlight a partition </h3><br>  Call prototype: <br><br>  <b>STATUS NU_Allocate_Partition (NU_PARTITION_POOL * pool, VOID ** return_pointer, UNSIGNED suspend);</b> <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_NO_PARTITION</b> - no sections available; <br>  <b>NU_INVALID_POOL</b> - invalid partition pool pointer; <br>  <b>NU_INVALID_POINTER</b> - passed null pointer to the returned data ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> ‚Äî An attempt to suspend a task was made from a thread not associated with a task; <br>  <b>NU_TIMEOUT</b> - no partitions are available, even after pausing for a specified waiting period; <br>  <b>NU_POOL_DELETED</b> - the partition pool was deleted when the task was suspended. <br><br><h3>  Calling the Nucleus SE API to allocate a section </h3><br>  This API call supports the core Nucleus RTOS API. <br><br>  Call prototype: <br><br>  <b>STATUS NUSE_Partition_Allocate (NUSE_PARTITION_POOL pool, ADDR * return_pointer, U8 suspend);</b> <br><br>  Options: <br><br>  <b>pool</b> - the index (ID) of the partition pool used; <br>  <b>return_pointer</b> is a pointer to a variable of type <b>ADDR</b> that accepts the address of the section to be allocated; <br>  <b>suspend</b> - the parameter to pause the task; it can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_NO_PARTITION</b> - no partitions available; <br>  <b>NUSE_INVALID_POOL</b> - incorrect partition pool index; <br>  <b>NUSE_INVALID_POINTER</b> - passed null pointer to the returned data ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND ‚ÄîThe</b> attempt to suspend a task was made from a thread not associated with the task or when the blocking API functions are disabled. <br><br><h3>  Implementing partitioning in the Nucleus SE </h3><br>  The code of the API function <b>NUSE_Partition_Allocate</b> is selected using conditional compilation after checking the parameters, depending on whether the blocking API call is activated (task paused) or not.  Below we will separately consider these two options. <br><br>  If blocking calls are deactivated, the API call is quite simple: <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br>  First, the availability of free partitions is checked.  If there are no such partitions, an error is returned ( <b>NUSE_NO_PARTITION</b> ).  Then there is a search of partitions, during which the first bytes are checked for the presence of zero values ‚Äã‚Äã(which means that the section is not used).  When such a partition is found, it is assigned a ‚Äúused‚Äù flag, including the index of the partition pool (see ‚ÄúFreeing the partition‚Äù below), and a pointer to the next byte (the beginning of the real data area) is returned.  An explanation of the data structures of the section pools will be presented in the next article in the section ‚ÄúData Structures‚Äù. <br><br>  If blocking is activated, the code for this API call becomes a bit more complicated: <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br>  The code is enclosed in a <b>do ... while loop</b> , which continues to work while the pause parameter is <b>NUSE_SUSPEND</b> . <br><br>  If no partitions are available and the suspend option is <b>NUSE_NO_SUSPEND</b> , the API call stops and returns the value <b>NUSE_NO_PARTITION</b> .  If the suspend parameter was set to <b>NUSE_SUSPEND</b> , the task is suspended.  When returned (for example, when the task is resumed), the return value of <b>NUSE_SUCCESS</b> indicates that the task was resumed because the section of memory was released and the code returns to the beginning of the cycle.  Since there are no API functions for reloading partition pools, tasks cannot be resumed for other reasons, but for the stability of blocking other types of objects, the <b>NUSE_Task_Blocking_Return []</b> checking process is preserved. <br><br><h3>  Release section </h3><br>  Releasing a partition in the Nucleus RTOS and Nucleus SE makes it available again.  Before release, no check is made whether this section is used by any task or not; the application programmer is responsible for this.  To free a partition, only a pointer to the data area is required. <br><br><h3>  Call the Nucleus RTOS API to release the partition </h3><br>  Call prototype: <br><br>  <b>STATUS NU_Deallocate_Partition (VOID * partition);</b> <br><br>  Options: <br><br>  <b>partition</b> - pointer to the data area (returned by the <b>NU_Allocate_Partition ()</b> function) of the partition being freed; <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_POINTER</b> is a null section pointer ( <b>NULL</b> ), or does not indicate a valid used section. <br><br><h3>  Calling the Nucleus SE API to free a partition </h3><br>  This API call supports the core Nucleus RTOS API. <br><br>  Call prototype: <br><br>  <b>STATUS NUSE_Partition_Deallocate (ADDR partition);</b> <br><br>  Options: <br><br>  <b>partition</b> - a pointer to the data area (returned by the <b>NUSE_Partition_Allocate ()</b> function) of the partition being freed <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_POINTER</b> is a null section pointer ( <b>NULL</b> ), or does not indicate a valid used section <br><br><h3>  Implementation </h3><br>  Instead of implementing using the blocking and non-blocking functions of the API, the <b>NUSE_Partition_Deallocate ()</b> function simply contains a conditionally compiled section that is responsible for unlocking tasks.  This code implements the release of the sections themselves: <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br>  First, the partition index is retrieved from its state byte.  Then, the partition status changes to ‚Äúunused‚Äù, the counter of the used partitions decreases, and the function reports the successful completion of the operation. <br><br>  If blocking is activated, the following code is used to resume tasks that are waiting for the available partition pool: <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br>  If tasks were blocked while allocating partitions in this pool, the first table is resumed. <br><br>  The next article will discuss additional API calls related to memory sections, as well as data structures associated with them. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK. </div><p>Source: <a href="https://habr.com/ru/post/426425/">https://habr.com/ru/post/426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426415/index.html">Fintech-digest: control by digitalization by the Central Bank, salary in cryptocurrency, ‚ÄúWorld‚Äù map in the form of bracelets and keyrings</a></li>
<li><a href="../426417/index.html">Pavel 2.0: Reptiloid consultant on JS, node.js with sockets and telephony</a></li>
<li><a href="../426419/index.html">Overloading that is prohibited or bridge methods in Java</a></li>
<li><a href="../426421/index.html">EHCI in Russian</a></li>
<li><a href="../426423/index.html">mmWave in smartphones: how Qualcomm made the impossible possible</a></li>
<li><a href="../426427/index.html">Useful things to "things": a small selection with low prices</a></li>
<li><a href="../426429/index.html">Installing FreeSWITCH 1.8 on Debian 9 (Raspbian Stretch, the basic image of the SmartDomain system MajorDoMo on Rasbperri Pi)</a></li>
<li><a href="../426431/index.html">Qlie visual story engine disassembly</a></li>
<li><a href="../426433/index.html">Delicious SMM for restaurant</a></li>
<li><a href="../426435/index.html">The best specialists are those that I myself have prepared: a course on testing games from the experts of Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>