<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparing Azure Queues and Service Bus Queues services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microsoft Azure supports two types of queuing mechanisms: Azure Queues and Service Bus Queues . 

 Azure Queues , is part of the Azure storage infrast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparing Azure Queues and Service Bus Queues services</h1><div class="post__text post__text-html js-mediator-article">  Microsoft Azure supports two types of queuing mechanisms: <b>Azure Queues</b> and <b>Service Bus Queues</b> . <br><br>  <b>Azure Queues</b> , is part of the <a href="http://www.windowsazure.com/en-us/home/features/data-management/">Azure storage</a> infrastructure, providing a simple REST-oriented Get / Put / Peek interface for reliable, guaranteed delivery of messages within a service or between several services. <br><br>  <b>Service Bus Queues</b> is part of the <a href="http://www.windowsazure.com/en-us/home/features/messaging/">Azure messaging</a> infrastructure, which deals with queuing, publishing / subscribing, web services and integration patterns (more about this <a href="http://msdn.microsoft.com/en-us/library/hh410103.aspx">Overview of Service Bus Messaging Patterns</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Services run in parallel, Azure Queues appeared earlier as a separate queue mechanism built on top of Azure storage services. <br>  Service Bus Queues are built on top of the ‚Äúmessage broker‚Äù infrastructure, designed to connect applications or application components that may require support for various protocols, work in different domains or network environments. <br><br>  This article compares these two queuing systems, focusing on differences in their behavior and implementation.  The article also gives advice on choosing the type of queue, which is better suited to your application. <br><a name="habracut"></a><br><br><h4>  Considerations on the choice of technology </h4><br>  Both Azure Queues and Service Bus Queues are queue services on the Microsoft Azure platform.  They have a slightly different set of features, so you can use one of them, or the other, or both together - depending on what your application needs.  Below are recommendations for selection. <br><br>  So, <b>you should choose Azure Queues</b> , if: <br><ul><li>  Your application needs to store more than 80 GB of data in one queue, and each message exists for no more than 7 days. </li><li>  Your application needs to monitor the processing status of the message in the queue.  For example, you want to be aware of the fall of the worker who processed the message, and when this event occurs, transfer further processing to another worker. </li><li>  You need logs of all transactions in your queue. </li></ul><br><br>  <b>You should choose Service Bus Queues</b> if: <br><ul><li>  You need to be able to receive messages without a permanent polling.  Service Bus Queues supports TCP-protocol, allowing you to quickly receive information about new messages. </li><li>  You need to ensure that the message handling order (FIFO) is maintained. </li><li>  You have experience with <a href="http://msdn.microsoft.com/en-us/library/dn282144.aspx">Service Bus for Windows Server</a> and you want to use it when working with queues in Azure. </li><li>  You want to automatically detect duplicate messages. </li><li>  You want in your application to process messages in parallel in the so-called ‚Äúthreads‚Äù (messages are associated with the stream by <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.brokeredmessage.sessionid.aspx">SessionId</a> ).  In this model, each application node receiving messages is responsible for processing one stream.  When a thread is transferred to the processing node, the latter can work with the stream using transactions. </li><li>  Your application needs to be transactional when sending or receiving a group of messages. </li><li>  The lifetime (TTL) of a message can exceed 7 days. </li><li>  Your application needs to process messages larger than 64 KB (but no more than 256 KB). </li><li>  You need to provide a role-based security model, to implement different levels of access rights for both providers and consumers of messages. </li><li>  The total size of all messages in the queue does not exceed 80 GB. </li><li>  You want to use the AMQP 1.0 protocol for working with messages.  More information here - <a href="http://msdn.microsoft.com/en-us/library/jj841072.aspx">Service Bus AMQP Overview</a> . </li><li>  You assume the theoretical possibility of transition from the ‚Äúone supplier, one recipient‚Äù model to a model, where messages can be generated by several suppliers and redirected to more than one recipient (possibly, according to some filtering rules). </li><li>  You need a ‚Äúat-most-once‚Äù type of delivery guarantee and you don‚Äôt want to build a special infrastructure for this. </li><li>  You need the ability to batch send and receive messages. </li><li>  You need full integration with the Windows Communication Foundation (WCF) stack and the .NET Framework. </li></ul><br><br><h4>  Comparing Azure Queues and Service Bus Queues </h4><br><br>  The tables in the following sections are divided into logical groups, each of which compares Azure Queues and Service Bus Queues in some parameters. <br><br><h4>  Fundamental features </h4><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Guaranteed to maintain order </td><td>  <b>Not</b> </td><td>  <b>Yes - FIFO</b> <br>  (through the use of sessions) </td></tr><tr><td>  Delivery guarantee </td><td>  <b>"At least once"</b> </td><td>  <b>"At least once"</b> <b><br></b>  <b>‚ÄúMaximum once‚Äù</b> </td></tr><tr><td>  Transaction support </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  (through the use of local transactions) </td></tr><tr><td>  Method of obtaining </td><td>  <b>Not blockable</b> <br>  (ends immediately if there are no new messages) </td><td>  <b>Lockable with or without timeout</b> <br>  (see ‚Äú <a href="http://en.wikipedia.org/wiki/Comet_(programming)">Comet technique</a> ‚Äù) <br><br>  <b>Not blockable</b> <br>  (through the use of the .NET API) </td></tr><tr><td>  Pushing messages by the server to the client </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  <a href="http://msdn.microsoft.com/en-us/library/jj908682.aspx">OnMessage</a> and <a href="http://msdn.microsoft.com/en-us/library/dn632585.aspx">OnMessage sessions</a> .NET API </td></tr><tr><td>  Method of obtaining </td><td>  <b>Peek &amp; Lease</b> </td><td>  <b>Peek &amp; lock</b> <br>  <b>Receive &amp; Delete</b> </td></tr><tr><td>  Exclusive access to the message </td><td>  <b>Based on Lease</b> </td><td>  <b>Based on lock</b> </td></tr><tr><td>  Lease / Lock timeout duration </td><td>  <b>30 seconds (default)</b> <br>  <b>7 days (maximum)</b> <br>  (can be updated or reset using the <a href="http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.queue.cloudqueue.updatemessage(v%3Dazure.10).aspx">UpdateMessage</a> API) </td><td>  <b>60 seconds (default)</b> <br>  (can be updated or reset using the <a href="http://msdn.microsoft.com/en-us/library/windowsazure/microsoft.servicebus.messaging.brokeredmessage.renewlock.aspx">RenewLock</a> API) </td></tr><tr><td>  Lease / Lock Granularity </td><td>  <b>At the message level</b> <br>  (each message can have its own timeout, for each message it can be changed using the UpdateMessage API) </td><td>  <b>At the queue level</b> <br>  (each queue has its own timeout, which applies to all messages in this queue, the timeout can be updated using the <a href="http://msdn.microsoft.com/en-us/library/windowsazure/microsoft.servicebus.messaging.brokeredmessage.renewlock.aspx">RenewLock</a> API) </td></tr><tr><td>  Batch receipt </td><td>  <b>Yes</b> <br>  (when receiving it is explicitly indicated how many messages are required, maximum - 32) </td><td>  <b>Yes</b> <br>  (implicitly through the inclusion of preloading or explicitly through transactions) </td></tr><tr><td>  Batch shipping </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  (via transaction or batch sending on client side) </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  If you already use Azure Storage Blobs and Tables and start using queues, you still have guaranteed availability of services within 99.9%.  If you use Blobs and Tables with Service Bus Queues, reliability will be less. </li><li>  Guaranteed Message Delivery (FIFO) in the Service Bus Queues requires the use of transactions.  If an application crashes while the message is in <b>Peek &amp; Lock</b> mode, after the application is restarted, it will receive the same message as soon as the TTL expires. </li><li>  Azure Queues is designed to support standard queuing scenarios, such as splitting application components to increase scalability and resilience to individual component failures. </li><li>  Service Bus Queues supports the At-Least-Once delivery guarantee model.  In addition, the ‚ÄúMaximum Once‚Äù model can be implemented with the help of transactions and atomic receipt of messages with updating the session state.  Azure Workflow service uses this technique to provide its ‚ÄúMaximum Once‚Äù warranty. </li><li>  Azure Queues provides a unified and consistent access interface, similar to the access interface to tables and blobs, which can be convenient if you need to use all these services. </li><li>  Service Bus Queues provides local transaction support in the context of each queue. </li><li>  The ‚ÄúReceive and Delete‚Äù mode supported by Service Bus Queues allows reducing the number of operations for receiving messages in exchange for a reduced guarantee of their receipt. </li><li>  Azure Queues allows you to handle the amount of message processing timeout.  A worker can quickly process ‚Äúshort‚Äù messages, and if he suddenly falls, messages will be promptly transferred to another worker.  At the same time, if the worker just needs more time to process the message, it can increase its timeout, making it clear that the message is still being processed. </li><li>  Azure Queues allow you to set a timeout "invisibility" of the message when it is published.  The message will be available to the consumer only after this timeout expires.  Service Bus Queues also allows you to set such a timeout, but only at the level of the queue metadata. </li><li>  The maximum timeout for blocking the operation of receiving messages in the Service Bus Queues is 24 days.  However, when using the REST interface, this timeout is 55 seconds. </li><li>  Client-side batch operations provided by Service Bus Queues allow multiple messages to be combined into a single send operation.  Batch send is available only for an asynchronous send operation. </li><li>  Supporting up to 200 TB of data in Azure Queues queues (and even more in the case of account virtualization) and an unlimited number of queues makes this service an ideal platform for SaaS providers. </li><li>  Azure Queues provides a flexible and efficient access delegation mechanism. </li></ul><br><br><h5>  Additional features </h5><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Scheduled Delivery </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Automatic labeling of "dead" messages </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Increase the lifetime of the message in the queue </td><td>  <b>Yes</b> <br>  (update timeout separately for each message in the queue) </td><td>  <b>Yes</b> <br>  (separate API function) </td></tr><tr><td>  Support for not fully processed messages </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Post update </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Server side transaction log </td><td>  <b>Yes</b> </td><td>  <b>Not</b> </td></tr><tr><td>  Storage metrics </td><td>  <b>Yes</b> <br>  <b>Minute metrics:</b> real-time for availability, TPS, number of API calls, number of errors, etc., see About Storage Analytics Metrics </td><td>  <b>Yes</b> <br>  ( <a href="http://msdn.microsoft.com/en-us/library/hh293128.aspx">GetQueues</a> method) </td></tr><tr><td>  State management </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.entitystatus.aspx">Microsoft.ServiceBus.Messaging.EntityStatus.Active</a> , <br>  <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.entitystatus.aspx">Microsoft.ServiceBus.Messaging.EntityStatus.Disabled</a> , <br>  <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.entitystatus.aspx">Microsoft.ServiceBus.Messaging.EntityStatus.SendDisabled</a> , <br>  <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.entitystatus.aspx">Microsoft.ServiceBus.Messaging.EntityStatus.ReceiveDisabled</a> </td></tr><tr><td>  Auto message forwarding </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Clearing the entire queue </td><td>  <b>Yes</b> </td><td>  <b>Not</b> </td></tr><tr><td>  Message groups </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  (via session posts) </td></tr><tr><td>  Application status for a group of messages </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Duplicate detection </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  (configurable on the sender side) </td></tr><tr><td>  WCF integration </td><td>  <b>Not</b> </td><td>  <b>Yes</b> <br>  (WCF - binding provided) </td></tr><tr><td>  Integration with WF </td><td>  <b>External</b> <br>  (requires building your own WF activities) </td><td>  <b>Built</b> <br>  (provided by WF activities) </td></tr><tr><td>  Message Viewer Groups </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Selection of messages of certain messages by session ID </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  Both technologies of queues allow to postpone delivery of the message for a certain time. </li><li>  Automatic message redirection allows you to collect messages from thousands of queues into one queue.  You can use this mechanism to ensure security, control processes and isolate message providers from each other. </li><li>  Azure Queues supports the ability to change message content.  You can use this to update the progress of the task corresponding to this message, so that, if necessary, show this information to the user or continue processing from the desired stage, rather than first.  In Service Bus Queues, you can implement a similar scenario using sessions.  Session allows you to save and retrieve application state (using the <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagesession.setstate.aspx">SetState</a> and <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagesession.getstate.aspx">GetState methods</a> ). </li><li>  The dead letter handling mechanism, which is supported by Service Bus Queues, allows you to isolate messages that cannot be successfully processed by the recipient or that have expired (TTL).  Such messages will be moved to a special queue called $ DeadLetterQueue. </li><li>  A partially similar mechanism can be implemented in Azure Queues on the application side ‚Äî by checking the <a href="http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storageclient.cloudqueuemessage.dequeuecount.aspx">DequeueCount</a> property, <a href="http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storageclient.cloudqueuemessage.dequeuecount.aspx">you</a> can redirect certain messages to another queue. </li><li>  Azure Queues allows you to get a detailed log of all transactions for each queue, as well as some aggregated metrics.  Both features are very useful for debugging and understanding how your applications use the queue.  They also help optimize performance and minimize costs when using queues. </li><li> The concept of "message sessions", supported by Service Bus Queues, allows each message to belong to a logical group that can be associated with an individual recipient.  You can use this functionality by filling in the <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.brokeredmessage.sessionid.aspx">SessionID</a> field for each message.  The recipient can then only request messages with a specific <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.brokeredmessage.sessionid.aspx">SessionID</a> from the queue. </li><li>  The duplicate detection mechanism supported by the Service Bus Queues automatically removes messages with the same <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.brokeredmessage.messageid.aspx">MessageID</a> from the queue. </li></ul><br><br><h4>  Capacity and quotas </h4><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Maximum queue size </td><td>  <b>200 TB</b> <br>  (limited by total storage for one account) </td><td>  <b>From 1 GB to 80 GB</b> (determined at the stage of creating a queue) </td></tr><tr><td>  Maximum message size </td><td>  <b>64 KB</b> <br>  (48 KB using <b>Base64</b> encoding) Azure supports large messages by combining queues and blobs - so you can store up to 200 GB of data in a single message </td><td>  <b>256 KB</b> (including header and message body, maximum header size is 64 KB) </td></tr><tr><td>  Maximum message lifetime </td><td>  <b>7 days</b> </td><td>  <b>Not limited</b> </td></tr><tr><td>  Maximum number of queues </td><td>  <b>Not limited</b> </td><td>  <b>10,000</b> <br>  (per namespace, can be increased) </td></tr><tr><td>  Maximum number of customers </td><td>  <b>Not limited</b> </td><td>  <b>Not limited</b> <br>  (100 connections for TCP clients) </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  For Azure Queues, if the message content contains characters that cannot be stored in XML, it must be encoded in <b>Base64</b> .  Please note that in this case the size of the payload in the message should not exceed 48 KB. </li><li>  For Service Bus Queues, each message consists of a header and body.  The total size of the message should not exceed 256 KB. </li><li>  When customers use Service Bus Qeues via TCP, the total number of active connections to one queue should not exceed 100. Both senders and recipients are counted.  If this quota is reached, subsequent requests will be rejected.  This limit does not apply to customers who use the queue through the REST API. </li><li>  Service Bus Queues has limits on queue size.  They are set when creating a queue and can be from 1 to 80 GB.  If the limit is reached, the next message will not be accepted into the queue.  More information - <a href="http://msdn.microsoft.com/en-us/library/ee732538.aspx">Azure Service Bus Quotas</a> . </li><li>  If you need more than 10,000 Service Bus Queues in the same namespace, you can contact Azure technical support and ask for a limit increase for you.  But it may be easier and faster to create additional namespace through the Microsoft Azure Management Portal. </li></ul><br><br><h4>  Management and access </h4><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Control protocol </td><td>  <b>REST over HTTP / HTTPS</b> </td><td>  <b>REST over HTTPS</b> </td></tr><tr><td>  Transaction protocol </td><td>  <b>REST over HTTP / HTTPS</b> </td><td>  <b>REST over HTTPS</b> <br>  <b>AMQP 1.0 Standard (TCP with TLS)</b> </td></tr><tr><td>  .NET API </td><td>  <b>Yes</b> <br>  (.NET Storage Client API) </td><td>  <b>Yes</b> <br>  (.NET API for message brokers) </td></tr><tr><td>  Native c ++ </td><td>  <b>Yes</b> </td><td>  <b>Not</b> </td></tr><tr><td>  Java API </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  PHP API </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Node.js API </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr><tr><td>  Support for custom metadata </td><td>  <b>Yes</b> </td><td>  <b>Not</b> </td></tr><tr><td>  Queue Naming Rules </td><td>  <b>Up to 63 characters</b> <br>  (letters must be lowercase) </td><td>  <b>Up to 260 characters</b> <br>  (queue names are case-insensitive) </td></tr><tr><td>  Getting the number of messages in the queue </td><td>  <b>Yes</b> <br>  (approximate, excluding messages for which TTL has expired and they are in the process of being deleted) </td><td>  <b>Yes</b> <br>  (exact) </td></tr><tr><td>  The function of viewing messages in the queue without their selection </td><td>  <b>Yes</b> </td><td>  <b>Yes</b> </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  Azure queues provides the ability to add an arbitrary amount of metadata in the form of key / value pairs to the queue. </li><li>  Both queuing technologies allow you to view messages in the queue without modifying / deleting them, which can be useful for implementing queuing tools. </li><li>  Service Bus supports TCP-based .NET API, which works more efficiently than REST requests or AMQP 1.0 protocol. </li><li>  The queue name in Azure Queue can be from 3 to 63 characters long, can include letters in different case, numbers and hyphens.  More information - <a href="http://msdn.microsoft.com/en-us/library/windowsazure/dd179349.aspx">Naming Queues and Metadata</a> . </li><li>  The queue name in the Service Bus Queue can be up to 260 characters and can include the characters '.', '-' and '_' in addition to letters and numbers. </li></ul><br><br><h5>  Performance </h5><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Maximum throughput </td><td>  <b>Up to 2000 messages per second</b> <br>  (for 1 KB messages) </td><td>  <b>Up to 2000 messages per second</b> <br>  (for 1 KB messages) </td></tr><tr><td>  Average delay </td><td>  <b>10 ms</b> <br>  (with TCP Nagle disabled) </td><td>  <b>20-25 ms</b> </td></tr><tr><td>  Overload behavior </td><td>  <b>HTTP code 503</b> <br>  (request is not paid) </td><td>  <b>HTTP code 503</b> <br>  (request is not paid) </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  One Azure Queue can handle up to 2000 transactions per second.  A transaction is a <b>Put</b> , <b>Get,</b> and <b>Delete</b> operation.  Sending one message to a queue ( <b>Put</b> ) is considered one transaction, but receiving a message is often a two-step operation ‚Äî you must first receive a message ( <b>Get</b> ) and then delete it from the queue ( <b>Delete</b> ), which results in two transactions.  Do not forget that in order to reduce the number of transactions you can receive in one request up to 32 messages, although you will have to remove them from the queue anyway.  You can create more queues to increase bandwidth (the total number is unlimited). </li><li>  When your application tries to process more than 2000 messages per second, you will receive an ‚ÄúHTTP 503 Server Busy‚Äù response.  In this case, you should reduce the frequency of calls to the queue. </li><li>  The delay in Azure Queues is on average 10 ms when processing messages up to 10 KB when working from an Azure virtual machine located in the same region as the queue </li><li>  Both queue services reject requests to queues in case of exceeding the maximum possible bandwidth.  Both services do not consider such requests paid. </li><li>  Service Bus Queues performance tests have shown that one queue can handle up to 2000 messages per second at a message size of 1 KB.  To provide more bandwidth, use multiple queues.  More information - <a href="http://msdn.microsoft.com/en-us/library/hh528527.aspx">Best Practices for Performance Improvement Service Bus Brokered Messaging</a> . </li><li>  When maximum throughput is reached when using Service Bus Queues, you will get a <a href="http://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.serverbusyexception.aspx">ServerBusExException</a> (when using the .NET API) or ‚ÄúHTTP 503 Server Busy‚Äù (when using the REST API). </li></ul><br><br><h4>  Authentication and authorization </h4><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Authentication </td><td>  <b>By symmetric key</b> </td><td>  <b>By symmetric key</b> </td></tr><tr><td>  Access control model </td><td>  Delegated access to SAS tokens </td><td>  RBAC over ACS </td></tr><tr><td>  Identity Provider Consolidation </td><td>  <b>Not</b> </td><td>  <b>Yes</b> </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  Each request to the queue must be authenticated.  Queues with public anonymous access are not supported.  Using SAS, you can build different scenarios for your application. </li><li>  The authentication scheme in Azure Queues is to use a symmetric key, which is a SHA-256 hash sum encoded in <b>Base64</b> .  More information on authentication in Azure Queues - <a href="http://msdn.microsoft.com/en-us/library/hh225339.aspx">Authenticating Access to Your Storage Account</a> , for Service Bus Queues - <a href="http://msdn.microsoft.com/en-us/library/dn170477.aspx">Shared Access Signature Authentication with Service Bus</a> . </li><li>  The Microsoft Azure Active Directory Access Control (also known as Access Control Service or ACS) supported Service Bus provides three different roles: <b>Admin</b> , <b>Sender</b> and <b>Receiver</b> , which are not currently supported by Azure Queues. </li><li>  Because the Service Bus supports integration with ACS, you can set up federation with Active Directory (through the use of ADFS) and publicly available identification providers such as Live ID, Google, Facebook or Yahoo. </li></ul><br><br><h4>  Prices </h4><br><table><tbody><tr><th>  Comparison criterion </th><th>  Azure queues </th><th>  Service Bus Queues </th></tr><tr><td>  Transaction cost </td><td>  <b>$ 0.0005</b> <br>  (per 10,000 transactions) </td><td>  <b>$ 0.01</b> <br>  (per 10,000 posts) </td></tr><tr><td>  Paid operations </td><td>  <b>Everything</b> </td><td>  <b>Only Send and Receive</b> <br>  (the rest are free) </td></tr><tr><td>  Idle transactions </td><td>  <b>Are paid</b> <br>  (a request for a message with an empty queue costs as much as a request for messages) </td><td>  <b>Are paid</b> <br>  (request for a message from an empty queue is charged as receiving a single message) </td></tr><tr><td>  Data storage cost </td><td>  <b>$ 0.07</b> <br>  (per GB per month) </td><td>  <b>$ 0.00</b> <br></td></tr><tr><td>  Cost of external traffic </td><td>  <b>$ 0.12 - $ 0.19</b> <br>  (depends on the data center) </td><td>  <b>$ 0.12 - $ 0.19</b> <br>  (depends on the data center) </td></tr></tbody></table><br><br><h5>  Additional Information </h5><br><ul><li>  Data transfer is charged based on the total amount of data originating from the Azure data center to the Internet for the paid period. </li><li>  Data transfer between Azure services within a single data center is free of charge. </li><li>  Currently, incoming traffic is not paid. </li><li>  The cost of ACS transactions when using the Service Bus Queues is very small.  Service Bus Queues generates one ACS token for each queue and uses it until it becomes outdated (about 20 minutes).  Thus, the number of transactions is not directly proportional to the number of ACS transactions. </li><li>  In situations where the message must be received very quickly, it is more cost-effective to use the Service Bus Queues and the notification mechanism when new messages arrive. </li></ul><br><br><h5>  Comment </h5><br>  Prices may vary.  Look at the <a href="http://www.windowsazure.com/en-us/pricing/details">Pricing Overview</a> page. <br><br><h4>  Conclusion </h4><br><br>  The decision to choose between Azure Queues and Service Bus Queues depends on many factors, the needs of your application and its architecture.  If you‚Äôre already using other Azure services, such as tables or blobs, you‚Äôll just start using Azure Queues, especially if you only need basic queue usage scenarios.  On the other hand, Service Bus Queues offers a number of additional features, such as sessions, transactions, duplicate detection, automatic processing of ‚Äúdead‚Äù messages, which may be necessary for your application. </div><p>Source: <a href="https://habr.com/ru/post/223863/">https://habr.com/ru/post/223863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223849/index.html">Rear printer: a view from the side of the head</a></li>
<li><a href="../223851/index.html">Why conspiracy theories arise and how to deal with them</a></li>
<li><a href="../223853/index.html">Home Security System</a></li>
<li><a href="../223857/index.html">Production of key components ITER has begun.</a></li>
<li><a href="../223861/index.html">GOkey: data cable, battery, USB flash drive and key detector in one bottle</a></li>
<li><a href="../223867/index.html">Vibrating Insoles - wearable technology that you did not expect. (concept)</a></li>
<li><a href="../223869/index.html">MBLOK Wireless Storage on Kickstarter</a></li>
<li><a href="../223873/index.html">Distribution of scientific software. Is free</a></li>
<li><a href="../223877/index.html">How Host-tracker helped to quickly detect malicious code</a></li>
<li><a href="../223883/index.html">Electric for regular airlines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>