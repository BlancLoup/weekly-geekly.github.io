<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize Caffe Neural Network Platform for Intel Architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern programs that claim to be effective should take into account the specifics of the hardware on which they will be executed. In particular, we ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize Caffe Neural Network Platform for Intel Architecture</h1><div class="post__text post__text-html js-mediator-article">  Modern programs that claim to be effective should take into account the specifics of the hardware on which they will be executed.  In particular, we are talking about multi-core processors, for example, such as Intel Xeon and Intel Xeon Phi, large cache sizes, instruction sets, say, Intel AVX2 and Intel AVX-512, which allow for improved computing performance. <br><br> <a href="https://habrahabr.ru/company/intel/blog/315582/"><img src="https://habrastorage.org/files/fc6/249/28c/fc624928c2334398ba90872d12ed055c.jpg"></a> <br>  <font color="#999999"><i>Barely resist, so as not to joke about Russiano)</i></font> <br><br>  For example, Caffe is a popular platform for developing deep learning neural networks.  It was created at Berkley Vision and Learning Center (BVLC), it was liked by the community of independent developers who make a contribution to its development.  The platform lives and develops, the proof of this is the statistics on <a href="https://github.com/BVLC/caffe">the project page</a> in GitHub.  Caffe is called the ‚Äúfast open platform for deep learning.‚Äù  Is it possible to speed up such a ‚Äúfast‚Äù set of tools?  Asking this question, we decided to optimize Caffe for Intel architecture. <br><a name="habracut"></a><br>  Looking ahead, thanks to integration with the Intel Math Kernel Library 2017 and a set of optimizations that we performed, following the plan outlined in <a href="https://software.intel.com/en-us/articles/what-is-code-modernization">this</a> material, we started working on Intel processors more than 10 times faster than the basic version, which we, in hereinafter, we will call BVLC Caffe.  The version optimized for the architecture of Intel, further, for short, will be called Intel Caffe.  <a href="https://github.com/intel/caffe">Here is</a> its source code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main areas of performance improvement, details of which are described below, were to refactor code, to optimize it for using sets of vector instructions, such as Intel AVX2, to fine tune the compilation, to increase the efficiency of multi-threaded code execution using OpenMP.  Tests were conducted on a system with two Intel Xeon processors.  In particular, we investigated the speed of the neural network built by Caffe using the images from the CIFAR-10 set.  The results of the program execution were analyzed in Intel VTune Amplifier XE 2017 and with the help of other tools. <br><br>  A similar approach can be used to improve the performance of a variety of programs, for example, other platforms for deep learning of neural networks. <br><br>  Before proceeding to the questions of optimization, we will discuss the algorithms of deep learning and the problems that are solved with their help. <br><br><h2>  <font color="#0071c5">About deep learning algorithms</font> </h2><br>  In-depth learning algorithms are part of a more general class of machine learning algorithms, which in recent years have shown significant results in image recognition on photos and videos, in speech recognition, in natural language processing, and in other areas where you have to deal with huge amounts of information and solve data analysis problems.  The success of deep learning is based on the latest advances in computing and algorithms, in the ability to handle large data sets.  The principle of operation of such algorithms is that the data is passed through the layers of the network in which information is transformed, extracting more and more complex features from it. <br><br>  Here is an example of how each level of the deep neural network is trained to identify the signs of increasing complexity.  It shows a small set of features recognized by a deep network, rendered as images in shades of gray.  It also shows the original color images, the processing of which leads to the selection of these signs.  The image is taken <a href="https://www.cs.nyu.edu/~fergus/papers/zeilerECCV2014.pdf">from here</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/427/ae4/b2e/427ae4b2ebe8b7c355fa94fb04fdc0c5.png"><br>  <i><font color="#999999">Convolutional neural network</font></i> <br><br>  The work of deep learning algorithms with a teacher requires a marked set of data.  Three popular types of deep neural networks that train with a teacher are multilayer perceptron (Multilayer Perceptron, MLM), convolutional neural networks (Convolution Neural Network, CNN), and recurrent neural networks (Recurrent Neural Network, RNN).  In these networks, the input data, as it passes through each layer of the network, is subjected to a series of linear and non-linear transformations.  As a result, the network output is generated.  The network response is compared with the expected result, errors are found, then, for the output layer, the error surface gradient vector is calculated, the contribution that the synaptic weights of the neurons contribute to the network response, taking into account the activation functions, then the same procedure is performed for other layers, applying previously obtained data.  This teaching method is called the backpropagation algorithm; as a result of its use, a stepwise modification of the weights of the neurons of the network is performed. <br><br>  In multilayer perceptrons, the input data in each layer (represented by a vector) is first multiplied by a completely filled weighting matrix unique to the layer.  In recurrent networks, such a matrix (or matrices) is the same for each layer (since the layer is recurrent), and the properties of the network depend on the input signal.  Convolution networks are similar to multilayer perceptrons, but they use sparse matrices for hidden layers, called convolutional.  In such networks, matrix multiplication is represented by a convolution matrix representation of the weights with a matrix representation of the input data of the layer.  Convolution networks are popular in image recognition, but they are used in both speech recognition and natural language processing.  <a href="http://cs231n.github.io/convolutional-networks/">Here</a> you can read about such networks in more detail. <br><br><h2>  <font color="#0071c5">Caffe, CIFAR-10 and image classification</font> </h2><br>  As already mentioned, here we are going to optimize for the Intel BVLC Caffe architecture ‚Äî a popular platform for creating and researching deep learning networks.  We will test the original and optimized version of the platform using the <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> data set, which is often used in image classification problems, and <a href="https://github.com/BVLC/caffe/blob/master/examples/cifar10/cifar10_full_sigmoid_train_test_bn.prototxt">the</a> neural network <a href="https://github.com/BVLC/caffe/blob/master/examples/cifar10/cifar10_full_sigmoid_train_test_bn.prototxt">model</a> built in Caffe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d5/47c/388/7d547c388e0f72ba9fc8d19a05a22390.png"><br>  <i><font color="#999999">Sample images from the CIFAR-10 set</font></i> <br><br>  The CIFAR-10 dataset consists of 60000 color images of 32x32 pixels divided into 10 classes: plane, car, bird, cat, deer, dog, frog, horse, ship, and truck.  Classes do not intersect.  For example, there is no overlap between the classes "car" and "truck".  ‚ÄúCars‚Äù include, for example, sedans and SUVs.  The ‚Äútruck‚Äù class includes only heavy trucks, and, for example, pick-up trucks are not found in any group of images. <br><br>  The network used during performance testing contains layers of various types.  In particular, these are layers with a sigmoid activation function (such layers, in Caffe terminology, have Sigmoid type), convolutional layers (Convolution type), spatial association layers or, as they are also called, subsampling layers (Pooling type), packet normalization layers ( type BatchNorm), fully connected layers (type InnerProduct).  At the output of the network is a layer with the activation function Softmax (type SoftmaxWithLoss).  We will talk more about this network and its layers below.  Now let's proceed to the analysis of the original version of Caffe. <br><br><h2>  <font color="#0071c5">Initial performance analysis</font> </h2><br>  One method for evaluating the performance of BVLC Caffe and Intel Caffe is to use the <b>time</b> command, which calculates the time it takes for the signal to travel through the layers in the forward and reverse directions.  This command is very useful for measuring the time spent on calculations in each level, and to obtain a comparative execution time for different models: <br><br><pre><code class="hljs pgsql">./build/tools/caffe <span class="hljs-type"><span class="hljs-type">time</span></span> \    <span class="hljs-comment"><span class="hljs-comment">--model=examples/cifar10/cifar10_full_sigmoid_train_test_bn.prototxt \    -iterations 1000</span></span></code> </pre> <br>  In this case, ‚Äúiteration‚Äù (what sets the <b>iteration</b> parameter) is one forward and backward pass through the batch of images.  The above command displays the average execution time for 1000 iterations, both for individual layers and for the entire network.  Here are the results of the work of this team for BVLC Caffe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/494/b15/d19/494b15d19c46bbf7ff45de3be3639bd2.png"><br>  <i><font color="#999999">BVLC Caffe time command output</font></i> <br><br>  In the tests, we used a system with two sockets.  Each had an Intel Xeon E5-2699 v3 processor (2.3 GHz) with 18 physical cores.  At the same time, Intel Hyper-Threading Technology was disabled.  Thus, in the system, there were only 36 physical processor cores and the same number of OpenMP threads as specified using the environment variable <b>OMP_NUM_THREADS</b> .  Unless otherwise indicated, this configuration was used in our experiments.  Please note that we recommend allowing Intel Caffe to automatically set OpenMP environment variables instead of setting them yourself.  The system also has 64 GB of DDR4 memory, which operates at a frequency of 2.133 MHz. <br><br>  Here are the results of performance testing, which was achieved by optimizing the code by Intel engineers.  We used the following tools to measure performance: <br><br><ul><li>  Callgrind from the Valgrind toolkit. </li><li>  Intel VTune Amplifier XE 2017 beta. </li></ul><br>  Tools from Intel VTune Amplifier XE provide the following information: <br><br><ul><li>  Functions that create the greatest load on the system (hotspots). </li><li>  System calls (including task switching). </li><li>  CPU and cache usage. </li><li>  Load distribution across OpenMP threads. </li><li>  Thread locks </li><li>  Memory usage. </li></ul><br>  Performance analyzes can be used to find suitable candidates for optimization, such as functions that put a heavy load on the system, and function calls that are performed for a relatively long time. <br><br>  The figure below shows a summary of BVLC Caffe performance data from Intel VTune, obtained after performing 100 iterations.  Elapsed Time, located at the top of the figure, is 37 seconds.  This is the time it took to execute the code on the test system.  CPU Time, processor time, is 1306 seconds.  This is slightly less than 37 seconds, multiplied by 36 cores (1332 seconds).  This indicator represents the total duration of code execution in all threads (or on all cores, since in our case Intel HT technology has been disabled), which are used in the calculations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eae/98b/b98/eae98bb98defdfd57171cb2c42c3a604.png"><br>  <i><font color="#999999">General results of the analysis of the performance of BVLC Caffe on the CIFAR-10 data set in the Intel VTune Amplifier XE 2017 beta</font></i> <br><br>  The processor utilization histogram, which is located at the bottom of the figure, indicates how often a certain number of threads are used at the same time during the test.  In this case, out of 37 seconds, 14 falls on one thread (that is, on one core).  All the rest of the time, we see very inefficient multi-threaded processing, with mostly less than 20 threads participating in the work. <br><br>  The Top Hotspots section, located in the middle of the figure, indicates which features work the most.  Here are the function calls and the contribution of each of them to the total CPU time.  The <b>kmp_fork_barrier</b> function is an external OpenMP function, which takes 1130 seconds of CPU time to execute code.  This means that about 87% of the processor's working time is spent on threads that are idle in this barrier function, without doing anything useful. <br><br>  In the source code of BVLC Caffe there is a line <b>#pragma omp parallel</b> .  However, in the code itself, there is no obvious use of the OpenMP library for organizing multi-threaded data processing.  At the same time, inside Intel MKL, OpenMP streams are used to parallelize the execution of some basic mathematical calculations.  In order to confirm this parallelization, we can use the Bottom-up tab in Intel VTune XE, the contents of which, after testing BVLC Caffe on the CIFAR-10 data set, are shown in the figure below.  Here you can find a list of function calls and additional information about them.  In particular, we are interested in the indicators of Effective Time by Utilization (the upper part of the tab) and the indicators of the distribution of the load created by the functions over the flows (the lower part). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/beb/a84/cf8/beba84cf83d7b0ad8d7b7fe0e19c497f.png"><br>  <i><font color="#999999">Visualization of the time parameters of the execution of functions and the list of functions that most heavily load the system when executing BVLC Caffe on the CIFAR-10 data set</font></i> <br><br>  The <b>gemm_omp_driver_v2</b> function is part of the <b>libmkl_intel_thread.so</b> library - a generic implementation of matrix multiplication (GEMM) from Intel MKL.  The internal mechanisms of this function involve OpenMP multithreading.  The multiplication function of matrices from Intel MKL is the main function used in the forward and backward propagation procedures, that is, in the operations of obtaining a network response and its learning.  Intel MKL uses multi-threaded execution, which typically reduces GEMM computation time.  However, in this particular case, the convolution operation for 32x32 images creates a not too heavy load on the system, which makes it impossible to effectively use all 36 OpenMP streams on 36 cores in one GEMM operation.  Therefore, as will be shown below, the use of various multi-threading schemes and parallelization of code execution is required. <br><br>  In order to demonstrate the additional load on the system, which is created by the need to work with multiple OpenMP threads, we run the same code with the environment variable <b>OMP_NUM_THREADS = 1</b> , and then we compared the execution time with the previous result.  What we did is shown in the figure below.  Here we see the Elapsed Time indicator, equal to 31.1 seconds, instead of 37 seconds from the previous test.  By writing a unit to the environment variable, we forced OpenMP to create only one thread and use it to execute the code.  The resulting difference of almost six seconds indicates an additional load on the system, which is caused by the initialization and synchronization of OpenMP threads. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b40/efd/954/b40efd954cc2bada96f835aab4c320ee.png"><br>  <i><font color="#999999">General results of the analysis of the performance of the BVLC Caffe on the CIFAR-10 data set in the Intel VTune Amplifier XE 2017 beta using a single stream</font></i> <br><br>  In the central part of the above figure there is a list of functions that most heavily load the system.  Among them, we found three main candidates for optimization.  Namely, these are the functions <b>im2col_cpu</b> , <b>col2im_cpu</b> , and <b>PoolingLayer :: Forward_cpu</b> . <br><br><h2>  <font color="#0071c5">Code optimization</font> </h2><br>  Working with a CIFAR-10 dataset in a Caffe environment optimized for Intel architecture is about 13.5 times faster than using BVLC Caffe.  The figure below shows the average results after 1000 iterations.  On the left are BVLC Caffe data, on the right - Intel Caffe.  It can be seen that in the first case, the total execution time was 270 ms, and in the second - 20 ms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/555/dcf/8c0/555dcf8c0b99e8e894583d78f94c3237.png"><br>  <i><font color="#999999">BVLC Caffe vs. Intel Caffe performance comparison</font></i> <br><br>  Details on how to set calculation parameters for layers can be found <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">here</a> . <br>  The next section will describe the optimizations used to improve the performance of the calculations used in different layers.  We followed the <a href="https://software.intel.com/en-us/articles/what-is-code-modernization">tutorials</a> from the Intel Modern Code program.  Some of the optimizations are based on basic math functions from Intel MKL 2017. <br><br><h2>  <font color="#0071c5">Scalar and sequential optimization</font> </h2><br><h3>  <font color="#0071c5">‚ñç Code vectorization</font> </h3><br>  After profiling the BVLC Caffe code and identifying the most loaded functions that consume the most CPU time, we began work on code vectorization.  Among the changes were the following: <br><br><ul><li>  Improved work with libraries of Basic Linear Algebra Subprograms (BLAS), namely - the transition from Automatically Tuned Linear Algebra System (ATLAS) to Intel MKL. </li><li>  Optimization in the process of assembling code (using JIT-assembler Xbyak). </li><li>  Code vectorization using GNU Compiler Collection (GCC) and OpenMP. </li></ul><br>  BVLC Caffe has the ability to use Intel MKL BLAS function calls or other implementations of the same mechanisms.  For example, the GEMM feature is optimized for vectorization, multi-threaded execution, and efficient use of cache memory.  To improve vectorization, we also used Xbyak - JIT-assembler for x86 (IA-32) and x64 (AMD64 or x86-64) architectures.  Xbyak supports the following sets of vector instructions: MMX, Intel Streaming SIMD Extensions (Intel SSE), Intel SSE2, Intel SSE3, Intel SSE4, floating point compute module, Intel AVX, Intel AVX2 and Intel AVX-512. <br><br>  Xbyak is an x86 / x64 assembler for C ++, a library specially created to increase the efficiency of code execution.  Xbyak is provided as a header file.  It can dynamically collect mnemonic instructions for x86 and x64 architectures.  JIT-generation of binary code in the process of execution provides additional optimization options.  For example, this is the optimization of quantization, the operation of element-by-element division of one array into another, or the optimization of polynomial calculations due to the automatic creation of the necessary functions during program execution.  With support for Intel AVX and Intel AVX2 vector instruction sets, Xbyak can achieve a better level of code vectorization in Caffe optimized for Intel architecture.  The latest version of Xbyak has support for the Intel AVX-512 vector instruction set.  This allows you to improve computing performance on Intel Xeon Phi x200 family processors. <br><br>  Improving the performance of vectorization allows Xbyak, using SIMD instructions, to process more data at the same time, which allows for more efficient use of parallel data processing.  We used Xbyak to optimize the code, which significantly improved the performance of calculations in layers of spatial union.  If you know the parameters of the spatial union, you can generate assembler code for specific models of union, which uses a specific data processing window or algorithm.  The result is a completely normal-looking build, which, as has been proven, works more efficiently than C ++ code compiled without using Xbyak. <br><br><h3>  <font color="#0071c5">‚ñçGeneral code optimization</font> </h3><br>  Other sequential optimizations included the following: <br><br><ul><li>  Reducing the complexity of algorithms. </li><li>  Reducing the amount of computation. </li><li>  Unrolling loops. </li></ul><br>  Getting rid of repeated code execution, the results of which do not change - this is one of the scalar optimization techniques that we used.  This was done in order to calculate in advance what would otherwise be calculated inside the loop with a maximum depth of nesting. <br>  Consider, for example, this code snippet: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; h_col &lt; height_col; ++h_col) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; w_col &lt; width_col; ++w_col) {   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_im = h_col * stride_h - pad_h + h_offset;   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w_im = w_col * stride_w - pad_w + w_offset;</code> </pre> <br>  The third line of this fragment, for calculating the variable <b>h_im</b> , does not use the index of the internal cycle <b>w_col</b> .  But despite this, the calculation of this variable is performed in each iteration of the nested loop.  Alternatively, we can move this line beyond the limits of the inner loop, leading the code to this form: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; h_col &lt; height_col; ++h_col) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_im = h_col * stride_h - pad_h + h_offset; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; w_col &lt; width_col; ++w_col) {   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w_im = w_col * stride_w - pad_w + w_offset;</code> </pre> <br><h2>  <font color="#0071c5">Processor-specific optimizations, systems, and other general approaches to improving code</font> </h2><br>  Here are some additional general code optimizations that have been applied: <br><br><ul><li>  Improved implementation of the <b>im2col_cpu</b> and <b>col2im_cpu functions</b> . </li><li>  Reducing the complexity of the batch normalization operation. </li><li>  CPU and system specific optimizations. </li><li>  Using a single core per computing thread. </li><li>  Elimination of movement of threads between computational cores. </li></ul><br>  Intel VTune Amplifier XE found that the <b>im2col_cpu</b> function is one of the most heavily loaded systems.  This means that she is a good candidate for performance optimization.  The <b>im2col_cpu</b> function is the implementation of a standard step in a direct convolution operation.  Each local fragment is expanded into a separate vector, the entire image is converted into a larger matrix (which increases the intensity of working with memory), the lines of which correspond to the many places where filters were applied. <br><br>  One optimization technique for the <b>im2col_cpu</b> function is to reduce the number of operations required to access data.  In the BVLC Caffe code, there are three nested loops in which the image pixels are traversed: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; c_col &lt; channels_col; ++c_col) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; h_col &lt; height_col; ++h_col)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w_col = <span class="hljs-number"><span class="hljs-number">0</span></span>; w_col &lt; width_col; ++w_col)     data_col[(c_col*height_col+h_col)*width_col+w_col] = <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br>  In this BVLC code snippet, Caffe initially calculated the corresponding indices of the array of <b>data_col</b> elements, although the indices of this array are simply processed sequentially.  Thus, four arithmetic operations (two additions and two multiplications) can be replaced by a single index increment operation.  In addition, the complexity of checking the condition can be reduced based on the following: <br><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/*     int  unsigned   ,     a    ,  ,    b.   b ‚Äì unsigned,   ,  ,    ,  0x800‚Ä¶,             ,  ,  0x800‚Ä¶        . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_a_ge_zero_and_a_lt_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt;(a) &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt;(b); }</code> </pre> <br>  In the BVLC Caffe code, there was a check of a condition of the form <b>if (x&gt; = 0 &amp;&amp; x &lt;N)</b> , where <b>x</b> and <b>N</b> are signed integers, while <b>N</b> is always a positive number.  Converting these integers to unsigned integers allows you to change the comparison interval.  Instead of performing two operations of comparing and calculating the logical <b>AND</b> , after the type conversion, one comparison is sufficient: <br><br><pre> <code class="hljs lisp">if (((<span class="hljs-name"><span class="hljs-name">unsigned</span></span>) x) &lt; ((<span class="hljs-name"><span class="hljs-name">unsigned</span></span>) N))</code> </pre> <br>  In order to avoid the operating system moving threads between compute cores, we used the OpenMP environment variable: <b>KMP_AFFINITY = compact, granularity = fine</b> .  The compact arrangement of neighboring threads can improve the performance of GEMM operations, since threads that work together with the same last-level cache (LLC) can reuse data previously written to cache lines. <br><br>  <a href="http://arxiv.org/pdf/1602.06709v1.pdf">Here is the</a> material in which you can find details about the optimization associated with blocking the cache, about the features of the optimal composition of data and vectorization. <br><br><h2>  <font color="#0071c5">Code parallelization using OpenMP</font> </h2><br><h3>  <font color="#0071c5">‚ñç Neural network layers</font> </h3><br>  During the use of OpenMP-parallelization, the following neural network mechanisms were optimized: <br><br><ul><li>  Convolution Layer (Convolution). </li><li>  Deconvolution transformation layer. </li><li>  Local normalization layer (LRN). </li><li>  Layer with a semi-linear activation function (Rectified-Linear Unit, ReLU) </li><li>  Layer with Softmax activation function. </li><li>  Concatenation layer. </li><li>  Utilities for OpenBLAS optimization, such as the <b>vPowx</b> operation <b>- y [i] = x [i] Œ≤, the</b> operations <b>caffe_set</b> , <b>caffe_copy</b> , and <b>caffe_rng_bernoulli</b> . </li><li>  The layer of spatial union, or subsamples (Pooling). </li><li>  Layer ‚Äúthinning‚Äù network to prevent the effect of retraining (Dropout). </li><li>  Batch normalization layer. </li><li>  Data layer. </li><li>  Layer for performing elementwise operations (Eltwise). </li></ul><br><h3>  <font color="#0071c5">Configuration layer</font> </h3><br>  The convolution layer, which is quite consistent with its name, performs convolution of the input data using a set of weights modified during the training of the network, or filters, each of which allows to get one feature map in the output image.  This optimization prevents insufficient use of hardware resources for one set of input feature maps. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">template</span></span> &lt;typename <span class="hljs-type"><span class="hljs-type">Dtype</span></span>&gt; void <span class="hljs-type"><span class="hljs-type">ConvolutionLayer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dtype</span></span>&gt;::<span class="hljs-type"><span class="hljs-type">Forward_cpu</span></span>(const vector&lt;<span class="hljs-type"><span class="hljs-type">Blob</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dtype</span></span>&gt;*&gt;&amp; \     bottom, const vector&lt;<span class="hljs-type"><span class="hljs-type">Blob</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dtype</span></span>&gt;*&gt;&amp; top) { const <span class="hljs-type"><span class="hljs-type">Dtype</span></span>* weight = this-&gt;blobs_[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;cpu_data(); //     ,    ,  //     ( ,  <span class="hljs-number"><span class="hljs-number">36</span></span> //    ). //    <span class="hljs-type"><span class="hljs-type">MKL</span></span>. for (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bottom.size(); ++i) {   const <span class="hljs-type"><span class="hljs-type">Dtype</span></span>* bottom_data = bottom[i]-&gt;cpu_data();   <span class="hljs-type"><span class="hljs-type">Dtype</span></span>* top_data = top[i]-&gt;mutable_cpu_data(); #ifdef _OPENMP   #pragma omp parallel for num_threads(this-&gt;num_of_threads_) #endif     for (int n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; this-&gt;num_; ++n) {       this-&gt;forward_cpu_gemm(bottom_data + n*this-&gt;bottom_dim_,                              weight,                              top_data + n*this-&gt;top_dim_);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this-&gt;bias_term_) {         const <span class="hljs-type"><span class="hljs-type">Dtype</span></span>* bias = this-&gt;blobs_[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;cpu_data();         this-&gt;forward_cpu_bias(top_data + n * this-&gt;top_dim_, bias);       }     } } }</code> </pre> <br>  We process <b>k = min (num_threads, batch_size)</b> of <b>input_feature</b> map <b>sets</b> .  For example, <b>k</b> <b>im2col</b> operations occur in parallel and <b>k</b> calls are made to Intel MKL.  Intel MKL switches to single-threaded execution mode automatically and overall performance is better than before when Intel MKL processed one packet.  This behavior is set in the source file src / caffe / layers / base_conv_layer.cpp.  This is an implementation of optimized multi-threaded processing using OpenMP from the source code file src / caffe / layers / conv_layer.cpp. <br><br><h3>  <font color="#0071c5">Subsample layer</font> </h3><br>  Max-pooling, average-pooling, and stochastic-pooling (not yet implemented) are different downsampling methods, while max-pooling is the most popular method.  The subsample layer breaks the result obtained from the previous layer into a set of usually non-overlapping rectangular fragments.  For each such fragment, the layer then outputs the maximum (max-pooling), arithmetic mean (average-pooling), or (in the future) the stochastic value (stochastic-pooling) derived from the multinomial distribution formed from the activation functions of each fragment. <br><br>  The subsample layers are useful in convolutional networks for three main reasons: <br><br><ul><li>  The subsample reduces the dimension of the problem and the computational load on the overlying layers. </li><li>  The subsample for the underlying layers allows the convolution kernels in the layers above to cover large areas of input data, and thus learn more complex features.  For example, the core of a layer below is usually trained to recognize small elements of the image, while the core of a layer above can be trained to recognize more complex structures, such as images of forests or beaches. </li><li>  The max-pooling method increases the stability of the network to image shift.        2x2 (   )      ,       .   3x3         . </li></ul><br>      ,    Xbyak  ,     ,              .          ,      OpenMP. <br><br>     ,   OpenMP-.    ,   : <br><br><pre> <code class="hljs mel">#ifdef _OPENMP #pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> collapse(<span class="hljs-number"><span class="hljs-number">2</span></span>) #endif <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">image</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">image</span></span> &lt; num_batches; ++<span class="hljs-keyword"><span class="hljs-keyword">image</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; num_channels; ++channel)     generator_func(bottom_data, top_data, top_count, <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>,                       mask, channel, channel+<span class="hljs-number"><span class="hljs-number">1</span></span>, this, use_top_mask); }</code> </pre> <br>   <b>collapse(2),</b>  OpenMP <b>#pragma omp parallel</b>      <b>for</b> ,          ,        ,  . <br><br><h3> <font color="#0071c5">‚ñç Softmax   </font> </h3><br>   ‚Äì      .           ,   .            ,  ,   ,  ,   ,   .         softmax (  ‚Äì SoftmaxWithLoss). <br><br>       ,       , ,    ,      .  ,     (    ),      ‚Äì  <b>K</b>   ,    <b>j</b> -    <b>x</b>    : <br><br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/rqA8FIUZQVKoSlCaQIaD86DFg-cbX0IHs82UYcTjfl6miMh7HHhKLw8qKRNac9hRlPzarSrYLghekPxtgNeofrDILTbcHNGoh9fzKd4aaQ2YJqKzqp082G_z2bglefuAU0W1MkHON-2SzTw7hA"></div><br>             . ,      ,    .     ,      . <br><br> ,                      : <br><br><pre> <code class="hljs pgsql">    //  #ifdef _OPENMP #pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> #endif   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; channels; j++) {     caffe_div(inner_num_, top_data + j*inner_num_, scale_data,             top_data + j*inner_num_);   }</code> </pre> <br><h3> <font color="#0071c5">‚ñçReLU       </font> </h3><br> ReLU ‚Äì        ,     .   ‚Äì   ,     (blob   Caffe),   ,           . (   ‚Äì   ,     Caffe.        , Caffe       ). <br><br>     ReLU    <b>x</b>        <b>x</b> ,    ,       <b>negative_slope</b>   : <br><br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/QedrwyT1c7Y1B8wgjIhLxBPgygyC6_0KclPlmny8i8VxJg0YRpiAwQQXhbYv075ATRRyYg2WrDo0UHPYSp-8ShN7NXhj3K_coF1PzXaadc2bJqowacIK-BFj9UtXvlpZJFl9EqNh-1m2HSrjdQ"></div><br>     <b>negative_slope</b>  ,     ReLU,           : <b>max(x, 0)</b> . -     ,       : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Dtype&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ReLULayer&lt;Dtype&gt;::Forward_cpu(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dtype* bottom_data = bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;cpu_data(); Dtype* top_data = top[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;mutable_cpu_data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;count(); Dtype negative_slope=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;layer_param_.relu_param().negative_slope(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPENMP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> for (int i = 0; i &lt; count; ++i) {   top_data[i] = std::max(bottom_data[i], Dtype(0))       + negative_slope * std::min(bottom_data[i], Dtype(0)); } }</span></span></code> </pre> <br>           : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Dtype&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ReLULayer&lt;Dtype&gt;::Backward_cpu(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&amp; propagate_down,   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propagate_down[<span class="hljs-number"><span class="hljs-number">0</span></span>]) {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dtype* bottom_data = bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;cpu_data();   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dtype* top_diff = top[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;cpu_diff();   Dtype* bottom_diff = bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;mutable_cpu_diff();   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;count();   Dtype negative_slope=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;layer_param_.relu_param().negative_slope(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPENMP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta">   for (int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; count; ++i) {     bottom_diff[i] = top_diff[i] * ((bottom_data[i] &gt; 0)         + negative_slope * (bottom_data[i] &lt;= 0));   } } }</span></span></span></span></code> </pre> <br>         S(x) = 1 / (1 + exp(-x)): <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPENMP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> for (int i = 0; i &lt; count; ++i) {   top_data[i] = sigmoid(bottom_data[i]); }</span></span></code> </pre> <br>   MKL        ReLU-,  ,      ,      ReLU-   (  Xbyak). ,  ,         Intel Xeon.    -    .     C++       . <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>           ,  ,  ,    ,    OpenMP  Intel MKL.   ,  , ,          . <br><br><img src="https://lh4.googleusercontent.com/Jq8MLfGUvT05rKLtO0fCbeg9mZHz5L8xqz51cyAs4KxFC-Gz0whWJs0C2LFA-h1XdrGjhEqbO_FU93SYt769GUIOHl8SFGOuWGWL1HHhquxE8FeJ9z1BooOtHglHkkVTXEJEc1UBMxqEW_8A-A"><br> <i><font color="#999999">     Caffe,    Intel,   CIFAR-10  Intel VTune Amplifier XE 2017 beta</font></i> <br><br>   Caffe,    Intel,      .         37     BVLC Caffe,   3.6    .       10 . <br><br>     Elapsed Time,    ,       Spin Time,    ,    ,     .           (    ).  ,     ,  ,     OpenMP.     OpenMP        OpenMP,           .       ,  ,    ,      . <br><br>           ,   ,   Caffe   Intel. <br><br><img src="https://lh5.googleusercontent.com/c_876iZea2vHo-yxPbGVrKpxDQHBKjQxUt4iVBQsv7uMava9QGs7tDcFdWasBnnvCeGkSmv0atmwOgVghnjkOzo9kzxt4r0R4nEd-SDBVuuUJSAqG0I0u9Jtl0KA45DVsZZgDlfvjTDbZtPauw"><br> <i><font color="#999999">   Intel Modern Code</font></i> <br><br>      Intel VTune Amplifier XE 2017 beta    ,      ,         .      ,   ,           .         ,     .         ,   ,   <a href="https://gcc.gnu.org/projects/tree-ssa/vectorization.html"></a>     GCC.  JIT- Xbyak      SIMD-. <br><br>     ,         OpenMP, ,          .       Intel Modern Code   ,      ,   ,       . ,   ,    .  ,   ,     -,     .       <a href="http://arxiv.org/pdf/1602.06709v1.pdf"></a> .     Intel Xeon Phi  x200      MCDRAM         NUMA. <br><br>  Caffe   Intel      ,            .        Caffe,       Intel,        . <br><br>  , ,      ,         ,        ,        ,    . <br> Intel                OpenMP- Caffe,    Intel. <br>    Intel Modern Code   <a href="https://software.intel.com/en-us/articles/what-is-code-modernization"></a>  <a href="https://software.intel.com/ru-ru/modern-code"></a> . </div><p>Source: <a href="https://habr.com/ru/post/315582/">https://habr.com/ru/post/315582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315572/index.html">What programming language should you learn first? ( ádƒ±…π…îs…ê å…ê…æ: …Ø«ù ö…Ø to ≈Üƒ±q√≠qvi ö…êdu)</a></li>
<li><a href="../315574/index.html">How can you centrally manage all mobile devices in a company?</a></li>
<li><a href="../315576/index.html">Make a simple and convenient site relevance map - DONE</a></li>
<li><a href="../315578/index.html">Security in IoT: Comprehensive Security Strategy</a></li>
<li><a href="../315580/index.html">Scrum: Game Rules</a></li>
<li><a href="../315584/index.html">We invite you on December 3 to a master class on employment in the gaming industry</a></li>
<li><a href="../315586/index.html">To the issue of trends</a></li>
<li><a href="../315588/index.html">Acquaintance and start of development on iCE40 FPGAs from Lattice Semiconductor</a></li>
<li><a href="../315590/index.html">I invite you to a virtual reality party ‚ÄúNew Year's VR-Today‚Äù, December 10</a></li>
<li><a href="../315592/index.html">5 tips to improve game animations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>