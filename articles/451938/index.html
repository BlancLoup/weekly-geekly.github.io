<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitmap indices in Go: search for wild speed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="opening speech 
 I gave this talk in English at the conference GopherCon Russia 2019 in Moscow and in Russian at a meeting in Nizhny Novgorod. We are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitmap indices in Go: search for wild speed</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  opening speech </h2><br>  I gave this talk in English at the conference GopherCon Russia 2019 in Moscow and in Russian at a meeting in Nizhny Novgorod.  We are talking about a bitmap-index - less common than a B-tree, but no less interesting.  I share <a href="https://youtu.be/WvlUH6MjUuI%3Flist%3DPL3xVZC4USRNSO_kb2lh_J_no6C-KJ7Phg">the</a> speech at the conference in English and text interpretation in Russian. <br><br>  We will look at how a bitmap index works, when it is better, when it is worse than other indexes, and in which cases it is much faster than them;  see in which popular DBMS already have bitmap-indices;  try to write your own on Go.  And ‚Äúfor dessert‚Äù we will use ready-made libraries to create our own super-fast specialized database. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I really hope that my works will be useful and interesting for you.  Go! <br><a name="habracut"></a><br><h2>  Introduction </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="http://bit.ly/bitmapindexes">http://bit.ly/bitmapindexes</a> <br>  <a href="https://github.com/mkevac/gopherconrussia2019">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Hello to all!  It's six in the evening, we are all superb.  Wonderful time to talk about the boring theory of database indexes, right?  Do not worry, I will have a couple of lines of source code here and there.  :-) <br><br>  If without jokes, the report is full of information, but we do not have much time.  So let's get started. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Today I will talk about the following: <br><br><ul><li>  What are indexes; <br></li><li>  What is a bitmap-index; <br></li><li>  where it is used and where it is NOT used and why; <br></li><li>  simple implementation on Go and a bit of combat with the compiler; <br></li><li>  slightly less simple, but much more productive implementation on the Go-assembler; <br></li><li>  ‚ÄúProblems‚Äù of bitmap indexes; <br></li><li>  existing implementations. <br></li></ul><br><br><h2>  So what are indexes? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  The index is a separate data structure that we keep and update in addition to the core data.  It is used to speed up the search.  Without indexes, a search would require a full pass through the data (a process called full scan), and this process has a linear algorithmic complexity.  But databases usually contain a huge amount of data and linear complexity - this is too slow.  Ideally, we would get logarithmic or constant. <br><br>  This is a huge complex topic, full of subtleties and trade-offs, but, looking at decades of development and research of various databases, I am ready to assert that there are only a few widely used approaches to creating database indices. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  The first approach is to hierarchically reduce the search area, dividing the search area into smaller parts. <br><br>  We usually do this using different kinds of trees.  An example would be a large box with the materials in your closet, in which there are smaller boxes with materials divided by various topics.  If you need materials, then you will probably look for them in a box labeled "Materials", and not in the one that says "Cookies", right? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  The second approach is to immediately select the desired element or group of elements.  We do this in hash maps or in reverse indexes.  Using hash maps is very similar to the previous example, only instead of a box with boxes in your closet a bunch of small boxes with final items. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  The third approach is to get rid of the need to search.  We do this using Bloom filters or cuckoo filters.  The first give the answer instantly, saving you from having to search. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  The latter approach is to fully utilize all the power that modern iron gives us.  That is what we do in bitmap indexes.  Yes, when using them, we sometimes need to go through the whole index, but we do it super-efficiently. <br><br>  As I said, the topic of database indexes is extensive and full of compromises.  This means that sometimes we can use several approaches at the same time: if we need to further accelerate the search or if it is necessary to cover all possible types of search. <br><br>  Today I will talk about the least well-known approach of these - about bitmap-indices. <br><br><h2>  Who am I to talk about this topic? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  I work as a team leader in Badoo (perhaps you know our other product better - Bumble).  We already have more than 400 million users worldwide and many features that are committed to selecting the best pair for them.  We do this with the help of custom services that use bitmap indexes as well. <br><br><h2>  So what is a bitmap index? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Bitmap indices, as the name suggests, use bitmaps or bitsets to embed a search index.  From a bird's eye view, this index consists of one or more such bitmaps, representing any entities (such as people) and their properties or parameters (age, eye color, etc.), and from an algorithm using bit operations (AND, OR, NOT) to respond to a search query. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  We are told that bitmap-indexes are best suited and very productive for cases where there is a search that combines queries on many columns that have little cardinality (imagine ‚Äúeye color‚Äù or ‚Äúmarital status‚Äù against something like ‚Äúdistance from city center‚Äù ).  But later I will show that they work fine in the case of columns with high cardinality. <br><br>  Consider the simplest example of a bitmap index. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Imagine that we have a list of Moscow restaurants with binary properties like these: <br><br><ul><li>  near the metro (near metro); <br></li><li>  there is a private parking (has private parking); <br></li><li>  there is a veranda (has terrace); <br></li><li>  can book a table (accepts reservations); <br></li><li>  suitable for vegetarians (vegan friendly); <br></li><li>  expensive <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Let's give each restaurant a sequence number starting from 0 and allocate memory for 6 bitmaps (one for each characteristic).  Then we fill in these bitmaps, depending on whether the restaurant has this property or not.  If restaurant 4 has a veranda, then bit 4 in the bitmap ‚Äúthere is a veranda‚Äù will be set to 1 (if there is no veranda, then to 0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Now we have the simplest bitmap index possible, and we can use it to answer queries like: <br><br><ul><li>  "Show me restaurants suitable for vegetarians"; <br></li><li>  "Show me cheap restaurants with a veranda where you can book a table." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  How?  Let's get a look.  The first request is very simple.  All we need is to take a bitmap ‚Äúsuitable for vegetarians‚Äù and turn it into a list of restaurants whose bits are on display. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  The second query is a bit more complicated.  We need to use the NOT bit operation on the expensive bitmap in order to get a list of inexpensive restaurants, then for AND with it, you can book a table and for the result with a veranda bitmap.  The resulting bitmap will contain a list of establishments that meet all our criteria.  In this example, this is only the restaurant "Youth". <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  There is a lot of theory here, but don't worry, we will see the code very soon. <br><br><h2>  Where are bitmap indexes used? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  If you google the bitmap indexes, 90% of the answers will be somehow connected to the Oracle DB.  But the rest of the DBMS also supports such a cool thing too, right?  Not really. <br><br>  Let's go through the list of main suspects. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL does not yet support bitmap indexes, but there is a Proposal with the suggestion to add this option ( <a href="https://dev.mysql.com/worklog/task/%3Fid%3D1524">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL does not support bitmap indexes, but uses simple bitmaps and bit operations to combine search results for several other indexes. <br><br>  Tarantool has bitset indexes, it supports a simple search for them. <br><br>  Redis has simple bitfields <a href="https://redis.io/commands/bitfield">(https://redis.io/commands/bitfield</a> ) without the ability to search for them. <br><br>  MongoDB does not yet support bitmap indexes, but there is also Proposal with the suggestion to add this option <a href="https://jira.mongodb.org/browse/SERVER-1723">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch uses bitmaps inside <a href="https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  But in our house there was a new neighbor: Pilosa.  This is a new non-relational database written in Go.  It contains only bitmap indexes and bases everything on them.  We will talk about her later. <br></li></ul><br><br><h2>  Go implementation </h2><br>  But why are bitmap indexes so rarely used?  Before answering this question, I would like to show you the implementation of a very simple bitmap index on Go. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Bitmaps are essentially just pieces of data.  In Go, let's use byte slices for this. <br><br>  We have one bitmap per restaurant characteristic, and each bit in bitmap tells us whether a particular restaurant has this property or not. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  We need two auxiliary functions.  One will be used to fill our bitmaps with random data.  Randomized, but with a certain probability that the restaurant has every property.  For example, I believe that in Moscow there are very few restaurants where a table cannot be booked, and it seems to me that about 20% of the establishments are suitable for vegetarians. <br><br>  The second function will convert bitmap to a list of restaurants. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  To answer the query ‚ÄúShow me cheap restaurants that have a veranda and where you can book a table,‚Äù we will need two bit operations: NOT and AND. <br><br>  We can simplify our code a bit by using the more complex AND NOT operation. <br><br>  We have functions for each of these operations.  Both of them go in slices, take the corresponding elements from each, combine them with a bit operation and put the result in the resulting slice. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  And now we can use our bitmaps and functions to respond to a search query. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  The performance is not so high, even though the functions are very simple and we saved a lot by not returning a new result slice with each function call. <br><br>  After profiling a bit with pprof, I noticed that the Go compiler missed one very simple, but very important optimization: function inlining. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  The fact is that the Go compiler is terribly afraid of the cycles that go along slices, and it categorically refuses to inline the functions that contain such cycles. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  But I‚Äôm not afraid and I can fool the compiler by using goto instead of a loop, like in the good old days. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  And, as you can see, now the compiler is happy to inline our function!  As a result, we manage to save about 2 microseconds.  Not bad! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  The second bottleneck is easy to see if you look closely at the assembler output.  The compiler added a check on the slice boundaries right inside our hottest loop.  The fact is that Go is a safe language, the compiler fears that my three arguments (three slices) are of different sizes.  After all, then there will be a theoretical possibility of the emergence of the so-called buffer overflow (buffer overflow). <br><br>  Let's calm the compiler by showing him that all the slices have the same size.  We can do this by adding a simple check at the beginning of our function. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Seeing this, the compiler happily skips the check, and we end up saving another 500 nanoseconds. <br><br><h2>  Big batch </h2><br>  OK, we managed to squeeze out some performance from our simple implementation, but this result is, in fact, much worse than possible with the current hardware. <br><br>  All that we do is basic bit operations, and our processors perform them very efficiently.  But, unfortunately, we ‚Äúfeed‚Äù our processor with very small pieces of work.  Our functions are performed by-byte operations.  We can very easily tweak our code so that it works with 8-byte chunks using UInt64 slices. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  As you can see, this small change accelerated our program eight times by increasing the batch eight times.  The win can be said to be linear. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  Implementation in assembly language </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  But this is not the end.  Our processors can work with chunks of 16, 32 or even 64 bytes.  Such ‚Äúwide‚Äù operations are called single instruction multiple data (SIMD; one instruction, a lot of data), and the process of transforming the code so that it uses such operations is called vectorization. <br><br>  Unfortunately, the Go compiler is far from excellent in vectorization.  Currently, the only way to vectorize code on Go is to take and put these operations manually using Go assembler. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go - a strange beast.  You probably know that an assembler is something that is strongly tied to the architecture of the computer for which you are writing, but in Go it is not.  Go assembler is more like IRL (intermediate representation language) or intermediate language: it is practically platform independent.  Rob Pike gave an excellent <a href="https://www.youtube.com/watch%3Fv%3DKINIAgRpkDA">talk</a> on the subject a few years ago at GopherCon in Denver. <br><br>  In addition, Go uses the unusual Plan 9 format, which is different from the generally accepted formats of AT &amp; T and Intel. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  It's safe to say that writing the assembler Go manually is not the most fun. <br><br>  But, fortunately, there are already two high-level tools that help us in writing the Go assembler: PeachPy and avo.  Both utilities generate Go-assembler from higher-level code written in Python and Go, respectively. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  These utilities simplify things like register allocation (choosing a processor register), writing cycles, and generally simplify the process of entering the world of assembly programming in Go. <br><br>  We will use avo, so our programs will be almost ordinary Go programs. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  Here is the simplest example of the avo program.  We have a main () function, which defines the Add () function inside itself, the meaning of which is the addition of two numbers.  There are auxiliary functions for getting parameters by name and getting one of the free and suitable processor registers.  Each processor operation has a corresponding function on avo, as seen by ADDQ.  Finally, we see an auxiliary function for storing the resulting value. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  By calling go generate, we will execute the program on avo and as a result two files will be generated: <br><br><ul><li>  add.s with the result code in Go-assembler; <br></li><li>  stub.go with headings of functions for communication of two worlds: Go and assembler. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Now that we have seen how and what makes avo, let's look at our functions.  I implemented both scalar and vector (SIMD) versions of functions. <br><br>  First, look at the scalar versions. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  As in the previous example, we ask you to provide us with a free and correct general-purpose register; we do not need to calculate the offsets and sizes for the arguments.  All this avo does for us. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Earlier we used labels and goto (or jumps) to improve performance and to trick the Go compiler, but now we do it from the very beginning.  The fact is that cycles are a higher level concept.  In assembly language, we only have labels and jumps. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  The remaining code should be familiar and understandable.  We emulate a cycle with labels and jumps, take a small part of the data from our two slices, combine them with a bit operation (AND NOT in this case) and then put the result into the resulting slice.  Everything. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  This is what the final assembly code looks like.  We did not need to calculate the displacements and sizes (highlighted in green) or monitor the registers used (highlighted in red). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  If we compare the performance of the implementation on the assembler with the performance of the best implementation on Go, then we will see that it is the same.  And this is expected.  After all, we did not do anything special - we just reproduced what the Go compiler would do. <br><br>  Unfortunately, we cannot force the compiler to inline our functions written in assembler.  The Go compiler doesn‚Äôt have such an opportunity today, although the request to add it has been around for quite a long time. <br><br>  That is why it is impossible to get any benefits from small functions in assembler.  We need to either write large functions, or use the new math / bits package, or bypass the assembler side. <br><br>  Let's now look at the vector versions of our functions. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  For this example, I decided to use AVX2, so we will use operations that work with 32-byte chunks.  The structure of the code is very similar to the scalar version: loading parameters, please provide us with a free general register, etc. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  One of the innovations is due to the fact that wider vector operations use special wide registers.  In the case of 32-byte chunks, these are registers with the Y prefix. That is why you see the YMM () function in the code.  If I used the AVX-512 with 64-bit chunks, the prefix would be Z. <br><br>  The second innovation is related to the fact that I decided to use an optimization called loop unrolling, that is, to do eight loop operations manually before jumping to the beginning of the loop.  This optimization reduces the number of brunches (branches) in the code, and it is limited by the number of free registers available. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Well, what about performance?  She is beautiful!  We got about seven times faster than the best Go solution.  Impressive, yes? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  But even this implementation could potentially be accelerated using AVX-512, prefetching or JIT (just-in-time compiler) for the query planner.  But this is certainly a topic for a separate report. <br><br><h2>  Bitmap Index Problems </h2><br>  Now, when we have already considered a simple implementation of a bitmap index on Go and much more productive on an assembler, let's finally talk about why bitmap indexes are so rarely used. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br>  Older scientific papers mention three problems of bitmap-indices, but newer scientific papers and I state that they are already irrelevant.  We will not dive deep into each of these problems, but we shall examine them superficially. <br><br><h2>  The problem of great cardinality </h2><br>  So, we are told that bitmap-indices are suitable only for fields with low cardinality, that is, those that have few values ‚Äã‚Äã(for example, gender or eye color), and the reason is that the usual representation of such fields (one bit per value) in the case of large cardinality will take up too much space and, moreover, these bitmap-indices will be weakly (rarely) filled. <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br>  Sometimes we can use another representation, such as the standard one, which we use to represent numbers.  But it was the appearance of compression algorithms that changed everything.  Over the past decades, scientists and researchers have come up with a large number of compression algorithms for bitmaps.  Their main advantage is that there is no need to compress bitmaps for performing bit operations - we can perform bit operations directly on compressed bitmaps. <br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br>  Recently, hybrid approaches have begun to appear, such as, for example, roaring bitmaps.  They use three different representations for bitmaps at the same time ‚Äî the bitmaps themselves, arrays and so-called bit runs ‚Äî and balance between them to maximize performance and minimize memory consumption. <br><br>  You can find roaring bitmaps in the most popular applications.  There are already a huge number of implementations for various programming languages, including more than three implementations for Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>  Another approach that can help us cope with great cardinality is binning.  Imagine that you have a field that represents the height of a person.  Growth is a floating point number, but we humans do not think about it in that way.  For us there is no difference between the growth of 185.2 cm and 185.3 cm. <br><br>  It turns out that we can group similar values ‚Äã‚Äãinto groups within 1 cm. <br><br>  And if we also know that very few people have a height of less than 50 cm and more than 250 cm, then we can, in fact, turn a field with infinite cardinality into a field with cardinality of about 200 values. <br><br>  Of course, if necessary, we can do additional filtering after. <br><br><h2>  High bandwidth problem </h2><br>  The next problem with bitmap indexes is that updating them can be very expensive. <br><br>  Databases should allow data to be updated at the moment when hundreds of other queries potentially search for this data.  We need locks to avoid simultaneous data access problems or other sharing problems.  And where there is one big lock, there is a problem - lock contention, when this lock becomes a bottleneck. <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>  This problem can be solved or circumvented using sharding or using versioned indexes. <br><br>  Sharding is a simple and well-known thing.  You can shard the bitmap index as you would shard any other data.  Instead of one big lock, you will get a bunch of small locks and thus get rid of lock contention. <br><br>  The second way to solve the problem is to use versioned indexes.  You can have one copy of the index that you use to search or read, and one to write or update.  And once in a certain period of time (for example, once in 100 ms or 500 ms), you duplicate them and swap them.  Of course, this approach is applicable only in cases where your application can work with a slightly lagging search index. <br><br>  These two approaches can be used at the same time: you can have a shard versioned index. <br><br><h2>  More complex queries </h2><br><br>  The last problem with bitmap-indexes is that, as we are told, they are poorly suited for more complex types of queries, for example queries "by interval". <br><br>  And the truth is, if you think bitwise operations like AND, OR, etc., are not very suitable for requests a la "Show me hotels with room rates from $ 200 to $ 300 per night." <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>  A naive and very unwise decision would be to take the results for each dollar value and combine them with the OR bit operation. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>  A slightly better solution would be to use grouping.  For example, in groups of $ 50.  This would speed up our process 50 times. <br><br>  But the problem is also easily solved using a view created specifically for this type of query.  In scientific papers, it is called range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>  In this view, we do not just set one bit for any value (for example, 200), but set this value and everything above.  200 and higher.  The same for 300: 300 and above.  And so on. <br><br>  Using this view, we can respond to this kind of search query, passing on the index only two times.  First we get a list of hotels where the room costs less or $ 300, and then we throw out of it those where the cost of the room is less or $ 199.  Is done. <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           ¬´ ¬ª (   ). <br><br><h2>  Turnkey solutions </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , ‚Äî  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br>     NOT   ¬´expensive¬ª,    ( AND-)   ¬´terrace¬ª    ¬´reservations¬ª.  ,   . <br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br>   ,        MySQL  PostgreSQL       ‚Äî bitmap-. <br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Conclusion </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>     , .       -   ,   ,     , ,  . <br><br>  bitmap-  ,        .         . <br><br>          Go   ,    Go     .           Go. <br><br>  ,    .  Thank! </div><p>Source: <a href="https://habr.com/ru/post/451938/">https://habr.com/ru/post/451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451926/index.html">About live-code after 130 streams</a></li>
<li><a href="../451930/index.html">Automation of staircase lighting</a></li>
<li><a href="../451932/index.html">PHDays 9: Welcome to the secure development section</a></li>
<li><a href="../451934/index.html">Alexander Lamden: ‚ÄúAny piece of iron has a character‚Äù</a></li>
<li><a href="../451936/index.html">We are looking for vulnerabilities in UC Browser</a></li>
<li><a href="../45194/index.html">Cyberflash TV Workshop Results</a></li>
<li><a href="../451942/index.html">How delivery by drones in Africa saves thousands of lives</a></li>
<li><a href="../451944/index.html">2019: Year of DEX (Decentralized Exchanges)</a></li>
<li><a href="../451948/index.html">The story of the three cartridges</a></li>
<li><a href="../45195/index.html">Parallels Desktop 4.0 for Mac and VMware Fusion 2.0 Comparison</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>