<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bootloader with AES-128 and EAX on AVR Assembler in 1024 bytes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Or how I stopped being afraid and fell in love with the assembler 

 One summer, I got a microcontroller programmer at my university. In the process o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bootloader with AES-128 and EAX on AVR Assembler in 1024 bytes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/901/b60/df9/901b60df921d25dd2a1fc72d894dbd09.png"><br>  <i>Or how I stopped being afraid and fell in love with the assembler</i> <br><br>  One summer, I got a microcontroller programmer at my university.  In the process of communicating with our chief engineer (hello, Alexey!), I learned that chips are cutting, projects are being stolen, customers throw and the appearance of a Chinese clone of our programmers for automotive electronics is only a matter of time, they can only be crushed by high quality.  With all this, it is impossible to fall into paranoia, users are unlikely to want to work with our glands in collars with explosives. <br><br>  A good security measure is software updates.  Chinese clones automatically die after each new firmware, and loyal users get our love, care and new features.  Robin Hoods in this situation, of course, will get their logical analyzers, HEX editors, and begin to pick the firmware process in order to satisfy the Russian-Chinese community. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Although we did not have projects that require such protection measures, it was clear: this should be done, sometime it will come in handy.  Googled - not found, invented - done.  In this article, I will tell you how to fit full 1-Kbyte encryption and why assembler is great.  A lot of text, code and a little surprise for lovers of old iron. <br><a name="habracut"></a><br><h4>  Platform and language </h4><br>  We did all the projects on ATmega simply because in the CIS they are easier and cheaper to buy.  As I understood from conversations with seniors, this is a very buggy family and you need to perform a lot of strange actions in order for it to work smoothly.  We wrote in assembly language because tasks are extremely sensitive to the speed of work.  It was impossible to rely on the compiler, and many parts of the code were calculated in cycles.  Moreover, only the assembler can do the impossible. <br><br>  Frankly, at first I was afraid to learn assembler, thinking that it causes irreversible brain damage and programmer disability.  And it‚Äôs not just that people invented the C - assembler, it must be a very complicated thing.  As it turned out, assembler is the easiest language in the world.  There is nothing simpler than assembler.  Blinking LEDs, enter interrupts and use the stack, I learned in one day and got to work.  After a couple of months, there was enough experience to write the project, which will be discussed in this article. <br><br>  There are no complicated abstractions in the assembler, which provides this blunt-headed simplicity.  Specifically, in the AVR version there are not even cycles.  To organize a cycle, you need to take a register, put into it the number of iterations, reduce the register by one at the end of the body and, if there is not 0 yet, jump (by some of the goto brothers) to the beginning of the body.  You get used to such strange structures very quickly and stop being afraid. <br><br><h4>  What is a bootloader </h4><br>  A bootloader is a program that starts immediately after the microcontroller revives.  What the bootloader does is decide the programmer.  As a rule, bootloaders are responsible for some very system functions, such as updating software, loading the OS, or setting up the environment for the following programs.  Our bootloader will perform a single function - to update the firmware of the microcontroller. <br><br>  In the AVR architecture, a bootloader can be invoked in two ways - by setting a reset vector on it or by setting the BOOTRST fusion, which will force the microcontroller to start working not from the 0 address, but from the start address of the bootloader, the size of which is specified, again, in the fusions. <br><br>  What problems may arise at this stage?  Fuses can be edited.  A highly intelligent "user" can, for example, reprogram BOOTRST and work will begin with a reset vector, not our boot.  He can change the size of the bootloader, the microcontroller will start to perform some kind of heresy from the middle of the boot, and this may compromise the system. <br><br>  So, we have to redirect the reset vector itself to our bootloader, and in its body place unconditional jumps to the beginning, in those places that correspond to different sizes of the rubble area.  No problem. <br><br>  The bootloader will determine whether it will execute a user program, or switch to firmware mode, based on the presence or absence of a level on a specific output. <br><br><h4>  Cryptography </h4><br>  Before starting work, I completed Part 1 of <a href="https://class.coursera.org/crypto-007">the cryptography course from Dan Bon</a> on the Coursera.  Professor Dan always talked about the fact that in no case can you write cryptographic systems yourself, this should be done by professionals, and not first-year students in their holidays.  Of course.  In justification, I can say that this bootloader is not positioned as an invulnerable to all attacks.  Its existence is not a major, but an additional measure of intellectual property protection.  In short, a person must dig into the update file, use the oscilloscope to stumble, suffer a week, think "well, to hell with it, pay $ 2000 to the Chinese, they will cut it" and do just that.  The cost of software hacking should exceed the cost of physical hacking, no more. <br><br>  The microcontroller is an open system, all engineers know how to work with it.  Microcontrollers can jump commands at overclocking, can ‚Äúforget‚Äù about protection at a certain undervoltage, can have very stupid holes, such as the ability to write and execute code in Flash from RAM, when reading is impossible (for example, ST92F).  If you can literally change a couple of bytes of firmware, it will be completely merged.  In the firmware, as a rule, there are areas with the expected structure - for example, unused interrupt vectors, which makes it easier to change a couple of bytes using the poke method.  So, a simple block cipher in CBC / CTR mode is indispensable. <br><br>  If you can not allow the possibility of changing the firmware - you have to use the message authentication code.  Examples of such codes are CCM, GCM, EAX.  Honestly, I already remember poorly why I chose EAX.  Most likely, its future implementation in assembler seemed to me the most simple. <br><br>  Each firmware will have its own, randomly generated key, connected as a separate file.  The same file encrypts updates.  Protection lies in the fact that we simply will not release new firmware for compromised keys.  It is necessary to know each user by sight, but security requires sacrifice.  Also, during key generation, some constants will be calculated, so that the microcontroller does not have to do it on its own. <br><br><h4>  EAX </h4><br>  How much documentation does an engineer need to write encryption?  Two pictures taken from <a href="http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf">scientific work</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48c/70b/3ac/48c70b3ac4b30c809cb7439fded51f48.png"><br><br>  Auxiliary Algorithms <br>  We guarantee the multiplicity of the data to the size of the block at the stage of encrypting the firmware, which reduces the pad function to M ^ B (31) and the variable P (32) will never be used. <br>  At the stage of key generation, we can calculate the constant L (40) and, as a result, B. <br>  ‚ÄúExclusive or with an arrow‚Äù (31) means that B will be at-xor-en only at the end of line M. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3a/5ac/58e/e3a5ac58e83011cbc55656905506b8de.png"><br><br>  Encryption process <br>  Where M is unencrypted text, CT is ciphertext, K is a key, N is the initialization vector, H is the header. <br>  The assembler will need to write only the decryption function. <br><br>  Let the message header H be set, unchanged and known only to us.  This does not affect cryptographic strength, since it is assumed that the title is public information.  Now you can calculate H '(23) at the stage of key generation. <br>  If you look at lines 22, 24, together with 50 and 10, you can realize that the tsiferka in superscript with OMAC will go into the last character of the string with a length equal to the length of the block and will be used as the first block in CBC, ie, encrypted.  Encryption of these lines can be carried out at the key generation stage.  Moreover, only encrypted strings with the numbers 0 (L0) and 2 (L2) will be included in the key file to calculate N 'and C', respectively. <br>  Having L0, B and N in hand, the calculation of N 'is reduced to E (L0 ^ B ^ N). <br><br>  So, at the key generation stage, B, L0, L2, H 'will be calculated. <br>  Together they will take 64 bytes. <br><br><h4>  AES-128 </h4><br>  AES - brilliant in its simplicity algorithm.  In addition, it has great flexibility, depending on whether we need capacity or volume.  In our case, the volume and simplicity occupied is crucial.  There are a lot of good articles written about AES, I will not go into details of its device. <br><br>  The special feature of AES is that decryption is algorithmically more complicated than encryption itself.  In the process of decoding, you need to multiply by 14 in the final field.  Since we do not have wired multiplication tables in this horror, we will use AES outside the box - to encrypt the update on a powerful computer, we will ‚Äúdecrypt‚Äù it, and when decrypting it on a weak microcontroller - ‚Äúencrypt‚Äù.  There is no difference in cryptographic strength. <br><br>  I have not come up with any effective (and safe) way to expand keys.  Preparation of all 11 copies is performed at the key generation stage.  In principle, for this reason, you can make the entire key block completely random - it will slightly increase the protection against brute force, if some pervert beaver chooses to do it. <br>  The extended key will be 176 bytes.  Together with the calculated constants, it forms a key file that takes forever 240 bytes of Flash.  There are 784 left, that is, 392 assembler commands. <br><br>  A vital and huge part of AES is the lookup table - the bytes to which the text bytes are replaced.  The byte already has 256 possible combinations and the table will take as much flash memory.  Unacceptable!  So we will calculate it. <br><br>  The substitution table is calculated as follows: first, the number that is the inverse of the element number of the table is found, then this inverse is subjected to the following affine transformation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95b/9a3/cc5/95b9a3cc51e43e8bc83d738d37a316ce.png"><br><br>  x0 ... x7 is the inverse number in the form of a vector.  It needs to be written in an assembler and stored in less than 256 bytes so that there is a benefit.  We are set to 88 bytes.  Let's get started <br><br><h4>  Hello, world! </h4><br>  The assembler programmer always starts the program by simplifying his own life.  It consists in renaming registers so that, for example, instead of r16 you can write temp_0.  I, by tradition, call the 0 and 1 registers OP0 and OP1, 2 and 3 - NULL and OxFF (filling them with the appropriate values), and the rest - as necessary. <br><br><div class="spoiler">  <b class="spoiler_title">Registers</b> <div class="spoiler_text"><pre><code class="hljs scala">.<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-type"><span class="hljs-type">OP0</span></span> = r0 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-type"><span class="hljs-type">OP1</span></span> = r1 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span> = r2 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-type"><span class="hljs-type">OxFF</span></span> = r3 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b0 = r4 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b1 = r5 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b2 = r6 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b3 = r7 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b4 = r8 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b5 = r9 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b6 = r10 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b7 = r11 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b8 = r12 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> b9 = r13 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bA = r14 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bB = r15 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bC = r16 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bD = r17 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bE = r18 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> bF = r19 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_0 = r20 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_1 = r21 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_2 = r22 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_3 = r23 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_4 = r24 .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> temp_5 = r25</code> </pre> </div></div><br>  In our case, we had to use almost all registers, from the 4th to the 19th, to store the decrypted data block.  I took it to the registers because working with them is much easier and faster.  Any activity with RAM in microcontrollers still leads to work with registers, why pay more. <br><br>  Registers 20 to 25 are used for temporary storage of calculated data and are named accordingly. <br>  From 26 to 32 are special 16-bit registers - X, Y, Z, used to address the memory.  Moreover, only Z can be used to address Flash.  As I heard, they physically have technical devices for increment, decrement and offset calculation, therefore, using them for other purposes, although it may be considered a bad practice, and can lead to unacceptable glitches in critical applications. <br><br>  In addition to renaming registers, we calculate some useful constants - the number of bytes in a flash memory page, the size of the entire bootloader, the size of the cipher block, the number of memory pages, the number of data blocks per page, and the address to which the key file should be located: <br><br><div class="spoiler">  <b class="spoiler_title">Constants</b> <div class="spoiler_text"><pre> <code class="hljs dos">.<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> PAGE_BYTES = PAGESIZE*<span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> BOOT_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> BLOCK_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> PAGES = (FLASHEND+<span class="hljs-number"><span class="hljs-number">1</span></span>)/PAGESIZE - BOOT_SIZE/PAGE_BYTES .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> BLOCKS_PER_PAGE = PAGE_BYTES / BLOCK_SIZE .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> KEY_ADDR = (FLASHEND + <span class="hljs-number"><span class="hljs-number">1</span></span>) ‚Äî (BLOCK_SIZE*(<span class="hljs-number"><span class="hljs-number">11</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>))/<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre></div></div><br>  Add to the future miracle of flexibility - let us choose the connection speed by UART, port, output and the level at which we will decide whether to stay in the bootloader or continue the download.  In addition to these utilitarian settings, you can set the address of the label to which the jump will be made, if the firmware is not required, and also decide whether the bootloader should remake the zero page of memory ‚Äî the interrupt vector is located there and the attacker can overwrite the system. <br><br><div class="spoiler">  <b class="spoiler_title">Settings</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">;<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> address (<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> asked <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> boot) .equ RESET_VECT = <span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">Is</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>th flash page used? .equ USE_0th_PAGE = <span class="hljs-number"><span class="hljs-number">1</span></span> ;////////////////////////PORT SETUP #define check_port \ port_settings \ <span class="hljs-comment"><span class="hljs-comment">/* use port letter... */</span></span>\ <span class="hljs-comment"><span class="hljs-comment">/* A / B / C / D / E */</span></span>\ C, \ <span class="hljs-comment"><span class="hljs-comment">/* check status of pin number...*/</span></span>\ <span class="hljs-number"><span class="hljs-number">5</span></span>, \ <span class="hljs-comment"><span class="hljs-comment">/* load boot only if port is... */</span></span>\ <span class="hljs-comment"><span class="hljs-comment">/* (S)ET (1) / (C)LEAR (0) */</span></span>\ S ;////////////////////////BAUD RATE SETUP .equ Fosc = <span class="hljs-number"><span class="hljs-number">16000000</span></span> ;clock frequency .equ baud = <span class="hljs-number"><span class="hljs-number">19200</span></span> ;baud rate .equ UBRR = Fosc / ( BLOCK_SIZE * baud ) - <span class="hljs-number"><span class="hljs-number">1</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> high( UBRR ) != <span class="hljs-number"><span class="hljs-number">0</span></span> .error "Unsupported baud rate setting - high byte of UBRR is not 0!" .endif</code> </pre></div></div><br>  Now, let's deal with the RAM.  AES requires 256 bytes for the replacement table.  The data block consists of an initialization vector (16 bytes), the data itself (page size), an integrity check mark (16 bytes).  To decrypt data, we need to generate a decryption sequence based on an initialization vector ‚Äî another page size. <br><br><div class="spoiler">  <b class="spoiler_title">Staking a place in memory</b> <div class="spoiler_text"><pre> <code class="hljs cs">.dseg .org <span class="hljs-number"><span class="hljs-number">0x60</span></span> SBOX: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">256</span></span> ;rijndael substitution box ;these three SHOULD be consecutive SAVED_IV: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> BLOCK_SIZE ;E(L0^N^B) RCVD_PAGE: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> PAGE_BYTES ;page to be written TAG: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> BLOCK_SIZE ;initially - precomputed header <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ENC_IV: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> PAGE_BYTES ;IV<span class="hljs-string"><span class="hljs-string">'s to xor with page to decrypt .cseg</span></span></code> </pre></div></div><br>  On the ATmega16, with a page size of 64 bytes, the amount of RAM used is 544 bytes from 1024. On the ATmega8 it is 416. A bit too much.  There are microcontrollers with large pages of flash-memory with a small amount of operational.  Perhaps you can come up with something, but few people will need compatibility with the whole family. <br><br>  With the preprocessor directives met, go to the assembler.  The program traditionally begins with initializing the stack pointer, turning off interrupts, setting the NULL and OxFF registers, setting the UART settings. <br><br><div class="spoiler">  <b class="spoiler_title">Initialization</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">BOOT_START: ldi temp_0, low( RAMEND) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> SPL, temp_0 ldi temp_0, high(RAMEND) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> SPH, temp_0 cli clr <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> mov OxFF, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> com OxFF ldi temp_0, low( UBRR ) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> UBRRH, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> UBRRL, temp_0 ldi temp_0, ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; RXEN ) | ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; TXEN ) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> UCSRB, temp_0 ldi temp_0, ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; URSEL ) | ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; UCSZ1 ) | ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; UCSZ0 ) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> UCSRC, temp_0</code> </pre></div></div><br>  All this was enough for us as many as 6 different assembler commands, which are abbreviations or abbreviations.  ldi - load into, mov - move, out - output to I \ O register, com - complement, cli - clear interrupt flag.  As I said, the assembler is very simple.  "Difficult" parts, with all kinds of incomprehensible UBRRH (UART Baud Rate Register High-byte), are described in detail in datasheets and are equipment settings. <br><br>  We decide to stay in the buta or not.  The selection of the port register, according to the user's settings, is performed at the assembly stage: <br><br><div class="spoiler">  <b class="spoiler_title">This is done by an elegant macro.</b> <div class="spoiler_text"><pre> <code class="hljs mel">.macro port_settings <span class="hljs-comment"><span class="hljs-comment">/*PORT LETTER, PIN NUMBER, LOGIC LEVEL*/</span></span> cbi DDR@0 , @1 sbi PORT@0, @1 nop sbi@2 PINB, @1 .endmacro</code> </pre></div></div><br>  A little original will be the procedure for reading / writing to the serial port.  Since we have little space and small speeds, I decided to combine confirmation of readiness for work with data acquisition and split the procedure into several, having different capabilities.  In assembly language, it is very easy to do by calling a subroutine with different labels: <br><br><div class="spoiler">  <b class="spoiler_title">Readiness and receiving for 8 teams</b> <div class="spoiler_text"><pre> <code class="hljs haskell">;<span class="hljs-type"><span class="hljs-type">UART</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">0xC0</span></span> ;temp_0 &lt;- <span class="hljs-type"><span class="hljs-type">UART</span></span> confirm_and_read: ldi temp_0, <span class="hljs-number"><span class="hljs-number">0xC0</span></span> ;<span class="hljs-type"><span class="hljs-type">UART</span></span> &lt;- temp_0 ;temp_0 &lt;- <span class="hljs-type"><span class="hljs-type">UART</span></span> <span class="hljs-type"><span class="hljs-type">UART_send</span></span>: sbis <span class="hljs-type"><span class="hljs-type">UCSRA</span></span>, <span class="hljs-type"><span class="hljs-type">UDRE</span></span> ;skip next command <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> readiness bit is set rjmp <span class="hljs-type"><span class="hljs-type">UART_send</span></span> out <span class="hljs-type"><span class="hljs-type">UDR</span></span>, temp_0 ;temp_0 &lt;- <span class="hljs-type"><span class="hljs-type">UART</span></span> <span class="hljs-type"><span class="hljs-type">UART_read</span></span>: sbis <span class="hljs-type"><span class="hljs-type">UCSRA</span></span>, <span class="hljs-type"><span class="hljs-type">RXC</span></span> rjmp <span class="hljs-type"><span class="hljs-type">UART_read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_0, <span class="hljs-type"><span class="hljs-type">UDR</span></span> ret</code> </pre></div></div><br>  The sad part is complete, the world is built for future work.  Let's start working. <br><br><h4>  88 byte lookup table </h4><br>  First, you need to find the number inverse to this in the final field.  Such that when multiplying this number by this one, we get 1. The multiplication algorithm is described in the article on the <a href="http://en.wikipedia.org/wiki/Finite_field_arithmetic">wiki</a> , I will not give it. <br><br>  Finding the opposite in a finite field is a difficult task.  Here we need to apply the advanced Euclidean algorithm ... but we are engineers.  Remove computer science graduates from the screens.  We are looking for the inverse element by brute force, using multiplication. <br><br><div class="spoiler">  <b class="spoiler_title">Search for an inverse element</b> <div class="spoiler_text"><pre> <code class="hljs vhdl"> ldi XH, high(SBOX) ;point X <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> SBOX memory location ldi XL, low( SBOX) ser bF ;first inc will overflow <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> next_box: inc bF mov temp_1, bF ;save input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_1 cp temp_1, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> breq sbox_byte_done ;<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> here mov OP0, OxFF ;so it overflows look_more: inc OP0 ;try <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> candidate ;temp_0 &lt;- OP0 * temp_1 (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a Galois field) ;branching <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> fine, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> precomputation only finite_multiplication: mov b0, OP0 ;operand <span class="hljs-number"><span class="hljs-number">0</span></span> (candidate) mov b1, temp_1 ;operand <span class="hljs-number"><span class="hljs-number">1</span></span> (current byte) ldi temp_2, <span class="hljs-number"><span class="hljs-number">0</span></span>x1B ;<span class="hljs-number"><span class="hljs-number">0</span></span>x1B holder clr temp_0 ;multiplication result next_bit: lsr b0 ;operand <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> brcc PC+<span class="hljs-number"><span class="hljs-number">2</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lsb <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operand <span class="hljs-number"><span class="hljs-number">0</span></span> was <span class="hljs-number"><span class="hljs-number">1</span></span> eor temp_0, b1 ;<span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> operand <span class="hljs-number"><span class="hljs-number">1</span></span> into result lsl b1 ;operand <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> brcc PC+<span class="hljs-number"><span class="hljs-number">2</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msb <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operand <span class="hljs-number"><span class="hljs-number">1</span></span> was <span class="hljs-number"><span class="hljs-number">1</span></span> eor b1, temp_2 ;<span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x1B into operand <span class="hljs-number"><span class="hljs-number">1</span></span> cp b0, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> there are bits <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> operand0 brne next_bit ;work <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> it cpi temp_0, <span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> multiplication result was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> brne look_more ;inverse <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> OP0</code> </pre></div></div><br>  After that, we carry out affine transformation and save the result in memory.  It is assembled from the simplest cubes.  Programming in assembler is a great exercise for the brain.  You can always find a more elegant solution, save a couple more teams, squeeze a couple more bars, and this saving on matches is sometimes a matter of life and death.  This is a parallel magic world of programming, in which the coding process is turned into a constructor assembly. <br><br><div class="spoiler">  <b class="spoiler_title">Affine transformation in assembler</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> clr temp_1 ;affine <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> result ldi temp_5, <span class="hljs-number"><span class="hljs-number">0</span></span>b11110001 ;matrix producer ldi temp_3, <span class="hljs-number"><span class="hljs-number">0</span></span>b00000001 ;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> mask process_bit: mov temp_4, OP0 ;multiplicative inverse <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> temp_4, temp_5 ;<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> matrix producer pop_next_bit: lsl temp_4 ;inv&amp;matrix &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> brcc PC+<span class="hljs-number"><span class="hljs-number">2</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it had msb eor temp_1, temp_3 ;sum <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> result cp temp_4, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> operand has bits brne pop_next_bit ;<span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> it lsl temp_3 ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> next <span class="hljs-type"><span class="hljs-type">bit</span></span> lsl temp_5 ;cyclically shift matrix producer brcc PC+<span class="hljs-number"><span class="hljs-number">2</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it had msb ori temp_5, <span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> msb <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> lsb cp temp_3, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> there are bits left brne process_bit ;process next <span class="hljs-type"><span class="hljs-type">bit</span></span> sbox_byte_done: ldi temp_2, <span class="hljs-number"><span class="hljs-number">0</span></span>b01100011 ;<span class="hljs-number"><span class="hljs-number">0x63</span></span> eor temp_1, temp_2 ;xor it <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> result st X+, temp_1 ;save <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> memory cpse bF, OxFF ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w<span class="hljs-string"><span class="hljs-string">e're at last byte rjmp next_box ;we'</span></span>re done</code> </pre></div></div><br>  Mission Complete. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf4/d9e/1ca/cf4d9e1cad324e845698d89dd3815fe5.png"><br><br>  How fast does it all work?  In the simulator - 2203268 tact.  0.27 seconds at a frequency of 8 MHz.  I think this is a great speed. <br><br>  We lost 256 bytes of RAM and 0.27 seconds at the start, saving 168 bytes of flash memory and solving a wonderful puzzle. <br><br>  The substitution table is ready, the keys are expanded on the computer - there is everything you need to implement AES. <br><br><h4>  Assembled Encryption Standard </h4><br>  Let's start with elementary operations.  At each stage of decryption, the key is summed with the data.  The data is in the register file, from the 4th, there are 16 of them, and let the Z register always indicate the current key. Pointer registers can point not only to the SRAM or Flash area, but also to the register file, which greatly simplifies us life and speeds up the system. <br><br><div class="spoiler">  <b class="spoiler_title">Add round key</b> <div class="spoiler_text"><pre> <code class="hljs sql">add_round_key: clr YH ;point to register file ldi YL, 4 xor_Z_to_Y: lpm temp_0, Z+ ;<span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ld temp_1, Y ;<span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> eor temp_1, temp_0 ;xor them st Y+, temp_1 ;store back to data cpi YL, low( 4 + 16 ) ;<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it was the <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> brne xor_Z_to_Y ;if not - process next data byte ret</code> </pre></div></div><br>  Another simple operation is to shuffle the rows.  Each row of data is cyclically shifted to the left by its sequence number.  You just need to think about which byte with which one to swap and, finally, apply these useful skills of exchanging two variables in places without using an additional variable.  Plus solutions - you can mix all these operations together for additional protection against attacks from third-party channels. <br><br><div class="spoiler">  <b class="spoiler_title">Shift rows</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">;cyclical shift: <span class="hljs-number"><span class="hljs-number">0</span></span>_row &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>_row &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>_row &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>_row &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span> shift_rows: ;<span class="hljs-number"><span class="hljs-number">1</span></span>st <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> eor b1, bD eor bD, b1 eor b1, bD eor b1, b5 eor b5, b1 eor b1, b5 eor b5, b9 eor b9, b5 eor b5, b9 ;<span class="hljs-number"><span class="hljs-number">2</span></span>nd <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> eor b2, bA eor bA, b2 eor b2, bA eor b6, bE eor bE, b6 eor b6, bE ;<span class="hljs-number"><span class="hljs-number">3</span></span>rd <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> eor b3, bF eor bF, b3 eor b3, bF eor b7, bF eor bF, b7 eor b7, bF eor bB, bF eor bF, bB eor bB, bF ;done ret</code> </pre></div></div><br>  Replacing all the data with the corresponding substitutions from the table would seem like a trivial task.  A simple approach, on the forehead, has a fatal flaw: it is too linear.  Linearity, immutability and clarity - potential vulnerabilities to attack by third-party channels.  Roughly speaking, we have nothing to change in the implementation from time to time, without the immutability of the result, for an additional level of protection.  We proceed otherwise.  We will process one column at a time.  We change the traversal order - and the attacker will suffer another week. <br><br>  The substitution always follows the offset of the rows, therefore, we will not separate these procedures. <br><br><div class="spoiler">  <b class="spoiler_title">Sub bytes</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">substitute_shift_rows: ldi XH, high(SBOX) ldi XL, low( SBOX) movw OP0, X ;one <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> at a <span class="hljs-type"><span class="hljs-type">time</span></span> clr YH ldi YL, <span class="hljs-number"><span class="hljs-number">4</span></span> sub_next: movw X, OP0 ldd temp_0, Y+<span class="hljs-number"><span class="hljs-number">0x08</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> XL, temp_0 adc XH, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ld temp_0, X std Y+<span class="hljs-number"><span class="hljs-number">0x08</span></span>, temp_0 movw X, OP0 ldd temp_0, Y+<span class="hljs-number"><span class="hljs-number">0x0C</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> XL, temp_0 adc XH, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ld temp_0, X std Y+<span class="hljs-number"><span class="hljs-number">0x0C</span></span>, temp_0 movw X, OP0 ldd temp_0, Y+<span class="hljs-number"><span class="hljs-number">0x04</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> XL, temp_0 adc XH, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ld temp_0, X std Y+<span class="hljs-number"><span class="hljs-number">0x04</span></span>, temp_0 movw X, OP0 ldd temp_0, Y+<span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> XL, temp_0 adc XH, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ld temp_0, X st Y+, temp_0 sbrs YL, <span class="hljs-number"><span class="hljs-number">3</span></span> ;XL == <span class="hljs-number"><span class="hljs-number">8</span></span> rjmp sub_next</code> </pre></div></div><br>  Approaching the portal to hell.  Before entering there, we need to invent multiplication by 2. From an engineering point of view, multiplying by 2 in the final field differs from the simple one in that after shifting to the left, add 0x1B to the result if the high bit of the multiplier was a single.  If the bit was edinichkoy, then ... you can not use the transitions and conditions in the relevant parts of the cryptographic systems.  No problem!  Before the shift to the left, we will save the most significant bit and then we will write it in the right places of the empty register until we collect 0x1B there, if the bit was one, or 0 if it was zero. <br><br>  Surprise.  In my implementation, the multiplication procedure by 2 is located on one of the bootloader sizes.  At the point of hit of this size, we place an unconditional transition to the beginning of the boot and, so that it does not interfere with living with each multiplication by 2, jump over it. <br><br><div class="spoiler">  <b class="spoiler_title">Sub bytes</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">;temp_0 &lt;- temp_0 * <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a finite field) ;temp_0 = (temp_0 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ (<span class="hljs-number"><span class="hljs-number">0x1B</span></span> &amp; MSB(temp_0)) ;<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> BRANCHING HERE ;uses <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a dirty way mul_by_2: bst temp_0, <span class="hljs-number"><span class="hljs-number">7</span></span> ;store <span class="hljs-number"><span class="hljs-number">7</span></span>th <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T bld <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;we form <span class="hljs-number"><span class="hljs-number">0x1B</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> rjmp cont_mul rjmp BOOT_START ;<span class="hljs-number"><span class="hljs-number">0x1F80</span></span>. BOOTSZ can be here cont_mul: bld <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> lsl temp_0 bld <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> bld <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> eor temp_0, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> clr <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ret</code> </pre></div></div><br>  There is the last stage - the mixing of columns.  The elements of each column undergo the following transformation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1f/1ee/d06/e1f1eed06c647d9c850b059bef5eddbc.png"><br><br>  Multiplication by 2 we wrote above.  Addition in a finite field is exclusive or.  To multiply by 3, you just need to add the number again to the result of multiplication by 2. The difficulty is that we, suddenly, write in assembly language, are limited in the amount of code and have a lot to count.  Optimization will have to perform in the mind and comments.  It is necessary to think very carefully about the course of calculations and use the registers wisely. <br><br><div class="spoiler">  <b class="spoiler_title">Mix columns</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">mix_columns: ;point <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> clr YH ldi YL, <span class="hljs-number"><span class="hljs-number">4</span></span> next_column: ldd temp_2, Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x00 ;result0 ldd temp_3, Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x01 ;r1 ldd temp_4, Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x02 ;r2 ldd temp_5, Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x03 ;r3 mov temp_0, temp_3 ;r1 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> operand rcall mul_by_2 ;r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov temp_1, temp_0 ;save r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_2 ;r0 + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_5 ;r0 + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 (lacks r2 * <span class="hljs-number"><span class="hljs-number">3</span></span>) std Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x01, temp_0 ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> r1 mov temp_0, temp_2 ;r0 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> operand rcall mul_by_2 ;r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov OP0, temp_0 ;OP0 &lt;- r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_1 ;r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_3 ;r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r1 * <span class="hljs-number"><span class="hljs-number">3</span></span> eor temp_0, temp_4 ;r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r1 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r2 eor temp_0, temp_5 ;r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r1 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r2 + r3 (done) std Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x00, temp_0 ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> r0 mov temp_1, OP0 ;OP0 -&gt; r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov temp_0, temp_5 ;r3 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> operand rcall mul_by_2 ;r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov OP0, temp_0 ;OP0 &lt;- r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_1 ;r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r0 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_2 ;r0 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_3 ;r0 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r1 + r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_4 ;r0 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r1 + r2 + r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> (done) std Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x03, temp_0 ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> r3 mov temp_1, OP0 ;OP0 -&gt; r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov temp_0, temp_4 ;r2 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> operand rcall mul_by_2 ;r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> mov OP0, temp_0 ;OP0 &lt;- r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_1 ;r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 * <span class="hljs-number"><span class="hljs-number">2</span></span> eor temp_0, temp_5 ;r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 * <span class="hljs-number"><span class="hljs-number">3</span></span> eor temp_0, temp_2 ;r0 + r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 * <span class="hljs-number"><span class="hljs-number">3</span></span> eor temp_0, temp_3 ;r0 + r1 + r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 * <span class="hljs-number"><span class="hljs-number">3</span></span> (done) std Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x02, temp_0 ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> r2 mov temp_1, OP0 ;OP0 -&gt; r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> ldd temp_0, Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x01 ;r0 + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 eor temp_0, temp_1 ;r0 + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r2 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r3 eor temp_0, temp_4 ;r0 + r1 * <span class="hljs-number"><span class="hljs-number">2</span></span> + r2 * <span class="hljs-number"><span class="hljs-number">3</span></span> + r3 (done) std Y+<span class="hljs-number"><span class="hljs-number">0</span></span>x01, temp_0 ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> r1 adiw Y, <span class="hljs-number"><span class="hljs-number">4</span></span> ;pointer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> column cpi YL, <span class="hljs-number"><span class="hljs-number">20</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> done brne next_column ;<span class="hljs-keyword"><span class="hljs-keyword">process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> ret</code> </pre></div></div><br>  Just a lot of arithmetic.  In the calculation process, there are 6 memory accesses instead of the expected 4, but, as it seems to me, the maximum possible spatial optimization has been achieved. <br><br>  So, all the necessary encryption steps for AES are written.  Let's put them together.  Keeping pointers to the stack before starting work and restoring them later is good practice.  Almost always they are used somewhere else and the main program does not expect such a setup as changing pointers to memory in one of the procedures.  The same applies to the status register.  If you are not limited in space - always save the status register at the beginning of the procedure and restore it before returning! <br><br><div class="spoiler">  <b class="spoiler_title">Encryption itself</b> <div class="spoiler_text"><pre> <code class="hljs perl">;performs a round of encryption ;using <span class="hljs-keyword"><span class="hljs-keyword">given</span></span> expanded <span class="hljs-keyword"><span class="hljs-keyword">keys</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span>-box Rijndael_encrypt: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ZH <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ZL <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> YH <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> YL <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> XH <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> XL ldi ZH, high(KEYS*<span class="hljs-number"><span class="hljs-number">2</span></span>) ldi ZL, low( KEYS*<span class="hljs-number"><span class="hljs-number">2</span></span>) rcall add_round_key ldi temp_<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> encryption_cycle: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> temp_<span class="hljs-number"><span class="hljs-number">0</span></span> ;store cycle counter rcall substitute_shift_rows rcall mix_columns rcall add_round_key rjmp continue_enc rjmp BOOT_START ;<span class="hljs-number"><span class="hljs-number">0x1F00</span></span>. BOOTSZ can be here continue_enc: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> temp_<span class="hljs-number"><span class="hljs-number">0</span></span> ;restore cycle counter dec temp_<span class="hljs-number"><span class="hljs-number">0</span></span> brne encryption_cycle rcall substitute_shift_rows rcall add_round_key <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> XL <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> XH <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> YL <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> YH <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ZL <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ZH ret</code> </pre></div></div><br>  Calculate how many bytes we packed.  Addition with a key - 18 bytes.  Multiplication by 2 - 22 bytes.  Row shift - 50 bytes.  The substitution is 62 bytes.  Mixing columns - 94 bytes.  Connect all this - 56 bytes.  Total - 302 bytes.  To understand that you did it is priceless.  Slightly larger than the average size of the Windows executable header <br><br>  The block cipher is good, but without a special encryption mode, it is practically useless.  If the block cipher has nothing to do - it is also useless, therefore, let's get to the reception of data. <br><br><h4>  Information Exchange Protocol </h4><br>  The block of encrypted data in EAX, as in almost any other authenticated encryption scheme, consists of the initialization vector, the data itself and the signature.  The initialization vector and the signature have the block length of the underlying cipher, the data itself is of arbitrary length, in our case the size of the Flash page.  Remember the memory allocation step - the data block elements are arranged in SRAM sequentially, to facilitate the process of receiving data from the computer. <br><br>  In order to simplify the design, we will not think about any fancy data format - we accept the firmware, which should fill the entire volume of Flash.  All memory areas that are not directly involved in the firmware must be filled with random bytes.  Thus, it is impossible to release a small patch that fixes just a couple of commands - the bootloader will change everything.  It may be long, but safety is paramount. <br><br>  The data exchange protocol is the following: immediately after the replacement table is generated, the bootloader issues the byte 0xC0 (COnfirm) to the port and waits for the 0x60 byte (GO).  After the readiness signal from the computer, the boot sets the Z pointer to the beginning of the recorded memory area, writes to temp_0 the number of pages to be received, decrypted and written, and proceeds to receive the page.  It looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Beginning of work</b> <div class="spoiler_text"><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">wait_for_start:</span></span> rcall confirm_and_read cpi temp_<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0x60</span></span> brne wait_for_start ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PAGE ADDR INIT .if USE_0th_PAGE == 0 ldi ZH, high(PAGE_BYTES) ldi ZL, low( PAGE_BYTES) ldi temp_0, PAGES - 1 .else clr ZH clr ZL ldi temp_0, PAGES .endif next_page: ;save page counter and address push temp_0 push ZH push ZL ;/</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>BLOCK RECEPTION ;receive whole block ldi XH, high(SAVED_IV) ldi XL, low( SAVED_IV) ldi temp_1,( BLOCK_SIZE /*nonce*<span class="hljs-regexp"><span class="hljs-regexp">/ + PAGE_BYTES /</span></span>*page*<span class="hljs-regexp"><span class="hljs-regexp">/ + BLOCK_SIZE /</span></span>*expected tag*<span class="hljs-regexp"><span class="hljs-regexp">/ ) get_more_block: rcall confirm_and_read st X+, temp_0 dec temp_1 brne get_more_block</span></span></code> </pre></div></div><br>  As we remember from the listing of the confirm_and_read function, it first sends 0xC0, then waits for a response.  This ensures synchronization with the computer in its simplest form - the software should send the next byte only with the full readiness of the receiving party.  This, of course, is slow - it takes longer to receive and transmit data than to decrypt, which we will now deal with. <br><br><h4>  EAX Assembled </h4><br>  If we implement EAX exactly as shown in the Two Documenting Pictures - we will not fit into the volume.  Therefore, we will correct the course of events. <br><br>  The signature is the sum of the encrypted initialization vector (N, from Nonce), the data header (it is processed at the key generation stage) and the authentication code of the data itself, calculated using the CMAC \ OMAC algorithm.  The signature calculated on the spot should be the same as the one sent to us.  An exclusive or two identical numbers is 0. Therefore, we will summarize all calculated values ‚Äã‚Äãdirectly into the resulting signature, and then check whether all of its values ‚Äã‚Äãhave been converted to 0. <br><br>  We already know H '‚Äîthe specified and processed header found in the key file.  Immediately add it to the received signature: <br><br><div class="spoiler">  <b class="spoiler_title">Beginning of work</b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/TAG INITIALIZATION ;initialize precomputed header with tag ;tag &lt;- H ^ tag header_to_tag: ldi ZH, high(PRECOMP_HEADER_TAG*2) ldi ZL, low( PRECOMP_HEADER_TAG*2) ldi YH, high(TAG) ldi YL, low( TAG) next_header_byte: lpm temp_0, Z+ ld temp_1, Y eor temp_0, temp_1 st Y+, temp_0 cpi YL, low( TAG + BLOCK_SIZE ) brne next_header_byte</span></span></code> </pre></div></div><br>  The next simple step is the calculation of N '.  We have all the necessary data for this.  We make life easier for us by highlighting all the manipulations with memory blocks in separate procedures.  We may need to move the data block to the register file, add two data blocks by the pointer, etc.  In two procedures, depending on the call mark, it was already located 9. I did not hear that such optimization was possible in a higher level language. <br><br><div class="spoiler">  <b class="spoiler_title">Secondary functions</b> <div class="spoiler_text"><pre> <code class="hljs haskell">;block &lt;- block ^ <span class="hljs-type"><span class="hljs-type">Z</span></span> xor_Z_to_block_RAM: ldi <span class="hljs-type"><span class="hljs-type">YH</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ldi <span class="hljs-type"><span class="hljs-type">YL</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> ;<span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">Y</span></span> ^ <span class="hljs-type"><span class="hljs-type">Z</span></span> xor_Z_to_Y_RAM: ldi temp_2, <span class="hljs-type"><span class="hljs-type">BLOCK_SIZE</span></span> ;<span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">Y</span></span> ^ <span class="hljs-type"><span class="hljs-type">Z</span></span> ( temp_2 times ) ram_xor_cycle: ld temp_3, <span class="hljs-type"><span class="hljs-type">Z</span></span>+ ld temp_1, <span class="hljs-type"><span class="hljs-type">Y</span></span> eor temp_1, temp_3 st <span class="hljs-type"><span class="hljs-type">Y</span></span>+, temp_1 dec temp_2 brne ram_xor_cycle ret ;block -&gt; <span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span> save_IV: ldi <span class="hljs-type"><span class="hljs-type">YH</span></span>, high(<span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span>) ldi <span class="hljs-type"><span class="hljs-type">YL</span></span>, low( <span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span>) ;block -&gt; <span class="hljs-type"><span class="hljs-type">Y</span></span> from_regs_to_Y: ldi <span class="hljs-type"><span class="hljs-type">XH</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ldi <span class="hljs-type"><span class="hljs-type">XL</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> rjmp move_from_X_to_Y ;<span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span> -&gt; block rest_IV: ldi <span class="hljs-type"><span class="hljs-type">XH</span></span>, high(<span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span>) ldi <span class="hljs-type"><span class="hljs-type">XL</span></span>, low( <span class="hljs-type"><span class="hljs-type">SAVED_IV</span></span>) ;<span class="hljs-type"><span class="hljs-type">X</span></span> -&gt; block from_X_to_regs: ldi <span class="hljs-type"><span class="hljs-type">YH</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ldi <span class="hljs-type"><span class="hljs-type">YL</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> ;<span class="hljs-type"><span class="hljs-type">X</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Y</span></span> move_from_X_to_Y: ldi temp_0, <span class="hljs-number"><span class="hljs-number">0x10</span></span> ;<span class="hljs-type"><span class="hljs-type">X</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Y</span></span> ( temp_0 times ) ram_save_cycle: ld temp_1, <span class="hljs-type"><span class="hljs-type">X</span></span>+ st <span class="hljs-type"><span class="hljs-type">Y</span></span>+, temp_1 dec temp_0 brne ram_save_cycle ret</code> </pre></div></div><br>  Now, let's proceed to the calculation of N 'according to the Documenting Pictures.  It uses the prepared at the stage of generating the key B and L0.  Everything that happens, traditionally, is described in the comments.  At the end of the calculation, the resulting N 'is summed with the signature. <br><br><div class="spoiler">  <b class="spoiler_title">Initialization Vector Processing</b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/NONCE ;block &lt;- N ldi XH, high(SAVED_IV) ldi XL, low( SAVED_IV) rcall from_X_to_regs ;block &lt;- N ^ B ldi ZH, high(PRECOMP_B*2) ldi ZL, low( PRECOMP_B*2) rcall add_round_key ;block &lt;- N ^ B ^ L0 ldi ZH, high(PRECOMP_L0*2) ldi ZL, low( PRECOMP_L0*2) rcall add_round_key ;block &lt;- E( N^B^L0 ) (nonce) rcall Rijndael_encrypt ;save calculated nonce rcall save_IV ;tag &lt;- H ^ N ^ expected ldi YH, high(TAG) ldi YL, low( TAG) ldi ZH, high(SAVED_IV) ldi ZL, low( SAVED_IV) rcall xor_Z_to_Y_RAM</span></span></code> </pre></div></div><br>  For data encryption, EAX uses AES in CTR mode.  This mode turns block AES into a stream cipher with which you can encrypt data of arbitrary length without any problems.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initialization vector is the just prepared N ', which, each block, is incremented by one and is encrypted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increasing by one is a problem; when we have a number of 16 random bytes, we will have to process all transfers to one, you never know.</font></font> Nothing complicated. <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increment of 16 registers at the same time</font></font></b> <div class="spoiler_text"><pre> <code class="hljs vhdl">;<span class="hljs-keyword"><span class="hljs-keyword">block</span></span>++ ;<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> carrying <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> done properly increment_regs: ldi YH, <span class="hljs-number"><span class="hljs-number">0</span></span> ldi YL, <span class="hljs-number"><span class="hljs-number">20</span></span> clr temp_0 carry_next: ld temp_0, Y cpi temp_0, <span class="hljs-number"><span class="hljs-number">1</span></span> ld temp_0, -Y adc temp_0, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> st Y, temp_0 cpi YL, <span class="hljs-number"><span class="hljs-number">5</span></span> brsh carry_next ret</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We add the encrypted initialization vector with the data - we get the decrypted data. </font><font style="vertical-align: inherit;">We will not decrypt them before verification of the signature, they will be decrypted immediately before being written into memory. </font><font style="vertical-align: inherit;">But N 'is ready, the memory for the decryption code is allocated - why not generate it?</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTR mode</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/DECRYPTION IVs ldi YH, high(ENC_IV) ldi YL, low( ENC_IV) IV_calc_cycle: ;block &lt;- E(IV) rcall Rijndael_encrypt ;ENC_IV &lt;- E(IV) rcall from_regs_to_Y push YH push YL ;IV++ rcall rest_IV rcall increment_regs rcall save_IV pop YL pop YH cpi YL, low( ENC_IV + PAGE_BYTES ) brne IV_calc_cycle</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The hardest part is the message authentication code. </font><font style="vertical-align: inherit;">It is based on CBC - not the most convenient for the implementation in the assembler encryption mode. </font><font style="vertical-align: inherit;">Honestly, I don‚Äôt know why people still use CBC instead of CTR in everyday life. </font><font style="vertical-align: inherit;">It requires alignment to block size, is not parallelized, has some funny vulnerabilities if it is implemented incorrectly and, in general, is more complicated. </font><font style="vertical-align: inherit;">Fortunately, we took care of the alignment during the encryption phase of the firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that B, according to Pictures, is summed only with the last block - at the end of the encrypted string. </font><font style="vertical-align: inherit;">As in the case of the initialization vector, the obtained authentication code is immediately summed up with the signature.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMAC / OMAC signature calculation</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/CMAC /</span></span> OMAC TAG CALCULATION ( block &lt;- C ) ;X contains <span class="hljs-number"><span class="hljs-number">20</span></span> after last save_IV command <span class="hljs-symbol"><span class="hljs-symbol">clear_registers:</span></span> st -X, NULL cpi XL, <span class="hljs-number"><span class="hljs-number">4</span></span> brne clear_registers ;block &lt;- L2 ldi ZH, high(PRECOMP_L2*<span class="hljs-number"><span class="hljs-number">2</span></span>) ldi ZL, low( PRECOMP_L2*<span class="hljs-number"><span class="hljs-number">2</span></span>) rcall add_round_key ;last block is processed individually ldi temp_<span class="hljs-number"><span class="hljs-number">0</span></span>, BLOCKS_PER_PAGE ldi ZH, high(RCVD_PAGE) ldi ZL, low( RCVD_PAGE) <span class="hljs-symbol"><span class="hljs-symbol">CBC_TAG:</span></span> ;block &lt;- block ^ m(i) ;temp_<span class="hljs-number"><span class="hljs-number">0</span></span> is fine rcall xor_Z_to_block_RAM push temp_<span class="hljs-number"><span class="hljs-number">0</span></span> cpi temp_<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> brne dont_add_B ldi ZH, high(PRECOMP_B*<span class="hljs-number"><span class="hljs-number">2</span></span>) ldi ZL, low( PRECOMP_B*<span class="hljs-number"><span class="hljs-number">2</span></span>) rcall add_round_key <span class="hljs-symbol"><span class="hljs-symbol">dont_add_B:</span></span> ;Z is saved properly rcall Rijndael_encrypt pop temp_<span class="hljs-number"><span class="hljs-number">0</span></span> dec temp_<span class="hljs-number"><span class="hljs-number">0</span></span> brne CBC_TAG ;block &lt;- H ^ N ^ C ^ expected ldi ZH, high(TAG) ldi ZL, low( TAG) rcall xor_Z_to_block_RAM</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We just installed the last part in the puzzle and we can check whether the signature came together or not. </font><font style="vertical-align: inherit;">The condition of the signature validity - all its bytes must turn to 0. Traditional cryptographic verification - combine all values ‚Äã‚Äãusing OR into a separate register, no conditions. </font><font style="vertical-align: inherit;">After the cycle is solved, write the data in Flash, or report a signature error and die.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditional secure signature verification</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/TAG CHECK clr temp_0 check_more: ld temp_1, -Y or temp_0, temp_1 cpi YL, 4 brne check_more cp temp_0, NULL breq do_write rjmp die</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The die label sends us to an infinite loop, sending 0xFF to any request. </font><font style="vertical-align: inherit;">The firmware should notice incorrect confirmation bytes and notify the user that the file is not suitable.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eternal cycle of error</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/TAG FAILURE AND EXIT die: ldi temp_0, 0xFF rcall UART_send rjmp die</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the caption is correct - we restore the Z pointer to the current Flash page and proceed to the recording procedure. </font><font style="vertical-align: inherit;">If this page was the last one, go to the upload_done tag, which sends the success byte to the firmware - 0x0C and goes into the death cycle.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All is well - go to the record</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/TAG SUCCESS - CTR AND WRITE do_write: ;restore page pointers pop ZL pop ZH ;decrypt and write page rcall store_page ;restore page counter pop temp_0 dec temp_0 ;continue if not done, else - die breq upload_done rjmp next_page</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The procedure for decrypting and writing to Flash is unremarkable, I just followed the self-programming documentation. </font><font style="vertical-align: inherit;">The only interesting place is an attempt to spoil the byte written into the Flash by the contents of the temp_0 register, which should contain the result of the signature packing. </font><font style="vertical-align: inherit;">If the signature was correct - there is 0 in temp_0 and nothing will happen to the data. </font><font style="vertical-align: inherit;">If for some reason the microcontroller successfully ‚Äúflew over‚Äù all the checks and started writing in Flash - at least it will write garbage there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The self-programming procedure is iron-dependent; when porting to other microcontrollers, it may be necessary to correct the call to the store program memory command.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decrypt data and write to Flash</font></font></b> <div class="spoiler_text"><pre> <code class="hljs pgsql">;D( RCVD_PAGE ) -&gt; flash store_page: ;erase <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> page ldi temp_1, <span class="hljs-number"><span class="hljs-number">0</span></span>b00000011 rcall spm_it ldi YH, high(RCVD_PAGE) ldi YL, low( RCVD_PAGE) ldi XH, high(ENC_IV) ldi XL, low( ENC_IV) write_next: ld r0, Y+ ld temp_2, X+ eor r0, temp_2 ld r1, Y+ ld temp_2, X+ eor r1, temp_2 ;last countermeasure - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we jumped through tag <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> eor r0, temp_0 eor r1, temp_0 ;store word <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> page buffer ldi temp_1, <span class="hljs-number"><span class="hljs-number">0</span></span>b00000001 rcall spm_it adiw Z, <span class="hljs-number"><span class="hljs-number">2</span></span> cpi YL, low( RCVD_PAGE + PAGE_BYTES ) brne write_next ;<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> page ;back <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> page <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> subi ZL, low( PAGE_BYTES) sbci ZH, high(PAGE_BYTES) ;<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> page ldi temp_1, <span class="hljs-number"><span class="hljs-number">0</span></span>b00000101 rcall spm_it ;<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> next page <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> subi ZL, low( -PAGE_BYTES) sbci ZH, high(-PAGE_BYTES) ;re-<span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> flash ldi temp_1, <span class="hljs-number"><span class="hljs-number">0</span></span>b00010001 rcall spm_it ret spm_it: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_2, SPMCSR sbrc temp_2, SPMEN rjmp spm_it <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> SPMCSR, temp_1 spm ret</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Putting it all together. </font><font style="vertical-align: inherit;">Exactly 1024 bytes. </font><font style="vertical-align: inherit;">It remains to flash the microcontroller, set up the fuses and write the client software.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/32e/123/aa6/32e123aa69c60ff0e1da72b8bb049a5c.png"><br><br><h4>  Testing </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not suffer from client software, we will write the key generator and the cryptographer of firmwares on Qt, with use of Crypto ++. </font><font style="vertical-align: inherit;">Static header for encryption is inscribed there, tightly. </font><font style="vertical-align: inherit;">All unused memory areas are filled with random bytes. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/113/ea9/e1a/113ea9e1ae93238811e75af64fb20a29.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The flasher is elementary - wait for 0xC0, send 0x60 and, until the file is finished, send a byte in response to each 0xC0. </font><font style="vertical-align: inherit;">Received 0x0C - everything is ready, received 0xFF - an error occurred. </font><font style="vertical-align: inherit;">Let's write it on pure C for Linux. </font><font style="vertical-align: inherit;">I don't have a COM port on my laptop, so ... we use the Psion 5MX, which is only 5 years younger than me.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/ff7/e54/933ff7e54a39ad2e98f5b711a9d3de59.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will get some board with ATmega8A from the bins of the homeland, we will boot it with a boot, connect the board with the MAX233 with a piece of board, assemble the flash driver on the Pioneer, rewind it all with random wiring, specify the port and the firmware file to the flash driver ... Restart the power supply ... The process has started. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember, no Arduino</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/bc4/9af/9ffbc49af5b0d6407b2b8b833e5503a9.jpg"></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something is clearly happening.</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/d8a/4bb/093/d8a4bb0937445161197515307894c187.jpg"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I apologize for the condition of the table and the test stand - the radio electronics engineer from me is not very. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole task of the test program is to turn off the LED and hang forever. </font><font style="vertical-align: inherit;">After the firmware, it succeeds. </font><font style="vertical-align: inherit;">Success!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diligent Psion delivered 10KB to the port and is waiting for instructions</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/ffe/d3c/ef2ffed3ce6be9c75ec735210fe62032.jpg"></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED goes out</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/8c5/fc7/928/8c5fc79289a3496a8e3ac22c6e4016bc.jpg"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this simple way, you can do the impossible and leave plenty of room for user code. </font><font style="vertical-align: inherit;">Now there is a way to roll out patches, without worrying about the source being stolen by some kind of Chinese spy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would be glad if someone finds critical security bugs in my implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All source codes and this article are distributed under the CreativeCommons Attribution-NonCommercial-ShareAlike license. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd3/f54/eba/fd3f54eba25923cfa3a72c5846809024.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The repository on GitHub: </font></font><a href="https://github.com/sirgal/AVR-EAX-AES-bootloader"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/sirgal/AVR-EAX-AES-bootloader</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (all the code for the PC is written in a hurry and, sometimes, a year ago, I will be glad if someone wants to fix this horror, I do not have time yet)</font></font></div><p>Source: <a href="https://habr.com/ru/post/224383/">https://habr.com/ru/post/224383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224371/index.html">PVS-Studio checks OpenMW: everything is not smooth in the Morrowind universe</a></li>
<li><a href="../224373/index.html">Portrait of active authors in the social network Odnoklassniki</a></li>
<li><a href="../224375/index.html">Skype: Online Voice Translator</a></li>
<li><a href="../224379/index.html">How Wikipedia works (part 1)</a></li>
<li><a href="../224381/index.html">The presentation of the server line EcoServer held at the All-Russian forum of providers of hosting</a></li>
<li><a href="../224387/index.html">Google released its own model of the robot car</a></li>
<li><a href="../224389/index.html">Blocks of information collection. Introduction</a></li>
<li><a href="../224391/index.html">Introduction to JadePHP</a></li>
<li><a href="../224393/index.html">Oracle introduced Solaris 11.2 Beta</a></li>
<li><a href="../224397/index.html">Is there a future for IT? View of David Vernon University Innopolis Professor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>