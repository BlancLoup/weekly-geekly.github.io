<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An introduction to shader programming: part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having learned how to write shaders, you will be able to make the most efficient use of all the computing power of modern graphics chips, thousands of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An introduction to shader programming: part 2</h1><div class="post__text post__text-html js-mediator-article">  Having learned how to write shaders, you will be able to make the most efficient use of all the computing power of modern graphics chips, thousands of cores of which work in parallel in one thread, because all shader calculations are performed on the GPU and not on the CPU.  Programming shaders requires a different thinking and approach to writing code than writing ordinary programs, but their almost unlimited potential more than pays for all the problems at the initial stages. <br><br><img src="https://habrastorage.org/files/fb6/77e/691/fb677e69164540a098cfeea507d29795.jpg"><br><a name="habracut"></a><br><br>  The first part of the ‚ÄúIntroduction to Shader Programming‚Äù material can be found <a href="http://gamedevelopment.tutsplus.com/ru/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">here.</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <a href="https://www.shadertoy.com/">ShaderToy</a> service that we used in the previous lesson is great for conducting quick tests and experiments, but its functionality is very limited.  For example, you can not specify which data you need to send to the shader.  To get more opportunities to create a variety of effects, you need your own working environment to run shaders. <br><br>  To work with shaders in the browser, we will use Three.js.  WebGL will provide us with a JavaScript API for rendering shaders, and Three.js will make this process even easier. <br><br>  If you are not interested in JavaScript or development for web platforms, do not worry: we will not be closely involved in the specifics of web rendering (if you want to learn more about Three.js, read <a href="http://gamedevelopment.tutsplus.com/articles/how-to-learn-threejs-for-game-development--gamedev-11787">this lesson</a> ).  The fact is that setting up shaders in the browser is the fastest way to get started, but as you familiarize yourself with the process, you can easily set up and use shaders on any other platform. <br><br>  <b>Customization</b> <br><br>  In this section we will talk about how to configure shaders locally.  Source code is available <a href="http://codepen.io/tutsplus/pen/OVxXZE">for viewing on CodePen</a> : <br><br><img src="https://habrastorage.org/files/e2c/d10/e6f/e2cd10e6f11b4d3d92a1d54ed3edb6bf.png"><br><br>  <b>Meet Three.js!</b> <br><br>  <a href="http://threejs.org/">Three.js</a> is a JavaScript framework that is responsible for the stereotypical code for WebGL needed to render shaders.  To get started with Three.js, you can use <a href="https://cdnjs.com/libraries/three.js/">its latest version on CDN.</a> <br><br>  <a href="https://github.com/tutsplus/Beginners-Guide-to-Shaders/blob/master/Part2/shader_base.html">Here</a> you can download the HTML code of the Three.js base scene. <br><br>  Save the file to disk, and then open it in a browser.  You will see just a black screen - nothing interesting.  Let's add a cube here to make sure everything works. <br><br>  Before you add a cube to a scene, you need to define its geometry and material.  Paste the following code snippet under Add your code here: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial( { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0x00ff00</span></span>} );<span class="hljs-comment"><span class="hljs-comment">//   var cube = new THREE.Mesh( geometry, material ); //    scene.add( cube ); cube.position.z = -3;// ,   </span></span></code> </pre> <br><br>  We will not analyze this code in detail, since we are more interested in working with shaders.  But if everything is correct, a green cube should appear in the middle of the screen: <br><br><img src="https://habrastorage.org/files/f10/5b6/5aa/f105b65aa9264d49a6f2cfb99e390e8f.png"><br><br>  Now let's add a spin.  The render function is called for each frame.  The rotation of the cube is set using cube.rotation.x (either .y or .z).  Here you can play with the values, but the final render function should look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cube.rotation.y += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; requestAnimationFrame( render ); renderer.render( scene, camera ); }</code> </pre><br><br>  <b>Task:</b> How to make the cube rotate on a different axis?  And on two axes at the same time? <br>  So, everything is ready, it's time to add shaders! <br><br>  <b>Adding Shaders</b> <br><br>  Now you can proceed to add shaders.  Regardless of the platform used, you will probably have a question: everything seems to be set up, a cube rotates on the screen, but how to get access to the GPU? <br><br>  <b>Step 1: Upload to GLSL Code</b> <br><br>  To build our scene, we use JavaScript.  In other cases, it can be C ++, Lua, or any other language.  Anyway, a special language is used to write shaders - Shading Language.  For OpenGL, that language is GLSL (OpenGL Shading Language).  Given that WebGL is based on OpenGL, we will have to deal with GLSL. <br><br>  How and where to write GLSL code?  As a rule, the GLSL code is loaded as a string of characters (string), which is then parsed and executed in the GPU. <br>  In JavaScript, you just need to add all the code to a variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderCode = <span class="hljs-string"><span class="hljs-string">"All your shader code here;"</span></span></code> </pre><br><br>  This method works, but since JavaScript is not so easy to create multi-line strings, it does not suit us.  Most developers write the shader code in a text file, change its extension to .glsl or .frag (abbreviated from ‚Äúfragment shader‚Äù) and then load it. <br><br>  We will go another way: we will write the code of our shader inside the script tag and from there we will load it into JavaScript.  Thus, we can, for convenience, store everything in one file. <br><br>  Add a script tag inside our HTML file: <br><br><pre> <code class="javascript hljs">&lt;script id=<span class="hljs-string"><span class="hljs-string">"fragShader"</span></span> type=<span class="hljs-string"><span class="hljs-string">"shader-code"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><br>  To make it easy to find the tag later, we assign it the identifier fragShader.  In fact, the type shader-code does not exist (instead, you can specify any other name).  We need this so that the code is not executed and not displayed in HTML. <br>  Now we add the simplest shader that returns only white color. <br><br><pre> <code class="javascript hljs">&lt;script id=<span class="hljs-string"><span class="hljs-string">"fragShader"</span></span> type=<span class="hljs-string"><span class="hljs-string">"shader-code"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/script&gt;</span></span></code> </pre><br><br>  In this case, the vec4 components correspond to the rgba values, as described in the previous lesson. <br>  Finally, download our code.  In JavaScript, this is done using a simple string that finds the HTML file and parses the code inside it: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderCode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"fragShader"</span></span>).innerHTML;</code> </pre><br><br>  This line must be below the code for the cube. <br>  Remember: only if the code is loaded as a string of characters will it be recognized as a valid GLSL code (that is, void main () {...}. The rest is just stereotypical HTML code). <br><br>  <b>Step 2: Shader Overlay</b> <br><br>  Shading methods may vary depending on the platform and how they interact with the GPU.  However, nothing complicated here.  In the same Google, you can easily find how to create an object <a href="http://threejs.org/docs/">and apply shaders to it using Three.js.</a> <br>  We need to create a special material and give him the code of our shader.  Create a plane (although a cube would suit for this) and impose a shader on it: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     var material = new THREE.ShaderMaterial({fragmentShader:shaderCode}) var geometry = new THREE.PlaneGeometry( 10, 10 ); var sprite = new THREE.Mesh( geometry,material ); scene.add( sprite ); sprite.position.z = -1; //  ,   </span></span></code> </pre><br><br>  A white screen should appear: <br><br><img src="https://habrastorage.org/files/4f7/942/025/4f79420251a7454e8c342acc0e7ec4e9.png"><br><br>  If you change the current color in the shader code to another, the new color will appear after the update. <br><br>  <b>Task:</b> How to make one part of the screen red and the other blue?  If you are having difficulty, study the next step. <br><br>  <b>Step 3: Submitting Data</b> <br><br>  Now we can do anything with a shader.  But, frankly, there is nothing special to do with it.  We can only set the built-in variable gl_FragCoord, which is responsible for the position of the pixels, but for this <a href="http://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">we need</a> to at least know the parameters of the screen. <br><br>  The data should be sent to the shader in the form of a so-called uniform variable.  To do this, create an object called uniforms and add our variables to it.  Here is an example syntax for sending screen resolution data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = {}; uniforms.resolution = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'v2'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth,<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight)};</code> </pre><br><br>  Each uniform variable must have two parameters: type and value.  In this case, we have a two-dimensional vector, where the width and height of the screen act as coordinates.  Below is a table (from <a href="http://threejs.org/docs/">the Three.js specifications</a> ) with all types and data identifiers that can be sent: <br><br><img src="https://habrastorage.org/files/5bc/3bb/87a/5bc3bb87af0d42b586abc10e1c264fb3.png"><br><br>  To send data to the shader, add it to ShaderMaterial: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({<span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>:uniforms,<span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>:shaderCode})</code> </pre><br><br>  And that is not all!  Now we can use this variable.  Let's create a gradient just like in the previous lesson: adjust the coordinates and adjust the color value. <br><br>  Change the code as follows: <br><br><pre> <code class="javascript hljs">uniform vec2 resolution; <span class="hljs-comment"><span class="hljs-comment">//  uniform- void main() { //     vec2 pos = gl_FragCoord.xy / resolution.xy; //   ! gl_FragColor = vec4(1.0,pos.x,pos.y,1.0); }</span></span></code> </pre><br><br>  And you will see a beautiful gradient! <br><br><img src="https://habrastorage.org/files/98d/c9f/acf/98dc9facfb1b422388edbc5553719855.png"><br><br>  On CodePen, you can create a source code branch and edit it. <br>  If it's not entirely clear to you how we managed to get such a nice gradient with just two lines of code, take a look at the first lesson.  In it, we analyzed all the details in detail. <br>  <b>Task:</b> How to divide the screen into four identical sectors with different colors?  Like that: <br><br><img src="https://habrastorage.org/files/1c9/185/c29/1c9185c293bb496fa573db03407a3aa2.png"><br><br>  <b>Step 4: Update Data</b> <br><br>  Now we can send data to the shader.  But what if you need to update them?  For example, <a href="http://codepen.io/tutsplus/pen/bdoeMm">if you open the previous example</a> in a new tab and change the size of the window, the gradient does not update, because it still uses the initial screen settings. <br><br>  Usually to update the variables you need to re-send the uniform variable.  But in Three.js, you simply update the uniforms object in the render function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cube.rotation.y += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; uniforms.resolution.value.x = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; uniforms.resolution.value.y = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; requestAnimationFrame( render ); renderer.render( scene, camera ); }</code> </pre><br><br>  If you open the updated <a href="http://codepen.io/tutsplus/pen/MwEeBN">code on CodePen</a> and change the window size, the colors will change, although the initial viewing area remains unchanged (you can easily see this if you look at the colors in each corner). <br><br>  <b>Note.</b>  This way of sending data to the GPU is very resource intensive.  When sending multiple variables in one frame, you will not feel the difference.  But if there are hundreds of variables, the frame rate will drop noticeably.  This may sound unbelievable, but if there are several hundred objects on the screen, and different lighting needs to be applied to everyone, the situation can quickly get out of control.  In the following articles we will definitely talk about optimizing the operation of shaders. <br><br>  <b>Task:</b> How to make the colors change over time?  If there are difficulties, look at <a href="http://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">how we dealt with this in the first lesson.</a> <a href="http://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313"><br></a> <br>  <b>Step 5: Working with Textures</b> <br><br>  Regardless of which platform you use and in what format you load textures, they are sent to the shader as uniform variables. <br><br>  For reference: uploading files to JavaScript is very simple from an external URL (which we will do).  When downloading an image from a local computer, access rights problems may occur, since JavaScript cannot and should not have access to your system files.  The easiest way to get around this is to set up a local server for Python.  But do not worry: it is much easier than it seems. <br>  Three.js is equipped with a very convenient function for loading an image as a texture: <br><br><pre> <code class="javascript hljs">THREE.ImageUtils.crossOrigin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       var tex = THREE.ImageUtils.loadTexture( "https://tutsplus.github.io/Beginners-Guide-to-Shaders/Part2/SIPI_Jelly_Beans.jpg" );</span></span></code> </pre><br><br>  The first line is entered only once.  Here you can paste the URL of any image. <br>  Now add a texture to the uniforms object. <br><br><pre> <code class="javascript hljs">uniforms.texture = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:tex};</code> </pre><br><br>  Finally, let's declare our uniform variable in the shader code and draw it in the same way as in the previous lesson ‚Äî using the texture2D function: <br><pre> <code class="javascript hljs">uniform vec2 resolution; uniform sampler2D texture; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec2 pos = gl_FragCoord.xy / resolution.xy; gl_FragColor = texture2D(texture,pos); }</code> </pre><br><br>  You should see a multi-colored dragee image stretched across the entire screen: <br><br><img src="https://habrastorage.org/files/a4f/9e4/5ce/a4f9e45ce56741e0bfe903eb578f5b7d.png"><br><br>  This is a standard computer graphics test image provided by the <a href="http://sipi.usc.edu/database/database.php%3Fvolume%3Dmisc%26image%3D7">Signal and Image Processing Institute of the</a> University of Southern California ( <a href="http://sipi.usc.edu/database/database.php%3Fvolume%3Dmisc%26image%3D7">hereinafter referred to as the Signal and Image Processing Institute</a> , hence the abbreviation IPI).  It is perfect for testing our graphic shaders. <br><br>  <b>Task:</b> How to make a gradual transition from full-color texture to grayscale?  Again, if there are difficulties, <a href="http://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">refer to the first lesson.</a> <br><br>  <b>Bonus Step: Overlaying Shaders to Other Objects</b> <br><br>  There is nothing special about the plane we created.  All this could be imposed on the cube. <br>  In fact, for this you need to change just one line of geometry, with this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PlaneGeometry( <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> );</code> </pre><br><br>  on this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre><br><br>  Voila!  Now dragee is displayed on the cube: <br><br><img src="https://habrastorage.org/files/2eb/ceb/1ea/2ebceb1ead4241688ee47e9f74df36e8.png"><br><br>  You can say: ‚ÄúWait a second, but this is not a completely correct projection of the texture onto the cube!‚Äù - and you will be right.  If you look closely at the shader, it becomes clear that we just put all the pixels of the test image on the screen.  That is, the image is flatly projected onto the cube, and all the pixels outside the cube are cropped. <br><br>  For a full projection on the edges of the cube, you would have to redo the 3D engine.  It sounds a little silly, considering that we already have a 3D engine that we <a href="http://codepen.io/tutsplus/pen/mJmjog">could use</a> to draw a texture on each facet separately.  But this series of lessons focuses more on the use of shaders to produce effects that could not have been achieved by other means.  Therefore, we will not analyze this issue.  If you're interested, <a href="https://www.udacity.com/course/interactive-3d-graphics--cs291">Udacity has an excellent course</a> on the basics of 3D graphics. <br><br>  <b>Further steps</b> <br><br>  At this stage, you already know how to use ShaderToy, and in addition you can apply any texture on any surface and on almost any platform.  So, we are ready to move to a more complex topic - setting up a lighting system with realistic shadows.  That is what we will do in the next lesson! </div><p>Source: <a href="https://habr.com/ru/post/281599/">https://habr.com/ru/post/281599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281589/index.html">A piece of space in a 3D case</a></li>
<li><a href="../281591/index.html">Development for copters</a></li>
<li><a href="../281593/index.html">v3.14.1592-beta2: everything you wanted to know about semantic versioning</a></li>
<li><a href="../281595/index.html">Reverse Engineering Visual Stories</a></li>
<li><a href="../281597/index.html">We write the Slack bot to get comments from VK in Python</a></li>
<li><a href="../281601/index.html">bash + logger application warrants</a></li>
<li><a href="../281603/index.html">Machine learning: what you need to know about creating strategies for trading on the exchange. Part IV</a></li>
<li><a href="../281605/index.html">RESTful Visual Editor</a></li>
<li><a href="../281607/index.html">Develop HTML5 games in Intel XDK. Part 4. The system of coordinates and moving objects</a></li>
<li><a href="../281609/index.html">Create 3D CSS effects on hover using jQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>