<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory capture / release speed in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I had such a task: you need to process the data file. The file is divided into sections with a length of about 1 MB, each of them contains approximate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory capture / release speed in C #</h1><div class="post__text post__text-html js-mediator-article">  I had such a task: you need to process the data file.  The file is divided into sections with a length of about 1 MB, each of them contains approximately 100000 records in packed form. The number of records can vary from section to section and is written in the header of each of them.  During processing the section is unpacked, and each record is converted into 20 integers.  For processing, you need to store the current unpacked section and several previous ones (about 5-10, but maybe more - it is not known in advance how many).  The question is how to allocate memory for unpacking sections. <br><br>  The project, within which it is necessary to solve the problem, is written in C # under VS 2008 (the use of inserts from other languages ‚Äã‚Äãis absolutely not welcome), the main system under which the finished program will work is Windows 7, 64 bit (at least for now).  And, as usual, you need to process faster. <br>  The first question that arises is whether it is necessary to organize a pool of arrays for unpacking, or it is possible to capture an array for each new section again.  The second question is what should be the structure of this array, what is better - work with linear arrays 8 MB in length, or break an array into smaller pieces and organize, for example, an array of arrays.  In the second case - what should be the length of these pieces. <br><a name="habracut"></a><br>  I took a few objects: <br><ul><li>  Array int [] [] of size M * N </li><li>  Array int [] of length N </li><li>  Homemade list of N items in length: <br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; }</code> </pre> </li><li>  List List &lt;int&gt; of N elements </li></ul><br>  The numbers M and N for the two-dimensional array were chosen so that M * N = 40000000 (which corresponds to the memory for 20 sections). <br>  For each object, the average time for creation + filling + reading was measured (after which the object was forgotten), and for control - time for filling + reading (the object was created only once).  Time was measured in nanoseconds per processed element of the object.  The measurement went on two times: when working on one processor core and when operating in parallel on 4 cores (in the second case, the time spent by 4 did not multiply, ie, the result, as a rule, should be less than in the case of a single core). <br><br>  The results look like this: <br><table><tbody><tr><td>  MxN </td><td>  8000x5000 </td><td>  2000x20000 </td><td>  1000x40000 </td><td>  100x400000 </td><td>  10x4000000 </td><td>  1x40000000 </td></tr><tr><td>  int [] [] </td><td>  8.34 / 7.30 </td><td>  8.34 / 7.02 </td><td>  4.08 / 2.69 </td><td>  3.76 / 2.55 </td><td>  3.62 / 2.58 </td><td>  3.63 / 2.78 </td></tr><tr><td>  int [] [], R + W </td><td>  2.57 / 1.60 </td><td>  2.64 / 1.60 </td><td>  2.22 / 1.04 </td><td>  2.20 / 1.00 </td><td>  2.18 / 1.00 </td><td>  2.09 / 1.03 </td></tr><tr><td>  int [], full </td><td>  1.94 / 1.04 </td><td>  1.85 / 0.96 </td><td>  3.4 / 1.58 </td><td>  3.44 / 2.69 </td><td>  3.60 / 3.63 </td><td>  3.60 / 2.78 </td></tr><tr><td>  int [], R + W </td><td>  1.58 / 0.46 </td><td>  1.56 / 0.47 </td><td>  1.56 / 0.47 </td><td>  1.57 / 0.63 </td><td>  1.83 / 0.93 </td><td>  2.00 / 1.05 </td></tr><tr><td>  list </td><td>  16.30 / 9.14 </td><td>  19.16 / 19.00 </td><td>  21.69 / 35.17 </td><td>  53.8 / 85.65 </td><td>  145/130 </td><td></td></tr><tr><td>  list, read </td><td>  2.32 / 0.60 </td><td>  2.29 / 0.61 </td><td>  2.31 / 1.12 </td><td>  6.4 / 2.58 </td><td>  7.2 / 3.67 </td><td></td></tr><tr><td>  List &lt;int&gt; </td><td>  8.95 / 4.21 </td><td>  11.06 / 4.74 </td><td>  11.98 / 5.03 </td><td>  11.85 / 6.38 </td><td>  11.85 / 6.98 </td><td>  13.71 / 8.10 </td></tr><tr><td>  List &lt;int&gt;, read </td><td>  2.95 / 0.88 </td><td>  2.96 / 0.92 </td><td>  2.96 / 0.92 </td><td>  2.96 / 0.92 </td><td>  3.13 / 1.05 </td><td>  4.13 / 1.65 </td></tr></tbody></table><br>  Each cell has two times for one and four cores. <br>  What can be learned from this plate?  First, it turns out that the time it takes to capture memory linearly depends on the length of the array: one linear array of 160 MB is captured 100 times longer than an array of 1.6 MB.  Secondly, if we want to capture one array for a short time, then short arrays have an advantage: their capture occupies 0.3ns / word, while the capture of long arrays is 1.8 ns / word (the difference between the 3rd and 4th lines).  This confirms the frequently cited assertion that objects with a length of less than 88 KB are taken from a separate, faster pool.  But if there are a lot of arrays, the picture becomes opposite: about 1.5 ns / word for long arrays, and 5.8 ns / word for short arrays - almost 4 times more!  So if you need a multidimensional array for a short time, then you should not make it stepped with short internal arrays, it is better to look for another option.  For example, capture a one-dimensional array and count indices. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, it is clear that my implementation of the list didn‚Äôt like the system at all: when its length approached a million, the time to create one element increased by about 6 times compared to short lists. <br><br>  The optimal for my task, apparently, would be the capture of long arrays (one per unpacked section) - if I want to capture arrays every time.  For a file with a length of 1600 sections (this is a typical size), the time loss would be 1.5 * 2 * 1.6 = 5 seconds.  True, now one of the processing options (without extra memory captures) takes only 11 seconds, but there is something to think about: other processing will be longer and more difficult.  It is possible that it will be necessary to continue to reuse memory wherever possible, and not to abuse dynamic memory.  But maybe not. </div><p>Source: <a href="https://habr.com/ru/post/137066/">https://habr.com/ru/post/137066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137060/index.html">Meet Goliath</a></li>
<li><a href="../137061/index.html">How to transcode latin1 to cyrillic</a></li>
<li><a href="../137062/index.html">Secure Payments with ActivateTo Codes (Part I)</a></li>
<li><a href="../137063/index.html">Two rules for a good iPhone app icon</a></li>
<li><a href="../137065/index.html">Multithreading in practice</a></li>
<li><a href="../137067/index.html">116 sites for promoting iPhone / iPad applications</a></li>
<li><a href="../137068/index.html">If there is no money left for marketing, or is there life in the valley of death?</a></li>
<li><a href="../137069/index.html">Practical bioinformatics</a></li>
<li><a href="../137070/index.html">Novice Project Manager - Design</a></li>
<li><a href="../137071/index.html">Malware JavaScript decryption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>