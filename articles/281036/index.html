<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explaining the inexplicable. Part 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The PG Day'16 conference is getting closer every day, and we continue to publish a series of articles by Hubert Lubaczewski on explain and its basic o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explaining the inexplicable. Part 4</h1><div class="post__text post__text-html js-mediator-article">  <i>The PG Day'16 conference is getting closer every day, and we continue to publish a series of articles by <a href="http://www.depesz.com/">Hubert Lubaczewski</a> on explain and its basic operations.</i> <br><br>  In this, I hope, the <a href="https://habrahabr.ru/post/275851/">penultimate</a> <a href="https://habrahabr.ru/post/276973/">post of the</a> <a href="https://habrahabr.ru/post/279255/">series,</a> I will discuss the remaining most common operations that you may encounter in the output of explain. <br><br><img src="https://habrastorage.org/files/89e/4b9/c11/89e4b9c11f4e4d45b0134edbd13a0db6.jpg"><br><a name="habracut"></a><br><h4>  <font color="#000000">Unique</font> </h4><br>  The name of the operation speaks for itself - it removes duplicate data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This can happen, for example, when you do the following: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> <span class="hljs-keyword"><span class="hljs-keyword">field</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span></code> </pre> <br>  In more recent versions of Postgres, this request will be implemented using HashAggregate. <br><br>  The Unique problem is that the data for it must be sorted.  Not because this operation needs data in a specific order, but in order for all rows with the same values ‚Äã‚Äãto be ‚Äútogether‚Äù. <br><br>  This makes Unique a really cool operation (in cases where it can be used), since it requires almost no memory.  It simply compares the value in the previous line with the current one and, if they are the same, discards it.  That's all. <br><br>  Thus, we can stimulate its use by sorting out the data: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------- Unique (cost=22.88..27.26 rows=4 width=1) -&gt; Sort (cost=22.88..23.61 rows=292 width=1) Sort Key: pg_class.relkind -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=1) (4 rows)</span></span></code> </pre><br><br><h4>  <font color="#000000">Append</font> </h4><br>  This plan simply runs a lot of sub-operations and returns all the rows returned by them as a common result. <br><br>  This is used by UNION / UNION ALL queries: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_proc <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_database; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------- Append (cost=0.00..104.43 rows=2943 width=4) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=4) -&gt; Seq Scan on pg_proc (cost=0.00..92.49 rows=2649 width=4) -&gt; Seq Scan on pg_database (cost=0.00..1.02 rows=2 width=4) (4 rows)</span></span></code> </pre><br>  Here you see how append ran three scans on three tables and returned all rows together. <br><br>  Please note that I used UNION ALL.  If I used UNION, we would get the following: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_proc <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_database; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------- HashAggregate (cost=141.22..170.65 rows=2943 width=4) -&gt; Append (cost=0.00..133.86 rows=2943 width=4) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=4) -&gt; Seq Scan on pg_proc (cost=0.00..92.49 rows=2649 width=4) -&gt; Seq Scan on pg_database (cost=0.00..1.02 rows=2 width=4) (5 rows)</span></span></code> </pre><br>  This happens because UNION removes duplicate strings, which in this case was produced by the HashAggregate operation. <br><br><h4>  <font color="#000000">Result</font> </h4><br>  Result appears mainly in very simple test queries.  This operation is used when your query selects a fixed value (or values): <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------ Result (cost=0.00..0.01 rows=1 width=0) (1 row)</span></span></code> </pre><br>  In addition to test queries, it can be found in queries that do something like ‚Äúinsert, but only if it is not duplication of data‚Äù: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (i) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------- Insert on t (cost=3.33..3.35 rows=1 width=4) -&gt; Result (cost=3.33..3.34 rows=1 width=0) One-Time Filter: (NOT $0) InitPlan 1 (returns $0) -&gt; Seq Scan on t t_1 (cost=0.00..40.00 rows=12 width=0) Filter: (i = 1) (6 rows)</span></span></code> </pre><br><h4>  <font color="#000000">Values ‚Äã‚Äãscan</font> </h4><br>  Just like Result, Values ‚Äã‚ÄãScan is used to return simple data entered in the request, but in this case it can be a whole set of records based on the functionality of VALUES (). <br><br>  If all of a sudden you don‚Äôt know, you can select multiple rows and many columns without any table, simply using the VALUES syntax, as in this example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hubert'</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'lubaczewski'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t (a,b); a | b <span class="hljs-comment"><span class="hljs-comment">---+------------- 1 | hubert 2 | depesz 3 | lubaczewski (3 rows)</span></span></code> </pre><br>  The plan for such a request is as follows: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------- Values Scan on "*VALUES*" (cost=0.00..0.04 rows=3 width=36) (1 row)</span></span></code> </pre><br>  This operation is commonly used in INSERTs, but it has other uses, such as <a href="http://www.depesz.com/2010/07/25/how-to-order-by-some-random-query-defined-values/">custom sorting</a> . <br><br><h4>  <font color="#000000">GroupAggregate</font> </h4><br>  This operation is similar to HashAggregate, which we <a href="https://habrahabr.ru/post/279255/">talked about earlier</a> . <br><br>  The difference is that in order for GroupAggregate to work, the data must be sorted using the column or columns you used in the GROUP BY clause. <br><br>  Like Unique, GroupAggregate uses very little memory, but requires data ordering. <br><br>  Example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind) x <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------- GroupAggregate (cost=22.88..28.03 rows=4 width=1) -&gt; Sort (cost=22.88..23.61 rows=292 width=1) Sort Key: pg_class.relkind -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=1) (4 rows)</span></span></code> </pre><br><h4>  <font color="#000000">HashSetOp</font> </h4><br>  This operation is used by INTERSECT / EXCEPT operations (with the optional modifier "ALL"). <br><br>  It works as follows: it starts the Append sub-operations for a pair of subqueries, and then, based on the result and the optional ALL modifier, decides which rows to return.  I did not go deep into the source code, so I can‚Äôt say exactly how it works, but, based on their name, the operation is similar to a simple solution based on a counter. <br><br>  We see that, unlike UNION, these operations work with two data sources: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) x <span class="hljs-keyword"><span class="hljs-keyword">intersect</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_proc <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) y; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------- HashSetOp Intersect All (cost=0.15..170.72 rows=292 width=4) -&gt; Append (cost=0.15..163.36 rows=2941 width=4) -&gt; Subquery Scan on "*SELECT* 1" (cost=0.15..18.37 rows=292 width=4) -&gt; Index Only Scan using pg_class_oid_index on pg_class (cost=0.15..12.53 rows=292 width=4) -&gt; Subquery Scan on "*SELECT* 2" (cost=0.28..145.00 rows=2649 width=4) -&gt; Index Only Scan using pg_proc_oid_index on pg_proc (cost=0.28..92.02 rows=2649 width=4) (6 rows)</span></span></code> </pre><br>  And with three sources we will have a more complex tree: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) x <span class="hljs-keyword"><span class="hljs-keyword">intersect</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_proc <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) y <span class="hljs-keyword"><span class="hljs-keyword">intersect</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> w; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------- HashSetOp Intersect All (cost=1.03..172.53 rows=2 width=4) -&gt; Append (cost=1.03..171.79 rows=294 width=4) -&gt; Subquery Scan on "*SELECT* 3" (cost=1.03..1.07 rows=2 width=4) -&gt; Sort (cost=1.03..1.03 rows=2 width=4) Sort Key: pg_database.oid -&gt; Seq Scan on pg_database (cost=0.00..1.02 rows=2 width=4) -&gt; Result (cost=0.15..170.72 rows=292 width=4) -&gt; HashSetOp Intersect All (cost=0.15..170.72 rows=292 width=4) -&gt; Append (cost=0.15..163.36 rows=2941 width=4) -&gt; Subquery Scan on "*SELECT* 1" (cost=0.15..18.37 rows=292 width=4) -&gt; Index Only Scan using pg_class_oid_index on pg_class (cost=0.15..12.53 rows=292 width=4) -&gt; Subquery Scan on "*SELECT* 2" (cost=0.28..145.00 rows=2649 width=4) -&gt; Index Only Scan using pg_proc_oid_index on pg_proc (cost=0.28..92.02 rows=2649 width=4) (13 rows)</span></span></code> </pre><br><h4>  <font color="#000000">CTE Scan</font> </h4><br>  This operation is similar to the Materialize operation <a href="https://habrahabr.ru/post/279255/">already mentioned</a> .  It runs part of the request and stores its output so that it can be used by another part (or parts) of the request. <br><br>  Example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relname, relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*), (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> x) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------- HashAggregate (cost=24.80..26.80 rows=200 width=1) (actual time=0.466..0.468 rows=6 loops=1) CTE x -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=65) (actual time=0.009..0.127 rows=295 loops=1) InitPlan 2 (returns $1) -&gt; Aggregate (cost=6.57..6.58 rows=1 width=0) (actual time=0.085..0.085 rows=1 loops=1) -&gt; CTE Scan on x x_1 (cost=0.00..5.84 rows=292 width=0) (actual time=0.000..0.055 rows=295 loops=1) -&gt; CTE Scan on x (cost=0.00..5.84 rows=292 width=1) (actual time=0.012..0.277 rows=295 loops=1) Total runtime: 0.524 ms (8 rows)</span></span></code> </pre><br>  Note that pg_class is scanned only once - line # 6.  But its results are stored in ‚Äúx" and then scanned twice - inside the aggregate (line # 9) and with the operation HashAggregate (10). <br><br>  What is the difference from Materialize?  To give a detailed answer to this question, you need to dive into the source code, but I would say that the difference is based on the simple fact that the CTE is user-defined, while Materialize is an auxiliary operation that Postgres decides to use when it sees fit. . <br><br>  Important note: CTEs always run exactly as indicated.  Therefore, they can be used to circumvent not the most successful optimizations that the scheduler can implement. <br><br><h4>  <font color="#000000">Initplan</font> </h4><br>  This plan happens every time there is a part of the request that can (or should) be calculated before the rest and does not depend on anything in the rest of your request. <br><br>  Suppose you want this query: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relkind = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random() <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------ Seq Scan on pg_class (cost=13.11..24.76 rows=73 width=203) Filter: (relkind = $0) InitPlan 1 (returns $0) -&gt; Limit (cost=13.11..13.11 rows=1 width=1) -&gt; Sort (cost=13.11..13.84 rows=292 width=1) Sort Key: (random()) -&gt; Seq Scan on pg_class pg_class_1 (cost=0.00..11.65 rows=292 width=1) (7 rows)</span></span></code> </pre><br>  In this case, you must run limit / sort / seq-scan before the usual sequential scan on pg_class, because Postgres will need to compare the value of the relkind with the value returned by the subquery. <br><br>  On the other hand, I could write: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> *, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(<span class="hljs-string"><span class="hljs-string">'depesz'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- Seq Scan on pg_class (cost=0.01..10.93 rows=292 width=203) InitPlan 1 (returns $0) -&gt; Result (cost=0.00..0.01 rows=1 width=0) (3 rows)</span></span></code> </pre><br>  Postgres correctly sees that the subselect column does not depend on any data from the pg_class table, so it can be run once and there is no need to recalculate the length for each row. <br><br>  Of course, you can have a lot of single plans (init plans), like this: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> *, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(<span class="hljs-string"><span class="hljs-string">'depesz'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relkind = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random() <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------ Seq Scan on pg_class (cost=13.12..24.77 rows=73 width=203) Filter: (relkind = $1) InitPlan 1 (returns $0) -&gt; Result (cost=0.00..0.01 rows=1 width=0) InitPlan 2 (returns $1) -&gt; Limit (cost=13.11..13.11 rows=1 width=1) -&gt; Sort (cost=13.11..13.84 rows=292 width=1) Sort Key: (random()) -&gt; Seq Scan on pg_class pg_class_1 (cost=0.00..11.65 rows=292 width=1) (9 rows)</span></span></code> </pre><br>  But it is necessary to take into account one detail - init planes within one request are numbered ‚Äúglobally‚Äù, and not by operations. <br><br><h4>  <font color="#000000">Subplan</font> </h4><br>  SubPlans are somewhat similar to NestedLoop.  In the sense that they can also be called many times. <br><br>  SubPlan is called to calculate data from a subquery that actually depends on the current row. <br><br>  For example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.relname, c.relkind, (<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class x <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.relkind = x.relkind) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class c; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------- Seq Scan on pg_class c (cost=0.00..3468.93 rows=292 width=65) (actual time=0.135..26.717 rows=295 loops=1) SubPlan 1 -&gt; Aggregate (cost=11.83..11.84 rows=1 width=0) (actual time=0.090..0.090 rows=1 loops=295) -&gt; Seq Scan on pg_class x (cost=0.00..11.65 rows=73 width=0) (actual time=0.010..0.081 rows=93 loops=295) Filter: (c.relkind = relkind) Rows Removed by Filter: 202 Total runtime: 26.783 ms (7 rows)</span></span></code> </pre><br>  For each row returned by scanning for ‚Äúpg_class as c‚Äù, Postgres should launch SubPlan, which checks how many rows in pg_class have the same (as for the just processed row) value in the relkind column. <br><br>  Note the ‚Äúloops = 295‚Äù in the ‚ÄúSeq Scan on pg_class x‚Äù line and the corresponding value of ‚Äúrows = 295‚Äù in the ‚ÄúSeq Scan on pg_class c‚Äù node. <br><br><h4>  <font color="#000000">Others?</font> </h4><br>  Yes, there are other operations.  Some of them are too rare to get our attention (especially if you consider that you have an excellent source of knowledge - the source code), and some are (I suspect) old versions of new nodes. <br><br>  If you have a plan with an operation about which I didn‚Äôt talk, and you don‚Äôt understand it, please write to me, in the comments, the link to explain on <a href="http://explain.depesz.com/">explain.depesz.com</a> , the name of the operation and the version of the Post in which you met it.  I will try to find all possible information on such cases and give you a detailed answer. </div><p>Source: <a href="https://habr.com/ru/post/281036/">https://habr.com/ru/post/281036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281024/index.html">How we implemented DevOps: continuous integration with GitHub and the Visual Studio Team Services build system</a></li>
<li><a href="../281026/index.html">Java 8 lambdas are closures?</a></li>
<li><a href="../281028/index.html">Azure-IaaS-Digest number 4 (March-April)</a></li>
<li><a href="../281032/index.html">ServerSide section on DUMP-2016</a></li>
<li><a href="../281034/index.html">Zenity in the service of a system administrator</a></li>
<li><a href="../281038/index.html">Intel RealSense Smartphone Developer Kit: Details</a></li>
<li><a href="../281040/index.html">Python production calendar</a></li>
<li><a href="../281042/index.html">Hacking Team deprived of the license to export their cyber services</a></li>
<li><a href="../281044/index.html">Plugin for Redmine: redmine_chat_telegram</a></li>
<li><a href="../281046/index.html">Upsource 3.0 with PHP support, GitHub pull requests and more</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>