<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>F #: What your code turns into after compilation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The F # language appeared in the standard delivery of VisualStudio quite recently, namely from the 2010 version (at the moment, the actual one). Natur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>F #: What your code turns into after compilation</h1><div class="post__text post__text-html js-mediator-article">  The F # language appeared in the standard delivery of VisualStudio quite recently, namely from the 2010 version (at the moment, the actual one).  Naturally, everyone knows this very well, the language functions on the basis of the CLR - all your code will be compiled in MS IL like any other language in the .NET family. <br><br>  Let's take a look at the frequently used and useful ‚Äúmemorialization‚Äù technique and look into what makes your code a compiler.  For clarity, I will write the code in F # and decompile it in C #. <br><a name="habracut"></a><br>  So, the original example: <br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> memoize f = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = System.Collections.Generic.Dictionary() fun x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cache.ContainsKey(x) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cache.[x] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = fx cache.[x] &lt;- res res <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec memoizedFactorial = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> factorial x = match x <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | a when a = <span class="hljs-number"><span class="hljs-number">0</span></span>I -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>I | x -&gt; x * memoizedFactorial (x - <span class="hljs-number"><span class="hljs-number">1</span></span>I) memoize factorial <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">now</span></span> = System.DateTime.<span class="hljs-built_in"><span class="hljs-built_in">Now</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arguments = [<span class="hljs-number"><span class="hljs-number">10000</span></span>I .. <span class="hljs-number"><span class="hljs-number">10100</span></span>I] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> factorials = arguments |&gt; List.map memoizedFactorial <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeDiff = System.DateTime.<span class="hljs-built_in"><span class="hljs-built_in">Now</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">now</span></span> printfn <span class="hljs-string"><span class="hljs-string">"Time: %A"</span></span> timeDiff</code> </pre> <br><br>  A few explanations: <br><ul><li>  We will consider 101 factorial from 10,000 to 10,100. In order to be a little longer. </li><li>  We notice the execution time of our calculation. </li><li>  Since there is no built-in memorial in F #, we use a self-made one.  It takes as an argument any function, initializes the cache and creates a lambda expression, which is used to check the existence of an element in the cache, call this function if there is no element, and add the element to the cache. </li><li>  For clarity, I created a separate memoizedFactorial function.  The effect is based on the fact that we define the <code>memoizedFactorial</code> function without arguments, and as a result we return another function, to which we later will pass arguments.  Thus, it turns out that <code>memoizedFactorial</code> exists in a single instance as an object and our cache will be the same for multiple function calls. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's now see what led the memorial. <br>  Program execution time without memorization is 28.97 s, and with memorialization 0.89 s.  As they say, the effect is obvious. <br><br>  We look at what all this compiles.  The most interesting point for a C # programmer is of course the moment that the <code>memoizedFactorial</code> function is <code>memoizedFactorial</code> .  Why is the local function cache not recreated? <br>  Let's watch. <br><br>  <code>main</code> function: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>@() { <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoizedFactorial</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">11</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">1</span></span> = LazyExtensions.Create&lt;FSharpFunc&lt;BigInteger, BigInteger&gt;&gt;(new Program.clo@<span class="hljs-number"><span class="hljs-number">11</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>()); <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoizedFactorial</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">11</span></span> = Program.memoizedFactorial@<span class="hljs-number"><span class="hljs-number">11</span></span>.get_Value(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">now</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">18</span></span> = DateTime.Now; <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">20</span></span> = SeqModule.ToList&lt;BigInteger&gt;(new Program.arguments@<span class="hljs-number"><span class="hljs-number">20</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, new BigInteger())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">factorials</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">21</span></span> = ListModule.Map&lt;BigInteger, BigInteger&gt;(Program.memoizedFactorial, Program.arguments); <span class="hljs-selector-tag"><span class="hljs-selector-tag">timeDiff</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">23</span></span> = (TimeSpan) (DateTime.Now - Program.now); <span class="hljs-selector-tag"><span class="hljs-selector-tag">fp</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">1</span></span> = new PrintfFormat&lt;FSharpFunc&lt;TimeSpan, Unit&gt;, TextWriter, Unit, Unit, TimeSpan&gt;(<span class="hljs-string"><span class="hljs-string">"Time: %A"</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">PrintfModule</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.PrintFormatLineToTextWriter</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">FSharpFunc</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeSpan</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Unit</span></span>&gt;&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Out</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fp</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">1</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">Invoke</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Program</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">timeDiff</span></span>); }</code> </pre><br><br>  Hmm ... the <code>memoizedFactorial</code> function <code>memoizedFactorial</code> become a separate object.  In addition, there are no variables at all - they all became fields of the class <code>internal static class $Program</code> .  In general, up to specific classes, the code should be clear.  <code>memoizedFactorial</code> into the <code>memoizedFactorial</code> . <br><br>  For a start, we have two fields of the <code>$Program</code> class: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">internal</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">FSharpFunc</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">BigInteger</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BigInteger</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoizedFactorial</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">11</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">internal</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">FSharpFunc</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">BigInteger</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BigInteger</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoizedFactorial</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">11</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">1</span></span>;</code> </pre><br><br>  It is seen that the second is initialized by an object of the standard class to which the closure is passed.  The first field does nothing interesting, it just returns itself ( <code>get_Value</code> method). <br><br>  So, looking closure: <br><pre> <code class="hljs ruby">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clo</span></span></span><span class="hljs-class">@11-1 : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSharpFunc</span></span></span><span class="hljs-class">&lt;Unit, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSharpFunc</span></span></span><span class="hljs-class">&lt;BigInteger, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigInteger</span></span></span><span class="hljs-class">&gt;&gt; { // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Methods</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clo</span></span></span><span class="hljs-class">@11-1();</span></span> public override FSharpFunc&lt;BigInteger, BigInteger&gt; Invoke(Unit arg0<span class="hljs-number"><span class="hljs-number">0</span></span>@); }</code> </pre><br><br>  We understand that this is a class that has an interesting method: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> FSharpFunc&lt;BigInteger, BigInteger&gt; Invoke(<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-symbol"><span class="hljs-symbol">arg00@</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Program.<span class="hljs-symbol"><span class="hljs-symbol">memoizedFactorial@</span></span><span class="hljs-number"><span class="hljs-number">11</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>(); }</code> </pre><br><br>  Hm  Looks like they came where they were.  But it is not.  This returns the result of calling the <code>memoizedFactorial@11-1</code> function.  Finally, we are looking at this function: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> static FSharpFunc&lt;BigInteger, BigInteger&gt; <span class="hljs-symbol"><span class="hljs-symbol">memoizedFactorial@</span></span><span class="hljs-number"><span class="hljs-number">11</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize&lt;BigInteger, BigInteger&gt;(new <span class="hljs-symbol"><span class="hljs-symbol">clo@</span></span><span class="hljs-number"><span class="hljs-number">13</span></span>()); }</code> </pre><br><br>  Here!  Finally we got to the <code>memoize</code> function.  And before one more short circuit.  A closure is a descendant of the same class; we immediately look at the Invoke method: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> BigInteger Invoke(BigInteger x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LanguagePrimitives.HashCompare.GenericEqualityIntrinsic&lt;BigInteger&gt;(x, BigInteger.Zero)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.One; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x * Program.<span class="hljs-symbol"><span class="hljs-symbol">memoizedFactorial@</span></span><span class="hljs-number"><span class="hljs-number">11</span></span>.get_Value().Invoke(x - BigInteger.One)); }</code> </pre><br><br>  Here it is our factorial!  We found a function that directly calculates the value.  Note that the recursion uses the memorized version, as we wrote in the F # code.  The comparison with the template was converted to a regular <code>if</code> .  We also note in passing that two <code>BigInteger</code> compared through their hashes. <br><br>  Let's go back a step and see the <code>memoize</code> function: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FSharpFunc&lt;a, b&gt; memoize&lt;a, b&gt;(FSharpFunc&lt;a, b&gt; f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> memoize@<span class="hljs-number"><span class="hljs-number">3</span></span>&lt;a, b&gt;(f, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;a, b&gt;()); }</code> </pre><br><br>  Here, the fun began.  As a result of the work, the object is returned to the constructor's parameters of which our closure (the first argument) and the dictionary (the second argument) are passed.  Now I understand why the dictionary is not recreated every time. <br><br>  Deepen: <br><pre> <code class="hljs ruby">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memoize</span></span></span><span class="hljs-class">@3&lt;a, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSharpFunc</span></span></span><span class="hljs-class">&lt;a, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">&gt; { // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fields</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dictionary</span></span></span><span class="hljs-class">&lt;a, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cache</span></span></span><span class="hljs-class">;</span></span> public FSharpFunc&lt;a, b&gt; f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Methods internal memoize@3(FSharpFunc&lt;a, b&gt; f, Dictionary&lt;a, b&gt; cache); public override b Invoke(ax); }</code> </pre><br><br>  The class fields once again show why the cache is one for the entire program.  See the function <code>Invoke</code> : <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> b Invoke(ax) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache.ContainsKey(x)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[x]; } b res = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f.Invoke(x); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[x] = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br><br>  And here is our memorial function!  The key is passed through the argument.  The closure of <code>f</code> we already know through the fields of the object.  The secret is solved. <br><br>  Thus, in F # there is no magic.  Well, absolutely.  All of these currying (and the <code>memoizedFactorial</code> function <code>memoizedFactorial</code> what it is), functions like first-class citizens are actually just automatically generated classes and objects.  I hope that my article will help someone better understand how F # works inside. </div><p>Source: <a href="https://habr.com/ru/post/115727/">https://habr.com/ru/post/115727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115720/index.html">WIND Mobile will be bought by Russian company VimpelCom</a></li>
<li><a href="../115722/index.html">Message from discussion "Firefox 4 has gone, will be released by March 22" in mozilla.dev.planning</a></li>
<li><a href="../115723/index.html">Live broadcast from the conference on the development of applications. 8-00 Moscow time</a></li>
<li><a href="../115725/index.html">PaaS "all in one"</a></li>
<li><a href="../115726/index.html">Experience contacting Sony support</a></li>
<li><a href="../115728/index.html">Internet Explorer 9 launched in Russia with Mail.Ru, Yandex and a new game.</a></li>
<li><a href="../115729/index.html">Effective presentation skills</a></li>
<li><a href="../115730/index.html">Windows: the ability to end the session if the screen is locked</a></li>
<li><a href="../115731/index.html">100 thousand visits per day (debriefing and new experiment)</a></li>
<li><a href="../115738/index.html">What is website design and why should it be done?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>