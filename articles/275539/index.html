<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why is HTTPS not commonly used yet?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Encryption. We all love him and want to use it everywhere. But why is it still not universally applied? 

 Problem in certificates? 
 The first and mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why is HTTPS not commonly used yet?</h1><div class="post__text post__text-html js-mediator-article">  Encryption.  We all love him and want to use it everywhere.  But why is it still not universally applied? <br><br><h4>  Problem in certificates? </h4><br>  The first and most common barrier to the transition to HTTPS is the price of obtaining, configuring and maintaining a valid certificate.  You must find a supplier of certificates, confirm your identity, pay for it and set up a server, as well as renew it in a timely manner. <br><br>  Most of the proposals for the transition to ubiquitous encryption sound like this: "The NSA records all our traffic, why not encrypt it?".  The purpose of such proposals is to increase the cost of passive tracking of all traffic, rather than more complex and targeted attacks that are used by attackers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The guys from Let's Encrypt have already guessed that the problem with certificates is almost completely automated, and that its implementation for release, installation, configuration and renewal on several of the most common platforms can cover the vast majority of the Internet.  A wonderful job, and, although much remains to be done, I think we can consider the problem of certificates solved. <br><a name="habracut"></a><br><h4>  Now we have a certificate, we can enable HTTPS, right? </h4><br>  Well, maybe.  But maybe not.  If all the HTML resources you provide have links (images, scripts ...) to the same host and you use only relative URLs, then everything is fine.  Otherwise, most likely HTTPS will not work correctly. <br><br>  <i>What?</i>  <i>HTTPS - it's good, why did it break?</i> <br><br>  Everything broke because almost certainly you have mixed content on your page. <br><br><h4>  What is mixed content and why should I care? </h4><br>  Consider the following case when you are the ‚ÄúOriginA‚Äù operator.  Do green circles mean resources available via http and https?  red - only http.  Dotted lines are content uploading via http.  The usual lines are https.  Suppose that all links are absolute.  A red cross indicates that the download will fail. <br><br><img src="https://habrastorage.org/files/1b3/121/cd9/1b3121cd9a2f4adf989f0c58bee36ef8.png"><br><br>  Now let's say you configured the certificate and enabled https on OriginA.  What will the chart look like now? <br><br><img src="https://habrastorage.org/files/b38/e3b/152/b38e3b15202049ecbfca472e2dbd9f98.png"><br><br>  If you do not update the absolute links in HTML, the browser will still try to get resources via http.  Most prohibit such downloads and show warnings in such cases, and over time they become only more severe. <br><br><h4>  Why do browsers block mixed content?  Why can't I influence this as a site owner? </h4><br>  In most web security models, the sources are responsible for their own information.  Content downloaded via HTTPS can redirect the user to an insecure site, send a POST request or postMessage () to an unsafe source, and the https site can receive GET, POST or onMessage () from documents downloaded via http.  With all this, why is POST allowed, but XHR prohibited? <br><br>  There is a formal security rule that browsers try to apply to sites.  For the first time, this rule was formulated as ‚ÄúTranquility‚Äù.  In simple terms, this means that a secure document will not become unsafe during an interaction. <br><br>  Of all the complications and traps of Web security, browsers have come to the conclusion that there is only one more or less reliable and useful security indicator: an address bar and a lock for using HTTPS.  If you type "https: //" in the address bar or see the lock icon of the document with which you interact, the browser promises you that the content is protected from outside threats. <br><br>  If the https site had uploaded a script or image via http, this promise would have been broken.  The specific consequences of such an action can vary greatly, but the browser does not have the right to deal with it, so it simply stops such behavior.  This was done not only to protect users who could not figure it out, for example by opening a browser client in the browser, requesting a script via http, in a coffee shop, but also as an indicator for content authors who might have missed something. <br><br>  This is a good solution for users, but it gives site operators some difficulties when translating sites to https.  All of their HTML resources that link to unsafe content break down or scare users with warnings.  This problem with dependencies, I believe, is a real obstacle that needs to be overcome to convert 100% of resources to HTTPS. <br><br><h4>  We mix mixed content </h4><br>  If you need to fix a problem with mixed content, then the cost of switching to https is somewhat higher.  It is a bit more complicated than server configuration or obtaining a certificate; deleting mixed content is expensive and not always automated. <br><br>  For a complex site, you cannot simply run s / http / https / g on all pages, or write a rule in mod_rewrite.  You may encounter http resources in many places: static content, dynamic, client, stored in the database, receiving data from third-party resources, and so on. <br><br>  New <a href="http://www.w3.org/TR/upgrade-insecure-requests/">specifications</a> in development are aimed at facilitating this process;  they help to automatically replace http resources with https. <br><br>  Before: <br><br><img src="https://habrastorage.org/files/d4c/201/c90/d4c201c908324ed0aec0aa2737c2a989.png"><br><br>  After: <br><br><img src="https://habrastorage.org/files/83f/f8d/a57/83ff8da574a34f888b70efaad6bfeb12.png"><br><br>  Upgrade-Insecure-Resources helped with the AccessA Access in this example.  One of the HTML resources no longer contains mixed content because the protocols were quietly replaced and remote dependencies became available via https.  This example shows why many sites reluctantly provide their own content via https, in order to avoid frightening error messages and defects in functionality. <br><br>  This leads to the sad circumstance that the least responsible participants at the end of the chain of dependencies can hinder progress.  Cyclic dependencies (since they definitely exist in the huge structure of the web) can create interlocks that cannot be resolved without coordination. <br><br><h4>  None of these sites can enable https </h4><br><br><img src="https://habrastorage.org/files/b9c/068/c41/b9c068c41f9849908b79b537be632434.png"><br><br><h4>  Eliminate cyclic dependencies </h4><br>  There is a lack of an intermediate state between http and https.  It would be ideal if this condition had the following properties: <br>  1. Allow safe sources that depend on your resources to receive them without violating the principle of tranquility. <br>  2. It would not force other resources to make hasty conclusions about security or the absence of mixed content. <br>  3. It would be extremely cheap and not creating any risks for implementation.  Ideally, add an http header. <br>  4. It would allow to determine dependencies that violate the principle of tranquility or create errors of mixed content. <br><br><img src="https://habrastorage.org/files/ede/25b/378/ede25b3787fd4b30b4fc8f145f64d989.png"><br><br>  OriginB goes into "https-transitional" mode.  This means that the resource is still not available at https: //, but will be available in the future through TLS with full guarantees, including a valid certificate.  This should not cost anything to OriginB, since the browser and users do not know anything about the security status of this resource. <br><br>  Now OriginB resources are available through the "https-transitional".  OriginA includes HTTPS.  The browser knows that it can initiate a TLS connection to the OriginB and request resources via the traditional http protocol.  If this protocol change fails, the resource will be marked as unsafe and a warning about mixed content will appear.  If everything ends successfully, all guarantees about the safety of OriginA declared by the browser will be true, warnings about mixed content will not appear, despite the fact that the file was transmitted via http. <br><br>  After updating, OriginA may also update Origin.  OriginB is still dependent on OriginD, so it cannot yet go to https, but including the ‚Äútransit‚Äù mode, it allows resources A and B to access resources via https. <br><br><h4>  How can we create this state? </h4><br>  To resolve circular dependencies without creating documents with mixed content, you need to configure a filter that returns 404 to all requests, except those for which you can return Content-Type text / html.  Pretty good solution, excluding some CORS-related cases.  Of the four properties we need, this approach implements three. <br><br>  The fourth property is the ability to determine the states of your dependencies in order to know the moment when you can enable full HTTPS.  What if browsers could use Content-Security-Policy-Report-Only with ‚Äúupgrade-insecure-requests‚Äù for http documents? <br><ol><li>  We try to change the protocol </li><li>  In case of failure: Rollback on http, message to the administrator </li></ol><br>  It is possible that you do not need to do anything other than the above steps.  This configuration, with upgrade-insecure-requests, implemented for A, B, and C: <br><br><img src="https://habrastorage.org/files/0b3/4fa/749/0b34fa749ca446a3b823c29ab2ac1117.png"><br><br><h4>  iframe </h4><br>  Unfortunately, simply switching to html html resources via https is not enough, it does not work with HTML dependencies to HTML via iframe.  It is quite often used. <br><br><img src="https://habrastorage.org/files/0a6/17f/25f/0a617f25f98944b49f17d8fb0afadd27.png"><br><br>  It is necessary to implement the ability to download the HTML resource by replacing the protocol with TLS, but only on a secure page.  This does not violate security because without the substitution of the protocol the content would already be unsafe, so we do not create mixed content for users of OriginB. <br><br><h4>  https-transitional with ALPN and HTTP Alt-Svc </h4><br>  ALPN allows the client to communicate with the server via TLS by specifying another protocol that the client would like to use. <br><br>  Let's introduce a new type of ALPN protocol: ‚Äúhttps-transitional‚Äù.  The server from which the client requests data in this way understands it as: ‚Äúconnect me to the server via http, but via TLS, not via https‚Äù.  As described in the HTTP Alt-Svc draft, a TLS connection should occur, the server should present a certificate suitable for the domain. <br><br>  The resource opened through the ‚Äúhttps-transitional‚Äù will have the following properties: <br><ul><li>  The resource should not be locked as mixed content. </li><li>  Document settings transmitted via the ‚Äúhttps-transitional‚Äù should not prohibit mixed content. </li><li>  The previous properties are executed until the parent frame of the document prohibits;  in this case, the upgrade-insecure-requests should automatically occur </li></ul><br><br>  Upgrade-Insecure-Requests will be modified as follows: <br><br><ul><li>  In the case of protocol substitution for a dependent resource, we connect to https, add a new ‚Äúhttps-transitional‚Äù ALPN protocol as preferred, in addition to http / spdy / h2. </li><li>  If the server understands the "https-transitional", respond to this protocol and deliver the http resource via TLS. </li><li>  If the server does not understand ‚Äúhttps-transitional‚Äù - reply by https. </li></ul><br><br>  The blocking of mixed content must also be modified.  Browsers are not currently trying to automatically replace http with https, since there is no guarantee that both schemes provide the same content.  The https-transitional scheme provides such a guarantee.  A servet can also report on the availability of a transit mode using the HTTP Alt-Svc header. <br><br>  After downloading the document in transit mode, the browser should try to replace all connections blocked as mixed content, as if upgrade-insecure-requests were enabled, but also should seamlessly download content via https if the previous attempt fails.  It should also output an error to the console. <br><br><img src="https://habrastorage.org/files/4d8/1c6/742/4d81c6742abc49feace355bd59d7b74d.png"><br><br>  The diagram above demonstrates the implementation of the above rules.  Resources downloaded from OriginA, whose iframe points to OriginB will never contain mixed content, because OriginB supports transit mode.  However, if OriginB resources are loaded from a document that blocks mixed content and depends on resources for which protocol replacement is not possible (for example, a JS file with OriginD), such requests will be silently blocked.  Partial failure is preferable to complete.  Resources downloaded directly from OriginB, which depend on the same on OriginD, will not be blocked, since the tranquility principle is not required. <br><br><h4>  Performance impact </h4><br>  For https resources, this offer should not create any new delays compared to using Upgrade-Insecure-Requests.  Browsers will prefer TLS, so no new requests will be required to determine support for https-transitional. <br><br>  The only place that can lose in performance is to replace the connection due to the Alt-Svc header.  The browser will attempt to recursively update all dependent resources, some of which may be unavailable via https, which can create long delays.  They can also fix this by remembering that TLS was unavailable for a certain source for a certain amount of time, or else parallelize requests.  Perhaps some experiments are needed to determine the best strategy. <br><br>  At some point, all sites will want to leave http.  Downloading via https never rolls back to http, but the above script is not enough to protect against hackers who use attacks to remove encryption.  How can we go from a transit web to a completely secure web, especially if the existence of the first means avoiding the need to change the query scheme for each link on the site? <br><br>  We can begin to develop patterns based on HTTP Strict Transport Security, which was created to solve the problems of sites that want to completely abandon the http and Alt-Svc header. <br><br>  The first thing an administrator can do is to install Alt-Svc in infinite, which will be a signal for browsers not to try to connect via http, use only https-transitional and https, always.  After that, the site can leave http support for legacy clients, or turn it off completely. <br><br>  The next step is to apply the principle tranquility for transit content.  Perhaps the best way to do this is the HTTP header.  Setting the tranquil bit will mean banning mixed content.  This may also allow this resource to get the lock icon, or to cause similar changes in the interface. <br><br>  One day, if transit mode propagation is sufficient, browsers will be able to start dropping http.  Perhaps the beginning will be the appearance of the item in the settings, then showing a big warning.  Many sites are likely to remain in transit for an unlimited time, but users will still benefit from using TLS. </div><p>Source: <a href="https://habr.com/ru/post/275539/">https://habr.com/ru/post/275539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275525/index.html">Corporate Laboratories 2016 - practical training in the field of information security</a></li>
<li><a href="../275527/index.html">What should we build the Zhegalkin polynomial ...</a></li>
<li><a href="../275529/index.html">NEMA Encryption Machine</a></li>
<li><a href="../275531/index.html">Translation of "Simplified JavaScript Jargon"</a></li>
<li><a href="../275535/index.html">Monitoring uninterruptible power supply ippon winner 3000 using apcupsd + Zabbix in Ubuntu</a></li>
<li><a href="../275541/index.html">2 ^ 74207281-1 - a prime number</a></li>
<li><a href="../275545/index.html">New interface for getting process attributes in Linux</a></li>
<li><a href="../275547/index.html">Some interesting and useful for all</a></li>
<li><a href="../275549/index.html">Whitelisting with Windows Firewall</a></li>
<li><a href="../275551/index.html">Watchdog timer for 4G-modem on CentOS 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>