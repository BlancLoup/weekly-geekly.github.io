<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional image processing in D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I completed the reworking of a graphics package for my D library. Inspired by the std.algorithm and std.range modules , I tried to achieve t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional image processing in D</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/95e/84f/d1d/95e84fd1dfcaf235e8d9fa3e5c771ea9.png" alt="image" align="right" width="300" height="300"><br><br>  Recently, I completed the reworking of a <a href="https://github.com/CyberShadow/ae/tree/master/utils/graphics">graphics package</a> for my D library.  Inspired by the <a href="http://dlang.org/phobos/std_algorithm.html">std.algorithm</a> and <a href="http://dlang.org/phobos/std_range.html">std.range modules</a> , I tried to achieve the following goals: <br><ul><li>  Present all in the form of small combinable components. </li><li>  Avoid implicit copying and preferably use lazy calculations. </li><li>  Use templates to improve the performance and efficiency of writing code. </li></ul><br><br>  Starting from the first version, all components of the image processing package have been parameterized by the color type.  This is not a standard way of implementing graphic libraries - most abstract a particular type of image color through an OOP interface, or simply convert all images into a single pixel format, which they later work with in memory.  However, in most cases this is a waste of memory and time, usually the developers know in advance what format the image will be presented, with the exception of applications where graphic data are entered by the user (for example, graph. Editors).  Instead, my library declares all types of images as templates with a parameter type for color. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I am very pleased with the results of the work on the library, so I want to share a few interesting points in this post. <br><br><a name="habracut"></a><br><hr><br><br>  The library begins with a <i>view</i> definition: <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  ,    width, height ///       ///    enum isView(T) = is(typeof(T.init.w) : size_t) &amp;&amp; // width is(typeof(T.init.h) : size_t) &amp;&amp; // height is(typeof(T.init[0, 0]) ); // color information</span></span></code> </pre> <br><br>  This method of declaring static interfaces is the same as used in std.range, for example, <a href="http://dlang.org/phobos/std_range.html">isInputRange</a> .  Instead of declaring an interface that is close in meaning to OOP, static interfaces in D are conditionally determined using a test for the implementation of certain features (note trans. <a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Duck typing</a> ).  The check succeeds if the operations that the type must implement are compiled without errors or have a specific type.  Usually, <a href="http://dlang.org/expression.html">IsExpression</a> or <a href="http://dlang.org/traits.html">trait</a> <a href="http://dlang.org/traits.html">compiles is</a> used for this. <br><br>  Similarly, <a href="http://dlang.org/phobos/std_range.html">std.range.ElementType we</a> define a template to get the type that is used in the view for the pixel color: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///     view alias ViewColor(T) = typeof(T.init[0, 0]);</span></span></code> </pre><br><br>  Next, we define several specializations for the view: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Views    ///    enum isWritableView(T) = isView!T &amp;&amp; is(typeof(T.init[0, 0] = ViewColor!T.init)); ///  view   ///    . ///  views  "direct views" enum isDirectView(T) = isView!T &amp;&amp; is(typeof(T.init.scanline(0)) : ViewColor!T[]);</span></span></code> </pre><br></div></div><br><br>  Again, this is similar to the definition of <a href="http://dlang.org/phobos/std_range.html">isForwardRange</a> : a check that the type implements all the basic features, as well as some additional features specific to this specialization. <br><br>  Since the implementation of direct access to the pixels can be defined through the <i>scanline</i> direct view, we declare the <a href="http://dlang.org/template-mixin.html">template mixin</a> that implements it: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    view ///     direct view mixin template DirectView() { alias COLOR = typeof(scanline(0)[0]); ///   view[x, y] ref COLOR opIndex(int x, int y) { return scanline(y)[x]; } ///   view[x, y] = c COLOR opIndexAssign(COLOR value, int x, int y) { return scanline(y)[x] = value; } }</span></span></code> </pre><br></div></div><br><br>  For example, define an <i>Image</i> template that describes an image in memory: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///    ///      struct Image(COLOR) { int w, h; COLOR[] pixels; ///     y COLOR[] scanline(int y) { assert(y&gt;=0 &amp;&amp; y&lt;h); return pixels[w*y..w*(y+1)]; } mixin DirectView; this(int w, int h) { size(w, h); } ///     void size(int w, int h) { this.w = w; this.h = h; if (pixels.length &lt; w*h) pixels.length = w*h; } }</span></span></code> </pre><br></div></div><br><br>  <a href="http://dlang.org/arrays.html">Arrays in D are</a> implemented through a pointer and length (and only request memory when they are expanded or glued together), so the expression <i>pixels [w * y ... w * (y + 1)]</i> does not create a copy of the array. <br><br>  The unit test checks at compile time that the <i>Image</i> actually satisfies the conditions of the <i>isDirectView</i> interface: <br><pre> <code class="cpp hljs">unittest { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isDirectView!(Image!ubyte))</span></span></span></span>; }</code> </pre><br><br><hr><br><br>  So, what can we do with this model? <br><br>  First, we can define images that do not actually refer to an array of pixels, but instead calculate them on demand: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view,    ///       template procedural(alias formula) { alias fun = binaryFun!(formula, "x", "y"); alias COLOR = typeof(fun(0, 0)); auto procedural(int w, int h) { struct Procedural { int w, h; auto ref COLOR opIndex(int x, int y) { return fun(x, y); } } return Procedural(w, h); } }</span></span></code> </pre><br></div></div><br><br>  This template of the same name uses <a href="http://dlang.org/phobos/std_functional.html">std.functional.binaryFun</a> to convert a string (which will be <a href="http://dlang.org/mixin.html">mixed in</a> ) into a predicate, or delegate (lambda).  Since the function has a return type of <b>auto</b> and returns a <b>struct</b> declared inside this function, <i>Procedural</i> is an example of <a href="http://www.drdobbs.com/cpp/voldemort-types-in-d/232901591">Voldemort types</a> . <br><br>  The simplest example of a procedural image filled with one color: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view,   ///     auto solid(COLOR)(COLOR c, int w, int h) { return procedural!((x, y) =&gt; c)(w, h); }</span></span></code> </pre><br><br>  Notice how the color type of the returned view is derived from the parameter type c, so <i>solid (RGB (1, 2, 3), 10, 10)</i> will return the view from the RGB pixels, even if it does not have a fully qualified name. <br><br><hr><br><br>  Another thing that can be represented in this model is creating views that transform other views in various ways.  Define another template mixin for frequently used code: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,   view   ///  view,    ///  mixin template Warp(V) { V src; auto ref ViewColor!V opIndex(int x, int y) { warp(x, y); return src[x, y]; } static if (isWritableView!V) ViewColor!V opIndexAssign(ViewColor!V value, int x, int y) { warp(x, y); return src[x, y] = value; } }</span></span></code> </pre><br></div></div><br><br>  Let's look at the <i>static if (isWritableView! V) line</i> , which says that the <i>view [x, y] = c</i> operator should be defined only if the underlying view supports it.  Total wraped view will be changeable only if the underlying view can also be changed. <br><br>  Using this function, we can define a <i>cropping view</i> , which represents a rectangular piece of another view: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view    auto crop(V)(auto ref V src, int x0, int y0, int x1, int y1) if (isView!V) { assert( 0 &lt;= x0 &amp;&amp; 0 &lt;= y0); assert(x0 &lt; x1 &amp;&amp; y0 &lt; y1); assert(x1 &lt;= src.w &amp;&amp; y1 &lt;= src.h); static struct Crop { mixin Warp!V; int x0, y0, x1, y1; @property int w() { return x1-x0; } @property int h() { return y1-y0; } void warp(ref int x, ref int y) { x += x0; y += y0; } static if (isDirectView!V) ViewColor!V[] scanline(int y) { return src.scanline(y0+y)[x0..x1]; } } static assert(isDirectView!V == isDirectView!Crop); return Crop(src, x0, y0, x1, y1); }</span></span></code> </pre><br></div></div><br><br>  <i>if (isView! V)</i> <a href="http://dlang.org/concepts.html">template constraint</a> checks that the first argument matches the conditions of the <i>isView</i> interface. <br><br>  As before, <i>crop</i> uses <i>isDirectView</i> to provide direct access to the pixels, if the underlying image supports it.  Direct access to the pixels is useful when working with a large number of pixels at a time, which leads to an increase in performance compared to sequential access.  For example, when copying one image to another, it is much faster to use slice copies (a type-safe replacement of <i>memcpy</i> in D), than to assign the values ‚Äã‚Äãof each pixel independently: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///   view  . /// Views    . void blitTo(SRC, DST)(auto ref SRC src, auto ref DST dst) if (isView!SRC &amp;&amp; isWritableView!DST) { assert(src.w == dst.w &amp;&amp; src.h == dst.h, "View size mismatch"); foreach (y; 0..src.h) { static if (isDirectView!SRC &amp;&amp; isDirectView!DST) dst.scanline(y)[] = src.scanline(y)[]; else { foreach (x; 0..src.w) dst[x, y] = src[x, y]; } } }</span></span></code> </pre><br></div></div><br><br>  The same idea as in <i>crop</i> can be used to implement a view that tails another view or scales according to the nearest-neighbor algorithm (scaling algorithms are more complicated and better implemented in the imperative style).  The code is very similar to <i>crop</i> , so I don‚Äôt include it here. <br><br>  Even if <i>crop</i> takes a source as a normal argument, the intended use of this function and others like it is as if it is a method of the original view: <i>someView.nearestNeighbor (100, 100) .tile (1000, 1000) .crop (50, 50, 950, 950)</i> .  This feature is due to a feature of the language called <a href="http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394">‚ÄúUniform Function Call Syntax‚Äù</a> (or simply UFCS), which allows you to write <i>a.fun (b ...)</i> instead of <i>fun (a, b ...)</i> .  The main advantage of this feature is the possibility of organizing <i>chaining</i> ( <i>a.fun1 (). Fun2 (). Fun3 ()</i> instead of <i>fun3 (fun2 (fun1 (a)))</i> ), which is used to the full extent in Phobos and in this package. <br><br><hr><br><br>  For simple transformations in which the size of the view does not change, we can define an auxiliary function that simplifies the application of a user-defined formula to each pixel coordinate: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view    ///    template warp(string xExpr, string yExpr) { auto warp(V)(auto ref V src) if (isView!V) { static struct Warped { mixin Warp!V; @property int w() { return src.w; } @property int h() { return src.h; } void warp(ref int x, ref int y) { auto nx = mixin(xExpr); auto ny = mixin(yExpr); x = nx; y = ny; } private void testWarpY()() { int y; y = mixin(yExpr); } ///  x     y   ///  x,      scanlines. static if (xExpr == "x" &amp;&amp; __traits(compiles, testWarpY()) &amp;&amp; isDirectView!V) ViewColor!V[] scanline(int y) { return src.scanline(mixin(yExpr)); } } return Warped(src); } }</span></span></code> </pre><br></div></div><br><br>  <i>warp</i> uses a clever method of checking formulas.  The <i>testWarpY</i> function <i>is</i> declared as a template, however with zero template arguments.  This forces the compiler to not conduct a semantic analysis of the body of this function until its use.  And since it does not have <i>x</i> in scope, it can be successfully installed only if <i>yExpr</i> does not use <i>x</i> .  The expression <i>__traits (compiles, testWrapY ())</i> checks for this.  All this allows us to determine the direct view <i>scanline</i> only if we are sure that we can do it safely.  Example: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view    x alias hflip = warp!(q{wx-1}, q{y}); ///  view    y alias vflip = warp!(q{x}, q{hy-1}); ///  view    x  y alias flip = warp!(q{wx-1}, q{hy-1});</span></span></code> </pre><br></div></div><br><br>  The <a href="http://dlang.org/lex.html">q {...}</a> syntax is simply a convenient way to define string constants.  This entry is usually used for D code, which is then mixed somewhere.  The expression has access to all characters in the place of mixing - in our case, this is the <i>warp</i> function and the <i>testWarpY</i> method of the <i>Wrapped</i> structure. <br><br>  Since <i>vflip</i> satisfies the first two conditions necessary to declare the <i>scanline</i> method, <i>someView.vflip ()</i> will be a direct view, if <i>someView is</i> .  And this was achieved without explicit verification for the <i>vflip</i> ad. <br><br>  Since the abstraction used does not rely on dynamic polymorphism, the compiler is free to embed calls to all layers of transformations.  Inverting the image does not generate the operation twice, and, in fact, <i>i [5, 5]</i> and <i>i.hflip (). Hflip () [5, 5]</i> generate the same machine code.  <a href="https://github.com/ldc-developers/ldc">Compilers D with a more advanced backend</a> can perform even more aggressive optimizations: for example, if you define the <i>flipXY</i> function, which inverts the X and Y axes, and <i>rotateCW</i> (to rotate an image 90 ¬∞ counterclockwise) as <i>src.flipXY (). Hflip ()</i> , then four successful <i>rotateCW calls</i> are cut during optimization. <br><br><hr><br><br>  Let's move on to the operations on the pixels themselves.  The main function in <i>std.algorithm</i> is <a href="http://dlang.org/phobos/std_algorithm.html">map</a> , which returns a <a href="http://dlang.org/phobos/std_range.html">range</a> that lazily applies an expression over another range.  Our <i>colorMap</i> uses this idea for colors: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view,    ///     view. template colorMap(alias pred) { alias fun = unaryFun!(pred, false, "c"); auto colorMap(V)(auto ref V src) if (isView!V) { alias OLDCOLOR = ViewColor!V; alias NEWCOLOR = typeof(fun(OLDCOLOR.init)); struct Map { V src; @property int w() { return src.w; } @property int h() { return src.h; } auto ref NEWCOLOR opIndex(int x, int y) { return fun(src[x, y]); } } return Map(src); } }</span></span></code> </pre><br></div></div><br><br>  Using <i>colorMap</i> , defining a function that inverts the colors of an image is as simple as: <br><pre> <code class="cpp hljs">alias invert = colorMap!q{~c};</code> </pre><br><br>  <i>colorMap</i> does not require matching the source and result color types.  This allows you to use it for color conversion: <i>read ("image.bmp"). ParseBMP! RGB (). ColorMap! (C =&gt; BGRX (cb, cg, cr))</i> returns RGB as BGRX view. <br><hr><br><br>  Image processing very often <a href="http://en.wikipedia.org/wiki/Embarrassingly_parallel">lends itself well to parallelization</a> .  <a href="http://dlang.org/phobos/std_parallelism.html">std.parallelism</a> helps to make the task of parallel image processing trivial: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///  view    ///  fun    /// . ///   , ///    , ///  vjoin  vjoiner. template parallel(alias fun) { auto parallel(V)(auto ref V src, size_t chunkSize = 0) if (isView!V) { auto processSegment(R)(R rows) { auto y0 = rows[0]; auto y1 = y0 + rows.length; auto segment = src.crop(0, y0, src.w, y1); return fun(segment); } import std.range : iota, chunks; import std.parallelism : taskPool, parallel; if (!chunkSize) chunkSize = taskPool.defaultWorkUnitSize(src.h); auto range = src.h.iota.chunks(chunkSize); alias Result = typeof(processSegment(range.front)); auto result = new Result[range.length]; foreach (n; range.length.iota.parallel(1)) result[n] = processSegment(range[n]); return result; } }</span></span></code> </pre><br></div></div><br>  Even if <i>parallel</i> shares its name with those functions that are present in <i>std.parallelism</i> , there is no conflict, as they have different signatures and work on different types. <br><br>  At the same time, the operation can be divided between several streams by replacing <i>image.process ()</i> with <i>image.parallel! (Segment =&gt; segment.process ()). Vjoin ()</i> . <br><br><hr><br><br>  Practical examples: <br><ul><li>  Creating a short animation: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.algorithm; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.parallelism; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.geometry; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.color; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.draw; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.gamma; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.image; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> W = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FG = L16(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BG = L16(ushort.max); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image = Image!L16(W, W); image.fill(BG); <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OUTER = W/<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> INNER = W/<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">13</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> THICK = W/<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>; image.fillCircle(W/<span class="hljs-number"><span class="hljs-number">2</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>, OUTER, FG); image.fillCircle(W/<span class="hljs-number"><span class="hljs-number">2</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>, INNER, BG); image.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>-INNER, W/<span class="hljs-number"><span class="hljs-number">2</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>+INNER, BG); image.fillRect(W/<span class="hljs-number"><span class="hljs-number">2</span></span>-THICK/<span class="hljs-number"><span class="hljs-number">2</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>-INNER, W/<span class="hljs-number"><span class="hljs-number">2</span></span>+THICK/<span class="hljs-number"><span class="hljs-number">2</span></span>, W/<span class="hljs-number"><span class="hljs-number">2</span></span>+INNER, FG); <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> frames = <span class="hljs-number"><span class="hljs-number">32</span></span>; foreach (n; frames.iota.parallel) image .rotate(TAU * n / frames, BG) .copy .downscale!(W/<span class="hljs-number"><span class="hljs-number">16</span></span>) .lum2pix(gammaRamp!(ushort, ubyte, ColorSpace.sRGB)) .toPNG .toFile(<span class="hljs-string"><span class="hljs-string">"loading-%02d.png"</span></span>.format(n++)); }</code> </pre><br></div></div><br><br>  This program draws the original image in higher resolution, using a 16-bit brightness, which then converts it into an 8-bit sRGB image after reduction.  Zooming out avoids <a href="http://en.wikipedia.org/wiki/Aliasing">aliasing</a> , and color conversion is necessary for <a href="http://www.4p8.com/eric.brasseur/gamma.html">accurate resizing</a> . <br><br>  This is what happened after converting PNG frames to GIF: <br><img src="https://habrastorage.org/getpro/habr/post_images/e72/dc3/2c3/e72dc32c30c7ff56a0b6b5dd1578bf64.gif" alt="image"><br></li><li>  Drawing a gray-white image of the <a href="http://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mandelbrot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.algorithm, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.view; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> procedural!((x, y) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = (<span class="hljs-number"><span class="hljs-number">2.0</span></span>*x/w - <span class="hljs-number"><span class="hljs-number">1.5</span></span>) + (<span class="hljs-number"><span class="hljs-number">2.0</span></span>*y/h - <span class="hljs-number"><span class="hljs-number">1.0</span></span>)*<span class="hljs-number"><span class="hljs-number">1</span></span>i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(ubyte)(<span class="hljs-number"><span class="hljs-number">1</span></span>+ recurrence!((a, n) =&gt; c + a[n<span class="hljs-number"><span class="hljs-number">-1</span></span>]^^<span class="hljs-number"><span class="hljs-number">2</span></span>)(<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>i) .take(ubyte.max) .countUntil!(z =&gt; z.re^^<span class="hljs-number"><span class="hljs-number">2</span></span> + z.im^^<span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)); })(w, h); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.image; mandelbrot(<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>).toPNG().toFile(<span class="hljs-string"><span class="hljs-string">"mandel.png"</span></span>); }</code> </pre><br></div></div><br><br>  This program uses <a href="http://dlang.org/phobos/std_range.html">recurrence</a> , <a href="http://dlang.org/phobos/std_range.html">take</a> and <a href="http://dlang.org/phobos/std_algorithm.html">countUntil</a> primitives over the D ranges, as well as built-in support for complex numbers, allowing you to concisely implement an <a href="http://en.wikipedia.org/wiki/Mandelbrot_set">algorithm</a> that usually requires many lines to implement (However, the built-in complex numbers are now in the process of being obsolete in favor of <a href="http://dlang.org/phobos/std_complex.html">std.complex</a> ). <br><br>  Result of work: <br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/95e/84f/d1d/95e84fd1dfcaf235e8d9fa3e5c771ea9.png" alt="image"><br></div></div><br></li></ul><br><br><hr><br><br>  The template approach promises big performance gains.  As a simple benchmark, this program reduces the scale of all images in the directory by 25%: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.file; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.color; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.gamma; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ae.utils.graphics.image; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alias BGR16 = Color!(ushort, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"g"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gamma = GammaRamp!(ushort, ubyte)(<span class="hljs-number"><span class="hljs-number">2.2</span></span>); foreach (de; dirEntries(<span class="hljs-string"><span class="hljs-string">"input"</span></span>, <span class="hljs-string"><span class="hljs-string">"*.bmp"</span></span>, SpanMode.shallow)) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Image!BGR scratch1; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Image!BGR16 scratch2, scratch3; de .read .parseBMP!BGR(scratch1) .parallel!(segment =&gt; segment .pix2lum(gamma) .copy(scratch2) .downscale!<span class="hljs-number"><span class="hljs-number">4</span></span>(scratch3) .lum2pix(gamma) .copy )(<span class="hljs-number"><span class="hljs-number">4</span></span>) .vjoin .toBMP .toFile(buildPath(<span class="hljs-string"><span class="hljs-string">"output-d"</span></span>, de.baseName)); } }</code> </pre><br></div></div><br><br>  I compared the result of the work with the equivalent <a href="http://www.imagemagick.org/">ImageMagick</a> team: <br><pre> <code class="hljs tex">convert <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>input/*.bmp <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-depth 16 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-gamma 0.454545 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-filter box <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-resize 25<span class="hljs-comment"><span class="hljs-comment">% \ -gamma 2.2 \ -depth 8 \ output-im/%02d.bmp</span></span></code> </pre><br><br>  Version on D runs 4-5 times faster.  Of course, this is an unfair comparison: even if both use 16-bit color depth, gamma correction, multithreading and are optimized for the same architecture, the D program contains code specially optimized for this task.  If you do not take into account the various JIT technology, the package can not be compared with libraries of image processing, general purpose. <br><br><hr><br><br>  A graphics package <a href="https://github.com/CyberShadow/ae/tree/master/utils/graphics">is available on GitHub</a> .  Thanks to David Ellsworth for his contribution to this article. </div><p>Source: <a href="https://habr.com/ru/post/218429/">https://habr.com/ru/post/218429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218417/index.html">WebView or a story about how the browser was written in KolibriOS</a></li>
<li><a href="../218419/index.html">Qt is now on Windows Phone</a></li>
<li><a href="../218421/index.html">Epidemic of online consultants</a></li>
<li><a href="../218423/index.html">Work with ZeroMQ and PostgreSQL in asyncio</a></li>
<li><a href="../218425/index.html">Development of Chromecast Ready applications for the Android platform</a></li>
<li><a href="../218431/index.html">Stock Market Technologies: Brokerage Trading System</a></li>
<li><a href="../218437/index.html">Terms of Service, Privacy Policy and License Agreement: an educational program for an indie mobile developer</a></li>
<li><a href="../218441/index.html">Universal applications for Windows and Windows Phone</a></li>
<li><a href="../218443/index.html">Epson on Droidcon Moscow</a></li>
<li><a href="../218445/index.html">Product Design Digest February-March 2014</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>