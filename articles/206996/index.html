<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DSL on Scala for working with HTML forms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely many of you are familiar with the process of creating and processing HTML forms. It may be trivial for a typical web application, but if you wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DSL on Scala for working with HTML forms</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/291/a99/6b9/291a996b965e12e8474403d25e0b9088.png"><br><br>  Surely many of you are familiar with the process of creating and processing HTML forms.  It may be trivial for a typical web application, but if you work in the corporate sector, the situation is a little different.  Forms for creating or editing clients, documents and more become a daily routine.  Developing Java frameworks, they offer more and more convenient API and components for working with them.  But even in spite of this, many probably wondered if it was possible to make work with forms a little more convenient. <br>  First of all, of course, I would like the framework to make the following tasks as easy as possible: <br><ul><li>  defining properties of form fields, such as type, title, or validity; </li><li>  processing the form data after it is sent; </li><li>  rendering form. </li></ul><br>  Moreover, it is desirable that many errors would be detected at the compilation stage. <br><br>  In this article, I will describe the process of creating your own DSL in the Scala language, and then I will show how to use the new way to describe forms in the context of the Play Framework 2. <br><a name="habracut"></a><br><h5>  A little about the terminology. </h5><br>  In this article, I am talking about internal DSL.  Internal DSL is not a new language, but only a convenient way of describing a subject area using the syntax of the main (host) programming language.  True, if the host-language syntax is sufficiently flexible, the internal DSL may look like it is a new language intended for a given area.  The advantages of this option include the fact that development environments understand the internal DSL, highlight the syntax, and offer options for auto-completion.  For comparison, external DSL is really a new language that needs its own parser. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The DSL described in the article was originally created to solve problems that arose due to some limitations of the form engine in the Play Framework 2. But now it is independent of Play and can be used with any JVM framework if you implement the appropriate adapters. <br><br><h5>  How to start developing DSL? </h5><br>  First of all, decide what you want to get as a result.  We need to dream up on the topic: ‚Äúwhat an ideal DSL should look like in order to solve this problem,‚Äù forgetting for a while that we are limited by the host-language syntax. <br>  As an example, take the registration form with the following fields: <br><ul><li>  mail - text, mandatory, validation of the postal address; </li><li>  Name - text, mandatory; </li><li>  date of birth is an optional date. </li></ul><br>  To describe it, you can write this entry in pseudocode: <br><pre><code class="scala hljs">form( string(email, required, validate(<span class="hljs-type"><span class="hljs-type">EmailAddress</span></span>)) string(name, required) date(birthDate) )</code> </pre> <br>  Now it's time to think about how to implement it.  First consider the general description of the form, namely the set of fields and their type.  Scala provides us with several approaches to create such a description: <br><br><h6>  1. Builder pattern and method chaining </h6><br>  Signature factory method for the form: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">form</span></span></span></span>(builderFoo: <span class="hljs-type"><span class="hljs-type">FormBuilder</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FormBuilder</span></span>)</code> </pre><br>  Using: <br><pre> <code class="scala hljs">form(_ .string(...) .string(...) .extend(commonFields) .date(...) )</code> </pre><br>  Here we use the <b>builder</b> and <b>method chaining</b> patterns.  This gives us the following benefits: <br><ul><li>  You can build a form description using the abstract builder interface - this allows you to change a specific implementation if necessary; </li><li>  A part of the call chain can be put into a separate function and used in different forms; </li><li>  need to write less auxiliary code; </li><li>  the closure type is derived from the form (...) signature. </li></ul><br>  <i>Looking ahead, I will say that this option was chosen</i> . <br><br><h6>  2. As a function with a variable number of parameters </h6><br>  Factory Method: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">form</span></span></span></span>(fields: <span class="hljs-type"><span class="hljs-type">FormBuilder</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FormBuilder</span></span>*)</code> </pre><br>  Using: <br><pre> <code class="scala hljs">form( _.string(...), _.string(...), _.date(...), commonFields:_* )</code> </pre><br>  There are several drawbacks to this option: <br><ul><li>  the need to write more auxiliary code; </li><li>  additional fields can be added only at the end of the list of arguments. </li></ul><br><h6>  3. Block code with a sequence of calls </h6><br>  Factory Method: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">form</span></span></span></span>(fields: =&gt; ())</code> </pre><br><pre> <code class="scala hljs">: form{ string(...) date(...) commonFields() }</code> </pre><br>  This method is bad because: <br><ul><li>  at the time of form determination, we are tied to the specific implementation of the string, date, etc. methods. </li><li>  to implement it, we would have to work with a changeable state, which we would like to avoid; </li><li>  There is no typification of transmitted expressions. </li></ul><br><br>  So, a preliminary analysis showed that the best option is using a known design pattern.  Surprise. <br><br><h5>  Field description </h5><br>  For a detailed description of the fields also selected method chaining and builder, for the same reasons. <br>  The signature of the field definition method: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span>(fieldFoo: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>): <span class="hljs-type"><span class="hljs-type">FormBuilder</span></span></code> </pre><br>  Using: <br><pre> <code class="scala hljs">.string(_.name(<span class="hljs-string"><span class="hljs-string">"email"</span></span>).required.validate(<span class="hljs-type"><span class="hljs-type">EmailAddress</span></span>))</code> </pre><br><h5>  A sketch of the implementation of the builder </h5><br>  The <code>case class</code> with its automatically defined <code>copy</code> method is ideal for implementing Scala in Scala.  This method copies the current object, modifying the desired attributes.  A builder for a particular field might look like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldBuilderImpl</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fieldType: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isRequired: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params">, validators: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Validator</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fieldType</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span> = copy(fieldType = t) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">label</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span> = copy(label = l) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">required</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span> = copy(isRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(vs: <span class="hljs-type"><span class="hljs-type">Validator</span></span>*): <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span> = copy(validators = validators ++ vs) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FieldDescription</span></span> = ??? }</code> </pre><br>  The main form parameter is a set of its fields, so for it the builder will look slightly different: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilderImpl</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fields: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldDescription</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">field</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>](name: <span class="hljs-type"><span class="hljs-type">String</span></span>)(foo: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]) = copy(fields = fields ++ <span class="hljs-type"><span class="hljs-type">Map</span></span>(name -&gt; foo(newFieldBuilder[<span class="hljs-type"><span class="hljs-type">F</span></span>]).asInstanceOf[<span class="hljs-type"><span class="hljs-type">FieldBuilderImpl</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]].build)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>)(foo: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) = field[<span class="hljs-type"><span class="hljs-type">String</span></span>](name)(foo andThen (_.fieldType(<span class="hljs-string"><span class="hljs-string">"string"</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newFieldBuilder</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>] = ??? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FormDescription</span></span> = ??? }</code> </pre><br>  It is worth noting that in this case we still need to specify the field ID manually.  At the same time, if we accidentally specify an incorrect identifier (for example, having sealed it), we will learn about the error only during the execution of the program. <br><br><h5>  Form Data Presentation </h5><br>  After the user submits the form, the web framework used receives the request data and converts it to its own framework-specific representation.  One of the tasks of integration with the framework is to transform its internal form representation to a convenient form (this process is briefly described at the end of the article with reference to the Play Framework) <br><br>  It is convenient to present the form data as an instance of the <code>case class</code> .  For brevity, we will call it ‚Äúform data object‚Äù or simply ‚Äúform data‚Äù.  Form fields will be represented by typed fields of this class.  In this case, we can identify the form fields with a closure ‚Äî by calling the getter of the desired field of the form data object (for example, a closure <code>(_.someField)</code> will correspond to a form field called <code>"someField"</code> ). <br><br>  Sending a closure instead of a string has an important advantage - it allows us to control the type of the form field, because we know the type of the closure.  For example, by the type <code>UserFormData =&gt; String</code> we can determine that the form field should be only string. <br><br><h5>  Getting the field name using reflection </h5><br>  There are at least two ways to get the field name in Scala: the first, the traditional one - with the help of reflection, the second - with the help of macros.  Reflection is good because it is a long-established, rather unpretentious mechanism, while macros are a new feature that is in the status of an experiment, and there are some limitations to its use.  But they allow you to determine the name of the field at compile time, which, of course, is a significant advantage.  In this article, we will limit ourselves to reflection (we'll get to the macro next time). <br>  So, we are interested in the ability to define a field in the following way: <br><pre> <code class="scala hljs">form[<span class="hljs-type"><span class="hljs-type">FormData</span></span>](_.string( _.someField )(_.someProperty))</code> </pre><br>  those.  on the <code>_.someField</code> closure get the name <code>"someField"</code> . <br>  A function to do this would have the following signature: <br> <code>fieldName[T:Manifest](fieldFoo: T =&gt; Any): String</code> <br>  The <code>[T:Manifest]</code> entry <a href="http://www.scala-lang.org/api/current/index.html">means</a> that an additional, <i>implicit</i> parameter list will be added to the method signature, expecting a Manifest [T] argument from the compiler.  In fact, this is nothing more than a crutch to overcome such a phenomenon in the JVM as <a href="http://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure</a> .  With the manifest, we get the opportunity to get <i>type parameter</i> (similar to the type variable from the Generic class in Java) at run time. <br>  Having received a class from the manifest, we construct from it a <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/html/javassist/util/proxy/Proxy.html">dynamic proxy</a> <code>proxyObject</code> : an object that satisfies the type that we transferred, the only task of which is to communicate the name of the first method called.  If the closure <code>(_: T).someField</code> is passed as <code>fieldFoo: T =&gt; Any</code> , then a call to <code>fieldFoo(proxyObject)</code> will give us the string <code>"someField"</code> .  These actions were moved to the <a href="https://github.com/NAUMEN-GP/scala-reflective-utils">scala-reflective-tools</a> library. <br>  Its use looks like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fieldA: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">import</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldNameGetter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assertTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClass</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_.fieldA</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldA</span></span></span><span class="hljs-class">"</span></span></code> </pre><br>  Now we can rewrite the form builder like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilderImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Manifest</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fields: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldDescription</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldNameGetter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">field</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>](fieldFoo: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>)(foo: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]) = copy(fields = fields ++ <span class="hljs-type"><span class="hljs-type">Map</span></span>($[<span class="hljs-type"><span class="hljs-type">T</span></span>](fieldFoo) -&gt; foo(newFieldBuilder[<span class="hljs-type"><span class="hljs-type">F</span></span>]).asInstanceOf[<span class="hljs-type"><span class="hljs-type">FieldBuilderImpl</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]].build)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span>(fieldFoo: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>)(foo: <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">FieldBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) = field[<span class="hljs-type"><span class="hljs-type">String</span></span>](fieldFoo)(foo andThen (_.fieldType(<span class="hljs-string"><span class="hljs-string">"string"</span></span>))) ... }</code> </pre><br><br>  Form fields can be required and optional.  We can reflect the optional property of a field in the case class, by giving the corresponding field the type Option [...]. <br>  For example, for our form, the case class might look like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegistrationFormData</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, surname: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">], email: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, birthDate: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Date</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  The getter of the <code>name</code> field is of type <code>RegistrationFormData =&gt; String</code> , and the getter <code>surname</code> is of type <code>RegistrationFormData =&gt; Option[String]</code> .  Accordingly, we must have two methods for defining fields. <br>  For mandatory: <br> <code>(def string(fieldFoo: T =&gt; String)(foo: FieldBuilder[String] =&gt; FieldBuilder[String])</code> <br>  For optional: <br> <code>def stringOpt(fieldFoo: T =&gt; Option[String])(foo: FieldBuilder[String] =&gt; FieldBuilder[String])</code> <br>  For each field type (except boolean) both options are required.  We customize the <code>string</code> method by declaring the <code>required</code> property in it.  With the help of currying it was possible to get a rather compact code: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilderImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Manifest</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fields: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldDescription</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormBuilder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldNameGetter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    : type FieldFoo[F] = FieldBuilder[F] =&gt; FieldBuilder[F] type FormField[F] = FieldFoo[F] =&gt; FormBuilder[T] //    def string(fieldFoo: T =&gt; String): FormField[String] = fieldBase[String](fieldFoo)(_.required) //    def stringOpt(fieldFoo: T =&gt; Option[String]): FormField[String] = fieldBase[String](fieldFoo)(identity) def field[F](fieldName: String)(foo: FieldFoo[F]) = copy(fields = fields ++ Map(fieldName -&gt; foo(newFieldBuilder[F]).asInstanceOf[FieldBuilderImpl[F]].build)) def fieldBase[F: Manifest](fieldFoo: T =&gt; Any) (innerConfigFoo: FieldFoo[F]) (userConfigFoo: FieldFoo[F]) = field($[T](fieldFoo))(innerConfigFoo andThen (_.fieldType(fieldTypeBy[F])) andThen userConfigFoo) ... }</span></span></code> </pre><br><br>  In addition, here we define the <code>fieldType</code> property using the type parameter. <br><br><h5>  DSL extension </h5><br>  At the moment, with our <code>FieldBuilder</code> we can only specify the <code>label</code> and <code>required</code> properties, and this is not enough.  Developers should be able to extend the set of field properties if required by the task.  In addition, fields of different types need to specify different properties. <br>  To solve this problem, we will use <i>implicit</i> transforms and the <a href="http://www.artima.com/weblogs/viewpost.jsp%3Fthread%3D179766">Pimp My Library</a> pattern. <br><br>  Add the following method to <code>FieldBuilder</code> : <br> <code>def addProperty(key: String, value: Any): FieldBuilder[T]</code> <br>  Further we will set all field configuration through it.  Users of our DSL will not access it directly, the user API will be composed of <i>implicit</i> converters of the form: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldDslExtenders</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">FieldAttributes</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringFieldBuilderExtender</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fb: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldBuilder</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minLength</span></span></span></span>(length: <span class="hljs-type"><span class="hljs-type">Int</span></span>) = fb.addProperty(<span class="hljs-type"><span class="hljs-type">MinLength</span></span>, length) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxLength</span></span></span></span>(length: <span class="hljs-type"><span class="hljs-type">Int</span></span>) = fb.addProperty(<span class="hljs-type"><span class="hljs-type">MaxLength</span></span>, length) } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SeqFieldBuilderExtender</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fb: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldBuilder</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DateFieldBuilderExtender</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fb: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FieldBuilder</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Date</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format</span></span></span></span>(datePattern: <span class="hljs-type"><span class="hljs-type">String</span></span>) = fb.addProperty(<span class="hljs-type"><span class="hljs-type">DatePattern</span></span>, datePattern) } }</code> </pre><br>  Note that <i>implicit</i> classes are inherited from <code>AnyVal</code> .  This is necessary so that at run time an object of this wrapper class is not instantiated, but instead a static method is called on the companion object, which will be implicitly created by the compiler. <br><br>  Not everything is perfect in our <code>FormBuilder</code> : with its help, so far you can add a rather limited set of field types.  It is clear that adding all the most common views to it is not difficult, but what if users need a new field type that is not in <code>FormBuilder</code> ?  This problem can be solved with the help of the same <i>implicit</i> converters that access the base <code>fieldBase</code> method.  With their help, we can extend <code>FormBuilder</code> - for example, we could add a method to create a field with a date: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormDslExtensions</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldNameGetter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> defaultDateFormat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleDateFormat</span></span>(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>).toPattern <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">FieldDslExtenders</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DateFormExtension</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Manifest</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fb: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">FormBuilder</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dateOpt</span></span></span></span>(fieldFoo: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Date</span></span>]) = fb.fieldBase[<span class="hljs-type"><span class="hljs-type">Date</span></span>](fieldFoo)(_.format(defaultDateFormat)) _ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">date</span></span></span></span>(fieldFoo: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>) = fb.fieldBase[<span class="hljs-type"><span class="hljs-type">Date</span></span>](fieldFoo)(_.required.format(defaultDateFormat)) _ } }</code> </pre><br><br><h5>  Internal form presentation </h5><br>  As a result of the work of our builders, we get a FormDescription description object containing the <code>String -&gt; FieldDescription</code> .  In turn, the <code>FieldDescription</code> contains the map <code>String -&gt; Any</code> .  Thus, we can set the fields for any attributes that may be required.  The resulting description of the form, in my opinion, is quite framework-agnostic, i.e.  can be used with various frameworks.  All that is needed is to implement the conversion into the form representation of the framework used.  Next we look at how this was done for the Play Framework. <br><br><h5>  Play integration </h5><br>  Play already has a mechanism that is convenient for not very complex forms.  But it has the following limitations: <br><ul><li>  a limit of 18 fields; </li><li>  the ability to specify only the type of fields and validation; </li><li>  the absence of fields with multiple choice (at the time of writing, should soon appear). </li></ul><br>  When submitting a form, Play receives an HTTP request, deserializes it and presents the request parameters as <code>Map[String, Seq[String]]</code> .  Further, they are expected to be validated and converted into a suitable representation for custom code.  Built-in Play allows you to convert this data either into a Tuple or into an arbitrary object - for this, however, you must provide the function of its creation.  If the form has enough fields, it can lead to code that is potentially rich in errors.  Imagine: you need to make sure that the 18 function arguments are in the correct order. <br><br>  To validate and convert raw data, Play uses the <a href="https://github.com/playframework/playframework/blob/2.1.3/framework/src/play/src/main/scala/play/api/data/Form.scala">Mapping</a> class. <br>  Form mappings built into Play receive field mappings as separate constructor arguments (for example, <a href="https://github.com/playframework/playframework/blob/2.1.3/framework/src/play/src/main/scala/play/core/hidden/ObjectMappings.scala">ObjectMapping9</a> ), so a form can only have a strictly fixed set of fields specified at the time of its definition.  Our class, which we call <a href="https://github.com/NAUMEN-GP/play-forms-improved/blob/master/src/main/scala/com/naumen/scala/forms/play/PlayFormFactory.scala">FormMapping</a> , can work with an arbitrary number of fields.  On the other hand, the fields passed to it lose their typing, but this is not terrible, since <code>FormMapping</code> not intended to work with fields manually.  Field typing is guaranteed by DSL, and the conversion to a form data object and vice versa occurs automatically using reflection. <br><br>  Forms on Play are represented using case class <a href="https://github.com/playframework/playframework/blob/2.1.3/framework/src/play/src/main/scala/play/api/data/Form.scala">play.api.data.Form</a> , and fields are <a href="https://github.com/playframework/playframework/blob/2.1.3/framework/src/play/src/main/scala/play/api/data/Form.scala">play.api.data.Field</a> .  Our implementations of <a href="https://github.com/NAUMEN-GP/play-forms-improved/blob/master/src/main/scala/com/naumen/scala/forms/play/PlayFormFactory.scala">forms</a> and <a href="https://github.com/NAUMEN-GP/play-forms-improved/blob/master/src/main/scala/com/naumen/scala/forms/play/PlayFormFactory.scala">fields</a> will be inherited from these classes, since we need to achieve compatibility with the old API.  The fields of the form will have a new field of <code>attributes</code> - with its help additional parameters will be passed. <br><br><h5>  Usage example </h5><br>  Form Definition: <br><pre> <code class="scala hljs"> <span class="hljs-type"><span class="hljs-type">PlayFormFactory</span></span>.form[<span class="hljs-type"><span class="hljs-type">FormData</span></span>](_.string(_.name)(_.label(<span class="hljs-string"><span class="hljs-string">""</span></span>).someAttribute(<span class="hljs-number"><span class="hljs-number">42</span></span>))</code> </pre><br><br>  Template with the form: <br><pre> <code class="scala hljs">@(form: com.naumen.scala.forms.play.<span class="hljs-type"><span class="hljs-type">ExtendedForm</span></span>[<span class="hljs-type"><span class="hljs-type">RegistrationFormData</span></span>]) &lt;div&gt; .... <span class="hljs-meta"><span class="hljs-meta">@myComponent</span></span>(form(_.name)) .... &lt;/div&gt;</code> </pre><br>  Template component myComponent: <br><pre> <code class="scala hljs">@(customField: com.naumen.scala.forms.play.<span class="hljs-type"><span class="hljs-type">ExtendedField</span></span>) &lt;div&gt; .... <span class="hljs-meta"><span class="hljs-meta">@customField</span></span>.ext.attrs(<span class="hljs-string"><span class="hljs-string">"someAttribute"</span></span>) .... &lt;/div&gt;</code> </pre><br>  The ability to set arbitrary field parameters at the form definition stage allows you to concentrate in the template on the layout and put the definition of parameters not related to the layout to the controller. </div><p>Source: <a href="https://habr.com/ru/post/206996/">https://habr.com/ru/post/206996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206984/index.html">Lock-free data structures. Inside RCU</a></li>
<li><a href="../206986/index.html">Colossus Google's distributed file system</a></li>
<li><a href="../206988/index.html">A selection of specialized software for a web developer under the Android OS</a></li>
<li><a href="../206992/index.html">"Debriefing" - Episode 52 - Chief of IDEA</a></li>
<li><a href="../206994/index.html">Fads of abstractions</a></li>
<li><a href="../206998/index.html">The letter reached! Duma adopted changes in the law on benefits for small IT companies</a></li>
<li><a href="../207000/index.html">Trends and prospects of algorithmic trading in Russia</a></li>
<li><a href="../207004/index.html">IT systems of large companies can even be hacked by a novice hacker.</a></li>
<li><a href="../207006/index.html">The concept of the perfect messenger</a></li>
<li><a href="../207010/index.html">The case of life, or to the question of choosing antivirus for home use</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>