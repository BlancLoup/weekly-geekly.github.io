<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Organization of multitasking in the OS kernel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By the will of fate, I happened to deal with the organization of multitasking, more precisely pseudo-multitasking, since tasks divide time on one core...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Organization of multitasking in the OS kernel</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f27/d21/be6/f27d21be66754ff47a87e281e7fe7e44.jpg" align="right">  By the will of fate, I happened to deal with the organization of multitasking, more precisely pseudo-multitasking, since tasks divide time on one core of the processor.  I have already met several articles on this topic in Habr√©, and it seemed to me that this topic was interesting to the community, so I will allow myself to make my modest contribution to the coverage of this issue. <br>  First I will try to talk about the types of multitasking (cooperative and repressive).  Then move on to planning principles for preemptive multitasking.  The story is designed more for the novice reader who wants to figure out how multitasking works at the kernel level of the OS.  But since everything will be accompanied by examples that can be compiled, run, and with which you can play around if you want, then perhaps the article will also interest those who are already familiar with the theory, but have never tried the scheduler.  Those who are too lazy to read can immediately go to the study of the code, since the code of the examples will be taken from <a href="https://github.com/embox/embox">our project</a> . <br>  Well, and multithreaded cats to attract attention. <br><br><a name="habracut"></a><br><br><h4>  Introduction </h4><br>  First, we define what the term ‚Äúmultitasking‚Äù means.  Here is the definition from Russian Wikipedia: <br><blockquote>  Multitasking (eng. Multitasking) - a property of the operating system or programming environment to provide the possibility of parallel (or pseudo-parallel) processing of several processes. </blockquote><br>  English gives, in my opinion, a less clear, but more detailed definition: <br><blockquote>  In the case of the same period of time.  The common process resources, such as a CPU and main memory.  In the case of a computer with a single CPU  It is a scheduling problem.  It is a switch to reassigning a context switch. </blockquote><br>  It introduces the concept of resource sharing (resources sharing) and, in fact, planning (scheduling).  It is about planning (first of all, CPU time) that this article will discuss.  Both definitions deal with process planning, but I will talk about flow-based planning. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a1c/0cc/dce/a1c0ccdce6d476e59835be0729969ddd.png" align="right">  Thus, we need to introduce another concept, let's call it the flow of execution - this is a set of instructions with a specific order that the processor performs during program operation. <br>  Since we are talking about multitasking, then of course in the system there can be several of these computational threads.  The thread whose instructions the processor is currently executing is called active.  Since only one instruction can be executed on one processor core at a time, only one computing thread can be active.  The process of selecting the active computational flow is called scheduling.  In turn, the module that is responsible for this choice is called the scheduler. <br><br>  There are many different planning methods.  Most of them can be attributed to two main types: <br><ul><li>  non-displacing (cooperative) - the scheduler cannot take time from the computational flow until he himself returns it </li><li>  preemptive - the scheduler selects the next active computational flow after a time slice has expired, the computational flow itself can also give the remainder of the time slice intended for it </li></ul><br><br>  Let's begin to deal with the non-displacing planning method, since it is very easy to implement. <br><br><h4>  Non-displacing scheduler </h4><br>  The considered non-preemptive scheduler is very simple, this material is given for beginners to make it easier to understand multitasking.  Anyone who has an idea, even a theoretical one, can immediately go to the section ‚ÄúForcing the scheduler‚Äù. <br><br><h5>  The simplest non-displacing scheduler </h5><br>  Imagine that we have several tasks that are rather short in time, and we can call them in turn.  The task is designed as a normal function with a certain set of parameters.  The scheduler will operate with an array of structures on these functions.  It will traverse this array and call function tasks with the given parameters.  The function, having performed the necessary actions for the task, will return control to the main cycle of the scheduler. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #define TASK_COUNT 2 struct task { void (*func)(void *); void *data; }; static struct task tasks[TASK_COUNT]; static void scheduler(void) { int i; for (i = 0; i &lt; TASK_COUNT; i++) { tasks[i].func(tasks[i].data); } } static void worker(void *data) { printf("%s\n", (char *) data); } static struct task *task_create(void (*func)(void *), void *data) { static int i = 0; tasks[i].func = func; tasks[i].data = data; return &amp;tasks[i++]; } int main(void) { task_create(&amp;worker, "First"); task_create(&amp;worker, "Second"); scheduler(); return 0; }</span></span></span></span></code> </pre> <br><br><h6>  Output Results: </h6><br>  <i>First</i> <i><br></i>  <i>Second</i> <i><br></i> <br><h6>  CPU busy schedule: </h6><br><img src="//habrastorage.org/files/f06/350/257/f063502577d940adbbd670a7ac7350b9.png"><br><br><h5>  Non-preemptive event-based scheduler </h5><br>  It is clear that the example described above is too primitive.  Let's also introduce the ability to activate a specific task.  To do this, add a flag to the task description structure that indicates whether the task is active or not.  Of course, still need a small API to control the activation. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #define TASK_COUNT 2 struct task { void (*func)(void *); void *data; int activated; }; static struct task tasks[TASK_COUNT]; struct task_data { char *str; struct task *next_task; }; static struct task *task_create(void (*func)(void *), void *data) { static int i = 0; tasks[i].func = func; tasks[i].data = data; return &amp;tasks[i++]; } static int task_activate(struct task *task, void *data) { task-&gt;data = data; task-&gt;activated = 1; return 0; } static int task_run(struct task *task, void *data) { task-&gt;activated = 0; task-&gt;func(data); return 0; } static void scheduler(void) { int i; int fl = 1; while (fl) { fl = 0; for (i = 0; i &lt; TASK_COUNT; i++) { if (tasks[i].activated) { fl = 1; task_run(&amp;tasks[i], tasks[i].data); } } } } static void worker1(void *data) { printf("%s\n", (char *) data); } static void worker2(void *data) { struct task_data *task_data; task_data = data; printf("%s\n", task_data-&gt;str); task_activate(task_data-&gt;next_task, "First activated"); } int main(void) { struct task *t1, *t2; struct task_data task_data; t1 = task_create(&amp;worker1, "First create"); t2 = task_create(&amp;worker2, "Second create"); task_data.next_task = t1; task_data.str = "Second activated"; task_activate(t2, &amp;task_data); scheduler(); return 0; }</span></span></span></span></code> </pre><br><br><h6>  Output Results: </h6><br>  <i>Second activated</i> <i><br></i>  <i>First activated</i> <br><br><h6>  CPU Busy Graph </h6><br><img src="//habrastorage.org/files/d61/c23/84e/d61c2384e6624800a7329e09eab37b15.png"><br><br><h5>  Non-preemptive Message Queuing Scheduler </h5><br>  The problems of the previous method are obvious: if someone wants to activate a task twice, until the task is processed, then it will fail.  Information about the second activation is simply lost.  This problem can be partially resolved with a message queue.  Instead of flags, we add an array in which message queues for each stream are stored. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define TASK_COUNT 2 struct message { void *data; struct message *next; }; struct task { void (*func)(void *); struct message *first; }; struct task_data { char *str; struct task *next_task; }; static struct task tasks[TASK_COUNT]; static struct task *task_create(void (*func)(void *), void *data) { static int i = 0; tasks[i].func = func; tasks[i].first = NULL; return &amp;tasks[i++]; } static int task_activate(struct task *task, void *data) { struct message *msg; msg = malloc(sizeof(struct message)); msg-&gt;data = data; msg-&gt;next = task-&gt;first; task-&gt;first = msg; return 0; } static int task_run(struct task *task, void *data) { struct message *msg = data; task-&gt;first = msg-&gt;next; task-&gt;func(msg-&gt;data); free(data); return 0; } static void scheduler(void) { int i; int fl = 1; struct message *msg; while (fl) { fl = 0; for (i = 0; i &lt; TASK_COUNT; i++) { while (tasks[i].first) { fl = 1; msg = tasks[i].first; task_run(&amp;tasks[i], msg); } } } } static void worker1(void *data) { printf("%s\n", (char *) data); } static void worker2(void *data) { struct task_data *task_data; task_data = data; printf("%s\n", task_data-&gt;str); task_activate(task_data-&gt;next_task, "Message 1 to first"); task_activate(task_data-&gt;next_task, "Message 2 to first"); } int main(void) { struct task *t1, *t2; struct task_data task_data; t1 = task_create(&amp;worker1, "First create"); t2 = task_create(&amp;worker2, "Second create"); task_data.next_task = t1; task_data.str = "Second activated"; task_activate(t2, &amp;task_data); scheduler(); return 0; }</span></span></span></span></code> </pre><br><br><h6>  Results of work: </h6><br>  <i>Second activated</i> <i><br></i>  <i>Message 2 to first</i> <i><br></i>  <i>Message 1 to first</i> <br><br><h6>  CPU Busy Graph </h6><br><img src="//habrastorage.org/files/ae9/afe/56c/ae9afe56cdae4da18f5b8a4fc750159e.png"><br><br><h5>  Non-displacing scheduler with call order preserved </h5><br>  Another problem with the previous examples is that the order of activation of tasks is not preserved.  In fact, each task has its own priority, which is not always good.  To solve this problem, you can create one message queue and a dispatcher that will parse it. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define TASK_COUNT 2 struct task { void (*func)(void *); void *data; struct task *next; }; static struct task *first = NULL, *last = NULL; static struct task *task_create(void (*func)(void *), void *data) { struct task *task; task = malloc(sizeof(struct task)); task-&gt;func = func; task-&gt;data = data; task-&gt;next = NULL; if (last) { last-&gt;next = task; } else { first = task; } last = task; return task; } static int task_run(struct task *task, void *data) { task-&gt;func(data); free(task); return 0; } static struct task *task_get_next(void) { struct task *task = first; if (!first) { return task; } first = first-&gt;next; if (first == NULL) { last = NULL; } return task; } static void scheduler(void) { struct task *task; while ((task = task_get_next())) { task_run(task, task-&gt;data); } } static void worker2(void *data) { printf("%s\n", (char *) data); } static void worker1(void *data) { printf("%s\n", (char *) data); task_create(worker2, "Second create"); task_create(worker2, "Second create again"); } int main(void) { struct task *t1; t1 = task_create(&amp;worker1, "First create"); scheduler(); return 0; }</span></span></span></span></code> </pre><br><br><h6>  Results of work: </h6><br>  <i>First create</i> <i><br></i>  <i>Second create</i> <i><br></i>  <i>Second create again</i> <br><br><h6>  CPU Busy Graph </h6><br><img src="//habrastorage.org/files/1d5/d6f/35b/1d5d6f35b7e647b0863b26f471ae3650.png"><br><br>  Before turning to the displacing scheduler, I want to add that the non-displacing scheduler is used in real systems, since the cost of switching tasks is minimal.  However, this approach requires a lot of attention from the programmer, he must independently ensure that tasks do not get stuck in the execution time. <br><br><h4>  Displacing scheduler </h4><br><img src="http://habrastorage.org/files/a2e/91c/229/a2e91c2298f14f10b481a5fdb3e34fc2.png" align="left">  Now let's imagine the following picture.  We have two computational threads that execute the same program, and there is a scheduler, which at an arbitrary time, before executing any instruction, can interrupt the active flow and activate the other.  To manage such tasks, there is not enough information only about the stream call function and its parameters, as is the case with non-displacing schedulers.  At a minimum, you still need to know the address of the current instruction being executed and the set of local variables for each task.  That is, for each task, you need to store copies of the corresponding variables, and since local variables for threads are located on its stack, space must be allocated for the stack of each thread, and a pointer to the current position of the stack must be stored somewhere. <br><br>  This data - instruction pointer and stack pointer - is stored in the registers of the processor.  In addition to them, other information contained in the registers is also necessary for correct operation: status flags, various general-purpose registers containing temporary variables, and so on.  All this is called processor context. <br><br><h5>  Processor context </h5><br><img src="http://habrastorage.org/files/1a8/5e0/fd3/1a85e0fd3f1e4969b883c136b0859351.png" align="right">  Processor context (CPU context) is a data structure that stores the internal state of the processor registers.  The context must allow the processor to return to the correct state in order to execute the computational flow.  The process of replacing one computational flow with another is usually called a context switch. <br><br>  Description of the context structure for the x86 architecture from our project: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x00 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eip; <span class="hljs-comment"><span class="hljs-comment">/**&lt; instruction pointer */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x04 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ebx; <span class="hljs-comment"><span class="hljs-comment">/**&lt; base register */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x08 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> edi; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Destination index register */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x0c */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> esi; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Source index register */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x10 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ebp; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Stack pointer register */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x14 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> esp; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Stack Base pointer register */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x18 */</span></span><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eflags; <span class="hljs-comment"><span class="hljs-comment">/**&lt; EFLAGS register hold the state of the processor */</span></span> };</code> </pre><br><br>  The concepts of processor context and context switching are fundamental to the concept of preemptive scheduling. <br><br><h5>  Context switch </h5><br>  Context switch - replacing the context of one thread with another.  The scheduler saves the current context and loads another into the processor registers. <br>  Above, I said that the scheduler can interrupt the active thread at any time, which somewhat simplifies the model.  In fact, it is not the scheduler that interrupts the thread, but the current program is interrupted by the processor as a result of a reaction to an external event ‚Äî a hardware interrupt ‚Äî and transfers control to the scheduler.  For example, an external event is a system timer, which counts the time slot allocated for the active flow.  If we assume that there is exactly one interrupt source in the system, the system timer, then the CPU time card will look like this: <br><img src="//habrastorage.org/files/1d5/b5e/5d4/1d5b5e5d46ee49588559e0b5565a6d39.png"><br>  The context switch procedure for the x86 architecture: <br><pre> <code class="cpp hljs"> .global context_switch context_switch: movl <span class="hljs-number"><span class="hljs-number">0x04</span></span>(%esp), %ecx <span class="hljs-comment"><span class="hljs-comment">/* Point ecx to previous registers */</span></span> movl (%esp), %eax <span class="hljs-comment"><span class="hljs-comment">/* Get return address */</span></span> movl %eax, CTX_X86_EIP(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save it as eip */</span></span> movl %ebx, CTX_X86_EBX(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save ebx */</span></span> movl %edi, CTX_X86_EDI(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save edi */</span></span> movl %esi, CTX_X86_ESI(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save esi */</span></span> movl %ebp, CTX_X86_EBP(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save ebp */</span></span> add $<span class="hljs-number"><span class="hljs-number">4</span></span>, %esp <span class="hljs-comment"><span class="hljs-comment">/* Move esp in state corresponding to eip */</span></span> movl %esp, CTX_X86_ESP(%ecx) <span class="hljs-comment"><span class="hljs-comment">/* Save esp */</span></span> pushf <span class="hljs-comment"><span class="hljs-comment">/* Push flags */</span></span> <span class="hljs-function"><span class="hljs-function">pop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EFLAGS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* ...and save them */</span></span></span><span class="hljs-function"> movl 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x04</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%esp)</span></span></span><span class="hljs-function">, %ecx </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Point ecx to next registers */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EBX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %ebx </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore ebx */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EDI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %edi </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore edi */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_ESP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %esi </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore esp */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EBP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %ebp </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore ebp */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_ESP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %esp </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore esp */</span></span></span><span class="hljs-function"> push </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EFLAGS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Push saved flags */</span></span></span><span class="hljs-function"> popf </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore flags */</span></span></span><span class="hljs-function"> movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CTX_X86_EIP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%ecx)</span></span></span><span class="hljs-function">, %eax </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Get eip */</span></span></span><span class="hljs-function"> push %eax </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* Restore it as return address */</span></span></span><span class="hljs-function"> ret</span></span></code> </pre><br><br><h6>  Flow machine </h6><br>  We discussed the important difference in the flow structure in the case of the displacing scheduler from the case of the non-preemptive scheduler - the presence of context.  Let's see what happens to the stream from its inception to its completion: <br><img src="//habrastorage.org/files/ed1/431/cc7/ed1431cc7ed64df9be05de77061b81ee.png"><br><br><ul><li>  The init state is responsible for creating the thread, but not adding it to the scheduler yet, and exit says that the thread has completed its execution, but has not yet released the memory allocated to it. </li><li>  The run state should also be obvious - the thread in this state is executed on the processor. </li><li>  The ready state indicates that the thread is not being executed, but is waiting for the scheduler to give it time, that is, it is in the scheduler queue. </li></ul><br>  But this does not exhaust the possible flow conditions.  The flow can give a quantum of time in anticipation of an event, for example, just fall asleep for a while and after that time continue execution from the place where it fell asleep (for example, the usual call to sleep). <br>  Thus, the flow can be in different states (ready for execution, terminating, in standby mode, and so on), whereas in the case of a non-preemptive scheduler, it was enough to have a flag about the activity of a particular task. <br><br>  This is how you can imagine a generalized state machine: <br><img src="//habrastorage.org/files/2f6/22a/eb8/2f622aeb8e4a4ded8924c2fe6de6eaab.png"><br>  In this scheme, a new wait state has appeared, which tells the scheduler that the thread has fallen asleep, and until it wakes up, it does not need to allocate processor time to it. <br>  Now let's take a closer look at the flow control API, as well as deepen our knowledge of flow conditions. <br><br><h6>  State implementation </h6><br>  If you look at the state diagram more closely, you can see that the init and wait states are almost the same: both can go to the ready state, that is, tell the scheduler that they are ready to receive their time slot.  Thus, the init state is redundant. <br><br>  Now look at the exit status.  This state has its own subtleties.  It is set to the scheduler in the final function, it will be discussed below.  Completion of a flow can take place in two scenarios: the first - the flow completes its main function and frees the resources it occupies, the second - the other thread takes responsibility for freeing resources.  In the second case, the thread sees that another thread will release its resources, informs it that it has completed, and transfers control to the scheduler.  In the first case, the thread frees resources and also transfers control to the scheduler.  After the scheduler has received control, the flow should never resume work.  That is, in both cases, the exit state has the same value - the thread in this state does not want to receive a new time slot, it does not need to be placed in the scheduler queue.  Conceptually, it is also no different from the wait state, so you can not start a separate state. <br><br>  Thus, we have three states.  We will store these states in three separate fields.  It would be possible to store everything in a single integer field, but to simplify the checks and by virtue of the peculiarity of the multiprocessor case, which we will not discuss here, such a decision was made.  So, the flow conditions: <br><br><ul><li>  active - started and executed on the processor </li><li>  waiting - waiting for some event.  Additionally, it replaces the init and exit states </li><li>  ready - is managed by the scheduler, i.e.  lies in the queue of ready threads in the scheduler or running on the processor.  This state is somewhat wider than the ready we see in the picture.  In most cases, active and ready, and ready and waiting are theoretically orthogonal, but there are specific transition states where these rules are violated.  I will tell about these cases below. </li></ul><br><br><h6>  Creature </h6><br>  Creating a thread includes the necessary initialization (the thread_init function) and the possible starting of the thread.  During initialization, memory is allocated for the stack, the processor context is set, the necessary flags and other initial values ‚Äã‚Äãare set.  Since during the creation we work with a queue of ready threads, which the scheduler uses at an arbitrary time, we need to block the work of the scheduler with the flow structure until the entire structure is initialized completely.  After initialization, the thread is in the waiting state, which, as we remember, is also responsible for the initial state.  After that, depending on the passed parameters, either we start the stream or not.  The start-up function is a start-up / wake-up function in the scheduler, it is described in detail below.  For now, we only say that this function places the thread in the scheduler queue and changes the waiting state to ready. <br>  So, the code of the thread_create and thread_init functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct thread *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *(*run)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ /* below we are going work with thread instances and therefore we need to * lock the scheduler (disable scheduling) to prevent the structure being * corrupted */ sched_lock(); { /* allocate memory */ if (!(t = thread_alloc())) { t = err_ptr(ENOMEM); goto out; } /* initialize internal thread structure */ thread_init(t, flags, run, arg); //‚Ä¶ } out: sched_unlock(); return t; }</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct thread *t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *(*run)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sched_priority_t</span></span> priority; assert(t); assert(run); assert(thread_stack_get(t)); assert(thread_stack_get_size(t)); t-&gt;id = id_counter++; <span class="hljs-comment"><span class="hljs-comment">/* setup thread ID */</span></span> dlist_init(&amp;t-&gt;thread_link); <span class="hljs-comment"><span class="hljs-comment">/* default unlink value */</span></span> t-&gt;critical_count = __CRITICAL_COUNT(CRITICAL_SCHED_LOCK); t-&gt;siglock = <span class="hljs-number"><span class="hljs-number">0</span></span>; t-&gt;lock = SPIN_UNLOCKED; t-&gt;ready = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;active = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;waiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;state = TS_INIT; <span class="hljs-comment"><span class="hljs-comment">/* set executive function and arguments pointer */</span></span> t-&gt;run = run; t-&gt;run_arg = arg; t-&gt;joining = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... /* cpu context init */ context_init(&amp;t-&gt;context, true); /* setup default value of CPU registers */ context_set_entry(&amp;t-&gt;context, thread_trampoline);/*set entry (IP register*/ /* setup stack pointer to the top of allocated memory * The structure of kernel thread stack follow: * +++++++++++++++ top * | * v * the thread structure * xxxxxxx * the end * +++++++++++++++ bottom (t-&gt;stack - allocated memory for the stack) */ context_set_stack(&amp;t-&gt;context, thread_stack_get(t) + thread_stack_get_size(t)); sigstate_init(&amp;t-&gt;sigstate); /* Initializes scheduler strategy data of the thread */ runq_item_init(&amp;t-&gt;sched_attr.runq_link); sched_affinity_init(t); sched_timing_init(t); }</span></span></code> </pre><br><br><h6>  Standby mode </h6><br>  A thread can give its time to another thread for some reason, for example, by calling the sleep function.  That is, the current thread goes from operation to standby mode.  If in the case of a non-preemptive scheduler, we simply set the activity flag, here we will save our stream in another queue.  The waiting thread is not put in the scheduler queue.  In order not to lose the flow, it is usually stored in a special queue.  For example, when trying to capture a busy mutex stream, before falling asleep, it puts itself in a queue of waiting mutex threads.  And when an event occurs that expects a thread, for example, the release of a mutex, it will wake it up and we will be able to return the flow back to the ready queue.  More details about waiting and pitfalls will be described below, after we deal with the code of the scheduler itself. <br><br><h6>  End flow </h6><br>  Here the thread is in the wait state.  If the thread performed the processing function and ended naturally, you need to free up resources.  I have already described this process in detail when I spoke about the redundancy of the exit state.  Let us now look at the implementation of this function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__((noreturn)) thread_exit(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ret) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_self</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_self</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">joining</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We can not free the main thread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task-&gt;main_thread == current) { <span class="hljs-comment"><span class="hljs-comment">/* We are last thread. */</span></span> task_exit(ret); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> } sched_lock(); current-&gt;waiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; current-&gt;state |= TS_EXITED; <span class="hljs-comment"><span class="hljs-comment">/* Wake up a joining thread (if any). * Note that joining and run_ret are both in a union. */</span></span> joining = current-&gt;joining; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (joining) { current-&gt;run_ret = ret; sched_wakeup(joining); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current-&gt;state &amp; TS_DETACHED) <span class="hljs-comment"><span class="hljs-comment">/* No one references this thread anymore. Time to delete it. */</span></span> thread_delete(current); schedule(); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> sched_unlock(); <span class="hljs-comment"><span class="hljs-comment">/* just to be honest */</span></span> panic(<span class="hljs-string"><span class="hljs-string">"Returning from thread_exit()"</span></span>); }</code> </pre><br><br><h5>  Springboard to call processing function </h5><br>  We have said more than once that when a thread finishes execution, it must release resources.  You don‚Äôt want to call the thread_exit function yourself - it is very rarely necessary to terminate the thread in an exceptional order, rather than naturally, after performing its function.  In addition, we need to prepare the initial context, which is also unnecessary to do every time.  Therefore, the thread starts not with the function that we specified during the creation, but with the thread_trampoline wrapper function.  It just serves to prepare the initial context and correctly terminate the flow. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__((noreturn)) thread_trampoline(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_self</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *res; assert(!critical_allows(CRITICAL_SCHED_LOCK), <span class="hljs-string"><span class="hljs-string">"0x%x"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)__critical_count); sched_ack_switched(); assert(!critical_inside(CRITICAL_SCHED_LOCK)); <span class="hljs-comment"><span class="hljs-comment">/* execute user function handler */</span></span> res = current-&gt;run(current-&gt;run_arg); thread_exit(res); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre><br><br><h5>  Summary: stream structure description </h5><br><img src="//habrastorage.org/files/4e8/38d/0a4/4e838d0a478c47bca0fdb60f5d10fe86.png" align="right">  So, to describe the problem in the case of the displacing scheduler, we need a rather complicated structure.  It contains: <br><ul><li>  information about processor registers (context). </li><li>  information on the status of the task, whether it is ready for execution or, for example, waiting for the release of a resource. </li><li>  identifier.  In the case of an array, this is an index in the array, but if streams can be added and deleted, it is better to use a queue where identifiers will be useful. </li><li>  the start function and its arguments, perhaps even the return result. </li><li>  the address of the piece of memory that is allocated for the stack, because when it exits the stream, it must be freed. </li></ul><br><br>  Correspondingly, the description of the structure in our project is as follows: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> critical_count; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> siglock; <span class="hljs-keyword"><span class="hljs-keyword">spinlock_t</span></span> lock; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Protects wait state and others. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> active; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Running on a CPU. TODO SMP-only. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ready; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Managed by the scheduler. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waiting; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Waiting for an event. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> state; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Thread-specific state. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/**&lt; Architecture-dependent CPU state. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *(*run)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/**&lt; Start routine. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *run_arg; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Argument to pass to start routine. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *run_ret; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Return value of the routine. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *joining; <span class="hljs-comment"><span class="hljs-comment">/**&lt; A joining thread (if any). */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* unnamed */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">thread_stack_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Handler for work with thread stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__thread_id_t</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/**&lt; Unique identifier. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/**&lt; Task belong to. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dlist_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_link</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/**&lt; list's link holding task threads. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigstate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigstate</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/**&lt; Pending signal(s). */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sched_attr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sched_attr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/**&lt; Scheduler-private data. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local_t</span></span> local; <span class="hljs-keyword"><span class="hljs-keyword">thread_cancel_t</span></span> cleanups; };</code> </pre><br>  The structure has fields that are not described in the article (sigstate, local, cleanups); they are needed to support full-fledged POSIX threads (pthread) and are not fundamental in this article. <br><br><h5>  Scheduler and scheduling strategy </h5><br>  Recall that now we have a flow structure, including the context, we are able to switch this context.  In addition, we have a system timer that measures time slices.  In other words, we have an environment for the work of the scheduler. <br>  The task of the scheduler is to distribute the processor time between threads.  The scheduler has a queue of ready threads, which it operates to determine the next active thread.  The rules by which the scheduler selects the next thread for execution will be called the planning strategy.  The main function of the planning strategy is to work with the queue of ready threads: add, delete and extract the next ready stream.  How these functions are implemented will determine the behavior of the scheduler.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we were able to define a separate concept - a planning strategy, we will move it into a separate entity. </font><font style="vertical-align: inherit;">We described the interface as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">, struct thread *thread)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">, struct thread *thread)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> struct thread *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_item_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_item_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *runq_link)</span></span></span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider the implementation of a planning strategy in more detail. </font></font><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample planning strategy </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example, I will analyze the most primitive planning strategy in order to focus not on the intricacies of the strategy, but on the features of the displacing scheduler. </font><font style="vertical-align: inherit;">The flows in this strategy will be processed in order of priority without regard to priority: the new flow and just completed its quantum will be placed at the end; </font><font style="vertical-align: inherit;">the thread that gets the CPU resources will be inherited from the beginning. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The queue will be a regular doubly linked list. </font><font style="vertical-align: inherit;">When we add an element, we insert it at the end, and when we get it, we take it and remove it from the beginning.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_item_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_item_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *runq_link)</span></span></span><span class="hljs-function"> </span></span>{ dlist_head_init(runq_link); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ dlist_init(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">, struct thread *thread)</span></span></span><span class="hljs-function"> </span></span>{ dlist_add_prev(&amp;thread-&gt;sched_attr.runq_link, <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">, struct thread *thread)</span></span></span><span class="hljs-function"> </span></span>{ dlist_del(&amp;thread-&gt;sched_attr.runq_link); } <span class="hljs-function"><span class="hljs-function">struct thread *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runq_extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">runq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">queue</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> thread = dlist_entry(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>-&gt;next, struct thread, sched_attr.runq_link); runq_remove(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, thread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> thread; }</code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scheduler </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we come to the most interesting - the description of the scheduler. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run Scheduler </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first stage of the scheduler is its initialization. </font><font style="vertical-align: inherit;">Here we need to provide the correct environment to the scheduler. </font><font style="vertical-align: inherit;">You need to prepare a queue of ready-made threads, add an idle stream to this queue, and start a timer that will be used to count time slots for the execution of threads. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheduler startup code:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sched_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct thread *idle, struct thread *current)</span></span></span><span class="hljs-function"> </span></span>{ runq_init(&amp;rq.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); rq.lock = SPIN_UNLOCKED; sched_wakeup(idle); sched_ticker_init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Awakening and starting a thread </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we remember from the description of the state machine, waking up and starting a thread for the scheduler is one and the same process. The call to this function is in the launch of the scheduler, where we start the idle stream. What actually happens when you wake up? First, the note that we are waiting is removed, that is, the thread is no longer in the waiting state. Then there are two options: have we managed to fall asleep or not yet. Why this happens, I will describe in the next section ‚ÄúWaiting‚Äù. If you do not have time, then the thread is still in the ready state, and in this case, the awakening is completed. Otherwise, we put the stream in the scheduler queue, remove the waiting status, put ready. In addition, rescheduling is called if the priority of the awakened thread is greater than the current one. Pay attention to various locks: the whole action occurs when interrupts are disabled.In order to see how the awakening and launch of the thread occurs in the case of SMP, I advise you to refer to the project code.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Locks: IPL, thread. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __sched_wakeup_ready(struct thread *t) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ready; spin_protected_if (&amp;rq.lock, (ready = t-&gt;ready)) t-&gt;waiting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ready; } <span class="hljs-comment"><span class="hljs-comment">/** Locks: IPL, thread. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __sched_wakeup_waiting(struct thread *t) { assert(t &amp;&amp; t-&gt;waiting); spin_lock(&amp;rq.lock); __sched_enqueue_set_ready(t); __sched_wokenup_clear_waiting(t); spin_unlock(&amp;rq.lock); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __sched_wakeup_smp_inactive(struct thread *t) { __sched_wakeup_waiting(t); } <span class="hljs-comment"><span class="hljs-comment">/** Called with IRQs off and thread lock held. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __sched_wakeup(struct thread *t) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> was_waiting = (t-&gt;waiting &amp;&amp; t-&gt;waiting != TW_SMP_WAKING); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (was_waiting) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!__sched_wakeup_ready(t)) __sched_wakeup_smp_inactive(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> was_waiting; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sched_wakeup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct thread *t)</span></span></span><span class="hljs-function"> </span></span>{ assert(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPIN_IPL_PROTECTED_DO(&amp;t-&gt;lock, __sched_wakeup(t)); }</code> </pre><br><br><h6>  Expectation </h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The transition to the standby mode and the correct exit from it (when the expected event finally happens) is probably the most difficult and delicate thing in the preemptive planning. Let's look at the situation in more detail.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, we have to explain to the scheduler that we want to wait for an event, and the event is naturally asynchronous, and we need to get it synchronously. Therefore, we need to specify how the scheduler determines that an event has occurred. At the same time, we do not know when it can happen, for example, we managed to tell the planner that we were waiting for an event, checked that the conditions for its occurrence had not yet been met, and at that moment a hardware interrupt occurs, which our event generates. But since we have already completed the test, this information will be lost. In our project, we solved this problem as follows. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting Macro Code</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCHED_WAIT_TIMEOUT(cond_expr, timeout) \ ((cond_expr) ? 0 : ({ \ int __wait_ret = 0; \ clock_t __wait_timeout = timeout == SCHED_TIMEOUT_INFINITE ? \ SCHED_TIMEOUT_INFINITE : ms2jiffies(timeout); \ \ threadsig_lock(); \ do { \ sched_wait_prepare(); \ \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cond_expr) \ break; \ \ __wait_ret = sched_wait_timeout(__wait_timeout, \ &amp;__wait_timeout); \ } while (!__wait_ret); \ \ sched_wait_cleanup(); \ \ threadsig_unlock(); \ __wait_ret; \ }))</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The flow can be immediately in the superposition of states. </font><font style="vertical-align: inherit;">That is, when the thread falls asleep, it is still active and only sets an additional waiting flag. </font><font style="vertical-align: inherit;">During the awakening again this flag is simply removed, and only if the thread has already managed to reach the scheduler and leave the queue of ready streams, will it be added there again. </font><font style="vertical-align: inherit;">If we consider the situation described earlier in the picture, we get the following picture. </font></font><br><img src="//habrastorage.org/files/0b0/c8a/d3d/0b0c8ad3d9ef4ef4bf8f81f682ad9d01.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A - active </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R - ready </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W - wait </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the picture, the letters indicate the presence of states. </font><font style="vertical-align: inherit;">Light green is the state of the thread before the wait_prepare, green is after the wait_prepare, and dark green is the call for the replanning. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the event does not have time to occur before rescheduling, then everything is simple - the stream will fall asleep and will await awakening:</font></font><br><img src="//habrastorage.org/files/147/b10/f86/147b10f866784c958185b62f170c8077.png"><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rescheduling </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main task of the scheduler is planning, I apologize for the tautology. And we finally came to the moment when you can disassemble how this process is implemented in our project. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, rescheduling should be done with the scheduler locked. Secondly, we want to give the opportunity to allow the displacement of the stream or not. Therefore, we carried the logic of the work into a separate function surrounded its call with locks and called it indicating that in this place we do not allow repression.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next come the actions with the queue of ready threads. If the thread that is active at the time of rescheduling is not going to fall asleep, that is, if it does not have the waiting status, we will simply add it to the scheduler's thread queue. Then we retrieve the highest priority thread from the queue. The rules for finding this stream are implemented using a scheduling strategy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, if the current active thread is the same as the one we got from the queue, we do not need rescheduling and we can simply exit and continue the flow. In the case if rescheduling is required, the function sched_switch is called, in which the actions necessary for the scheduler are performed and the main thing called the context_switch which we considered above.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the thread is going to fall asleep, is in the waiting state, then it does not fall into the scheduler queue, and the ready tag is removed from it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, signal processing occurs, but as I noted above, this is beyond the scope of this article.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sched_switch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct thread *prev, struct thread *next)</span></span></span><span class="hljs-function"> </span></span>{ sched_prepare_switch(prev, next); trace_point(__func__); <span class="hljs-comment"><span class="hljs-comment">/* Preserve initial semantics of prev/next. */</span></span> cpudata_var(saved_prev) = prev; thread_set_current(next); context_switch(&amp;prev-&gt;context, &amp;next-&gt;context); <span class="hljs-comment"><span class="hljs-comment">/* implies cc barrier */</span></span> prev = cpudata_var(saved_prev); sched_finish_switch(prev); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __schedule(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> preempt) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ipl_t</span></span> ipl; prev = thread_self(); assert(!sched_in_interrupt()); ipl = spin_lock_ipl(&amp;rq.lock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preempt &amp;&amp; prev-&gt;waiting) prev-&gt;ready = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> __sched_enqueue(prev); next = runq_extract(&amp;rq.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); spin_unlock(&amp;rq.lock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev != next) sched_switch(prev, next); ipl_restore(ipl); assert(thread_self() == prev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prev-&gt;siglock) { thread_signal_handle(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sched_lock(); __schedule(<span class="hljs-number"><span class="hljs-number">0</span></span>); sched_unlock(); }</code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifying multithreading </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As an example, I used the following code: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;errno.h&gt; #include &lt;stdio.h&gt; #include &lt;util/array.h&gt; #include &lt;kernel/thread.h&gt; #include &lt;framework/example/self.h&gt; /** * This macro is used to register this example at the system. */ EMBOX_EXAMPLE(run); /* configs */ #define CONF_THREADS_QUANTITY 0x8 /* number of executing threads */ #define CONF_HANDLER_REPEAT_NUMBER 300 /* number of circle loop repeats*/ /** The thread handler function. It's used for each started thread */ static void *thread_handler(void *args) { int i; /* print a thread structure address and a thread's ID */ for(i = 0; i &lt; CONF_HANDLER_REPEAT_NUMBER; i ++) { printf("%d", *(int *)args); } return thread_self(); } /** * Example's executing routine * It has been declared by the macro EMBOX_EXAMPLE */ static int run(int argc, char **argv) { struct thread *thr[CONF_THREADS_QUANTITY]; int data[CONF_THREADS_QUANTITY]; void *ret; int i; /* starting all threads */ for(i = 0; i &lt; ARRAY_SIZE(thr); i ++) { data[i] = i; thr[i] = thread_create(0, thread_handler, &amp;data[i]); } /* waiting until all threads finish and print return value*/ for(i = 0; i &lt; ARRAY_SIZE(thr); i ++) { thread_join(thr[i], &amp;ret); } printf("\n"); return ENOERR; }</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, this is almost a normal application. The EMBOX_EXAMPLE (run) macro sets the entry point to the specific type of our modules. The thread_join function waits until the thread is complete, until I also considered it. And so it happened a lot for one article. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of running this example on qemu as part of our project is the following. </font></font><br><img src="//habrastorage.org/files/a27/8a7/397/a278a73976e849a7989639fc320c5b01.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the results, the first threads created are executed one by one, the scheduler gives them time in turn. At the end of some discrepancy. I think this is a consequence of the fact that the scheduler has a rather rough accuracy (not comparable with the output of one character on the screen). Therefore, in the first passes, the threads manage to perform a different number of cycles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, who wants to play, you can </font></font><a href="https://github.com/embox/embox"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">download the project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and try all of the above in practice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the topic is interesting, I will try to continue the story about planning, there are still quite a few topics left open.</font></font></div><p>Source: <a href="https://habr.com/ru/post/219431/">https://habr.com/ru/post/219431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219419/index.html">Suggestions for learning programming language</a></li>
<li><a href="../219423/index.html">System and business intelligence in anticipation of the most significant event of the sphere!</a></li>
<li><a href="../219425/index.html">Adventure game that is played by changing its Javascript code</a></li>
<li><a href="../219427/index.html">Overview of 6 Budget Wheel Platforms for Ebay Robots</a></li>
<li><a href="../219429/index.html">Platform for video service for a quarter</a></li>
<li><a href="../219435/index.html">Filtering the blacklist of sites by URL</a></li>
<li><a href="../219437/index.html">The quality of transposing samples in Ableton Live 8 tools and free plugins</a></li>
<li><a href="../219439/index.html">Strange Analytical Beast Axiom</a></li>
<li><a href="../219441/index.html">Getting started with the graph database Neo4j</a></li>
<li><a href="../219443/index.html">10 Gbps Wi-Fi announced in 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>