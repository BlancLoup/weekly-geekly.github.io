<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modern aspects of the presentation of texts in the analysis of natural language: classical and alternative approaches</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In computer science, the topic of natural language processing is becoming increasingly popular from year to year. Due to the huge numbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modern aspects of the presentation of texts in the analysis of natural language: classical and alternative approaches</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In computer science, the topic of natural language processing is becoming increasingly popular from year to year.  Due to the huge number of tasks that require such an analysis, it is difficult to overestimate the need for automatic processing of text documents. <br><br>  In this article, we will as simple as possible try to describe the most popular modern approaches to the presentation of text documents for computer processing.  And on one of them, which is currently not yet widespread, but it has every chance, let's stop in more detail, because we use this method in <a href="http://slickjump.com/">SlickJump</a> when developing algorithms, for example, <a href="http://marketing-wiki.ru/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25BC%25D0%25B0">contextual advertising targeting</a> . <br><br>  Note that the presented approaches are applicable not only to texts, but in general to any objects that can be represented as symbolic sequences, for example, some macromolecules (DNA, RNA, proteins) from genetics.  We consider a total of 4 methods: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Sign description. </li><li>  Pairwise overlay (alignment) of texts. </li><li>  Forming a profile and a hidden Markov model. </li><li>  Representation by fragments. </li></ol><br>  So let's get started. <br><a name="habracut"></a><br><h4>  Feature Description </h4><br>  The feature description is an approach that can be called a classic when analyzing a natural language.  It implies that a certain number of features are distinguished from the analyzed text documents, for example, words, or pairs of consecutive words (the so-called bigrams).  You can filter for signs, for example, by frequency of occurrence in a set of documents, or remove from the list those that are of no interest - for example, prepositions or conjunctions (‚Äústop words‚Äù).  Further, each document is characterized by the number of occurrences of these attributes in it, or, for example, by their presence / absence, which is conveniently represented as a vector, where each element corresponds to a specific attribute.  Their order, of course, must be fixed in advance.  Note that an important task is to identify the same signs in different forms - for example, it is convenient to assume that ‚ÄúKatya‚Äù and ‚ÄúKatya‚Äù are one and the same attribute.  For this purpose, processes of stemming are used, in which only the basics of words are considered (most often, roots, and prefixes, suffixes, endings are discarded) or lemmatization, when all words are reduced to ‚Äúnormal form‚Äù, for example, nouns in Russian are conveniently reduced to case in the singular.  The second process is almost always more difficult, it is often necessary to have a base of word forms (without them, for example, the word ‚Äúpeople‚Äù does not get the normal form ‚Äúperson‚Äù), whereas for the first process a list of word conversion rules is sufficient for many languages. <br><br>  For example, let us be given a text taken from N. Gumilyov's beautiful poem ‚ÄúGiraffe‚Äù: <br><blockquote>  Listen: far, far away, on Lake Chad <br>  Exquisite wandering giraffe. </blockquote>  Select the signs from here (we will use only separate words), lemmatizing them, we get the following set: <br><br>  <i>(listen, far, lake, chad, exquisite, wander, giraffe)</i> <br><br>  The preposition "on" is not taken as a stop word.  If we now present the first line of the text given to us in a vector form based on the above list, we get the following vector: <br><br>  <i>(1, 2, 1, 1, 0, 0, 0)</i> <br><br>  The resulting vectors can be combined into a matrix, measure different distances (of which there are a great many) between them, apply frequency conversion techniques to them (TF-IDF, for example - but in this case, the number of features and documents should be sufficient for its adequate operation). <br><br><h4>  Overlay sequences, forming profiles </h4><br>  In some tasks, an approach is used which consists in the pairwise superposition (alignment) of symbol sequences.  The essence of this method is to maximize the number of positions in which the matching characters of the sequences are located, while the sequences themselves can be ‚Äúbroken‚Äù.  This approach is actively used in tasks of bioinformatics, where macromolecules, for example, DNA act as sequences of symbols, and usually such that some of them are the results of changes in others, for example, historical modifications.  It is often assumed that all compared sequences have a common ancestor.  For this approach, several proximity measures have been developed, generating distance matrices, with which further work is being conducted. <br><br>  In addition, there is a method that involves the formation of a profile and a hidden Markov model for text documents.  This approach is again based on the imposition of sequences, but not in pairs, but in the plural.  Positions in which all sequences are involved are highlighted separately.  The hidden Markov model is the development of this approach, suggesting that sequences are generated by transitions between its states.  At each transition with certain probabilities its symbols are formed.  This method is not widely used, because we will dwell on such a brief description of it. <br><br><h4>  Fragment view </h4><br>  And finally, the last approach, on which we will stop attention, is a fragmentary description of the texts.  In this approach, so-called annotated suffix trees are used.  An annotated suffix tree (ASD) is a data structure used to compute and store all text fragments along with their frequencies.  It is defined as the root tree (that is, one vertex in it is selected and is called the root), in which each node corresponds to one symbol and is marked by the frequency of the text fragment that encodes the path from the root to this node. <br>  When using the SDA, all text is divided into lines - strings of characters.  As a rule, one line is formed from 2-4 consecutive words.  An example of an SDA for a short string <img height="12" src="https://habrastorage.org/getpro/habr/post_images/a0e/dff/cc3/a0edffcc3882739b342ab0ce3201bd37.png">  shown in the image below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e3/e70/acd/4e3e70acdf623342af08f9deaf6510ad.png"><br><br>  Suffix Length <img height="12" src="https://habrastorage.org/getpro/habr/post_images/e29/fa1/e88/e29fa1e88b070e043e799ed3a3c2d8b3.png">  lines <img height="12" src="https://habrastorage.org/getpro/habr/post_images/afb/882/e89/afb882e892819f6590d222d8232ef00d.png">  lengths <img height="12" src="https://habrastorage.org/getpro/habr/post_images/1b9/e53/b69/1b9e53b69796a5dc18e8f66dfe78f910.png">  ( <img height="12" src="https://habrastorage.org/getpro/habr/post_images/6db/a4c/a58/6dba4ca581fda7b38f84f60aa079d5d3.png">  ) consisting of characters <img height="12" src="https://habrastorage.org/getpro/habr/post_images/eaa/df0/5b2/eaadf05b2e7c04d87d6e619a568b62b5.png">  is called a substring <img height="12" src="https://habrastorage.org/getpro/habr/post_images/2f2/ee1/50e/2f2ee150e4f17351fa06949cfd674f19.png">  .  For example, for the string <img height="12" src="https://habrastorage.org/getpro/habr/post_images/b21/1dd/949/b211dd9493d3138fbd260aa25b3019c1.png">  suffix length 2 will be a substring <img height="12" src="https://habrastorage.org/getpro/habr/post_images/d07/744/cb3/d07744cb3c39026d862f907098b08917.png">  .  We give an informal description of the algorithm for constructing ASD on a given string <img height="12" src="https://habrastorage.org/getpro/habr/post_images/fb3/d18/511/fb3d18511c4de6b35b03982c8efc48e9.png">  . <br><br><ol><li>  Initialize an empty structure for storing ASD - <img height="12" src="https://habrastorage.org/getpro/habr/post_images/31f/cf6/aa3/31fcf6aa37ac64b417eedad122396cc9.png">  .  This structure should be able to store a tree with symbols and numbers (their frequency) in nodes. </li><li>  Find all suffixes strings: <img height="20" src="https://habrastorage.org/getpro/habr/post_images/830/977/494/8309774949ecb080697e990a251b81cd.png">  . </li><li>  For each suffix <img height="12" src="https://habrastorage.org/getpro/habr/post_images/7f8/5f5/1c0/7f85f51c0b55cc1abe6649c97016efda.png">  looking in <img height="12" src="https://habrastorage.org/getpro/habr/post_images/31f/cf6/aa3/31fcf6aa37ac64b417eedad122396cc9.png">  such a path from the root that the coincidence with the beginning of the suffix is ‚Äã‚Äãas long as possible - <img height="20" src="https://habrastorage.org/getpro/habr/post_images/7ab/e9a/b22/7abe9ab2286cb4096591cd6465665692.png">  .  For all characters matched <img height="20" src="https://habrastorage.org/getpro/habr/post_images/7ab/e9a/b22/7abe9ab2286cb4096591cd6465665692.png">  , we increase the frequency of the corresponding nodes by 1. </li><li>  If a match <img height="20" src="https://habrastorage.org/getpro/habr/post_images/7ab/e9a/b22/7abe9ab2286cb4096591cd6465665692.png">  less length <img height="12" src="https://habrastorage.org/getpro/habr/post_images/e29/fa1/e88/e29fa1e88b070e043e799ed3a3c2d8b3.png">  it means that the suffix is ‚Äã‚Äãnot complete.  Then in <img height="12" src="https://habrastorage.org/getpro/habr/post_images/31f/cf6/aa3/31fcf6aa37ac64b417eedad122396cc9.png">  it is necessary to create new nodes by assigning them a frequency of 1. <br></li></ol><br>  When constructing an ASD for two or more lines, the suffixes of all the lines are sequentially superimposed on the common tree.  Thus, by presenting a document in the form of a set of lines, one can construct for it an appropriate ASD. <br>  ASD, built for the document, allows you to successfully solve such a problem as finding the proximity of a line and a document.  This task is called the task of determining the degree of occurrence of a substring in a tree.  We present its solution (proposed and described in detail in [3]). <br><br>  We introduce the concept of conditional probability of a node <img height="12" src="https://habrastorage.org/getpro/habr/post_images/fd6/062/cba/fd6062cbaae2d81ffef805975d72376c.png">  in ASD <img height="12" src="https://habrastorage.org/getpro/habr/post_images/31f/cf6/aa3/31fcf6aa37ac64b417eedad122396cc9.png">  with root top <img height="12" src="https://habrastorage.org/getpro/habr/post_images/bd1/806/168/bd1806168468ad0be4dd8997694d51f3.png">  .  Node frequency <img height="12" src="https://habrastorage.org/getpro/habr/post_images/fd6/062/cba/fd6062cbaae2d81ffef805975d72376c.png">  denote by <img height="20" src="https://habrastorage.org/getpro/habr/post_images/bd6/ec6/e64/bd6ec6e6462c4c07d22dde89f533166e.png">  .  Then the conditional probability of a node is: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73d/ab6/54e/73dab654ee458d947ab68c00879e5f62.png"><br><br>  Where <img height="20" src="https://habrastorage.org/getpro/habr/post_images/26a/b05/8bb/26ab058bb9a759e5247b24f2b8153fdd.png">  - ancestor node <img height="12" src="https://habrastorage.org/getpro/habr/post_images/fd6/062/cba/fd6062cbaae2d81ffef805975d72376c.png">  in a tree <img height="12" src="https://habrastorage.org/getpro/habr/post_images/31f/cf6/aa3/31fcf6aa37ac64b417eedad122396cc9.png">  .  For those vertices for which the root is an ancestor <img height="12" src="https://habrastorage.org/getpro/habr/post_images/bd1/806/168/bd1806168468ad0be4dd8997694d51f3.png">  formula <img height="20" src="https://habrastorage.org/getpro/habr/post_images/5a9/121/952/5a912195288a6a7b72764f717ce80081.png">  takes the form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9a/330/41b/d9a33041b8df286bb83ec3460345799e.png"><br><br>  where many <img height="20" src="https://habrastorage.org/getpro/habr/post_images/e58/27d/c58/e5827dc58d4cfc5720c3e91e6bde0e52.png">  there is nothing more than the set of all nodes on the first level of the tree. <br><br>  For each suffix <img height="12" src="https://habrastorage.org/getpro/habr/post_images/6cd/308/5f8/6cd3085f83cda1704f38a15dd992a169.png">  lines <img height="12" src="https://habrastorage.org/getpro/habr/post_images/9c8/2d2/b17/9c82d2b17637425e6d4d51b3ab8d65bd.png">  estimate of the degree of its entry into the tree is expressed as the sum of the conditional probabilities of nodes belonging to the maximum match <img height="30" src="https://habrastorage.org/getpro/habr/post_images/7a2/3a8/9a9/7a23a89a93370332438c911e4429355b.png">  lengths <img height="20" src="https://habrastorage.org/getpro/habr/post_images/792/b66/25b/792b6625b00a38738e87a41bc2ec5c4c.png">  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b6/916/2c8/0b69162c8844fe7d3a6c8f5195865311.png"><br><br>  Then the assessment of the degree of occurrence of a row in the tree is defined <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/2ab/c8e/b612abc8e4bd0d43e26725ac2ba9a24a.png"><br><br>  When comparing the degree of occurrence of a string in two or more ASD formulas <img height="20" src="https://habrastorage.org/getpro/habr/post_images/54b/5b8/992/54b5b8992306fa7682070845959130f8.png">  must be modified by dividing by the length of the occurrence found. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e86/69a/6be/e8669a6bebf2669ff52b3940c54e1021.png"><br><br>  If you practice and calculate according to this formula the degree of occurrence in the ASD of some rows in the tree shown in the figure above, we will get the following label: <br><table><tbody><tr><th>  Line </th><th>  The degree of entry of the string in the tree </th></tr><tr><td>  JAVASCRIPT </td><td>  0.083 </td></tr><tr><td>  Jeep </td><td>  0.125 </td></tr><tr><td>  SLICKJUMP </td><td>  0.111 </td></tr><tr><td>  Jk </td><td>  0.291 </td></tr><tr><td>  Juke </td><td>  0.125 </td></tr></tbody></table>  The algorithm for constructing the ASD, given above, is not optimal.  At present, algorithms based on classical methods of working with strings, for example, the Ukkonen algorithm for searching for a substring in a string (for which you can read in [4]) are more often used to build ASD.  This allows you to reduce the time spent on the construction of the ASD, and on the calculation of the assessment of the occurrence of a string in the ASD.  Another direction - reducing the required memory resources.  This can be achieved by applying various data structures to store trees, for example, special arrays. <br><br><h4>  Benefits </h4><br>  We note the advantages of this approach in comparison with the attribute method.  Characteristic approaches feel the deep "structure" of the text much worse, even when using digrams as signs (or even longer sequences of words - trigrams, etc., which, by the way, greatly increases the dimension of the vectors).  In addition, a fragmentary approach does not require bringing words to normal forms (if it, of course, uses only the transformation rules, and not the word form base) - if the word is included in the SDA, then its basis will obviously be located in the SDA on some branches.  But the most important thing is that the fragmentary approach is tolerant of minor errors in the texts.  Of course, there are special methods that allow to teach this and attribute approaches, but this often complicates the algorithms very much.  Let us explain in more detail by the example of a specific example from our company. <br><br>  The technology of contextual targeting of partner store products in SlickJump is based on the probabilistic thematic model LDA (Dirichlet hidden placement) that works with features.  In general, probabilistic thematic modeling is a separate extensive and interesting topic; if we do, we will not go into this article.  We only note that this approach allows us to solve the problem of finding the degrees of document proximity (i.e., the context and the goods offered), and solve it for a huge number of documents - and there are more than 2 million goods of partner stores in our company's bases. <br><br>  But for contextual targeting of banners, the number of which is incomparably smaller than the number of products in partner online stores, we use a specially developed model based on the SDA method.  This allows you to give good quality contextual targeting even where people write like chicken paw - for example, on forums.  Consider an example. <br><br>  Let us have electronics store banners offering fashionable accessories for smartphones with discounts.  And a forum about mobile technology as an advertising platform.  The advertiser specifies a list of keywords for his banners or gives it to us (which is convenient, when the number of banners is in the thousands, we have the corresponding functionality).  We need to pick relevant banners (usually a web page, forum post, etc.) banners.  Let's compare two contextual targeting models: LDA (based on features) and our model based on ASD, and find out whether relevant banners will be found in two different situations: when people write correctly and when they make mistakes. <br>  If all people had written without errors, there would never have been any problems with contextual targeting.  If there is a key word ‚Äúcharger‚Äù, and in the text of the messages somewhere ‚Äúcharging‚Äù is indicated, then there will be no problems with targeting due to the process of normalization of signs.  The screenshot below shows that both models found relevant banners. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a48/1d3/3a8a481d3fb0a0bad08995aac0edf781.png"><br><br>  But if a person wrote hts instead of htc (although a primitive example, but a classic of the genre), everything is much more interesting.  Let's try to find banners relevant to this word.  The LDA model, based on an indicative approach without special adaptations, will not find anything (or nothing adequate, which is also bad).  A method based on the ASD, gives an excellent result, despite the fact that the word has a whole one error on just three letters.  This is shown in the screenshot below, which shows the corresponding product names found on request. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/593/a8a/389/593a8a3899746f1e94b0135c79c53fb5.png"><br><br><h4>  Conclusion </h4><br>  Of course, the approach using the SDA will not solve the problems of synonymy and homonymy that are complex for a natural language, so the panacea for everything is not.  In addition, the degree of entry of a row into a tree, which is necessary for calculating the relevance, is calculated in a time dependent on the length of this row - the longer the row, the greater the time.  And with a primitive approach, such verification should be done in the SDA for all documents.  But in SlickJump we use special data structures of higher order, which allow to determine the list of candidates for relevant among all documents and check the degree of entry only into them without loss of quality, not to search where there is obviously nothing to find.  We are actively working in this direction, there is much that can be improved. <br><br>  We have no doubt that the fragmentary method for presenting texts in the coming years will actively develop and develop in many directions.  And in the next articles we will review modern algorithms for constructing and representing annotated suffix trees. <br><br><h4>  References for reading on the topic </h4><br><ol><li>  Manning K. D., Raghavan P., Schutz H. Introduction to information retrieval.  M .: Williams, 2011 </li><li>  Mirkin, B. G. Cluster Analysis Methods for Decision Support: An Overview.  M .: Publishing House of the National Research University "Higher School of Economics", 2011 </li><li>  Mirkin B. G., Chernyak E. L., Chugunova O. N. An annotated suffix tree method for estimating the degree of occurrence of lines in text documents.  Business Informatics.  2012. V. 3. No. 21. P. 31-41. </li><li>  Dubov MS, Chernyak EL. Annotated suffix trees: implementation features.  In the book: Reports of the All-Russian Scientific Conference AIST-2013 / Ed.  Ed .: E. L. Chernyak;  scientific  Ed .: D.I. Ignatov, M.Yu. Khachai, O. Barinova.  M .: National Open University "INTUIT", 2013. S. 49-57. </li><li>  Mirkin BG, Core Concepts of Data Analysis.  Springer, 2012 </li><li>  Korshunov A, Gomzin A. Thematic modeling of texts in natural language.  Proceedings of ISP RAS.  2012. No.  P.215-244. </li><li>  Steven Bird, Ewan Klein, Edward Loper.  Natural Language Processing with Python.  OReilly Media, 2009 </li></ol></div><p>Source: <a href="https://habr.com/ru/post/227199/">https://habr.com/ru/post/227199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227185/index.html">Development for Microsoft SQL Server: Unix way</a></li>
<li><a href="../227189/index.html">Hola: principles of work</a></li>
<li><a href="../227193/index.html">Creating offline maps for iOS applications</a></li>
<li><a href="../227195/index.html">Reflections on the blues - once again about exception handling</a></li>
<li><a href="../227197/index.html">Porting a Windows 8.1 application to Windows Phone 8.0 with troubleshooting</a></li>
<li><a href="../227201/index.html">Own WebGL engine. Article number 1. Canvas</a></li>
<li><a href="../227203/index.html">Migration and Coexistence of Mail Systems</a></li>
<li><a href="../227205/index.html">Autotiling: automatic tile transitions</a></li>
<li><a href="../227209/index.html">The line between the cargo cult and the evolution in learning success</a></li>
<li><a href="../227211/index.html">Increase website conversion: How to use cognitive beliefs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>