<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DMA in general and in particular</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Would know where you fall, would spread straws 
 The existence of DMA (Direct Memory Access) - Russian-language PDP (Direct Memory Access), many devel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DMA in general and in particular</h1><div class="post__text post__text-html js-mediator-article"><h5>  Would know where you fall, would spread straws </h5><br>  The existence of DMA (Direct Memory Access) - Russian-language PDP (Direct Memory Access), many developers of embedded devices have heard, but they use it much less frequently than it (PDP) deserves.  By the way, I will mention this abbreviation, not because I am such a stubborn patriot and opponent of English-language borrowings, but only because I am too lazy to switch the keyboard layout once again. <br><br>  There are three main reasons for insufficient use of the RAP in MK programs: 1) the relative complexity of this device, which, together with 2) lack of understanding of the benefits of its use, leads to the unwillingness of this device to study and master (as they say in such cases, the older sister does not order - for those who is in the tank is about the laziness that was born before us), burdened by 3) the lack of good and understandable examples of the use of PDP in manuals supplied with the MC.  And if the first two reasons are clearly subjective, then the third one is undoubtedly objective and paranoid wakes up inside me and insists that it was done specifically to prevent domestic developers of the MC at advanced levels, somewhere above 60 (the fact that and the rest of the developers around the world, paranoid is ignored, because either 1) the right examples are distributed outside of Russia, or 2) for the great purpose of not getting up, you know who, from the knees of the burzhuiny are ready to go for any  rtvy). <br><br>  Nevertheless, no joke, indeed, in the examples, at best, there is a setup module for a single PDP channel, and you will not find a coherent system with a PDP driver (you will not find an even reason in CMSIS, I‚Äôll write a post about I will mention it).  Why, in fact, I don‚Äôt know, but the crystal developers know better, the only rational justification that comes to my mind is that the PDPs are quite specific, so ‚Äúyou can‚Äôt just transfer the code from another source, but because the low demand for RAPs in real-world development; the absence of such examples is not considered a significant drawback.  This post is filled with the knowledge gap indicated by me (an indiscreet statement, but if you do not praise yourself, you go all day as a spat), so those whom I intrigued can press a button. <br><a name="habracut"></a><br>  Nevertheless, I must warn the impatient reader that he will not find a silver bullet here, which can be safely included in his designs, and only (but this is not a little) will find some thoughts and approaches that will facilitate his construction of his own systems on the MC with using the RAP.  That is, I will check the boxes in those places where the rake lies exactly, but I do not guarantee that there will be no unlabeled rake, which, however, does not prevent you from throwing up the flags in the FIG and walk on the rake yourself.  In general, those who read my posts probably noticed that I was not focusing on what should be done and how, but why I would recommend to do so. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the PDP is a part of the MC hardware that allows data transfer between different components of a given MC (and the system with its participation) without using processor resources (more precisely, with minimal involvement, since doing anything in the MC system WITHOUT processor involvement - a bold and far-flung thought. <br><br>  The main idea of ‚Äã‚Äãthese devices is that when executing a program, not every command causes a system bus to access external devices or main memory (access to program memory is not considered), so the device serving the system bus has idle cycles that it would be nice to use something. <br><br>  Another reason contributing to the creation of the RAP was the appearance of fast-acting I / O devices, the maintenance of which in terms of poling required a significant amount of CPU time, and the maintenance of interrupts was almost impossible.  The so-called peripheral processors in the architecture of mainframes with local memory should be considered the forerunners of the PDP, which were then transformed into real PDPs that solve data transfer problems between high-speed I / O devices and the main RAM and are part of the hardware that controls a specific external device. <br><br>  There was a picture (for example, in the Far Eastern Military Committee), when one WU worked according to the RAP, and the second - by interruptions or even in the polling cycle (the MX driver, if anyone remembers).  When the first MKs appeared in which the memory was integrated into the chip, the creation of external devices with PDP in relation to the chip became a very nontrivial task and, naturally, the PDP migrated inside the MC and became part of its architecture.  This process did not have a linear progressive character and can be found in both the MK based on the 51st architecture with support for the RAP and the MK based on the Cortex-M3 with a rich set of peripherals, but without the support of the RAP (for example, Stellaris).  Nevertheless, in most modern MCs based on the ARM RAP is present and we can proceed to study them and, to begin, dwell on the consideration of their features. <br><br>  As mentioned above, the main purpose of the RAP is to transfer data between different devices with minimal processor involvement.  As a rule, one of these devices is the main memory of the MC, although sometimes it is possible to transfer between two external devices and from memory to memory.  Some PDPs support such capabilities, some are not, and this should be considered when choosing a MC. <br><br>  The next important characteristic is the number of simultaneously serviced transmission channels - in the sense, of course, that only one piece of data can be transmitted over the bus at a time, but there can be several requests that will be serviced alternately, again with minimal CPU resources.  Naturally, the minimum number of PDP-1 channels (smaller number of channels will hardly be efficient), the maximum number is practically unlimited, the number of external devices + 1 (for memory-memory requests) can be a real limitation, but nothing (except for cost) can prevent make us as many channels as you like. <br><br>  The following feature can be considered as a mechanism for servicing requests in one channel.  Let us dwell on this moment in more detail and analyze in general terms the work of one request for one PDP channel. <br><br>  In order to complete the transfer, we should inform the RAP about our intentions, that is, from where we want to transfer data, where they should be sent, how much data should be transferred, transfer modes (more on that later), and possibly proprietary information.  We can put this information either in the registers responsible for the operation of the RAP (the outdated method and then we will understand why) or in the operational memory of the system, and in the latter case it must be either a special dedicated area of ‚Äã‚Äãmemory so that the RAP knows where to get the information , or in some kind of the PDP register, information should be placed on where the data is located in the RAM (in the usual language, we should place the link).  It is the latter method that is used because it has the following advantages: the MK's RAM is a valuable resource and it is not good practice to segment it into deterministic blocks. <br><br>  So, after the specified transfer is made, we will receive a signal about the end of the transfer (most likely in the form of an interrupt) and we may well need to start the next transfer as soon as possible.  If we set the transfer parameters in registers, then either we cannot modify them until the end of the current transfer, or make shadow registers.  If the register contains a link to the data defining the transfer (TCB - Transfer Control Block - Transfer Control Unit - BUP), then we can configure the BUP in advance for the next transfer and at the end of the current transfer just change the link in the PDP register . <br><br>  In practice, there are various combined schemes, mainly to save MK equipment - a pointer to a memory area in which 2 or more PCBs are located, cyclically switching as they are executed, a pointer to the next PCB in the service field of the current PCB, hierarchical access when the PCB contains indications of the PCB sequence, which are actually executed and so on. <br><br>  In the cases described above, we will also need a special tag, indicating the completion of all the programs requested so far, which will be among the proprietary information.  Among other overhead information, there are often tags that indicate the transfer mode (the width of the transmitted data, the step and direction of changing the addresses of the receiver and the sender, information for the memory management module ...). <br><br>  We now turn from consideration of the PDP in general to the consideration of a specific implementation, namely, to Milandr‚Äôs company MK 1986EV1T. <br><br>  Why precisely to him?  Well, firstly, I work with him, secondly, he has a fairly rich PDP, and thirdly, he has rich features (this is not a bug, this is such a feature - yes, it is from this category) that make working with MCs is a fascinating occupation, after which work with counterparts from well-known manufacturers will seem easy and simple. <br><br>  First, about good - PDP supports 32 independent access channels - one for each external device as part of the MC and one more for memory-to-memory transfers.  In addition, as you already understood from the previous sentence, the PDP supports all possible transfer modes, namely: WU-memory registers, WU-registers, WU registers, memory-memory, and if it seems to you that this should be so, then not so, and the different modes function slightly differently and are not implemented everywhere. <br><br>  Further, the PDP supports different data formats: 1 byte, 2 bytes and 4 bytes (a word in our architecture), as well as different types of address increment for a separate source and receiver: 1, 2, and 4 (decrement is not supported).  RAP has a system of arbitration of serviced channels with the possibility of assigning flexible priorities for each channel and a customizable size of an elementary transaction (the number of transfers of one channel according to which the arbitration is performed).  In addition, each channel can have up to 2 BUPs, which can be changed according to the cyclic system, or work in a hierarchical mode, while a one-time mode is also possible. <br><br>  To keep a balance, let's say about less good.  Again about the documentation - if you don‚Äôt know how the RAP works, then you don‚Äôt know exactly about this from the company‚Äôs documentation.  The documentation is clearly translated, there are translation errors that distort the meaning, there are also very vaguely described places, but in general it can be enough for a trained developer if you are used to thinking about the author.  Of the more significant shortcomings (of course, compared with the ideal device) is the significant cost of the bus resource (6 accesses per shipment, although maybe I misunderstood something) and a number of features, which are a little later. <br><br>  And here we are waiting for: <br><br>  Ambush # 1 from the developers - the interruption from the end of the transfer does not appear in external devices.  That is, we have one interrupt vector at the end of a transaction from any of the programmed channels.  Moreover, there is no register in which the number of the channel that completed the transaction, or at least a bit register with flags, would be stored.  That is, the only way to determine the number of the channel that completed the transfer is to loop through all the channels and watch the corresponding TCB fields, and we will have to do this in the interrupt handler, which should take minimal time.  The promising solution - to transfer the search channel in the lower half of the driver processing does not pass, because we expect: <br><br>  WITHOUT number 2 from the developers - the interruption is potential and we cannot stop the work of the upper half without explicitly dropping it.  Moreover, there is also <br><br>  WITNING number 3 from them - we can not reset the interruption by manipulating the RPS registers, and must carry out a reset permit for generating requests in the registers of the external device.  Yes, yes, exactly, the PDP driver should know something about the composition of the registers of serviced devices, a more monstrous violation of the principle of encapsulation (and it is also true for designing equipment) is hard to imagine.  I do not know that the developers of the PDP smoked, but, as Haiduk wrote, ‚Äúsomething very interesting‚Äù.  That is, you may not believe, but if we prohibit the passage of requests of the corresponding channel and prohibit its processing, then we still DO NOT RESET the interruption. <br>  Something turned out more letters than planned, so let's leave readers to reflect on the difficult situation in which the main character of the story found himself, which is especially important on Friday evening, and I'll write myself. To be continued ... </div><p>Source: <a href="https://habr.com/ru/post/228531/">https://habr.com/ru/post/228531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228521/index.html">A new version of the distribution has been released to create a pfSense 2.1.4 firewall.</a></li>
<li><a href="../228523/index.html">How to impose a theme for WordPress</a></li>
<li><a href="../228525/index.html">Structure from Motion - classic implementation</a></li>
<li><a href="../228527/index.html">How does international roaming work?</a></li>
<li><a href="../228529/index.html">How does the CROC engineering service work - and what happens if, at 3 am, a cluster breaks somewhere far away</a></li>
<li><a href="../228533/index.html">GameDev for quizzes - I brought you a bunch of useless facts and a bit of veterinary</a></li>
<li><a href="../228535/index.html">Month of use of the IBM cloud server: free opportunity to get acquainted with the Softlayer platform</a></li>
<li><a href="../228537/index.html">New AppStore section, the dependence of the number of installations on the weight of the application and the report on the growth of Google Play over the past year - the main mobile news for the week</a></li>
<li><a href="../228539/index.html">Cisco removed backdoor from VoIP and Jabber controller</a></li>
<li><a href="../228541/index.html">Personal account and mobile application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>