<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write in assembler in 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is devoted to the language of the assembler, taking into account the current realities. Advantages and differences from JAVA are presented...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write in assembler in 2018</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/nz/sl/bk/nzslbk8moxt_2a7a18ugpk4azxq.jpeg"><br><br>  The article is devoted to the language of the assembler, taking into account the current realities.  Advantages and differences from JAVA are presented, a small comparison of compilers is made, a significant amount of the best subject literature is meticulously collected. <br><a name="habracut"></a><br><h2>  1. Language.  Advantages and differences from HLL </h2><br>  Assembly (Assembly) - a programming language, the concepts of which reflect the architecture of an electronic computer.  Assembly language - the symbolic form of writing machine code, the use of which simplifies the writing of machine programs.  For the same computer, different assembly languages ‚Äã‚Äãcan be developed.  In contrast to high-level abstraction languages, in which many problems of the implementation of algorithms are hidden from developers, assembly language is closely related to the microprocessor command system.  For an ideal microprocessor, in which the command system corresponds exactly to the programming language, the assembler produces one machine code for each language operator.  In practice, real microprocessors may require several machine instructions to implement one language operator. <br><br>  An assembly language provides access to registers, an indication of addressing methods, and a description of operations in terms of processor commands.  An assembly language can contain tools of a higher level of abstraction: built-in and defined macros, corresponding to several machine instructions, automatic selection of a command depending on the types of operands, means of describing data structures.  The main advantage of assembly language is ‚Äúproximity‚Äù to the processor, which is the basis of a computer programmer, and the main disadvantage is too small a division of typical operations, which is perceived by most users with difficulty.  However, the assembler language to a much greater extent reflects the very functioning of the computer than all other languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Although drivers and operating systems are now written in C, C, for all its merits, is a high-level language of abstraction, hiding various subtleties and nuances of hardware from a programmer, and an assembler is a low-level language of abstraction that directly reflects all these subtleties and nuances. <br><br>  To successfully use assembler, three things are needed at once: <br><br><ul><li>  knowledge of the assembler translator syntax, which is used (for example, the syntax of MASM, FASM and GAS is different), the assignment of assembler language directives (operators processed by the translator during the translation of the program source text); </li><li>  understanding of the machine instructions executed by the processor during program operation; </li><li>  the ability to work with the services provided by the operating system ‚Äî in this case, this means knowledge of the Win32 API functions.  When working with high-level languages, the programmer often does not directly refer to the system API;  he may not even be aware of its existence, since the language library hides from the programmer the details that depend on the particular system.  For example, in Linux, and in Windows, and in any other system in a C / C ++ program, you can output a string to the console using the printf () function or the cout stream, that is, there is no difference for a programmer using these tools under which system the program is made, although the implementation of these functions will be different in different systems, because the systems API is very different.  But if a person writes in assembler, he no longer has ready-made functions such as printf (), in which it is thought out how to "communicate" with the system, and he must do it himself. </li></ul><br>  As a result, it turns out that for writing even a simple program in assembler a very large amount of preliminary knowledge is required - the ‚Äúthreshold of entry‚Äù here is much higher than for high-level languages. <br><br>  <i>The best</i> can be considered a program that works correctly, as quickly as possible and takes up possibly a small amount of memory.  In addition, it is easy to read and understand;  it is easy to change;  its creation requires little time and minor expenses.  Ideally, an assembly language should have a set of characteristics that would allow to obtain programs that satisfy as many of the listed qualities as possible. <br><br>  In assembly language, programs or their fragments are written in cases when they are critically important: <br><br><ul><li>  the amount of memory used (boot programs, embedded software, programs for microcontrollers and processors with limited resources, viruses, software protection, etc.); </li><li>  speed (programs written in assembly language run much faster than analog programs written in high-level abstraction programming languages. In this case, speed depends on understanding how a particular processor model works, the actual processor on the processor, the size of the cache, the subtleties of work operating system. As a result, the program starts to work faster, but loses portability and versatility). </li></ul><br>  In addition, knowledge of assembly language makes it easier to understand the architecture of a computer and the operation of its hardware, something that knowledge <i>of high-level abstraction languages</i> (REL) cannot provide.  Currently, most programmers develop programs in <i>rapid design environments</i> (Rapid Application Development) when all the necessary design and control elements are created using ready-made visual components.  This greatly simplifies the programming process.  However, it is often necessary to face such situations when the most powerful and effective functioning of separate program modules is possible only if they are written in assembly language (assembler inserts).  In particular, in any program related to the execution of repeatedly repeated cyclical procedures, be it cycles of mathematical calculations or graphics output, it is advisable to group the most time-consuming operations into submodules programmed in assembler language.  All packages of modern high-level abstraction programming languages ‚Äã‚Äãallow this, and the result is always a significant increase in the speed of programs. <br><br>  Programming languages ‚Äã‚Äãof a high level of abstraction were developed with the aim of approximating as closely as possible the method of recording programs to those familiar to users of computers of various forms of recording, in particular mathematical expressions, and also not to take into account the specific technical features of individual computers in programs.  The assembly language is developed taking into account the specifics of the processor, so for a competent writing of a program in assembly language it is required, in general, to know the architecture of the processor of the computer used.  However, bearing in mind the preferential distribution of PC-compatible personal computers and ready-made software packages for them, you should not worry about this, since such concerns are assumed by development companies of specialized and universal software. <br><br><h2>  2. About compilers </h2><br><h3>  Which assembler is better? </h3><br>  For the x86-x64 processor, there are more than a dozen different assembler compilers.  They differ in different sets of functions and syntax.  Some compilers are more suitable for beginners, some for experienced programmers.  Some compilers are well documented, others have no documentation at all.  For some compilers, developed by many programming examples.  For some assemblers, textbooks and books are written in which the syntax is discussed in detail, others have nothing.  Which assembler is better? <br><br>  Given the many dialects of assemblers for x86-x64 and a limited amount of time to study them, we will limit ourselves to a brief overview of the following compilers: MASM, TASM, NASM, FASM, GoASM, Gas, RosAsm, HLA. <br><br><h3>  What operating system would you like to use? </h3><br>  This is a question you must answer first.  The most multifunctional assembler will not bring you any benefit if it is not designed to work under the operating system that you plan to use. <br><br><table><tbody><tr><th></th><th>  Windows </th><th>  Dos </th><th>  Linux </th><th>  BSD </th><th>  QNX </th><th>  MacOS working on <br>  Intel / AMD processor </th></tr><tr><td>  Fasm </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td></td><td></td></tr><tr><td>  Gas </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td></tr><tr><td>  GoAsm </td><td>  x </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  HLA </td><td>  x </td><td></td><td>  x </td><td></td><td></td><td></td></tr><tr><td>  MASM </td><td>  x </td><td>  x </td><td></td><td></td><td></td><td></td></tr><tr><td>  NASM </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td></tr><tr><td>  RosAsm </td><td>  x </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  TASM </td><td>  x </td><td>  x </td><td></td><td></td><td></td><td></td></tr></tbody></table><br><h3>  16 bit support </h3><br>  If the assembler supports DOS, then it also supports 16-bit instructions.  All assemblers provide the ability to write code that uses 16-bit operands.  16-bit support means the ability to create code that works in a 16-bit segmented memory model (compared to the 32-bit flat memory model used by most modern operating systems). <br><br><h3>  64 bit support </h3><br>  With the exception of TASM, to which Borland has cooled in the middle of zero, and which even 32-bit programs do not fully support, all other dialects support the development of 64-bit applications. <br><br><h3>  Program portability </h3><br>  Obviously, you are not going to write code in x86-x64 assembler that would run on some other processor.  However, even on a single processor, you may encounter portability issues.  For example, if you intend to compile and use your programs in assembler under different operating systems.  NASM and FASM can be used in those operating systems that they support. <br><br>  Do you intend to write an application in assembler and then port, this application from one OS to another with the ‚Äúrecompilation‚Äù of the source code?  This function is supported by the HLA dialect.  Do you intend to be able to create Windows and Linux applications in assembly language with minimal effort for this?  Although, if you are working with one operating system and absolutely do not plan to work in any other OS, then this problem does not concern you. <br><br><h3>  Support for high-level language constructs </h3><br>  Some assemblers provide extended syntax that provides language high-level control structures (such as IF, WHILE, FOR, and so on).  Such constructions can facilitate learning to assembler and help to write more readable code.  Some assemblers have built-in ‚Äúhigh-level constructions‚Äù with limited capabilities.  Others provide high-level macro-level constructs. <br><br>  No assembler forces you to use any control structures or high-level data types if you prefer to work at the encoding level of machine instructions.  High-level constructs are an extension of the basic machine language that you can use if you find them convenient. <br><br><h3>  Quality of documentation </h3><br>  Ease of use of the assembler is directly related to the quality of its documentation.  Given the amount of work that is spent to create an assembler dialect, the compiler authors practically do not bother creating documentation for this dialect.  Authors, expanding their language, forget to document these extensions. <br><br>  The following table describes the quality of the assembler reference manual that is attached to the product: <br><br><table><tbody><tr><th width="113"></th><th width="113">  Documentation </th><th>  Comments </th></tr><tr><td>  Fasm </td><td>  Good </td><td>  Most of the free time the author gives to the development of innovative FASMG.  Nevertheless, the author provides support for FASM from time to time, updates manuals, and describes new functions on its own forum.  Documentation can be considered quite good.  Documentation <a href="https://flatassembler.net/docs.php">webpage</a> . <br></td></tr><tr><td>  Gas <br></td><td>  The bad <br></td><td>  poorly documented and documentation, rather, has a "general view".  gas is an assembler that was designed so that you can easily write code for different processors.  The documentation that exists basically describes pseudo codes and assembler directives.  In the "intel_syntax" mode of operation, the documentation is almost absent.  Books using the AT &amp; T syntax: Jonathon Bartlett's ‚ÄúProgramming from scratch‚Äù and Richard Blum‚Äôs Professional Assembly Language, Konstantin Boldyshev <a href="http://asm.sourceforge.net/asmutils.html">asmutils - Linux Assembly</a> . <br></td></tr><tr><td>  GoAsm <br></td><td>  Weak <br></td><td>  Most of the syntax is described in the manual, and an experienced user will find what he is looking for.  Many manuals and posted on the site ( <a href="http://www.godevtool.com/">http://www.godevtool.com/</a> ).  Several GoAsm textbooks: <br><ul><li>  <a href="http://www.easycode.cat/English/Tutorial.htm">Bill Aitken's tutorials for using GoAsm and the IDE</a> </li><li>  <a href="http://www.godevtool.com/3rdparty/Documentation%2520GoTools%2520Vol1.pdf">Manual of Robert Cordonnier in French</a> </li><li>  Patrick Ruiz <a href="">Reference</a> </li></ul><br></td></tr><tr><td>  HLA <br></td><td>  Extensive <br></td><td>  HLA has a 500-page reference manual.  <a href="http://webster.cs.ucr.edu/">The site</a> contains dozens of articles and HLA documentation. <br></td></tr><tr><td>  MASM <br></td><td>  Good <br></td><td>  Microsoft has written a significant amount of documentation for MASM, there are a large number of directories written for this dialect. <br></td></tr><tr><td>  NASM <br></td><td>  Good <br></td><td>  NASM authors write more software for this dialect, leaving the manual to be written ‚Äúlater‚Äù.  NASM has been around for quite a long time, so several authors wrote a manual for NASM Jeff Duntemann ‚ÄúAssembly Language Step-by-Step: Programming with Linux‚Äù, Jonathan Leto ‚Äú <a href="http://leto.net/writing/nasm.php">Writing A Useful Program With NASM</a> ‚Äù, in Russian there is the book of Stolyarov ( <a href="http://www.stolyarov.info/books/asm_unix">Site AV Stolyarov</a> ). <br></td></tr><tr><td>  RosAsm <br></td><td>  Weak <br></td><td>  not very interesting "online tutorials". <br></td></tr><tr><td>  TASM <br></td><td>  Good <br></td><td>  Borland produced excellent reference manuals in its time; reference manuals for non-Borland enthusiastic authors were written for TASM.  But Borland no longer supports TASM, so most of the documentation intended for TASM is not printed and it becomes harder and harder to find. <br></td></tr></tbody></table><br><br><h3>  Textbooks and study materials </h3><br>  The documentation in the assembler itself is of course very important.  Even more interesting for newbies and others who are learning the assembly language (or additional features of this assembler) is the availability of documentation outside the reference manual for the language.  Most people want a tutorial that explains how to program in assembly language, not only provides the syntax of machine instructions and expects the reader to explain how to combine these instructions to solve real problems. <br><br>  MASM is the leader among a huge amount of books describing how to program in this dialect.  There are dozens of books that use MASM as their assembler to train in assembler. <br><br>  Most of the MASM / TASM assembler textbooks continue to teach MS-DOS programming.  Although gradually there are textbooks that teach programming in Windows and Linux. <br><br><table><tbody><tr><th width="113"></th><th>  Comments </th></tr><tr><td>  Fasm </td><td>  Several textbooks that describe programming on FASM: <br><ul><li>  <a href="http://asmworld.ru/uchebnik">Fasm on asmworld</a> </li><li>  <a href="http://www.nestor.minsk.by/kg/abc/087.html">Cycle of articles "Assembler under Windows for Dummies"</a> </li><li>  <a href="http://flatassembler.narod.ru/fasm.htm">Site on narod</a> </li><li>  <a href="https://wasm.in/threads/uroki-iczeliona-ot-sulaiman-chang-na-dialekte-fasm.31759/">Iczelion's lessons from Sulaiman Chang in the FASM dialect</a> </li><li>  <a href="https://wasm.in/threads/ponimanie-fasm.31761/">Understanding FASM</a> </li><li>  <a href="https://wasm.in/threads/programmirovanie-na-jazyke-assembler-v-fasm.31750/">Programming in language Assembler in FASM</a> </li><li>  <a href="https://wasm.in/threads/sozdanie-zaplatok-na-assemblere-fasm.31737/">Creating patches in FASM assembler</a> </li><li>  Norseev S.A.  " <a href="http://www.twirpx.com/file/2222829/">Development of window applications on FASM</a> " </li><li>  Ruslan Ablyazov ‚ÄúProgramming in assembler on the x86-64 platform‚Äù </li></ul><br></td></tr><tr><td>  Gas <br></td><td>  <a href="http://savannah.nongnu.org/projects/pgubook">Tutorial using AT &amp; T syntax</a> <br>  <a href="https://ru.wikibooks.org/wiki/%25D0%2590%25D1%2581%25D1%2581%25D0%25B5%25D0%25BC%25D0%25B1%25D0%25BB%25D0%25B5%25D1%2580_%25D0%25B2_Linux_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2_C">Tutorial assembler in Linux for programmers C</a> <br></td></tr><tr><td>  HLA <br></td><td>  The 32-bit version of ‚ÄúThe Art of Assembly Language Programming‚Äù (exists in both electronic and printed form), programming under Windows or Linux <br></td></tr><tr><td>  MASM <br></td><td>  A large number of books on learning DOS programming.  There are not very many books about programming under Win32 / 64 Pirogov, Yurov, Zubkov, Flenov <br></td></tr><tr><td>  NASM <br></td><td>  many books devoted to programming in DOS, Linux, Windows.  Jeff Duneman‚Äôs book "Assembly Language Step-by-Step: Programming with Linux" uses NASM for Linux and DOS.  The Paul Carter tutorial uses NASM (DOS, Linux). <br></td></tr><tr><td>  TASM <br></td><td>  As with MASM, a large number of DOS-based books have been written for TASM.  But, since Borland no longer supports this product, they have stopped writing books about using TASM.  Tom Swan wrote a TASM tutorial that contained several chapters on programming under Windows. <br></td></tr></tbody></table><br><br><h2>  3. Literature and web resources </h2><br><h3>  Beginners </h3><br><ol><li>  Abel P. Assembler language for the IBM PC and programming.  - M .: Higher School, 1992. - 447 p. </li><li>  Bradley D. Programming in assembly language for personal computers of the IBM company. - M .: Radio and communication, 1988. - 448 p. </li><li>  Galiseev G.V.  IBM PC assembler.  Tutorial .: - M .: Publishing house "Williams", 2004. - 304 pp .: Il. </li><li>  Tao L. Microprocessor Programming 8088. - M .: Mir, 1988. - 357 p. </li><li>  Zhukov A.V., Avdyukhin A.A.  Assembler  - SPb .: BHV-Petersburg, 2003. - 448 pp., Ill. </li><li>  Zubkov SV, Assembler for DOS, Windows and UNIX.  - M .: DMK Press, 2000. - 608 pp., Ill.  (A series for programmers). </li><li>  Irwin K. Assembly language for Intel processors, 4th edition: trans.  from English  - M .: Williams Publishing House, 2005. - 912 pp., Ill.  - Paral.  tit  English (see also the latest <a href="http://kipirvine.com/asm/">7th edition</a> in original) </li><li>  Norton P., Souhe D. The assembly language for the IBM PC. - M .: Computer, 1992. - 352 p. </li><li>  Pilshchikov V.N.  Programming in assembler language IBM PC.‚Äì M .: DIALOG-MEPI, 1994‚Äì2014 288 p. </li><li>  Sklyarov I.S.  We study the assembler for 7 days <a href="http://www.sklyaroff.ru/">www.sklyaroff.ru</a> </li></ol><br><br><h3>  Advanced </h3><br><ol><li>  Kaspersky K. Fundamental bases of hacking.  The art of disassembling.  - M .: SOLON-Press, 2004. 448 p.  - (Kodokopatel series) </li><li>  Kaspersky K. Technique debugging programs without source texts.  - SPb .: BHV-Petersburg, 2005. - 832 pp., Ill. </li><li>  Kaspersky K. Computer viruses inside and out.  - SPb .: Peter, 2006. - 527 pp., Ill. </li><li>  Kaspersky K. Notes of the researcher of computer viruses.  - SPb .: Peter, 2006. - 316 pp., Ill. </li><li>  Knut, D. The Art of Programming, Volume 3. Sorting and Search, 2nd ed .: Per.  from English  - M .: Publishing house "Williams", 2003. - 832 pp., Ill.  - Paral.  tit  English </li><li>  Kolisnichenko D.N.  Rootkits for Windows.  The theory and practice of programming ‚Äúinvisible caps‚Äù, which allow to hide data, processes, network connections from the system.  - SPb .: Science and Technology, 2006. - 320 pp., Ill. </li><li>  Lyamin L.V.  Macroassembler MASM.‚Äì M .: Radio and communications, 1994.‚Äì 320 pp.: Il. </li><li>  Magda Y. Assembler for Intel Pentium processors.  - SPb .: Peter, 2006. - 410 pp., Ill. </li><li>  Maiko G.V.  Assembler for IBM PC.‚Äì M .: Business-Inform, Sirin, 1997.‚Äì 212 p. </li><li>  Warren G. Algorithmic Tricks for Programmers, 2nd ed .: Per.  from English  - M .: Publishing house "Williams", 2004. - 512 pp., Ill.  - Paral.  tit  English </li><li>  Sklyarov I.S.  The art of protecting and hacking information.  - SPb .: BHV-Petersburg, 2004. - 288 pp., Ill. </li><li>  Wetzerell C. Etudes for Programmers: Trans.  from English  - M .: Mir, 1982. - 288 p., Il. </li><li>  Frolov Brothers Electronic Library <a href="http://www.frolov-lib.ru/">www.frolov-lib.ru</a> </li><li>  Chekatov A.A.  The use of Turbo Assembler in the development of programs. - Kiev: Dialectics, 1995.‚Äì 288 p. </li><li>  Yurov V. Assembler: a special reference book. - St. Petersburg: Peter, 2001.‚Äì 496 p.: Ill. </li><li>  Yurov V. Assembler.  Workshop.  2nd ed.  - SPb .: Peter, 2006. - 399 p.: Il. </li><li>  Yurov V. Assembler.  Textbook for universities.  2nd ed.  - SPb .: Peter, 2007. - 637 pp., Ill. </li><li>  Pirogov V. Assembler training course.  2001 Knowledge </li><li>  Pirogov V. ASSEMBLER training course 2003 Knowledge-BHV </li><li>  Pirogov V. Assembler for windows <br>  1st edition - M .: publishing house Molgacheva SV, 2002 <br>  2nd edition - SPb.:.  BHV-Petersburg, 2003 - 684 pp., Il. <br>  3rd edition - SPb.:.  BHV-Petersburg, 2005 - 864 pp., Ill. <br>  4th edition - SPb.:.  BHV-Petersburg, 2012 - 896 pp., Il. </li><li>  Pirogov V. Assembler on examples.  - SPb.:.  BHV-Petersburg, 2012 - 416 pp., Ill. </li><li>  Pirogov V. ASSEMBLER and disassembly.  - SPb.:.  BHV-Petersburg, 2006. - 464 pp., Ill. </li><li>  Pirogov V. work on the book '64-bit programming in assembler (Windows, Unix)'.  The book covers programming on fasm in 64-bit Windows and Unix </li><li>  Yurov V., Khoroshenko S. Assembler: training course. - St. Petersburg: Peter, 1999. - 672 p. </li><li>  Yu-Zheng Liu, Gibson G. Microprocessors of the 8086/8088 family.  Architecture, programming and design of microcomputer systems. - M .: Radio and communication, 1987.‚Äì 512 p. </li><li>  Agner Fog: Software optimization resources (assembly / c ++) 1996 - 2017. <a href="http://www.agner.org/optimize/">Web page</a> </li><li>  Intel¬Æ 64 and IA-32 Architectures Optimization Reference Manual </li><li>  Intel¬Æ 64 and IA-32 Architectures Software Developer's Manual Volume 1: Basic Architecture </li><li>  Intel¬Æ 64 and IA-32 Architects Software Developer's Manual Volume 2A: Instruction Set Reference, AM </li><li>  Intel¬Æ 64 and IA-32 Architects Software Developer's Manual Volume 2B: Instruction Set Reference, NZ </li><li>  Intel¬Æ 64 and IA-32 Architects Software Developer's Manual Volume 3A: System Programming Guide, Part 1 </li><li>  ¬Æ 64 and IA-32 Architects Software Developer's Manual Volume 3B: System Programming Guide, Part 2 </li><li>  Leiterman JC 32/64-BIT 80x86 Assembly Language Architecture.  ¬© 2005, Wordware Publishing, Inc. (568 pages) 2320 Los Rios Boulevard Plano, Texas 75074 </li><li>  Turbo Assembler Version 3.2 User's Guide Borland International.  Inc 1800 Green Hills Road PO BOX 660001, Scotts Valley, CA 95067-0001 </li><li>  Articles from the site <a href="http://www.wasm.in/">wasm.in</a> </li><li>  Articles from the site sasm.narod.ru </li><li>  <a href="http://masm32.com/">MASM32</a> website and <a href="http://masm32.com/board/">forum</a> </li><li>  <a href="https://flatassembler.net/">FASM</a> website and <a href="https://board.flatassembler.net/">forum</a> </li><li>  <a href="http://www.nasm.us/">NASM</a> website </li></ol><br><h2>  4. Practice </h2><br>  So, you already know what an assembler is and what it is eaten with.  You have stocked up with a pair / three books and web manuals, and you may have decided on the compiler ... Unfortunately, programming lessons are beyond the scope of this article, but for those whose choice fell on MASM / FASM you can use the following layouts: <br><br><ul><li>  MASM64 simple window <a href="https://gist.github.com/alexeygritsenko/8ef376d3f588f43582059a435bbb76ce">masm64SimpleWindow.asm</a> </li><li>  FASM64 simple window <a href="https://gist.github.com/alexeygritsenko/03a89385ea479bb0604739c1163f363d">fasm64SimpleWindow.asm</a> </li></ul><br>  The question remains, in which editor to write the code?  Someone writes in a notebook and compiles via the command line, the more savvy prepare scripts - simplifying the process, while others use special development environments.  Yes, there is an IDE in the field of low-level programming, their review is also beyond the scope of the article.  However, taking the opportunity, I dare to suggest that you try your own programming language in assembly language - <a href="https://gri-software.com/ru/">ASM Visual</a> .  In addition to the basic features, it differs from analogs in the presence of refactoring tools, code metrics, in general, more intuitive interfaces and its own project type. <br><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text">  It so happened that the environment is not completely free.  You can support the project by purchasing a Pro license for a free price.  Use the code: <b>HABR_zzdBG1qadG</b> (if free set the slider to position 0). <br></div></div><br>  <i>We wish you, friends, significant achievements and new knowledge in 2018!</i> <i><br><br></i>  <i>respectfully</i> <i><br></i>  <i>Michael Smolentsev <a href="https://habrahabr.ru/users/miklirk/" class="user_link">MiklIrk</a> (Irkutsk State University of Communications),</i> <i><br></i>  <i>Alexey Gritsenko <a href="https://habrahabr.ru/users/expressrus/" class="user_link">expressrus</a> (Don State Technical University).</i> <br><br>  <b>Ps1</b> : Dear, Habrahabr!  Add assembler highlighting (Intel syntax) to your editor, this will come in handy for future articles! <br><br>  <b>Ps2</b> : Soon we will launch a portal with tests (the question is the answer options) on the knowledge of assembler and computer architecture.  Tests will be structured by difficulty level.  If you teach assembler or have sufficient knowledge in this area - write us an e-mail express-rus@yandex.ru you can participate by offering your test to the system. </div><p>Source: <a href="https://habr.com/ru/post/345748/">https://habr.com/ru/post/345748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345738/index.html">The system for preparing video for streaming on the platform ivi</a></li>
<li><a href="../345740/index.html">What is Hashing? Under the hood of the blockchain</a></li>
<li><a href="../345742/index.html">How not to write on Habr: Antireyting 2017</a></li>
<li><a href="../345744/index.html">New release Oh, my code! How I became a VKontakte developer at 16</a></li>
<li><a href="../345746/index.html">Eat three donuts from UWP and not choke</a></li>
<li><a href="../345750/index.html">Development of Wi-Fi network scanner for Sailfish OS</a></li>
<li><a href="../345752/index.html">Richard Hamming: ‚ÄúThe teacher must prepare the student for the student‚Äôs future, not for the teacher‚Äôs past‚Äù</a></li>
<li><a href="../345754/index.html">Blockchain technology in a new business model from a small candy store</a></li>
<li><a href="../345756/index.html">Is it logical that Google rejected the candidacy of Max Howell, author of Homebrew, for his inability to invert binary trees?</a></li>
<li><a href="../345758/index.html">Comparative testing of Smart IDReader on 5 computing complexes with Elbrus processors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>