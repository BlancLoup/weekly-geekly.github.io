<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote Futboloid under iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I greet the most honorable Habraludey! 


 Not so long ago, while searching for a new job, I received a very interesting test task from ZeptoLab : wri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote Futboloid under iOS</h1><div class="post__text post__text-html js-mediator-article"> I greet the most honorable Habraludey! <br><br><img src="https://habrastorage.org/storage2/6ff/b78/0de/6ffb780de7d374d3154c3d4b2629c6d3.jpg" align="right"><br>  Not so long ago, while searching for a new job, I received a very interesting test task from <a href="http://habrahabr.ru/company/ZeptoLab/">ZeptoLab</a> : write an Arkanoid for iOS in a couple of working days without using third-party libraries like Cocos2d / Box2d, etc., that is, on ‚Äúpure‚Äù <b>OpenGL</b> , which seemed to me very interesting.  By the way, <a href="http://habrahabr.ru/company/ZeptoLab/blog/137114/">they</a> already <a href="http://habrahabr.ru/company/ZeptoLab/blog/137114/">wrote</a> about this task on Habr√©, and even arranged a <a href="http://habrahabr.ru/company/ZeptoLab/blog/147684/">debriefing</a> .  So, I challenged fate and took up game development for the first time after school exercises with you in graphical mode! <br><br>  I will specify that I already had some knowledge of OpenGL, but very, very superficial.  We can say that they were not there well, almost completely, I just knew what a viewport is and there are some sprites there, that there are transformation matrices ... So this article could be entitled ‚Äú <i>How to write a simple game under iOS on pure OpenGL without knowing it</i> ", but it is too long. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, if you are interested in how I did it in ~ 10 hours of development and ~ 2 hours of reading, I ask for cat.  (careful! a lot of code! few pictures! link to githab and relaxing video at the end!) <br><a name="habracut"></a><br>  Let's be honest.  Picture_to_tool_vlemaniya ‚Ñ¢ is not a screenshot of what happened to me.  And this is what happened to me: <br><img src="https://habrastorage.org/storage2/dfd/6bd/f2f/dfd6bdf2feb1d88094d296052f8b64b8.png"><br><br>  Forgive me for this deception, but you are still interested in my article, right?  ) <br><br>  How do you start writing a program that uses technologies that are new to you?  That's right, from reading the documentation, examples and articles (well, like the one before you).  After a couple of minutes of sitting in Google, a <a href="http://www.raywenderlich.com/9743/how-to-create-a-simple-2d-iphone-game-with-opengl-es-2-0-and-glkit-part-1">wonderful article</a> was discovered (by Ray Wenderlich), which described in detail the process of creating a simple toy.  Here, if you like, you can close my article and start reading the Ray's article, but for those who still came for the arkanoid and explanations in their native language, I will continue the narration. <br><br>  To begin, create an empty project for the game.  In Xcode, click <b>File -&gt; New -&gt; Project ...</b> , select the <b>iOS</b> template <b>-&gt; Application -&gt; OpenGL Game</b> .  Personally, I chose a project with ARC and without StoryBoard, but you, dear reader, are free to do as you like.  Well, the project was created, we can now immediately run Run and admire the spinning cubes.  But this is not exactly what we wanted to do, so we delete almost everything that we inserted into the template, leaving only the necessary.  First we remove the added shaders, from the ViewController.m we delete all enums and global variables that go to the <b><code>interface ViewController ()</code></b> Now remove the extra methods: <b><code>loadShaders, compileShader:type:file:, linkProgram:, validateProgram:</code></b> in our simplest example we will not use shaders.  Of course, you can use them if you know how and why, but I did not bother with it =). <br><br>  Next, we throw away all the excess of all the remaining methods.  <b><code>setupGL</code></b> and <b><code>tearDownGL</code></b> we bring to the form: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupGL { [EAGLContextsetCurrentContext:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.context]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect = [[GLKBaseEffectalloc] init]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tearDownGL { [EAGLContextsetCurrentContext:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.context]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }</code> </pre><br>  Further.  We make a primitive game with a primitive architecture, so let our ViewController control the whole game at all.  In an amicable way, it would be necessary to create a GameController and assign all these functions to it, but for the time being we will manage it this way.  Therefore, we add the following properties and methods to our ViewController: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define kGameStateNone 0 #define kGameStateLose 1 #define kGameStateWon 2 @property (assign) int gameState; // see kGameState... @property (assign) BOOL gameRunning; - (void)loadBricks; - (void)startGame; - (void)endGameWithWin:(BOOL)win;</span></span></code> </pre><br>  What they are responsible for - and without comment is clear.  Well, now is the time to think about the logic of the game, more precisely, about the logic of the program.  What and how will we do?  What objects will we have?  What do you need to do for this? <br><br>  A lot of questions, yes.  But by simple reflections (and the knowledge that there are some <b>sprites</b> ) we come to this model: there is a ‚Äúbeat‚Äù that the player controls, there are bricks that need to be broken and there is a ball that bounces off everything and breaks the bricks.  In addition, there is a background, and there is a menu - where we can start the game and see its results (whether we won or lost).  Everything we see on the screen is drawn with the help of sprites, which are the basic objects for drawing, something like windows in the system.  Well, or the buttons in the window.  They can have various attributes: coordinates, dimensions, a picture that they draw.  Looking ahead, add here the speed and direction of movement.  Well, let's arm ourselves with these properties and boldly click ‚åòN in Xcode!  Let's create a new class inherited from <b>NSObject</b> , let's call it GameSprite.  And add to it the following properties and methods: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSprite</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithTexture</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKTextureInfo</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textureInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">effect</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKBaseEffect</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">effect</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithImage</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImage</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">image</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">effect</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKBaseEffect</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">effect</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">render</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">update</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGRect</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">boundingRect</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKVector2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">position</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGSize</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contentSize</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKVector2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moveVelocity</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">points</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sec</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Actually, we will be able to create sprites based on a picture or texture, draw them, update them depending on time, get its borders.  As well as ask and get its position, size and speed.  But in the implementation of the sprite begins interesting!  We will need vertices and quads.  What it is?  Well, if simple, then a vertex is a point in space, and a quad is a collection of four vertices.  And the vertex contains actually two points - for the sprite itself and for its texture.  Declare the appropriate structures: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> geometryVertex; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> textureVertex; } TexturedVertex; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { TexturedVertex bl; TexturedVertex br; TexturedVertex tl; TexturedVertex tr; } TexturedQuad;</code> </pre><br>  The following feature should be taken into account: the coordinates of the texture are normalized, that is, they always change in the interval from 0 to 1. We need this quad to draw our texture with the sprite, so for the GameSprite class we will declare such private properties: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSprite</span></span></span><span class="hljs-class">() @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKBaseEffect</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">effect</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TexturedQuad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quad</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLKTextureInfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textureInfo</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initQuadAndSize</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Thus, we have the effect and information about the texture will be stored in the same properties, but not public.  Well, now you can begin to implement the initialization of the sprite: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithTexture:(GLKTextureInfo *)textureInfo effect:(GLKBaseEffect *)effect { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect = effect; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo = textureInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Error loading texture! Texture info is nil!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> initQuadAndSize]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithImage:(<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *)image effect:(GLKBaseEffect *)effect { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect = effect; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *options = [<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> dictionaryWithObjectsAndKeys:[<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithBool:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>], GLKTextureLoaderOriginBottomLeft, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo = [GLKTextureLoader textureWithCGImage:image.CGImage options:options error:&amp;error]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Error loading image: %@"</span></span>, [error localizedDescription]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> initQuadAndSize]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)initQuadAndSize { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contentSize = <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.width, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.height); TexturedQuad newQuad; newQuad.bl.geometryVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); newQuad.br.geometryVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.width, <span class="hljs-number"><span class="hljs-number">0</span></span>); newQuad.tl.geometryVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.height); newQuad.tr.geometryVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.width, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.height); newQuad.bl.textureVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); newQuad.br.textureVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); newQuad.tl.textureVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); newQuad.tr.textureVertex = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.quad = newQuad; }</code> </pre><br>  Nothing tricky, just assigning or loading a texture from a picture and setting a quad.  Here you can see that for each of the four vertices, the coordinates of the geometry and texture are set in different units. <br><br>  Now let's get to the most interesting part - to render the sprite, which is responsible for the <code>render</code> method! <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)render { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect.texture2d0.name = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textureInfo.name; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect.texture2d0.enabled = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect.transform.modelviewMatrix = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.modelMatrix; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect prepareToDraw]; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> offset = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)&amp;_quad; glEnableVertexAttribArray(GLKVertexAttribPosition); glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribPosition, <span class="hljs-number"><span class="hljs-number">2</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TexturedVertex), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) (offset + offsetof(TexturedVertex, geometryVertex))); glVertexAttribPointer(GLKVertexAttribTexCoord0, <span class="hljs-number"><span class="hljs-number">2</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TexturedVertex), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) (offset + offsetof(TexturedVertex, textureVertex))); glDrawArrays(GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre><br>  Here we prepare the texture for drawing through the effect (about the transformation matrix - a little later, until you read this line), turn on the necessary OpenGL parameters (position and texture), transfer our quad to OpenGL using tricky transformations and finally draw!  Everything seems to be simple, but a detailed explanation of what these lines do is beyond the scope of this article, I just send you, dear reader, to the documentation ( <a href="">glVertexAttribPointer</a> and <a href="">glDrawArrays</a> ). <br><br>  We now turn to the transformation matrix, which will be responsible for everything: for coordinates, rotation, scaling and other things.  But, for now, we just need to move our sprite to the desired part of the playing field, so let's go: <br><br><pre> <code class="objectivec hljs">- (GLKMatrix4)modelMatrix { GLKMatrix4 modelMatrix = GLKMatrix4Identity; modelMatrix = GLKMatrix4Translate(modelMatrix, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>); modelMatrix = GLKMatrix4Translate(modelMatrix, -<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contentSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contentSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modelMatrix; }</code> </pre><br>  Here, too, everything is simple: take the Identity matrix (the one that does nothing), translate the origin of coordinates into self.position, and then move it to the middle of the sprite.  This is very handy when manipulating a bunch of sprites.  Now, having made a stub for <code>update:</code> we can create our first sprite and load a picture from resources into it.  And in our ViewController to draw it: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.context) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Failed to create ES context"</span></span>); } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setupGL]; GLKView *view = (GLKView *)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view; view.context = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.context; GLKMatrix4 projectionMatrix = GLKMatrix4MakeOrtho(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">480</span></span>, <span class="hljs-number"><span class="hljs-number">-1024</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.effect.transform.projectionMatrix = projectionMatrix; <span class="hljs-comment"><span class="hljs-comment">// initializing game state self.gameRunning = NO; self.gameState = kGameStateNone; // initializing sprites self.testSprite = [[GameSpritealloc] initWithImage:[UIImageimageNamed:@"myImage"] effect:self.effect]; self.testSprite .position = GLKVector2Make(160, 35); } - (void)glkView:(GLKView *)view drawInRect:(CGRect)rect { glClearColor(1.f, 1.f, 1.f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glEnable(GL_BLEND); [self.testSprite render]; }</span></span></code> </pre><br><img src="https://habrastorage.org/storage2/c7d/17e/b45/c7d17eb45de0fc5748b0a6100f6348cc.png"><br>  Well, not bad?  On our playing field one picture is now drawn.  Yes, we can call friends and boast that we almost wrote the game!  =) <br><br>  But, in fact, it is too early to rejoice.  Sprite we have one and he does not move.  We‚Äôll remove it completely and do something interesting, for example, think up what sprites we need.  First, a beat.  Secondly, the ball.  Third, a bunch of sprites for bricks.  Something else?  Oh yeah, another background.  And also - the menu!  And how to do it?  Sprite for blackout, sprite for the word ‚Äúwon‚Äù, sprite for the word ‚Äúlost‚Äù, sprite for the word ‚Äúwell‚Äù, sprite for the ‚Äúplay‚Äù button.  Well, everything seems to be, fuh.  Well, let's go, we set the properties to our controller: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *playerBat; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *ball; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *background; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *menuDimmer; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *menuCaption; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *menuCaptionWon; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *menuCaptionLose; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) GameSprite *menuStartButton; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *bricks;</code> </pre><br><img src="https://habrastorage.org/storage2/d46/436/7ad/d464367ad7e204118595d79fb0fbc682.png"><br>  For all these elements we will create pictures of suitable sizes in the gimp / photoshop / other.  Let the bricks we have 50x10 pixels, a very good size.  You can draw a ball, or you can find it on the net, which I actually did.  Comrade <a href="https://habrahabr.ru/users/junior/" class="user_link">Junior</a> podsobil with the background (by the way, and invented to completely take a football theme), well, I drew the bricks and the bat myself.  I will not give completely the initialization code of all sprites, it is identical to the one already mentioned, only the coordinates differ.  But what about bricks?  Their location somehow does not want to hardcode, right?  And if you want to add another level?  Let's better think up our own file format in which these levels will be stored.  My format is very simple, but you are free to give free rein to fantasy.  So, here is my file for the first (and so far only) level: <br><br><pre> <code class="objectivec hljs"><span class="hljs-number"><span class="hljs-number">101101</span></span> <span class="hljs-number"><span class="hljs-number">111111</span></span> <span class="hljs-number"><span class="hljs-number">010010</span></span> <span class="hljs-number"><span class="hljs-number">111111</span></span> <span class="hljs-number"><span class="hljs-number">000000</span></span> <span class="hljs-number"><span class="hljs-number">111111</span></span></code> </pre><br>  It seems that the format is self-evident, right?  0 - no bricks, 1 - there is.  Well, if you want to make the second type of bricks, then enter the numbers 2, 3, 4, and so on.  But this is the way of the future.  The function of loading bricks is also very clear: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)loadBricks { <span class="hljs-comment"><span class="hljs-comment">// assuming 6x6 brick matrix, each brick is 50x10 NSError *error; [NSBundle mainBundle] ; NSStringEncoding encoding; NSString *filePath = [[NSBundle mainBundle] pathForResource:@"level1" ofType:@"txt"]; NSString *levelData = [NSString stringWithContentsOfFile:filePath usedEncoding:&amp;encoding error:&amp;error]; if (levelData == nil) { NSLog(@"Error loading level data! %@", error); return; } levelData = [[levelData componentsSeparatedByCharactersInSet: [NSCharacterSet whitespaceAndNewlineCharacterSet]] componentsJoinedByString: @""]; if ([levelData length] &lt; (6*6)) { NSLog(@"Level data has incorrect size!"); return; } NSMutableArray *loadedBricks = [NSMutableArray array]; UIImage *brickImage = [UIImage imageNamed:@"brick1"]; NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES], GLKTextureLoaderOriginBottomLeft, nil]; GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:brickImage.CGImage options:options error:&amp;error]; if (textureInfo == nil) { NSLog(@"Error loading image: %@", [error localizedDescription]); return; } for (int i = 0; i &lt; 6; i++) { for (int j = 0; j &lt; 6; j++) { if ([levelData characterAtIndex:j + i * 6] == '1') { GameSprite *brickSprite = [[GameSprite alloc] initWithTexture:textureInfo effect:self.effect]; brickSprite.position = GLKVector2Make((j + 1) * 50.f - 15.f, 480.f - (i + 1) * 10.f - 15.f); [loadedBricks addObject:brickSprite]; } } } self.bricks = loadedBricks; }</span></span></code> </pre><br>  Well, now we loaded the bricks.  You can run our game and admire even rows of bricks, our bat and ball, and all this against the background of our background.  Oh yeah, we won't see it, because we forgot to add the drawing to <code>glkView:drawInRect:</code>  Add a drawing in order: first the background, then the beat, then all the bricks, and at the end the ball.  And now you can and admire!  =) <br><br>  But how so?  Why doesn't the ball move?  This is not a picture, this is a game, which means that the ball must fly somewhere!  In order for the ball to fly, it needs to set the speed, and in the sprite <code>update:</code> method <code>update:</code> you need to take this speed into account and change the coordinates: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)update:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)dt { GLKVector2 curMove = GLKVector2MultiplyScalar(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.moveVelocity, dt); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position = GLKVector2Add(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position, curMove); }</code> </pre><br>  And in the <code>update</code> method of our ViewController, you need to update the ball sprite: <br><br><pre> <code class="objectivec hljs"> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ball update:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timeSinceLastUpdate];</code> </pre><br><br>  Now you can set the ball to a non-zero speed in <code>startGame</code> - and the ball will fly! <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)startGame { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.gameRunning = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.gameState = kGameStateNone; [selfloadBricks]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ball.position = GLKVector2Make(<span class="hljs-number"><span class="hljs-number">160</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ball.moveVelocity = GLKVector2Make(<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>); }</code> </pre><br>  Well, now let's call this method in <code>viewDidLoad</code> - and the ball will fly, but - will quickly fly off the screen.  Hmm, sad!  Well, we start thinking about handling collisions and collisions of a ball with walls.  In the ready-made <code>update</code> method, add the first ball collision with walls: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// checking for walls // left if (self.ball.boundingRect.origin.x &lt;= 0) { self.ball.moveVelocity = GLKVector2Make(-self.ball.moveVelocity.x, self.ball.moveVelocity.y); self.ball.position = GLKVector2Make(self.ball.position.x - self.ball.boundingRect.origin.x, self.ball.position.y); } // right if (self.ball.boundingRect.origin.x + self.ball.boundingRect.size.width &gt;= 320) { self.ball.moveVelocity = GLKVector2Make(-self.ball.moveVelocity.x, self.ball.moveVelocity.y); self.ball.position = GLKVector2Make(self.ball.position.x - (self.ball.boundingRect.size.width + self.ball.boundingRect.origin.x - 320), self.ball.position.y); } // top if (self.ball.boundingRect.origin.y + self.ball.boundingRect.size.height &gt;= 480) { self.ball.moveVelocity = GLKVector2Make(self.ball.moveVelocity.x, -self.ball.moveVelocity.y); self.ball.position = GLKVector2Make(self.ball.position.x, self.ball.position.y - (self.ball.boundingRect.origin.y + self.ball.boundingRect.size.height - 480)); } // bottom (player lose) if (self.ball.boundingRect.origin.y + self.ball.boundingRect.size.height &lt;= 70) { [self endGameWithWin:NO]; }</span></span></code> </pre><br>  The logic is simple, even tigonometry is not required: in a collision with the left and right wall, we reverse the horizontal velocity component, with the upper wall - the vertical one.  The angle of incidence is equal to the angle of reflection - and therefore the laws of physics are observed.  Well, when crossing the lower boundary, we count the loss.  Alas.  By the way, we also ‚Äúcorrect‚Äù the position of the ball in order to avoid gaps. <br><br>  Run!  The ball bounced off the right wall, from the top - and we lost, although we did not know about it.  Already not bad!  Now we need to make a rebound from the bat, and, as is customary in Arkanoid, the angle of incidence will not always be equal to the angle of reflection, which will depend on the place where the ball falls on the bat.  Here we already use trigonometry to calculate this angle itself: <br><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// player strikes! if (CGRectIntersectsRect(self.ball.boundingRect, self.playerBat.boundingRect)) { float angleCoef = (self.ball.position.x - self.playerBat.position.x) / (self.playerBat.contentSize.width / 2); float newAngle = 90.f - angleCoef * 80.f; GLKVector2 ballDirection = GLKVector2Normalize(GLKVector2Make(1 / tanf(GLKMathDegreesToRadians(newAngle)), 1)); float ballSpeed = GLKVector2Length(self.ball.moveVelocity); self.ball.moveVelocity = GLKVector2MultiplyScalar(ballDirection, ballSpeed); self.ball.position = GLKVector2Make(self.ball.position.x, self.ball.position.y + (self.playerBat.boundingRect.origin.y + self.playerBat.boundingRect.size.height - self.ball.boundingRect.origin.y)); }</span></span></code> </pre><br>  Primitive enough.  But now the most interesting will begin: the definition of a collision with bricks, their destruction and a ball bounce. <br><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// checking for broken bricks NSMutableArray *brokenBricks = [NSMutableArray array]; GLKVector2 initialBallVelocity = self.ball.moveVelocity; for (GameSprite *brick in self.bricks) { if (CGRectIntersectsRect(self.ball.boundingRect, brick.boundingRect)) { [brokenBricks addObject: brick]; if ((self.ball.position.y &lt; brick.position.y - brick.contentSize.height / 2) || (self.ball.position.y &gt; brick.position.y + brick.contentSize.height / 2)) { self.ball.moveVelocity = GLKVector2Make(initialBallVelocity.x, -initialBallVelocity.y); } else { self.ball.moveVelocity = GLKVector2Make(-initialBallVelocity.x, initialBallVelocity.y); } } } // removing them for (GameSprite *brick in brokenBricks) { [self.bricks removeObject:brick]; } if (self.bricks.count == 0) { [self endGameWithWin:YES]; }</span></span></code> </pre><br>  Here, the logic is already more cunning: we determine which side of the ball hit the brick, and depending on this, we change the necessary component of speed, and mark the brick as broken.  Well, then all the broken ones are simply deleted, and if they are not left, we finish the game, we won! <br><br>  Well, now you can start the game and see how the ball jumps, breaks bricks and ... Yes, but how to beat it, then?  Bit there, but we do need to manage it?  I chose the easiest way to control the bat: I allocated a place under it for an ‚Äúear‚Äù, for which you can carry it with your thumb.  In order to change the position of the bits, we need to receive the events of pressing and moving the finger, and for this we need gesture recognizers!  Install them: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { <span class="hljs-comment"><span class="hljs-comment">// ... // gestures UIPanGestureRecognizer *panRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanGesture:)]; UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapGestureFrom:)]; [self.view addGestureRecognizer:panRecognizer]; [self.view addGestureRecognizer:tapRecognizer]; } - (void)handleTapGestureFrom:(UITapGestureRecognizer *)recognizer { CGPoint touchLocation = [recognizer locationInView:recognizer.view]; if (self.gameRunning) { GLKVector2 target = GLKVector2Make(touchLocation.x, self.playerBat.position.y); self.playerBat.position = target; } } - (void)handlePanGesture:(UIGestureRecognizer *)gestureRecognizer { CGPoint touchLocation = [gestureRecognizer locationInView:gestureRecognizer.view]; if (self.gameRunning) { GLKVector2 target = GLKVector2Make(touchLocation.x, self.playerBat.position.y); self.playerBat.position = target; } }</span></span></code> </pre><br>  Are you ready to play?  Launched, broke all the bricks!  So, what is next?  It would be necessary to show the player the result of his labors, and therefore display the menu.  Usually for such things do separate scenes, implemented using the GameScene class, inherited from GameSprite, but I decided not to bother and leave the code as simple as possible.  So the menu is going from different sprites.  Well, in <code>glkView:drawInRect:</code> we need to check the state of the game and draw everything as it should: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)glkView:(GLKView *)view drawInRect:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)rect { glClearColor(<span class="hljs-number"><span class="hljs-number">1.</span></span>f, <span class="hljs-number"><span class="hljs-number">1.</span></span>f, <span class="hljs-number"><span class="hljs-number">1.</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); glClear(GL_COLOR_BUFFER_BIT); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glEnable(GL_BLEND); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.background render]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.playerBat render]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GameSprite *brick <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bricks) { [brick render]; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ball render]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.gameRunning) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuDimmer render]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuStartButton render]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.gameState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> kGameStateWon: [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuCaptionWon render]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> kGameStateLose: [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuCaptionLose render]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> kGameStateNone: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuCaption render]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  Here again, everything is extremely simple, I do not even want to comment.  It remains to process the click on the "play" button, for this in the <code>handleTapGestureFrom:</code> the "else" block: <br><br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">CGRectContainsPoint</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.menuStartButton.boundingRect, touchLocation)) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> startGame]; }</code> </pre><br>  Everything!  Run, play, win and lose!  And most importantly - rejoice!  We rejoice in our own, self-written game for iPhone on a pure OpenGL! <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ufYQ8Gzw4xc%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhjUkZaKVmHukois1d3IYkldkA6T4w" frameborder="0" allowfullscreen=""></iframe><br><br>  Fuh, everything seems to be.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I can take a break and give a link to what happened to me, as usual, the </font></font><a href="https://github.com/silvansky/SimpleArkanoid"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sources on the githaba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (The attentive reader has already noticed that the ball rotates on the video? Well, there is a code for this on the githaba, but I didn‚Äôt want to overload the article) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this game is far from perfect. It lacks the animation of breaking bricks, falling bonuses, scoring, changing levels, better definition of collisions, attacks of the same sounds. Well, you can still add a table of records, integration with the Game Center, saving the results in iCloud, sending to Facebook / Twitter, achievements and other things, without which the modern game is not taken seriously. But in my plans there was no release of the game in the App Store, so I didn‚Äôt bother with all this, since the test task didn‚Äôt provide for this either.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS or WhatWhereFore:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And then there was nothing interesting. </font><font style="vertical-align: inherit;">I went to the interview in ZeptoLab, but very quickly fell on the ignorance of OpenGL at a deep level. </font><font style="vertical-align: inherit;">But I got my profit: now I know that I can make a simple game if necessary, and in general I figured out a little in a new area for myself. </font><font style="vertical-align: inherit;">I hope that now you can write a game and you, my dear reader! </font><font style="vertical-align: inherit;">For this, let me leave, goodbye.</font></font></div><p>Source: <a href="https://habr.com/ru/post/151762/">https://habr.com/ru/post/151762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151754/index.html">The meaning of software life</a></li>
<li><a href="../151756/index.html">Smiley :-) turned 30 years old</a></li>
<li><a href="../151759/index.html">Blocking YouTube was tested on Omsk users of Rostelecom</a></li>
<li><a href="../151760/index.html">Pre-order the 4th edition of The C ++ Programming Language</a></li>
<li><a href="../151761/index.html">Preparing an IT demo for MMS and IT Camps - part 1</a></li>
<li><a href="../151763/index.html">Using the Android Tablet PC as a Personal GPS Tracker</a></li>
<li><a href="../151764/index.html">William Gibson Interview Wired. Part 1</a></li>
<li><a href="../151765/index.html">Intel forecast - the transition to 5-nm technology will allow Gordon Moore's law to hold on for at least another decade</a></li>
<li><a href="../151769/index.html">Runetology (165): Yuri Virovets and Alexey Babin, investor and founder of Clickberry</a></li>
<li><a href="../151771/index.html">Bash: we start the demon with child processes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>