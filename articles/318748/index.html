<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods of protection against CSRF attacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is a CSRF attack? 


 You can get acquainted with the very idea of ‚Äã‚Äãa CSRF attack on classic resources: 


- Owasp 
- Acunetix 
- Excellent answ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods of protection against CSRF attacks</h1><div class="post__text post__text-html js-mediator-article"><h2 id="chto-takoe-csrf-ataka">  What is a CSRF attack? </h2><br><p>  You can get acquainted with the very idea of ‚Äã‚Äãa CSRF attack on classic resources: </p><br><ul><li>  <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet">Owasp</a> </li><li>  <a href="http://www.acunetix.com/websitesecurity/csrf-attacks/">Acunetix</a> </li><li>  <a href="http://stackoverflow.com/questions/11518245/csrf-attacks-and-double-submitted-cookie/29622103">Excellent answer to SO</a> </li></ul><br><h5 id="vyderzhka-iz-otveta-na-so">  Excerpt from the answer to SO: </h5><br><p> The reason for CSRF lies in the fact that browsers do not understand how to distinguish whether an action was explicitly performed by the user ( <em>like, say, clicking a button on a form or following a link</em> ) or the user unintentionally performed this action ( <em>for example, when visiting <code>bad.com</code> , A request was sent to <code>good.com/some_action</code> , while the user was already logged in to <code>good.com</code></em> ). </p><br><h2 id="kak-ot-nee-zaschititsya">  How to protect against it? </h2><br><p>  An effective and generally accepted way to protect against CSRF-Attack is a <strong>token</strong> .  A token means a random set of bytes that the server sends to the client, and the client returns to the server. </p><br><p>  Protection comes down to verifying the token that the server generated and the token that the user sent. </p><a name="habracut"></a><br><h4 id="a-chto-sobstvenno-zaschischat">  And what, actually, to protect? </h4><br><p>  If you write your Web-Service in accordance with the <a href="https://tools.ietf.org/html/rfc7231">RFC7231</a> standard, then the <code>GET</code> , <code>HEAD</code> , <code>OPTIONS</code> and <code>TRACE</code> methods are safe: they are for information only and should not change the state of the server. </p><br><p>  Thus, it is necessary to protect the unsafe methods, which include: <code>POST</code> , <code>PUT</code> , <code>DELETE</code> , <code>PATCH</code> . </p><br><p>  On Habrahabr published an article from Yandex, which describes <a href="https://habrahabr.ru/company/yandex/blog/265569/">why you need to write your services, guided by the standard</a> . </p><br><h2 id="trebovaniya-k-tokenu">  Token requirements: </h2><br><ul><li>  Unique token for each operation </li><li>  Valid once </li><li>  Has a size that is resistant to selection </li><li>  Generated by a cryptographically pseudo-random number generator </li><li>  Has a limited lifetime </li></ul><br><p>  At the <a href="https://www.ptsecurity.com/ru-ru/about/events/112681/">first PDU MeetUp meeting,</a> Timur Yunusov ( <em>head of banking security department</em> <em><br></em>  <em>Systems Positive Technologies</em> ) <a href="https://youtu.be/Zx8HDAW7TKo%3Ft%3D36m13s">told</a> why exactly such requirements are imposed on the CSRF-Token and what threatens to neglect them. </p><br><h2 id="trebovaniya-k-web-servisu-i-okruzheniyu">  Requirements for Web-service and environment: </h2><br><ul><li><p>  Lack of <strong>XSS</strong> vulnerabilities </p><br><p>  Introduced by the attacker script has the ability to send a request to the server on behalf of the user and read it without any obstacles. </p><br><p>  Thus, XSS vulnerabilities can be used to obtain the current token. </p><br></li><li><p>  No <strong>malware</strong> on the client machine </p><br><p>  If the attacker has the ability to run the software on the client‚Äôs machine, he can get any data that is available in the browser. </p><br></li></ul><br><h2 id="metody-zaschity">  Protection methods </h2><br><p>  There are 3 methods of using tokens to protect web services from CSRF attacks: </p><br><ul><li>  <a href="https://habr.com/ru/post/318748/">Synchronizer Tokens</a> ( <em>Statefull</em> ) </li><li>  <a href="https://habr.com/ru/post/318748/">Double Submit Cookie</a> ( <em>Stateless</em> ) </li><li>  <a href="https://habr.com/ru/post/318748/">Encrypted Token</a> ( <em>Stateless</em> ) </li></ul><br><h3 id="synchronizer-tokens">  Synchronizer tokens </h3><br><p>  A simple approach that is used everywhere.  Requires server-side storage. </p><br><h6 id="sut">  The bottom line: </h6><br><ol><li><p>  When the <strong>session starts</strong> , a token is generated on the server side. </p><br></li><li><p>  The token is placed in the session data storage ( <em>i.e. stored on the server side for subsequent verification</em> ) </p><br></li><li><p>  In response to the request ( <em>which started the session</em> ), the client returns a token. </p><br><p>  If <strong>rendering occurs on the server</strong> , then the token can be returned inside HTML, such as one of the form fields, or inside the <code>&lt;meta&gt;</code> tag. </p><br><p>  In case the answer is returned <strong>for the JS application</strong> , the token can be passed to the header ( <em>often <code>X-CSRF-Token</code> used for this</em> ) </p><br></li><li><p>  In subsequent requests, the client is obliged to transfer the token to the server for verification. </p><br><p>  When rendering the content by the server, the token is usually returned <strong>within the POST</strong> form <strong>data</strong> . </p><br><p>  JS applications usually send <strong>XHR requests with a header</strong> ( <code>X-CSRF-Token</code> ) containing the token. </p><br></li><li><p>  When receiving a request with an insecure method ( <code>POST</code> , <code>PUT</code> , <code>DELETE</code> , <code>PATCH</code> ), the server must check the identity of the token <strong>from the session data</strong> and the token that the <strong>client sent</strong> . </p><br><p>  If both tokens match, then the request has not been subjected to CSRF-Attack, otherwise we log the event and reject the request. </p><br></li></ol><br><h6 id="na-vyhode-imeem">  At the exit we have: </h6><br><ul><li><p>  CSRF protection at a good level </p><br></li><li><p>  The token is updated <strong>only when the session is re-created</strong> , and this happens when the session expires. </p><br><p>  During the life of one session, all actions will be checked on <strong>one token</strong> . </p><br><p>  If a token leaks, the attacker can perform a CSRF Attack on <strong>any request</strong> and <strong>for a long time</strong> .  And this is not good. </p><br></li><li><p>  Free multi-tab browser support. </p><br><p>  The token is not disabled after the execution of the request, which allows the developer not to worry about synchronization of the token in different browser tabs, since the token is always the same. </p><br></li></ul><br><h3 id="double-submit-cookie">  Double Submit Cookie </h3><br><p>  This approach <strong>does not</strong> require server-side data storage, which means it is <strong>Stateless</strong> .  Used if you want to be able to quickly and accurately scale your Web service horizontally. <br>  The idea is to give the token to the client by two methods: <strong>in cookies</strong> and in <strong>one of the response parameters</strong> ( <em>header or inside HTML</em> ). </p><br><h6 id="sut-1">  The bottom line: </h6><br><ol><li><p>  When a request is received from the client, a token is generated on the server side.  In the response, the token is returned in the <strong>cookie</strong> (for example, <code>X-CSRF-Token</code> ) and <strong>in one of the response parameters</strong> ( <em>in the header or inside HTML</em> ). </p><br></li><li><p>  In subsequent requests, the client must provide <strong>both</strong> tokens received earlier.  One as a cookie, the other as either a <strong>header</strong> , or <strong>inside a POST</strong> form <strong>data</strong> . </p><br></li><li><p>  When a request is received by an insecure method ( <code>POST</code> , <code>PUT</code> , <code>DELETE</code> , <code>PATCH</code> ), the server must check the <strong>cookie</strong> token for identity and the token that the <strong>client</strong> has explicitly <strong>sent</strong> . </p><br><p>  If both tokens match, then the request has not been subjected to CSRF-Attack, otherwise we log the event and reject the request. </p><br></li></ol><br><h6 id="na-vyhode-imeem-1">  At the exit we have: </h6><br><ul><li><p>  Stateless CSRF protection. </p><br></li><li><p>  It is necessary to take into account that subdomains can read cookies of the main domain, if this is not explicitly <code>.site.ru</code> (that is, if the cookie is set on <code>.site.ru</code> , then it can be read both by <code>a.site.ru</code> and <code>b.site.ru</code> ). </p><br><p>  Thus, if your service is available on the 3rd level domain, and the attacker has the opportunity to register his resource on your 2nd level domain, then set the cookie to your domain explicitly. </p><br></li><li>  The nuances depend on the implementation </li></ul><br><h3 id="encrypted-token">  Encrypted Token </h3><br><p>  Just like Double Submit, is a <strong>stateless</strong> approach.  The main thing is that if you encrypt any data with a reliable algorithm and transfer it to the client, the client will not be able to fake it without knowing the key.  This approach does not require the use of cookies.  The token is sent to the client only in the response parameters. </p><br><p>  In this approach, <strong>tokens are facts encrypted with a key</strong> .  The minimal necessary facts are the <strong>user ID</strong> and the <strong>timestamp</strong> of the token generation time.  The key should not be known to the client. </p><br><h6 id="sut-2">  The bottom line: </h6><br><ol><li><p>  When a request is received from the client, a token is generated on the server side. </p><br><p>  Generation of the token consists in encrypting the facts necessary for validation of the token in the future. </p><br><p>  The minimum required facts are the <strong>user ID</strong> and the <strong>timestamp</strong> .  In response, the token is returned <strong>in one of the response parameters</strong> ( <em>In the header or inside HTML</em> ). </p><br></li><li><p>  In subsequent requests, the client is obliged to provide the previously received token. </p><br></li><li><p>  When receiving a request using an insecure method ( <code>POST</code> , <code>PUT</code> , <code>DELETE</code> , <code>PATCH</code> ), the server must validate the token received from the client. </p><br><p>  Validation of a token consists in deciphering it and comparing facts obtained after decryption with real ones.  (The <strong>timestamp</strong> check is necessary to limit the lifetime of the token) </p><br><p>  If it was not possible to decrypt or the facts do not match, it is considered that the request was subjected to CSRF-Attack. </p><br></li></ol><br><h6 id="na-vyhode-imeem-2">  At the exit we have: </h6><br><ul><li><p>  Stateless CSRF protection </p><br></li><li><p>  No need to store data in the cookie. </p><br></li><li>  No nuances with subdomains. </li></ul><br><h2 id="o-realizacii">  About implementation </h2><br><ul><li><p>  Let's generate a new token for <strong>each</strong> request, no matter what HTTP method and for what purpose this request is made. </p><br><p>  Thus, we get a token that changes constantly. </p><br><p>  Of course, the question arises of organizing multi-tab work. </p><br><p>  Synchronization of tokens between tabs can be implemented using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage">localStorage</a> and its <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent">StorageEvent</a> </p><br></li><li><p>  <strong>We limit the lifetime of the</strong> cookie, which contains the token, to a reasonable value.  For example, 30 minutes. </p><br></li><li><p>  Making the cookie inaccessible from JS (set <strong>HTTPOnly = true</strong> ) </p><br></li><li><p>  Use <strong>TLS</strong> to prevent <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">MITM</a> </p><br><p>  At the same time, we send cookies only over HTTPS (set <strong>Secure = true</strong> ) </p><br></li><li><p>  The size of the token is <strong>at least 32 bytes</strong> . </p><br></li><li><p>  We generate a token with a cryptographically stable pseudo-random number generator. </p><br><p>  To do this, you can use the system functions: </p><br><pre> <code class="hljs php">Linux =&gt; getrandom(<span class="hljs-number"><span class="hljs-number">2</span></span>)  , /dev/urandom  OpenBSD =&gt; getentropy(<span class="hljs-number"><span class="hljs-number">2</span></span>)   Unix-like  =&gt; /dev/urandom Windows =&gt; CryptGenRandom API</code> </pre> <br></li></ul><br><h2 id="chto-esche-nuzhno-znat">  What else do you need to know? </h2><br><p>  Tokens - mandatory protection against CSRF. </p><br><ul><li><p>  Check, but do not rely solely on <code>X-Requested-With: XMLHttpRequest</code> </p><br></li><li><p>  Check, but do not rely only on the headers: <code>Host</code> , <code>Origin</code> , <code>Referer</code> </p><br></li><li><p>  Do not pass tokens in URL </p><br></li><li>  Protect all requests. </li></ul><br><h2 id="same-site">  Same Site </h2><br><p>  We are currently working on the specification of the "Same Site" attribute for cookies (the latest version at the time of this writing). </p><br><p>  Such an attribute will enable developers to explicitly indicate that the cookie should not be sent if the request comes from a site other than the one on which the cookie was set.  This means that we will have the opportunity to protect resources from CSRF without using additional tools. </p><br><p>  Chrome browser now supports this feature. </p><br><p>  A little more information on how and why is available on the <a href="http://security.stackexchange.com/a/121986">Stack Exchange</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318748/">https://habr.com/ru/post/318748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318738/index.html">How to bring the project to mind with the help of PERT-diagrams</a></li>
<li><a href="../318740/index.html">Data retrieval bike</a></li>
<li><a href="../318742/index.html">New Year game from Rambler & Co</a></li>
<li><a href="../318744/index.html">The debug mechanism in Intel processors allows you to capture them via the USB port</a></li>
<li><a href="../318746/index.html">MegaFon in hard to reach places</a></li>
<li><a href="../318750/index.html">The whole truth about the rating of manufacturers of video surveillance from ASmag</a></li>
<li><a href="../318752/index.html">Ada Lovelace. The first program in the world and a look into the future</a></li>
<li><a href="../318754/index.html">[Translation] How to correctly determine the size of the team for beta testing a mobile application</a></li>
<li><a href="../318756/index.html">How 10 years ago the project PVS-Studio started</a></li>
<li><a href="../318758/index.html">Why this winter we again invite everyone to play computer games using artificial intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>