<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generating a list of IPv4 addresses on TCL and some number systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, it was necessary to solve the problem of mass device configuration update. A standard system administration task if you have more tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generating a list of IPv4 addresses on TCL and some number systems</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, it was necessary to solve the problem of mass device configuration update.  A standard system administration task if you have more than one device in service that performs the same type of function.  For the solution, there are both universal products, for example, from the available <a href="http://redmine.nocproject.org/">redmine.nocproject.org</a> , and many scripts widely presented on thematic forums and portals.  Just in this case, the handwritten script should have turned out to be its own written script, but it didn‚Äôt turn out, therefore, considering that there was time for maneuvers, the script was written anew, executed and put on the shelf, so that there would be lost again. <br>  For writing, we used expect - <a href="http://expect.sourceforge.net/">expect.sourceforge.net</a> , an add-on for TCL that allows processing and responding to responses from various interactive console utilities, in particular, telnet.  Considering that for TCL it was not necessary to write earlier, the code needed to be rethought.  The key point of the script is the generator of the list of IPv4 addresses to process, after a careful assessment of this piece of the program it was possible to significantly, in my opinion, optimize, at least reduce the number of lines by one third and add the new functionality without serious consequences.  Moreover, all these abbreviations did not relate much to the specifics of TCL, but concerned fundamental approaches to the construction of the algorithm as a whole. <br>  I selected this code into a separate utility, which I will try to disassemble in great detail later in the text - how it was ‚Äúbefore‚Äù and what became ‚Äúafter‚Äù, and why it was impossible to write right away as ‚Äúafter‚Äù.  I still don‚Äôt like everything in it: confusing both algorithmic problems and TCL problems, for example, using lists instead of arrays (which is faster?, Safer?, Ideologically more correct?), All doubts are also present in the text, with the hope of constructive comments. <a name="habracut"></a><br>  The logic of the utility (cipl.tl) is as follows: we set two parameters in the command line: the IPv4 address from which we will start building our list and the IPv4 address by which the list will end or the number indicating how many items should be in the list.  The order of construction from a smaller address (the first parameter) to a larger one.  If the second parameter is omitted, then a list consisting only of the initial IPv4 address is displayed: <br><blockquote><pre> &gt; cipl.tl 192.0.2.1 1
 192.0.2.1
 192.0.2.2
 &gt; cipl.tl 192.0.2.1 192.0.2.2
 192.0.2.1
 192.0.2.2
 &gt; cipl.tl 192.0.2.1
 192.0.2.1
</pre></blockquote><br>  For Windows, the script runs along with the tclsh interpreter, in fact, you can also do it in * nix <br><blockquote><pre> &gt; tclsh cipl.tl 192.0.2.1
 192.0.2.1
</pre></blockquote><br>  Next, I will quote the code, supplying it with line numbers and versions, and then commenting on it.  The resulting version, you can pick up the links at the end of the topic. <br><br>  <b>Ver.1, ‚Ññ1-12</b> <br><blockquote><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/tclsh8.5 set exip {^(2(5[0-5]|[0-4]\d)|1\d{2}|[1-9]\d{0,1})(\.(2(5[0-5]|[0-4]\d)|1\d{2}|[1-9]\d|\d)){3}$} set exdg {^(0?|([1-9]\d{0,5}))$} if {$argc == 0 || $argc &gt; 2} then { puts "cipl.tl -   IP    " puts ": cipl.tl &lt;start IP&gt; \[&lt;count&gt;|&lt;finish IP&gt;\]" puts ": &lt;start IP&gt; - IPv4     &lt;finish IP&gt;" puts "\t &lt;finish IP&gt; - IPv4 " puts "\t &lt;count&gt; -   0  999999" } else {</span></span></code> </pre> </blockquote><br>  In the first line we show what we need to use an interpreter, this is a line for Linux.  In general, you must specify the full path to tclsh, for example, for FreeBSD this line will look like this: <br><blockquote><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/local/bin/tclsh8.5</span></span></code> </pre> </blockquote><br>  Next, we set the variables <i>exip</i> and <i>exdg,</i> which are regular expressions that will be used later in the program.  The first variable we need to verify the correctness of the input IPv4 address.  Under this regular expression get the correct addresses written in decimal form from 1.0.0.0 to 255.255.255.255, that is, to set the address of the form 192.0.02.010 will not work.  The second variable determines the number, without leading zeros - the valid bounds of the list are from 0 to 999999, the empty string is also true.  The limitation on top of 999999, in my opinion, was reasonable and, moreover, I did not waste time searching for a regular expression of the corresponding number 2 to the power of 32. These regular expressions did not appear immediately, but were added based on the needs of the solution, which explains how much such, but it will be seen a little further. <br>  Next, the <b>if</b> condition is checked - the number of parameters passed from the command line, if there are 0 or more than 2, then display a small help.  At this point, you can not output anything, but simply take the first two parameters as required, thereby concentrating more on the batch operation of the utility without cluttering output in case of an error. <br>  The last line opens an <b>else</b> block in which the main processing takes place. <br><br>  <b>Ver.1, ‚Ññ12-17</b> <br><blockquote><pre> <code class="bash hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> startip [lindex <span class="hljs-variable"><span class="hljs-variable">$argv</span></span> 0] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> countip [lindex <span class="hljs-variable"><span class="hljs-variable">$argv</span></span> 1] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> getcountip <span class="hljs-variable"><span class="hljs-variable">$countip</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$startip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsip [split <span class="hljs-variable"><span class="hljs-variable">$startip</span></span> {.}]</code> </pre></blockquote><br>  In this part, we first save the parameters obtained at the input to the <i>startip</i> variables - the first parameter, <i>countip</i> - the second parameter, if there is no second parameter, then <b>lindex</b> returns us an empty string.  And also save the second parameter in the additional variable <i>getcountip</i> . <br>  Next, we check that the first parameter matches the correct IP address using <b>regexp</b> and the <i>exip</i> variable with the regular expression specified earlier.  In this condition, it is important that the IPv4 address is fully consistent with what we expect, since the next line we create is the <i>octsip</i> list using <b>split</b> , the dot symbol is used as a separator.  The resulting list must contain only decimal digits from 0 to 255 in the right places without leading zeros, in order to operate with them without further additional checks.  Leading zeros play a role here, insofar as, for example, the number 011 in the substitution will be perceived as an octal number, that is, it will be equal to 9 in the decimal number system. <br>  Here you should pay attention to the fact that a query in a search engine quite often leads to regular expressions that do not check all these conditions, often it is just a test for 4 groups of 3 digits per group.  For example, the expression from <a href="http://habrahabr.ru/blogs/webdev/123845">habrahabr.ru/blogs/webdev/123845</a> allows the construction 000.100.1.010, which of course is the IP address, but does not uniquely define its octal or decimal form, this introduces uncertainty and requires further checks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Ver.1, ‚Ññ18-35</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$countip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octfip [split <span class="hljs-variable"><span class="hljs-variable">$countip</span></span> {.}] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsub {0} <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> countip {0} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> i 3} {<span class="hljs-variable"><span class="hljs-variable">$i</span></span>&gt;=0} {incr i -1} { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsub [expr [lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span>] - [lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span>]]] &lt; 0} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; 0} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> si [expr <span class="hljs-variable"><span class="hljs-variable">$i</span></span> - 1] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octfip [lreplace <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> <span class="hljs-variable"><span class="hljs-variable">$si</span></span> <span class="hljs-variable"><span class="hljs-variable">$si</span></span> [expr [lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> <span class="hljs-variable"><span class="hljs-variable">$si</span></span>] - 1]] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsub [expr 256 + <span class="hljs-variable"><span class="hljs-variable">$octsub</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> } } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ni [expr 3 - <span class="hljs-variable"><span class="hljs-variable">$i</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> countip [expr <span class="hljs-variable"><span class="hljs-variable">$countip</span></span> + (<span class="hljs-variable"><span class="hljs-variable">$octsub</span></span> * (1 &lt;&lt; (<span class="hljs-variable"><span class="hljs-variable">$ni</span></span> * 8)))] } }</code> </pre></blockquote><br>  Here we check if the second parameter is the correct IPv4 address and if this is the case, then we try to calculate the difference between this address and the one that is specified in the first parameter, that is, at the output of this block, the <i>countip</i> variable must contain the correct list length value.  The <b>if</b> condition check is nested in the superior check (line 16), so if the previous check is failed (the first parameter is not an IPv4 address), the program will not get to this site. <br>  The solution of this subtask (subtraction of IPv4 addresses) is made as if we had read two numbers into the bar: <br><blockquote><pre>  192.168.3.  one
 -192.168.2.  ten
 = 0. 0.0.247
</pre></blockquote><br>  Of course, these numbers are not decimal, but on the basis of 256. That is, when we occupy the value from the previous digit, we should add not 10, but 256 (0x100) in the hexadecimal representation of octets, it looks clearer: <br><blockquote><pre>  0xC0.0xA8.0x03.0x01
 -0xC0.0xA8.0x02.0x0A
 ---------------------- (perform the loan, remove the unit from the senior level)
 = 0xC0.0xA8.0x03.0x01
          -.0x01
 ---------------------- (continue the loan, adjust the result by the value of the base of the number system)
 -0xC0.0xA8.0x02.0x00A
               + .0x100
 ---------------------- (the result is such an operation)
 = 0xC0.0xA8.0x02.0x101
 -0xC0.0xA8.0x02.0x00A
 = 0x00.0x00.0x00.0x0F7
</pre></blockquote><br>  To implement this, we also, like with the first parameter, create an <i>otcfip</i> list, then create a variable <i>octsub</i> which will contain the difference between octets and <i>zero out the countip</i> which stores the size of the address list, and not the IPv4 address that was there when we entered this code block. <br>  We organize a <b>for</b> loop with the variable <i>i</i> in the reverse order from 3 to 0. In this cycle, we must go through all the octets of the IPv4 address starting with the youngest, that is, all the elements of the <i>octsip</i> and <i>octfip lists</i> starting with the last element. <br>  We calculate the difference between the current <i>octfip-octcip octets</i> and save it in <i>octsub</i> .  Here I really wanted to use arrays, because the <b>lindex</b> construct is very cumbersome, but I did not see a simple way to form an array (in TCL, it is only associative) from the list, so only lists are present everywhere.  The calculated difference is immediately checked for a condition less than 0, that is, do we need to make a loan from the senior octet or not? <br>  If a loan should be made and it is not the most <i>significant</i> octet ( <i>i</i> greater than 0), then <i>we</i> add 256 to the <i>octsub</i> difference and subtract 1 from the next octet of a decrement ( <i>octfip</i> ). <br>  If this is the most senior octet, then we have a reduced <i>octfip</i> less than a deductible <i>octsip</i> , that is, the difference is negative, which cannot be according to the condition of the problem, in this case we exit the cycle - <b>break</b> <br>  If a loan is not necessary, then the result will satisfy us.  However, the result is in any case represented in the number system with a base of 256, which is not convenient, since we need to do further calculations in a system that the interpreter understands.  Therefore, we translate the resulting result in a standard way for the positional number system: <br>  <i>... + A <sub>i</sub> * B <sup>i</sup> ... + A <sub>3</sub> * B <sup>3</sup> + A <sub>2</sub> * B <sup>2</sup> + A <sub>1</sub> * B <sup>1</sup> + A <sub>0</sub> * B <sup>0</sup> = N <sub>B</sub></i> , where B is the base of the number system. <br>  In our case: <i>countip = octsub <sub>ni</sub> * 256 <sup>ni</sup></i> , where <i>ni</i> varies from 0 to 3, or <i>ni</i> = 3 - <i>i</i> , where <i>i</i> changes from 3 to 0, which allows us to include translation into the existing cycle.  Since the base of the number system is a multiple of 2, we use a shift that is a multiple of 8 to calculate the degree, since 256 is 100000000 in binary representation, that is, the unit is shifted 8 bits to the left.  Thus, shifting first to 0, then to 8 (the last significant line in this section of the code), then to 16 and 24, we thereby multiply by 1 (256 <sup>0</sup> ), 256, 256 <sup>2</sup> and 256 <sup>3</sup> . <br>  Returning to this site for the second time, it caused some confusion in me, which seemed simple and understandable during implementation, now it seemed too complicated and complicated.  This can be judged even by the amount of text describing this code. <br>  What is wrong?  Why did it take anew !, to invent a subtraction operation, even for numbers in the number system with a base of 256, instead of translating these values ‚Äã‚Äãinto a numeric form that is understandable to the programming language, and doing the subtraction using standard tools, especially since we still do the translation?  In the end, for myself, I came to the conclusion that the subjective human perception has played a cruel joke once again.  What can be easier to perform actions in the bar, which take place in the first class?  Nothing, because this is the first thing that everyone learns after the actual numbers.  Translations, shifts, seem complicated compared to the simplest operation from the first class.  Understanding that this is not a decimal number system comes a little later, but an understanding of the incorrectness of what is happening, only when I had to look at the written code a second time.  As a result, the second version of the same area. <br><br>  <b>Ver.2, ‚Ññ18-25</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$countip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octfip [split <span class="hljs-variable"><span class="hljs-variable">$countip</span></span> {.}] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nfip [expr ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 0] * 0x1000000) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 1] * 0x10000)\ + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 2] * 0x100) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 3])] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nsip [expr ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 0] * 0x1000000) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 1] * 0x10000)\ + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 2] * 0x100) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 3])] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {<span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &gt;= <span class="hljs-variable"><span class="hljs-variable">$nsip</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> countip [expr <span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> - <span class="hljs-variable"><span class="hljs-variable">$nsip</span></span>]} }</code> </pre></blockquote><br>  After forming the <i>octfip</i> list (as well as in the first version), we generate numbers corresponding to the IPv4 address value (which they are) in the <i>nfip</i> variable ‚Äî for the address in the second argument and the <i>nsip</i> variable ‚Äî for the address in the first argument.  We do the translation the same way as we did, only without any cycles, substituting the values ‚Äã‚Äãinto one line: <i>nfip = listitem <sub>0</sub> * 256 <sup>3</sup> + listitem <sub>1</sub> * 256 <sup>2</sup> + listitem <sub>2</sub> * 256 + listitem <sub>3</sub></i> , where <i>listitem <sub>n</sub></i> is the corresponding list item directly in the expression using <b>lindex</b> .  256 to some extent, in the code for ease of perception is presented in the form of round hexadecimal values ‚Äã‚Äã0x100xxxx.  Then we check that the second argument is greater than the first one and subtracts the first argument from the second while keeping the result value in <i>countip</i> . <br>  As a result, it turned out a little easier than it was, even much easier.  The only thing that confuses me in this version is the hypothetical possibility of overflowing the <i>nfip</i> and <i>nsip variables</i> when calculating <b>expr</b> .  Although for current C compilers this should not be scary.  From the documentation about calculations and overflows <a href="http://www.tcl.tk/man/tcl8.4/TclCmd/expr.htm">http://www.tcl.tk/man/tcl8.5/TclCmd/expr.htm#M23</a> .  For version 8.4, <a href="http://www.tcl.tk/man/tcl8.4/TclCmd/expr.htm">www.tcl.tk/man/tcl8.4/TclCmd/expr.htm#M5 it was</a> explicitly stated that the numeric constants are 32-bit signed numbers, which, if necessary, will be perceived as 64-bit signed, for version 8.5 of this mention no.  In the previous version, the hypothetical possibility of overflow was also present, but there we were processing the already obtained difference, which in real cases of application would be much less than even a 16-bit number. <br>  Then the second part of the utility begins, in which the displayed list of IPv4 addresses is generated. <br><br>  <b>Ver.2, ‚Ññ26-27</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exdg</span></span> <span class="hljs-variable"><span class="hljs-variable">$countip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { puts <span class="hljs-variable"><span class="hljs-variable">$startip</span></span></code> </pre></blockquote><br>  We check the <i>countip</i> variable for compliance with a numeric value from 0 to 999999. The value of this variable can be passed in the second argument, that is, the previous check for its belonging to an IPv4 address failed.  Or already calculated difference between the addresses specified in the arguments.  If the value of this variable is too large, or does not correspond at all to the number (this may be after our calculations, for example, if the difference between IPv4 addresses is negative), then no further processing will be performed.  If everything is in order, then we display the first element from the list (IPv4 address specified by the first argument).  Then I will call the resulting list of IPv4 addresses a sequence, so as not to be confused with the internal concept of TCL - the list. <br><br>  <b>Ver.2, ‚Ññ28-29</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> i 0} {<span class="hljs-variable"><span class="hljs-variable">$i</span></span>&lt;<span class="hljs-variable"><span class="hljs-variable">$countip</span></span>} {incr i 1} { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsip [lreplace <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> {3} {3} [expr [lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> {3}] + 1]]</code> </pre></blockquote><br>  We form the remaining elements of the desired sequence, again I really want to use arrays, but it seems to me worse to translate from a list to an array than to use lists in this form (how to do it correctly and simply?).  Here is the <b>for</b> loop <b>for</b> variable <i>i</i> running through a value from 0 to the maximum calculated (or given) element of the sequence <i>countip</i> .  Inside the loop, the last element of the previously formed <i>octsip</i> list (the least <i>significant</i> octet in our address) is increased by 1 ... <br><br>  <b>Ver.2, ‚Ññ30-36</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> j 3} {<span class="hljs-variable"><span class="hljs-variable">$j</span></span>&gt;=0} {incr j -1} { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> <span class="hljs-variable"><span class="hljs-variable">$j</span></span>] &gt; 255 &amp;&amp; <span class="hljs-variable"><span class="hljs-variable">$j</span></span> &gt; 0} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sj [expr <span class="hljs-variable"><span class="hljs-variable">$j</span></span> - 1] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsip [lreplace <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> <span class="hljs-variable"><span class="hljs-variable">$j</span></span> <span class="hljs-variable"><span class="hljs-variable">$j</span></span> {0}] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsip [lreplace <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> <span class="hljs-variable"><span class="hljs-variable">$sj</span></span> <span class="hljs-variable"><span class="hljs-variable">$sj</span></span> [expr [lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> <span class="hljs-variable"><span class="hljs-variable">$sj</span></span>] + 1]] } }</code> </pre></blockquote><br>  ... and check whether it is necessary to adjust other digits.  For this, we also organize a <b>for</b> loop with variable <i>j</i> running through values ‚Äã‚Äãfrom 3 to 0. Next in the if condition, we check that the current octet is greater than 255 (an overflow occurred) and this is not the leading octet <i>j</i> greater than 0, but not equal to 0. If overflow occurred , the current octet is zeroed out, we add 1 to the <i>most significant</i> octet (which corresponds to the element of the <i>octsip</i> list closer to its beginning). If the overflow occurred in the senior octet, then we do not make an adjustment, so that we have the wrong IPv4 address. <br><br>  <b>Ver.2, ‚Ññ37-44</b> <br><blockquote><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> oip [join <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> {.}] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$oip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { puts <span class="hljs-variable"><span class="hljs-variable">$oip</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">":    "</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 3 } }</code> </pre></blockquote><br>  Merge the resulting list containing the octets of our address together, <b>join</b> the variable <i>oip</i> separator - a point.  Next, we check the result for belonging to an IPv4 address using our regular expression specified at the very beginning.  If everything is correct, we deduce, if not, then an overflow or another error has already occurred in the process of forming a sequence, we exit <b>exit</b> .  This moment is also not quite beautiful, since we have several exit points, which can be inconvenient if we want, for example, to perform the same type of actions at the end. <br>  The last closing parenthesis is the completion of the <b>for</b> loop that forms the output sequence and is open in line 28. <br><br>  <b>Ver.2, ‚Ññ45-51</b> <br><blockquote><pre> <code class="bash hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">"    \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$getcountip</span></span></span><span class="hljs-string">\""</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">"   IP  \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$startip</span></span></span><span class="hljs-string">\""</span></span> } }</code> </pre></blockquote><br>  The final lines, in which we display error messages on the <b>else</b> branches for conditions of 26 and 16 lines, where we check the arguments given at the start of the program to meet the expectations.  This is the only place where the <i>getcountip</i> variable is used <i>that</i> stores the second received argument of the program unchanged, which is strange and seems like brute force, but the obvious (simple) other option could not be implemented in this case. <br>  Looking through the second time already this part of the program (where the sequence is formed for output), I first thought that it would be nice to implement a full adder of 4-bit numbers in the base 256 base system and a translator into the additional code of these same numbers so that subtraction on the same adder.  By that time, I had not yet changed the first part, and was dominated by ideas about the simplicity of calculations by the bar.  The desire to implement this (wild) venture did not pass, as it is interesting in itself, but perhaps not at TCL.  It was already clear that the second part should be changed in the same way as the first, that is, to make a translation from the usual representation to the one we need (and this is already a translation into a 256-number system). <br>  The concept of busting has also changed. If we can sort through IPv4 addresses in the <b>for</b> loop, then we need not pre-calculate the size of a given sequence, we will simply move from one address in a row to another.  Also in this approach, it turned out to be very easy for us to move not only in the forward direction from the smallest to the larger, but also in the opposite direction - this does not require additional efforts, we just need to correctly set the increment of the loop variable when it is formed (here there is an opportunity for additional functionality that allows form a sequence in any direction). <br><br>  <b>Ver.3, ‚Ññ31-32</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {<span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$minip</span></span> &amp;&amp; <span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &lt; <span class="hljs-variable"><span class="hljs-variable">$maxip</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> d [expr <span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &gt;= <span class="hljs-variable"><span class="hljs-variable">$nsip</span></span>]]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> di {1}} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> di {-1}}</code> </pre></blockquote><br>  We check the ownership of <i>nfip</i> , in which, I recall, the second argument contains the IPv4 address as a number in the specified range ( <i>minip</i> and <i>maxip are</i> defined at the beginning of the program).  If we fall into the range, then we set the direction of the search, if the second IPv4 <i>nfip</i> address is <i>greater</i> than the first <i>nsip</i> (we already have the address in the form of numbers), then the search in the direct order is a variable <i>di</i> = 1, if less, then the search in the reverse order, <i>di</i> = -one.  The result of the comparison is also remembered in <i>d</i> . <br><br>  <b>Ver.3, ‚Ññ33-37</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> i <span class="hljs-variable"><span class="hljs-variable">$nsip</span></span>} {(<span class="hljs-variable"><span class="hljs-variable">$i</span></span>&lt;=<span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &amp;&amp; <span class="hljs-variable"><span class="hljs-variable">$d</span></span>) || (<span class="hljs-variable"><span class="hljs-variable">$i</span></span>&gt;=<span class="hljs-variable"><span class="hljs-variable">$nfip</span></span> &amp;&amp; !<span class="hljs-variable"><span class="hljs-variable">$d</span></span>)} {incr i <span class="hljs-variable"><span class="hljs-variable">$di</span></span>} { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octip [list [expr (<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &amp; 0xFF000000) &gt;&gt; 24] [expr (<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &amp; 0xFF0000) &gt;&gt; 16]\ [expr (<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &amp; 0xFF00) &gt;&gt; 8] [expr (<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &amp; 0xFF)]] puts [join <span class="hljs-variable"><span class="hljs-variable">$octip</span></span> {.}] }</code> </pre></blockquote><br>  We organize a <b>for</b> loop on a variable <i>i</i> whose initial value is set to <i>nsip</i> , and the exit condition is adjusted with the condition <i>nfip&gt; = nsip</i> , the result of which we store in <i>d</i> : <i>i &lt;= nfip</i> if we approach <i>nfip</i> from below, or otherwise <i>i&gt; = nfip</i> .  The increment <i>i is</i> already calculated and stored in <i>di</i> . <br>  In the body of the loop, we form an <i>octsip</i> list of octets of the IPv4 address.  That is, we need to form the address in the decimal representation of its numerical representation ‚Äî translate into a 256-number system.  In the general case, following the theory, we need to divide the number in one number system, on the basis of another number system and form a number from the residuals in the new number system (on the basis of which we divide): <br><blockquote><pre>   3,221,225,985 |  256
  -3 221 225 984 |  -----------
  -------------- |  12,582,914 |  256
               1 |  -12 582 912 |  ------- 
                    ---------- |  49 152 |  256
                             2 |  -49 152 |  ---
                                       0 |  192                                                     
</pre></blockquote><br>  Starting from the result of 192, for all balances in the reverse order of 0, 2, 1 we get 192.0.2.1.  Dividing is a complicated operation and does not bring any optimization, but in our very special case: IPv4 address and dividing by 256 - everything is very simple.  We will shift by 8 (divide by degrees 256) and mask the bits we don't need (binary operation ‚ÄúAND‚Äù).  Imagine in hexadecimal: <br><blockquote><pre>    0xC0000201 |  0xC0000201 |  0xC0000201 |  0xC0000201
   &amp; 0xFF000000 |  &amp; 0x00FF0000 |  &amp; 0x0000FF00 |  &amp; 0x000000FF
  -------------------------------------------------- -------------------
    0xC0000000 &gt;&gt; 24 |  0x00000000 &gt;&gt; 16 |  0x00000200 &gt;&gt; 8 |  0x00000001
  -------------------------------------------------- -------------------
  = 0xC0 (192) |  = 0x00 (0) |  = 0x02 (2) |  = 0x01 (1)
</pre></blockquote><br>  All this is done in one line, each digit is placed in its list <b>list</b> item.  The second operator in the body of the loop displays a combined list. <br><br>  <b>Ver.3, ‚Ññ38-45</b> <br><blockquote><pre> <code class="bash hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">" IP      "</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 3 } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">"   IP  \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$startip</span></span></span><span class="hljs-string">\""</span></span> } }</code> </pre></blockquote><br>  The final lines are almost indistinguishable, besides the conclusion about the error of setting the second argument is shifted slightly higher in the program.  The first part of the program, compared with the second version, also changed a little. <br><br>  <b>Ver.3, ‚Ññ1-7</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/tclsh8.5 set exip {^(2(5[0-5]|[0-4]\d)|1\d{2}|[1-9]\d{0,1})(\.(2(5[0-5]|[0-4]\d)|1\d{2}|[1-9]\d|\d)){3}$} set exdg {^-?(0?|([1-9]\d*))$} set maxip {0xFFFFFFFF} set minip {0xFFFFFF}</span></span></code> </pre></blockquote><br>  A regular expression for checking a numeric parameter now returns a positive answer for any numerical values ‚Äã‚Äãof any length, without a leading 0, but with a possible negative sign "-" in front.  Here we have simplified the check and expanded the boundaries, because the length of the resulting sequence is checked in numeric form using the following <i>maxip</i> and <i>minip variables</i> .  These values ‚Äã‚Äãdo not duplicate the regular <i>exip</i> expression, since it now checks only the correctness of user input, and not the results of calculations. <br><br>  <b>Ver.3, ‚Ññ15-20</b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> startip [lindex <span class="hljs-variable"><span class="hljs-variable">$argv</span></span> 0] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {![string length [<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> finiship [lindex <span class="hljs-variable"><span class="hljs-variable">$argv</span></span> 1]]]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> finiship {0}} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$startip</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octsip [split <span class="hljs-variable"><span class="hljs-variable">$startip</span></span> {.}] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nsip [expr ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 0] * 0x1000000) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 1] * 0x10000)\ + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 2] * 0x100) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octsip</span></span> 3])]</code> </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 8-14 almost completely repeat lines 6-12 of the first option, only slightly corrected messages in accordance with the new functionality. Then we perform almost the same actions as the second option. The only thing we force is to set the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finiship</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value </font><font style="vertical-align: inherit;">to 0 if the second argument was not set so that the variable was always defined. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finiship</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has the same meaning as the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">countip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the second option, and was renamed to fit the new concept. Ultimately, this variable will not contain the size of the sequence of IPv4 addresses, but the last address of this sequence. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perform the </font><i><font style="vertical-align: inherit;">nsip</font></i><font style="vertical-align: inherit;"> calculation </font><font style="vertical-align: inherit;">immediately after decomposing the first argument into its components. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver.3, ‚Ññ21-30</font></font></b> <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> {[regexp <span class="hljs-variable"><span class="hljs-variable">$exip</span></span> <span class="hljs-variable"><span class="hljs-variable">$finiship</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> octfip [split <span class="hljs-variable"><span class="hljs-variable">$finiship</span></span> {.}] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nfip [expr ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 0] * 0x1000000) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 1] * 0x10000)\ + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 2] * 0x100) + ([lindex <span class="hljs-variable"><span class="hljs-variable">$octfip</span></span> 3])] } elseif {[regexp <span class="hljs-variable"><span class="hljs-variable">$exdg</span></span> <span class="hljs-variable"><span class="hljs-variable">$finiship</span></span>] &amp;&amp; [expr abs(<span class="hljs-variable"><span class="hljs-variable">$finiship</span></span>)] &lt; <span class="hljs-variable"><span class="hljs-variable">$maxip</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nfip [expr <span class="hljs-variable"><span class="hljs-variable">$nsip</span></span> + <span class="hljs-variable"><span class="hljs-variable">$finiship</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { puts <span class="hljs-string"><span class="hljs-string">"    \"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$finiship</span></span></span><span class="hljs-string">\""</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 5 }</code> </pre></blockquote><br>         ,   ‚Äî        . <br>   <b>elseif</b>        ,            ,        IPv4 ,        ,     .   ,  <i>nfip</i>      <i>nsip</i> .     IPv4 ,       (    ). <br>       ,  IPv4  ‚Äî   <b>exit</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Again, we obtain a multiplicity of exit points, and in this version there are three of them. This can be overcome by wrapping the entire program in an endless loop and, if necessary, interrupting its </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">break</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the end of the program, but here it was not at all necessary. As mentioned earlier, all error checking can be eliminated by replacing them with default actions, this is more appropriate for the command mode. In this variant, there is no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getcountip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">- the second argument </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finiship</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is directly present in the error message </font><font style="vertical-align: inherit;">, since it does not change, but is only used in the course of work.</font></font><br>    (cipl.tl) ,  IPv4           IPv4    ,          .       ,        . <br><blockquote><pre>&gt; cipl.tl 192.0.2.1 -1<font></font>
192.0.2.1<font></font>
192.0.2.0<font></font>
&gt; cipl.tl 192.0.2.1 192.0.2.0<font></font>
192.0.2.1<font></font>
192.0.2.0<font></font>
</pre></blockquote><br>    ,     ,          <a href="http://habrahabr.ru/blogs/complete_code/135340">habrahabr.ru/blogs/complete_code/135340</a> ,       ,  : ¬´  ,  ¬ª,   . <br><br>     : <a href="http://yadi.sk/d/O582G4HypFjW">cipl.zip</a> <br>       wikibooks ‚Äî <a href="http://ru.wikibooks.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D1%258B_%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">ru.wikibooks.org/wiki/_</a> <br>      TCL   <a href="http://www.tcl.tk/doc">www.tcl.tk/doc</a>   <a href="http://wiki.tcl.tk/">wiki.tcl.tk</a> </div><p>Source: <a href="https://habr.com/ru/post/135920/">https://habr.com/ru/post/135920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135914/index.html">The interaction of the circuit in Proteus with the outside world</a></li>
<li><a href="../135915/index.html">Backdoor in Active Directory # 2</a></li>
<li><a href="../135916/index.html">Manual: Pyramid for People - Table of Contents</a></li>
<li><a href="../135917/index.html">New C ++ World Map from Alenacpp</a></li>
<li><a href="../135919/index.html">Simple minimalist implementation of complex JavaScript applications</a></li>
<li><a href="../135921/index.html">Close the site mirror from indexing correctly</a></li>
<li><a href="../135922/index.html">JRebel Quickstart</a></li>
<li><a href="../135926/index.html">How do you type important letters?</a></li>
<li><a href="../135927/index.html">Browser "Internet"</a></li>
<li><a href="../135928/index.html">Nokia introduced the Lumia 900 for AT & T</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>