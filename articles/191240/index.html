<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elliptical cryptography: practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi% username%! 

 A couple of weeks ago I published the post Elliptic Cryptography: a theory in which I tried to describe the main aspects of using el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elliptical cryptography: practice</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/ff3/29e/5fc/ff329e5fc4ee48e53e9fc6909dd634eb.jpg" alt="image" align="left"><br>  Hi% username%! <br><br>  A couple of weeks ago I published the post <a href="http://habrahabr.ru/post/188958/">Elliptic Cryptography: a theory</a> in which I tried to describe the main aspects of using elliptic curves in cryptography.  That my post carried exclusively fact-finding character, and did not provide any other work with the compiler, except contemplative.  But what kind of theory without practice?  In order to correct this omission, I, gathering my courage, rushed into battle with GOST, 10/34/2012, an EDS scheme on elliptic curves.  If it is interesting to you to look that from all this it turned out, then welcome under kat. <a name="habracut"></a><br><br>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Elliptic Curve Selection </h4><br>  Let me remind you that in elliptical cryptography are used so-called.  "Curves over a finite field".  This means that the curves have a finite number of points.  The number of points of such a curve is called the <b>order of the curve</b> .  To use an elliptic curve in cryptography, you need to know its order.  This is due at least to the fact that the crypto-resistance of the system depends on the order of the curve, which I wrote about in my previous opus. <br>  This is where the complexity lies.  The process of choosing a curve can be written as follows: <br><ol><li>  The choice of the parameters a and b, describing the equation of a straight line <img src="https://habrastorage.org/storage2/22b/cff/93d/22bcff93d1aac6c21be568e1d2bb76b4.png" alt="image"></li><li>  Counting the points of the selected curve; </li><li>  Check whether the selected curve with a given number of points corresponds to a set of conditions. </li></ol><br>  So, the problem is that the calculation of the order of an elliptic curve is a very nontrivial task. <br><br>  The most common method of calculating the number of points <a href="http://en.wikipedia.org/wiki/Schoof%27s_algorithm">Shuf algorithm</a> has a fairly large computational complexity <img src="https://habrastorage.org/getpro/habr/post_images/b12/741/b40/b12741b40629ebcbfba8a91935c9efc3.png" alt="image">  .  In addition, the algorithm uses very serious mathematical methods and is very difficult to understand. <br><br>  There is another way, the so-called.  <b>complex multiplication method</b> .  The kind Habrachelovek <a href="http://habrahabr.ru/users/grechnik/" class="user_link">grechnik has</a> kindly shared information about this method in his post. <a href="http://habrahabr.ru/post/189618/">Representation of numbers by the sum of two squares and elliptic curves</a> .  In short, this method makes it much more efficient to find curves with a given number of points.  However, unlike the Shuf algorithm, which is universal, the complex multiplication method works only when certain conditions are met.  This method is also not as simple as it may seem at first.  More details about this can be for example <a href="http://tuprints.ulb.tu-darmstadt.de/211/1/dissertation_harald_baier.pdf">here</a> (thanks again for the link, <a href="http://habrahabr.ru/users/grechnik/" class="user_link">grechnik</a> ). <br><br>  Fortunately, NIST, apparently in order to <s>create backdoors to</s> make life easier for developers, has compiled a list of elliptic curves with an already known number of points that are recommended for use in EDS schemes.  Actually, I chose one of these curves for my experiments. <br><br>  To describe the curve in the NIST standard, a set of 6 parameters D = (p, a, b, G, n, h) is used, where <br><br>  <b>p</b> is a prime number, modulus of an elliptic curve; <br>  <b>a, b</b> - set the equation of an elliptic curve <img src="https://habrastorage.org/storage2/22b/cff/93d/22bcff93d1aac6c21be568e1d2bb76b4.png" alt="image">  ; <br>  <b>G</b> is a point of an elliptic curve of large order.  This means that if you multiply a point by numbers smaller than the order of a point, each time you get completely different points; <br>  <b>n</b> is the order of the point G; <br>  <b>h</b> is a parameter called a cofactor.  It is determined by the ratio of the total number of points on an elliptic curve to the order of the point G. This number should be as small as possible. <br><br><h4>  A couple of words about the parameters </h4><br>  Not really bothering with the choice, I decided to use the first NIST recommended curve, in which the value of the parameters described above is equal to: <br>  p = 6277101735386680763835789423207666416083908700390324961279; <br>  a = -3; <br>  b = 2455155546008943817740293915197451784769108058161191238065; <br>  x <sub>G</sub> = 602046282375688656758213480587526111916698976636884684818 (the x-coordinate of the point G); <br>  y <sub>G</sub> = 174050332293622031404857552280219410364023488927386650641 (the y-coordinate of the point G); <br>  n = 6277101735386680763835789423176059013767194773182842284081; <br>  h = 1. <br><br>  About the parameter <b>p</b> , I tell you in more detail.  This number refers to the <b>generalized Mersenne numbers</b> , which means that it can be represented as the sum of the various powers of two.  Specifically in our case, the number <b>p</b> can be written as <br>  p = 2 <sup>192</sup> -2 <sup>64</sup> -1. <br>  All elliptic curves over a prime field recommended by NIST can be written in a similar way.  Using such numbers allows you to speed up the multiplication operation modulo a large number.  The essence of the method is reduced to the representation of the result of multiplication in the form of 32-bit machine words, the combination of which results in the desired product modulo a large number.  You can read more about this, for example, <a href="http://cryptography.programmation.ru/58.shtml">here</a> (thanks to <a href="http://habrahabr.ru/users/datacompboy/" class="user_link">datacompboy</a> for the tip). <br><br>  Another interesting point is related to the coordinates of the points.  Often, in various kinds of specifications, the generator point G of an elliptic curve is specified in a compressed form.  For example, in our case the point G can be set as follows: <br><br>  G = 0x 03 188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012 <br><br>  The first byte stores the parity data of the y-coordinate.  It can be equal to 2 (this means that the y-coordinate is even) or 3 (respectively, odd).  The remaining bytes store the x-coordinate. <br>  With this data we can restore the y-coordinate as follows. <br><br>  We know that the point G belongs to an elliptic curve.  Accordingly, for it is equal: <br><br><img src="https://habrastorage.org/storage2/d7b/89d/dee/d7b89ddee68b1f62563e751f127a648b.png"><br><br>  and we can calculate <b>y</b> like: <br><br><img src="https://habrastorage.org/storage2/02c/9b6/449/02c9b6449da3f8995feedd01ed2ca8c4.png">  . <br><br>  Since the result of calculating the square root modulo <b>p</b> is two numbers <b>y</b> and <b>py</b> , we choose the number whose parity coincides with the parity of the first byte of the compressed coordinate record G. <br><br><h4>  Signature generation </h4><br>  Before embarking on the implementation of the EDS algorithm itself, it is necessary to write a class for working with points of an elliptic curve.  I wrote a little about mathematical laws and operations on elliptic curves in the last post, so I will not focus on this now. <br>  Let me just say that to implement GOST 34.10, we need only three operations: <br><ul><li>  Addition of two different points; </li><li>  Double point; </li><li>  Multiplication of a point by a number. </li></ul><br>  <i>A little more details can be found, for example, on <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F">Wikipedia</a> .</i> <br><br>  The implementation of the ECPoint class, which allows you to perform these actions, look under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">ECPoint.cs</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ECPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BigInteger x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BigInteger y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BigInteger a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BigInteger b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BigInteger FieldChar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ECPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ECPoint p</span></span></span><span class="hljs-function">)</span></span> { x = px; y = py; a = pa; b = pb; FieldChar = p.FieldChar; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ECPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); FieldChar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); } <span class="hljs-comment"><span class="hljs-comment">//   P1  P2 public static ECPoint operator +(ECPoint p1, ECPoint p2) { ECPoint p3 = new ECPoint(); p3.a = p1.a; p3.b = p1.b; p3.FieldChar = p1.FieldChar; BigInteger dy = p2.y - p1.y; BigInteger dx = p2.x - p1.x; if (dx &lt; 0) dx += p1.FieldChar; if (dy &lt; 0) dy += p1.FieldChar; BigInteger m = (dy * dx.modInverse(p1.FieldChar)) % p1.FieldChar; if (m &lt; 0) m += p1.FieldChar; p3.x = (m * m - p1.x - p2.x) % p1.FieldChar; p3.y = (m * (p1.x - p3.x) - p1.y) % p1.FieldChar; if (p3.x &lt; 0) p3.x += p1.FieldChar; if (p3.y &lt; 0) p3.y += p1.FieldChar; return p3; } //  P c   public static ECPoint Double(ECPoint p) { ECPoint p2 = new ECPoint(); p2.a = pa; p2.b = pb; p2.FieldChar = p.FieldChar; BigInteger dy = 3 * px * px + pa; BigInteger dx = 2 * py; if (dx &lt; 0) dx += p.FieldChar; if (dy &lt; 0) dy += p.FieldChar; BigInteger m = (dy * dx.modInverse(p.FieldChar)) % p.FieldChar; p2.x = (m * m - px - px) % p.FieldChar; p2.y = (m * (px - p2.x) - py) % p.FieldChar; if (p2.x &lt; 0) p2.x += p.FieldChar; if (p2.y &lt; 0) p2.y += p.FieldChar; return p2; } //    x,     x      public static ECPoint multiply(BigInteger x, ECPoint p) { ECPoint temp = p; x = x - 1; while (x != 0) { if ((x % 2) != 0) { if ((temp.x == px) || (temp.y == py)) temp = Double(temp); else temp = temp + p; x = x - 1; } x = x / 2; p = Double(p); } return temp; } }</span></span></code> </pre> <br></div></div><br><br>  To generate a digital signature, a large number <b>d is used</b> , which is the <b>permanent secret key of the</b> scheme, and should be known only to the signer. <br>  To calculate the message signature M using the GOST algorithm, the following steps must be performed: <br><br><ol><li>  Calculate the message hash M: <b>H</b> = h (M).  At this step, the Stribog hash function is used, which I already <a href="http://habrahabr.ru/post/188152/">wrote about</a> in Habr√©; </li><li>  Calculate the integer <b>Œ±</b> , the binary representation of which is H; </li><li>  Define <b>e</b> = Œ± mod n, if e = 0, set e = 1; </li><li>  Generate a random number <b>k</b> satisfying the condition 0 &lt;k &lt;n; </li><li>  Calculate the point of an elliptic curve <b>C</b> = k * G; </li><li>  Determine <b>r</b> = x <sub>C</sub> mod n, where x <sub>C</sub> is the x-coordinate of point C. If r = 0, then return to step 4; </li><li>  Calculate the value <b>s</b> = (rd + ke) mod n.  If s = 0, then go back to step 4; </li><li>  Return the value of <b>r || s</b> as a digital signature. </li></ol><br><br>  Let's write the <b>SignGen</b> function that implements all these actions: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignGen</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] h, BigInteger d</span></span></span><span class="hljs-function">)</span></span> { BigInteger alpha = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(h); BigInteger e = alpha % n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == <span class="hljs-number"><span class="hljs-number">0</span></span>) e = <span class="hljs-number"><span class="hljs-number">1</span></span>; BigInteger k = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); ECPoint C=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ECPoint(); BigInteger r=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); BigInteger s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k.genRandomBits(n.bitCount(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random()); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((k &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || (k &gt; n)); C = ECPoint.multiply(k, G); r = Cx % n; s = ((r * d) + (k * e)) % n; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((r == <span class="hljs-number"><span class="hljs-number">0</span></span>)||(s==<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Rvector = padding(r.ToHexString(),n.bitCount()/<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Svector = padding(s.ToHexString(), n.bitCount() / <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rvector + Svector; }</code> </pre><br><br>  In the given part of the code, the <b>padding</b> function complements the hexadecimal representations of the numbers r and s to the length of the module p, so that when checking the signature they can be parsed. <br><br><h4>  Signature verification </h4><br>  To verify the signature, a point <b>Q is used</b> that satisfies the equality Q = d * G.  Point Q is the <b>public key of the scheme</b> and can be known to any verifier. <br>  Signature verification process occurs according to the following algorithm: <br><br><ol><li>  According to the received signature, restore the numbers r and s.  If the inequalities 0 &lt;r &lt;n and 0 &lt;s &lt;n are not met, then return ‚Äúthe signature is not true‚Äù; </li><li>  Calculate the message hash M: <b>H</b> = h (M); </li><li>  Calculate the integer <b>Œ±</b> , the binary representation of which is H; </li><li>  Define <b>e</b> = Œ± mod n, if e = 0, set e = 1; </li><li>  Calculate <b>v</b> = e <sup>-1</sup> mod n; </li><li>  Calculate the values ‚Äã‚Äãof <b>z <sub>1</sub></b> = s * v mod n and <b>z <sub>2</sub></b> = -r * v mod n; </li><li>  Calculate the point of an elliptic curve C = z <sub>1</sub> * G + z <sub>2</sub> * Q; </li><li>  Determine R = x <sub>c</sub> mod n, where x <sub>c</sub> is the x-coordinate of point C; </li><li>  If R = r, then the signature is correct.  Otherwise, the signature is not accepted. </li></ol><br><br>  To understand why this works, we write the signature verification process in the form of formulas: <br><img src="https://habrastorage.org/storage2/b10/63a/d0d/b1063ad0d247bba8c81c8cd4a704a404.png"><br>  As you can see, at the verification stage we get that same point C = k * G, as in the formation of the signature. <br><br>  The SignVer function that performs the check: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignVer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] H, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sign, ECPoint Q</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Rvector = sign.Substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, n.bitCount() / <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Svector = sign.Substring(n.bitCount() / <span class="hljs-number"><span class="hljs-number">4</span></span>, n.bitCount() / <span class="hljs-number"><span class="hljs-number">4</span></span>); BigInteger r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(Rvector, <span class="hljs-number"><span class="hljs-number">16</span></span>); BigInteger s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(Svector, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((r &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) || (r &gt; (n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) || (s &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) || (s &gt; (n - <span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; BigInteger alpha = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(H); BigInteger e = alpha % n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == <span class="hljs-number"><span class="hljs-number">0</span></span>) e = <span class="hljs-number"><span class="hljs-number">1</span></span>; BigInteger v = e.modInverse(n); BigInteger z1 = (s * v) % n; BigInteger z2 = n + ((-(r * v)) % n); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.G = GDecompression(); ECPoint A = ECPoint.multiply(z1, G); ECPoint B = ECPoint.multiply(z2, Q); ECPoint C = A + B; BigInteger R = Cx % n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R == r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  The <b>GDecompression ()</b> function unpacks points. <br><br>  Fully DSGost class, which implements the signature and verification of messages using the GOST 34.10-2012 algorithm, you can look under the spoiler. <br><div class="spoiler">  <b class="spoiler_title">DSGost.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DSGost</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigInteger p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigInteger a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigInteger b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigInteger n = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] xG; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ECPoint G = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ECPoint(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSGost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BigInteger p, BigInteger a, BigInteger b, BigInteger n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] xG</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p = p; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xG = xG; } <span class="hljs-comment"><span class="hljs-comment">//     public BigInteger GenPrivateKey(int BitSize) { BigInteger d = new BigInteger(); do { d.genRandomBits(BitSize, new Random()); } while ((d &lt; 0) || (d &gt; n)); return d; } //    d   Q=d*G,       public ECPoint GenPublicKey(BigInteger d) { ECPoint G=GDecompression(); ECPoint Q = ECPoint.multiply(d, G); return Q; } //  y   x    y private ECPoint GDecompression() { byte y = xG[0]; byte[] x=new byte[xG.Length-1]; Array.Copy(xG, 1, x, 0, xG.Length - 1); BigInteger Xcord = new BigInteger(x); BigInteger temp = (Xcord * Xcord * Xcord + a * Xcord + b) % p; BigInteger beta = ModSqrt(temp, p); BigInteger Ycord = new BigInteger(); if ((beta % 2) == (y % 2)) Ycord = beta; else Ycord = p - beta; ECPoint G = new ECPoint(); Ga = a; Gb = b; G.FieldChar = p; Gx = Xcord; Gy = Ycord; this.G = G; return G; } //        q public BigInteger ModSqrt(BigInteger a, BigInteger q) { BigInteger b = new BigInteger(); do { b.genRandomBits(255, new Random()); } while (Legendre(b, q) == 1); BigInteger s = 0; BigInteger t = q - 1; while ((t &amp; 1) != 1) { s++; t = t &gt;&gt; 1; } BigInteger InvA = a.modInverse(q); BigInteger c = b.modPow(t, q); BigInteger r = a.modPow(((t + 1) / 2), q); BigInteger d = new BigInteger(); for (int i = 1; i &lt; s; i++) { BigInteger temp = 2; temp = temp.modPow((s - i - 1), q); d = (r.modPow(2, q) * InvA).modPow(temp, q); if (d == (q - 1)) r = (r * c) % q; c = c.modPow(2, q); } return r; } //   public BigInteger Legendre(BigInteger a, BigInteger q) { return a.modPow((q - 1) / 2, q); } //  public string SignGen(byte[] h, BigInteger d) { BigInteger alpha = new BigInteger(h); BigInteger e = alpha % n; if (e == 0) e = 1; BigInteger k = new BigInteger(); ECPoint C=new ECPoint(); BigInteger r=new BigInteger(); BigInteger s = new BigInteger(); do { do { k.genRandomBits(n.bitCount(), new Random()); } while ((k &lt; 0) || (k &gt; n)); C = ECPoint.multiply(k, G); r = Cx % n; s = ((r * d) + (k * e)) % n; } while ((r == 0)||(s==0)); string Rvector = padding(r.ToHexString(),n.bitCount()/4); string Svector = padding(s.ToHexString(), n.bitCount() / 4); return Rvector + Svector; } //  public bool SignVer(byte[] H, string sign, ECPoint Q) { string Rvector = sign.Substring(0, n.bitCount() / 4); string Svector = sign.Substring(n.bitCount() / 4, n.bitCount() / 4); BigInteger r = new BigInteger(Rvector, 16); BigInteger s = new BigInteger(Svector, 16); if ((r &lt; 1) || (r &gt; (n - 1)) || (s &lt; 1) || (s &gt; (n - 1))) return false; BigInteger alpha = new BigInteger(H); BigInteger e = alpha % n; if (e == 0) e = 1; BigInteger v = e.modInverse(n); BigInteger z1 = (s * v) % n; BigInteger z2 = n + ((-(r * v)) % n); this.G = GDecompression(); ECPoint A = ECPoint.multiply(z1, G); ECPoint B = ECPoint.multiply(z2, Q); ECPoint C = A + B; BigInteger R = Cx % n; if (R == r) return true; else return false; } //      n,  n -     private string padding(string input, int size) { if (input.Length &lt; size) { do { input = "0" + input; } while (input.Length &lt; size); } return input; } }</span></span></code> </pre><br></div></div><br><br>  Example of working with the class: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ECTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { BigInteger p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(<span class="hljs-string"><span class="hljs-string">"6277101735386680763835789423207666416083908700390324961279"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); BigInteger a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(<span class="hljs-string"><span class="hljs-string">"-3"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); BigInteger b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(<span class="hljs-string"><span class="hljs-string">"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] xG = FromHexStringToByte(<span class="hljs-string"><span class="hljs-string">"03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012"</span></span>); BigInteger n = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(<span class="hljs-string"><span class="hljs-string">"ffffffffffffffffffffffff99def836146bc9b1b4d22831"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); DSGost DS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DSGost(p, a, b, n, xG); BigInteger d=DS.GenPrivateKey(<span class="hljs-number"><span class="hljs-number">192</span></span>); ECPoint Q = DS.GenPublicKey(d); GOST hash = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GOST(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] H = hash.GetHash(Encoding.Default.GetBytes(<span class="hljs-string"><span class="hljs-string">"Message"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sign = DS.SignGen(H, d); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = DS.SignVer(H, sign, Q); }</code> </pre><br><br><h4>  Conclusion </h4><br>  We considered the case when a cryptosystem is built on an elliptic curve over a residue field modulo a large prime number.  However, one should not forget that the concept of elliptic cryptography includes much more than this single case.  And when implementing cryptosystems on elliptic curves over fields of other types, it is necessary to take into account that the mathematical operations on these curves can differ significantly from those given in this post. <br><br>  PS project sources are <a href="https://github.com/NeverWalkAloner/ECCGost">here</a> . <br><h4>  Links </h4><br><ol><li>  <a href="http://www.altell.ru/legislation/standards/gost-34.10-2012.pdf">Reference to the standard GOST 34.10-2012;</a> </li><li>  <a href="http://cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf">Reference to the ECDSA standard with a list of recommended curves.</a> </li><li>  <a href="http://www.secg.org/collateral/sec2_final.pdf">Standards for Efficient Cryptography, an extended list of recommended curves.</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/191240/">https://habr.com/ru/post/191240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191216/index.html">Zephyr - NASA Sail Rover to explore Venus</a></li>
<li><a href="../191218/index.html">Divide and rule. Or a rights sharing system for ASP MVC</a></li>
<li><a href="../191232/index.html">Google is working on unmanned vehicles of its own production</a></li>
<li><a href="../191234/index.html">Ranking algorithm changes in App Store</a></li>
<li><a href="../191236/index.html">How to start developing games even if you were an accountant before</a></li>
<li><a href="../191242/index.html">Programmer's brain</a></li>
<li><a href="../191246/index.html">Conflict Resolution in Transitive Dependencies - Good, Bad, Angry</a></li>
<li><a href="../191248/index.html">ASP.NET MVC client-side routing</a></li>
<li><a href="../191250/index.html">Internal device llst, part 2 or Little Smalltalk + LLVM =</a></li>
<li><a href="../191252/index.html">Parsing and building syntax trees with PLY. The basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>