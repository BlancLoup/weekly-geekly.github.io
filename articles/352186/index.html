<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cache problems and solutions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 My name is Victor Pryazhnikov, I work for the Badoo SRV team. Our team develops and maintains an internal API for our clients from the se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cache problems and solutions</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  My name is Victor Pryazhnikov, I work for the Badoo SRV team.  Our team develops and maintains an internal API for our clients from the server side, and data caching is something we encounter every day. <br><br>  There is an opinion that in programming there are only two truly complex tasks: inventing names and invalidation of the cache.  I will not argue with the fact that disability is difficult, but it seems to me that caching is a pretty tricky thing, even without considering disability.  There are many things to think about before starting to use the cache.  In this article I will try to formulate some problems that can be encountered when working with a cache in a large system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/8y/yz/ra/8yyzrae06lhwrrrbqlm3kvwauko.jpeg"><br>  <i>Wild horses stampeding.</i>  <i><a href="https://en.wikipedia.org/wiki/Stampede">Original picture.</a></i> <br><br>  I will talk about the problems of separating cached data between servers, parallel updates of data, cold start and system malfunctioning.  I will also describe possible solutions to these problems and provide links to materials where these topics are covered in more detail.  I will not tell what cache is in principle and concern the details of the implementation of specific systems. <br><br>  In my work, I assume that the system in question consists of an application, a database and a cache for data.  Instead of a database, any other source can be used (for example, some microservice or an external API). <br><a name="habracut"></a><br><h2>  Dividing data between caching servers </h2><br>  If you want to use caching in a large enough system, you need to make sure that you can divide the cached data among the available servers.  This is necessary for several reasons: <br><br><ul><li>  data can be very much, and they physically do not fit in the memory of one server; </li><li>  data can be requested very often, and one server is not able to process all these requests; </li><li>  You want to make caching more reliable.  If you have only one caching server, then if it crashes, the whole system will remain without a cache, which can dramatically increase the load on the database. </li></ul><br>  The most obvious way to break down data is to calculate the server number in a pseudo-random manner, depending on the caching key. <br><br>  There are different algorithms for implementing this.  The easiest is to calculate the server number as the remainder of the integer division of the numerical key representation (for example, CRC32) by the number of cache servers: <br><br><pre><code class="php hljs">$cache_server_index = crc32($cache_key) % count($cache_servers_list);</code> </pre> <br>  Such an algorithm is called modular hashing (English modulo hashing).  CRC32 is used here as an example.  Instead, you can take any other hashing function, from the results of which you can get a number greater or equal to the number of servers, with a more or less evenly distributed result. <br><br>  This method is easy to understand and implement, it distributes data fairly evenly between servers, but it has a serious drawback: when the number of servers changes (due to technical problems or when new ones are added), a significant portion of the cache is lost, since the remainder of the division changes for the keys. <br><br>  I wrote a small script that will demonstrate this problem. <br><br>  It generates 1 million unique keys, distributed across five servers using hashing modulo and CRC32.  I emulate the failure of one of the servers and the redistribution of data on the four remaining ones. <br><br>  As a result of this ‚Äúfailure‚Äù, approximately 80% of the keys will change their location, that is, they will be inaccessible for further reading: <br><br>  Total keys count: 1,000,000 <br>  Shards count range: 4, 5 <br><br><table><tbody><tr><th>  ShardsBefore </th><th>  ShardsAfter </th><th>  LostKeysPercent </th><th>  Lostkeys </th></tr><tr><td align="right">  five </td><td align="right">  four </td><td align="right">  80.03% </td><td align="right">  800345 </td></tr></tbody></table><br>  The most annoying thing here is that 80% is far from the limit.  With the increase in the number of servers, the percentage of cache loss will continue to grow.  The only exception is multiple changes (from two to four, from nine to three, etc.), in which the losses will be less than usual, but in any case at least half of the existing cache: <br><br><img src="https://habrastorage.org/webt/5r/g7/iv/5rg7ivugiqmw8oen_wgh_hrfdau.png"><br>  I put a <a href="https://github.com/pryazhnikov/cache-simulations/">script</a> on <a href="https://github.com/pryazhnikov/cache-simulations/">GitHub</a> with which I collected data, as well as an ipynb file that paints this table and data files. <br><br>  To solve this problem, there is another breakdown algorithm - <b>consistent hashing</b> .  The basic idea of ‚Äã‚Äãthis mechanism is very simple: an additional display of keys is added to the slots, the number of which significantly exceeds the number of servers (there may be thousands and even more).  The slots themselves, in turn, are somehow distributed across servers. <br><br>  When the number of servers changes, the number of slots does not change, but the distribution of slots between these servers changes: <br><br><ul><li>  <i>if one of the servers fails,</i> then all the slots that belong to it are distributed among the remaining ones; </li><li>  <i>if a new server is added,</i> then a part of the slots from the existing servers is transferred to it. </li></ul><br>  Usually, the idea of ‚Äã‚Äãconsistent hashing is visualized with the help of rings, the dots on the circles of which show slots or boundaries of slot ranges (in case there are a lot of these slots).  Here is a simple redistribution example for a situation with a small number of slots (60), which were initially distributed across four servers: <br><br><img src="https://habrastorage.org/webt/y6/ua/jw/y6uajw5sczl7fejjo6bg63ote-i.png"><br><br>  In the picture of the initial partition, all the slots of one server are located in a row, but in reality this is not a necessary condition - they can be located as you please. <br><br>  The main advantage of this method over the previous one is that there is not a single value for each server, but a whole range, and when the number of servers changes, a much smaller part of the keys is redistributed ( <code>k / N</code> , where <code>k</code> is the total number of keys and <code>N</code> is number of servers). <br><br>  If you go back to the scenario that I used to demonstrate the lack of hashing by module, then with the same situation with the fall of one of the five servers (with the same weight) and the redistribution of keys from it between the remaining losses, not 80% of the cache, but only 20%.  If we assume that initially all data is in the cache and all of them are requested, then this difference means that with consistent hashing we will receive four times less database queries. <br><br>  The code that implements this algorithm will be more complicated than the previous code, so I will not give it in the article.  If desired, it can be easily found - on GitHub there are a <a href="https://github.com/search%3Futf8%3D%25E2%259C%2593%26q%3Dconsistent%2Bhashing%26type%3D">lot of implementations</a> in many different languages. <br><br>  Along with consistent hashing, there are other ways to solve this problem (for example, <a href="https://en.wikipedia.org/wiki/Rendezvous_hashing">rendezvous hashing</a> ), but they are much less common. <br><br>  Regardless of the algorithm chosen, <i>choosing a server based on a key hash can work poorly.</i>  Typically, the cache is not a set of the same type of data, but a large number of heterogeneous: cached values ‚Äã‚Äãoccupy different places in the memory, are requested with different frequencies, have different generation times, different refresh rates and different lifetime.  When using hashing, you cannot control where the key will go, and as a result there may be a ‚Äúbias‚Äù both in the amount of stored data and in the number of requests to them, which will cause the behavior of different caching servers to vary greatly. <br><br>  To solve this problem, it is necessary to ‚Äúspread‚Äù the keys so that heterogeneous data is distributed more or less uniformly between servers.  To do this, to select a server, you need to use not a key, but some other parameter, to which you need to apply one of the described approaches.  This is not to say what the parameter will be, since it depends on your data model. <br><br>  In our case, almost all cached data belongs to the same user, so we use the User ID as the sharding parameter of the data in the cache.  Thanks to this, we manage to distribute data more or less evenly.  In addition, we get a bonus - the ability to use <code>multi_get</code> to download several different keys at once with information about the user (which we use in preloading frequently used data for the current user).  If the position of each key was determined dynamically, it would be impossible to use <code>multi_get</code> in such a scenario, since there would be no guarantee that all the requested keys belong to the same server. <br><br>  See also: <br><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">Wikipedia Distributed hash table</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Consistent_hashing">Consistent hashing article on Wikipedia</a> </li><li>  <a href="https://www.toptal.com/big-data/consistent-hashing">A Guide to Consistent Hashing</a> </li><li>  <a href="https://dl.acm.org/citation.cfm%3Fid%3D258660">Distributed hashing trees on the World Wide Web</a> </li><li>  <a href="https://docs.openstack.org/swift/latest/ring_background.html">Building a Consistent Hashing Ring</a> </li></ul><br><h2>  Parallel data update requests </h2><br>  Look at such a simple piece of code: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContactsCountCached</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $user_id)</span></span></span><span class="hljs-function"> : ?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span></span>{ $contacts_count = \Contacts\Cache::getContactsCount($user_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($contacts_count !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $contacts_count; } $contacts_count = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getContactsCount($user_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null($contacts_count)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } \Contacts\Cache::setContactsCount($user_id, $contacts_count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $contacts_count; }</code> </pre><br>  What happens if there is no requested data in the cache?  Judging by the code, the mechanism that will get this data should start.  If the code is executed only in one thread, then everything will be fine: the data will be loaded, placed in the cache and with the next query taken from there.  But when working in several parallel threads, everything will be different: the data will be downloaded not once, but several. <br><br>  It will look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cb/xw/gn/cbxwgnplffbpuseihjnuwdyxv9i.png" width="600"></div><br><br>  At the time of the beginning of the processing of the request in process No. 2, there is no data in the cache yet, but they are already read from the database in process No. 1.  In this example, the problem is not so significant, there are only two requests, but there may be much more. <br><br>  The number of parallel downloads depends on the number of parallel users and the time it takes to download the necessary data. <br><br>  Suppose you have some kind of functionality that uses a cache with a load of 200 requests per second.  If you need 50 ms to load data, then during this time you will receive <code>50 / (1000 / 200) = 10</code> requests. <br><br>  That is, in the absence of a cache, one process will start loading data, and during the load time, nine more requests will arrive that will not see the data in the cache and will also load it. <br><br>  This problem is called <b>cache stampede</b> (I haven‚Äôt found the Russian equivalent of this term, literally, this can be translated as ‚Äústampede cache‚Äù, and the picture in the beginning of the article shows an example of this action in the wild), <b>hit miss storm</b> or the <b>dog-pile effect</b> .  There are several ways to solve it: <br><br><h4>  Blocking before starting the operation of recalculating / loading data </h4><br>  The essence of this method is that, in the absence of data in the cache, a process that wants to load it must capture a lock that will not allow the same processes to be executed by other processes running in parallel.  In the case of memcached, the easiest way to block is to <b>add a</b> key to the same caching server, in which the cached data itself should be stored. <br><br>  With this option, the data is updated only in one process, but you need to decide what to do with processes that are in a situation with a missing cache, but could not get a lock.  They can give an error or some default value, wait for some time, and then try to get the data again. <br><br>  In addition, you need to carefully select the time of the lock itself - it is guaranteed to be enough to load data from the source and put it in the cache.  If not enough, another parallel process may begin reloading the data.  On the other hand, if this time period is too large and the process that received the lock dies without writing data to the cache and not releasing the lock, other processes will also not be able to get this data until the end of the lock time. <br><br><h4>  Take out updates in the background </h4><br>  The main idea of ‚Äã‚Äãthis method is the separation of the data from the cache and writing to it according to different processes.  In online processes, only the data from the cache is read, but not its loading, which is only in a separate background process.  This option makes parallel data updates impossible. <br><br>  This method requires additional ‚Äúcosts‚Äù to create and monitor a separate script that writes data to the cache, and to synchronize the lifetime of the recorded cache and the time of the next run of the updating script. <br><br>  We use this option in Badoo, for example, for a counter of the total number of users, which will be discussed further. <br><br><h4>  Probabilistic update methods </h4><br>  The essence of these methods lies in the fact that the data in the cache is updated not only in the absence, but also with some probability in their presence.  This will allow updating them before the cached data is ‚Äúrotten‚Äù and all processes need to be used at once. <br><br>  For such a mechanism to work correctly, it is necessary that at the beginning of the life of cached data, the probability of recalculation is small, but gradually increased.  This can be <b>achieved</b> using the <b>XFetch</b> algorithm, which uses an exponential distribution.  Its implementation looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xFetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key, $ttl, $beta = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ [$value, $delta, $expiry] = cacheRead($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$value || (time() ‚àí $delta * $beta * log(rand())) &gt; $expiry) { $start = time(); $value = recomputeValue($key); $delta = time() ‚Äì $start; $expiry = time() + $ttl; cacheWrite(key, [$value, $delta, $expiry], $ttl); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value; }</code> </pre><br>  In this example, <code>$ttl</code> is the lifetime of the value in the cache, <code>$delta</code> is the time it took to generate the cached value, <code>$expiry</code> is the time until which the value in the cache is valid, <code>$beta</code> is the algorithm setting parameter, which can be changed on the probability of recalculation (the bigger it is, the more likely the recalculation is with each request).  A detailed description of this algorithm can be found in the white paper "Optimal Probabilistic Cache Stampede Prevention", a link to which you will find at the end of this section. <br><br>  It should be understood that when using such probabilistic mechanisms, you do not exclude parallel updates, but only reduce their likelihood.  To exclude them, you can "cross" several ways at once (for example, by adding a lock before updating). <br><br>  See also: <br><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Cache_stampede">Cache stampede article on Wikipedia</a> </li><li>  <a href="http://cseweb.ucsd.edu/~avattani/papers/cache_stampede.pdf">Optimal Probabilistic Cache Stampede Prevention</a> </li><li>  <a href="https://github.com/internetarchive/xfetch/">GitHub repository with descriptions and tests of different ways</a> </li><li>  <a href="https://habrahabr.ru/company/google/blog/316344/">The article "Caches for" dummies ""</a> </li></ul><br><h2>  "Cold" start and "warming up" cache </h2><br>  It should be noted that the problem of mass data updates due to their absence in the cache can be caused not only by a large number of updates of the same key, but also by a large number of simultaneous updates of different keys.  For example, this can happen when you roll out a new "popular" functionality using caching and a fixed cache lifetime. <br><br>  In this case, immediately after rolling out the data will begin to load (the first manifestation of the problem), after which they will get into the cache - and for some time everything will be fine, and after the expiration of the cache lifetime all the data will start loading again and create an increased load on the database. <br><br>  It is impossible to get rid of such a problem completely, but you can ‚Äúspread out‚Äù data loading over time, thereby eliminating a sharp number of parallel queries to the database.  There are several ways to achieve this: <br><br><ul><li>  <b>smooth inclusion of new functionality.</b>  This requires a mechanism that allows it to be done.  The simplest version of the implementation is to roll out the new functionality included for a small part of users and gradually increase it.  In this scenario, there should not be a large update shaft at once, since at first the functionality will be available only to some users, and as it increases, the cache will already be ‚Äúwarmed up‚Äù. </li><li>  <b>different lifetime of different elements of the data set.</b>  This mechanism can be used only if the system is able to withstand the peak that will occur when rolling out all the functionality.  Its peculiarity lies in the fact that when writing data to the cache, each element will have its own lifetime, and thanks to this, the update shaft will smooth out much faster due to the distribution of subsequent updates in time.  The simplest way to implement such a mechanism is to multiply the cache lifetime by some random factor: </li></ul><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewSnapshotTTL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $random_factor = rand(<span class="hljs-number"><span class="hljs-number">950</span></span>, <span class="hljs-number"><span class="hljs-number">1050</span></span>) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intval(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getSnapshotTTL() * $random_factor); }</code> </pre><br>  If for some reason you do not want to use a random number, you can replace it with a pseudo-random value obtained using a hash function based on some data (for example, User ID). <br><br><h4>  Example </h4><br>  I wrote a small script that <a href="https://github.com/pryazhnikov/cache-simulations/blob/master/run_cold_start.php">emulates a ‚Äúcold‚Äù cache situation.</a> <br>  In it, I reproduce the situation in which the user loads data about himself when requested (if they are not in the cache).  Of course, the example is synthetic, but even on it you can see the difference in the behavior of the system. <br><br>  This is how the graph of the number of hit <i>misses</i> looks in a situation with a fixed <i>(fixed_cache_misses_count)</i> and different <i>(random_cache_misses_count)</i> cache lifetime: <br><br><img src="https://habrastorage.org/webt/vy/yk/nt/vyyknt4dlezh2vbpisf44kpjza0.png"><br><br>  It can be seen that at the beginning of work in both cases the load peaks are very noticeable, but when using a pseudo-random lifetime, they are smoothed out much faster. <br><br><h2>  Hot Keys </h2><br>  The data in the cache is heterogeneous, some of them can be requested very often.  In this case, problems may be created not even by parallel updates, but by the number of readings themselves.  An example of such a key is the total users count: <br><br><img src="https://habrastorage.org/webt/sk/ps/rx/skpsrxip6vywuuyccxnjstwywye.png"><br><br>  This counter is one of the most popular keys, and using the usual approach, all requests to it will go to one server (since this is just one key, and not many of the same type), whose behavior can change and slow down work with other keys stored in the same . <br><br><img src="https://habrastorage.org/webt/ae/qm/4q/aeqm4qq7kmsj64y0vbxitf7yh2i.png"><br><br>  To solve this problem, you need to write data not to one caching server, but to several at once.  In this case, we will multiply reduce the number of readings of this key, but we will complicate its updates and server selection code, since we will need to use a separate mechanism. <br><br>  We at Badoo solve this problem by writing data to all caching servers at once.  Due to this, when reading, we can use a common server selection mechanism - in the code, you can use the usual User ID sharding mechanism, and when reading, you do not need to know anything about the specifics of this ‚Äúhot‚Äù key.  In our case, this works because we have relatively few servers (approximately ten per site). <br><br>  If there were much more caching servers, then this method might not be the most convenient - it simply does not make sense to duplicate the same data hundreds of times.  In this case, it would be possible to duplicate the key not for all servers, but only for their part, but this option requires a little more effort. <br><br>  If you use the server definition by the cache key, you can add a limited number of pseudo-random values ‚Äã‚Äãto it (by making <code>total_users_count</code> from <code>total_users_count</code> t <code>otal_users_count_1</code> , <code>total_users_count_2</code> , etc.).  A similar approach is used, for example, in Etsy. <br><br>  If you use explicit sharding parameter specifications, simply pass in different pseudo-random values. <br><br>  The main problem with both methods is to make sure that different values ‚Äã‚Äãreally fall on different caching servers. <br><br>  See also: <br><br><ul><li>  <a href="https://codeascraft.com/2017/11/30/how-etsy-caches/">How Etsy caches: hashing, Ketama, and cache smearing</a> </li></ul><br><h2>  Malfunctions </h2><br>  The system can not be 100% reliable, so you need to consider how it will behave in case of failures.  Failures can be in the work of the cache itself, and in the database. <br><br>  I have already talked about <b>cache failures</b> in previous sections.  The only thing that can be added is it would be good to provide for the possibility of disabling part of the functionality on a running system.  This is useful when the system is unable to cope with the peak load. <br><br>  If <b>the database fails</b> and there is no cache, we can get into a cache stampede situation, about which I also told earlier.  You can get out of it in the ways already described, or you can write to the cache a deliberately incorrect value with a short lifespan.  In this case, the system will be able to determine that the source is unavailable, and for some time will stop trying to request data. <br><br><h2>  Conclusion </h2><br>  In the article I touched upon the main problems when working with the cache, but I am sure that, besides them, there are many others, and this conversation can be continued for a very long time.  I hope that after reading my article, your cache will become more efficient. </div><p>Source: <a href="https://habr.com/ru/post/352186/">https://habr.com/ru/post/352186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352176/index.html">When the actor framework turns into a ‚Äúblack box‚Äù and what can we do about it?</a></li>
<li><a href="../352178/index.html">All according to GOST. Information security when using virtualization technologies</a></li>
<li><a href="../352180/index.html">Patch from Meltdown led to a more critical vulnerability Windows 7x64 / 2008R2</a></li>
<li><a href="../352182/index.html">Validation of email addresses to protect against spam bots on the site</a></li>
<li><a href="../352184/index.html">From the installation of AWX to the launch of the first playbook - setting up centralized control Ansible</a></li>
<li><a href="../352188/index.html">Camel in questions and answers</a></li>
<li><a href="../352190/index.html">Divide and conquer: demarcation of access to the records of conversations</a></li>
<li><a href="../352192/index.html">How to become a GPU engineer in an hour</a></li>
<li><a href="../352194/index.html">How to grow from a junior tester into a good tester? Continuation</a></li>
<li><a href="../352196/index.html">Comparison of ITSM-systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>