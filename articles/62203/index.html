<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedure for resolving methods in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This note discusses the MRO C3 algorithm and some specific problems of multiple inheritance. Although the algorithm and problems are not limited to th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedure for resolving methods in Python</h1><div class="post__text post__text-html js-mediator-article">  This note discusses the MRO C3 algorithm and some specific problems of multiple inheritance.  Although the algorithm and problems are not limited to the framework of a single language, I focused my attention on Python.  At the end is a list of useful links on this topic. <br><a name="habracut"></a><br><br>  The method resolution order allows Python to figure out from which ancestor class the method should be called if it is not found directly in the descendant class.  If each descendant has only one ancestor, then the task is trivial.  There is an upward search across the entire hierarchy.  If multiple inheritance is used, you may encounter specific problems, which are described below. <br><br>  In the old versions of Python, the order of resolution of the methods was quite primitive: the search was carried out in all parent classes from left to right to the maximum depth.  Those.  if the parent class in turn did not have the necessary method, but there were parents, then the search was performed in them according to the same rules.  For example, let's take the structure: <br><pre> AC
 |  |
 Bd
  \ /
    E
</pre><br>  When referring to an instance method of a class E, such an algorithm would search sequentially in classes E, B, A, D and C. Thus, the search was conducted first in the first parent class and in all its ancestors, then in the second parent class with all the ancestors etc. This method did not cause any special complaints, until the classes had a common ancestor.  However, starting with version 2.2, the base class object has appeared, from which it was recommended to inherit all user classes.  Why it was introduced - a topic for a separate article.  Perhaps the most significant factor is the separation of the object model and the meta-data model.  Starting with version 3.0, the old classes are no longer supported, and all user-defined classes are derived from the object class by default. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This gave rise to the ‚Äúdiamond diagram‚Äù problem. <br><pre>    object
    / \
   AB
    \ /
      C
</pre><br>  If we have classes A and B, from which class C is inherited, then when searching for a method using the old algorithm (C, A, object, B), it turns out that if a method is not defined in classes C and A, it will be extracted from the object, even if it is defined in B. This creates certain inconveniences, since  object has many magic methods defined, such as __init__, __str__, etc.  But even if object is replaced with a certain user-defined class D, then the problem will remain - the less specific method of the ancestor class can work instead of the more specific method of the descendant class. <br><br>  So, we have the class itself, a list of all its ancestors and the connections between them.  From this data, we need to build an ordered list of classes in which the search method will be performed from left to right.  Such a list is called class linearization.  For simplicity, take the structure: <br><pre> object
    | 
    A
    |
    B
</pre><br>  Then the linearization for class B will be the list [B, A, object].  Those.  When calling B (). The something () method will first be searched in class B. If it is not found there, the search will continue in class A. If it is not there, the search will end in the object class.  After going through all the classes from the linearization and not finding the desired method, Python will throw out the Attribute Error error. <br><br>  To solve the diamond-shaped structure, linearization should be monotonous.  This means that if in the linearization of a certain class C, class A follows class B (it has the form [C, ..., B, ..., A]), then for any of its descendant D, class B will follow A in its linearization ( it will be [D, ..., C, ..., B, ..., A]).  As you can see, the old order of resolution of methods is not monotonous, since  in the case of a diamond-shaped structure for class A, linearization is [A, object], for class B - [B, object], but for class C - [C, A, object, B], which violates the monotony property with respect to class B. <br><br>  To satisfy the property of monotonicity, in this case, two linearizations are appropriate: [C, A, B, object] and [C, B, A, object].  Obviously, both of them do not violate monotony either with respect to class A (since object follows A in both cases) or with respect to class B (since object follows B in both cases).  So which one to choose?  In this case, the most intuitive way is to look at the definition of class C. If a class is declared as C (A, B), then it is reasonable to take the first linearization, since B follows A. In this case, if the class is declared as C (B, A ), it will be better to take the second linearization, in which A follows B. <br><br>  Such a choice is determined by the local precedence order (local precedence ordering).  The property of the order of local seniority requires respect for the parent classes in the linearization of the descendant class of the same order as when it was declared.  For example, if a class is declared as D (A, B, C), then in linearization D, class A should stand before B, and class B should stand for C. <br><br>  Let's sum up the intermediate results: <br><ul><li>  A class is a linearization of a list from the class itself and all its ancestors (parents and parents) in which, in order from left to right, the method will be searched. </li><li>  Method Resolution Order (MRO) is the way a class is linearized. </li><li>  monotony is a property that requires that the descendant class of the parent classes be followed in linearization of the same class as in the parent class. </li><li>  the order of local precedence is a property that requires that the descendant class follow the same order of parent classes in linearization as in its declaration. </li></ul>  We want our linearization to observe both monotony and the order of local seniority. <br><br><br><h4>  The algorithm for ordering the resolution of methods C3. </h4><br>  To achieve the above goals in Python, the C3 algorithm is used.  It is quite simple, however, for a better understanding, we introduce the following conventions: <br>  [C1, C2, ... CN] - a list of the elements C1, C2, ... CN.  Accordingly, [] is a list of one element C. <br>  L [C] - linearization of class C. It is important to remember that any linearization is a list by definition. <br>  merge (L [C1], L [C2], ..., L [CN]) - combining the elements of linearization L [C1], L [C2], ..., L [CN] into the list using some algorithm.  In fact, this algorithm should order all classes from L [C1], L [C2], ..., L [CN] and eliminate duplication of classes in the final list. <br><br>  Algorithm C3 is a set of the following rules: <br><ul><li>  Linearization of class C is a singleton list of the class C itself, plus the union of the linearizations of its parents and the list of all its parents.  In the legend, this can be written as L [C] = [C] + merge (L [C1], L [C2], ..., L [CN], [C1, C2, ..., CN]) if the class C was declared class C (C1, C2, ..., CN).  It should be noted that each linearization of L [CX] begins with the class CX, which was additionally assigned to the end of the merge list as an immediate parent of class C. Why this is done will become clear further. </li><li>  Combining linearization is as follows: <br><ol><li>  Take the zero element from the first linearization (L [C1] [0]). </li><li>  This element is sought in all other linearizations (from L [C2] to L [CN]). </li><li>  If this element is found somewhere outside the beginning of the list (L [CK] [X] == L [C1] [0], X! = 0; in essence, this means that L [C1] [0] is someone else ancestor), the algorithm proceeds to the first step, taking as the zero element from the following linearization (L [C2] [0]). </li><li>  If an element is not found anywhere in a position other than zero, then it is added to the end of the final linearization list and removed from all lists under consideration (from L [C1] to L [CN]; the same class cannot be found in the final list twice) .  If after deleting an item there are empty lists, they are excluded from the union.  After this, the algorithm is repeated from the very beginning (from the new element L [C1] [0]), if it exists.  If it is not - the union is over. </li><li>  If the algorithm has reached the last element of L [CN], but none of the zero elements satisfies the rules, then linearization is not possible. </li></ol><br></li></ul>  To make the algorithm clearer, let‚Äôs analyze a few examples.  First of all, let's see what happens with our diamond shape now.  For her, we get: <br>  L [C] = [C] + merge (L [A], L [B], [A, B]) <br>  L [A] = [A] + merge (L [object], [object]) <br>  L [B] = [B] + merge (L [object], [object]) <br>  L [object] = [object] (degenerate case) <br><br>  Of greatest interest is the process of unification, so we analyze it in more detail.  In cases of L [A] and L [B], the expression merge (L [object], [object]) = merge ([object], [object]) is expanded trivially.  Since both the first and second lists consist of one object element, according to item 4 of the merge rule, the result will be [object]. <br><br>  Now let's look at L [C] = [C] + merge (L [A], L [B], [A, B]) = [C] + merge ([A, object], [B, object], [A , B]).  We will write down our union according to the rules C3: <br><ul><li>  Take the zero element of the first list - A. </li><li>  Let's look for it in all the other lists, i.e.  in [B, object] and [A, B]. </li><li>  Since class A is not found in the list [B, object], and in the list [A, B] is the zero element, we add it to the final linearization list L = [] + [A] = [A].  After this, class A needs to be removed from all lists in the union.  We get L [C] = [C] + [A] + merge ([object], [B, object], [B]). </li><li>  Again, take the zero element of the first list, object. </li><li>  Let's look for it in all other lists and find out that object is the first (not zero) element of the list [B, object].  As mentioned above, in essence, this means that the class object is an ancestor of class B. So, first, it makes sense to look for a more specific method in class B. Therefore, the algorithm justly returns to item 1. </li><li>  Again, take the zero element, but this time from the second list, i.e.  B from the list [B, object]. </li><li>  Let's look for it in other lists and find it only in the third list [B] in the zero position, which suits us perfectly.  Therefore, we add it to the final list, and then remove it from all the lists in the union.  We get L = [A] + [B] = [A, B] and accordingly L [C] = [C] + [A, B] + merge ([object], [object]). </li><li> The resulting merge ([object], [object]) union has already been considered above.  As a result, we obtain L [C] = [C] + [A, B] + [object] = [C] + [A, B, object] = [C, A, B, object].  The list [A, B, object] is the result of our merge (L [A], L [B], [A, B]) union. </li></ul>  I hope that the algorithm has become clearer.  However, it is not yet clear why, according to the rules, it is necessary to add a list of all parents to the end of the union.  Particularly perspicacious could already notice that if we changed the linearization of L [A] and L [B] in the union, i.e.  would write merge (L [B], L [A], [A, B]), then the list of parents specified in the same order as when initializing the class descendant class C (A, B) would not allow class B be searched before A. And that's true.  The list of parents is necessary in order not to allow violating the rule of local seniority.  But let's look at an example class C (D, E): <br><pre> object
   |
   D
   |  \
   |  E
   |  /
   C
</pre><br>  We write the linearization of L [C]: <br>  L [C] = [C] + merge (L [D], L [E], [D, E]) <br>  L [E] = [E] + merge (L [D], [D]) <br>  L [D] = [D] + merge (L [object], [object]) = [D, object] <br><br>  Perform substitution and get: <br>  L [E] = [E] + merge ([D, object], [D]) = [E, D, object] <br>  L [C] = [C] + merge ([D, object], [E, D, object], [D, E]) <br><br>  Now look what we got.  The merge ([D, object], [E, D, object], [D, E]) merge cannot be completed, because in the [D, object] and [D, E] lists the zero element is D, which is the first list item [E, D, object].  Conversely, E, which is the zero element of [E, D, object], is also the first element of [D, E].  Thus, after 3 iterations, the algorithm will arrive at point 5, after which Python throws out a TypeError error: local precedence: L [C] = [C] + merge ([D, object], [E, D, object]) = [C] + [E] + merge ([D, object], [D, object] ) = [C] + [E, D] + [object] = [C, E, D, object].  With such a linearization of the class C, the search would be conducted first in the class E, and then in the class D, although the declaration recorded C (D, E). <br><br>  Solving this problem is not difficult.  It is enough to rewrite the ad on class C (E, D).  In this case, we get: <br>  L [C] = [C] + merge ([E, D, object], [D, object], [E, D]) = [C] + [E] + merge ([D, object], [D] , object], [D]) = [C] + [E, D, object] = [C, E, D, object]. <br>  In fact, nothing has changed, except that in the declaration of a class, the order of enumeration of parents turned out to be the same as in the linearization of the class, i.e.  the order of local seniority is respected.  It should be noted that although Python hints at the order in which it would be more logical to indicate parents, it will not prevent you from seeking adventure if you declare your own MRO through the metaclass.  But more about that near the end. <br><br>  Python calculates linearization once during class creation.  If you want to get it for self-checking or for some other purpose, use the class property __mro__ (for example, C .__ mro__).  In order to consolidate the material we will analyze examples of pozakovyrister.  The object class is intentionally thrown away so as not to clutter the linearization.  As is known from the above, with single inheritance, the classes are simply lined up from the descendant to the ancestors, so the object will always be at the end of any chain.  And further.  I am not a cook or a musician, so examples are just examples.  It is not necessary to focus on semantic inaccuracies in them. <br><br><pre>        Music
       / \
    Rock Gothic ------
    / \ / \
 Metal Gothic Rock \
   |  |  \
    \ ------------------ Gothic Metal
                 |  /
                 The 69 eyes
</pre><br> <code><font color="#00A202">class</font> <font color="#0ABB9A">Music</font> (object): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Rock</font> (Music): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Gothic</font> (Music): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Metal</font> (Rock): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">GothicRock</font> (Rock, Gothic): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">GothicMetal</font> (Metal, Gothic): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">The69Eyes</font> (GothicRock, GothicMetal): <font color="#00A202">pass</font> <br></code> <br>  L [The69Eyes] = [The69Eyes] + merge (L [GothicRock], L [GothicMetal], [GothicRock, GothicMetal]) <br>  L [GothicRock] = [GothicRock] + merge (L [Rock], L [Gothic], [Rock, Gothic]) <br>  L [GothicMetal] = [GothicMetal] + merge (L [Metal], L [Gothic], [Metal, Gothic]) <br>  L [Rock] = [Rock, Music] <br>  L [Gothic] = [Gothic, Music] <br>  L [Metal] = [Metal] + [Rock, Music] = [Metal, Rock, Music] <br><br>  After substitutions we get: <br>  L [GothicRock] = [GothicRock] + merge ([Rock, Music], [Gothic, Music], [Rock, Gothic]) = [GothicRock, Rock, Gothic, Music] <br>  L [GothicMetal] = [GothicMetal] + merge ([Metal, Rock, Music], [Gothic, Music], [Metal, Gothic]) = [GothicMetal] + [Metal, Rock, Gothic, Music] = [GothicMetal, Metal , Rock, Gothic, Music] <br>  L [The69Eyes] = [The69Eyes] + merge ([GothicRock, Rock, Gothic, Music], [GothicMetal, Metal, Rock, Gothic, Music], [GothicRock, GothicMetal]) <br>  = [The69Eyes] + [GothicRock, GothicMetal] + merge ([Rock, Gothic, Music], [Metal, Rock, Gothic, Music]) <br>  = [The69Eyes] + [GothicRock, GothicMetal, Metal] + merge ([Rock, Gothic, Music], [Rock, Gothic, Music]) <br>  = [The69Eyes, GothicRock, GothicMetal, Metal, Rock, Gothic, Music] <br><br><pre>       Food -------
      / \ \
     Meat Milk Flour
     |  \ \ /  
 Rabbit Pork Pasty
       \ |  /
          Pie
</pre><br> <code><font color="#00A202">class</font> <font color="#0ABB9A">Food</font> (object): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Meat</font> (Food): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Milk</font> (Food): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Flour</font> (Food): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Rabbit</font> (Meat): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pork</font> (Meat): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pasty</font> (Milk, Flour): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pie</font> (Rabbit, Pork, Pasty): <font color="#00A202">pass</font> <br></code> <br>  L [Pie] = [Pie] + merge (L [Rabbit], L [Pork], L [Pasty], [Rabbit, Pork, Pasty]) <br>  L [Rabbit] = [Rabbit] + merge (L [Meat], [Meat]) <br>  L [Pork] = [Pork] + merge (L [Meat], [Meat]) <br>  L [Pasty] = [Pasty] + merge (L [Milk], L [Flour], [Milk, Flour]) <br>  L [Meat] = [Meat] + merge (L [Food], [Food]) = [Meat, Food] <br>  L [Milk] = [Milk] + merge (L [Food], [Food]) = [Milk, Food] <br>  L [Flour] = [Flour] + merge (L [Food], [Food]) = [Flour, Food] <br><br>  After substitutions we get: <br>  L [Rabbit] = [Rabbit, Meat, Food] <br>  L [Pork] = [Pork, Meat, Food] <br>  L [Pasty] = [Pasty] + merge ([Milk, Food], [Flour, Food], [Milk, Flour]) = [Pasty] + [Milk, Flour, Food] = [Pasty, Milk, Flour, Food ] <br>  L [Pie] = [Pie] + merge ([Rabbit, Meat, Food], [Pork, Meat, Food], [Pasty, Milk, Flour, Food], [Rabbit, Pork, Pasty]) <br>  = [Pie] + [Rabbit] + merge ([Meat, Food], [Pork, Meat, Food], [Pasty, Milk, Flour, Food], [Pork, Pasty]) <br>  = [Pie] + [Rabbit, Pork] + merge ([Meat, Food], [Meat, Food], [Pasty, Milk, Flour, Food], [Pasty]) <br>  = [Pie] + [Rabbit, Pork, Meat] + merge ([Food], [Food], [Pasty, Milk, Flour, Food], [Pasty]) <br>  = [Pie] + [Rabbit, Pork, Meat, Pasty] + merge ([Food], [Food], [Milk, Flour, Food]) <br>  = [Pie] + [Rabbit, Pork, Meat, Pasty, Milk, Flour, Food] <br>  = [Pie, Rabbit, Pork, Meat, Pasty, Milk, Flour, Food] <br><br><br><h4>  How to turn to ancestors. </h4><br>  Multiple inheritance causes another specific problem.  In fact, a direct search for a method in the parent classes is only a fraction of the benefits that can be derived from it.  As in the case of single inheritance, you can often make your life easier by implementing a method in the descendant that, in addition to some actions, will call the same method of the parent.  For example, quite often you can find this: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">B</font> (A): <br> <font color="#00A202">def</font> <font color="#062871">__init__</font> (self): <br> <font color="#60A0AF"># something</font> <br> A. <font color="#062871">__init__</font> (self) <br></code> <br>  However, for the case of multiple inheritance, this approach is not suitable.  And for some reason: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">C</font> (B, A): <br> <font color="#00A202">def</font> <font color="#062871">__init__</font> (self): <br> <font color="#60A0AF"># something</font> <br> B. <font color="#062871">__init__</font> (self) <br> A. <font color="#062871">__init__</font> (self) <br></code> <br>  First, we explicitly refer to the parent classes (in fact, in the example with a single inheritance, the same thing).  If we want to replace someone from the ancestors with another class or remove them altogether, then we will have to change all the functions that were applied to it.  This is fraught with bugs if we miss something.  But this is still half the trouble.  Secondly, we know nothing about classes A and B. Perhaps they have common ancestors, to whom they refer in a similar way: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">A</font> (P1, P2): <br> <font color="#00A202">def</font> <font color="#062871">__init__</font> (self): <br> <font color="#60A0AF"># something</font> <br> P1. <font color="#062871">__init__</font> (self) <br> P2. <font color="#062871">__init__</font> (self) <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">B</font> (P1, P2): <br> <font color="#00A202">def</font> <font color="#062871">__init__</font> (self): <br> <font color="#60A0AF"># something</font> <br> P1. <font color="#062871">__init__</font> (self) <br> P2. <font color="#062871">__init__</font> (self) <br></code> <br>  If this is so, then it turns out that the initialization of the common ancestors will work two times.  It is not right.  To avoid this in Python there is a class super.  In version 3.0, he is finally humanized and can be addressed as follows: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">C</font> (B, A): <br> <font color="#00A202">def</font> <font color="#062871">__init__</font> (self): <br> <font color="#60A0AF"># something</font> <br> <font color="#062871">super</font> (). <font color="#062871">__init__</font> () <font color="#60A0AF">#    3.0   super(C, self)</font> <br></code> <br>  Please note that in versions 2.x, the first argument is to specify the class itself, and not any of its parents.  In fact, an object of class super remembers the arguments passed to it at the time of initialization and when calling any method (super () .__ init __ (self) in the example above) goes through the linearization list of the second argument class (self .__ class __.__ mro__), trying to call this method take turns for all classes following the class in the first argument (class C), passing the first argument (self) as a parameter.  Those.  for our case: <br>  self .__ class __.__ mro__ = [C, B, A, P1, P2, ...] <br>  super (C, self) .__ init __ () =&gt; B .__ init __ (self) <br>  super (B, self) .__ init __ () =&gt; A .__ init __ (self) <br>  super (A, self) .__ init __ () =&gt; P1 .__ init __ (self) <br>  As you can see, from method B .__ init__, when using super, method A .__ init__ will be called, although class A is in no way associated with it and is not its ancestor.  In this case, if necessary, the methods of all ancestors will be tested once in a chain. <br><br>  Thanks to this approach, you can, for example, introduce the allergen method for all components for the considered example of a pie, which will successively go through the chain of ancestors to make a list of all the allergen components to warn customers.  It will be convenient instead of rewriting the ‚Äúnot recommended‚Äù list for each product each time simply to inherit it from the components.  Then the list will be generated automatically.  Similarly, it will be possible to offer the user a choice of drinks for each product, or to twist the user's weight preferences on a handwritten Internet radio station, going from a specific group to genres with a certain attenuation coefficient. <br><br>  An example of a pie might look like this (for version 2.x): <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">Food</font> (object): <br> <font color="#00A202">def</font> drink(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Water'</font> , <font color="#4075A0">'Cola'</font> ] <br> <font color="#00A202">def</font> allergen(self): <br> <font color="#00A202">return</font> [] <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Meat</font> (Food): <br> <font color="#00A202">def</font> drink(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Red wine'</font> ] + <font color="#062871">super</font> (Meat, self).drink() <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Milk</font> (Food): <br> <font color="#00A202">def</font> allergen(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Milk-protein'</font> ] + <font color="#062871">super</font> (Milk, self).allergen() <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Flour</font> (Food): <font color="#00A202">pass</font> <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Rabbit</font> (Meat): <br> <font color="#00A202">def</font> drink(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Novello wine'</font> ] + <font color="#062871">super</font> (Rabbit, self).drink() <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pork</font> (Meat): <br> <font color="#00A202">def</font> drink(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Sovinion wine'</font> ] + <font color="#062871">super</font> (Pork, self).drink() <br> <font color="#00A202">def</font> allergen(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Pork-protein'</font> ] + <font color="#062871">super</font> (Pork, self).allergen() <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pasty</font> (Milk, Flour): <font color="#00A202">pass</font> <br> <br> <font color="#00A202">class</font> <font color="#0ABB9A">Pie</font> (Rabbit, Pork, Pasty): <br> <font color="#00A202">def</font> drink(self): <br> <font color="#00A202">return</font> [ <font color="#4075A0">'Mineral water'</font> ] + <font color="#062871">super</font> (Pie, self).drink() <br> <br> <font color="#00A202">if</font> <font color="#062871">__name__</font> == <font color="#4075A0">"__main__"</font> : <br> pie = Pie() <br> <br> <font color="#00A202">print</font> <font color="#4075A0">'List of allergens: '</font> <br> <font color="#00A202">for</font> allergen <font color="#00A202">in</font> pie.allergen(): <font color="#00A202">print</font> <font color="#4075A0">' - '</font> + allergen <br> <br> <font color="#00A202">print</font> <font color="#4075A0">'List of recommended drinks: '</font> <br> <font color="#00A202">for</font> drink <font color="#00A202">in</font> pie.drink(): <font color="#00A202">print</font> <font color="#4075A0">' - '</font> + drink <br></code> <br>  As a result, we will see the following: <br>  List of allergens: <br>  - Pork-protein <br>  - Milk-protein <br>  List of recommended drinks: <br>  - Mineral water <br>  - Novello wine <br>  - Sovinion wine <br>  - Red wine <br>  - Water <br>  - Cola <br><br>  Based on this list, you can understand how to manage the list of linearization.  As you can see, none of the parental methods were called twice, otherwise the list of allergens or recommendations would show repetitions.  Also note that in the most senior class Food both methods are defined - allergen and drink.  The call to super () does not perform any checks, so if we try to access a nonexistent method, we get an error like AttributeError: 'super' object has no attribute 'allergen'. <br><br><br><h4>  When linearization can not be drawn. </h4><br>  We have already analyzed the case when it was impossible to compose a linearization using the C3 algorithm.  However, then the problem was solved by changing the places of the ancestor classes in the declaration of the descendant class.  There are other cases in which the compilation of linearization is not possible: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">C</font> (A, B): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">D</font> (B, A): <font color="#00A202">pass</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">E</font> (C, D): <font color="#00A202">pass</font> <br></code> <br>  L [E] = [E] + merge (L [C], L [D], [C, D]) = [E] + merge ([C, A, B], [D, B, A], [C, D]) <br>  = [E] + [C, D] + merge ([A, B], [B, A]) <br><br>  As you see, the conflict turned out to be insoluble, since in declaration C the class A stands before B, and in declaration D it is the other way around.  Well, from this place you have to go and revise the structure.  But if you really need to quickly podhachit or you just know what you are doing, Python will not limit you.  You can define your own linearization through metaclasses.  To do this, it is enough to specify the method mro (cls) in the metaclass - in fact, override the method of the basic metaclass type - which returns the linearization you need. <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">MetaMRO</font> ( <font color="#062871">type</font> ): <br> <font color="#00A202">def</font> mro(cls): <br> <font color="#00A202">return</font> (cls, A, B, C, D object) <br></code> <br>  Further class declaration differs for version 3.0 and 2.x: <br> <code><font color="#00A202">class</font> <font color="#0ABB9A">E</font> (C, D): __metaclass__ = MetaMRO <font color="#60A0AF"># 2.x</font> <br> <font color="#00A202">class</font> <font color="#0ABB9A">E</font> (C, D, metaclass = MetaMRO): <font color="#00A202">pass</font> <font color="#60A0AF"># 3.0</font> <br></code> <br>  After that, E .__ mro__ = [E, A, B, C, D, object].  Notice that if you take responsibility for the MRO Python does not conduct any additional checks and you can safely search in ancestors earlier than in descendants.  And although this is not a desirable practice, it is possible. <br><br>  Useful links: <br>  <a href="http://www.python.org/download/releases/2.2.3/descrintro/">Unifying types and classes in Python 2.2</a> - about the separation of the object model and the meta-data model.  It also discusses the MRO, the problems of multiple inheritance and super (). <br>  <a href="http://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order</a> is a C3 algorithm with examples.  In the end, there is an implementation of mro and merge functions on pure Python for those who perceive code better than text. <br>  <a href="http://192.220.96.201/dylan/linearization-oopsla96.html">A Monotonic Superclass Linearization for Dylan</a> - a comparison of some types of linearization. <br><br><br><h4>  Afterword. </h4><br>  Of course, it is impossible to cover all related topics, and perhaps someone has more questions than answers.  For example, what are metaclasses, base classes type and object, and the like.  If there is interest, then, over time, I could try to make out such topics: <br><ul><li>  introspection in python: interactive help, dir, sys, etc. </li><li>  type and object: most likely as a free and abbreviated translation of <a href="http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html">this one</a> </li><li>  Python magic: __str__, __init__, __new__, __slots__, etc.  In fact, there is quite a lot of it, so there may be several parts. </li><li>  metaclasses </li></ul><br><br>  PS: Thanks to all those who helped me post this topic and personally <a href="https://habrahabr.ru/users/goodrone/" class="user_link">Goodrone</a> . </div><p>Source: <a href="https://habr.com/ru/post/62203/">https://habr.com/ru/post/62203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../62194/index.html">The exact time 0100 hours 010111 minutes</a></li>
<li><a href="../62196/index.html">GoogleApps + Postfix + Fetchmail (OpenLdap + Postfix)</a></li>
<li><a href="../62198/index.html">New simulator of life sysadmin from Intel</a></li>
<li><a href="../62200/index.html">Give Internet, Yota-Magister</a></li>
<li><a href="../62202/index.html">Questions about .NET ‚Ññ2</a></li>
<li><a href="../62204/index.html">Fan table under the laptop</a></li>
<li><a href="../62206/index.html">Netbook Review / UMPC Kohjinsha SC3</a></li>
<li><a href="../62208/index.html">Opera Unite for web developers</a></li>
<li><a href="../62212/index.html">New tourist service Turometr.ru</a></li>
<li><a href="../62214/index.html">Ubiquity + habrahabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>