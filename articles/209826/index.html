<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of the shingle algorithm on Node.JS. Finding Fuzzy Duplicates for English Texts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When working with information often arise problems of parsing web pages. One of the problems in this case is the definition of similar pages. A good e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of the shingle algorithm on Node.JS. Finding Fuzzy Duplicates for English Texts</h1><div class="post__text post__text-html js-mediator-article">  When working with information often arise problems of parsing web pages.  One of the problems in this case is the definition of similar pages.  A good example of such an algorithm is the <a href="http://habrahabr.ru/post/65944/">‚ÄúShingle algorithm for web documents‚Äù</a> . <br><br>  A part of the parsing project was implemented on Node.JS, therefore, the algorithm needed to be implemented on it.  I did not find any implementations in javascript or npm-packages - I had to write my own. <br><a name="habracut"></a><br>  All work on the code is based on the article above, so all the points of the algorithm will be from it, but with some amendments. <br><br>  To determine the similarity of 2 documents, you must: <br><ol><li>  text canonization; </li><li>  splitting into shingles; </li><li>  calculating a shingle hash using 84x static functions; </li><li>  random sampling of 84 checksum values; </li><li>  comparison, determination of the result. </li></ol><br>  Points 3,4 for me were quite problematic.  1st - you need to find 84 static functions for hashing, and 2nd - a random sample of 84 x values ‚Äã‚Äãof checksums.  If for the 1st problem - solutions can be found, then the second is not clear to me.  If we have an array of text shingles with 84 functions, then it turns out that the output will be a 2-dimensional array of dimension 84xN (the number of shings in the document).  Now you need to bypass this 84-element array for each text and compare random shingles hashes.  You can compare random elements, but this option may not give matches.  If we take the minimum hashes in length, then for md5 all hashes are equal in length, and the length according to the character codes is an additional load.  Therefore, I decided to replace points 3 and 4 with a simple hashing of shingles using crc32 and a sequential comparison. <br>  The final algorithm: <br><ol><li>  text canonization; </li><li>  splitting into shingles; </li><li>  calculating a shingle hash using crc32; </li><li>  sequential comparison, determination of the result. </li></ol><br><h5>  1. Canonization of the text </h5><br>  In my case, canonization consists of: <br><ol><li>  cleaning up html entities; </li><li>  cleaning of excess spaces on the sides (trim); </li><li>  clearing such special characters '‚Äù', '"', "\ n", '\ r', ',', '.', ':', '$', '#', '"', '(' , ')'; </li><li>  clearing unnecessary parts of speech in a sentence </li></ol><br>  First you need to prepare methods for processing text. <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strWordRemove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">entry</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'(^|\\s)'</span></span> + entry + <span class="hljs-string"><span class="hljs-string">'(?=\\s|$)'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>); text = text.replace(regex, <span class="hljs-string"><span class="hljs-string">''</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strCharacterRemove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">entry</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> escapeRegExp = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g</span></span>, <span class="hljs-string"><span class="hljs-string">"\\$&amp;"</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(escapeRegExp(entry), <span class="hljs-string"><span class="hljs-string">'g'</span></span>); text = text.replace(regex, <span class="hljs-string"><span class="hljs-string">''</span></span>); };</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first is needed to replace the words in the text, and the second to replace the specials.  characters.  Next comes the processing itself: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> withoutTagsRegex = <span class="hljs-regexp"><span class="hljs-regexp">/(&lt;([^&gt;]+)&gt;)/ig</span></span>; text = text.replace(withoutTagsRegex, <span class="hljs-string"><span class="hljs-string">""</span></span>); text = text.trim(); [<span class="hljs-string"><span class="hljs-string">'‚Äù'</span></span>, <span class="hljs-string"><span class="hljs-string">'‚Äú'</span></span>, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">'\r'</span></span>].forEach(strCharacterRemove);</code> </pre><br><br>  For Node.JS there is an npm-package ‚Äúpos‚Äù, which allows you to find parts of speech in the text.  It works pretty well. <br><div class="spoiler">  <b class="spoiler_title">Handling parts of speech using pos</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> words = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pos.Lexer().lex(text); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taggedWords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pos.Tagger().tag(words); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> removeWords = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nounWords = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taggedWords) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taggedWord = taggedWords[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> word = taggedWord[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tag = taggedWord[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//Adjective /* JJ Adjective big JJR Adj., comparative bigger JJS Adj., superlative biggest CC Coord Conjuncn and,but,or IN Preposition of,in,by TO √íto√ì to UH Interjection oh, oops DT Determiner the,some */ //console.log(word + " /" + tag); if(tag === 'NNS') { nounWords.push(word); } if(['JJ', 'JJR', 'JJS', 'CC', 'IN', 'TO', 'UH', 'DT'].indexOf(tag) !== -1) { removeWords.push(word); } } removeWords.forEach(strWordRemove);</span></span></code> </pre><br></div></div><br>  All other specials.  I decided to remove the characters after processing parts of speech. <br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">':'</span></span>, <span class="hljs-string"><span class="hljs-string">'$'</span></span>, <span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">'('</span></span>, <span class="hljs-string"><span class="hljs-string">')'</span></span>].forEach(strCharacterRemove);</code> </pre><br>  Then it remains to bring all the nouns to a single form and the canonization unit can be considered ready.  It is worth noting that pos brings to plural nouns such words as Command's.  I decided to skip them. <br><div class="spoiler">  <b class="spoiler_title">Nouns to a single species</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// replace all plural nouns to single ones nounWords.forEach(function(entry) { //parent's || Apple's || Smurf's if(entry.length &gt; 2 &amp;&amp; entry.slice(-2) === "'s") { // now skip it. in future we can test to remove it return ; } var newOne = ''; if(entry.length &gt; 3 &amp;&amp; entry.slice(-3) === "ies") { newOne = entry.slice(0, -3) + 'y'; } else if(entry.length &gt; 2 &amp;&amp; entry.slice(-1) === "s") { newOne = entry.slice(0,-1); } else { return ; } var rexp = new RegExp('(^|\\s)' + entry + '(?=\\s|$)','g') text = text.replace(rexp, "$1" + newOne ); });</span></span></code> </pre><br></div></div><br>  Remove all multiple spaces and pass the text to the next level. <br><pre> <code class="javascript hljs">text = text.replace(<span class="hljs-regexp"><span class="hljs-regexp">/ +(?= )/g</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>); callback(text);</code> </pre><br><h5>  2. Sharding </h5><br>  With this item, everything is simple.  We divide the text by spaces and create arrays. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makeShingles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> words = text.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shingles = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wordsLength = words.length; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(shingles.length !== (wordsLength - shingleLength + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { shingles.push(words.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, shingleLength).join(<span class="hljs-string"><span class="hljs-string">' '</span></span>)); words = words.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>); } callback(shingles) };</code> </pre><br><h5>  3. Calculation of shingles hashes using crc32 </h5><br>  At this point, we go around the array of shingles and hash the strings.  The first cycle from 0 to 1 is left from the attempt to hash with the help of 84 functions.  I decided not to clean it (I suddenly come back to this idea). <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashingShingles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shingles, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashes = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashedArr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, k = shingles.length; j &lt; k; j++) { hashedArr.push(crc.crc32(shingles[j])); } hashes.push(hashedArr); } callback(hashes); };</code> </pre><br><h5>  4. Sequential comparison, determination of the result </h5><br>  For example, I took 2 news from google news which he showed as similar.  I saved them in the json file and further, for higher speed, processed in parallel using Async utilities.  Then I found the number of matching shingles and calculated the result. <br><br><div class="spoiler">  <b class="spoiler_title">Definition of results for 2 texts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileJSON = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./article1.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content1 = fileJSON.content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileJSON2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./article2.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content2 = fileJSON2.content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'async'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.parallel([ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ textCanonization(content1, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ makeShingles(text, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shingles</span></span></span><span class="hljs-function">) </span></span>{ hashingShingles(shingles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hashes</span></span></span><span class="hljs-function">) </span></span>{ callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, hashes); }); }) }); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ textCanonization(content2, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ makeShingles(text, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shingles</span></span></span><span class="hljs-function">) </span></span>{ hashingShingles(shingles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hashes</span></span></span><span class="hljs-function">) </span></span>{ callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, hashes); }); }) }); } ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstHashes = results[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondHashes = results[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compareShingles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr1, arr2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; arr1[<span class="hljs-number"><span class="hljs-number">0</span></span>].forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr2[<span class="hljs-number"><span class="hljs-number">0</span></span>].indexOf(item) !== <span class="hljs-number"><span class="hljs-number">-1</span></span>) { count++; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count*<span class="hljs-number"><span class="hljs-number">2</span></span>/(arr1[<span class="hljs-number"><span class="hljs-number">0</span></span>].length + arr2[<span class="hljs-number"><span class="hljs-number">0</span></span>].length)*<span class="hljs-number"><span class="hljs-number">100</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = compareShingles(firstHashes, secondHashes); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(c); });</code> </pre><br></div></div><br>  Formula <code>count*2/(arr1[0].length + arr2[0].length)*100</code> finds the percentage ratio for 2 texts. <br><br>  Texts for comparison: <a href="http://www.washingtonpost.com/business/technology/ftc-says-apple-will-pay-at-least-325-million-over-in-app-purchases/2014/01/15/7c2ebc54-7e13-11e3-95c6-0a7aa80874bc_story.html">FTC says Apple will pay at least $ 32.5 million over in-app purchases</a> and <a href="http://www.bostonglobe.com/business/2014/01/16/apple-will-refund-least-million-app-case/EZlzgfWQWoCXsxcQKqReWP/story.html">Apple will pay $ 32.5m to settle the app</a> .  With the number of words in a shingle equal to 10 - the texts were similar to 2.16% which is very good. <br>  From the questions it is not clear what the option of using 84x functions is better  And I would also like to know some kind of algorithm for calculating the optimal number of words in a shingle (currently indicated 10). <br>  The entire source code of the algorithm and an example of work can be viewed on <a href="https://github.com/aslikeyou/node-w-shingling">github.com</a> </div><p>Source: <a href="https://habr.com/ru/post/209826/">https://habr.com/ru/post/209826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209816/index.html">Day-to-Day Service Plan - Part 2: Automatic Update of Statistics</a></li>
<li><a href="../209818/index.html">FORTH: nano-servers and nanoclients. Part 1</a></li>
<li><a href="../209820/index.html">Validating Forms in a Declarative Style (C #)</a></li>
<li><a href="../209822/index.html">Testers - a supporting role?</a></li>
<li><a href="../209824/index.html">Test boost :: lockfree on the speed and delay of message transmission</a></li>
<li><a href="../209828/index.html">Hekslet: Erlang, logic, operating systems, Java 2</a></li>
<li><a href="../209830/index.html">Recognition of document images using the roulette algorithm</a></li>
<li><a href="../209832/index.html">Persuasion architecture, 7 user manipulation mechanisms</a></li>
<li><a href="../209834/index.html">Transition to ADFS authorization and authentication mechanisms as part of a marketing strategy</a></li>
<li><a href="../209838/index.html">How to test in Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>