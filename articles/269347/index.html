<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Celery: best practices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are working with Django, then at some development stage you may need background processing of long running tasks. It is possible that for this ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Celery: best practices</h1><div class="post__text post__text-html js-mediator-article">  If you are working with Django, then at some development stage you may need background processing of long running tasks.  It is possible that for this kind of tasks you use some kind of tool for managing the queues of tasks.  Celery is one of the most popular projects for solving similar problems in the world of python and Django at the moment, but there are other projects for this purpose. <br><br>  While I was working on some projects using Celery to manage the task queues, some best practices emerged that I decided to document.  But these are big words for what I think about the right approach to solving such problems, as well as some of the underused opportunities offered by the community of the Celery project. <br><a name="habracut"></a><br><h3>  No.1: Do not use DBMS as your AMQP broker </h3><br>  Let me explain why I think this is wrong (besides the <a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/django.html">limitations</a> described in the Celery documentation). <br><br>  The DBMS was not developed for those tasks that perform a full-fledged AMQP broker such as RabbitMQ.  It will fall in ‚Äúcombat‚Äù conditions even on a project with not very large traffic / user base. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I assume that the most popular reason for why people decide to use a DBMS is that, as a rule, they already have one DBMS for a web application, so why not use it again.  Getting started with this option is easy and you don‚Äôt need to worry about other components (such as RabbitMQ). <br><br>  Suppose a not so hypothetical scenario: you have 4 background workers for processing that you put into the database.  This means that you get 4 processes that often request a database about new tasks, not to mention the fact that each of them can have its own competing threads.  At some point in time, you realize that the delay in processing tasks grows, and therefore more new tasks come in than are completed, it is necessary to increase the number of workers.  Suddenly, the speed of your database starts to "cave in" due to the huge number of requests from the workers to the database, disk input / output exceeds the specified limits, and all this begins to affect your application, because the workers actually arranged a DDOS attack on your database. <br><br>  This would not have happened when using a full-fledged AMQP broker, since the queue is placed in memory and thus eliminates the high load on the hard disk.  Consumers (workers) do not need to frequently request information, since the queue has a mechanism for delivering a new task to the worker, and even if the AMQP broker is overloaded for any other reason, this will not lead to a crash and slowdown of the web application that interacts with the user . <br><br>  I will go even further and say that you should not use the DBMS as a broker even during the development process, then there are such things as Docker and many pre-configured <a href="https://registry.hub.docker.com/search%3Fq%3Drabbitmq">images that provide customized RabbitMQ out of the box</a> . <br><br><h3>  No.2: Use more queues (i.e. not just one, which is given by default) </h3><br>  Celery is very easy to start using, and it immediately provides one default queue, in which all tasks are placed until another Celery behavior is explicitly prescribed.  The most common example of what you can see: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.task() def my_taskA(a, b, c): print("doing something here...") @app.task() def my_taskB(x, y): print("doing something here...")</span></span></code> </pre> <br><br>  What happens if both tasks are placed in the same queue, unless otherwise specified in the celeryconfig.py file.  I am fully understanding what this approach can justify, you have one decorator who creates convenient background tasks.  Here I would like to note that taskA and taskB, while in the same queue, can do completely different things and thus one of them may be much more important than the other, so why are they all in the same basket?  Even if you have one worker, then imagine such a situation that the less important task of taskB will be so massive that the more important task of taskA the worker cannot give the necessary attention. This brings us to the next point. <br><br><h3>  <b>No.3: Use Worker Priorities</b> </h3><br>  By solving the problem mentioned above, placing taskA in one queue, and taskB in another, and then assigning x workers to processing Q1 and the rest to processing Q2, since more tasks come to it.  That way, you can be sure that taskB will get enough workers, while the rest will handle the lower priority task when it arrives, without causing long waiting times and processing.  Therefore, determine your queues yourself: <br><br><pre> <code class="python hljs">CELERY_QUEUES = ( Queue(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, Exchange(<span class="hljs-string"><span class="hljs-string">'default'</span></span>), routing_key=<span class="hljs-string"><span class="hljs-string">'default'</span></span>), Queue(<span class="hljs-string"><span class="hljs-string">'for_task_A'</span></span>, Exchange(<span class="hljs-string"><span class="hljs-string">'for_task_A'</span></span>), routing_key=<span class="hljs-string"><span class="hljs-string">'for_task_A'</span></span>), Queue(<span class="hljs-string"><span class="hljs-string">'for_task_B'</span></span>, Exchange(<span class="hljs-string"><span class="hljs-string">'for_task_B'</span></span>), routing_key=<span class="hljs-string"><span class="hljs-string">'for_task_B'</span></span>), )</code> </pre><br>  And your routers, which determine where to send the task: <br><pre> <code class="python hljs">CELERY_ROUTES = { <span class="hljs-string"><span class="hljs-string">'my_taskA'</span></span>: {<span class="hljs-string"><span class="hljs-string">'queue'</span></span>: <span class="hljs-string"><span class="hljs-string">'for_task_A'</span></span>, <span class="hljs-string"><span class="hljs-string">'routing_key'</span></span>: <span class="hljs-string"><span class="hljs-string">'for_task_A'</span></span>}, <span class="hljs-string"><span class="hljs-string">'my_taskB'</span></span>: {<span class="hljs-string"><span class="hljs-string">'queue'</span></span>: <span class="hljs-string"><span class="hljs-string">'for_task_B'</span></span>, <span class="hljs-string"><span class="hljs-string">'routing_key'</span></span>: <span class="hljs-string"><span class="hljs-string">'for_task_B'</span></span>}, }</code> </pre><br>  This will allow to perform the workers for each task: <br><pre> <code class="python hljs">celery worker -E -l INFO -n workerA -Q for_task_A celery worker -E -l INFO -n workerB -Q for_task_B</code> </pre><br><h3>  <b>No.4: use Celery mechanisms to handle errors</b> </h3><br>  Most of the tasks that I have seen do not have error handling mechanisms.  If an error occurred in the task, it simply falls.  This may be convenient for some tasks, however most of the tasks I saw interacted with external APIs and fell due to some kind of network errors or other ‚Äúresource availability‚Äù problems.  The simplest approach to handling such errors is to over-execute the task code, since, perhaps, the problems of interaction with the external API have already been eliminated. <br><br><pre> <code class="hljs ruby">@app.task(bind=True, default_retry_delay=<span class="hljs-number"><span class="hljs-number">300</span></span>, max_retries=<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_task_A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">try:</span></span> print(<span class="hljs-string"><span class="hljs-string">"doing stuff here..."</span></span>) except SomeNetworkException as <span class="hljs-symbol"><span class="hljs-symbol">e:</span></span> print(<span class="hljs-string"><span class="hljs-string">"maybe do some clenup here...."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">retry</span></span>(e)</code> </pre><br>  I like to define the default time for the task, which it will wait before trying to execute again and how many attempts it will take before it finally throws an error (default_retry_delay and max_retries parameters, respectively).  This is the simplest form of error handling that I can imagine, but I have seen that it is almost never used.  Of course, Celery has more complex error handling methods, they are described in the Celery documentation. <br><br><h3>  <b>No.5: use Flower</b> </h3><br>  <a href="http://celery.readthedocs.org/en/latest/userguide/monitoring.html">Flower</a> is a great tool for tracking the status of your tasks and Celery workers.  The tool has a web interface and it allows such things as: <br><ul><li>  task progress </li><li>  execution details </li><li>  status of workers </li><li>  launch new workers </li></ul><br>  You can see the full list of features here. <br><br><h3>  <b>No.6: Track task status only if you need it.</b> </h3><br>  The task status is information about whether the task was completed successfully or not.  It may be useful for some statistical indicators.  An important thing to be understood in this case: the status of the task is not the resulting data and the work that it performed, such information is most similar to the implicit changes recorded in the database (such as changes in the user‚Äôs friends list). <br><br>  In most of the projects that I saw, I really didn‚Äôt care about the status of the task after it was completed, using the sqlite database, which is suggested by default, or spent better time using large PostgreSQL DBMS.  Why just load the database of your application?  Use CELERY_IGNORE_RESULT = True in your celeryconfig.py configuration file and discard such data. <br><br><h3>  <b>No.7: do not transfer database objects \ ORM to the task</b> </h3><br>  After discussing the above, at meetings of local python developer groups, some people suggested including an additional item in the list provided.  What is he talking about?  You should not transfer database objects, for example, a user model to a background task, since the serialized object may contain outdated and incorrect data.  If it is necessary for you, transfer the user ID to the task, and in the task itself request the database about this user. </div><p>Source: <a href="https://habr.com/ru/post/269347/">https://habr.com/ru/post/269347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269331/index.html">SVG icons - a lot and with style</a></li>
<li><a href="../269333/index.html">Routing subtleties</a></li>
<li><a href="../269337/index.html">Authentication: what is common between a refrigerator and a gun?</a></li>
<li><a href="../269341/index.html">Magento Codepools [Magento Certification]</a></li>
<li><a href="../269343/index.html">On the road with clouds: the reality of data centers and the role of SPLA in it</a></li>
<li><a href="../269349/index.html">New animation tabs in the assembly Vivaldi 1.0.303.23</a></li>
<li><a href="../269351/index.html">Swipe banner with navigation buttons and progress bar: use the jQuery Cycle2 plugin</a></li>
<li><a href="../269355/index.html">How to start a newbie in Go</a></li>
<li><a href="../269359/index.html">What is wrong with this code?</a></li>
<li><a href="../269361/index.html">The digest of interesting materials from the world of Drupal # 14</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>