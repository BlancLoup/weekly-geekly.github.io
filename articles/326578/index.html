<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My C ++ I / O streams using std :: streambuf</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The example article explains how to implement streaming I / O support from the standard library (<iostream>) for its classes. 

 The text of the artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My C ++ I / O streams using std :: streambuf</h1><div class="post__text post__text-html js-mediator-article">  <i>The example article explains how to implement streaming I / O support from the standard library (&lt;iostream&gt;) for its classes.</i> <i><br><br></i>  <i>The text of the article will often contain the word "stream", which means just the input-output stream ((i / o) stream), but not the execution thread (thread).</i>  <i>Execution threads are not considered in the article.</i> <br><br><h1>  Introduction </h1><br>  Standard library streams are a powerful tool.  Argument function can specify the stream, and it provides its versatility: it can work with standard files (fstream) and the console (cin / cout), and with sockets and COM-ports, if you find the appropriate library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, it is not always possible to find a ready-made library where the appropriate functionality has already been implemented, maybe even you are developing your own library with your own classes.  Then there is the task of implementing the thread interface on its own. <br><a name="habracut"></a><br><h3>  Environment Used </h3><br>  When writing an article for the test of examples, the g ++ compiler was used (Ubuntu 5.4.0-6ubuntu1 ~ 16.04.4), as well as the c ++ 11 standard.  For clarity, I used the override keyword from it to mark the base class's overridable methods, but if you remove it (and nullptr to replace NULL), then it should be collected on older standards. <br><br>  All examples are also available on github: <a href="https://github.com/iassasin/streambuf_examples">streambuf_examples</a> . <br><br><h1>  Content </h1><br><ul><li>  <a href="https://habr.com/ru/post/326578/">How are the streams arranged?</a> </li><li>  <a href="https://habr.com/ru/post/326578/">Simple cases - unbuffered</a> <br><ul><li>  <a href="https://habr.com/ru/post/326578/">Example 1 - we filter numbers</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/326578/">We use buffers</a> <br><ul><li>  <a href="https://habr.com/ru/post/326578/">Example 2 - block output</a> </li><li>  <a href="https://habr.com/ru/post/326578/">Example 3 - buffered input from file</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/326578/">Extended capabilities</a> <br><ul><li>  <a href="https://habr.com/ru/post/326578/">seekoff and seekpos to move around the file</a> </li><li>  <a href="https://habr.com/ru/post/326578/">pbackfail - return read characters back</a> </li><li>  <a href="https://habr.com/ru/post/326578/">Example 4 - reading a file with positioning and returning characters</a> </li><li>  <a href="https://habr.com/ru/post/326578/">Other features</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/326578/">Conclusion</a> </li><li>  <a href="https://habr.com/ru/post/326578/">Links</a> </li></ul><br><a name="General"></a><h1>  How are the streams arranged? </h1><br>  Each class that supports stream I / O inherits the classes <b>std :: istream</b> (input), <b>std :: ostream</b> (output), or <b>std :: iostream</b> (input and output).  They provide the ability to use overloaded '&lt;&lt;' and '&gt;&gt;' operators, output formatting, converting numbers to strings and vice versa, etc. <br><br>  However, the direct reading or writing of data does not occur in it, but in the class inheriting from <b>std :: streambuf</b> .  Streambuf itself is just an interface with a set of virtual functions that need to be redefined in the inheritance class and already in them implement your own logic of reading / writing data (this is exactly what is done in the std :: filebuf and std :: stringbuf classes for fstream and stringstream respectively). <br><br>  In addition, streambuf implements part of the buffer logic.  The programmer need only specify the beginning and end of the buffer and implement event handlers for its overflow, emptying, synchronization, etc. <br><br>  When developing your own streams, the most difficult part is the implementation of <b>std :: streambuf</b> .  Derived classes from istream, ostream or iostream in simple cases may be completely absent. <br><a name="No_buffers"></a><br><h1>  Simple cases - unbuffered </h1><br>  In the simple case, or when performance is not important, buffers may not be necessary.  Then it is enough to override only three virtual functions: <br><br><ul><li>  <b>int overflow (int c)</b> - called when the buffer overflows.  The argument is a character that "did not fit" into the buffer. <br><br>  <u>Return value:</u> if successful, the code of the written symbol, converted to int, otherwise EOF. <br><br>  <u>Default behavior:</u> always returns EOF. <br><br></li><li>  <b>int underflow ()</b> - called to get the current character without going to the next. <br><br>  <u>Return value:</u> if successful, the code of the character read, converted to int, otherwise EOF. <br><br>  <u>Default behavior:</u> if the buffer is available and there are unread characters, returns the character at the current position in the buffer, otherwise EOF. <br><br></li><li>  <b>int uflow ()</b> is the same as underflow, but if successful, shifts the buffer pointer to the next character. <br><br>  <u>Return value:</u> as in underflow. <br><br>  <u>Default behavior:</u> causes underflow.  If the result is successful, shifts the buffer pointer to the next character and returns the result of the underflow call; if unsuccessful, returns EOF.  Attempting to move the pointer to an unset buffer will end with a segmentation fault; remember to override this behavior if you are not using a buffer! </li></ul><br>  <i>Hereinafter, the description of functions is taken from cppreference.com</i> <br><a name="Example_1"></a><br><h2>  Example 1 - we filter numbers </h2><br>  Perhaps, while the text is enough.  As an example, let's analyze the filtering stream, which will pass only the characters of numbers and spaces (so that the numbers can somehow be separated from each other), we will take the data from another stream. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; class numfilterbuf : public streambuf { private: istream *in; ostream *out; int cur; //  ,   underflow() protected: /*    : */ virtual int overflow(int c) override { if (c == traits_type::eof()){ return traits_type::eof(); } char_type ch = static_cast&lt;char_type&gt;(c); if (ch == ' ' || (ch &gt;= '0' &amp;&amp; ch &lt;= '9')){ //     out-&gt;put(ch); // -  ,  EOF return out-&gt;good() ? ch : traits_type::eof(); } return ch; } /*    : */ // -        segmentation fault virtual int uflow() override { int c = underflow(); cur = traits_type::eof(); // underflow()       return c; } virtual int underflow() override { if (cur != traits_type::eof()){ return cur; } //   ,  while (in-&gt;good()){ cur = in-&gt;get(); if (cur == traits_type::eof()){ return traits_type::eof(); } char_type ch = static_cast&lt;char_type&gt;(cur); if (ch == ' ' || (ch &gt;= '0' &amp;&amp; ch &lt;= '9')){ //      return ch; } } return traits_type::eof(); } public: numfilterbuf(istream &amp;_in, ostream &amp;_out) : in(&amp;_in), out(&amp;_out), cur(traits_type::eof()) {} }; int main(int argc, char **argv){ const char str1[] = "In 4 bytes contains 32 bits"; const char str2[] = "Unix time starts from Jan 1, 1970"; istringstream str(str1); numfilterbuf buf(str, cout); //   stringstream,    iostream numfilter(&amp;buf); //        iostream string val; getline(numfilter, val); numfilter.clear(); //     EOF     stringstream cout &lt;&lt; "Original: '" &lt;&lt; str1 &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Read from numfilter: '" &lt;&lt; val &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Original: '" &lt;&lt; str2 &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Written to numfilter: '"; numfilter &lt;&lt; str2; cout &lt;&lt; "'" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  The result of the program: <br><br><pre> <code class="hljs pgsql">Original: <span class="hljs-string"><span class="hljs-string">'In 4 bytes contains 32 bits'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numfilter: <span class="hljs-string"><span class="hljs-string">' 4 32 '</span></span> Original: <span class="hljs-string"><span class="hljs-string">'Unix time starts from Jan 1, 1970'</span></span> Written <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numfilter: <span class="hljs-string"><span class="hljs-string">' 1 1970'</span></span></code> </pre><br>  The main points in the code have already been commented, however, it is worth noting that it is important to read both <b>uflow</b> and <b>underflow</b> for reading, since underflow can be called <i>before</i> uflow and even <i>several times in a row</i> .  If you add debugging output to the beginning of these functions, you can see it clearly, for example, when reading from a stream into an integer variable. <br><br>  Also in the code, you might notice the use of the <code>char_type</code> type.  It is defined in the streambuf class and in our case it is an alias to the <code>char</code> type, i.e.  single byte character.  More on this will be discussed at the end of the article. <br><a name="Use_buffers"></a><br><h1>  We use buffers </h1><br>  As I said earlier, streambuf already implements in itself a part of the logic of working with the buffer and provides access to 6 pointers, 3 pointers each to the input and output buffers.  However, streambuf does not implement memory allocation for buffers.  This task is assigned to the programmer along with the initialization of the buffer pointers. <br><br>  For the input buffer, the pointers are as follows: <br><br><ul><li>  <b>eback ()</b> <i>(end back pointer)</i> - pointer to the first element of the buffer </li><li>  <b>gptr ()</b> <i>(get pointer)</i> - pointer to the element of the buffer that will be read next </li><li>  <b>egptr ()</b> <i>(end get pointer)</i> - pointer to the element following the last element of the buffer.  When <code>gptr</code> reaches it, it means that the buffer is exhausted and needs to be filled again. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/abd/803/c95/abd803c95a924afc8f6248b77672e602.png"></div><br>  <i>Visual illustration from mr-edd.co.uk</i> <br><br>  The following functions are also used to control the input buffer pointers: <br><br><ul><li>  <b>setg (eback, gptr, egptr)</b> - sets the values ‚Äã‚Äãof the corresponding pointers </li><li>  <b>gbump (offset)</b> - move the <code>gptr</code> pointer to the <code>offset</code> positions.  In fact, after executing the function, <code>gptr</code> will take the value <code>gptr + offset</code> </li></ul><br>  Output buffer pointers have similar names and purposes: <br><br><ul><li>  <b>pbase ()</b> <i>(put base pointer)</i> - pointer to the first element of the buffer </li><li>  <b>pptr ()</b> <i>(put pointer)</i> - pointer to the element of the buffer that will be written next </li><li>  <b>epptr ()</b> <i>(end put pointer)</i> - pointer to the element following the last element of the buffer. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/661/8ee/a7f/6618eea7fe4d4293849973f6e7df2d61.png"></div><br>  <i>Another graphic illustration from mr-edd.co.uk</i> <br><br>  The control functions of the output buffer are also similar: <br><br><ul><li>  <b>setp (pbase, epptr)</b> - sets the values ‚Äã‚Äãof the corresponding pointers.  Note that <code>setp</code> only two arguments, unlike <code>setg</code> .  When initializing the output buffer <code>pptr</code> automatically equated to <code>pbase</code> (i.e. set at the beginning of the buffer) </li><li>  <b>pbump (offset)</b> - move the <code>pptr</code> pointer to the <code>offset</code> positions.  In fact, after executing the function <code>pptr</code> will take the value <code>pptr + offset</code> </li></ul><br>  At this theory ends, and we turn to practice. <br><a name="Example_2"></a><br><h2>  Example 2 - block output </h2><br>  In one project, I needed to transparently divide the stream into small parts, each of which was accompanied by a certain heading.  I realized this with the help of the new heir <code>streambuf</code> .  It seemed to me that this class rather simply and clearly shows a simple operation with an output buffer.  Therefore, in the following example, we will divide the output into parts and frame each with the <code>&lt;start&gt;</code> and <code>&lt;end&gt;</code> tags: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class blockoutputbuf : public streambuf { private: ostream *out; vector&lt;char_type&gt; buffer; string startb, endb; protected: virtual int overflow(int c) override { if (out-&gt;good() &amp;&amp; c != traits_type::eof()){ *pptr() = c; //   1 "" ,    pbump(1); //        return sync() == 0 ? c : traits_type::eof(); } return traits_type::eof(); } virtual int sync() override { if (pptr() == pbase()) //  ,     return 0; ptrdiff_t sz = pptr() - pbase(); //,      //     *out &lt;&lt; startb; out-&gt;write(pbase(), sz); *out &lt;&lt; endb; if (out-&gt;good()){ pbump(-sz); //        return 0; } return -1; } public: blockoutputbuf(ostream &amp;_out, size_t _bufsize, string _startb, string _endb) : out(&amp;_out), buffer(_bufsize), startb(_startb), endb(_endb) { char_type *buf = buffer.data(); setp(buf, buf + (buffer.size() - 1)); // -1  ,    overflow() } }; int main(int argc, char **argv){ const char str1[] = "In 4 bytes contains 32 bits"; const char str2[] = "Unix time starts from Jan 1, 1970"; blockoutputbuf buf(cout, 10, "&lt;start&gt;", "&lt;end&gt;\n"); ostream blockoutput(&amp;buf); cout &lt;&lt; "Original: '" &lt;&lt; str1 &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Written to blockoutputbuf: '"; blockoutput &lt;&lt; str1; blockoutput.flush(); //"" ,       str1 cout &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Original: '" &lt;&lt; str2 &lt;&lt; "'" &lt;&lt; endl; cout &lt;&lt; "Written to blockoutputbuf: '"; blockoutput &lt;&lt; str2; blockoutput.flush(); cout &lt;&lt; "'" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre><br></div></div><br>  The attentive reader has probably already thought a long time ago: the buffer is a buffer, but you have to somehow reset it, not only when overflowed, but also at the request of the programmer (just as it does when writing to a file). <br><br>  For this purpose, one more virtual function <b>int sync ()</b> serves.  Usually, it is called just at the request of the programmer, however, in the example above, we also call it ourselves when the buffer overflows.  The value returned by it indicates a successful synchronization (0) or unsuccessful (-1), if unsuccessful, the stream becomes an invalid state.  The default implementation does nothing and simply returns 0 (success). <br><br>  Speaking of buffer overflow.  In the example, a small trick was used to simplify the implementation of <code>overflow()</code> : the actual buffer size is always 1 element larger than the streambuf "thinks".  This allows you to place the ‚Äúnot fit‚Äù character passed to the <code>overflow</code> function and not complicate the code with its specific processing. <br><br>  The output of the program for blocks of 10 characters is as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> Original: 'In 4 bytes contains 32 bits'
 Written to blockoutputbuf: '&lt;start&gt; In 4 bytes &lt;end&gt;
 &lt;start&gt; contains &lt;end&gt;
 &lt;start&gt; 32 bits &lt;end&gt;
 '
 Original: 'Unix time starts from Jan 1, 1970'
 Written to blockoutputbuf: '&lt;start&gt; Unix time &lt;end&gt;
 &lt;start&gt; starts fro &lt;end&gt;
 &lt;start&gt; m Jan 1, 1 &lt;end&gt;
 &lt;start&gt; 970 &lt;end&gt;
 ' </pre></div></div><br><a name="Example_3"></a><br><h2>  Example 3 - buffered input from file </h2><br>  Reading is a bit more complicated, so let's start with a simple one.  In the example below, a simple sequential reading of the file is implemented using a stream.  To retrieve data from a file, use the tools of the C standard library. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; class cfilebuf : public streambuf { private: vector&lt;char_type&gt; buffer; FILE *file; protected: virtual int underflow() override { if (!file) return traits_type::eof(); if (gptr() &lt; egptr()) //   ,    return *gptr(); char_type *start = eback(); //   ,    size_t rd = fread(start, sizeof(char_type), buffer.size(), file); //    ,     setg(start, start, start + rd); return rd &gt; 0 ? *gptr() : traits_type::eof(); } public: cfilebuf(size_t _bufsize) : buffer(_bufsize), file(nullptr) { char_type *start = buffer.data(); char_type *end = start + buffer.size(); setg(start, end, end); // eback = start, gptr = end, egptr = end //.. gptr == egptr,            } ~cfilebuf(){ close(); } bool open(string fn){ close(); file = fopen(fn.c_str(), "r"); return file != nullptr; } void close(){ if (file){ fclose(file); file = nullptr; } } }; int main(int argc, char **argv){ cfilebuf buf(10); istream in(&amp;buf); string line; buf.open("file.txt"); while (getline(in, line)){ cout &lt;&lt; line &lt;&lt; endl; } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Since the example is simple, it has a number of drawbacks, the main of which we will discuss below. <br><a name="Extended"></a><br><h1>  Extended capabilities </h1><br>  Despite the fact that the streams obtained in the previous sections can already be used, their implementation is incomplete.  In practice, more complex situations may arise that require additional functionality, which will be discussed later. <br><a name="Seeks"></a><br><h2>  seekoff and seekpos to move around the file </h2><br>  When working with a file, it may be necessary to move the position in the file to an arbitrary location.  As you have already guessed, in the example above this is not implemented: the file is read only in one direction, you cannot go back, only to rediscover the file.  To fix this major flaw, we will need to override the following methods of the <code>streambuf</code> class: <br><br><ul><li>  <b>streampos seekpos (streampos sp, openmode which)</b> - called when trying to move to the position specified by the absolute value, i.e.  position from the beginning of the sequence. <br><br>  <u>Return value:</u> if successful, the new set position, otherwise -1. <br><br>  <u>Default behavior:</u> does nothing and returns -1. <br><br></li><li>  <b>streampos seekoff (streamoff off, seekdir way, openmode which)</b> - called when trying to move to a position specified relative to some reference point, which is given by the argument <code>way</code> . <br><br>  <u>Return value:</u> if successful, the new <b>absolute</b> position set, otherwise -1. <br><br>  <u>Default behavior:</u> does nothing and returns -1. </li></ul><br>  In functions, in addition to the first argument (position or offset), there are two more: <br><br><ul><li>  <b>openmode</b> is the type of pointer that needs to be moved: <code>ios_base::in</code> (read position) and <code>ios_base::out</code> (write position).  Note that the argument is a bitmask: i.e.  may contain one of the values, or <b>both</b> . <br><br></li><li>  <b>seekdir</b> is used for relative shift and indicates the point of reference for moving the pointer.  It can take one of three values: <code>ios_base::beg</code> (from the beginning of the stream), <code>ios_base::cur</code> (from the current position) or <code>ios_base::end</code> (from the end of the stream). </li></ul><br>  Now, armed with this knowledge, let's imagine what the implementation of navigating through a file in Example 3 might look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> streampos </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekpos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(streampos sp, ios_base::openmode which)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(which &amp; ios_base::in)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> streampos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fill_buffer_from(sp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> streampos </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekoff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(streamoff off, ios_base::seekdir way, ios_base::openmode which)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(which &amp; ios_base::in)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> streampos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (way){ <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ios_base::beg: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fill_buffer_from(off, SEEK_SET); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ios_base::cur: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fill_buffer_from(pos_base + gptr() - eback() + off, SEEK_SET); <span class="hljs-comment"><span class="hljs-comment">//       case ios_base::end: return fill_buffer_from(off, SEEK_END); } }</span></span></code> </pre><br>  Explanation: in the <code>pos_base</code> field the <code>pos_base</code> is stored in the file from which the data was loaded into the buffer. <br><br>  It looks pretty simple, but in fact, the <code>fill_buffer_from</code> function takes over the <code>fill_buffer_from</code> .  Its implementation is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">streampos </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill_buffer_from</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(streampos newpos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dir = SEEK_SET)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file || fseek(file, newpos, dir) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> pos = ftell(file); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; pos_base = pos; char_type *start = eback(); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rd = fread(start, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(char_type), buffer.size(), file); setg(start, start, start + rd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rd &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pos_base &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? pos_base : streampos(<span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre><br>  The function tries to move the pointer in the file to the specified position and fill our entire buffer from beginning to end.  It is not very productive for any operation to re-fill the buffer from the file, but in the example this is done to simplify the implementation.  When you implement your own successor to streambuf, you will probably know the subtleties of working with your data in order to write the most efficient pointer positioning functions. <br><br>  Well, we go further. <br><a name="pbackfail"></a><br><h2>  pbackfail - return read characters back </h2><br>  There are algorithms that do not require free movement to an arbitrary place in the stream, but in the process of reading and processing they may be asked to return several characters (usually 1-3) back to the stream.  For this, <code>istream</code> has <code>unget()</code> and <code>putback(character)</code> methods.  In the <code>streambuf</code> class <code>streambuf</code> if the character returned to the stream matches the previous one in the buffer, no additional calls occur.  However, if the characters do not match or the buffer pointer is at the very beginning, then a function is called to handle this situation: <br><br><ul><li>  <b>int pbackfail (int c)</b> - called if the <code>c</code> character returned to the stream does not <b>match the</b> character in the buffer at the previous position (or it does not exist). <br><br>  <u>Return value: the</u> code of the character returned to the stream, cast to type int, in case of failure - EOF. <br><br>  <u>Default behavior:</u> does nothing and returns EOF. </li></ul><br>  Now we implement our <code>pbackfail</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pbackfail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   if (pos_base &lt;= 0 || gptr() &gt; eback()) return traits_type::eof(); //   ,     if (fill_buffer_from(pos_base - 1L) == -1) return traits_type::eof(); if (*gptr() != c){ gbump(1); return traits_type::eof(); } return *gptr(); }</span></span></code> </pre><br>  As I said earlier, in this example, the performance will be terrible, because  almost every time <code>pbackfail</code> called <code>pbackfail</code> data will be re-read from the file to the buffer for the sake of just one character - the previous one.  But the goal of this article is to understand the principle of operation, and not the competition in the performance of implementations. <br><a name="Example_4"></a><br><h2>  Example 4 - reading a file with positioning and returning characters </h2><br>  Here you can simply see the code in which the edits implemented in the previous sections are added, as well as examples of the use of this functionality, with explanations: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; class cfilebuf : public streambuf { private: vector&lt;char_type&gt; buffer; FILE *file; streampos pos_base; //    eback streampos fill_buffer_from(streampos newpos, int dir = SEEK_SET) { if (!file || fseek(file, newpos, dir) == -1) return -1; //      eback long pos = ftell(file); if (pos &lt; 0) return -1; pos_base = pos; char_type *start = eback(); //   ,    size_t rd = fread(start, sizeof(char_type), buffer.size(), file); //    ,     setg(start, start, start + rd); return rd &gt; 0 &amp;&amp; pos_base &gt;= 0 ? pos_base : streampos(-1); } protected: virtual int underflow() override { if (!file) return traits_type::eof(); if (gptr() &lt; egptr()) //   ,    return *gptr(); streampos pos; if (pos_base &lt; 0) { //    ,    pos = fill_buffer_from(0); } else { //      pos = fill_buffer_from(pos_base + egptr() - eback()); } return pos != streampos(-1) ? *gptr() : traits_type::eof(); } //       ios_base::in //       ios_base::out     ( ) virtual streampos seekpos(streampos sp, ios_base::openmode which) override { if (!(which &amp; ios_base::in)) return streampos(-1); return fill_buffer_from(sp); } //   :  ,       virtual streampos seekoff(streamoff off, ios_base::seekdir way, ios_base::openmode which) override { if (!(which &amp; ios_base::in)) return streampos(-1); switch (way) { default: case ios_base::beg: return fill_buffer_from(off, SEEK_SET); case ios_base::cur: return fill_buffer_from(pos_base + gptr() - eback() + off); //       case ios_base::end: return fill_buffer_from(off, SEEK_END); } } virtual int pbackfail(int c) override { // gptr &gt; eback,        , //     ,  if (pos_base &lt;= 0 || gptr() &gt; eback()) return traits_type::eof(); //   ,     if (fill_buffer_from(pos_base - streampos(1L)) == streampos(-1)) return traits_type::eof(); if (*gptr() != c) { gbump(1); // ,   return traits_type::eof(); } return *gptr(); } public: cfilebuf(size_t _bufsize) : buffer(_bufsize), file(nullptr), pos_base(-1) { char_type *start = buffer.data(); char_type *end = start + buffer.size(); setg(start, end, end); // eback = start, gptr = end, egptr = end } ~cfilebuf() { close(); } bool open(string fn) { close(); file = fopen(fn.c_str(), "r"); return file != nullptr; } void close() { if (file) { fclose(file); file = nullptr; } } }; void read_to_end(istream &amp;in) { string line; while (getline(in, line)) { cout &lt;&lt; line &lt;&lt; endl; } } int main(int argc, char **argv) { cfilebuf buf(10); istream in(&amp;buf); buf.open("file.txt"); read_to_end(in); in.clear(); //      cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "Read last 6 symbols:" &lt;&lt; endl; in.seekg(-5, ios_base::end); //  ,     5   in.seekg(-1, ios_base::cur); //  6,     :) read_to_end(in); in.clear(); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "Read all again:" &lt;&lt; endl; in.seekg(0); read_to_end(in); in.clear(); in.seekg(2); //     3-    (      2-) in.get(); in.putback('b'); in.putback('a'); // pbackfail()             in.putback('H'); string word; in &gt;&gt; word; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "Read word after putback(): " &lt;&lt; word &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> </div></div><br><a name="Other"></a><br><h2>  Other features </h2><br>  In addition to the features discussed in the article, there are others.  Some are quite simply implemented, others are needed only in specific cases, so they are not discussed in detail.  The following is a list of such functions and a brief description of why they are needed.  A more detailed description of them you can find in the official documentation (link is at the end of the article). <br><br>  Other override methods: <br><br><ul><li>  <b>imbue ()</b> - redefining this function allows you to work with different locales for converting readable and writable characters. <br><br></li><li>  <b>setbuf ()</b> - allows you to use a custom buffer, instead of the built-in.  By default, this function does nothing, but you can add this feature to your implementation. <br><br></li><li>  <b>showmanyc ()</b> - allows you to tell the using function how many characters you can still read from the stream before blocking.  By default, returns 0 (i.e. there is no information about the number of characters). <br><br></li><li>  <b>xsgetn () and xsputn ()</b> are a pair of methods for reading / writing solid data blocks, in functionality similar to <code>fread</code> and <code>fwrite</code> .  If suddenly for block reading or writing in your case, you can implement a more efficient algorithm than character-by-character processing, then these methods are for you. </li></ul><br>  Also in your projects a situation may arise when the size of one character is more than 1 byte.  In this case, you should inherit from the <code>basic_streambuf</code> template class and use the character type you need.  Type aliases such as <code>char_type</code> , <code>int_type</code> , <code>pos_type</code> , etc. will help you in the implementation.  It is preferable to use them, since they always correspond to the types with which the library implementation of <code>streambuf</code> . <br><a name="End"></a><br><h1>  Conclusion </h1><br>  The standard library offers a large amount of functions for the flexible and productive implementation of your own threads.  However, remember that actual performance always depends on your implementation of the overridden methods for your particular case. <br><a name="Links"></a><br><h2>  Links </h2><br><ul><li>  <a href="https://github.com/iassasin/streambuf_examples">https://github.com/iassasin/streambuf_examples</a> - all examples from an article on the githaba; </li><li>  <a href="http://www.cplusplus.com/reference/streambuf/streambuf/">http://www.cplusplus.com/reference/streambuf/streambuf/</a> - official documentation on streambuf; </li><li>  <a href="http://www.mr-edd.co.uk/blog/beginners_guide_streambuf">http://www.mr-edd.co.uk/blog/beginners_guide_streambuf</a> is an English-language article from which illustrations and ideas were borrowed for some examples. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/326578/">https://habr.com/ru/post/326578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326568/index.html">Autonumber in four languages. Part 1</a></li>
<li><a href="../326570/index.html">How to talk with artificial intelligence?</a></li>
<li><a href="../326572/index.html">Creating a single-player game: from idea to prototype</a></li>
<li><a href="../326574/index.html">TCP / IP basics for future dilettantes</a></li>
<li><a href="../326576/index.html">Test Data Generator for C ++</a></li>
<li><a href="../326580/index.html">Switch from bash to zsh</a></li>
<li><a href="../326582/index.html">The story of how the parser turned into a full-fledged IRCO bot for Telegrams</a></li>
<li><a href="../326584/index.html">Notes on Cisco Catalyst: VLAN setup, password reset, IOS operating system flashing</a></li>
<li><a href="../326588/index.html">How to make your IDEA IDE level</a></li>
<li><a href="../326590/index.html">Mail.Ru Group Online Course News: Restarting Advanced C ++ Programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>