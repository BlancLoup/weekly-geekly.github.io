<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real-time BeagleBone: Using High-Speed ‚Äã‚ÄãPins</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habravchane! I have long been a reader of Habr, but still could not find a decent topic for publication. And now, finally, having thorough...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real-time BeagleBone: Using High-Speed ‚Äã‚ÄãPins</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f64/245/c6a/f64245c6aeb0466898e9ce9b48516050.jpg" alt="Fast GPIO tutorial"><br><br>  Hello, dear habravchane!  I have long been a reader of Habr, but still could not find a decent topic for publication.  And now, finally, having thoroughly gone through Habr and GT, I was surprised at the lack of publications on the Programmable Real-Time Subsystem ( <abbr title="The Programmable Real-Time Unit and Industrial Communication Subsystem">PRU-ICSS</abbr> ) of the <abbr title="Texas Instruments">TI</abbr> Sitara <sup>TM</sup> processor line. <br><br>  The most popular and affordable debug board with an AM335x processor is the so-called ‚Äúsingle-board‚Äù BeagleBone Black (White, Green).  And it is the presence of the PRU that makes BeagleBone the most preferable for use in <strong><em>hardware</em></strong> projects as compared to other budget single-server <b><i>* Pi</i></b> .  In addition, in some cases, BBB-PRU can quite effectively replace a bunch of <abbr title="Personal Computer">PC</abbr> - <abbr title="Microcontroller">MK</abbr> - <abbr title="Programmable logic integrated circuit">FPGA</abbr> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article provides a brief overview of the PRU subsystem and the modes of operation of high-speed I / O ports, a step-by-step example of the initialization of high-speed output ports (Enhanced GPIO) and an assessment of their performance. <a name="habracut"></a><br><br><h2>  <font color="#B4A279">Introduction</font> </h2><br>  I‚Äôll make a reservation at once that I‚Äôll not dwell on the characteristics and settings of the BeagleBone itself, since these topics are fairly well covered on the Internet, I‚Äôll just give the most useful, in my opinion, resources at the end.  And I will concentrate directly on the <abbr title="The Programmable Real-Time Unit and Industrial Communication Subsystem">PRU-ICSS</abbr> subsystem. <br><br>  Similar PRU solutions from among the popular ones have been found only for Intel Edison (by the way, a <a href="https://habrahabr.ru/company/intel/blog/260471/">tutorial</a> on this topic).  But at a similar price, Edison is inferior in performance and performance. <br><br>  <strong>IMPORTANT!</strong>  Not all PRU modes of operation described below and not fully implemented with BeagleBone due to the physical limitations of the board topology. <br><br>  A significant part of the materials presented in the publication is a translation, adaptation, modification, or combination of resources, given in <a href="https://habr.com/ru/post/319338/">useful sources</a> at the end of the article. <br><br>  So, what is the real-time subsystem? <br><br><h2>  <font color="#B4A279">PRU ICSS Overview</font> </h2><br>  PRU-ICSS consists of two 32-bit cores with a <abbr title="restricted (reduced) instruction set computer">RISC</abbr> architecture and operating at 200 MHz.  Each core has its own memory area, as well as a shared memory area with Linux, it can use general-purpose pins located on the P8-P9 connectors and form interrupts. <br><br>  The PRU is an important addition to the entire BeagleBone platform, allowing you to provide support for applications with tight time constraints.  But it is worth noting that the PRU is <strong><em>not a</em></strong> hardware accelerator, allowing to increase the speed of Linux-based applications.  The PRU can be assigned to perform certain functions and tasks, such as implementing software high-speed data transfer protocols, including non-standard ones, or digital processing of sensor signals in real time.  You can also simply implement additional hardware, such as the sixth UART ttyO6. <br><br><h3>  <font color="#B4A279">PRU architecture</font> </h3><br>  I will not delve into the translation of the manuals, I will mention the main characteristics of the system and comment on some of the slides from the <a href="http://events.linuxfoundation.org/sites/events/files/slides/Enhancing%2520RT%2520Capabilities%2520with%2520the%2520PRU%2520final.pdf">presentations</a> and schemes from the <a href="http://elinux.org/images/d/da/Am335xPruReferenceGuide.pdf">manuals</a> . <br><br><img src="https://habrastorage.org/files/476/b57/f4d/476b57f4d2604ca3b3ecb0635321d83e.jpg" alt="PRU + ARM Architecture"><br><br>  The main advantage of PRU is the short access time to local memory and peripherals.  In the clock cycles of the reference frequency, it is even lower than that of the ARM subsystem.  A more detailed description of write / read delays is provided <a href="http://processors.wiki.ti.com/index.php/AM335x_PRU_Read_Latencies">here</a> . <br><br>  The PRU subsystem includes the following units: <br><br><ul><li>  Two PRU cores, each includes: <br><ul><li>  8KB memory instructions; </li><li>  8KB of data memory; </li><li>  High-speed <abbr title="Open core protocol">OCP</abbr> bus interface for access to memory and ARM peripherals; </li><li>  I / O ports ( <abbr title="Enhanced general-purpose input / output">eGPIO</abbr> ) with support for asynchronous capture and serial output; </li><li>  Accumulative multiplier ( <abbr title="Multiplier ‚Äì Accumulator">MAC</abbr> ); </li></ul><br></li><li>  High-speed temporary memory ( <a href="https://en.wikipedia.org/wiki/Scratchpad_memory">Scratchpad memory</a> ): <br><ul><li>  3 blocks, in each 30 32-bit registers; </li><li>  Direct access allows fast synchronization between PRU cores; </li></ul><br></li><li>  One Interrupt Controller (INTC): <br><ul><li>  Receive up to 64 external events; </li><li>  10 interrupt channels; </li><li>  Hardware prioritization of events; </li></ul><br></li><li>  One set of industrial Ethernet peripherals: <br><ul><li>  One timer with 10 capture events and 8 comparisons; </li><li>  Two synchronization signals; </li><li>  Two 16-bit watchdog timers; </li><li>  Digital I / O ports; </li></ul><br></li><li>  12KB general purpose memory; </li><li>  Formation of 16 program events; </li><li>  One dual port <a href="https://ru.wikipedia.org/wiki/MII">MII</a> Ethernet module; </li><li>  One <abbr title="Bidirectional serial data channel for communicating with transceiver control registers">MDIO</abbr> port; </li><li>  One UART transceiver with a clock frequency of 192 MHz; </li><li>  One capture module ( <abbr title="Enhanced Capture Module">ECAP</abbr> ); </li><li>  Supports flexible power management; </li></ul><br><img src="https://habrastorage.org/files/582/1fb/e6d/5821fbe6daa14a3dae61b27f67651f85.jpg" alt="PRUSS scheme"><br><br>  Now let's take a closer look at the structure of high-speed I / O ports, which is directly the topic of the lesson below and the subject of study. <br><br>  Management of input and output ports is carried out using the registers R31 and R30, respectively.  It is noteworthy that the register R31 is also used to form a system interrupt.  Thus, writing to R31 generates an interrupt, and reading from the register returns information about the state of the input ports (GPI) and the interrupt controller (INTC). <br><br><img src="https://habrastorage.org/files/d86/6d9/f55/d866d9f556c64332a2c8fe430e69e87e.jpg" alt="Fast GPIO"><br><br>  The high speed of the I / O ports is provided by direct PRU access, unlike the ARM core, which has access to GPIO through several levels of connections. <br><br><h4>  <font color="#B4A279">GPIO Modes</font> </h4><br>  Modes are set by setting the corresponding bits in the CFG configuration register.  Live mode is the default mode and does not require additional settings. <br><br>  Input ports (GPI - R31) have 4 operation modes: <br><br><ul><li>  Live: <br><br><ul><li>  The PRU &lt;n&gt; _DATAIN register (pru &lt;n&gt; _r31_status [16: 0]) is connected directly to the corresponding PRU &lt;n&gt; </li><li>  Each PRU has independent input ports, so the total is 34; <br><br></li><li><div class="spoiler">  <b class="spoiler_title">GPI Live Connection</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/58e/e24/d61/58ee24d61a3e43a2828787ee6c65ad9d.jpg"></div></div></li></ul><br></li><li>  16-bit parallel capture: <br><br><ul><li>  The PRU &lt;n&gt; _DATAIN register (pru &lt;n&gt; _r31_status [16: 0]) captures data on the positive or negative edge of the clock frequency generated in the PRU &lt;n&gt; _CLOCK register (pru &lt;n&gt; _r31_status [16]); <br><br></li><li><div class="spoiler">  <b class="spoiler_title">Parallel capture circuit</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a07/bcc/c47/a07bccc47f324660816a5f026c39f565.jpg"></div></div></li></ul><br></li><li>  Shift 28-bit input register: <br><br><ul><li>  Register PRU &lt;n&gt; _DATAIN (pru &lt;n&gt; _r31_status [0]) captures and then shifts; </li><li>  The sampling rate is determined by the corresponding value of the slips in the CGF configuration register; <br><br></li><li><div class="spoiler"> <b class="spoiler_title">Shift register pattern</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/036/20c/c86/03620cc8663646298a673498e8b659db.jpg"></div></div></li></ul><br></li><li>  MII_RT mode: <br><br><ul><li>  Register mii_rt_r31_status [29: 0] is under the control of the module MII_RT; </li></ul></li></ul><br>  Output ports (GPO - R30) have 2 operation modes: <br><br><ul><li>  Live: <br><br><ul><li>  The PRU &lt;n&gt; _DATAOUT register (pru &lt;n&gt; _r30 [15: 0]) is connected directly to the corresponding PRU &lt;n&gt; </li><li>  Each PRU has independent output ports, so the total is 32; <br><br></li><li><div class="spoiler">  <b class="spoiler_title">GPO Direct Power On Scheme</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/cb0/db5/f19/cb0db5f19e744c1fbb038cad4cebeaed.jpg"></div></div></li></ul><br></li><li>  Shift Output Register: <br><br><ul><li>  The PRU &lt;n&gt; _DATAOUT register (pru &lt;n&gt; _r30 [0]) outputs and then shifts along the positive edge of the clock frequency generated in the PRU &lt;n&gt; _CLOCK register (pru &lt;n&gt; _r30 [1]); </li><li>  The sampling rate is determined by the corresponding value of the slips in the CGF configuration register; </li><li>  In this mode, double buffering is implemented using the 16-bit shadow registers gpo_sh0 and gpo_sh1; </li><li>  Each shadow register has an independent load control signal pru &lt;n&gt; _r30 [29:30] (PRU &lt;n&gt; _LOAD_GPO_SH [0: 1]); </li><li>  The issuance of values ‚Äã‚Äãbegins after setting the pru &lt;n&gt; _r30 [31] bit (PRU &lt;n&gt; _ENABLE_SHIFT) to 1; </li><li>  If you do not update the values ‚Äã‚Äãof the shadow registers, then the cyclic output of the predefined values ‚Äã‚Äãwill continue; </li><li>  Values ‚Äã‚Äãare terminated when the pru &lt;n&gt; _r30 [31] bit (PRU &lt;n&gt; _ENABLE_SHIFT) is reset to 0; <br><br></li><li><div class="spoiler">  <b class="spoiler_title">Shift register pattern</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b9d/50a/4e6/b9d50a4e64854d8c8adde553a2da8838.jpg"></div></div></li></ul></li></ul><br>  It is worth noting that the PRU can also access normal I / O ports and other peripherals of the ARM core via the <abbr title="Open core protocol">OCP</abbr> bus, but this will take longer. <br><br><h3>  <font color="#B4A279">Development under PRU</font> </h3><br>  To create a program under PRU, the following actions are required: <br><br><ol><li>  Install the PRU-ICSS package (if not pre-installed); </li><li>  Create a description of the device tree of the used peripherals and PRUs, compile and download it; </li><li>  Write a program for PRU (* .p) and compile it (* .bin); </li><li>  Write a loading and control program (*. C) for the PRU program and compile it; </li></ol><br>  The PRU-ICSS package serves as a means of downloading applications from Linux to the PRU and consists of two sections: a low-level kernel driver and user libraries.  The low-level kernel driver (uio_pru) provides the interaction of the PRU core with the PRUSSDRV user library and takes over the functions of powering the PRU, initializing the PRU clock, allocating memory for the PRU, and registering the PRU interrupts.  The PRUSSDRV library, in turn, allows you to start and stop the PRU, provides PRU access to peripherals and external memory, and manages PRU interrupts.  Also, the PRU-ICSS package includes the PRU assembler compiler - pasm. <br><br>  PRU-ICSS package software stack: <br><br><img src="https://habrastorage.org/files/459/0a8/948/4590a8948cd0426987d61a3d65d23e14.jpg" alt="PRU-ICSS package"><br><br>  Thus, the program * .c under Linux using the functions of the PRUSSDRV library loads the executable file (* .bin) into the PRU, creates shared memory areas, sends and receives interrupts. <br><br>  Separately, it is worth mentioning that for PRU, <abbr title="Texas Instruments">TI</abbr> has released the <a href="https://tiny.cc/ebb1310">prudebug</a> debugger and the <a href="https://tiny.cc/ebb1311">C compiler</a> . <br><br>  A compact and informative description of the instruction set can be found <a href="http://exploringbeaglebone.com/wp-content/uploads/2014/12/Instruction-Set-Sheet.pdf">here</a> . <br><br><h3>  <font color="#B4A279">Areas of possible use</font> </h3><br>  As noted earlier, the main task of the PRU is to unload the main ARM core by performing strictly time-limited tasks.  Such tasks can be the implementation of data transfer protocols or digital signal processing units.  So on BeagleBone PRU you can implement up to 25 PWM channels or 4 additional software UART.  The most successful projects demonstrating the power of PRU are <a href="http://beaglelogic.net/">BeagleLogic</a> , <a href="http://www.machinekit.io/">MachineKit</a> and <a href="https://trmm.net/Category:LEDscape">LEDscape</a> . <br><br>  Examples of use of PRU-cape: <br><br><img src="https://habrastorage.org/files/94c/6dc/2ab/94c6dc2ab9a74ea2a98b0ab455cf9cbd.jpg" alt="PRU-cape"><br><h2>  <font color="#B4A279">PRU installation</font> </h2><br>  Let's start, finally, the practical part. <br><br>  So, I will experiment on the existing Beaglebone Black A5C revision.  I use the Linux image <a href="">bone-debian-7.8-lxde-4gb-armhf-2015-03-01-4gb.img.xz</a> , loaded from an external SD memory card.  To access the BBB I use SSH PuTTY, for sharing WinSCP files. <br><br><pre><code class="bash hljs">root@beaglebone:~<span class="hljs-comment"><span class="hljs-comment"># uname -a Linux beaglebone 3.8.13-bone70 #1 SMP Fri Jan 23 02:15:42 UTC 2015 armv7l GNU/Linux</span></span></code> </pre> <br>  In the latest versions of the kernel, the <a href="http://processors.wiki.ti.com/index.php/PRU-ICSS_Remoteproc_and_RPMsg"><strong><em>remoteproc</em></strong></a> framework is used by default for PRU <a href="http://processors.wiki.ti.com/index.php/PRU-ICSS_Remoteproc_and_RPMsg"><strong><em>programming</em></strong></a> , but I have not yet mastered it, so we will use the PRUSSDRV library described earlier.  To make this possible, we include the module: <br><br><pre> <code class="bash hljs">root@beaglebone:~<span class="hljs-comment"><span class="hljs-comment"># modprobe uio_pruss</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Make sure the other necessary components are preinstalled.</b> <div class="spoiler_text"><pre> <code class="bash hljs">root@beaglebone:~<span class="hljs-comment"><span class="hljs-comment"># ls -a /usr/include | grep pruss pruss_intc_mapping.h prussdrv.h root@beaglebone:~# ls -a /usr/lib | grep pruss libprussdrv.a libprussdrv.so libprussdrvd.a libprussdrvd.so root@beaglebone:~# pasm PRU Assembler Version 0.86 Copyright (C) 2005-2013 by Texas Instruments Inc. Usage: pasm [-V#EBbcmLldz] [-Idir] [-Dname=value] [-Cname] InFile [OutFileBase] ... root@beaglebone:~# lsmod | grep pru uio_pruss 4066 0</span></span></code> </pre> <br></div></div><br>  Perform preliminary settings by setting the necessary environment variables in autoload: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"export SLOTS=/sys/devices/bone_capemgr.*/slots"</span></span> &gt;&gt; ~/.profile <span class="hljs-comment"><span class="hljs-comment">#echo "export SLOTS=/sys/devices/platform/bone_capemgr/slots" &gt;&gt; ~/.profile #    4 echo "export PINS=/sys/kernel/debug/pinctrl/44e10800.pinmux/pins" &gt;&gt; ~/.profile echo "export PINGROUPS=/sys/kernel/debug/pinctrl/44e10800.pinmux/pingroups" &gt;&gt; ~/.profile source .profile</span></span></code> </pre> <br><h4>  <font color="#B4A279">HDMI / EMMC Disable</font> </h4><br>  Almost all PRU peripherals are routed to ports whose main function is HDMI / EMMC.  Therefore, for successful interaction of the PRU with the outside world, it is necessary to disable the initialization of HDMI / EMMC. <br><br>  For the image used, this is done quite simply - it is only necessary to uncomment the required line in / boot / uEnv.txt.  Therefore, we edit it <code>nano /boot/uEnv.txt</code> , so that in the end it‚Äôs like this: <br><br><pre> <code class="bash hljs">... <span class="hljs-comment"><span class="hljs-comment">##Disable HDMI/eMMC cape_disable=capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN,BB-BONE-EMMC-2G ...</span></span></code> </pre> <br><h2>  <font color="#B4A279">GPIO: direct mode</font> </h2><br>  Using the informative tables of the <a href="http://exploringbeaglebone.com/wp-content/uploads/resources/BBBP8Header.pdf">P8</a> and <a href="http://exploringbeaglebone.com/wp-content/uploads/resources/BBBP9Header.pdf">P9</a> connectors, you can find out that BeagleBone has 8 high-speed output ports for PRU0 and 14 for PRU1.  As described <a href="https://habr.com/ru/post/319338/">earlier</a> , you must first disable HDMI / EMMC and configure the pins in the desired mode.  Since I want to squeeze more out of the BBB, we will work with PRU1 and configure the pins pr1_pru1_pru_r30 [0:13].  Also, we still have one unused input pr1_pru1_pru_r31_16, located on connector P9.26.  It is used to run the program on the external button. <br><br>  The best example of how to demonstrate the operation of the ports of general purpose PRU, in my opinion, will be the implementation of the programmable hardware delay function for an external event.  We will transmit the delay using a user program under linux through a shared area of ‚Äã‚Äãmemory.  The PRU directly implements a hardware delay and outputs its value, namely the lower 14 bits, to the available outputs. <br><br>  Thus, the following program algorithm appears: <br><br><ol><li>  Run the user program with the desired delay as an argument; </li><li>  The program initializes the PRU, passes the delay value, and starts the PRU routine; </li><li>  The subroutine PRU waits for an external event (button press); </li><li>  After an event is detected, the specified delay counts; </li><li>  Notifies user program of completion through an interrupt; </li><li>  The user program receives a subroutine shutdown interrupt; </li><li>  After that, deactivates the PRU and terminates itself; </li></ol><br><h3>  <font color="#B4A279">Direct GPO device tree overlays</font> </h3><br>  So, to implement the conceived program, it is necessary to configure 14 BBB ports for output and 1 port for input, as well as directly launch the PRU subsystem. <br><br>  Based on the examples from github, I compiled the following description of the device tree: <br><br><div class="spoiler">  <b class="spoiler_title">PRU_DGPO-00A0.dts</b> <div class="spoiler_text"><pre> <code class="bash hljs">/dts-v1/; /plugin/; / { compatible = <span class="hljs-string"><span class="hljs-string">"ti,beaglebone"</span></span>, <span class="hljs-string"><span class="hljs-string">"ti,beaglebone-black"</span></span>; /* identification */ part-number = <span class="hljs-string"><span class="hljs-string">"PRU_DGPO"</span></span>; version = <span class="hljs-string"><span class="hljs-string">"00A0"</span></span>; /* state the resources this cape uses */ exclusive-use = /* PRU1 Direct Output */ <span class="hljs-string"><span class="hljs-string">"P8.20"</span></span>, /* pru1: pr1_pru1_pru_r30_13 */ <span class="hljs-string"><span class="hljs-string">"P8.21"</span></span>, /* pru1: pr1_pru1_pru_r30_12 */ <span class="hljs-string"><span class="hljs-string">"P8.28"</span></span>, /* pru1: pr1_pru1_pru_r30_10 */ <span class="hljs-string"><span class="hljs-string">"P8.27"</span></span>, /* pru1: pr1_pru1_pru_r30_8 */ <span class="hljs-string"><span class="hljs-string">"P8.30"</span></span>, /* pru1: pr1_pru1_pru_r30_11 */ <span class="hljs-string"><span class="hljs-string">"P8.29"</span></span>, /* pru1: pr1_pru1_pru_r30_9 */ <span class="hljs-string"><span class="hljs-string">"P8.40"</span></span>, /* pru1: pr1_pru1_pru_r30_7 */ <span class="hljs-string"><span class="hljs-string">"P8.39"</span></span>, /* pru1: pr1_pru1_pru_r30_6 */ <span class="hljs-string"><span class="hljs-string">"P8.42"</span></span>, /* pru1: pr1_pru1_pru_r30_5 */ <span class="hljs-string"><span class="hljs-string">"P8.41"</span></span>, /* pru1: pr1_pru1_pru_r30_4 */ <span class="hljs-string"><span class="hljs-string">"P8.44"</span></span>, /* pru1: pr1_pru1_pru_r30_3 */ <span class="hljs-string"><span class="hljs-string">"P8.43"</span></span>, /* pru1: pr1_pru1_pru_r30_2 */ <span class="hljs-string"><span class="hljs-string">"P8.46"</span></span>, /* pru1: pr1_pru1_pru_r30_1 */ <span class="hljs-string"><span class="hljs-string">"P8.45"</span></span>, /* pru1: pr1_pru1_pru_r30_0 */ /* PRU1 Direct Input */ <span class="hljs-string"><span class="hljs-string">"P9.26"</span></span>, /* pru1: pr1_pru1_pru_r31_16 */ /* the hardware ip uses */ <span class="hljs-string"><span class="hljs-string">"pru1"</span></span>; fragment@0 { target = &lt;&amp;am33xx_pinmux&gt;; __overlay__ { pru_pru_pins: pinmux_pru_pru_pins { // The PRU pin modes pinctrl-single,pins = &lt; 0x084 0x0D /* lcd_pclk.pr1_pru1_pru_r30_13, MODE5 | OUTPUT | PRU */ 0x080 0x0D /* lcd_pclk.pr1_pru1_pru_r30_12, MODE5 | OUTPUT | PRU */ 0x0e8 0x0D /* lcd_pclk.pr1_pru1_pru_r30_10, MODE5 | OUTPUT | PRU */ 0x0e0 0x0D /* lcd_vsync.pr1_pru1_pru_r30_8, MODE5 | OUTPUT | PRU */ 0x0ec 0x0D /* lcd_ac_bias_en.pr1_pru1_pru_r30_11, MODE5 | OUTPUT | PRU */ 0x0e4 0x0D /* lcd_hsync.pr1_pru1_pru_r30_9, MODE5 | OUTPUT | PRU */ 0x0bc 0x0D /* lcd_data7.pr1_pru1_pru_r30_7, MODE5 | OUTPUT | PRU */ 0x0b8 0x0D /* lcd_data6.pr1_pru1_pru_r30_6, MODE5 | OUTPUT | PRU */ 0x0b4 0x0D /* lcd_data5.pr1_pru1_pru_r30_5, MODE5 | OUTPUT | PRU */ 0x0b0 0x0D /* lcd_data4.pr1_pru1_pru_r30_4, MODE5 | OUTPUT | PRU */ 0x0ac 0x0D /* lcd_data3.pr1_pru1_pru_r30_3, MODE5 | OUTPUT | PRU */ 0x0a8 0x0D /* lcd_data2.pr1_pru1_pru_r30_2, MODE5 | OUTPUT | PRU */ 0x0a4 0x0D /* lcd_data1.pr1_pru1_pru_r30_1, MODE5 | OUTPUT | PRU */ 0x0a0 0x0D /* lcd_data0.pr1_pru1_pru_r30_0, MODE5 | OUTPUT | PRU */ 0x180 0x36 /* uart1_rxd.pr1_pru1_pru_r31_16, MODE6 | INPUT | PRU */ &gt;; }; }; }; fragment@1 { target = &lt;&amp;ocp&gt;; __overlay__ { test_helper: helper { compatible = <span class="hljs-string"><span class="hljs-string">"bone-pinmux-helper"</span></span>; pinctrl-names = <span class="hljs-string"><span class="hljs-string">"default"</span></span>; pinctrl-0 = &lt;&amp;pru_pru_pins&gt;; status = <span class="hljs-string"><span class="hljs-string">"okay"</span></span>; }; }; }; fragment@2 { // Enable the PRUSS target = &lt;&amp;pruss&gt;; __overlay__ { status = <span class="hljs-string"><span class="hljs-string">"okay"</span></span>; }; }; };</code> </pre> <br></div></div><br>  Next, this file must be compiled, copied to / lib / firmware and downloaded: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Compiling the overlay from .dts to .dtbo"</span></span> dtc -O dtb -o PRU_DGPO-00A0.dtbo -b 0 -@ PRU_DGPO-00A0.dts <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Copy PRU_DGPO-00A0.dtbo to /lib/firmware"</span></span> cp PRU_DGPO-00A0.dtbo /lib/firmware <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Loading overlay:"</span></span> sh -c <span class="hljs-string"><span class="hljs-string">"echo 'PRU_DGPO' &gt; </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SLOTS</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Then you should check the boot process. <br><br><div class="spoiler">  <b class="spoiler_title">In a successful case, it should be like this:</b> <div class="spoiler_text"><pre> <code class="bash hljs">root@beaglebone:~<span class="hljs-comment"><span class="hljs-comment"># dmesg | tail [12566.485091] bone-capemgr bone_capemgr.9: slot #7: generic override [12566.485149] bone-capemgr bone_capemgr.9: bone: Using override eeprom data at slot 7 [12566.485197] bone-capemgr bone_capemgr.9: slot #7: 'Override Board Name,00A0,Override Manuf,PRU_DGPO' [12566.485506] bone-capemgr bone_capemgr.9: slot #7: Requesting part number/version based 'PRU_DGPO-00A0.dtbo [12566.485554] bone-capemgr bone_capemgr.9: slot #7: Requesting firmware 'PRU_DGPO-00A0.dtbo' for board-name 'Override Board Name', version '00A0' [12566.492347] bone-capemgr bone_capemgr.9: slot #7: dtbo 'PRU_DGPO-00A0.dtbo' loaded; converting to live tree [12566.494050] bone-capemgr bone_capemgr.9: slot #7: #3 overlays [12566.555682] bone-capemgr bone_capemgr.9: slot #7: Applied #3 overlays. root@beaglebone:~# cat $SLOTS 0: 54:PF--- 1: 55:PF--- 2: 56:PF--- 3: 57:PF--- 4: ff:PO-- Bone-LT-eMMC-2G,00A0,Texas Instrument,BB-BONE-EMMC-2G 5: ff:PO-- Bone-Black-HDMI,00A0,Texas Instrument,BB-BONELT-HDMI 6: ff:PO-- Bone-Black-HDMIN,00A0,Texas Instrument,BB-BONELT-HDMIN 7: ff:POL Override Board Name,00A0,Override Manuf,PRU_DGPO root@beaglebone:~# cat $PINS | grep 00d pin 32 (44e10880) 0000000d pinctrl-single pin 33 (44e10884) 0000000d pinctrl-single pin 40 (44e108a0) 0000000d pinctrl-single pin 41 (44e108a4) 0000000d pinctrl-single pin 42 (44e108a8) 0000000d pinctrl-single pin 43 (44e108ac) 0000000d pinctrl-single pin 44 (44e108b0) 0000000d pinctrl-single pin 45 (44e108b4) 0000000d pinctrl-single pin 46 (44e108b8) 0000000d pinctrl-single pin 47 (44e108bc) 0000000d pinctrl-single pin 56 (44e108e0) 0000000d pinctrl-single pin 57 (44e108e4) 0000000d pinctrl-single pin 58 (44e108e8) 0000000d pinctrl-single pin 59 (44e108ec) 0000000d pinctrl-single root@beaglebone:~# cat $PINS | grep 036 pin 96 (44e10980) 00000036 pinctrl-single</span></span></code> </pre> </div></div><br>  To learn more about the settings of the device tree of the latest Debian releases, I recommend contacting <a href="https://github.com/beagleboard/bb.org-overlays/">here</a> . <br><br>  In general, the Linux device tree is a separate topic that requires in-depth consideration.  Those interested can start exploring <a href="https://en.wikipedia.org/wiki/Device_tree">Device Tree</a> <a href="http://elinux.org/Device_Tree_Reference">here</a> and <a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">here</a> . <br><br><h3>  <font color="#B4A279">User program</font> </h3><br>  As mentioned earlier, the main tasks of the user program are: <br><br><ul><li>  Initializing PRU; </li><li>  Data exchange with PRU through a shared memory area; </li><li>  Run subroutine PRU; </li><li>  Formation and processing of interruptions and PRU events; </li></ul><br>  <b><i>Parallel_output.c:</i></b> <br><br><pre> <code class="hljs lua">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;prussdrv.h&gt; #include &lt;pruss_intc_mapping.h&gt; #define PRU_NUM <span class="hljs-number"><span class="hljs-number">1</span></span> // using PRU1 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> these examples int main (int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* argv[]) { unsigned int ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(getuid()!=<span class="hljs-number"><span class="hljs-number">0</span></span>){ printf(<span class="hljs-string"><span class="hljs-string">"You must run this program as root. Exiting.\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(argc!=<span class="hljs-number"><span class="hljs-number">2</span></span>) { printf(<span class="hljs-string"><span class="hljs-string">"Usage is Parralel_output and integer number of delay \n"</span></span>); printf(<span class="hljs-string"><span class="hljs-string">" eg ./Parralel_output 100\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *p; unsigned int cyc = (unsigned int) strtol(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], &amp;p, <span class="hljs-number"><span class="hljs-number">10</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"Delay for %d cycles\n"</span></span>, cyc); // Initialize structure used by prussdrv_pruintc_intc // PRUSS_INTC_INITDATA is found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pruss_intc_mapping.h tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA; // Allocate <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> initialize memory prussdrv_init (); ret = prussdrv_open(PRU_EVTOUT_0); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { printf(<span class="hljs-string"><span class="hljs-string">"prussdrv_open open failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ret); } // Map PRU<span class="hljs-string"><span class="hljs-string">'s interrupts prussdrv_pruintc_init(&amp;pruss_intc_initdata); // Write a number of cycles into PRU1 Data RAM0 prussdrv_pru_write_memory(PRUSS0_PRU1_DATARAM , 0, &amp;cyc, 4); // Load and execute the PRU program on the PRU prussdrv_exec_program (PRU_NUM, "./Parallel_output.bin"); // Wait for event completion from PRU, returns the PRU_EVTOUT_0 number int n = prussdrv_pru_wait_event (PRU_EVTOUT_0); printf("PRU program completed, event number %d.\n", n); // Disable PRU and close memory mappings prussdrv_pru_disable(PRU_NUM); prussdrv_exit (); return EXIT_SUCCESS; }</span></span></code> </pre> <br>  Compile: <br><br><pre> <code class="hljs swift">gcc <span class="hljs-type"><span class="hljs-type">Parallel_output</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> -o <span class="hljs-type"><span class="hljs-type">Parallel_output</span></span> -lpthread -lprussdrv</code> </pre> <br><h3>  <font color="#B4A279">PRU subroutine</font> </h3><br>  PASM assembler is used to write the PRU subroutine.  The subroutine runs on one of the two PRU cores independently of Linux.  PRU and Linux are synchronized via events and interrupts. <br><br>  In addition to the algorithm described above, we will add a few more instructions to the subroutine in order to estimate their execution time. <br><br>  <b><i>Parallel_output.p:</i></b> <br><br><pre> <code class="hljs pgsql">.origin <span class="hljs-number"><span class="hljs-number">0</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> program <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> PRU memory .entrypoint <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> // program entry <span class="hljs-type"><span class="hljs-type">point</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a debugger) #define PRU0_R31_VEC_VALID <span class="hljs-number"><span class="hljs-number">32</span></span> // allows notification <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> program completion #define PRU_EVTOUT_0 <span class="hljs-number"><span class="hljs-number">3</span></span> // the event number that <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> sent back <span class="hljs-keyword"><span class="hljs-keyword">START</span></span>: WBC r31.t16 // wait <span class="hljs-type"><span class="hljs-type">bit</span></span> clear - ie, button press // Toggle <span class="hljs-number"><span class="hljs-number">4</span></span> times Parallel output pins MOV r30, <span class="hljs-number"><span class="hljs-number">0xffff</span></span> MOV r30, <span class="hljs-number"><span class="hljs-number">0x0000</span></span> MOV r30, <span class="hljs-number"><span class="hljs-number">0xffff</span></span> MOV r30, <span class="hljs-number"><span class="hljs-number">0x0000</span></span> LBCO r30, C24, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> PRU1 Data RAM <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> r30 (use c24 const addr) <span class="hljs-keyword"><span class="hljs-keyword">CYCLE</span></span>: SUB r30, r30, <span class="hljs-number"><span class="hljs-number">1</span></span> // Decrement REG30 <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - ie, parallel output <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pins QBNE <span class="hljs-keyword"><span class="hljs-keyword">CYCLE</span></span>, r30, <span class="hljs-number"><span class="hljs-number">0</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CYCLE</span></span>, unless REG30=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>: // <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span> the calling app that finished MOV R31.b0, PRU0_R31_VEC_VALID | PRU_EVTOUT_0 HALT // halt the pru program</code> </pre> <br>  Compile: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">pasm</span></span> -b Parallel_output.p</code> </pre> <br><h3>  <font color="#B4A279">Run PRU and performance evaluation</font> </h3><br>  In order to estimate the speed of the PRU instructions, I will use a Tektronix MSO4032 350 MHz oscilloscope with a 16-channel logic analyzer having a resolution of 2 ns. <br><br><div class="spoiler">  <b class="spoiler_title">Photo system complete</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/525/76b/bdd/52576bbdd1874bec87551d1d0b028be3.jpg"><br><br><img src="https://habrastorage.org/files/7ee/0c7/2db/7ee0c72db0aa48939447f59903d0b521.jpg"><br></div></div><br>  Finally, run the program: <br><br><pre> <code class="bash hljs">root@beaglebone:/home/debian/Desktop/Direct-GPO<span class="hljs-comment"><span class="hljs-comment"># ./Parallel_output 15 Delay for 15 cycles PRU program completed, event number 1.</span></span></code> </pre> <br>  Since the delay cycle includes 2 instructions (SUB and QBNE), each for 5 ns, the hardware delay will be <i>arg * 10 ns</i> .  For the example above, the delay should be 150 ns.  Measurements are taken without taking into account test initial instructions. <br><br>  For clarity, the instructions are superimposed on the waveform: <br><br><img src="https://habrastorage.org/files/af1/3ce/9a4/af13ce9a451444c7be41edb86693d83c.jpg" alt="osc"><br><br>  As you can see, the execution time of the MOV instruction within the error limits due to the resolution of the logic analyzer is 2 ns, and it fits well with the stated 5 ns.  All 14 pins and 1 input are involved, as planned. <br><br>  Execution of the WBC instruction - waiting for an event - takes ~ 25 ns, but this time is constant and it will not be difficult to take into account if necessary. <br><br>  The following are oscillograms for different values ‚Äã‚Äãof the arguments, the delay measurement is made using the oscilloscope cursors. <br><br><div class="spoiler">  <b class="spoiler_title">Oscillogram for 150 ns delay</b> <div class="spoiler_text"> <code>root@beaglebone:~# ./Parallel_output 15</code> <br> <img src="https://habrastorage.org/files/e6a/aef/bf7/e6aaefbf74ba45ebb5f573e36b80f5d7.jpg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">15 ¬µs delay waveform</b> <div class="spoiler_text"> <code>root@beaglebone:~# ./Parallel_output 1500</code> <br> <img src="https://habrastorage.org/files/bf1/0c7/cd5/bf10c7cd5e6542b3b49b4e783795fa5f.jpg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Oscillogram for a delay of 159.23 Œºs</b> <div class="spoiler_text"> <code>root@beaglebone:~# ./Parallel_output 15923</code> <br> <img src="https://habrastorage.org/files/f84/6df/88b/f846df88b07c41d0bea3d8f04968402a.jpg"><br><br>  15923 is just a random number, close to 2 ^ 14, to tap into all the conclusions. <code>hex2dec('3E32') = 15922.</code> <br><br><img src="https://habrastorage.org/files/a67/0b6/8d4/a670b68d4a4949a4bc60514310514a6d.jpg"><br><br><img src="https://habrastorage.org/files/498/016/369/49801636929f4ff493e98dd219c5ea30.jpg"><br></div></div><br><h2>  <font color="#B4A279">Results</font> </h2><br>  Thus, using the above example, the capabilities of the BeagleBone PRU in terms of signal generation with a resolution of up to 5ns on 14 pins simultaneously are demonstrated, the basic principles of PRU control and configuration, as well as the PRU software model are considered. <br><br>  Sources can be found <a href="https://github.com/EgorchikS/BBB-PRU-Tutorial">here</a> . <br><br><h2>  <font color="#B4A279">Useful sources</font> </h2><br>  Much of the examples and principles of work are taken from the materials of Derek Molloy: <br><br><ul><li>  Directly <a href="http://derekmolloy.ie/">his site</a> ; </li><li>  BeagleBone <a href="https://www.youtube.com/playlist%3Flist%3DPLF4A1A7E09E5E260A">playlist</a> ; </li><li>  <a href="http://exploringbeaglebone.com/chapters/">The site of</a> his book on BB with examples; </li><li>  <a href="https://github.com/derekmolloy">Repository</a> ; </li></ul><br>  Thank you so much for all this! <br><br>  ‚Üí <a href="http://www.ofitselfso.com/">An interesting site</a> dedicated to the use of BBB in CNC and not only. <br>  ‚Üí Internet connection on the BBB ( <a href="http://ofitselfso.com/BeagleNotes/HowToConnectBeagleboneBlackToTheInternetViaUSB.php">one</a> , <a href="http://lanceme.blogspot.ru/2013/06/windows-7-internet-sharing-for.html">two</a> and <a href="https://elementztechblog.wordpress.com/2014/12/22/sharing-internet-using-network-over-usb-in-beaglebone-black/">three</a> ). <br>  ‚Üí <a href="https://github.com/beagleboard/bb.org-overlays/">Device tree overlay repository for BB</a> . </div><p>Source: <a href="https://habr.com/ru/post/319338/">https://habr.com/ru/post/319338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319328/index.html">Sevastopol on Baikal and other wonders of nature</a></li>
<li><a href="../319330/index.html">RID Master Recovery Features</a></li>
<li><a href="../319332/index.html">The play "Technical duty"</a></li>
<li><a href="../319334/index.html">What is in my name to you: how to ‚Äúpierce‚Äù a person on the Internet qualitatively?</a></li>
<li><a href="../319336/index.html">FRAM via I2C for Arduino as a replacement for EEPROM</a></li>
<li><a href="../319340/index.html">Get an investment of up to $ 100,000 and launch joint projects with the leaders of the advertising industry</a></li>
<li><a href="../319342/index.html">Higher education and IT - current realities and perspectives, opinions and experience of experts</a></li>
<li><a href="../319344/index.html">Automation of business processes. Ad-hoc changes on the example of life. Part 3</a></li>
<li><a href="../319346/index.html">LexikFormFilterBundle, create filter forms even faster</a></li>
<li><a href="../319348/index.html">Overview of cross-platform solutions for mobile application development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>