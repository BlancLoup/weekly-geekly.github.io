<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regexp and Python: extracting tokens from text</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parsing logs and configuration files is a task that often arises and is repeatedly described. In this article, I will tell you how to implement its cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regexp and Python: extracting tokens from text</h1><div class="post__text post__text-html js-mediator-article"><img src="http://dl.getdropbox.com/u/239055/habr/py_regexp_tokenize_logo.png" align="left" alt="image">  Parsing logs and configuration files is a task that often arises and is repeatedly described.  In this article, I will tell you how to implement its classical solution in python: using regular expressions and named groups.  If possible, I will try to tell the reasons for which this or that solution is applied, as well as to outline the pitfalls and methods of their circumvention. <br><br><a name="habracut"></a><br><h3>  Why parse the text and who the tokens are </h3><br>  In text files of interest to our programs with you, usually there is more than one piece of information.  So that the program can separate one part of the information from another, we set the file formats - that is, an agreement on how the text is written inside the file.  The simplest format is that each piece of information is on a separate line.  Such a file almost does not require additional processing - it is enough to consider it as the means of the programming language used and break it up into lines.  Most languages ‚Äã‚Äãallow you to split a file into lines with one or two commands.  Unfortunately, most of the files that need to be processed have a slightly more complex format.  For example, the classic settings file contains lines of the form name = value.  In the general case, such a format is also fairly easy to parse, reading the file line by line and finding in each line '='.  The one to the left of it will be the name of the field, and the one to the right will be the value.  This logic will work until we need to parse the file with multi-line field values ‚Äã‚Äãand values ‚Äã‚Äãthat contain the symbol "=".  Attempts to process such a file quickly lead to the appearance in the code of numerous checks, loops and other difficulties.  Therefore, for text files that are more complicated in structure than a list of strings, the method of tokening using regular expressions has long been successfully applied.  The word ‚Äútoken‚Äù is usually understood as a small part of the text, located in a certain place of this text and having a certain meaning.  For example, in the following fragment of the configuration file: <br><img src="http://dl.getdropbox.com/u/239055/habr/py_regexp_tokenize_cfg.png"><br>  Three tokens can be distinguished: ‚Äúname‚Äù as the field name, ‚Äú=‚Äù as the separator, and ‚ÄúVasya‚Äù as the field value.  Strictly speaking, what I call tokens in this article more closely matches the definition of lexeme.  The difference between them is that a token is a fragment of text of a certain format without taking into account its position relative to other fragments of text.  Complex parsers, for example, those used in compilers, at the beginning break the text into lexemes and then process the list of lexemes with the help of a large and branched finite automaton, which already selects tokens from the lexemes. <br>  Fortunately, Python has a very good library for working with regular expressions, which allows you to solve most text processing tasks in one pass, without an intermediate search for tokens and their subsequent conversion into tokens. <br><br><h3>  Who are regular expressions? </h3><br>  Regular expressions are such, such ... If at all briefly, then this is a programming language that is designed to search for text.  A very, very simple programming language.  The conditions are practically not applied to it, there are no cycles and functions, there is only one expression that describes what text we want to find.  But this is the only expression that can be very long :).  To successfully use regular expressions in general and on python in particular, you need to know a few things.  First, every self-respecting library for working with regular expressions uses its own syntax for these most regular expressions.  In general, syntax is similar, but the details and additional features can vary greatly - therefore, before using regular expressions in python, you should be familiar with the syntax in the <a href="http://docs.python.org/library/re.html">official documentation</a> . <br>  Secondly, regular expressions do not share the syntax of the language itself and user data.  That is, if we want to find the word "Vasya", then the regular expression for its search will look like that - "Vasya".  In this line, the programming language itself is not present, there is only the string we specify, which is to be searched.  But if we want to find the word ‚ÄúVasya‚Äù, followed by a comma or a semicolon, then the regular expression will acquire the necessary and important details: ‚ÄúVasya, | Vasya;‚Äù.  As we can see, the construction of the ‚Äúlogical or‚Äù language, which is represented by a vertical bar, was added here.  At the same time, the lines we have specified are not separated from the syntax of the language.  This leads to an important and unpleasant consequence - if we want to specify a character in the search string, which is present in the syntax of the language, then we need to write "\" in front of it.  So a regular expression that searches for the word ‚ÄúVasya‚Äù after which there is a dot or a question mark will look like this: ‚ÄúVasya \. | Vasya \?‚Äù.  Both the dot and the question mark are used in the regular expression language syntax: (. <br>  Third, regular expressions are greedy by default.  That is, if you do not specifically specify this, then a string of maximum length will be found that satisfies the regular expression.  For example, if we want to find a line like "name = value" in the text and write a regular expression: ". + =. +", Then for the text "a = b" it will work correctly, returning "a = b".  But for the text ‚Äúa = b, c = d‚Äù it returns ‚Äúa = b, c = d‚Äù - the whole text.  This property of regular expressions must always be remembered and written in such a way that the library will not be tempted to return half of the ‚Äúwar and peace‚Äù as a result of the search.  For example, the previous regular expression is enough to modify a little: "[^ =] + = [^ =] +" - this version will take into account that the text "=" itself should not be in the text before and after the "=" symbol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  We are looking for a token in the text </h3><br>  The python regular expression library is called ‚Äúre‚Äù.  The main function is essentially one ‚Äî search ().  By passing the regular expression as the first argument, the second in which to search for the text, we will get the result of the search at the output.  Please note that for a string with a regular expression, it is better to use the ‚Äúr‚Äù prefix so that the "\" characters are not converted to string escape sequences.  Search example: <br><br><blockquote>  <font color="#ff7700">import</font> <font color="#dc143c">re</font> <br>  match = <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> ur <font color="#483d8b">"Vasya <font color="#000099">\.</font> | Vasya <font color="#000099">\?</font> "</font> , u <font color="#483d8b">"Vasya?"</font> <font>)</font> <br>  <font color="#ff7700">print</font> match.  <font>group</font> <font>(</font> <font>)</font> .  <font>encode</font> <font>(</font> <font color="#483d8b">"cp1251"</font> <font>)</font> </blockquote><br>  As you can see from the example, the search () method returns an object of the type 'search result', which has several methods and fields with which you can get the found text, its position in the original expression and other necessary and useful properties.  Consider a more vital example - a classic configuration file consisting of section names in curly brackets, field names and their values.  The regular expression for searching for section names will look like this: <br><br><blockquote>  <font color="#ff7700">import</font> <font color="#dc143c">re</font> <br>  txt = <font color="#483d8b">"</font> <font color="#483d8b">"</font> <font color="#483d8b"><br></font>  <font color="#483d8b">{number section}</font> <font color="#483d8b"><br></font>  <font color="#483d8b">num = 1</font> <font color="#483d8b"><br></font>  <font color="#483d8b">{text section}</font> <font color="#483d8b"><br></font>  <font color="#483d8b">txt = "2"</font> <font color="#483d8b"><br></font>  <font color="#483d8b">'</font> <font color="#483d8b">' '</font> <br>  match = <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> ur <font color="#483d8b">"{[^}] +}"</font> , txt <font>)</font> <br>  <font color="#ff7700">print</font> match.  <font>group</font> <font>(</font> <font>)</font> <br></blockquote><br>  The result of executing this code will be the string "{number section}" - the section name was successfully found. <br><br><h3>  We are looking for all instances of the token in the text. </h3><br>  As can be seen from the previous example, simply calling re.search () will only find the first token in the text.  The re library offers several methods for finding all instances of a token.  The most correct, in my opinion, is a call to the finditer () method, which returns a list of objects of the type 'search result'.  Obtaining these mysterious objects instead of ordinary lines (which the findall method can return, for example), we get the opportunity not only to familiarize ourselves with the fact that the text is found, but also to find out exactly where it was found - for this object the type of ‚Äúsearch result‚Äù has a trained method span () that returns the exact position of the found fragment in the source text.  The modified code for finding all instances of the token using the finditer () method will look like this: <br><br><blockquote>  result = <font color="#dc143c">re</font> .  <font>finditer</font> <font>(</font> ur <font color="#483d8b">"{[^} <font color="#000099">\ n</font> ] +}"</font> , txt <font>)</font> <br>  <font color="#ff7700">for</font> match <font color="#ff7700">in</font> result: <br>  <font color="#ff7700">print</font> match.  <font>group</font> <font>(</font> <font>)</font> </blockquote><br><h3>  We are looking for different tokens in the text </h3><br>  Unfortunately, the search for a single token is certainly an interesting thing - but almost useless.  Usually in the text, even as simple as a configuration file, there are many tokens of interest to us.  In the configuration file example, this will be at least section names, field names, and field values.  Groups are used to search for several different tokens in the regular expression language.  Groups are fragments of a regular expression, enclosed in parentheses ‚Äî the parts of the text corresponding to these fragments will be returned as separate results.  Thus, a regular expression that can search for sections, fields, and values ‚Äã‚Äãwill look like this: <br><br><blockquote>  result = <font color="#dc143c">re</font> .  <font>finditer</font> <font>(</font> ur <font color="#483d8b">"({[^} <font color="#000099">\ n</font> ] +}) | (?: ([^ = <font color="#000099">\ n</font> ] +) = ([^ <font color="#000099">\ n</font> ] +))"</font> , txt <font>)</font> <br>  <font color="#ff7700">for</font> match <font color="#ff7700">in</font> result: <br>  <font color="#ff7700">print</font> match.  <font>groups</font> <font>(</font> <font>)</font> <br></blockquote><br>  Please note that this code is significantly different from the previous one.  First, in the regular expression there are three groups: "({[^} \ n] +})" corresponds to the title in curly brackets, <br>  "([^ = \ n] +)" before the '=' sign matches the field name and "([^ \ n] +)" after the '=' sign matches the field value.  It also uses the strange group "(? :)", which combines groups of names and field values.  This is a special group for use with the logical operator '|'  - it allows you to combine several groups with one operator '|'  no side effects.  Secondly, the groups () method was used instead of the group () method to print the results.  This is not surprising - the python regular expression library has its own idea of ‚Äã‚Äãwhat a ‚Äúsearch result‚Äù is.  This separateness is expressed in the fact that the regular expression from two groups "([^ = \ n] +) = ([^ = \ n] +)", applied to the test "a = b" returns ONE object of the type "result", which consists of several GROUPS. <br><br><h3>  Determine exactly what we found </h3><br>  If we run the previous example, the following result will be displayed on the screen: <br><br><blockquote>  ('{number section}', None, None) <br>  (None, 'num', '1') <br>  ('{text section}', None, None) <br>  (None, 'txt', '"2"') <br></blockquote><br>  As you can see, for each result, the groups () method returns a magic list of three elements, each of which can be either None (empty) or found text.  If you thoughtfully smoke the documentation, then you can figure out that the library found three groups in our expression and now for each result it lists which groups are present in it.  We see that the first group corresponds to the section name, the second field name and the third field value.  So the first result, "{number section}", is the name of the section.  The second result, ‚Äúnum = 1‚Äù, is the name of the field and the value of the field, and so on.  As we see, it is rather confusing and inconvenient - in the general case it is difficult to determine WHAT IT IS we have found. <br>  To answer this important question the group can be called.  For this purpose, a special syntax is provided in the regular expression language: "(? P &lt;group_name&gt; expression)".  If we slightly change our code and give three groups names, then everything will be much more convenient: <br><br><blockquote>  <font color="#ff7700">import</font> <font color="#dc143c">re</font> <br>  txt = <font color="#483d8b">"</font> <font color="#483d8b">"</font> <font color="#483d8b"><br></font>  <font color="#483d8b">{number section}</font> <font color="#483d8b"><br></font>  <font color="#483d8b">num = 1</font> <font color="#483d8b"><br></font>  <font color="#483d8b">{text section}</font> <font color="#483d8b"><br></font>  <font color="#483d8b">txt = "2"</font> <font color="#483d8b"><br></font>  <font color="#483d8b">'</font> <font color="#483d8b">' '</font> <br>  <font color="#008000">object</font> = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> ur <font color="#483d8b">"(? P &lt;section&gt; {[^} <font color="#000099">\ n</font> ] +}) | (? :(? P &lt;name&gt; [^ = <font color="#000099">\ n</font> ] +) = (? P &lt;value&gt; [^ <font color="#000099">\ n</font> ] +)) "</font> , <font color="#dc143c">re</font> . <font>M</font> | <font color="#dc143c">re</font> . <font>S</font> | <font color="#dc143c">re</font> . <font>U</font> <font>)</font> <br>  result = <font color="#008000">object</font> .  <font>finditer</font> <font>(</font> txt <font>)</font> <br>  group_name_by_index = <font color="#008000">dict</font> <font>(</font> <font>[</font> <font>(</font> v, k <font>)</font> <font color="#ff7700">for</font> k, v <font color="#ff7700">in</font> <font color="#008000">object</font> . <font>groupindex</font> . <font>items</font> <font>(</font> <font>)</font> <font>]</font> <font>)</font> <br>  <font color="#ff7700">print</font> group_name_by_index <br>  <font color="#ff7700">for</font> match <font color="#ff7700">in</font> result: <br>  <font color="#ff7700">for</font> group_index, group <font color="#ff7700">in</font> <font color="#008000">enumerate</font> <font>(</font> match. <font>groups</font> <font>(</font> <font>)</font> <font>)</font> : <br>  <font color="#ff7700">if</font> group: <br>  <font color="#ff7700">print</font> <font color="#483d8b">"text:% s"</font> <font color="#66cc66">%</font> group <br>  <font color="#ff7700">print</font> <font color="#483d8b">"group:% s"</font> <font color="#66cc66">%</font> group_name_by_index <font>[</font> group_index + <font color="#ff4500">1</font> <font>]</font> <br>  <font color="#ff7700">print</font> <font color="#483d8b">"position:% d,% d"</font> <font color="#66cc66">%</font> match.  <font>span</font> <font>(</font> group_index + <font color="#ff4500">1</font> <font>)</font> </blockquote><br>  Pay attention to a number of cosmetic changes.  Before searching, the re.compile () method is used, which returns the so-called ‚Äúcompiled regular expression‚Äù.  In addition to speed and convenience, it has one remarkable property - if you call its groupindex () method, we will get a dictionary containing the names of all found groups and from indexes.  Unfortunately, the dictionary is somehow inverted - the name of the group is not the index in it.  A terrible dict () expression corrects this annoying misunderstanding and the group_name_by_index dictionary can be used to get the name of a group by its number.  Also, when compiling, the flags re.M (correct search for the beginning of the string "^" and the end of the string "$" in the multiline text) are used, re.S ("." Finds absolutely everything, including \ n) and .U (correct search in unicode text).  As a result, the analysis of the found takes two cycles - first we iterate over the search results, and then for each result by the groups it contains.  The result is an accurate and complete list of tokens, indicating their type and position in the text.  This list can be used for text processing, syntax highlighting, finding errors - in general, a necessary and useful thing. <br><br><h3>  Conclusion </h3><br>  The demonstrated way of finding lexemes in the text is not the best or the most correct one - even within the framework of the python language and its standard library of regular expressions, there are at least a dozen alternative ways that are not inferior to this.  But I hope that the examples and explanations given will help someone, if necessary, quickly get up to speed, saving time for googling and finding out why it doesn‚Äôt work quite as we would like.  Good luck to everyone, waiting for comments. <br><br></div><p>Source: <a href="https://habr.com/ru/post/60369/">https://habr.com/ru/post/60369/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../60360/index.html">We program Windows 7: Taskbar. Part 6 - AppId</a></li>
<li><a href="../60362/index.html">About color blindness and color perception modeling</a></li>
<li><a href="../60363/index.html">Basics of digital signal processing for the smallest</a></li>
<li><a href="../60365/index.html">Modern warfare 2</a></li>
<li><a href="../60368/index.html">Disable touchpad scrolling after viewing fullscreen video in Firefox</a></li>
<li><a href="../60370/index.html">Experiment: How it works ... maps.google.com + maps.live.com</a></li>
<li><a href="../60374/index.html">Budgets Salaries. Dollars, euros or local currency (rubles, hryvnia, etc.)</a></li>
<li><a href="../60377/index.html">Mail Server on Zimbra Collaboration Suite</a></li>
<li><a href="../60378/index.html">The answer to business vs the rest</a></li>
<li><a href="../60380/index.html">Data on Last.fm users got into the RIAA. All the same</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>