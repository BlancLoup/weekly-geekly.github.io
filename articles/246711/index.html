<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Named C ++ Parameters. Not useful</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time, it suddenly starts to want named parameters in C ++. Not so long ago there was an article , and some time ago he himself wrote on t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Named C ++ Parameters. Not useful</h1><div class="post__text post__text-html js-mediator-article">  From time to time, it suddenly starts to want named parameters in C ++.  Not so long ago there was <a href="http://habrahabr.ru/company/infopulse/blog/246663/">an article</a> , and some time ago he himself <a href="http://habrahabr.ru/post/213015/">wrote</a> on this topic.  And what is surprising is that since the time of that article I have been participating in a new project without having to drag the old code behind me, and somehow I don‚Äôt use all this described by myself.  Those.  figured out the question, admired the prospects ... and continued to work the old-fashioned way!  How so?  Laziness?  Inertia?  I will try to give the answer under a cat. <br><a name="habracut"></a><br>  To begin, consider an example - the declaration of a function that returns a date object for a given day, month, and year. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> day, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> year, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> month)</span></span></span></span>;</code> </pre> <br>  The problem is obvious - what order of the parameters you do not choose, in a month, after seeing such <br><br><pre> <code class="cpp hljs">Date theDate = createDate(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  will you wonder: ‚ÄúWhat is this?  March 2, 2004, or the fourth of 2002?  If it is particularly lucky, and the team is international, the interpretation of the function by the developers may be completely different.  Identical types go in a row in the parameter list ... In such cases, you usually want named parameters, which in C ++, alas, no. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many programmers have to switch from one programming language to another.  At the same time, something in the new language is like, something is not ... The bad is forgotten over time, but you want to bring good things to the environment where you are working now.  There, in the same Objective-C, there are named parameters! <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> *)colorWithRed:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)red green:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)green blue:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)blue alpha:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)alpha</code> </pre><br>  Yes, the first parameter goes without a name, but its name is often included in the name of the method.  The solution, of course, is not ideal (for example, the colorWithBlue method does not exist, such is the color injustice), but the named parameters are supported at the language level.  VBA is still better - all parameters can be given names, thanks to them it is possible not to produce many similar methods, but to do with one.  For example, look at <a href="http://msdn.microsoft.com/en-us/library/office/ff837331(v%3Doffice.15).aspx">Document.PrintOut</a> <br><br>  And in C ++ there is nothing like that!  Just want to correct the situation, look for libraries, invent crutches and bicycles.  And even something will be and will turn out.  But instead, you can think, if everything is so beautiful, why the named parameters are not added.  So many paradigms are supported, and here it is ... <br><br>  Or maybe added?  Just called differently.  For example, custom types.  It's time to bring the main idea of ‚Äã‚Äãthe article.  <b>Primitive standard types have no place in the interfaces of the real system</b> .  These types are just building blocks from which you need to build, rather than try to live inside. <br><br>  For example, an object of type <b>int</b> is a signed integer lying in a certain range.  What does this type describe?  Only its implementation.  It can not be, for example, the number of apples.  Because apples can not be minus 10. Still worse: <b>unsigned int is</b> also unsuitable for this task.  Because apples have nothing to do with the type of data on your platform.  By binding the primitive types of the language to the parameters of the open methods of our models, we make a mistake, which we then try to ‚Äúhush up‚Äù with various crutches.  And in our desire to hide the mistake, we often ignore the simple fact that the language is trying to help us, saying: "I do not support this directly, and not without purpose ...". <br><br>  But the main disadvantage of primitive types is that the compiler loses the chance to detect a logical error.  For example, we have a method that takes two parameters - a name and a surname.  If we reduce them to standard string types, the compiler will see only two pieces of text, from the permutation of which the meaning will not change.  As a result, one developer will give the first parameter the first name, and the other the last name.  And both will be technically right.  The error is destroyed in the germ if there are special types for the first and last names.  In a real system, where the first and last names are so important entities that enter the interface separately, simply reducing them to strings is an error.  A name is not an arbitrary string.  If only because it is selected from a previously known set.  It also, say, does not contain numbers (although here I am not sure). <br><br>  But back to the dates.  Day is by no means <b>unsigned int</b> , not <b>unsigned char,</b> not even <b>std :: string</b> .  Day is ... day!  If we build a model in which there are dates, then it makes sense to create a special type to represent the days.  User-defined data types are exactly what gives C ++ all its power and expressiveness.  Then the crutches are not needed.  Enter class to represent days <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Day</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Day</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> day)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//... private: unsigned char mValue; };</span></span></code> </pre><br>  Something like that.  Naturally, for the physical representation of a value in memory, we still use the primitive type.  But this is no longer part of the interface.  Immediately we get full control over the contents of this field, eliminating a number of possible errors.  Yes, without knowing the full date, exact limitations cannot be established, but at least a check for getting into the interval of 1..31 can already be organized.  The most important thing is that by implementing special data types for the month and year with explicit constructors for initialization with primitive types, we get the named parameters supported by the language itself.  The function can now be called as follows. <br><br><pre> <code class="cpp hljs">Date theDate = createDate(Day(<span class="hljs-number"><span class="hljs-number">2</span></span>), Month(<span class="hljs-number"><span class="hljs-number">3</span></span>), Year(<span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  No detours, no additional libraries.  Yes, changing the parameters of this approach will not allow, but it is not so important.  The main mission of the named parameters is to eliminate errors when calling functions and improve the readability of the code - is carried out. <br><br>  As a bonus, we obtain increased flexibility if, say, we wanted to set the month also in string form.  Now it is possible not to make the overloadable variant <b>createDate</b> (this is a function of creating a date object, which in general it is up to the month format).  Instead, another explicit month constructor is simply added. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Month</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Month</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> month)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Month</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> month)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//... private: unsigned char mValue; };</span></span></code> </pre><br>  Everyone now does his job - <b>createDate</b> creates a date, and the <b>Month</b> class interprets and controls the correctness of the month value. <br><br><pre> <code class="cpp hljs">Date theDate = createDate(Day(<span class="hljs-number"><span class="hljs-number">2</span></span>), Month(<span class="hljs-string"><span class="hljs-string">"Jan"</span></span>), Year(<span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Immediately I would like to argue - isn‚Äôt there going to be too many extra types if you make your own type-wrapper for every primitive type?  Then how to look.  If you are a student who needs to quickly write a lab, give it up and forget, then yes - a lot of extra code and lost time.  But if we are talking about a real system, in which you are interested in a long and happy life, then I wouldn't call the user types for the entities used in the interface superfluous. <br><br>  But what about custom types?  What, for example, to do if a method accepts several objects of the same type <br><br><pre> <code class="cpp hljs">User user1, user2; <span class="hljs-comment"><span class="hljs-comment">//... someMethod(user1, user2);</span></span></code> </pre><br>  It all depends on the context.  If all objects are equivalent, then there is no problem - nothing changes from the order of their transmission.  To emphasize this, you can only transfer objects packed into an array or another container.  If the objects are unequal, for example, the method subordinates user2 to the object user1, then special types reflecting the role of objects will be quite useful.  It should be wrappers around user objects (as is the case with primitive types) or it is easier to create special classes that inherit from User depends on the system being implemented.  It is important to somehow express the different roles of user1 and user2 by means of the language, allowing the compiler to catch errors related to their possible confusion. <br><br>  What can be concluded.  No need to strive to grab all the best of all languages ‚Äã‚Äãand shove it into one, and without that long-suffering C ++.  It is important to be able to overcome inertia when changing a programming language.  Say yes, in Lua you can assign values ‚Äã‚Äãto several variables at once. <br><br>  x, y = getPosition () <br><br>  The idea itself is beautiful, but is it necessary in C ++.  Generally not needed.  It is easier to create a type of Position and assign a value to its object.  Language is a tool, nothing more.  And from the fact that the tools are sometimes similar, it does not at all follow that you need to use them equally down to the smallest detail. </div><p>Source: <a href="https://habr.com/ru/post/246711/">https://habr.com/ru/post/246711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246699/index.html">Designing a RESTful API with Python and Flask</a></li>
<li><a href="../246701/index.html">The first interview, or Why get a job is more difficult than passing an exam</a></li>
<li><a href="../246703/index.html">Development of Magento modules with application deployment through Magento Composer</a></li>
<li><a href="../246707/index.html">Parsing formulas with functions</a></li>
<li><a href="../246709/index.html">How to disable updates in Skype and advertising at the same time</a></li>
<li><a href="../246713/index.html">Registration of offshore company in Belize</a></li>
<li><a href="../246717/index.html">Christmas tales engineer post</a></li>
<li><a href="../246719/index.html">InterSystems iKnow. We load data from VKontakte</a></li>
<li><a href="../246721/index.html">DriverPack on the threshold of 2015: statistics</a></li>
<li><a href="../246723/index.html">Rzborda, or How to Make an Internet-Controlled Typewriter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>