<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write Policy server on C ++ for Unity3d</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why do I need a policy server? 
 In Unity , starting with version 3.0, for assemblies for the Web player security mechanisms are used, similar to thos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write Policy server on C ++ for Unity3d</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/097/bd0/3d2/097bd03d2c29483a9ad565c09a9c9189.png"><br><a name="habracut"></a><br><h2>  Why do I need a policy server? </h2><br>  In <a href="http://unity3d.com/ru/">Unity</a> , starting with version 3.0, for assemblies for the Web player security mechanisms are used, similar to those used by Adobe in the Flash player.  Its essence lies in the fact that when accessing the server, the client asks him for "permission", and if the server does not "allow", the client will not try to connect to it.  These restrictions work to access remote servers through the <a href="http://docs.unity3d.com/ScriptReference/WWW.html">WWW</a> class and using sockets.  If you want to make any request on the rest protocol from your client to a remote server, it is necessary that a special xml be in the root of the domain.  It should be called crossdomain.xml and have the following format: <br><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  The client will download the security policy file before the request, check it and, seeing that all domains are allowed, will continue to fulfill the request you have made. <br><br>  If you need to connect to a remote server using sockets (tcp / udp), before connecting, the client will make a request to the server for port 843 to get a security policy file describing which ports and from which domains you can connect: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to-ports</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1200-1220"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span>"</code> </pre><br>  If the client data does not satisfy all parameters (domain, port), then the client will generate a SecurityException exception and will not attempt to connect to the server. <br><br>  This article will focus on writing a server that will give security policy files, in the future I will call it Policy server. <br><br><h2>  How should a policy server work? </h2><br>  The server operation is simple: <br><br><ol><li>  The server starts and listens to port 843 via the tcp protocol.  It is possible to override the <a href="http://docs.unity3d.com/ScriptReference/Security.PrefetchSocketPolicy.html">Security.PrefetchSocketPolicy ()</a> port </li><li>  The client connects to the server using the tcp protocol and sends xml with a request for the security policy file: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">policy-file-request</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre></li><li>  The server parses the request and sends the xml client with the security policy </li></ol><br>  In practice, the process of parsing the request does not make any sense.  The value is the time that the client waits before receiving the security policy file, since it increases the delay before connecting to the target port.  We can modify the server operation process and give the client a security policy file immediately after connection. <br><br><h2>  What is already there? </h2><br>  At the moment there is a server written in a bunch of Java + <a href="http://netty.io/">Netty</a> , the <a href="https://github.com/helper2424/unity_policy_server">source code with the instruction and jar</a> .  One of its key drawbacks is dependence on jre.  In general, deploying a jre on a linux server is not a problem, but often game developers are client programmers who want to make as few gestures as possible, all the more they don‚Äôt want to install jre and later administer it.  Therefore, it was decided to write a policy server in C ++, which would work as a native application on a linux machine. <br><br>  Written in C ++, the policy server should not be inferior in performance to the old, ideally should show the result much better.  The key performance metrics will be: the time that the client spends waiting for the security policy file, and the number of clients that can receive security policy files at the same time, which, in fact, also comes down to the timeout for the policy file. <br><br>  For testing, I used this <a href="">script</a> .  It works as follows: <br><br><ol><li>  Clears the average ping to the server </li><li>  Runs several threads (the number is specified in the script) </li><li>  In each thread, requests the policy server's security policy file. </li><li>  If the policy file matches the one expected, then each request is time spent waiting </li><li>  Prints the results to the console.  We are interested in the following values: minimum wait time, maximum wait time, average wait time and the same parameters without ping </li></ol><br>  The script is written in ruby, but since the <a href="https://en.wikipedia.org/wiki/Ruby_MRI">standard ruby ‚Äã‚Äãinterpreter</a> lacks support for operating system-level threads, I used <a href="http://jruby.org/">jruby</a> for work.  The most convenient way to use <a href="https://rvm.io/">rvm</a> , the command to run the script will look like this: <br><br><pre> <code class="bash hljs">rvm jruby <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ruby test.rb</code> </pre><br>  The results of testing Policy server'a written in Java + <a href="http://netty.io/">Netty</a> : <br><table><tbody><tr><th>  Average, ms </th><td>  245 </td></tr><tr><th>  Min, ms </th><td>  116 </td></tr><tr><th>  Maximum, ms </th><td>  693 </td></tr></tbody></table><br><h2>  What is needed? </h2><br>  In essence, the task is to write a daemon on C ++ that could listen to several ports, create a socket when clients connect, copy text information to the socket and close it.  It is desirable to have as few dependencies as possible, and if they do, they should be in the repositories of the most common linux distributions.  For writing code, we will use the c ++ 11 standard.  As a minimum set of libraries, take: <br><br><ul><li>  <a href="http://software.schmorp.de/pkg/libev.html">libev</a> for working with the application event cycle </li><li>  <a href="http://www.boost.org/doc/libs/1_59_0/doc/html/program_options.html">boost program_options</a> for working with command line parameters </li><li>  <a href="https://github.com/easylogging/easyloggingpp">Easylogging ++</a> for working with logs </li></ul><br><h2>  One port - one stream </h2><br>  The structure of the application is quite simple: you will need functionality for working with command line parameters, classes for working with streams, functionality for working with networks, functionality for working with logs.  These are simple things that should not be a problem, so I will not dwell on them in detail.  Code can be found <a href="https://github.com/helper2424/unity_policy_server_native">here</a> .  Problem is the organization of processing client requests.  The simplest solution is to connect all the data after connecting a client socket and close the socket immediately.  Those.  The code responsible for handling the new connection will look like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Connector::connnect(ev::io&amp; connect_event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(client_addr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> client_sd; client_sd = accept(connect_event.fd, (struct sockaddr *)&amp;client_addr, &amp;client_len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(client_sd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;server-&gt;get_text()-&gt;c_str(); send(client_sd, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)data, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(data), <span class="hljs-number"><span class="hljs-number">0</span></span>); shutdown(client_sd, <span class="hljs-number"><span class="hljs-number">2</span></span>); close(client_sd); }</code> </pre><br>  When I tried to test on a large number of threads (300, 10 connections per each), I could not wait for the end of the test script.  From which we can conclude that this solution does not suit us. <br><br><h2>  Async </h2><br>  The operation of data transmission over the network is time-consuming, it is obvious that it is necessary to separate the process of creating a client socket and the process of sending data.  It would also be nice to give the data in several threads.  A good solution is to use <a href="http://en.cppreference.com/w/cpp/thread/async">std :: async</a> , which appeared in the C ++ 11 async standard.  The code responsible for handling the new connection will look like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Connector::connnect(ev::io&amp; connect_event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(client_addr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> client_sd; client_sd = accept(connect_event.fd, (struct sockaddr *)&amp;client_addr, &amp;client_len); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::async(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::launch::async, [client_addr, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> client_socket) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * data = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;server-&gt;get_text()-&gt;c_str(); send(client_socket, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)data, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(data), <span class="hljs-number"><span class="hljs-number">0</span></span>); shutdown(client_socket, <span class="hljs-number"><span class="hljs-number">2</span></span>); close(client_socket); }, client_sd); }</code> </pre><br>  The disadvantage of this solution is the lack of control resources.  By minimal intervention in the code, we are able to asynchronously perform sending data to the client, and we cannot control the process of generating new threads.  The process of creating a new thread is expensive for the operating system, and a large number of threads can slow down server performance. <br><br><h2>  Pub / Sub </h2><br>  A suitable solution for this problem is the publisher-subscriber pattern.  The scheme of the server should look like this: <ul><li>  Several publishers, one for each port, save in the buffer the identifiers of the clients' sockets to which the security policy file should be given. </li><li>  Several subscribers receive buffer identifiers from the buffer, copy the security policy file into them, and close the socket. </li></ul><br>  The queue is suitable as a buffer, it is the first to connect to the server - the first is the policy file.  In the standard C ++ library there is a ready-made queue container, but it will not work for us, since a thread-safe queue is required.  At the same time, we need the operation of adding a new element to be non-blocking, while the reading operation was blocking.  Ie at the start of the server several subscribers will be started, who will wait while the queue is empty.  As soon as data appears there, one or several processors are triggered.  Publishers, however, asynchronously write socket identifiers to a given queue. <br><br>  A little googling, I found some ready-made implementations: <br><ol><li>  <a href="https://github.com/cameron314/concurrentqueue">https://github.com/cameron314/concurrentqueue</a> . <br>  In this case, we are interested in <a href="">blockingconcurrentqueue</a> , which is simply copied into the project as a header .h file.  Conveniently enough, and there are no dependencies.  This solution has the following disadvantages: <br><ul><li>  There are no methods for stopping subscribers.  The only way to stop them is to add data to the queue, which will signal to subscribers that they need to stop work.  This is quite inconvenient and could potentially cause deadlock. <br></li><li>  It is supported by one person, commits lately appear quite rarely. </li></ul><br></li><li>  <a href="https://www.threadingbuildingblocks.org/docs/help/reference/containers_overview/concurrent_queue_cls.htm">tbb concurrent queue</a> . <br>  Multi-threaded queue from the library <a href="https://www.threadingbuildingblocks.org/">tbb</a> (Threading Building Blocks).  The library is developed and maintained by Intel, and it has everything we need: <br><ul><li>  Block read from queue </li><li>  Non-blocking write to the queue </li><li>  The ability to stop threads waiting for data at any time </li></ul><br>  Among the minuses it can be noted that this solution increases the number of dependencies, i.e.  end users will have to install tbb on their server.  In the most common linux repositories, tbb can be installed via the operating system's package manager, so there should be no dependency problems. <br></li></ol><br>  Thus, the code for creating a new connection will look like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Connector::connnect(ev::io&amp; connect_event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(client_addr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> client_sd; client_sd = accept(connect_event.fd, (struct sockaddr *)&amp;client_addr, &amp;client_len); clients_queue()-&gt;push(client_sd); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;handled_clients++; }</code> </pre><br>  Client socket processing code: <br><br><pre> <code class="hljs kotlin">void Handler::run() { LOG(INFO) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Handler with thread id "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;thread.get_id() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" started"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;is_run) { int socket_fd = clients_queue()-&gt;pop(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;handle(socket_fd); } LOG(INFO) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Handler with thread id "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;thread.get_id() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" stopped"</span></span>; }</code> </pre><br>  Queue code: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClientsQueue::push(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> client) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.try_push(client)) LOG(WARNING) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Can't push socket "</span></span> &lt;&lt; client &lt;&lt; <span class="hljs-string"><span class="hljs-string">" to queue"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ClientsQueue::pop() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.pop(result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) { result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClientsQueue::stop() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }</code> </pre><br>  The code for the entire project with installation instructions can be found <a href="https://github.com/helper2424/unity_policy_server_native">here</a> .  The result of the test run with ten threads handlers: <br><table><tbody><tr><th>  Average, ms </th><td>  151 </td></tr><tr><th>  Min, ms </th><td>  100 </td></tr><tr><th>  Maximum, ms </th><td>  1322 </td></tr></tbody></table><br><h2>  Total </h2><br>  Comparison results table <br><table><tbody><tr><th></th><th>  Java + Netty </th><th>  C ++ Pub / Sub </th></tr><tr><th>  Average, ms </th><td>  245 </td><td>  151 </td></tr><tr><th>  Min, ms </th><td>  116 </td><td>  100 </td></tr><tr><th>  Maximum, ms </th><td>  693 </td><td>  1322 </td></tr></tbody></table><br><anchor>  Links </anchor>  : <br><ul><li>  <a href="https://github.com/helper2424/unity_policy_server">Old version of Policy server'a on java</a> </li><li>  <a href="https://github.com/helper2424/unity_policy_server_native">New version of policy server'a in C ++</a> </li></ul><br>  PS: Currently, the Unity Web player is experiencing hard times due to the closure of npapi in the top browsers.  But if anyone else uses it and keeps the server on linux machines, then you can use this server, I hope it will be useful to you.  <a href="https://vk.com/themoonisalwaysspyingonyourfears">Special</a> thanks to <a href="https://vk.com/themoonisalwaysspyingonyourfears">themoonisalwaysspyingonyourfears</a> for the illustration of the article. </div><p>Source: <a href="https://habr.com/ru/post/268091/">https://habr.com/ru/post/268091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268077/index.html">Project Fi - what can its subscribers get?</a></li>
<li><a href="../268079/index.html">Playgrounds for browser games</a></li>
<li><a href="../268081/index.html">Diagnosing the behavior of "cumulative" (rollup) fields in Microsoft Dynamics CRM 2015</a></li>
<li><a href="../268087/index.html">Critical vulnerabilities discovered in TrueCrypt cryptograph</a></li>
<li><a href="../268089/index.html">It's time. Upgrade to Oracle Database 12</a></li>
<li><a href="../268093/index.html">Unbearable server burden: to the issue of transition to the IaaS model</a></li>
<li><a href="../268095/index.html">Two types of applications for Bitrix24</a></li>
<li><a href="../268097/index.html">Meet HP IT Outsourcing</a></li>
<li><a href="../268101/index.html">New vulnerabilities discovered in Android</a></li>
<li><a href="../268103/index.html">A little about the development of technology and the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>