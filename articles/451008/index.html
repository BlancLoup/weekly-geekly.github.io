<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>End2End-approach to speaking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are several approaches to understanding the conversational machine: a classic three-component approach (includes a speech recognition component,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>End2End-approach to speaking</h1><div class="post__text post__text-html js-mediator-article">  <i>There are several approaches to understanding the conversational machine: a classic three-component approach (includes a speech recognition component, a component of natural language understanding, and a component responsible for some business logic) and an End2End approach, which involves four implementation models: direct, collaborative, multi-step, and multi-tasking .</i>  <i>Consider all the pros and cons of these approaches, including those based on Google‚Äôs experiments, and analyze in detail why the End2End approach solves the problems of the classical approach.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/4f/zx/o3/4fzxo3p37pnl9kprkwk1trmwxd4.png"><a name="habracut"></a><br><br>  We give the floor to Nikita Semenov, the leading developer of the AI ‚Äã‚ÄãMTS center. <br><br>  Hello!  As a preface, I want to quote the well-known scientists Jan Lekun, Yoshua Bengio and Jeffrey Hinton - these are the three pioneers of artificial intelligence who have recently received one of the most prestigious awards in the field of information technology - the Turing Prize.  In one of the issues of the journal Nature in 2015, they released a very interesting article ‚ÄúDeep learning‚Äù, in which was an interesting phrase: ‚ÄúDeep learning‚Äù.  It is difficult to translate correctly, but the meaning is something like this: ‚ÄúDeep learning has come with the promise of being able to cope with raw signals without the need to manually create signs.‚Äù  In my opinion, for developers it is the main motivator from all existing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Classic approach </h4><br>  So let's start with the classic approach.  When we talk about understanding conversational machine, we mean that we have a certain person who wants to control some services with the help of his voice or has a need for some system to respond to his voice commands with some logic. <br><br>  How is this problem solved?  In the classic version, a system is used, which, as mentioned above, consists of three major components: a speech recognition component, a component of natural language understanding, and a component responsible for some business logic.  It is clear that at the beginning the user creates a certain sound signal, which hits the speech recognition component and turns from sound into text.  Then the text falls into the component of understanding a natural language, from which a certain semantic structure is pulled out, which is necessary for the component responsible for business logic. <br><br><img src="https://habrastorage.org/webt/sl/s9/a1/sls9a1uzwmia7h523tecvgssiec.png"><br><br>  What is the semantic structure?  This is a kind of generalization / aggregation of several tasks into one - for ease of understanding.  The structure includes three important parts: the classification of the domain (some definition of the subject), the classification of the intent (understanding and what actually needs to be done) and the allocation of named entities to fill in the cards, which are necessary for specific business tasks in the next step.  To understand what a semantic structure is, you can consider a simple example, which is most often given by Google.  We have a simple request: ‚ÄúPlease play some song of an artist‚Äù. <br><br><img src="https://habrastorage.org/webt/nf/an/6l/nfan6l3vzzjsl_r4iq9_3x491rk.png"><br><br>  The domain and subject matter in this query is music;  intent - play a song;  ‚Äúplay a song‚Äù card attributes - what a song, what an artist.  Such a structure is the result of understanding natural language. <br><br>  If we talk about solving a complex and multi-stage task of speaking, then it, as I said, consists of two stages: the first is speech recognition, the second is the understanding of natural language.  The classical approach implies a complete separation of these stages.  As a first step, we have a certain model that receives an acoustic signal at the input, and the output, using language and acoustic models and the lexicon, determines the most likely verbal hypothesis from this acoustic signal.  This is a completely probabilistic history - you can decompose it using the well-known Bayes formula and get a formula that allows you to write the sample likelihood function and use the maximum likelihood method.  We have a conditional probability of the signal X, provided that the word sequence W is multiplied by the probability of this word sequence. <br><br><img src="https://habrastorage.org/webt/u0/pz/y8/u0pzy8cvkx_texgnjfzun-keavu.png"><br><br>  We have passed the first stage - we have received a certain verbal hypothesis from the sound signal.  Next comes the second component, which takes this very verbal hypothesis and tries to pull out of it the semantic structure described by us above. <br><br>  We have the probability of semantic structure S under the condition of the word sequence W at the input. <br><br><img src="https://habrastorage.org/webt/yi/34/tx/yi34txzqvgevrvoauj4stho32im.png"><br><br>  What is so bad about the classical approach consisting of these two elements / steps that are taught separately (i.e., we first train the model of the first element and then the model of the second)? <br><br><ul><li>  The natural language understanding component works with the high-level verbal hypotheses that ASR generates.  This is a big problem because the first component (the ASR itself) works with low-level raw data and generates a high-level verbal hypothesis, and the second component takes the hypothesis as input - not the raw data from the original source, but the hypothesis that the first model gives - and builds its hypothesis above the hypothesis of the first stage.  This is a rather problematic story, because it becomes too ‚Äúconditional.‚Äù </li><li>  The next problem: we can‚Äôt build a link between the importance of the words that are needed to build the very semantic structure and the one that is preferred by the first component when building our verbal hypothesis.  That is, if we rephrase, it turns out that the hypothesis is already constructed.  It is built on the basis of three components, as I have already said: the acoustic part (what came to the input and is somehow modeled), the language part (completely simulates some language engrams - the probability of speech) and the lexicon (pronunciation of words).  These are three big parts that need to be combined and to find some hypothesis in them.  But there is no possibility to influence the choice of the very hypothesis so that this hypothesis is important to the next stage (which is basically in the clause that they are trained completely separately and in no way influence each other). </li></ul><br><h4>  End2End approach </h4><br>  We understood what a classic approach is, what problems it has.  Let's try to solve these problems with the help of the End2End approach. <br><br>  By End2End we mean a model that connects the various components into a single component.  We will simulate using models that consist of the architecture of an encoder-decoder containing attention modules.  Such architectures are often used in speech recognition tasks and in tasks related to the processing of natural language, in particular, machine translation. <br><br>  There are four options for implementing such approaches, which could solve the problem of the classical approach set before us: these are direct, cooperative, multistage, and multitasking models. <br><br><h4>  Direct model </h4><br>  The direct model takes low-level, raw signs as input.  low-level audio signal, and at the output we immediately get a semantic structure.  That is, we have one module - the input of the first module from the classical approach and the output of the second module from the same classical approach.  Just such a ‚Äúblack box‚Äù.  From here there are some pluses and some minuses.  The model does not learn to completely transcribe the input signal - this is an obvious plus, because we do not need to collect large-large markup, we do not need to collect a lot of audio signal, and then give it to assessors on the markup.  We only need this audio signal and the corresponding semantic structure.  And that's all.  This greatly reduces the labor costs for marking data.  Probably the biggest disadvantage of this approach is that the task is too complicated for such a ‚Äúblack box‚Äù, which tries to solve, conditionally, two problems at once.  First, he tries to build a certain transcription inside himself, and then from this transcription to reveal the very semantic structure.  Here comes the rather difficult task - to learn how to ignore parts of the transcription.  And it is very difficult.  This factor is quite large and a huge disadvantage of this approach. <br><br>  If we talk about probabilities, then this model solves the problem of finding the most likely semantic structure S from an acoustic signal X with model parameters Œ∏. <br><br><img src="https://habrastorage.org/webt/34/kl/m2/34klm26dj3vk5sd9kdcxckkenii.png"><br><br><h4>  Joint model </h4><br>  What is the alternative?  This is a joint model.  That is, some model is very similar to the straight line, but with one exception: the output here already consists of verbal sequences and the semantic structure is simply concatenated to them.  That is, we have a sound signal at the input and a neural network model, which at the output already gives both a verbal transcription and a semantic structure. <br><br><img src="https://habrastorage.org/webt/jz/kn/-f/jzkn-frploycnewpluip2kgoqb8.png"><br><br>  From the pros: we have a simple encoder, a simple decoder.  Learning is facilitated because the model does not attempt to solve two problems at once, as in the case of the direct model.  Another advantage can be noted that this dependence of the semantic structure on low-level sound features is still present.  Because again, one encoder, one decoder.  And, accordingly, one of the advantages can be noted that there is a dependency in the prediction of this very semantic structure and its influence directly on the transcription itself - which did not suit us in the classical approach. <br><br>  Again, we need to find the most likely sequence of words W and the corresponding semantic structures S from the acoustic signal X with parameters Œ∏. <br><br><h4>  Multitasking model </h4><br>  The next approach is a multitasking model.  Again, the encoder-decoder approach, but with one exception. <br><br><img src="https://habrastorage.org/webt/ym/kz/l3/ymkzl3t_nh892ohttlu84sjg98i.png"><br><br>  For each task, that is, to create a word sequence, to create a semantic structure, we have our own decoder, using one common hidden representation that generates a single encoder.  A very famous machine learning trick, very often used in works.  Solving two different problems at once helps to much better look for dependencies in the source data.  And as a consequence of this - the best generalizing ability, since the optimal parameter is chosen for several tasks at once.  This approach is best suited for tasks with less data.  And decoders use one hidden vector space into which their encoder creates. <br><br><img src="https://habrastorage.org/webt/8l/-q/pj/8l-qpjo3dccdzmqh5a-fspmveiq.png"><br><br>  It is important to note that already in probability there appears a dependence on the parameters of the encoder and decoder models.  And these parameters are important. <br><br><h4>  Multistage model </h4><br>  Let's move, in my opinion, to the most interesting approach: a multi-stage model.  If you look very closely, you can see that this is actually the same two-component classical approach with one exception. <br><br><img src="https://habrastorage.org/webt/fr/az/np/fraznpocvjmklcjjmau4i9v9ago.png"><br><br>  Here it is possible to establish a connection between the modules and make them single-module.  Therefore, the semantic structure is considered conditionally dependent on transcription.  There are two options for working with this model.  We can train separately these two mini-blocks: the first and second encoder-decoder.  Or combine them and train both tasks at the same time. <br><br>  In the first case, the parameters for the two tasks are not related (we can train using different data).  Suppose we have a large corpus of sound and corresponding verbal sequences and transcriptions.  We ‚Äúdrive‚Äù them, train only the first part.  We get in good transcription modeling.  Then we take the second part, we train on another case.  We connect and get a solution that in this approach is 100% consistent with the classical approach, because we took the first part separately and trained the first part and the second part separately.  And then we train the connected model on the corpus, which already contains data triads: the audio signal, the corresponding transcription and the corresponding semantic structure.  If we have such a corpus, we can retouch the model trained separately on large enclosures for our specific small task and get the maximum accuracy gain in this tricky way.  This approach allows us to take into account the importance of different parts of transcription and their impact on the prediction of the semantic structure by <i>taking into account the error of the</i> second stage in the first. <br><br>  It is important to note that the final task is very similar to the classical approach with one big difference: the second member of our function, the logarithm of the probability of the semantic structure, subject to the input acoustic signal X, also depends on the parameters of the <i>model of the first stage</i> . <br><br><img src="https://habrastorage.org/webt/pa/24/xr/pa24xr-aaep-mqo7bzd3loksve4.png"><br><br>  It is also important to note here that the second component depends on the parameters of the first and second models. <br><br><h4>  Method of assessing the accuracy of approaches </h4><br>  Now it is necessary to determine the methodology for assessing accuracy.  How, in fact, to measure this accuracy in order to take into account features that do not suit us in the classical approach?  There are classic labels for these separate tasks.  To evaluate speech recognition components, we can take the classic WER metric.  This is Word Error Rate.  According to a not very complicated formula, we count the number of inserts, replacements, and permutations of a word and divide them by the number of all words.  And we get some evaluation characteristic of the quality of our recognition.  For the semantic structure componentwise, we can simply read the F1 score.  This is also a kind of classical metric for the classification problem.  It's all plus or minus clear.  There is completeness, there is accuracy.  And this is just the harmonic mean between them. <br><br>  But the question arises how to measure accuracy when the input transcription and the output argument do not match or when the output is audio data.  Google has proposed a metric that will take into account the importance of predicting the first speech recognition component by assessing the effect of this recognition on the second component itself.  They called it Arg WER, that is, it is the weighting of WER by the entities of the semantic structure. <br><br>  Take the query: "Set the alarm for 5 hours."  This semantic structure contains an argument such as "five o'clock", an argument of the type "date time".  It is important to understand that if the speech recognition component produces this argument, then the error metric of this argument, that is, WER, is 0%.  If this value does not correspond to five hours, then the metric has 100% WER.  Thus, we simply consider the weighted average value for all arguments and, in general, we obtain an aggregated metric that evaluates the importance of transcription errors, which create a speech recognition component. <br><br>  I will cite as an example the experiments of Google, which she conducted in one of her studies on this topic.  They used data from five domains, five topics: Media, Media_Control, Productivity, Delight, None - with the corresponding distribution of data on training test data sets.  It is important to note that all models were trained from scratch.  The cross_entropy was used, the beam search parameter was equal to 8, they used the optimizer, of course, Adam.  They considered, of course, on a large cloud of their TPU.  What was the result?  These are interesting figures: <br><br><img src="https://habrastorage.org/webt/cj/bb/of/cjbbofaddfuhufwqk3brhr2-l04.png"><br><br>  To understand, Baseline is a classic approach, which consists of two components, as we said at the very beginning.  The following are examples of direct, coupled, multi-tasking, and multistage models. <br><br>  How much are two multistage models?  Just at the junction of the first and second parts used different layers.  In the first case - this is ArgMax, in the second case - SampedSoftmax. <br><br>  What you should pay attention to?  The classical approach loses on all three metrics, which are an estimate directly of the joint work of these two components.  Yes, we are not interested in how well the transcription is done there, we are only interested in how well the element that predicts the semantic structure works.  It is evaluated by three metrics: F1 - by subject, F1 - by intent and by ArgWer metric, which is considered according to the arguments of the entities.  F1 is considered a weighted average between accuracy and completeness.  That is, the standard is 100. ArgWer - on the contrary, it is not a success, it is a fallacy, that is, here the standard is 0. <br><br>  It is worth noting that our connected and multi-tasking models completely benefit all models of the classification of topics and intents.  A model that is multistage, has a very large increase in the final ArgWer.  Why is it important?  Because in tasks related to understanding conversational speech, it is important that the final action be performed in the component responsible for the business logic.  It does not directly depend on the transcriptions created by ASR, but on the quality of the work of the components of the ASR and NLU together.  Therefore, the difference in almost three points of the argWER metric is a very steep indicator that indicates the success of this approach.  It is also worth noting that all approaches have comparable meanings for defining topics and intents. <br><br>  I will give a couple of examples of the use of such algorithms for understanding conversational speech.  Google, when talking about the tasks of understanding conversational speech, first of all notes the human-computer interfaces, that is, these are all sorts of virtual assistants like Google Assistant, Apple Siri, Amazon Alexa and so on.  As a second example, it is worth noting such a task pool as Interactive Voice Response.  That is, it is a kind of story that automates call-centers. <br><br>  So, we looked at approaches with the ability to use collaborative optimization, which helps the model focus on errors that are more significant to the SLU.  Such an approach to the task of understanding a spoken language greatly simplifies the overall complexity. <br><br>  We have the opportunity to perform a logical inference, that is, to obtain some kind of result, without the need for additional resources such as the lexicon, language models, analyzers, and so on (that is, all these factors that are inherent in the classical approach).  The problem is solved "directly." <br><br>  In fact, you can not stop there.  And if now we have combined two approaches, two components of a common structure, then it is possible to aim a blow at more.  Combine both three components and four - just continue to combine this logical chain and ‚Äúdrag‚Äù the importance of errors one level lower, given the criticality there already.  This will allow us to increase the accuracy of solving the problem. </div><p>Source: <a href="https://habr.com/ru/post/451008/">https://habr.com/ru/post/451008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450996/index.html">Framework Game: JavaScript Trends in 2019</a></li>
<li><a href="../451/index.html">Runner opens contextual advertising school</a></li>
<li><a href="../4510/index.html">Head of Sun Microsystems fights for blogosphere rights</a></li>
<li><a href="../451002/index.html">Building a custom computer, part 1</a></li>
<li><a href="../451004/index.html">Technosphere. Course of lectures "Management of IT-projects and product"</a></li>
<li><a href="../451012/index.html">Random permutations and random partitions</a></li>
<li><a href="../45102/index.html">One billion downloads addons</a></li>
<li><a href="../45103/index.html">Photosynty and panorama of Yekaterinburg</a></li>
<li><a href="../451032/index.html">We write HTTP / 1.1 & HTTP / 2 client and server on Golang</a></li>
<li><a href="../45104/index.html">my.opera.com loves Habrahabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>