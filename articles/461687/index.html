<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker + Laravel + RoadRunner = ‚ù§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is written at the request of workers who periodically ask about "How to run the Illuminate / Symfony / MyOwn Psr7 application in the docker....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker + Laravel + RoadRunner = ‚ù§</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/zm/nm/pr/zmnmprsvbuxifiuo2dcdb6z1vle.png" alt="picture"></p><br><p>  This post is written at the request of workers who periodically ask about "How to run the Illuminate / Symfony / MyOwn <a href="https://www.php-fig.org/psr/psr-7/">Psr7</a> application in the docker."  I don‚Äôt feel like giving a link to a <a href="https://habr.com/ru/post/425101/">previously written post</a> , because my views on how to solve the problem have changed quite a lot. </p><br><p>  Everything that will be written below is a subjective experience, which <em>(as always)</em> does not claim to be considered the only right decision, but some approaches and solutions may seem interesting and useful to you. </p><br><blockquote>  As an application, I will also use Laravel, since it is most familiar to me and quite widespread.  Adapting to other <a href="https://www.php-fig.org/psr/psr-7/">PSR-7</a> -based frameworks / components is possible, but this story is not about that. </blockquote><a name="habracut"></a><br><h2 id="rabota-nad-oshibkami">  Error handling </h2><br><p>  I would like to start with what turned out to be "not the best practices" in the context of the <a href="https://habr.com/ru/post/425101/">previous article</a> : </p><br><ul><li>  The need to change the structure of files in the repository </li><li>  Using FPM.  If we want performance from our applications, then perhaps one of the best solutions even at the stage of technology selection will be to abandon it in favor of something faster and ‚Äúadapted‚Äù to the fact that memory may leak.  RoadRunner <sup><em>by <a href="https://habr.com/ru/users/lachezis/" class="user_link">lachezis is</a></em></sup> here as never before </li><li>  A separate image with source and assets.  Despite the fact that using this approach, we can reuse the same image to build a more complex routing of incoming requests (nginx at the front to return static; requests for dynamics are served by another container into which volume is thrown with the same sources - for better scaling) - this scheme has proved to be rather complicated in product operation.  And what's more, RR itself perfectly renders statics, and if there are a lot of statics <em>(or the resource can load and display user-generated content)</em> - we take it out to CDN (the S3 + CloudFront + CloudFlare bundle works fine) and forget about this problem in principle </li><li>  Complex CI.  This became a real problem when the period of active "building meat" began at the stages of assembly and automatic testing.  A dude who did not support this CI before, it becomes very difficult to make changes to it without fear of breaking anything. </li></ul><br><p> Now, knowing what problems need to be fixed and with an understanding of how to do this, I propose proceeding with their elimination.  The set of "developer tools" has not changed - it's all the same <code>docker-ce</code> , <code>docker-compose</code> and the powerful <code>Makefile</code> . </p><br><p>  As a <strong>result,</strong> we get: </p><br><ul><li>  A standalone container with an application without the need to mount additional volume </li><li>  An example of using git-hooks - we will put the necessary dependencies after <code>git pull</code> automatically and prohibit pushing the code if the tests fail (hooks will be stored under the git, of course) </li><li>  RoadRunner will handle HTTP (s) requests </li><li>  Developers will still be able to execute <code>dd(..)</code> and <code>dump(..)</code> for debugging, and nothing will crash in their browser </li><li>  Tests can be run directly from the PHPStorm IDE, while they will be run in the container with the application </li><li>  CI will collect images for us when publishing a new application version tag </li><li>  Let us take the strict rule of maintaining the files <code>CHANGELOG.md</code> and <code>ENVIRONMENT.md</code> </li></ul><br><h2 id="naglyadnoe-vnedrenie-novogo-podhoda">  Visual introduction of a new approach </h2><br><p>  For a visual demonstration, I will break the whole process into several stages, the changes within which will be made out as separate MRs (after the merger, all brunches will remain in their places; references to MR in the headings of the ‚Äústeps‚Äù).  The starting point is the Laravel skeleton of an application created using <code>composer create-project latavel/laravel</code> : </p><br><pre> <code class="bash hljs">$ docker run \ --rm -i \ -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(pwd)</span></span></span><span class="hljs-string">:/src"</span></span> \ -u <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -u)</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -g)</span></span></span><span class="hljs-string">"</span></span> \ composer composer create-project --prefer-dist laravel/laravel \ /src/laravel-in-docker-with-rr <span class="hljs-string"><span class="hljs-string">"5.8.*"</span></span></code> </pre> <br><h1 id="shag-1---dokerizaciya--rrhttpsgitlabcomtarampampamlaravel-in-docker-with-rrmerge_requests1diffs">  Step 1 - <a href="https://gitlab.com/tarampampam/laravel-in-docker-with-rr/merge_requests/1/diffs">Docking + RR</a> </h1><br><p>  First of all, you need to teach the application to run in the container.  To do this, we need a <code>Dockerfile</code> , <code>docker-compose.yml</code> for a description of ‚Äúhow to lift and link containers‚Äù, and a <code>Makefile</code> in order to reduce an already simplified process to one or two commands. </p><br><h3 id="dockerfile">  Dockerfile </h3><br><p>  The basic image I use <code>php:XXX-alpine</code> as the easiest and contains what you need to run.  Moreover - all subsequent updates to the interpreter are reduced to simply changing the value in this line (now it‚Äôs nowhere easier to update PHP). </p><br><p>  Composer and the RoadRunner binary file are delivered to the container using multistage and <code>COPY --from=...</code> - this is very convenient, and all the values ‚Äã‚Äãassociated with the versions are not "scattered", but are at the beginning of the file.  This works fast, and without dependencies on <code>curl</code> / <code>git clone</code> / <code>make build</code> .  <a href="https://github.com/512k/roadrunner-docker">512k / roadrunner images are</a> supported by me, if you want - you can assemble the binary file yourself. </p><br><blockquote>  An interesting story happened with the environment variable <code>PS1</code> (responsible for the prompt in the shell) - it turns out you can use emoji in it, and everything works locally, but if you try to start the image with a variable containing emoji in, say, rancher, it will crash (in swarm everything works without problems). </blockquote><p>  In <code>Dockerfile</code> I start generating a self-signed SSL certificate in order to use it for incoming HTTPS requests.  Naturally - nothing prevents the use of a "normal" certificate. </p><br><p>  I would also like to say about: </p><br><pre> <code class="plaintext hljs">COPY ./composer.* /app/ RUN set -xe \ &amp;&amp; composer install --no-interaction --no-ansi --no-suggest --prefer-dist \ --no-autoloader --no-scripts \ &amp;&amp; composer install --no-dev --no-interaction --no-ansi --no-suggest \ --prefer-dist --no-autoloader --no-scripts</code> </pre> <br><p>  Here the meaning is the following - the <code>composer.lock</code> and <code>composer.json</code> files are delivered in a <strong>separate layer</strong> to the image, after which all the dependencies described in them are installed.  This is done so that during subsequent builds of the image using <code>--cache-from</code> , if the composition and versions of the installed dependencies have not changed, then <code>composer install</code> <strong>not</strong> executed, taking this layer from the cache, thereby saving build time and traffic (thanks for the idea <a href="https://habr.com/ru/users/jetexe/" class="user_link">jetexe</a> ). </p><br><p>  <code>composer install</code> is executed twice (the second time with <code>--no-dev</code> ) to "warm up" the cache of dev dependencies, so that when we put all the dependencies on the CI to run the tests, they are put from the composer cache, which is already in the image, and not stretched from distant galaxies. </p><br><p>  With the last <code>RUN</code> instruction, we display the versions of the installed software and the composition of the PHP modules both for the history in the build logs and to make sure that "it is at least there and somehow starts." </p><br><p>  I also use my Entrypoint, because before starting the application somewhere in the cluster I really want to check the availability of dependent services - DB, redis, rabbit and others. </p><br><h3 id="roadrunner">  Roadrunner </h3><br><p>  To integrate RoadRunner with a Laravel application, a <a href="https://github.com/avto-dev/roadrunner-laravel">package</a> was written that reduces all integration to a couple of commands in the shell (by running <code>docker-compose run app sh</code> ): </p><br><pre> <code class="bash hljs">$ composer require avto-dev/roadrunner-laravel <span class="hljs-string"><span class="hljs-string">"^2.0"</span></span> $ ./artisan vendor:publish --provider=<span class="hljs-string"><span class="hljs-string">'AvtoDev\RoadRunnerLaravel\ServiceProvider'</span></span> --tag=rr-config</code> </pre> <br><p>  Add <code>APP_FORCE_HTTPS=true</code> to the <code>./docker/docker-compose.env</code> file, and specify the path to the SSL certificate in the container in the <code>.rr*.yaml</code> . </p><br><blockquote>  In order to be able to use <code>dump(..)</code> and <code>dd(..)</code> and everything would work, there is another package - <a href="https://github.com/avto-dev/stacked-dumper-laravel"><code>avto-dev/stacked-dumper-laravel</code></a> .  All that is required is to add a pefix to these helpers, namely <code>\dev\dd(..)</code> and <code>\dev\dump(..)</code> respectively.  Without this, you will observe an error of the form: <br><pre> <code class="plaintext hljs">worker error: invalid data found in the buffer (possible echo)</code> </pre> <br></blockquote><p>  After all the manipulations, do <code>docker-compose up -d</code> and voila: </p><br><p><img src="https://habrastorage.org/webt/5i/5h/ie/5i5hiea5tk9eysqzboe0pen_mp4.png" alt="screenshot"></p><br><p>  The PostgeSQL database, redis, and RoadRunner workers successfully ran in containers. </p><br><h1 id="shag-2---makefile-i-testyhttpsgitlabcomtarampampamlaravel-in-docker-with-rrmerge_requests2diffs">  Step 2 - <a href="https://gitlab.com/tarampampam/laravel-in-docker-with-rr/merge_requests/2/diffs">Makefile and Tests</a> </h1><br><p>  As I wrote earlier, a Makefile is a very underrated item.  Dependent goals, your own syntactic sugar, 99% chance that he already stands on the linux / mac development machine, autocomplete ‚Äúout of the box‚Äù - a small list of its advantages. </p><br><p>  Adding <a href="https://gitlab.com/tarampampam/laravel-in-docker-with-rr/blob/master/Makefile">it</a> to our project and doing <code>make</code> without parameters, we can observe: </p><br><p><img src="https://habrastorage.org/webt/ob/zz/q_/obzzq_e86v5nkadq11mmncax3ci.png" alt="screenshot"></p><br><p>  To run unit tests, we can either do a <code>make test</code> , or get a shell inside the container with the application ( <code>make shell</code> ), run <code>composer phpunit</code> .  To get a coverage report, just make <code>make test-cover</code> , and before running the tests, xdebug with its dependencies will be delivered to the container and the tests will be launched (since this procedure is not performed often and not by CI - this solution seems to be better than keeping a separate image with all dev-lotions). </p><br><h3 id="git-hooks">  Git hooks </h3><br><p>  Hooks in our case will fulfill 2 important roles - not allowing pushing code into the origin whose tests are not successful;  and automatically put all the necessary dependencies, if pulling the changes to your machine it turns out that <code>composer.lock</code> has changed.  In the <code>Makefile</code> , there is a separate target for this: </p><br><pre> <code class="plaintext hljs">cwd = $(shell pwd) git-hooks: ## Install (reinstall) git hooks (required after repository cloning) -rm -f "$(cwd)/.git/hooks/pre-push" "$(cwd)/.git/hooks/pre-commit" "$(cwd)/.git/hooks/post-merge" ln -s "$(cwd)/.gitlab/git-hooks/pre-push.sh" "$(cwd)/.git/hooks/pre-push" ln -s "$(cwd)/.gitlab/git-hooks/pre-commit.sh" "$(cwd)/.git/hooks/pre-commit" ln -s "$(cwd)/.gitlab/git-hooks/post-merge.sh" "$(cwd)/.git/hooks/post-merge"</code> </pre> <br><p>  Doing <code>make git-hooks</code> simply takes away the existing hooks and puts those in the <code>.gitlab/git-hooks</code> directory in their place.  Their source can be viewed <a href="https://gitlab.com/tarampampam/laravel-in-docker-with-rr/tree/master/.gitlab/git-hooks">at this link</a> . </p><br><h3 id="zapusk-testov-iz-phpstorm">  Running tests from PhpStorm </h3><br><p>  Despite the fact that it is quite simple and convenient - I used it for a long time <code>./vendor/bin/phpunit --group=foo</code> instead of just pressing the hotkey directly while writing a test or code associated with it. </p><br><p>  Click <code>File &gt; Settings &gt; Languages &amp; Frameworks &gt; PHP &gt; CLI interpreter &gt; [...] &gt; [+] &gt; From Docker, Vargant, VM, Remote</code> .  Select <strong>Docker compose</strong> , and the service name is <strong>app</strong> . </p><br><p><img src="https://habrastorage.org/webt/jk/ux/fy/jkuxfyw_7scvkz8oppse4t6i2ii.png" alt="screenshot"></p><br><p>  The second step is to tell phpunit to use the interpreter from the container: <code>File &gt; Settings &gt; Test frameworks &gt; [+] &gt; PHPUnit by remote interpreter</code> and select the previously created remote interpreter.  In the <code>Path to script</code> <code>/app/vendor/autoload.php</code> , specify <code>/app/vendor/autoload.php</code> , and in <code>Path mappings</code> specify the project root directory as mounted in <code>/app</code> . </p><br><p><img src="https://habrastorage.org/webt/8z/wq/ad/8zwqadvi8elq3hwaetcojgce2hk.png" alt="screenshot"></p><br><p>  And now we can run tests directly from the IDE using the interpreter inside the image with the application, pressing (by default, Linux) Ctrl + Shift + F10. </p><br><h1 id="shag-3---avtomatizaciyahttpsgitlabcomtarampampamlaravel-in-docker-with-rrmerge_requests3diffs">  Step 3 - <a href="https://gitlab.com/tarampampam/laravel-in-docker-with-rr/merge_requests/3/diffs">Automation</a> </h1><br><p>  All that remains for us to do is to automate the process of running tests and building the image.  To do this, create the <code>.gitlab-ci.yml</code> in the root directory of the application, filling it with the <a href="">following contents</a> .  The main idea of ‚Äã‚Äãthis configuration is to be as simple as possible, but not to lose functionality at the same time. </p><br><p>  The image is assembled at each brunch, at each commit.  Using <code>--cache-from</code> assembling an image upon re-commit is very fast.  The need for rebuilding is due to the fact that on each brunch we have an image with the changes that were made as part of this brunch, and as a result, nothing prevents us from rolling it out to swarm / k8s / etc in order to make sure "live" that everything works, and works as it should even before the merge with the <code>master</code> light. </p><br><p>  After the assembly, run unit tests and check the launch of the application in the container, sending curl-th requests to the health-check endpoint (this action is optional, but several times this test helped me a lot). </p><br><p>  For the "release of the release" - just publish a <strong>tag of the</strong> form <code>vX.XX</code> (if you still stick to semantic versioning - it will be very cool) - CI will collect the image, run the tests, and perform the actions that you specify in <code>deploy to somewhere</code> . </p><br><blockquote>  Do not forget in the project settings (if possible) to limit the ability to publish tags only to persons who are allowed to "release releases". </blockquote><br><h3 id="changelogmd-i-environmentmd">  <code>CHANGELOG.md</code> and <code>ENVIRONMENT.md</code> </h3><br><p>  Before accepting one or another MR, the inspector must, without fail, check the <code>CHANGELOG.md</code> and <code>ENVIRONMENT.md</code> files <code>CHANGELOG.md</code> <code>ENVIRONMENT.md</code> .  If the first is <a href="https://keepachangelog.com/en/1.0.0/">more and less clear</a> , then the relative second I will give an explanation.  <a href="">This file</a> is used to describe all environment variables that the container with the application responds to.  Those.  if the developer adds or removes support for one or another environment variable, this must be reflected in this file.  And at the moment when the question ‚ÄúWe urgently need to redefine this and that‚Äù arises - no one frantically begins to delve into the documentation or source codes - but looks in a single file.  Very comfortably. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, we examined the rather painless process of transferring application development and launching into the Docker environment, integrated RoadRunner, and using a simple CI script automated the assembly and testing of the image with our application. </p><br><p>  After cloning the repository, developers need to do <code>make git-hooks &amp;&amp; make install &amp;&amp; make up</code> and start writing useful code.  To companions * ops-am - to take an image with the necessary tag and roll it on their clusters. </p><br><p>  Naturally - this scheme is also simplified, and on the "combat" projects I‚Äôm wrapping up a lot more, but if the approach described in the article helps someone, I‚Äôll know that I wasted my time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/461687/">https://habr.com/ru/post/461687/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461665/index.html">Zen2. The evolution of the AM4 platform on the example of Ryzen 7 3700x</a></li>
<li><a href="../461669/index.html">PHP Digest No. 161 (July 15 - 29, 2019)</a></li>
<li><a href="../461673/index.html">8 tips for novice programmers or a retrospective of my career</a></li>
<li><a href="../461679/index.html">Electronic Arts Libraries of Almost Good Quality</a></li>
<li><a href="../461685/index.html">LED therapy, or ‚Äúyouthful apples‚Äù of the 21st century</a></li>
<li><a href="../461689/index.html">Developer IoT Identification</a></li>
<li><a href="../46169/index.html">Normal debug in NetBeans</a></li>
<li><a href="../461693/index.html">Cross-compiling OpenCV 4 for Raspberry Pi and BeagleBone Black</a></li>
<li><a href="../461695/index.html">VFX Internship</a></li>
<li><a href="../461697/index.html">Beer intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>