<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As we wrote the iOS library to work with the Wargaming API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="World of Tanks Assistant (WOT Assistant) and World of Warplanes Assitant (WOWP Assistant) are companion apps for players that allow you to monitor in-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As we wrote the iOS library to work with the Wargaming API</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/055/060/d85/055060d852be4888922e33ca6f29a5a6.jpg"><br><br>  <i><a href="https://itunes.apple.com/us/app/wot-assistant/id500174696%3Fmt%3D8">World of Tanks Assistant</a> (WOT Assistant)</i> and <i><a href="https://itunes.apple.com/us/app/world-of-warplanes-assistant/id739076510%3Fmt%3D8">World of Warplanes Assitant</a> (WOWP Assistant)</i> are companion apps for players that allow you to monitor in-game statistics, compare your combat performance with your friends, and also provide offline access to technical information . <br><br>  WOWP Assistant appeared relatively recently (November 2013), and the version for World of Tanks was rewritten from scratch in early 2013, which coincided with the transition to the new <a href="http://ru.wargaming.net/developers/documentation/guide/getting-started/">Wargaming Public API</a> .  Hopefully, the most technically interesting moments of developing an iOS library for <i>Assistant's</i> interaction with the API will be useful for developers and provide inspiration for participants in the Wargaming Developers Contest. <br><a name="habracut"></a><br><h4>  Requirements </h4><br>  The main high-level requirement for the library is ease of use and the ability to provide assistance or even completely solve some everyday tasks (for example, data caching) in order to simplify the client application code.  Below, I tried to formalize the list of functional and non-functional project requirements: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  flexible data caching; </li><li>  support for "partial" answers; </li><li>  convenient way to handle request chains; </li><li>  convenient way to integrate into applications; </li><li>  maximum code coverage tests. </li></ul><br><h4>  Used third-party solutions </h4><br>  Before we go back to the details of the implementation of these requirements, it is worth mentioning briefly which libraries we used. <br><br><h5>  <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> </h5><br>  AFNetworking is the de facto standard library for working with network data.  Although its ‚Äúuniversality‚Äù pulls a bunch of unnecessary functionality behind itself, we decided not to write our own. <br><br><h5>  <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> </h5><br>  The library brings functional reactive paints to the world of iOS ( <a href="http://habrahabr.ru/post/215033/">article on Habr√©</a> ).  Currently actively used in assistant applications.  At the initial stage, it seemed to me a convenient way to describe requests as separate units of the API (for what it was needed, it will be discussed in the section on the query chain below). <br><br><h5>  <a href="https://github.com/Mantle/Mantle">Mantle</a> </h5><br>  Another library from the iOS team Github, which allows you to significantly simplify the data model layer, namely the parsing of web services responses (the example in README is quite indicative).  As a bonus, all objects automatically receive support. <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h5> <code><code><a href="https://github.com/kiwi-bdd/Kiwi"></a>    . <br> <br> Kiwi <br>  BDD-    RSpec -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code></code> </h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h5> <code><a href="https://github.com/AliSoftware/OHHTTPStubs"></a><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> OHTTPStubs <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <blockquote> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </blockquote> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ul><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ul> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h5> <code><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"></a><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> NSURLCache <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><code class="objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> - (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse; <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ol><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ol> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ul><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ul> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ul><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ul> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <blockquote> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </blockquote> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><code class="objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ul><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ul> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ul><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ul> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><code class="objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> (id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error; </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h5> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <pre> <code class="hljs objectivec"><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      <span class="hljs-string"><span class="hljs-string">""</span></span>,      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code><span class="hljs-built_in"><span class="hljs-built_in">NSCache</span></span></code> .   ,       ,         ‚Äî         .         <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></a> <br> <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code>        <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span></code>   .      ,    . <br> <br>   : <br> <code class="objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> *urlCache = [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnectionDelegate</span></span></code>   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    : <br> <code class="objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)connection:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span> *)connection willCacheResponse:(<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *httpResponse = (<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span>*)[cachedResponse response]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *headers = [httpResponse allHeaderFields]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cacheControl = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expires = [headers valueForKey:<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((cacheControl == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) &amp;&amp; (expires == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *expireDate = [<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> RFC822StringFromDate:[[<span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> date] dateByAddingTimeInterval:cacheTime]]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *values = @{<span class="hljs-string"><span class="hljs-string">@"Expires"</span></span>: expireDate, <span class="hljs-string"><span class="hljs-string">@"Cache-Control"</span></span>: <span class="hljs-string"><span class="hljs-string">@"public"</span></span>}; [modifiedHeaders addEntriesFromDictionary:values]; <span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> *response = [[<span class="hljs-built_in"><span class="hljs-built_in">NSHTTPURLResponse</span></span> alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:<span class="hljs-string"><span class="hljs-string">@"HTTP/1.1"</span></span> headerFields:modifiedHeaders]; <span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> *modifiedCachedResponse = [[<span class="hljs-built_in"><span class="hljs-built_in">NSCachedURLResponse</span></span> alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:<span class="hljs-built_in"><span class="hljs-built_in">NSURLCacheStorageAllowed</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modifiedCachedResponse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span></code> ,   . <br> : <br>     <span class="hljs-number"><span class="hljs-number">30</span></span>  ;       ; :         <span class="hljs-number"><span class="hljs-number">200</span></span>- , <code><span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span></code>   . <br>  <span class="hljs-string"><span class="hljs-string">""</span></span>  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span></code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span></code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *parameters = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; parameters[<span class="hljs-string"><span class="hljs-string">@"search"</span></span>] = query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (limit) parameters[<span class="hljs-string"><span class="hljs-string">@"limit"</span></span>] = @(limit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getPath:<span class="hljs-string"><span class="hljs-string">@"account/list"</span></span> parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)query limit:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     <span class="hljs-string"><span class="hljs-string">""</span></span>    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> JSON) { <span class="hljs-comment"><span class="hljs-comment">// Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    ,          .         </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">  ,       . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment">   ‚Äî      ,      .        ,         Promises  Futures. </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      </span></span><br><span class="hljs-comment"><span class="hljs-comment">        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,         ,      ‚Äî . ,    (    )       </span></span><a href="http://cocoapods.org/"><span class="hljs-comment"><span class="hljs-comment">CocoaPods</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,       .       </span></span><code><span class="hljs-comment"><span class="hljs-comment">subspecs</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ""  ""  ,      : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="ruby"><span class="hljs-comment"><span class="hljs-comment">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment">        </span></span><a href="http://habrahabr.ru/post/164073/"><span class="hljs-comment"><span class="hljs-comment"></span></span></a><span class="hljs-comment"><span class="hljs-comment">  </span></span><a href="http://habrahabr.ru/post/150438/"><span class="hljs-comment"><span class="hljs-comment">   </span></span></a><span class="hljs-comment"><span class="hljs-comment"> .        . </span></span><br><span class="hljs-comment"><span class="hljs-comment">         (98%).           : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ;    . </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ,     / ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">RACSignal</span></span></code><span class="hljs-comment"><span class="hljs-comment">      ,       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="objectivec"><span class="hljs-comment"><span class="hljs-comment">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> * ‚Äî    - -    Kiwi,      ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">nil</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       API    : </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ;   . </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,  ,       :  query  http-. </span></span><code><span class="hljs-comment"><span class="hljs-comment"> </span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,      </span></span><code><span class="hljs-comment"><span class="hljs-comment">ReactiveCocoa</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</span></span></code> </pre> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <ol><li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> <li> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </li> </ol> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> <h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </h4> <code><a href="https://github.com/kiwi-bdd/Kiwi"></a> <code>   . <br> <br> Kiwi <br>  BDD-    RSpec</code> -  ,   .   ¬´--¬ª. <br> <br> <a href="https://github.com/AliSoftware/OHHTTPStubs">OHTTPStubs</a> <br>   ,      web-   .      "",      <a href="https://gist.github.com/garnett/7267579">-</a> . <br> <br>     . <br> <br>    <br> There are only two hard things in Computer Science: cache invalidation and naming things. <br> <br> -- Phil Karlton <br>  ¬´ ¬ª  : <br> <br>                .. <br> ,            . <br>       -     <code>inMemory CoreData</code> ,       <code>NSCache</code> .   ,       ,         ‚Äî         .         <code>NSURLConnection</code> . <br> <br> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html">NSURLCache</a> <br> <code>NSURLCache</code>        <code>NSURLRequest</code>   .      ,    . <br> <br>   : <br> <code class="objectivec">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:kInMemoryCacheSize diskCapacity:kOnDiskCacheSize diskPath:path]; [NSURLCache setSharedURLCache:urlCache];</code> <br>     ,           . <br> <br>  <code>NSURLConnectionDelegate</code>   ,     ""    : <br> <code class="objectivec">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</code> <br>    ? <br> <br> <code class="objectivec"> NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)[cachedResponse response]; NSDictionary *headers = [httpResponse allHeaderFields]; NSString *cacheControl = [headers valueForKey:@"Cache-Control"]; NSString *expires = [headers valueForKey:@"Expires"]; if((cacheControl == nil) &amp;&amp; (expires == nil)) { NSMutableDictionary *modifiedHeaders = [httpResponse.allHeaderFields mutableCopy]; NSString *expireDate = [NSDate RFC822StringFromDate:[[NSDate date] dateByAddingTimeInterval:cacheTime]]; NSDictionary *values = @{@"Expires": expireDate, @"Cache-Control": @"public"}; [modifiedHeaders addEntriesFromDictionary:values]; NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:httpResponse.URL statusCode:httpResponse.statusCode HTTPVersion:@"HTTP/1.1" headerFields:modifiedHeaders]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:cachedResponse.data userInfo:cachedResponse.userInfo storagePolicy:NSURLCacheStorageAllowed]; return modifiedCachedResponse; } return cachedResponse;</code> <br>      HTTP-      . <br> <br> ,     (    ,    ,            ).   ,     ( <code>cacheTime</code> )   . <br>     ‚Äî        (      ).    ,      ,    . <br> <br> : <br> <br>        (, ,   ..);  -   <code>NSURLCache</code> ,   . <br> : <br>     30  ;       ; :         200- , <code>NSURLConnection</code>   . <br>  ""  <br>          API (, <a href="https://ru.wargaming.net/developers/api_reference/wowp/account/info/">  </a> ),     <code>fields</code> : <br> <br>   .   .    .    ,   . <br>  ,   <code>Player</code> ,      JSON-,   .        ,       <code>fields</code> ,        <code>NSDictionary</code> .         ,  -       .          ,           . <br>   <code>JSON -&gt; NSObject</code>    <code>Mantle</code> ,     API      ( <code>RACSignal</code>   API      ): <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@"search"] = query; if (limit) parameters[@"limit"] = @(limit); return [self getPath:@"account/list" parameters:parameters resultClass:WOTSearchPlayer.class]; }</code> <br>  ,       <code>resultClass</code> ,         ? : <br> <br> <code class="objectivec"> - (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit resultClass:(Class)resultClass</code> <br> ,     API,           . <br> <br>       <br>     API     ,               : ,   ,     ""    . (    ).    ,       (   <code>AFJSONRequestOperation</code> ): <br> <br> <code class="objectivec"> op1 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op2 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { op3 = [AFJSONRequestOperation JSONRequestOperationWithRequest:nil success:^(id JSON) { // Combine all the responses and return } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }]; } failure:^(NSError *error) { // Handle error }];</code> <br>  ,    ,          .         <code>ReactiveCocoa</code>  ,       . <br>  API    : <br> <br> <code class="objectivec">- (RACSignal *)searchPlayers:(NSString *)query limit:(NSUInteger)limit; - (RACSignal *)fetchPlayers:(NSArray *)playerIDs;</code> <br> <code>RACSignal</code> ‚Äî  ,       ,     .    ‚Äî       ,    .          / : <br> <br> <code class="objectivec"> RACSignal *fetchPlayersAndRatings = [[[[API searchPlayers:@"" limit:0] flattenMap:^RACStream *(id players) { // skipping data processing return [API fetchPlayers:@[]]; }] flattenMap:^RACStream *(id fullPlayers) { // Skipping data processing return [API statsSliceForPlayer:nil hoursAgo:@[] fields:nil]; }] flattenMap:^RACStream *(id value) { // Compose all responses here id composedResponse; return [RACSignal return:composedResponse]; }]; [fetchPlayersAndRatings subscribeNext:^(id x) { // Fully composed response } error:^(NSError *error) { // All erros go to one place }];</code> <br>  <code>ReactiveCocoa</code>   ‚Äî      ,      .        ,         Promises  Futures. <br> <br>      <br>        : <br> Core ( , ); WOT (    World of Tanks‚Äì); WOWP (    World of Warplanes‚Äì) <br>  ,         ,      ‚Äî . ,    (    )       <a href="http://cocoapods.org/">CocoaPods</a> ,       .       <code>subspecs</code> ,        : <br> <br> <code class="ruby"> # Subspecs s.subspec 'Core' do |cs| cs.source_files = 'WGNAPIClient/Core/**/*.{h,m}' end s.subspec 'WOT' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOT/**/*.{h,m}' end s.subspec 'WOWP' do |cs| cs.dependency 'WGNAPIClient/Core' cs.source_files = 'WGNAPIClient/WOWP/**/*.{h,m}' end</code> <br> <br>    ""  ""  ,      : <br> <code class="ruby">pod 'WGNAPIClient/WOT' pod 'WGNAPIClient/WOWP'</code> <br>     <br>        <a href="http://habrahabr.ru/post/164073/"></a>  <a href="http://habrahabr.ru/post/150438/">   </a> .        . <br>         (98%).           : <br> <br>   ;    . <br>   <br>     : <br> <code class="objectivec"> context(@"API works with players data", ^{ it (@"should search players", ^{ stubResponse(@"/wot/account/list", @"players-search.json"); RACSignal *searchRequest = [client searchPlayers:@"garnett" limit:0]; NSArray *response = [searchRequest asynchronousFirstOrDefault:nil success:NULL error:&amp;error]; [[error should] beNil]; [[response should] beKindOfClass:NSArray.class]; [[response.lastObject should] beKindOfClass:WOTSearchPlayer.class]; WOTSearchPlayer *player = response[0]; [[player.ID should] equal:@"1785514"]; }); });</code> <br> ,     / ,    <code>RACSignal</code>      ,       : <br> <code class="objectivec">(id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;</code> <br>   <br> <code class="objectivec">describe(@"WOTRatingType", ^{ it(@"should parse json to model object", ^{ NSDictionary *json = @{ @"threshold": @5, @"type": @"1", @"rank_fields": @[ @"xp_amount_rank", @"xp_max_rank", @"battles_count_rank", @"spotted_count_rank", @"damage_dealt_rank", ] }; NSError *error; WOTRatingType *ratingType = [MTLJSONAdapter modelOfClass:WOTRatingType.class fromJSONDictionary:json error:&amp;error]; [[error should] beNil]; [[ratingType should] beKindOfClass:WOTRatingType.class]; [[json[@"threshold"] should] equal:theValue(ratingType.threshold)]; * [[json[@"type"] should] equal:ratingType.type]; [[ratingType.rankFields shouldNot] beNil]; [[ratingType.rankFields should] beKindOfClass:NSArray.class]; [[ratingType.rankFields should] haveCountOf:5]; [[@"maximumXP" should] equal:ratingType.rankFields[1]]; }); });</code> <br> <br> * ‚Äî    - -    Kiwi,      ,     <code>nil</code> . <br> <br>       API    : <br>    ;   . <br>  ,  ,       :  query  http-. <code> </code> <br> <br>  <br>    ,      <code>ReactiveCocoa</code> ,         (    ).    ( )   2k LOC (  ~1k -  ,   ~700 -     ),     :        ‚Äî         .</code> </div><p>Source: <a href="https://habr.com/ru/post/232037/">https://habr.com/ru/post/232037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232021/index.html">T-shirt printer: from home crafts to serial models of textile printer</a></li>
<li><a href="../232023/index.html">Directive Controllers in AngularJS</a></li>
<li><a href="../232025/index.html">How I created a magic piano</a></li>
<li><a href="../232029/index.html">Video experiments in physics and augmented reality for schools</a></li>
<li><a href="../232033/index.html">Control access to electronic documents. From DefView to Vivaldi</a></li>
<li><a href="../232039/index.html">Overview of the most interesting materials on data analysis and machine learning ‚Ññ7 (July 28 - August 4, 2014)</a></li>
<li><a href="../232041/index.html">Enlarge your pension size or your own financial adviser</a></li>
<li><a href="../232043/index.html">The digest of interesting news and materials from the world of PHP No. 45 (July 20 - August 3, 2014)</a></li>
<li><a href="../232045/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ118 (July 28 - August 3, 2014)</a></li>
<li><a href="../232047/index.html">The Russians took the victory in the final of the Imagine Cup 2014</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>