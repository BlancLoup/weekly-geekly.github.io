<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We use the built-in microcontroller in Intel Edison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think that many of you are already familiar with Intel Edison from the previous notes, and some, after reading the specifications, probably had a qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We use the built-in microcontroller in Intel Edison</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/867/a4f/7cd/867a4f7cd0d74902b2068fa5ca9f7730.jpg">  I think that many of you are already familiar with <a href="https://software.intel.com/ru-ru/iot/hardware/edison">Intel Edison</a> from the previous notes, and some, after reading the specifications, probably had a question - what is the second mysterious MCU processor running at 100 MHz?  Why is it needed?  How to use it? <br>  Meanwhile, the role of the MCU in some cases is extremely important.  Those who tried to use Edison to work with various sensors may have already noticed - Intel Edison does not provide a real-time response to their readings when working from Linux.  And here comes the MCU.  It's time to tell a little about this built-in microcontroller, its architecture, areas of application and consider a practical example. <br><a name="habracut"></a><br>  Since 2.1, the <a href="https://software.intel.com/en-us/iot/hardware/edison/downloads">software</a> for Intel Edison has added the ability to use the integrated microcontroller. <br><br>  Consider a system on a chip used in the Intel Edison Compute Module: <br><img src="https://habrastorage.org/files/c90/9f9/fc9/c909f9fc900349fbbcdeab4c2ccbab34.png"><br><br>  The system on a chip used in the Intel Edison Compute Module includes two processors: <br><ol><li>  Intel Atom dual-core processor operating at 500 MHz.  Designated as Host CPU. </li><li>  Microcontroller architecture Minute IA, operating at 100 MHz.  Designated as MCU. </li></ol><br>  Consider the microcontroller in more detail.  The Minute IA Computing Core is an energy efficient architecture based on 486 with the addition of commands for compatibility with the Pentium.  In addition to the computational core, the microcontroller contains an input-output subsystem (GPIO, I2C, High Speed ‚Äã‚ÄãUART, DMA) and SRAM.  The microcontroller has access to all GPIO ports in the Edison Compute Module.  The total amount of SRAM for code and data is 192 kb.  The microcontroller runs the Viper OS real-time operating system from WindRiver. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The microcontroller application runs on top of the Viper core and controls the peripherals connected to the MCU, regardless of the Intel Atom processor.  For example, it can manage GPIO ports, interact with sensors using I2C or UART, and exchange data with the Intel Atom processor. <br><br><h2>  Why do I need a microcontroller in Intel Edison? </h2><br>  I would single out two areas where you can apply the built-in microcontroller: <br><ol><li>  Work with I / O ports and interfaces with real-time response. </li><li>  Energy efficiency. </li></ol><br>  The Intel Atom processor and the standard Yocto Linux distribution do not allow an out-of-box implementation of applications with a real-time response.  An application may be preempted by the task scheduler, leading to an unacceptable and unpredictable delay.  A single application and a real-time operating system are running on the microcontroller, so it is possible to provide a real-time response.  This is required to work with many sensors, where the interaction protocol depends on strict adherence to short time intervals.  To connect them without a built-in microcontroller, one would have to use a separate microcontroller on which to implement all the functionality for working with such sensors.  An example of a solution for Intel Edison with an external microcontroller is the <a href="https://www.sparkfun.com/products/13036">SparkFun Block for Intel Edison - Arduino</a> expansion <a href="https://www.sparkfun.com/products/13036">board</a> . <br><br>  You can increase energy efficiency using a microcontroller in those applications where the main processor can be in a state of sleep, and the microcontroller can expect a certain event (for example, exceeding the threshold values ‚Äã‚Äãfrom the sensor). <br>  If necessary, the microcontroller awakens the main processor.  An example implementation is given in the article <a href="https://software.intel.com/en-us/node/557354">Using the MCU SDK and API: Code examples</a> . <br><br>  As an example of working with an Intel Edison microcontroller, consider the connection of the ultrasonic distance sensor HC-SR04.  The measured distance will be displayed on the Grove LCD RGB Backlight character screen. <br><br><h2>  Ultrasonic distance sensor HC-SR04 </h2><br><img src="https://habrastorage.org/files/f4c/05c/681/f4c05c68170140cab2b81385b35b0f20.jpg"><br>  The sensor has 4 terminals: <br><ul><li>  <strong>Vcc</strong> - 5V. </li><li>  <strong>Trig</strong> - Trigger signal to the sensor.  The microcontroller delivers a 10 microsecond pulse to the sensor.  The sensor initiates the metering process. </li><li>  <strong>Echo</strong> - <strong>Echo</strong> signal from the sensor to the microcontroller.  The pulse duration is proportional to the measured distance. </li><li>  <strong>Gnd</strong> - Earth. </li></ul><br>  Here is the process of working with the sensor on the oscilloscope screen: <br><img src="https://habrastorage.org/files/308/3c8/08d/3083c808d8f44f3a957ab84b46fef7a6.png"><br><br><ul><li>  <strong>Channel 1</strong> - Trig </li><li>  <strong>Channel 2</strong> - Echo </li></ul><br>  The microcontroller gives impulse to <strong>Trig</strong> .  After that, the sensor responds with a pulse to <strong>Echo</strong> . <br>  The pulse duration is proportional to the measured distance. <br>  The measured distance is calculated using the formula (taken from the sensor specification): <br><pre>  distance (cm) = pulse width Echo (microseconds) / 58 </pre><br>  According to the specification, the sensor can measure distances from 2 to 400 cm. <br>  To measure the pulse duration with the predicted error without real-time will be problematic. <br>  The measurement process may, for example, be superseded by the scheduler and the measurement result will be incorrect. <br><br><h2>  We connect HC-SR04 to the Intel Edison microcontroller </h2><br><img src="https://habrastorage.org/files/a3a/75f/5cf/a3a75f5cf2f14895a183d8fbb7670e1f.jpg"><br><br>  Components Used: <br><ul><li>  Edison Compute Module </li><li>  Edison arduino board </li><li>  Grove Basic Shield </li><li>  Character screen Grove LCD RGB Backlight </li><li>  Ultrasonic distance sensor HC-SR04 </li><li>  Bread board </li></ul><br>  First, <a href="https://software.intel.com/en-us/assembling-intel-edison-board-with-arduino-expansion-board">connect the</a> Edison Compute Module to the Edison Arduino board.  Then connect the Grove Basic Shield expansion board to the Edison Arduino Board.  Grove LCD RGB Backlight connects to the I2C connector on the Grove Basic Shield. <br><br>  Ultrasonic distance sensor HC-SR04 connects to Grove Basic Shield as follows: <br><ul><li>  <strong>Vcc</strong> to + 5V. </li><li>  <strong>Trig</strong> to pin # 3. </li><li>  <strong>Echo</strong> to pinu # 4. </li><li>  <strong>Gnd</strong> to Gnd. </li></ul><br>  Pins 3, 4 are randomly selected, others can be used instead. <br><br><h2>  Intel Edison Firmware Update </h2><br>  Microcontroller support is available in the Intel Edison¬Æ Board Firmware Software Release since version 2.1.  If your firmware is older, then you need to update it. <br><br>  You can find out the current firmware version with the command: <br><pre><code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># configure_edison --version</span></span></code> </pre> <br>  This example was created on firmware version 146. <br><br>  The process of updating the firmware is described in detail in the article <a href="http://www.intel.com/support/edison/sb/CS-035280.htm">Flashing Intel Edison</a> .  Personally, I usually use the method described in the <strong>Alternate Flashing Method</strong> section. <br>  <em>Read the instructions carefully before flashing.</em> <br><br><h2>  We connect Intel Edison through Ethernet-over-USB </h2><br>  To work with Edison from the MCU SDK environment, you need to create a network connection. <br>  To do this, for example, connect a USB cable to the middle micro-USB port (the switch should be set to the side of micro-USB ports). <br>  In Linux, the network is configured with the command: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ifconfig usb0 192.168.2.2</span></span></code> </pre><br>  Intel Edison IP Address: <code>192.168.2.15</code> <br>  The connection process is described in more detail in the <a href="https://software.intel.com/en-us/connecting-to-intel-edison-board-using-ethernet-over-usb">Connecting to your Intel¬Æ Edison board using Ethernet over USB</a> article. <br><br><h2>  MCU SDK </h2><br>  A cross-platform development environment <a href="https://software.intel.com/en-us/node/545143">MCU SDK</a> based on Eclipse has been released to create applications that will run on the embedded microcontroller.  The installation process is described in detail in the article <a href="https://software.intel.com/en-us/node/545143">Installing the MCU SDK</a> . <br>  The MCU SDK allows you to create, compile, download to the board and debug applications for the microcontroller. <br><br><h3>  Interaction with MCU </h3><br>  To interact with a microcontroller from Linux several interfaces are available: <br>  <code>/dev/ttymcu0</code> - The channel for data exchange.  From Linux, you can work with standard file operations.  From the program on the microcontroller, the exchange is performed using the <code>host_send</code> and <code>host_receive</code> . <br>  <code>/dev/ttymcu1</code> - The channel through which the microcontroller sends debug messages <code>debug_print</code> function. <br>  <code>/sys/devices/platform/intel_mcu/log_level</code> - Allows you to set the level of debugging messages (fatal, error, warning, info, debug). <br><br><h3>  Work with ports Edison Arduino Board </h3><br>  The microcontroller is built into the Edison Compute Module and controls the I / O ports located on the 70-pin connector of the module. <br>  If you need to use a microcontroller with the Edison Arduino Board, then you need to find the matching GPIO port in the Edison Compute Module port number in the Edison Arduino Board. <br>  Then you need to configure multiplexing and set the direction in the logic level converter. <br>  When working with ports on the Linux level, all these actions are performed by the <a href="https://github.com/intel-iot-devkit/mraa">MRAA</a> library.  In the case of a microcontroller, you need to take care of this yourself using <a href="https://software.intel.com/en-us/node/557356">scripts</a> (init_DIG.sh, init_i2c8.sh, init_mcu_PWM.sh, set_DIG.sh, read_DIG.sh, init_UART1.sh).  For more information, see the <a href="http://www.intel.com/support/edison/sb/CS-035275.htm">Intel¬Æ Edison Kit for Arduino * Hardware Guide</a> (table 4). <br><br><h3>  Linux program </h3><br>  A small Python script that will receive data from the embedded microcontroller and display it on a character display.  To work with the symbolic display, we will use the <a href="http://iotdk.intel.com/docs/master/upm/classupm_1_1_jhd1313m1.html">Jhd1313m1</a> module from the <a href="https://github.com/intel-iot-devkit/upm">UPM</a> library. <br><br><div class="spoiler">  <b class="spoiler_title">Script show_distance.py:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyupm_i2clcd RET_ERROR = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: lcd = pyupm_i2clcd.Jhd1313m1(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x3E</span></span>, <span class="hljs-number"><span class="hljs-number">0x62</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'/dev/ttymcu0'</span></span>, <span class="hljs-string"><span class="hljs-string">'w+t'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: f.write(<span class="hljs-string"><span class="hljs-string">'get_distance\n'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Send command to MCU f.flush() line = f.readline() # Read response from MCU, -1 = ERROR value = int(line.strip('\n\r\t ')) lcd.clear() if value == RET_ERROR: lcd.setColor(255, 0, 0) # RED lcd.write('ERROR') else: lcd.setColor(0, 255, 0) # GREEN lcd.write('%d cm' % (value,)) time.sleep(1)</span></span></code> </pre><br></div></div><br><br><h3>  Microcontroller software </h3><br>  The program on the microcontroller should, when receiving the get_distance command from the host, measure the distance and send the result to the host (distance in centimeters, or -1 in case of an error). <br>  Configuring ports on the Edison Arduino Board: <br><pre> <code class="bash hljs">./init_DIG.sh -o 3 -d output ./init_DIG.sh -o 4 -d input</code> </pre><br>  Let me remind you that the microcontroller works with GPIO ports on the Edison Compute Module, which differ from the numbering on the Edison Arduino Board.  The correspondence table is shown, for example, at the end of the article <a href="https://software.intel.com/en-us/node/545145">Blinking an LED using the MCU</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Program for the microcontroller in the MCU SDK:</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"mcu_api.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"mcu_errno.h"</span></span> // Arduino Extension PIN = <span class="hljs-number"><span class="hljs-number">3</span></span> #define TRIG <span class="hljs-number"><span class="hljs-number">12</span></span> // Arduino Extension PIN = <span class="hljs-number"><span class="hljs-number">4</span></span> #define ECHO <span class="hljs-number"><span class="hljs-number">129</span></span> // From HC-SR04 datasheet #define MIN_DISTANCE <span class="hljs-number"><span class="hljs-number">2</span></span> #define MAX_DISTANCE <span class="hljs-number"><span class="hljs-number">400</span></span> #define MAX_WAIT <span class="hljs-number"><span class="hljs-number">10000</span></span> #define RET_ERROR <span class="hljs-number"><span class="hljs-number">-1</span></span> int get_distance() { // Send Trig signal to HC-SR04 gpio_write(TRIG, <span class="hljs-number"><span class="hljs-number">1</span></span>); mcu_delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); gpio_write(TRIG, <span class="hljs-number"><span class="hljs-number">0</span></span>); // Read Echo signal from HC-SR04 int i; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((gpio_read(ECHO) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (i &lt; MAX_WAIT)) { mcu_delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); i++; } unsigned long t0 = time_us(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gpio_read(ECHO) == <span class="hljs-number"><span class="hljs-number">0</span></span> || i == MAX_WAIT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; } i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((gpio_read(ECHO) == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (i &lt; MAX_WAIT)) { mcu_delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); i++; } unsigned long t1 = time_us(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gpio_read(ECHO) == <span class="hljs-number"><span class="hljs-number">1</span></span> || i == MAX_WAIT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; } unsigned long distance = (t1 - t0) / <span class="hljs-number"><span class="hljs-number">58</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MIN_DISTANCE &lt; distance &amp;&amp; distance &lt; MAX_DISTANCE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; } } #define MAX_BUF <span class="hljs-number"><span class="hljs-number">255</span></span> unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> buf[MAX_BUF]; void mcu_main() { // Setup Trig as OUTPUT gpio_setup(TRIG, <span class="hljs-number"><span class="hljs-number">1</span></span>); // Initially set Trig to LOW gpio_write(TRIG, <span class="hljs-number"><span class="hljs-number">0</span></span>); // Setup Echo as INPUT gpio_setup(ECHO, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { unsigned int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = host_receive(buf, MAX_BUF); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) &amp;&amp; (strncmp(buf, <span class="hljs-string"><span class="hljs-string">"get_distance"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { unsigned int distance; distance = get_distance(); <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = mcu_snprintf(buf, MAX_BUF, <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, distance); host_send(buf, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>); } } }</code> </pre><br></div></div><br><h3>  Add script to autorun </h3><br>  Create a file that will run our script: <br><div class="spoiler">  <b class="spoiler_title">File /home/root/startup.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash cd /home/root # configure PIN3 as GPIO OUPUT (TRIG signal) ./init_DIG.sh -o 3 -d output # configure PIN4 as GPIO INPUT (ECHO signal) ./init_DIG.sh -o 4 -d input python show_distance.py</span></span></code> </pre><br></div></div><br>  Mark scripts as executable: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chmod a+x /home/root/startup.sh # chmod a+x /home/root/init_DIG.sh</span></span></code> </pre><br>  Since Yocto Linux uses systemd, to add a script to autorun, you need to create a file of the so-called ‚Äúservice‚Äù. <br><div class="spoiler">  <b class="spoiler_title">Create a file /lib/systemd/system/startup-script.service</b> <div class="spoiler_text">  [Unit] <br>  Description = Startup User Script <br>  After = syslog.target <br><br>  [Service] <br>  ExecStart = / home / root / startup.sh <br><br>  [Install] <br>  WantedBy = multi-user.target <br></div></div><br>  Add a script to autorun: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl enable startup-script</span></span></code> </pre><br>  After the reboot, the measured distance should be displayed on the symbol display: <br><img src="https://habrastorage.org/files/b0d/05c/399/b0d05c3991f84944b69faa6033ac0744.JPG"><br><br><h2>  Resources used </h2><br><ul><li>  <a href="https://software.intel.com/en-us/iot/hardware/edison/downloads">Intel Edison Board Software Downloads</a> </li><li>  <a href="https://www.sparkfun.com/products/13036">SparkFun Block for Intel Edison - Arduino</a> </li><li>  <a href="https://software.intel.com/en-us/node/557354">Using the MCU SDK and API: Code examples</a> </li><li>  <a href="https://software.intel.com/en-us/assembling-intel-edison-board-with-arduino-expansion-board">Assembling the Intel¬Æ Edison board with the Arduino expansion board</a> </li><li>  <a href="http://www.intel.com/support/edison/sb/CS-035280.htm">Flashing intel edison</a> </li><li>  <a href="https://software.intel.com/en-us/connecting-to-intel-edison-board-using-ethernet-over-usb">Connecting to your Intel¬Æ Edison board using Ethernet over USB</a> </li><li>  <a href="https://software.intel.com/en-us/node/545143">MCU SDK</a> </li><li>  <a href="https://software.intel.com/en-us/node/545143">Installing the MCU SDK</a> </li><li>  <a href="https://github.com/intel-iot-devkit/mraa">MRAA library</a> </li><li>  <a href="http://www.intel.com/support/edison/sb/CS-035275.htm">Intel Edison Kit for Arduino Hardware Guide</a> </li><li>  <a href="https://software.intel.com/en-us/node/557356">Sample scripts for the MCU SDK</a> </li><li>  <a href="https://github.com/intel-iot-devkit/upm">UPM library</a> </li><li>  <a href="http://iotdk.intel.com/docs/master/upm/classupm_1_1_jhd1313m1.html">UPM: Jhd1313m1 module</a> </li><li>  <a href="https://software.intel.com/en-us/node/545145">Blinking an LED using the MCU</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/260471/">https://habr.com/ru/post/260471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260459/index.html">Attackers used stolen digital certificate for Duqu2 malicious campaign</a></li>
<li><a href="../260461/index.html">My first game development history</a></li>
<li><a href="../260463/index.html">Looking at the code with eyes closed</a></li>
<li><a href="../260467/index.html">Explosive GameDev. The history of my game</a></li>
<li><a href="../260469/index.html">Kolab Groupware (Part 1 - Overview)</a></li>
<li><a href="../260475/index.html">How we implanted voice calls in Megaplan</a></li>
<li><a href="../260477/index.html">Interview with the commercial director of the portal zaycev.net</a></li>
<li><a href="../260479/index.html">DevConf 2015 - the conference program is formed</a></li>
<li><a href="../260481/index.html">.NEXT 2015 Piter: Is it possible to press Moscow?</a></li>
<li><a href="../260487/index.html">Pacman-like game on STM32F429I-DISCO with map editor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>