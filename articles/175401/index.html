<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We struggle with deadlock: pattern unlocked callbacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Interlock situations 
 Wikipedia gives the following definition of interlocking: "Mutual blocking (eng. Deadlock) is a situation in a multitasking env...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We struggle with deadlock: pattern unlocked callbacks</h1><div class="post__text post__text-html js-mediator-article"><h4>  Interlock situations </h4><br>  Wikipedia gives the following definition of interlocking: "Mutual blocking (eng. Deadlock) is a situation in a multitasking environment or a DBMS, in which several processes are in a state of endless waiting for resources occupied by these processes themselves." <br><br>  Interlocks are usually dynamic in nature: their manifestation depends on such factors as user actions, availability of network services, positioning of the hard disk head, switching tasks in a system with preemptive multitasking, etc. <br><br>  A classic example of interlocking: the first thread (A) captures the M1 mutex and then the M2 mutex.  The second thread (B) captures the M2 mutex, and after that the M1 mutex.  Mutual blocking of these two streams can occur as follows: flow A captures M1, flow B captures M2, then both flows are "doomed": neither flow A can capture M2, nor flow B can capture M1;  attempts to capture mutexes will block both threads. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The described mutual blocking will occur only if both threads manage to capture exactly one mutex.  Otherwise, the threads will continue. <br><br>  This situation is very common in complex multi-threaded systems.  As a rule, participating mutexes are located far from each other (in various components of the system), and it turns out to be quite difficult to identify participants of interlocking. <br><a name="habracut"></a><br><h4>  Common situation in the real system </h4><br>  One of the particular cases of the interlocking described above is as follows: <br><ul><li>  some object (Worker) performs some activity in a separate thread;  at the beginning of its existence, the Worker object creates this thread, and terminates it itself before its destruction; </li><li>  the flow activity consists in cyclically repeating certain actions (for example, retrieving data from the network); </li><li>  the results of these individual actions are provided to consumers via callback functions or interfaces; </li><li>  at any time during the life of the Worker object, a new consumer may appear or the existing one disappear;  The Worker object maintains a consumer list and provides functions for registering and deleting consumers (registerCallback and unregisterCallback, respectively); </li><li>  the consumer list is a shared resource: it is accessed by the internal flow of the Worker object, as well as by consumers who make registerCallback and unregisterCallback calls from the context of their own flow; </li><li>  since the consumer list is a shared resource, it is protected by a mutex owned by the Worker object;  with a captured mutex, the consumer list is modified;  with a captured mutex, data is transmitted to consumers from the Worker object. </li></ul><br>  How dangerous is the situation described above?  By the fact that during the development phase of the Worker object, the developer did not yet know exactly which functions of the system would be called through the callback interface.  He only made demands on the interface: the function must have such and such parameters through which such and such data will be transmitted.  And this call ‚Äúin an unknown direction‚Äù is made with a captured mutex. <br><br>  It is enough to add a few strokes to the picture described (this happens in complex systems): <br><ul><li>  inside one of the Worker object's consumers, a mutex M is captured (and then released, of course); </li><li>  another system object with a captured mutex M registers itself as a consumer of the Worker object. </li></ul><br>  Everything.  It turned out a situation in which interlocking is possible.  It will not occur in 100% of cases (a certain dynamics is necessary so that each of the participating threads has time to capture only one mutex), and this significantly complicates the search for such errors. <br><br>  The following are two ways to solve this problem. <br><br><h4>  Method 1: change the lock order </h4><br>  The Worker object will provide separate functions for blocking and unlocking its internal mutex, and the user will be registered as follows: <br><ol><li>  First, the internal mutex of the Worker object will be blocked (foreseen). </li><li>  After that, the consumer will perform actions that require the capture of the mutex M. </li><li>  The consumer will register with the Worker object;  no internal mutex is captured inside the Worker object. </li></ol><br>  The disadvantages of this method are obvious: <br><ul><li>  each consumer has the burden of preliminary actions before working with the Worker object;  the probability of error on the part of the programmer increases; </li><li>  this is not always possible at all: what if a secure access to the pointer to the Worker object was provided with the help of the M mutex? </li><li>  "Gut out" - it's just ugly. </li></ul><br><h4>  Method 2: Do not block the mutex when transferring data to consumers </h4><br>  This method sounds promising: if data is transferred from the internal flow of the Worker object to consumers when the mutexes are not locked, this will correct all possible deadlocks when working with the Worker object. <br><br>  Why not just make a callback when the mutex is not captured?  Because the flow of the Worker object must go through the list of registered consumers and call the interface function of each consumer.  If the list is not protected by the mutex, and the contents of the list change during this cycle, it is likely that the program will loop or even crash due to incorrect memory access. <br><br>  Why not make a copy of the list of consumers (when creating a copy, capture a mutex), and then go through a cycle on the copy?  Because you need to guarantee the consumer that after calling unregisterCallback data will not be transferred to him.  If the consumer calls unregisterCallback from his destructor, the subsequent transfer of data to the callback interface of this consumer will cause the program to crash. <br><br>  Thus, we almost came to the decision: <br><ul><li>  Worker's object flow must create a copy of the list of consumers before calling interfaces of registered consumers;  a copy is created when a captured mutex is captured; to transfer data to consumers, the thread makes a cycle on a copy of the list; </li><li>  it must be ensured that after the completion of the unregisterCallback call, no data will be passed to the consumer;  Since a copy of the list of consumers is created each time a call is received from a stream to consumers, the risk of a ‚Äúlate call‚Äù exists only once, if unregisterCallback is called during the passage through the copy of the list of consumers; </li><li>  and thus, it is necessary to somehow identify the state when the flow of the Worker object transmits data to consumers and works with a copy of the list of consumers;  if unregisterCallback is called when the stream is in this state, the return from unregisterCallback must be delayed until the data transfer to consumers is completed. </li></ul><br>  Here is a turnkey solution.  To implement it, you need another synchronization object - the ‚Äúcondition variable‚Äù (eng. Condition variable): <br><ul><li>  Worker object contains: <ul><li>  consumer list; </li><li>  a flag indicating that the stream is currently transmitting data to consumers; </li><li>  Mutex for differentiation of access to the list of consumers and the flag; </li><li>  conditional variable for organizing the expectation and awakening of the consumer that caused the unregisterCallback "at the wrong time"; </li></ul></li><li>  initially the flag is initialized to false; </li><li>  registerCallback captures the mutex, adds a consumer to the list and releases the mutex; </li><li>  the stream before the data transfer cycle to consumers performs the following actions: <ul><li>  captures the mutex; </li><li>  creates a copy of the list of consumers;  a copy is created on the thread stack; </li><li>  sets the flag to true; </li><li>  frees up mutex; </li></ul></li><li>  the stream transfers data to consumers, passing in a cycle over a copy of the list of consumers;  the mutex is not captured, but the flag is set; </li><li>  after transmitting data to consumers, the stream performs the following actions: <ul><li>  captures the mutex; </li><li>  resets the flag to false; </li><li>  using a condition variable wakes up all pending threads; </li><li>  frees up mutex; </li></ul></li><li>  and - the most interesting - unregisterCallback: <ul><li>  captures the mutex; </li><li>  removes a consumer from the list; </li><li>  as long as the flag is set, waits on a condition variable;  atomically with a transition to the idle state, the mutex is released, and atomically with awakening, the mutex is captured; </li><li>  frees up mutex. </li></ul></li></ul><br>  Important note: if unregisterCallback can be called from the callback interface implemented by the consumer, then the described algorithm will result in a 100% hang inside unregisterCallback.  This is easily solved: if unregisterCallback is called in the context of the internal flow of the Worker object, there is no need to check the flag and wait for the change of the condition variable. <br><br><h4>  Implementation using the Qt library synchronization tools </h4><br>  Header file: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICallback</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataReady</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QByteArray data)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QThread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Worker(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ICallback *callback)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unregisterCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ICallback *callback)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QMutex _mutex; QWaitCondition _wait; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _callingNow; QLinkedList&lt;ICallback *&gt; _callbacks; };</code> </pre> <br><br>  Implementation: <br><pre> <code class="cpp hljs">Worker::Worker() : QThread(), _mutex(QMutex::NonRecursive), _callingNow(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Worker::registerCallback(ICallback *callback) { <span class="hljs-function"><span class="hljs-function">QMutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;_mutex)</span></span></span></span>; _callbacks.append(callback); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Worker::unregisterCallback(ICallback *callback) { <span class="hljs-function"><span class="hljs-function">QMutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;_mutex)</span></span></span></span>; _callbacks.removeOne(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(QThread::currentThread()!=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(_callingNow) _wait.wait(&amp;_mutex); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Worker::run() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(...) { QByteArray data; ... QLinkedList&lt;ICallback *&gt; callbacksCopy; _mutex.lock(); _callingNow=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; callbacksCopy=_callbacks; _mutex.unlock(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(QLinkedList&lt;Callback *&gt;::const_iterator it=callbacksCopy.begin(); it!=callbacksCopy.end(); ++it) { (*it)-&gt;dataReady(data); } _mutex.lock(); _callingNow=<span class="hljs-literal"><span class="hljs-literal">false</span></span>; _wait.wakeAll(); _mutex.unlock(); } }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/175401/">https://habr.com/ru/post/175401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175381/index.html">Crazy skyscrapers of the future</a></li>
<li><a href="../175383/index.html">Disney kills Star Wars 1313 and dismisses employees of LucasArts</a></li>
<li><a href="../175385/index.html">But isn't it time for Habr√© to create your own investment fund for interesting ideas?</a></li>
<li><a href="../175397/index.html">Solder the connector for 4 hours. Accelerated video</a></li>
<li><a href="../175399/index.html">Ruby: about email in general and for the sake of validation without regexp, in particular</a></li>
<li><a href="../175403/index.html">Opera also moves to the Blink engine</a></li>
<li><a href="../175407/index.html">Useful for beginners to play Ingress</a></li>
<li><a href="../175409/index.html">Mosaic creates a single screen from multiple iPhones and iPads.</a></li>
<li><a href="../175411/index.html">Deploy dependencies in .NET</a></li>
<li><a href="../175413/index.html">2GIS for Windows Phone (real)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>