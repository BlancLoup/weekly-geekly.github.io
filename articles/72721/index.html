<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming Magic: the Gathering - ¬ß1 Mana</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to start posts about programming Magic: the Gathering (M: tG), and we will start with the simplest thing - the concept of "mana". Mana is what ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming Magic: the Gathering - ¬ß1 Mana</h1><div class="post__text post__text-html js-mediator-article"><img src="http://flashripper.net/wp-content/uploads/2008/03/magic_the_gathering_mana.jpg" align="right"><br>  I want to start posts about programming <a href="http://ru.wikipedia.org/wiki/Magic">Magic: the Gathering</a> (M: tG), and we will start with the simplest thing - the concept of "mana".  Mana is what all spells are paid for.  Despite the fact that it looks like only 5 types of mana, in fact everything is a bit more complicated.  Let's try to figure it out. <br><br><br><a name="habracut"></a><br>  Firstly, mana is not at all 5 types.  Even if you discard the "double" mana (when you can pay either one or the other), then there is still "colorless" mana, for which artifacts are bought, and which appears in the cost of many (most) spells.  Also - if we are talking about ‚Äúprice‚Äù and not about payment, mana X appears, i.e.  situation when the price is regulated by the rules. <br><br>  Consider a few examples. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Ordinary colors </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/20c/03c/fa0/20c03cfa07becbc1c3040f3d30e272cc.jpg" align="right">  Basic mana can be five colors, and mix as you like.  This is a direct hint that in any class that deals with mana there should be a model of these five colors.  Each element of the model, as is the case with the straightforward application of OOP, pulls a few more extras.  For example, a naive approach to implementing mana might look like this: <br><br><br><br> <code><font color="black"><font color="#0000FF">class</font> Mana <br> { <br> ‚ãÆ <br> <font color="#0000FF">public</font> <font color="#0000FF">int</font> Blue { get; set; } <br> <font color="#0000FF">public</font> <font color="#0000FF">bool</font> IsBlue { get { <font color="#0000FF">return</font> Blue &gt; 0; } } <br> <font color="#006400">//   </font> <br> } <br></font></code> <br>  While we are playing with the idea that the cost and the presence of mana in a pool can be contained in one entity, we can still fantasize a little bit.  For example, how to get a representation of mana in a text line (for example, WUBRG for Sliver Legion)?  Like this: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">string</font> ShortString <br> { <br> get <br> { <br> StringBuilder sb = <font color="#0000FF">new</font> StringBuilder(); <br> <font color="#0000FF">if</font> (Colorless &gt; 0) sb.Append(Colorless); <br> <font color="#0000FF">if</font> (Red &gt; 0) sb.Append( <font color="#570000">'R'</font> .Repeat(Red)); <br> <font color="#0000FF">if</font> (Green &gt; 0) sb.Append( <font color="#570000">'G'</font> .Repeat(Green)); <br> <font color="#0000FF">if</font> (Blue &gt; 0) sb.Append( <font color="#570000">'U'</font> .Repeat(Blue)); <br> <font color="#0000FF">if</font> (White &gt; 0) sb.Append( <font color="#570000">'W'</font> .Repeat(White)); <br> <font color="#0000FF">if</font> (Black &gt; 0) sb.Append( <font color="#570000">'B'</font> .Repeat(Black)); <br> <font color="#0000FF">if</font> (HasX) sb.Append( <font color="#570000">"X"</font> ); <br> <font color="#0000FF">return</font> sb.ToString(); <br> } <br> } <br></font></code> <br>  This is how I illustrate the weakness of the model.  If we did not know that there is a double mana (and we know), then subsequent changes would have caused an architectural apocalypse in our essence and everything with which it interacted.  This is the first. <br><br>  Secondly, writing the same thing 5+ times is bad.  Imagine that you are implementing a method for paying for a certain mana cost from a pool.  If you follow the same approach, you probably have to write something like this: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">void</font> PayFor(Mana cost) <br> { <br> <font color="#0000FF">if</font> (cost.Red &gt; 0) Red -= cost.Red; <br> <font color="#0000FF">if</font> (cost.Blue &gt; 0) Blue -= cost.Blue; <br> <font color="#0000FF">if</font> (cost.Green &gt; 0) Green -= cost.Green; <br> <font color="#0000FF">if</font> (cost.Black &gt; 0) Black -= cost.Black; <br> <font color="#0000FF">if</font> (cost.White &gt; 0) White -= cost.White; <br> <font color="#0000FF">int</font> remaining = cost.Colorless; <br> <font color="#0000FF">while</font> (remaining &gt; 0) <br> { <br> <font color="#0000FF">if</font> (Red &gt; 0) { --Red; --remaining; <font color="#0000FF">continue</font> ; } <br> <font color="#0000FF">if</font> (Blue &gt; 0) { --Blue; --remaining; <font color="#0000FF">continue</font> ; } <br> <font color="#0000FF">if</font> (Black &gt; 0) { --Black; --remaining; <font color="#0000FF">continue</font> ; } <br> <font color="#0000FF">if</font> (Green &gt; 0) { --Green; --remaining; <font color="#0000FF">continue</font> ; } <br> <font color="#0000FF">if</font> (White &gt; 0) { --White; --remaining; <font color="#0000FF">continue</font> ; } <br> <font color="#0000FF">if</font> (Colorless &gt; 0) { --Colorless; --remaining; <font color="#0000FF">continue</font> ; } <br> Debug.Fail( <font color="#570000">"Should not be here"</font> ); <br> } <br> } <br></font></code> <br>  The number of repetitions does not "rolls over", but certainly annoying.  Let me remind you that in C # there are no macros. <br><br><h3>  Colorless mana </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/d44/d56/d9fd44d56815c8eb3df746cf0b2ff796.jpg" align="right">  Colorless mana is the first hint that each type of mana draws upon itself domain-specific logic, which in principle is difficult to predict.  For example, the card on the right is a typical example of a kinder surprise when working with an inflexible domain like M: tG.  However, even using the same model (in C #), you can get several additional methods.  For example, here‚Äôs what the ‚Äúconverted value‚Äù property looks like: <br><br><br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">int</font> ConvertedManaCost <br> { <br> get <br> { <br> <font color="#0000FF">return</font> Red + Blue + Green + Black + White + Colorless; <br> } <br> } <br></font></code> <br>  If you want something more serious, then you can calculate whether the mana amount satisfies a certain cost: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">bool</font> EnoughToPay(Mana cost) <br> { <br> <font color="#0000FF">if</font> (Red &lt; cost.Red || Green &lt; cost.Green || White &lt; cost.White || <br> Blue &lt; cost.Blue || Black &lt; cost.Black) <br> <font color="#0000FF">return</font> <font color="#0000FF">false</font> ; <br> <font color="#006400">// can we pay the colourless price?</font> <br> <font color="#0000FF">return</font> ((Red - cost.Red) + (Green - cost.Green) + (White - cost.White) + <br> (Blue - cost.Blue) + (Black - cost.Black) + Colorless) &gt;= cost.Colorless; <br> } <br></font></code> <br>  Colorless mana, in contrast to color, reduces the degree of determinism, because  we cannot play the spell automatically if, for example, we paid RG for a card worth 1, because  it is not clear what color mana to pay. <br><br><h3>  Hybrid mana </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/046/d61/249/046d6124935780f4776e897e8b0a4a1c.jpg" align="right">  This is where it all begins ... because up to this point we thought that everything is very simple, and that you can for example take and predictably <code>2RG</code> line and get an object like <code>Mana</code> .  And here again - and the new rules, not only the mechanics, but also the records.  After all, how to write a double mana symbol?  Most likely this way: <code>{WB}{WB}{WB}</code> .  Vooot, and for this you need a parser. <br><br>  Moreover, imagine that mana has multiplied like slivers ‚Äî purple, purple, and so on appeared.  Is it easy to add support for new mana in those pieces of code that I quoted above?  That's right - it's <em>unrealistically difficult</em> .  Need a different approach. <br><br>  Before we look at this very ‚Äúdifferent approach‚Äù, it should be mentioned that cost and payment are two different things.  More precisely, they are similar, but the cost, for example, may contain an <code>X</code> icon.  For example, pay <code>XG</code> and get <code>X</code> life.  In order not to produce entities, I still think that the essence of <code>Mana</code> should be one.  The situation with <code>X</code> can be razrulit single ( <code>public bool HasX</code> ), but you can summarize a little, so if suddenly there is a card with a value of <code>XY</code> , we do not have to rewrite all the logic.  In addition, there are situations when you can pay for a certain <code>X</code> only with mana of a certain color.  This also needs to be taken into account. <br><br><h3>  Pro metaprogramming </h3><br>  It seems to me that in this task you need metaprogramming, at least in order to avoid unnecessary code duplication and also to protect yourself from such cases when, for example, you suddenly need to add Observable support (say, through individual events) without rewriting each class property.  C # is not suitable for such purposes (even if PostSharp is available).  We need something that can take into account our goals, namely: <br><br><ul><li>  Maintain color mana with an arbitrary number of colors.  That is, for example, adding <font color="#ff00ff">lilac</font> mana should not break the system and should carry only minor changes in the code. </li><li>  Maintain hybrid mana.  I think that there will be no mana and more mana, so you can simply make the support of the double mana of all existing colors.  Moreover, when adding a new type of ‚Äúprimary‚Äù mana, there is no need to carry out additional actions for its ‚Äúhybridization‚Äù. </li><li>  Properly maintain colorless mana as well as operations with it. </li><li>  Maintain standard mana notation, i.e.  have a parser that can build a <code>Mana</code> object from a string. </li></ul><br>  So, let's see how you can gradually implement all the above properties in a language that supports metaprogramming.  Of course, I'm talking about the language of Boo.  (Although there is still Nemerle, but I am not strong in it.) <br><br><h3>  Ordinary colors (attempt number 2) </h3><br><img src="http://wiki.mtgsalvation.com/images/thumb/9/98/Color_wheel.jpg/350px-Color_wheel.jpg" align="right">  <strong>Nb</strong> here and on will go the calculations in two languages ‚Äã‚Äãat once - on Boo (what we wrote) and on C # (what Reflector saw in this).  This is done in order to illustrate the actions of macros and meta-methods, since  Boo itself, as you can guess, will not be transparent in this regard. <br><br>  I would like to write "so, let's start with a simple one," but it will not be easy, alas.  To begin with, we will do two projects, namely <br><br><ul><li>  <code>MagicTheGathering.Entities</code> for entities such as <code>Mana</code> .  This assembly can <code>ILMerge</code> with other assemblies written in C # or F #. </li><li>  <code>MagicTheGathering.Meta</code> for our meta-abstractions that will "collect" our entities. </li></ul><br><h3>  Fields </h3><br>  Let's start with the support of forests: <br><br><br><br> <code><font color="black">[ManaType( <font color="#570000">"Green"</font> , <font color="#570000">"G"</font> , <font color="#570000">"Forest"</font> )] <br> <font color="#0000FF">class</font> Mana: <br> <font color="#0000FF">public</font> <font color="#0000FF">def</font> <font color="#0000FF">constructor</font> (): <br> <font color="#0000FF">pass</font> <br></font></code> <br>  So, we put on our manaclass attributes of different lands, starting with the forests.  What do we need from these attributes?  First, they need to add the appropriate fields.  It's simple: <br><br> <code><font color="black"><font color="#0000FF">class</font> ManaTypeAttribute(AbstractAstAttribute): <br> colorName <font color="#0000FF">as</font> string <br> colorAbbreviation <font color="#0000FF">as</font> string <br> landName <font color="#0000FF">as</font> string <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">def</font> <font color="#0000FF">constructor</font> (colorName <font color="#0000FF">as</font> StringLiteralExpression, <br> colorAbbreviation <font color="#0000FF">as</font> StringLiteralExpression, landName <font color="#0000FF">as</font> StringLiteralExpression): <br> <font color="#0000FF">self</font> .colorName = colorName.Value <br> <font color="#0000FF">self</font> .colorAbbreviation = colorAbbreviation.Value <br> <font color="#0000FF">self</font> .landName = landName.Value <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> <font color="#0000FF">def</font> Apply(node <font color="#0000FF">as</font> Node): <br> AddField(node) <br> <br> <font color="#0000FF">private</font> <font color="#0000FF">def</font> AddField(node <font color="#0000FF">as</font> Node): <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> f = [| <br> $(colorName.ToLower()) <font color="#0000FF">as</font> Int32 <br> |] <br> c.Members.Add(f) <br></font></code> <br>  So, we have defined a constructor for an attribute that is called from our original entity.  In the example above, we add a field to an already existing class.  This is done in three steps: <br><br><ul><li>  First, we provide the element to which the attribute is applied to the type <code>ClassDefinition</code> </li><li>  Then, we create a field using a splice (we turn the content of the string <code>colorName</code> into the real name of the field) and a quote (the brackets <code>[|</code> and <code>|]</code> turn our construct into an element of the property </li><li>  Add the collected property to the class. </li></ul><br>  Let's now compare the original and final result: <br><br><table><tbody><tr><td>  Boo </td><td>  C # </td></tr><tr><td> <code><font color="black">[ManaType( <font color="#570000">"Green"</font> , <font color="#570000">"G"</font> , <font color="#570000">"Forest"</font> )] <br> <font color="#0000FF">class</font> Mana: <br> <font color="#0000FF">public</font> <font color="#0000FF">def</font> <font color="#0000FF">constructor</font> (): <br> <font color="#0000FF">pass</font> <br></font></code> <br></td><td> <code><font color="black">[Serializable] <br> <font color="#0000FF">public</font> <font color="#0000FF">class</font> Mana <br> { <br> <font color="#006400">// Fields</font> <br> <font color="#0000FF">protected</font> <font color="#0000FF">int</font> green; <br> } <br></font></code> <br></td></tr></tbody></table><br><h3>  Direct and derived properties </h3><br>  Hmm, isn't this what we wanted?  :) How about building a simple property over this field?  Elementary, Watson - you only need to change the definition of <code>AddField()</code> : <br><br> <code><font color="black"><font color="#0000FF">private</font> <font color="#0000FF">def</font> AddField(node <font color="#0000FF">as</font> Node): <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> r = ReferenceExpression(colorName) <br> f = [| <br> [Property($r)] <br> $(colorName.ToLower()) <font color="#0000FF">as</font> Int32 <br> |] <br> c.Members.Add(f) <br></font></code> <br>  Let's now create a test field, for example, let <code>IsGreen</code> return us <code>true</code> if the map is green and <code>false</code> if not.  This property we will meet again, because  It interacts specifically with hybrid maps.  Here is my first attempt to implement it: <br><br> <code><font color="black"><font color="#0000FF">private</font> <font color="#0000FF">def</font> AddIndicatorProperty(node <font color="#0000FF">as</font> Node): <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> r = ReferenceExpression(colorName) <br> f = [| <br> $( <font color="#570000">"Is"</font> + colorName) <font color="#0000FF">as</font> bool: <br> <font color="#0000FF">get</font> : <br> <font color="#0000FF">return</font> ($r &gt; 0); <br> |] <br> c.Members.Add(f) <br></font></code> <br>  Implementing a derived property was also very easy.  And this is how it all looks translated to C #: <br><br> <code><font color="black">[Serializable] <br> <font color="#0000FF">public</font> <font color="#0000FF">class</font> Mana <br> { <br> <font color="#006400">// Fields</font> <br> <font color="#0000FF">protected</font> <font color="#0000FF">int</font> green; <br> <font color="#006400">// Properties</font> <br> <font color="#0000FF">public</font> <font color="#0000FF">int</font> Green <br> { <br> get <br> { <br> <font color="#0000FF">return</font> <font color="#0000FF">this</font> .green; <br> } <br> set <br> { <br> <font color="#0000FF">this</font> .green = <font color="#0000FF">value</font> ; <br> } <br> } <br> <font color="#0000FF">public</font> <font color="#0000FF">bool</font> IsGreen <br> { <br> get <br> { <br> <font color="#0000FF">return</font> ( <font color="#0000FF">this</font> .Green &gt; 0); <br> } <br> } <br> } <br></font></code> <br><h3>  Interaction </h3><br>  Let's try to auto-generate the total cost (converted mana cost).  To do this, you need to realize a colorless mana that, in fact, is not so difficult.  But how to autogenerate the sum of all the colors of mana + colorless?  To do this, we apply the following approach: <br><br><ol><li>  First, we will create a new attribute, and in it - a list of those properties that need to be summarized <br> <code><font color="black"><font color="#0000FF">class</font> ManaSumAttribute(AbstractAstAttribute): <br> <font color="#0000FF">static</font> <font color="#0000FF">public</font> LandTypes <font color="#0000FF">as</font> List = [] <br> ‚ãÆ <br></font></code> <br></li><li>  Now, when creating any "property of the earth", we will write the name in this static property: <br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">def</font> <font color="#0000FF">constructor</font> (colorName <font color="#0000FF">as</font> StringLiteralExpression, <br> ‚ãÆ <br> ManaSumAttribute.LandTypes.Add( <font color="#0000FF">self</font> .colorName) <br></font></code> <br></li><li>  And now we use this property to create a sum: <br> <code><font color="black"><font color="#0000FF">class</font> ManaSumAttribute(AbstractAstAttribute): <br> ‚ãÆ <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> <font color="#0000FF">def</font> Apply(node <font color="#0000FF">as</font> Node): <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> root = [| Colorless |] <font color="#0000FF">as</font> Expression <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(LandTypes.Count): <br> root = BinaryExpression(BinaryOperatorType.Addition, <br> root, ReferenceExpression(LandTypes[i] <font color="#0000FF">as</font> string)) <br> p = [| <br> <font color="#0000FF">public</font> ConvertedManaCost: <br> <font color="#0000FF">get</font> : <br> <font color="#0000FF">return</font> $root <br> |] <br> c.Members.Add(p) <br></font></code> <br></li></ol><br>  Now let's check - add support for the mountains (mountain) and see what is being emitted for the <code>ConvertedManaCost</code> property.  Here is what we get: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">int</font> ConvertedManaCost <br> { <br> get <br> { <br> <font color="#0000FF">return</font> (( <font color="#0000FF">this</font> .Colorless + <font color="#0000FF">this</font> .Green) + <font color="#0000FF">this</font> .Red); <br> } <br> } <br></font></code> <br>  As you can see, everything works :) <br><br><h3>  Hybrid land support </h3><br>  Okay, we started getting something.  I add support for all lands to the code and cheers, now Boo autogenerates 10 properties for them, plus it does the sum.  What else is needed?  Well, how about supporting hybrid land.  This is certainly more difficult, because  need to take <em>all the pairs of</em> existing lands.  But it‚Äôs interesting, so why not try it? <br><br>  The principle is the same as with the amount generator - use a static field and fill it with attributes of different mana.  And then‚Ä¶.  then a very complicated thing.  In short, we are looking for all valid mana pairs and for them we create approximately the same properties as for normal, ‚Äúsame type‚Äù mana. <br><br> <code><font color="black"><font color="#0000FF">class</font> HybridManaAttribute(AbstractAstAttribute): <br> <font color="#0000FF">static</font> <font color="#0000FF">public</font> LandTypes <font color="#0000FF">as</font> List = [] <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> <font color="#0000FF">def</font> Apply(node <font color="#0000FF">as</font> Node): <br> mergedTypes <font color="#0000FF">as</font> List = [] <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(LandTypes.Count): <br> <font color="#0000FF">for</font> j <font color="#0000FF">in</font> range(LandTypes.Count): <br> <font color="#0000FF">unless</font> (mergedTypes.Contains(string.Concat(LandTypes[i], LandTypes[j])) <font color="#0000FF">or</font> <br> mergedTypes.Contains(string.Concat(LandTypes[j], LandTypes[i])) <font color="#0000FF">or</font> <br> i == j): <br> mergedTypes.Add(string.Concat(LandTypes[i], LandTypes[j])) <br> <font color="#006400">// each merged type becomes a field+property pair</font> <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> <font color="#0000FF">for</font> n <font color="#0000FF">in</font> range(mergedTypes.Count): <br> name = mergedTypes[n] <font color="#0000FF">as</font> string <br> r = ReferenceExpression(name) <br> f = [| <br> [Property($r)] <br> $(name.ToLower()) <font color="#0000FF">as</font> int <br> |] <br> c.Members.Add(f) <br></font></code> <br>  I will not give the result, because many properties are obtained :) Let's better discuss what to do with properties like <code>IsGreen</code> in the case of hybrid mana.  After all, we can no longer keep them in the attributes of uniform mana, because  At that time, nothing was known about the hybrid mana.  Let's move them to a separate attribute.  So, we need to use both hybrid and single properties in order to understand the color of the map. <br><br> <code><font color="black"><font color="#0000FF">class</font> ManaIndicatorsAttribute(AbstractAstAttribute): <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> <font color="#0000FF">def</font> Apply(node <font color="#0000FF">as</font> Node): <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(ManaSumAttribute.LandTypes.Count): <br> basic = ManaSumAttribute.LandTypes[i] <font color="#0000FF">as</font> string <br> hybridLands <font color="#0000FF">as</font> List = [] <br> <font color="#0000FF">for</font> j <font color="#0000FF">in</font> range(HybridManaAttribute.HybridLandTypes.Count): <br> hybrid = HybridManaAttribute.HybridLandTypes[j] <font color="#0000FF">as</font> string <br> <font color="#0000FF">if</font> (hybrid.Contains(basic)): <br> hybridLands.Add(hybrid) <br> rbasic = ReferenceExpression(basic.ToLower()) <br> b = Block(); <br> b1 = [| <font color="#0000FF">return</font> <font color="#0000FF">true</font> <font color="#0000FF">if</font> $rbasic &gt; 0 |] <br> b.Statements.Add(b1) <br> <font color="#0000FF">for</font> k <font color="#0000FF">in</font> range(hybridLands.Count): <br> rhybrid = ReferenceExpression((hybridLands[k] <font color="#0000FF">as</font> string).ToLower()) <br> b2 = [| <font color="#0000FF">return</font> <font color="#0000FF">true</font> <font color="#0000FF">if</font> $rhybrid &gt; 0 |] <br> b.Statements.Add(b2) <br> r = [| <br> $( <font color="#570000">"Is"</font> + basic): <br> <font color="#0000FF">get</font> : <br> $b; <br> |] <br> c.Members.Add(r) <br></font></code> <br>  Voila!  In the code above, we find all the types of mana that this type affects, and compare them to zero.  This is not the most optimal way to calculate the <code>IsXxx</code> property, but it works, although at the Reflector level such a mess is obtained. <br><br><h3>  String representation and parser </h3><br>  For each simple type of mana, we have a string representation.  This view allows us to both read a string and receive it.  Let's start with a simple one - we get a string representation of the mana, which we will issue via <code>ToString()</code> : <br><br> <code><font color="black"><font color="#0000FF">class</font> ManaStringAttribute(AbstractAstAttribute): <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> def Apply(node <font color="#0000FF">as</font> Node): <br> b = Block() <br> b1 = [| <br> sb.Append(colorless) <font color="#0000FF">if</font> colorless &gt; 0 <br> |] <br> b.Statements.Add(b1) <br> <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(ManaTypeAttribute.LandTypes.Count): <br> land = ReferenceExpression((ManaTypeAttribute.LandTypes[i] <font color="#0000FF">as</font> <font color="#0000FF">string</font> ).ToLower()) <br> abbr = StringLiteralExpression(ManaTypeAttribute.LandAbbreviations[i] <font color="#0000FF">as</font> <font color="#0000FF">string</font> ) <br> b2 = [| <br> sb.Append($abbr) <font color="#0000FF">if</font> $land &gt; 0; <br> |] <br> b.Statements.Add(b2) <br> <br> <font color="#0000FF">for</font> j <font color="#0000FF">in</font> range(HybridManaAttribute.HybridLandTypes.Count): <br> land = ReferenceExpression((HybridManaAttribute.HybridLandTypes[j] <font color="#0000FF">as</font> <font color="#0000FF">string</font> ).ToLower()) <br> abbr = StringLiteralExpression( <font color="#570000">"{"</font> + <br> (HybridManaAttribute.HybridLandAbbreviations[j] <font color="#0000FF">as</font> <font color="#0000FF">string</font> ) + <font color="#570000">"}"</font> ) <br> b3 = [| <br> sb.Append($abbr) <font color="#0000FF">if</font> $land &gt; 0; <br> |] <br> b.Statements.Add(b3) <br> <br> b3 = [| <br> sb.Append( <font color="#570000">"X"</font> ) <font color="#0000FF">if</font> hasX <br> |] <br> <br> m = [| <br> <font color="#0000FF">public</font> <font color="#0000FF">override</font> def ToString(): <br> sb = StringBuilder(); <br> $b <br> <font color="#0000FF">return</font> sb.ToString() <br> |] <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> c.Members.Add(m) <br></font></code> <br>  Well, we have almost everything, all that remains is to add the most important thing - the mana description parser, that is  so that the program can create the corresponding object from the <code>2GG{RW}</code> line.  Let's divide the manaparser into 3 parts - the analysis of base mana, hybrid mana, and "everything else".  So, basic mana is not difficult to disassemble: <br><br> <code><font color="black"><font color="#006400">// basic land cases are in a separate block</font> <br> basicLandCases = Block() <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(ManaTypeAttribute.LandTypes.Count): <br> name = ManaTypeAttribute.LandTypes[i] <font color="#0000FF">as</font> string <br> abbr = ManaTypeAttribute.LandAbbreviations[i] <font color="#0000FF">as</font> string <br> rAbbr = CharLiteralExpression( <font color="#0000FF">char</font> .ToUpper(abbr[0])) <br> rName = ReferenceExpression(name) <br> case = [| <br> <font color="#0000FF">if</font> ( <font color="#0000FF">char</font> .ToUpper(spec[i]) == $rAbbr): <br> m.$rName = m.$rName + 1 <br> <font color="#0000FF">continue</font> <br> |] <br> basicLandCases.Statements.Add(case); <br></font></code> <br>  You need to tinker with hybrid mana, so that the order of writing mana ( <code>RG</code> or <code>GR</code> ) does not affect the parser.  However, the solution is not very complicated: <br><br> <code><font color="black"><font color="#006400">// hybrid land cases are in a much smarter block</font> <br> hybridLandCases = Block() <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(HybridManaAttribute.HybridLandTypes.Count): <br> name = HybridManaAttribute.HybridLandTypes[i] <font color="#0000FF">as</font> string <br> abbr = HybridManaAttribute.HybridLandAbbreviations[i] <font color="#0000FF">as</font> string <br> <font color="#006400">// build an appreviation literal</font> <br> abbr1 = StringLiteralExpression(abbr) <br> abbr2 = StringLiteralExpression(abbr[1].ToString() + abbr[0].ToString()) <br> case = [| <br> <font color="#0000FF">if</font> (s == $abbr1 <font color="#0000FF">or</font> s == $abbr2): <br> m.$name = m.$name + 1 <br> <font color="#0000FF">continue</font> <br> |] <br> hybridLandCases.Statements.Add(case) <br></font></code> <br>  Well, then you can do the method itself as a set of cases.  In addition to color mana, we add support for colorless mana, as well as the <code>X</code> symbol: <br><br> <code><font color="black"><font color="#006400">// the method itself</font> <br> method = [| <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">def</font> Parse(spec <font color="#0000FF">as</font> string) <font color="#0000FF">as</font> Mana: <br> sb = StringBuilder() <br> cb = StringBuilder() <font color="#006400">// composite builder</font> <br> inHybrid = <font color="#0000FF">false</font> <font color="#006400">// set when processing hybrid mana</font> <br> m = Mana() <br> <font color="#0000FF">for</font> i <font color="#0000FF">in</font> range(spec.Length): <br> <font color="#0000FF">if</font> (inHybrid): <br> cb.Append(spec[i]) <br> <font color="#0000FF">continue</font> <br> <font color="#0000FF">if</font> ( <font color="#0000FF">char</font> .IsDigit(spec[i])): <br> sb.Append(spec[i]) <br> <font color="#0000FF">continue</font> ; <br> <font color="#0000FF">if</font> (spec[i] == <font color="#570000">'{'</font> ): <br> inHybrid = <font color="#0000FF">true</font> <br> <font color="#0000FF">continue</font> <br> <font color="#0000FF">if</font> (spec[i] == <font color="#570000">'}'</font> ): <br> <font color="#0000FF">raise</font> ArgumentException( <font color="#570000">"Closing } without opening"</font> ) <font color="#0000FF">if</font> <font color="#0000FF">not</font> inHybrid <br> inHybrid = <font color="#0000FF">false</font> <br> s = cb.ToString().ToUpper() <br> <font color="#0000FF">raise</font> ArgumentException( <font color="#570000">"Only two-element hybrids supported"</font> ) <font color="#0000FF">if</font> s.Length != 2 <br> $hybridLandCases <br> <font color="#0000FF">raise</font> ArgumentException( <font color="#570000">"Hybrid mana "</font> + s + <font color="#570000">" is not supported"</font> ) <br> $basicLandCases <br> <font color="#0000FF">if</font> ( <font color="#0000FF">char</font> .ToUpper(spec[i]) == <font color="#570000">'X'</font> ): <br> m.HasX = <font color="#0000FF">true</font> <br> <font color="#0000FF">continue</font> ; <br> |] <br> <font color="#006400">// add it</font> <br> c = node <font color="#0000FF">as</font> ClassDefinition <br> c.Members.Add(method) <br></font></code> <br>  I will not give the result of this macro, since  a <em>lot of</em> code is generated. <br><br><h3>  Conclusion </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/529/754/8e2/5297548e2b8ef25f7ce4503766e1f45a.jpg" align="right">  Despite the fact that we haven‚Äôt disassembled several cases, such as paying a mana for a certain spell, I‚Äôll probably stop - partly because Firefox is already starting to fall on the number of characters in the textbox.  I hope that this post has illustrated how difficult it is to make extensible entities, and the fact that sometimes metaprogramming is not optional.  By the way, the full code (I can not vouch for its correctness at this stage) can be found <a href="http://pastebin.com/f27c2f561">here</a> .  Boo is ruthless. <br><br>  Oh yes, as far as our essence is concerned, now it looks like this: <br><br><br><br> <code><font color="black">[ManaType( <font color="#570000">"Green"</font> , <font color="#570000">"G"</font> , <font color="#570000">"Forest"</font> )] <br> [ManaType( <font color="#570000">"Red"</font> , <font color="#570000">"R"</font> , <font color="#570000">"Mountain"</font> )] <br> [ManaType( <font color="#570000">"Blue"</font> , <font color="#570000">"U"</font> , <font color="#570000">"Island"</font> )] <br> [ManaType( <font color="#570000">"Black"</font> , <font color="#570000">"B"</font> , <font color="#570000">"Swamp"</font> )] <br> [ManaType( <font color="#570000">"White"</font> , <font color="#570000">"W"</font> , <font color="#570000">"Plains"</font> )] <br> [ManaSum] <br> [HybridMana] <br> [ManaIndicators] <br> [ManaString] <br> [ManaParser] <br> <font color="#0000FF">class</font> Mana: <br> [Property(Colorless)] <br> colorless <font color="#0000FF">as</font> int <br> [Property(HasX)] <br> hasX <font color="#0000FF">as</font> bool <br></font></code> <br>  This is really all.  Comments welcome.  ‚ñ† </div><p>Source: <a href="https://habr.com/ru/post/72721/">https://habr.com/ru/post/72721/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../72712/index.html">We calculate bad bots</a></li>
<li><a href="../72714/index.html">Correctly and conveniently recoded mp3 tags in UTF-8</a></li>
<li><a href="../72715/index.html">We hand over the bottle playing?</a></li>
<li><a href="../72716/index.html">PHPunit implementation practice</a></li>
<li><a href="../72720/index.html">Motorola Droid - new analog iPhone with OS Android</a></li>
<li><a href="../72722/index.html">TV slot machine "Highway"</a></li>
<li><a href="../72723/index.html">What awaits us in AIR 2.0</a></li>
<li><a href="../72724/index.html">An example of a good promotional site</a></li>
<li><a href="../72729/index.html">Securelist.com - XSS and SQL Injection vulnerabilities</a></li>
<li><a href="../72730/index.html">The Large Hadron Collider. Appeared on Earth one of the coldest places in the universe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>