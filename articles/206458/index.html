<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Auto and decltype secrets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The new standard of the language was adopted relatively long ago and now, probably, there is no programmer who has not heard about the new keywords au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Auto and decltype secrets</h1><div class="post__text post__text-html js-mediator-article">  The new standard of the language was adopted relatively long ago and now, probably, there is no programmer who has not heard about the new keywords <i>auto</i> and <i>decltype</i> .  But as with almost every aspect of C ++, the use of these new tools is not without nuances.  Some of them I will try to highlight in this article. <br><a name="habracut"></a><br>  To warm up, I suggest starting with a little test. <br><h5>  Test </h5><br>  1. What type will the ri1..riN variables appear after executing the following code? <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ri = foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ri1 = foo1(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ri2 = foo2(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ri3 = foo3(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ri4 = foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ri5 = foo1(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ri6 = foo2(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ri7 = foo3(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; ri8 = foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; ri9 = foo1(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; ri10 = foo2(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; ri11 = foo3(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(k)&amp;&amp; rk = k; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo())&amp;&amp; ri12 = foo(); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo1())&amp;&amp; ri13 = foo1(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i) ri14; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>((i)) ri15; }</code> </pre> <br>  Will the following fragments be compiled? <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lmbd = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i){...}; <span class="hljs-number"><span class="hljs-number">3.</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">4.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) var = some_expression; <span class="hljs-comment"><span class="hljs-comment">//WTF?! 5. auto var = {1, 2, 3}; // ,     var? 6. template&lt;typename T&gt; void foo(T t){} foo({1, 2, 3});</span></span></code> </pre><br><h5>  Theory </h5><br>  Two new mechanisms have been added to the type inference mechanism used in templates in C ++ 11: <i>auto</i> and <i>decltype</i> .  And so that the life of programmers does not seem to be honey, all these 3 mechanisms deduce types in their own way.  The mechanism used by <i>auto</i> exactly copies the template mechanism, except for the type <i>std :: initializer_list</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> var = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// Ok, var    std::initializer_list&lt;int&gt; template&lt;typename T&gt; void foo(T t); foo({1, 2, 3}); //  </span></span></code> </pre><br><br>  There are few explanations for this behavior and all of them do not differ in intelligibility.  Scott Meyers, for example, writes on this subject as follows: <i>‚ÄúI‚Äôm not a concept.</i>  <i>If you know, please tell me! ‚Äù</i> .  In C ++ 14, they are not going to change this mechanism.  For an explanation, you can try to accept the fact that such amazing things work, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill_from_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; cont, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; l)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; fill_from_list(v, {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>});</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Auto </h6><br>  So, how does the `auto` type output?  Unfortunately, there is no simple rule for all occasions, except, perhaps, the fact that `auto`, in its type inference, generally throws away cv qualifiers and references.  Below I will list the most important points. <br><br>  one. <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> var = some_expression;</code> </pre><br>  If the type <i>some_expression</i> <i>T *</i> or <i>const T *</i> , then the type var will also be <i>T *</i> or <i>const T *,</i> respectively.  So far, no surprises.  Further - more interesting.  Perhaps the most important rule from a practical point of view is that if the type <i>some_expression</i> is <i>T</i> , <i>const T</i> , <i>T &amp;</i> or <i>const T &amp;</i> , <b>then the type var will be T.</b>  This, however, if you think about it, is quite logical, because in this case, the value returned by <i>some_expression is</i> copied into var and you can safely write like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">widget_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> w = l.front(); l.pop(); <span class="hljs-comment"><span class="hljs-comment">// work with `w` here }</span></span></code> </pre><br><br>  2 <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; var = some_expression;</code> </pre><br>  In this case, it is expected if the type <i>some_expression</i> is <i>T</i> or <i>const T</i> , it will not compile, since the <i>lvalue</i> reference cannot be initialized to <i>rvalue</i> .  If the type <i>some_expression</i> is <i>T &amp;</i> , then var will be of type <i>T &amp;</i> .  The important point here is that if the type <i>some_expression</i> is <i>const T &amp;</i> , then the type var will be <i>const T &amp;</i> . <br><br>  3 <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; var = some_expression;</code> </pre><br>  The rule of ‚Äúuniversal links‚Äù invented (or at least sounded by Scott Meyers) is in effect here.  It lies in the fact that the type of <i>var</i> will depend on what <i>value category</i> in <i>some_expression</i> .  If <i>rvalue</i> , then the type of <i>var</i> will be <i>T &amp;&amp;</i> , if <i>lvalue</i> , then <i>T &amp;</i> .  <i>Cv</i> qualifiers are preserved. <br><br><h6>  Auto as a function parameter </h6><br>  <i>auto</i> cannot be used as a parameter of a function and changes in this behavior are not expected.  Obviously, the point here is that if this were allowed, then it turns out that any ordinary function could be declared essentially implicitly template.  And it becomes unclear how to resolve the overload.  Imagine this situation: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v1+v2)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span></span>; foo(‚ÄúC++ is cool?‚Äù, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  However, in c ++ 14 it will be possible to use <i>auto</i> parameters in lambdas. <br><br><h6>  decltype </h6><br>  With <i>decltype, the</i> situation on the one hand is more complicated (if you look at formal rules), on the other hand it is simpler (if you highlight the main points).  I will formulate these rules as I understood them. <br>  So, it is necessary to distinguish two main cases of <i>decltype</i> . <br>  1. <i>decltype (var)</i> , when <i>var</i> is a declared variable (for example, in a function or as a member of a class).  In this case, <i>decltype (var)</i> will have exactly the type with which the variable is declared. <br>  2. <i>decltype (expr)</i> , <i>expr</i> - expression.  In this case, the <i>decltype (expr)</i> type will be a type that <b>could return this expression</b> , with the proviso that <i>decltype (expr)</i> will be of type <i>T &amp;</i> ( <i>const T &amp;</i> ) if <i>expr</i> returns <i>lvalue</i> , <i>T</i> if <i>expr</i> returns <i>rvalue of</i> type <i>T</i> ( <i>const T</i> ) and <i>T &amp;&amp;</i> ( <i>const T &amp;&amp;</i> ), if expr returns <i>xvalue</i> ( <i>rvalue reference</i> ). <br><br>  What does ‚Äúcould return‚Äù mean?  This means that <i>decltype</i> does not evaluate the expression passed to it as an argument. <br>  A few explanatory examples: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i); <span class="hljs-comment"><span class="hljs-comment">// int decltype(i + 1); // int decltype((i)); // int&amp; decltype(i = 4); //int&amp; const int foo(); decltype(foo()) ;// int int&amp;&amp; foo1(); decltype(foo1()) ;// int&amp;&amp;</span></span></code> </pre><br><br>  In the event that we do not know <i>lvalue, the</i> expression will return, <i>rvalue</i> or <i>xvalue</i> , and we want to use the type, we can use the standard <i>std :: remove_reference template</i> to ‚Äúclear‚Äù the type from the links. <br><br><h6>  Decltype (auto) </h6><br>  This is a new ‚Äúfeature‚Äù of the language, which will be included in C ++ 14.  It is needed to preserve <i>decltype</i> semantics when declaring <i>auto</i> variables and will be used in cases when we are not satisfied with <i>auto</i> discarding references and cv qualifiers and, possibly, in conjunction with the new C ++ 14 feature - output of the value returned by the function . <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = foo(); <span class="hljs-comment"><span class="hljs-comment">// i    int dectype(auto) i2 = foo(); // i2    const int&amp;&amp;</span></span></code> </pre><br>  In the latter case, we could write <i>decltype (foo ())</i> , but imagine if there was an expression for 2 lines instead of <i>foo ()</i> , and such in C ++ is not uncommon. <br><br><h5>  Answers </h5><br>  Well, now, having loaded the theory into the cache, you can try to answer the questions of the test. <br><br>  one. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ri = foo(); <span class="hljs-comment"><span class="hljs-comment">// int auto ri1 = foo1(); // int auto ri2 = foo2(); // int auto ri3 = foo3(); // int auto&amp; ri4 = foo(); //   auto&amp; ri5 = foo1(); // int&amp; auto&amp; ri6 = foo2(); //   auto&amp; ri7 = foo3(); // const int&amp; auto&amp;&amp; ri8 = foo(); // int&amp;&amp; auto&amp;&amp; ri9 = foo1(); // int&amp; auto&amp;&amp; ri10 = foo2(); // const int&amp;&amp; auto&amp;&amp; ri11 = foo3(); // const int&amp; int k = 5; decltype(k)&amp;&amp; rk = k; //   decltype(foo())&amp;&amp; ri12 = foo(); // int&amp;&amp; decltype(foo1())&amp;&amp; ri13 = foo1(); // int&amp; int i = 3; decltype(i) ri14; // int decltype((i)) ri15; // int&amp; }</span></span></code> </pre><br>  Will the following fragments be compiled? <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lmbd = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i){...}; <span class="hljs-comment"><span class="hljs-comment">//  - ,   ++14 -  3. void foo(auto i); //  4. decltype(auto) var = some_expression; // ,  ++14 5. auto var = {1, 2, 3}; // ,  = std::initializer_list&lt;int&gt; 6. template&lt;typename T&gt; void foo(T t){} foo({1, 2, 3}); // </span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/206458/">https://habr.com/ru/post/206458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206442/index.html">Laravel: Dependency Injection in practice</a></li>
<li><a href="../206444/index.html">Chicago woodpile - 1: The world's first nuclear reactor</a></li>
<li><a href="../206448/index.html">Mobidapter genial adapter of the past</a></li>
<li><a href="../206454/index.html">Simple interpreter from scratch in Python # 2</a></li>
<li><a href="../206456/index.html">Meteor version 0.7.0 released</a></li>
<li><a href="../206460/index.html">How to make yourself work?</a></li>
<li><a href="../206464/index.html">Mobile VDS server management</a></li>
<li><a href="../206468/index.html">Solving Major CAPTCHA Problems</a></li>
<li><a href="../206472/index.html">Recover deleted contacts with Apple iPhone. 9 easy steps</a></li>
<li><a href="../206478/index.html">Preparing for the CCIE labe at home</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>