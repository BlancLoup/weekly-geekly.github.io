<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to deal with unstable Google C2DM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It just so happens that at work I‚Äôm working with a small team of like-minded people to write applications for smartphones, in particular, iTelephone a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to deal with unstable Google C2DM</h1><div class="post__text post__text-html js-mediator-article">  It just so happens that at work I‚Äôm working with a small team of like-minded people to write applications for smartphones, in particular, iTelephone and Android. <br><br>  We started with the development of the iPhone, where everything worked smoothly and as expected. <br>  And what worked?  The main task of the application was to send the request ‚ÄúWhere are you?‚Äù - nothing complicated.  But I would really like to deliver this request to the addressee as quickly as possible while it is still relevant.  Here, having experience in the development of the iPhone, the reader will say that there is <abbr title="Apple Push Notification">APN</abbr> Service, and will be absolutely right.  It was to them that we used and did not know grief, for these notifications were delivered faster than a second. <br><br>  Then, for some internal reasons, we switched to development for Android and quickly ported everything.  In particular, without any <abbr title="Cloud To Device Messaging">hindsight, the</abbr> module for working with <abbr title="Apple Push Notification">APN</abbr> was replaced by a similar one with <abbr title="Cloud To Device Messaging">C2DM</abbr> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All developers' phones had no delivery problems.  But the new users immediately discovered a huge problem - the delivery time for the notification is not guaranteed at all, and some of them arrived in a few hours.  And on the next device they reached in seconds. <br><br>  During the study of this problem, I came across a number of strange features of the work of these notifications from Google. <br><a name="habracut"></a><br><br>  <i>Those interested in the implemented low-level interaction of the smartphone with the server without prejudice to the prerequisites can skip these prerequisites and go to section ‚Äú4.</i>  <i>An alternative to Google C2DM, but not a replacement. "</i> <br><br><h4>  1. Scheme for using notifications </h4><br>  First of all, the scheme (designations are chosen just for clarity, and not according to <abbr title="State standard">GOST</abbr> ): <br><img src="https://habrastorage.org/storage2/c79/5ac/8cb/c795ac8cbbd8ec2271d9f7d8933cf39d.png" alt="smartphone-server-C2DM network communication scheme"><br>  To study the problem you need to understand how compounds 1, 2 and 3 are arranged. <br><ol><li>  This is our open <abbr title="HyperText Transfer Protocol">HTTP</abbr> connection that sends the request.  The application waits for the server only 200 OK and the rest is not important.  Here, a wide part of the bottle - there are few users so far, and they send inquiries a little (60-100 messages / s during active work). </li><li>  Our server opens this connection via <abbr title="HyperText Transfer Protocol">HTTP protocol</abbr> to Google servers.  In this case, you have to make 2 consecutive connections: first, the authorization in the recommended way is ClientLogin, then the request to <a href="http://android.clients.google.com/c2dm/send">android.clients.google.com/c2dm/send</a> .  The first thing to look for a problem started here. </li><li>  Finally, this connection is kept by Google itself with smartphones running Android. </li></ol><br><br><h4>  2. We are looking for problems with the request to <abbr title="Cloud To Device Messaging">C2DM</abbr> </h4><br>  Since I am developing mainly the server part, the first stone flew into me for possible problems in connection # 2.  What has been done? <br><br>  <i>In my humble opinion, the best explanation of how to connect <abbr title="Cloud To Device Messaging">C2DM</abbr> in an application is in habratopic. <a href="http://habrahabr.ru/post/116106/">We are writing an Android application with Cloud to Device Messaging (C2DM) support</a></i> <br><br>  This connection itself is implemented according to the recommendations of this article. <br><br>  Sometimes when connecting to the Google server, Connection timed out came, which gave me the idea of ‚Äã‚Äãlimiting the number of our simultaneous connections.  The thought may be erroneous, but the applied solution turned out to be useful. <br>  The server part is written in Java and runs as a separate <abbr title="Java Archive">JAR</abbr> with Jetty built into it.  The Spring Framework is responsible for setting up and launching, which means that I managed to reconfigure the interaction with the <abbr title="Cloud To Device Messaging">C2DM</abbr> server rather painlessly. <br><br><h5>  Step 1 </h5><br>  Add asynchrony to query execution. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C2DMServer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPushNotificator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPushChecker</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Async</span></span> <span class="hljs-comment"><span class="hljs-comment">//     public void sendData(String deviceId, String c2dmID, String jsonObject) { ... } }</span></span></code> </pre> <br><br>  This step gave another improvement - the 200 OK response to the requesting client now comes much faster, since the thread does not wait for a response from the Google notification server. <br><br><h5>  Step 2 </h5><br>  Customize the number of parallel requests to Google, just to meet the limits. <br>  There were a lot of tests and selection of coefficients, and the result resulted in such a Spring configuration. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">task:annotation-driven</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">executor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"asyncExecutor"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">task:executor</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"asyncExecutor"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pool-size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"15"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">queue-capacity</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rejection-policy</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"CALLER_RUNS"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br><br>  If pool-size is set to more than 15, then this number of simultaneous connections leads to various network errors. <br><br><h5>  Total </h5><br>  <u>What pleased me</u> : no more errors connecting to the Google server. <br>  <u>What upset</u> : the problem of speed of delivery remained, which means we move on. <br><br><h4>  3. Explore Google‚Äôs work with Android </h4><br>  After installing on Android, any application can request an identifier from a special service with which to send notifications. <br><br>  This is done by inheriting from the base class C2DMBaseReceiver. <br>  You can see an example of such inheritance in the same way. <a href="http://habrahabr.ru/post/116106/">We are writing an Android application with the support of Cloud to Device Messaging (C2DM)</a> .  Here is a modified implementation for me: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.android.c2dm.C2DMBaseReceiver; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C2DMReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C2DMBaseReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DATA = <span class="hljs-string"><span class="hljs-string">"data"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C2DMReceiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(Settings.C2DM_ACCOUNT); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, String errorId)</span></span></span><span class="hljs-function"> </span></span>{ Settings.Init(context, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); Settings.updateC2DM(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent receiveIntent)</span></span></span><span class="hljs-function"> </span></span>{ Settings.Init(context, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); String data = receiveIntent.getStringExtra(DATA); JSONUtils.processJSON(context, data); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRegistered</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, String registrationId)</span></span></span><span class="hljs-function"> </span></span>{ Settings.Init(context, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!registrationId.equals(Settings.getC2dm_id())) Settings.updateC2DM(registrationId); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUnregistered</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  <i>Here Settings is an assistant class with a bunch of static fields and methods for storing application state.</i>  <i>JSONUtils is another helper class that parses JSON and stores all data in Settings.</i> <br><br>  What is important to understand is that the moment of receiving the identifier is not defined.  In fact, with this class we just hang on to the event that the <abbr title="Cloud To Device Messaging">C2DM</abbr> identifier is <abbr title="Cloud To Device Messaging">received</abbr> , and, in theory, when it triggers, we should immediately pass the identifier to the server. <br>  Anaaaaaaaa <br><br>  After that, any message to the <abbr title="Cloud To Device Messaging">C2DM</abbr> server with this identifier must be delivered to the desired device and the desired application. <br><br>  Let's see how these messages are delivered. <br><br><img src="https://habrastorage.org/storage2/0d1/f5c/042/0d1f5c042098c9cf34b9523cb7eefdeb.png" alt="C2DM-GTalk application interaction diagram"><br><br>  In the center of all is the service Cloud To Device Messaging. <br>  Interestingly, on problematic devices, this service was sometimes unloaded from memory.  This means that it does not take any <abbr title="Operating System">OS</abbr> locks and may well turn off when Android needs resources.  This service uses the Google Messaging service as the core of the exchange protocol, on which GTalk also depends.  This happens because the <abbr title="Cloud To Device Messaging">C2DM</abbr> protocol is encapsulated in the <abbr title="Extensible Messaging and Presence Protocol">XMPP</abbr> protocol over which GTalk is exchanged.  On this channel, once every 300 seconds, the <abbr title="Cloud To Device Messaging">C2DM</abbr> service sends a Ping to Google‚Äôs servers and waits for Ack, confirming that the connection is OK.  You can learn more from the source in this <a href="http://www.youtube.com/watch%3Fv%3DPLM4LajwDVc">video</a> . <br>  With services all, of course, is not so sad.  The notification service is able to recover when the network conditions change and when the screen is turned on, although not always. <br>  <i>To see the status of your connection, you can dial <code>*#*#8255#*#*</code> and in the GTalk Service Monitor that opens, see what application has been exchanged via Google Messaging.</i> <br><br>  So, part of the problem was identified, but there was no solution for it. <br>  Why exactly a part?  Because notifications still did not reach, even with operating services.  Sometimes waves of notifications were noticed, when after some time (20-40 minutes) all devices received notifications at the same time, although they were sent at different times. <br><br>  In the end, after thinking, reading the documentation and a lot of forums and Q &amp; A all agreed on one thing - we will make an alternative channel of notifications. <br><br><h4>  4. Alternative to Google <abbr title="Cloud To Device Messaging">C2DM</abbr> , but not replacement </h4><br>  The main question: how to arrange a stable server-client channel? <br>  A side question: how can this channel not eat the entire battery of a user? <br><br>  Examples of inspiration from the resource <a href="http://code.google.com/p/android-random/">http://code.google.com/p/android-random/</a> . <br>  In particular, the <a href="">KeepAliveService</a> example. <br><br>  The first idea is a frontal solution: once every n seconds, open a connection to the server and check if there are no notifications. <br>  Instead of a frontal solution to the ‚Äúoften polling server‚Äù, the authors offer a more reasonable option, although it looks like a kind of hack. <br><br>  Chips of the proposed solution: <br><ul><li>  connection to the server must be kept constantly, and not reconnected at intervals; </li><li>  once per n seconds, where n&gt; 60, check the connection status by sending something to it and reconnect only if it is open; </li><li>  use blocking read on server connection. </li></ul><br><br>  I tested various client options for the notification server. <br>  2 clients were written: <br><ol><li>  I opened it once every n seconds and read if anything had appeared.  It was n that varied in testing. </li><li>  Opened a permanent connection and checked it every 60 seconds.  The devices varied to find out how the lifetimes differ. </li></ol><br>  The first client is not difficult to implement on their own.  All the details of the second can be viewed <a href="">in the archive</a> .  It includes an Android client of the second type and a server that supports the connection, logs all keepalive client messages, and also sends a notification to the client once a minute.  Everything is going to Maven with the connected android-maven-plugin. <br><br><table><thead><tr><td></td><td colspan="4">  Customer 1 </td><td colspan="3">  Customer 2 </td></tr></thead><tbody><tr><td>  Device </td><td>  Desire </td><td>  Desire </td><td>  Desire </td><td>  Desire </td><td>  Desire </td><td>  Wildfire s </td><td>  Desire s </td></tr><tr><td>  Test duration (min.) </td><td>  540 </td><td>  1273 </td><td>  845 </td><td>  962 </td><td>  1117 </td><td>  1180 </td><td>  1121 </td></tr><tr><td>  Charge consumption </td><td>  82 </td><td>  87 </td><td>  31 </td><td>  9 </td><td>  39 </td><td>  80 </td><td>  49 </td></tr><tr><td>  KeepAlive in seconds </td><td>  ten </td><td>  thirty </td><td>  60 </td><td>  60 </td><td>  60 </td><td>  60 </td><td>  60 </td></tr><tr><td>  Internet connection </td><td>  3G </td><td>  3G </td><td>  3G </td><td>  WiFi </td><td>  3G </td><td>  3G </td><td>  3G </td></tr><tr><td>  Calculated discharge rate (s./h) </td><td>  ten </td><td>  4.28 </td><td>  2.22 </td><td>  0.56 </td><td>  2.22 </td><td>  4.28 </td><td>  3 </td></tr></tbody></table><br><img src="https://habrastorage.org/storage2/33e/c84/9ab/33ec849ab76c77209130214938f99666.png" alt="battery discharge in s. at one o'clock"><br><br>  Immediately striking several results: <br><ol><li>  Although reopening the connection, at least keeping it open - it does not matter from the point of view of the battery. </li><li>  3G burns out the battery many times faster than WiFi. </li><li>  The optimal polling time is 60 seconds. </li></ol><br>  For us, the most important is the first result.  It follows from it that you need to choose from two clients according to their functional capabilities.  For a reconnecting client (# 1), notifications arrive only once at a specified check interval.  The client that supports the connection (‚Ññ2), notifications come at the moment when the server writes to the open connection.  And, running ahead, I will say that even the asleep device wakes up when a message from the server comes to the open connection. <br><br>  To withstand the influx of <abbr title="Transmission Control Protocol">TCP</abbr> connections, I built the following architecture. <br><img src="https://habrastorage.org/storage2/489/33b/d32/48933bd321e40724cd5504b52a07e26c.png" alt="own notification server"><br><br>  The notification server consists of two components: <br><ul><li>  Router - registers the connected device and gives it the address and port of the server with which to keep the connection.  In addition, it sends all requests for sending notifications to the required notification server. </li><li>  The notification server itself keeps the connection, notifies the router that it has received keepalive successfully from the device, and sends a notification if the router has called it. </li></ul><br>  All client interaction goes on pure <abbr title="Transmission Control Protocol">TCP</abbr> .  The notification itself can be of arbitrary size and content, but to reduce the load in my application, I send exactly one byte "1". <br>  <abbr title="Remote Method Invocation">RMI</abbr> connections are raised between server components using Spring Remoting. <br><br>  Now let's take a look at the client side logic in steps. <br><br><ol><li>  The client, when connected to the notification servers, reports its unique identifier, in my case it is just the <abbr title="Globally Unique Identifier">GUID</abbr> . </li><li>  In response, he receives the address and port, where to open and maintain the connection. </li><li>  After the socket is opened, the client goes into blocking read without setting the read timeout. </li><li>  Using AlarmManager, the client wakes up every 60 seconds and sends a message with its <abbr title="Globally Unique Identifier">GUID</abbr> to the open connection.  So the server finds out that the client is still alive. </li><li>  If the connection is dropped, the client checks for any access to the Internet and reconnects if there is one. </li><li>  If read returned the data, it means that a notification has been received, which is reported to the rest of the application logic, and the client again goes to the blocking read. </li></ol><br><br>  Working with AlarmManager is very simple. <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       Intent i = new Intent(this, NotificationService.class).setAction(ACTION_KEEPALIVE); PendingIntent pi = PendingIntent.getService(this, 0, i, 0); //      AlarmManager- AlarmManager alarmMgr = (AlarmManager) getSystemService(ALARM_SERVICE); alarmMgr.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + KEEP_ALIVE_INTERVAL, KEEP_ALIVE_INTERVAL, pi);</span></span></code> </pre><br>  Read more in the <a href="http://developer.android.com/reference/android/app/AlarmManager.html">documentation</a> . <br><br><h5>  Results and problems of my implementation or why it is impossible to completely abandon <abbr title="Cloud To Device Messaging">C2DM</abbr> </h5><br><br><ul><li>  For maximum lightness, all notification servers do not work with either files or databases.  <b><i>Hence the first consequence: if the notification did not reach, it will never reach.</i></b> </li><li>  Notification servers do not know anything about the data in the router.  <b><i>The second consequence: the client is not obliged to obey the router and go to the specified address and port, which means that clients can launch an attack on one notification server, while others will stand idle.</i></b> </li><li>  The router remembers when keepalive came from the client.  <b><i>A useful third consequence: the router can communicate this information to external systems, and this information is essentially a record of who is online now.</i></b> </li><li>  The router remembers to which notification server the client sent keepalive.  <b><i>The fourth consequence: even if the client connects to the wrong server, the router will know through which notification server to send the packet, instead of sending this packet to all servers.</i></b> </li></ul><br><br><h4>  5. Conclusion </h4><br>  ‚ÄúAny self-respecting smartphone programmer should write his own implementation of the notification service‚Äù - this is how the result of my work was jokingly described. <br>  But despite the joke, the notification service described above works at the same speed and almost with the same stability as that of Apple, which is good news, and the lifetime of the device, about which developers worry so much, is not reduced by much. <br><br><h4>  6. Useful links </h4><br>  <a href="http://tokudu.com/2010/how-to-implement-push-notifications-for-android/">Reflections on how to implement a good delivery of notifications</a> <br>  <a href="http://code.google.com/intl/ru-RU/android/c2dm/">Google C2DM Connection Documentation</a> <br>  <a href="http://habrahabr.ru/post/116106/">Habratopik "Writing an Android application with Cloud to Device Messaging (C2DM) support"</a> <br>  <a href="http://groups.google.com/group/android-c2dm/browse_thread/thread/1f42c8f44d8bb4cf">Complaints about the speed of C2DM</a> and <a href="https://www.google.ru/webhp%3Fq%3Dsite:groups.google.com%2Bc2dm%2Bslow">others</a> - I hope among them one day the answer will appear ‚ÄúHurray!  It all worked! </div><p>Source: <a href="https://habr.com/ru/post/142045/">https://habr.com/ru/post/142045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142039/index.html">Integration of web applications with social networks or ‚Äúaffixing likes‚Äù</a></li>
<li><a href="../142040/index.html">Facebook has updated the Download Your Information feature.</a></li>
<li><a href="../142041/index.html">Windows 8 and iPad app</a></li>
<li><a href="../142042/index.html">Boeing is going to release a super-reliable smartphone</a></li>
<li><a href="../142044/index.html">WI-FI. We are trying to improve</a></li>
<li><a href="../142046/index.html">The digest of interesting news and materials from the world of ayti for the last week</a></li>
<li><a href="../142047/index.html">HP donates code to the Linux kernel</a></li>
<li><a href="../142048/index.html">A set of useful utilities and libraries in the .NET world</a></li>
<li><a href="../142049/index.html">Online store with a discount system, other things being equal, you choose?</a></li>
<li><a href="../142050/index.html">Saga of the capacitors or "Another failure of covers"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>