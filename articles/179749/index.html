<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a single routing offline and online products 2GIS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If someone else does not know, then 2GIS is a free directory of organizations with a city map. And if a lot has already been written about the directo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a single routing offline and online products 2GIS</h1><div class="post__text post__text-html js-mediator-article">  If someone else does not know, then <a href="http://2gis.ru/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_routing">2GIS</a> is a free directory of organizations with a city map.  And if a <a href="http://habrahabr.ru/company/2gis/">lot has already been written about the directory</a> , then there is less information about the map and its capabilities.  And there is something to tell.  For example, about routing - why we did not take existing solutions, but wrote our own or why we need a single algorithm for building in different products. <br><br><img src="https://habrastorage.org/storage2/d38/7e6/2ac/d387e62ac30942d643287bf1a2f9ee96.png"><br><a name="habracut"></a><br><br>  In early 2012, we first encountered a problem - the engine that was previously used in the <a href="http://2gis.ru/about/pc/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_routing">desktop version</a> turned out to be too demanding of resources and cannot be used <a href="http://2gis.ru/about/mobile/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_routing">on mobile devices</a> .  It was necessary to do something. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Why not take ready-made solutions?</b> <br><br>  It is believed that the routing engine is a very difficult task with a lot of subtleties of implementation.  It‚Äôs as if you don‚Äôt go into boost :: graph and you don‚Äôt need to take it (it‚Äôs not supposed to know about the movie, yes) and it‚Äôs easier to find a ready-made solution.  Perhaps, but not in our case. <br><br>  I hope that it will become clear from the article - common sense, a bit of adventurism and a guide that is ready for the whole allow to solve any problem. <br><br>  In fairness, it should be noted that I already had experience with search in graphs (~ 50 million vertices), so some ideas about how to solve such problems already existed. <br><br>  <b>So, introductory:</b> <br><br><ol><li>  In the server version, the same code should work, but with different settings; </li><li>  Building a path should work on mobile phones for a reasonable time; </li><li>  In the asset ready (and verified) road graph;  It turned out to be much easier / more convenient / cheaper than searching and sharpening ready-made solutions. </li></ol><br><br>  Let's designate the <b>main</b> (and, banal, in general) <b>principles</b> : <br><br><ol><li>  Storage structures should be simple. </li><li>  It is useful to stimulate the locality of links, i.e.  if the data is related to physically close (for example) vertices of the graph, then they should be located nearby on the disk if possible. </li><li>  In no case should the elements of the graph on the disk be addressed one at a time, reading is carried out only in batches. </li><li>  Low-level caching is of little use, you should only care about ‚Äúexpensive‚Äù objects.  For example, instead of directly caching disk accesses, it is better to take care to minimize their number in an algorithmic way. </li><li>  The search logic in the graph should be simplified, where it is possible, because ‚Äúif breaks the conveyor‚Äù (C) </li><li>  Compress the data on the disk - good. </li><li>  It is not reprehensible to disregard precision in favor of performance. </li></ol><br><br>  <b>Main ideas</b> <br><br><ol><li>  Put the coordinates of the vertices on the lattice.  Those.  translate floating point coordinates into integers.  The grid can be made rather coarse, increasing its pitch until the vertices begin to stick together or, worse, to form edges of zero length.  When searching, we will need the coordinates to estimate the remaining distance to the final (and for debugging) and with the lattice with a large step, not far from the finish, the algorithm will start to behave strangely. <br>  Note that the rougher the grating, the smaller the amount of data on the disk, so if you really want it, you can choose it iteratively.  We have a lattice step - meter. <br><br><img src="https://habrastorage.org/storage2/471/de0/2f4/471de02f4ad6210e69d79b1d5791ef89.jpg"><br><br>  <i>Here is a fragment of a graph planted on a grid.</i> </li><li>  Mentally divide the extent of our graph into a number of rectangular tiles that form a grid.  This lattice does not have to be a sublattice thereof at the vertices. </li><li>  A tile is a logical unit to be simultaneously loaded from disk and cached.  It contains all vertices and outgoing arcs (i.e. arcs whose initial vertices lie in this tile).  Plus related information, if any. <br><br><img src="https://habrastorage.org/storage2/c04/796/127/c04796127e44dd8177ce3ad0b0e29a7a.png"><br><br>  <i>An example of edges that fell into one tile using the example of a fragment of a Moscow road graph.</i> </li><li>  The size of the tile should be selected based on the size of the graph.  Once we load something from the disk, it will be reasonable that the total amount of information read is comparable with the size of the disk buffer.  It would be strange to use heavy artillery in the form of disk hits to access several peaks that fit in a hundred bytes.  Of course, the graph is unevenly arranged, but you can appeal to average values, for example, the graph occupies 20mb on the disk, i.e.  2500 8K pages, hence sawing the extent of the graph into 50 √ó 50 parts (sqrt (2500)).  Here it is implicitly assumed that all information about the tile lies in one place.  If this is not the case, an appropriate amendment must be made. </li><li>  It makes sense to cache it tiles. </li><li>  A graph loaded into memory (or its part) is a large number of small objects.  It is impossible with impunity to allocate and release large quantities of small objects.  Therefore, we will use session page allocators, where possible.  In addition to speed and much less fragmentation of memory, this will also provide savings on the prologue and epilogue of the data block (meaning an algorithm with double tags). <br>  A page allocator distributes memory from its fixed-size pages (if possible), which it solicits from the system as needed.  Memory is released only all at once in its destructor. </li><li>  A tile will necessarily have such an allocator, everything that will be allocated when it is loaded will be taken from it and will die with its tile when it is pushed out of the cache. </li><li>  Another candidate for the use of the page allocator is the search itself, it is convenient to store information about the passed part of the graph in this way. </li><li>  Actually search algorithm.  We will use an ordinary A *, one ‚Äúwave‚Äù, with an estimate of the value of the vertex as the sum of the distance traveled (or time) and the estimate of the remaining one. </li><li>  A * - because  It allows you to reduce the number of traversed vertices compared to the original Dijkstra algorithm. </li><li>  One wave - for two reasons.  First, the launch of two waves towards meet, although it reduces the portion of the graph, but it will complicate the stopping criterion because  we must constantly check whether two waves are encountered.  And this entails either the content of each wave of a dynamic set of traversed vertices, or a modification of directly loaded tiles. </li><li>  The second reason is that the presence of an oncoming wave will not allow dynamically influencing the cost of the ribs, for example, due to a change in the traffic situation by the time we mentally get to this edge. </li><li>  The estimate of the cost of the remaining path can be any, provided that the triangle inequality is not violated.  For example, you can use a fair Euclidean distance or Chebyshev distance. </li></ol><br><br>  <b>Initial data</b> <br><br><ol><li>  Graph vertices - structures having coordinates and identifier </li><li>  Edges contain the identifier, length, type and identifiers of the initial and final vertices.  All edges are unidirectional. </li><li>  Restrictions - a pair of edges, the transition between which is impossible.  The constraint is tied to a specific vertex common to both edges.  We describe such a rather truncated version of the restrictions; if necessary, the reader will easily come up with a generalization. </li></ol><br><br>  <b>Pretreatment</b> <br><br><ol><li>  Find the inclusive extent of the graph. </li><li>  We determine the lattice coordinates. </li><li>  We are determined with a grid of tiles.  Each tile is assigned its ID.  The identifier is the number that grows as a result of the work of some sweeping curve.  Such a curve can be a line scan (igloo), a Hilbert curve, or a bit interleaving curve (zorder).  By and large, it is only important to be able to determine, by the coordinates of a point, which tile it falls into.  And the choice of a sweeping curve only affects the ability of the data to be compressed. </li><li>  We assign each vertex to a specific tile.  In this case, we assign each vertex its ordinal number in its tile, this is also useful for compression. </li><li>  For each edge, we determine which tile it goes from and into which tile, as well as the internal numbers of the outgoing and incoming points. </li></ol><br><br>  <b>Disk storage</b> <br><br>  The actual data is stored in B-trees, more precisely in one of their varieties. <br>  From the data warehouse, we need the ability to store a sorted N-ok array and quickly read their intervals. <br><br>  By and large, the choice of storage is not critical, we chose B-trees, because they: <br><br><ol><li>  Easy to understand and debug </li><li>  Allow to compress data without being tied to specific </li><li>  Most importantly, their implementation was tested at hand. </li></ol><br><br>  So, there are several trees: <br><br>  1. <b>Tree tops.</b>  N-ka of this tree consists of 4 elements: <br><br><ul><li>  Vertex Tile ID </li><li>  The ordinal number of the vertex in this tile </li><li>  X - point coordinate </li><li>  Y is the coordinate of the point. </li></ul><br><br>  2. <b>Edge tree</b> , His key consists of 7 elements: <br><br><ul><li>  Outgoing vertex tile identifier </li><li>  Number of outgoing vertex in its tile </li><li>  Incoming vertex tile identifier </li><li>  The number of the incoming vertex in its tile </li><li>  Edge cost, for example, length </li><li>  Edge type, for example, road class </li><li>  External identifier of the edge. </li></ul><br><br>  3. <b>Tree of identifiers.</b>  Used to communicate with the outside world.  The key contains 5 items: <br><br><ul><li>  External edge ID </li><li>  Outgoing vertex tile number </li><li>  Number of outgoing vertex in its tile </li><li>  Tile number of the incoming vertex </li><li>  The number of the incoming vertex in its tile. </li></ul><br><br>  4. Tree of restrictions with a key of length 4: <br><br><ul><li>  The tile number of the vertex of the constraint. </li><li>  The number of this vertex in the tile </li><li>  External identifier of the edge from which movement is prohibited </li><li>  External identifier of the edge where movement is prohibited. </li></ul><br><br>  Thoughtful reader will say: ‚ÄúBah!  To read all the information about a single tile, you need to make 3 lines of trees.  Isn't it better to pack everything into a BLOB and pick it up in one fell swoop? ‚ÄùFor read-only data, it‚Äôs better, of course, in terms of speed and compression quality.  But this is additional work, additional testing.  In addition, profiling showed that, in fact, the reading of data is not a bottleneck when searching for directions. <br><br>  If we are talking about data that can dynamically change, here B-trees are out of competition.  It is not even necessary to have your own implementation of trees, you can use SQL storage, and set the above-described entities as tables consisting of only primary key.  So, one of the predecessors of the described engine was built on the basis of <a href="http%253A%252F%252Fvirtuoso.openlinksw.com%252Fdataspace%252Fdoc%252Fdav%252Fwiki%252FMain%252F%26sa%3DD%26sntz%3D1%26usg%3DAFQjCNE6rH8ztAOZKC38o0yW3WyvbyE_lQ">OpenLink Virtuoso</a> DBMS, where the tables themselves are arranged like trees and, in our case, there is no duplication of data as such (meaning duplication of data from the table in the index). <br><br>  <b>Graph representation in memory</b> <br><br>  In this section we describe how the unpacked graph looks in memory. <br><br>  1. The entire graph in memory may not exist.  As already mentioned, it is loaded slowly as someone needs parts of this graph. <br><br>  2. Therefore, there is a cache of tiles and a holder of this cache.  Caching strategy can be any.  We have this LRU (Least Recently Used). <br><br>  3. Tile loaded into memory - contains all the information about the data trapped in its area of ‚Äã‚Äãspace.  As already mentioned, all the memory for this is allocated from the tile-owned allocator and is released upon its death.  Namely: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> vertex_t {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> link_t*links_; };  ,   ..     .  links_      ,    . <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> link_t { int64_tfid_; <span class="hljs-comment"><span class="hljs-comment">//    int len_; //  int class_; //  int vert_id_; //   , &gt;0,      union { const vertex_t *vertex_; //         int tile_id_; //    }; const link_t *next_; //   }; struct restriction_t {uint64_t from_; uint64_t to_;};   .         ,   ( )         . ,   .</span></span></code> </pre> <br><br>  4. Thus, a tile in memory is a ready-to-use piece of the graph that can: <br><br><ul><li>  Give vertex by number </li><li>  Verify outgoing edges by vertex </li><li>  Test a couple of edges for restrictions on it. </li><li>  Edges are either pointers when moving inside a tile, or a pair of tile number / vertex number otherwise.  For this pair, when moving along the graph, you can transparently ask the required cache holder for the cache holder, load it if necessary, and switch to it. </li></ul><br><br>  <b>Actually search</b> <br><br>  1. Before starting the search, you need to bind to the graph.  Those.  on the outside we get two sets of points - the source and the end.  The description of each point consists of its external identifier of the graph edge and cost.  The cost of reaching the beginning of this edge for the starting point and the cost of the path from the end of the edge to the final for the ending point.  So: <br><br>  2. Using the tree of identifiers, we turn edge identifiers into entry points to the graph (const vertex_t *).  To do this, you will need to contact the tile cache holder and load the necessary ones. <br>  We need an object - the holder of information about the final, including tile identifiers and vertex numbers.  Another useful information that this object possesses is the geometrical position of the finish.  It can be given explicitly, but it can be calculated, for example, as the centroid of the final points.  We will need this point to calculate the estimated part of the cost of the reached vertex for the algorithm A * <br><br>  3. Now we need a ‚Äúwave‚Äù holder.  It consists of: <br><br>  a.  Allokator, well, where can I go without it. <br>  b.  A set of loaded tiles.  For graphs of reasonable size, a bit mask is sufficient.  That is, when we hit a tile for the first time, mark the corresponding bit in this mask and increment the counter of its links.  After completing the search, focusing on this mask, we will roll back the reference counters.  At the same time, those tiles whose counters have been reset will receive a chance to fly out of the cache in the future. <br>  c.  Priority queue.  We use a binary sorting heap.  Candidates for viewing are in the queue.  For example, starting points go straight here.  The key here is the distance traveled or the time spent.  And the value is a pointer to the handle of the passed point. <br>  d.  Set of points passed.  Each such point is described by a structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vertex_ptr_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> fid_; <span class="hljs-comment"><span class="hljs-comment">//   ,      //     0 const vertex_t *ptr_; //      const vertex_ptr_t *prev_; //      size_t cost_len_; //      size_t cost_time_; //      };</span></span></code> </pre><br>  Of course, these structures are allocated with an allocator. <br><br>  4. So, for each starting point, we create its descriptor and put it in a heap.  So we are ready to start the search. <br><br>  5. While there is something in the heap (and so far it is something potentially better than the already found candidates), choose the cheapest element from it and: <br><br>  a.  we run according to the list of its outgoing edges and for each of them: <br><br>  I. check the possibility of transition to this edge from the previous one. <br>  Ii.  find the vertex of the graph pointed to by this edge.  It is possible that a new tile will be loaded, and this point will be in it. <br>  III.Calculate the cost of achieving this new point.  For this: <br><br><ol><li>  take the accumulated path and time </li><li>  sum up the path with the length of the current edge </li><li>  we increase the time by the amount needed to overcome the current in accordance with its length, type and anything else </li><li>  we calculate and add the estimate of the remaining path - abs (dx) + abs (dy), where dx and dy - the difference in longitude and latitude, respectively </li><li>  we calculate and add an estimate of the time remaining to the finish based on the estimate of the remaining path, time of day, average speed on </li><li>  passed stage and anything else </li></ol><br><br>  Iv.  create and fill the handle of the traversed vertex <br>  V. check whether this is final <br>  Vi.  if it is a finish, then we unwind the list of previous ones <br>  <i>(vertex_ptr_t :: prev_)</i> , starting from this point, while on the rest in 0, <br>  those.  at the start  Here is a ready candidate for extradition. <br>  VII.  we put the created descriptor in a heap <br><br>  <b>results</b> <br><br>  Let's try to evaluate the results of the deed on the example of the road graph of the capital of our vast Motherland. <br><br><ul><li>  The graph contains 307338 vertices </li><li>  And 806220 ribs. </li><li>  The size of the extent - 92 x 112 km </li><li>  Number of tiles - 46 x 56 = 2576 pieces </li><li>  The total amount of data on the disk occupied by the road graph is 13 980 kb </li><li>  The average length of the calculated path is 32.8 km </li><li>  For example, </li></ul><br><br><img src="https://habrastorage.org/storage2/2ad/508/401/2ad50840163cbfeede3afb81c5c409a7.png"><br><br>  Blue indicates the optimal route, red - ‚Äúwave‚Äù. <br><br><ul><li>  In this case, on average, 1644 vertices and 2406 edges are covered, which lie on 22 tiles. </li><li>  This requires 2096 kb for tiles and 116 kb for wave </li><li>  time spent on Sony Xperia S 400 + 500 (on index initialization) ms (IPhone 4 800 + 1000 (...) ms) </li><li>  Example, the path through the entire graph </li></ul><br><br><img src="https://habrastorage.org/storage2/d0c/c3a/ac4/d0cc3aac42f4e66e2f1a8911d854ce8b.png"><br><br>  As before, blue is the optimal route, red is the ‚Äúwave‚Äù. <br>  It's funny to see how the search revealed (actual, implicit) hierarchical structure of the graph and began to use it. <br><br><ul><li>  Its calculated length is 135.3 km. </li><li>  This affects 2251 vertices and 3044 edges, lying on 120 tiles. </li><li>  This requires 3,946 kb for tiles and 133 kb for wave </li><li>  time spent 400 ms Sony Xperia S (500 IPhone 4) plus the same one-time index load, of course </li><li>  And here is a demonstration of how important the heuristics used are - three pictures of a passage in Novosibirsk with different settings: </li></ul><br><br><img src="https://habrastorage.org/storage2/288/578/53b/28857853b5eda3d395e2f4514f5522e3.png"><br><br>  <b>Total</b> <br><br>  As we can see, such a simple data structure and the described algorithm allow you to work with a single-level graph of a big city on an ordinary smartphone.  And if RAM allows us, for example, in the server case, increasing the size of the tile cache, we simply drive the entire graph into memory and work with its ready representation.  That has a beneficial effect on performance. <br><br>  We intentionally did not touch on certain points, for example, taking into account the traffic situation, prediction of this, hierarchical graphs, because this is a completely different story. <br><br>  That's All Folks! </div><p>Source: <a href="https://habr.com/ru/post/179749/">https://habr.com/ru/post/179749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../179735/index.html">0day vulnerability in Linux from 2.6.37 to 3.8.10</a></li>
<li><a href="../179739/index.html">The history of the creation of Diablo</a></li>
<li><a href="../179741/index.html">The official announcement of the free upgrade of Windows 8.1</a></li>
<li><a href="../179745/index.html">Business studios: about stages, money, calculator and kanban</a></li>
<li><a href="../179747/index.html">Do you remember how it all started?</a></li>
<li><a href="../179751/index.html">A new simplified package build format and a new installer may appear in ubuntu.</a></li>
<li><a href="../179755/index.html">Angularjs guidelines for beginners. Part 1</a></li>
<li><a href="../179759/index.html">University for IT specialist: a view from the inside</a></li>
<li><a href="../179761/index.html">Host Protected Area or Where is my place?</a></li>
<li><a href="../179767/index.html">Clouds, liability and unexpected situations with SSL certificates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>