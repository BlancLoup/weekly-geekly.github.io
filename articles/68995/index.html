<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Part 1/3. Ideal VM compiler for ICFPC 2009, on Haskell, with popularizing comments</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here we will spell some program (VM compiler) on Haskell. At the input of this compiler is given a binary file with instructions of a certain processo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Part 1/3. Ideal VM compiler for ICFPC 2009, on Haskell, with popularizing comments</h1><div class="post__text post__text-html js-mediator-article">  Here we will spell some program (VM compiler) on Haskell.  At the input of this compiler is given a binary file with instructions of a certain processor, where in these instructions certain calculations are described.  At the output of our compiler, the program text is obtained, also on Haskell, which performs the same calculations with great speed.  Perhaps this is not a compiler, but a decompiler, I do not know.  Comparison of the work of the resulting programs in Haskell / Java is given in the <a href="http://san13.habrahabr.ru/blog/67225/">previous post</a> . <br><br><a name="habracut"></a><br><br>  Warning: people with formal mathematical thinking are <b>forbidden to read</b> !  You already know everything.  This post is for people who are interested in something beyond the usual C / C ++ / C # / Java, because in the last 5 years they have been tired of writing the same thing in these wonderful languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About the initial task of the ICFP contest once again, with technical details: we are given a binary file in which the program (calculating formulas) is written in the machine instructions of a certain processor.  There are several formulas at once, so when calculating formulas a special pool is used for return values.  There is a pool for input values.  And there is a pool for storing the values ‚Äã‚Äãrequired during the calculation of the formulas, and for the values ‚Äã‚Äãthat live from iteration to iteration (that is, when the program runs many times, it can use data from the last run).  The input pool in terms of the task is called a set of input ports, similarly there are output ports, everything else is simply called ‚Äúmemory‚Äù. <br><br>  Calculations are performed as follows: by adding, subtracting, and other arithmetic operations on data from input ports and memory, a value is obtained that is written to one of the output ports.  According to the authors, the binary file from the task is a program for the ‚Äúblack box‚Äù, which is able to calculate something for us. <br><br>  Implementing this black box so that it can calculate at all quickly, and is our first goal in ICFPC 2009, and the rest (calculate the control actions on the satellite so that it can fly correctly in the world described by these formulas) is the main goal of the contest We will not consider this post, and maybe in another. <br><br>  In this binary file, the original data was intermixed with the code as follows: <br><table cellpadding="3" border="1"><tbody><tr><td>  Offset (dec) <br></td><td>  Length <br></td><td>  Content <br></td><td>  Type of <br></td></tr><tr><td>  O <br></td><td>  eight <br></td><td>  <font>data (cell 0)</font> </td><td>  Double <br></td></tr><tr><td>  eight <br></td><td>  four <br></td><td>  <font>opcode (cell 0)</font> </td><td>  UInt32 <br></td></tr><tr><td>  12 <br></td><td>  four <br></td><td>  <font>opcode (cell 1)</font> </td><td>  UInt32 <br></td></tr><tr><td>  sixteen <br></td><td>  eight <br></td><td>  <font>data (cell 1)</font> </td><td>  Double <br></td></tr></tbody></table>  then the same order is repeated for 2.3 cells, then 4.5, and so on.  In the specification it is written: for even cells, data first goes, then opcode, vice versa for odd ones.  Why is there data here, why do non-zero data exist at all?  Very simply, 1) in opcodes it is impossible to clog a constant, a variable is used (a memory cell) that is not modified by anyone 2) some variables are initialized, and they also lie in the data. <br><br>  In order to compile such a binary into a beautiful text in any language, you need: <br><br>  1) read binary into buffer <br>  2) separate data from opcodes <br>  3) build an AST from opcodes (AST in local terms is a disassembled opcode decomposed into a form convenient for manipulations, in the original it means Abstract Syntax Tree, an abstract tree because it contains the essence of the program, not its text or binary representation) <br>  4) to transform AST into another type (higher level) <br>  5) output AST in text form in the required language, and also display the definition of the data with its original meaning. <br><br>  Next comes the program with comments for people who are far from Haskell, so some points in the explanations are intentionally simplified and even slightly distorted (marked separately), for ease of perception. <br><br>  Connection of some standard modules: <br><br><blockquote><code><font color="#a020f0">import</font> System.IO&lt;br&gt; <br> <font color="#a020f0">import</font> Foreign.Marshal.Alloc&lt;br&gt; <br> <font color="#a020f0">import</font> Foreign.Ptr&lt;br&gt; <br> <font color="#a020f0">import</font> Data.Word&lt;br&gt; <br> <font color="#a020f0">import</font> Foreign.Storable&lt;br&gt; <br> <font color="#a020f0">import</font> Debug.Trace&lt;br&gt; <br> <font color="#a020f0">import</font> Data.Bits&lt;br&gt; <br> <font color="#a020f0">import</font> Data.List&lt;br&gt; <br> <font color="#a020f0">import</font> Data.Maybe</code> </blockquote> <br>  Description of type synonyms, for details of the following data definitions: it says that the source address in the command is of type Int, as well as the destination address. <br><br><blockquote> <code><font color="#2e8b57"><b>type</b></font> DestAddr <font color="#a52a2a"><b>=</b></font> Int&lt;br&gt; <br> <font color="#2e8b57"><b>type</b></font> SrcAddr <font color="#a52a2a"><b>=</b></font> Int</code> </blockquote> <br>  Now (below) comes the AST element, that is, the decoded instruction from the specification.  Commands usually contain addresses of input data (or several pieces, for example, an addition command) - the type SrcAddr is mentioned, and one address in which they write the result (DstAddr is mentioned). <br><br>  In our task, different things are done with AST: several commands are replaced with one that is not in the specification, then all commands are replaced with some kind of tree, whose elements are the same commands, but from a different set (more on that later).  It is supposed to divide the sets of commands into different types, but in this case we have a dump here, and only comments help to separate the set from the set (see below). <br><br>  In Haskell there is the so-called algebraic data type, which is generally everywhere, and it is very convenient for use in our case.  We create the type Op (from the word opcode) and assign several constructors to it (they are not constructors from the OOP, but if we think in terms of the OOP, then the empty class Op is declared, and many of the classes derived from it are, and each has its own data). <br><br><blockquote> <code><font color="#2e8b57"><b>data</b></font> Op <font color="#a52a2a"><b>=</b></font> &lt;br&gt; <br> <font color="#0000ff">--     .  ,  :</font> &lt;br&gt; <br> Const Double <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> ReadExp SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- read main memory</font> &lt;br&gt; <br> ReadVarExp SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- read temporary variable</font> &lt;br&gt; <br> ReadPortExp SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- read port</font> &lt;br&gt; <br> <font color="#0000ff">--  :</font> &lt;br&gt; <br> SqrtExp Op <font color="#a52a2a"><b>|</b></font> SubExp Op Op <font color="#a52a2a"><b>|</b></font> AddExp Op Op <font color="#a52a2a"><b>|</b></font> MulExp Op Op <font color="#a52a2a"><b>|</b></font> DivExp Op Op <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- math</font> &lt;br&gt; <br> IfExp CmdOp Op Op Op <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- branch: compare 1st op with zero, choose from other ops.</font> &lt;br&gt; <br> <font color="#0000ff">--   ( +)</font> &lt;br&gt; <br> Add DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> Sub DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> Mul DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> Div DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> Output SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- copy from memory to out port.</font> &lt;br&gt; <br> If CmdOp SrcAddr DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">--  compare mem with 0,choose,store</font> &lt;br&gt; <br> Input DestAddr SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- read src port into memory</font> &lt;br&gt; <br> Sqrt DestAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> Copy DestAddr SrcAddr <font color="#a52a2a"><b>|</b></font> &lt;br&gt; <br> <font color="#0000ff">--   ,      </font> &lt;br&gt; <br> Cmpz CmdOp SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- first part of "If"</font> &lt;br&gt; <br> Phi DestAddr SrcAddr SrcAddr <font color="#a52a2a"><b>|</b></font> <font color="#0000ff">-- second part of "If"</font> &lt;br&gt; <br> Noop DestAddr   &lt;br&gt; <br> <font color="#2e8b57"><b>deriving</b></font> Show <br></code> </blockquote><br>  We see that our options are listed through the symbol "|", traditionally meaning "or."  Also there is a ‚Äúderiving Show‚Äù, which means that if we want to translate some value of this type to a string, we will get a string in Haskel, approximately close to the original.  This construction means literally the following: ‚Äúcompiler, make the specified type belonging to the Show class, and the class method Show, which translates from value to a string, generate it yourself as you can.‚Äù <br><br>  Now that we will have about the tree.  Suppose an expression is generated in the resulting code: <br>  o32 = (i2 * 37) + (m75 * (m76 * t4)) <br>  It means: put the value of the input port multiplied by 37 plus the product of two memory cells and one time variable in the output port.  The expression to the right of the brackets is written in terms of our AST as follows: <br><br> <code>AddExp (MulExp (ReadPortExp <font color="#ff00ff">2</font> ) (ConstExp <font color="#ff00ff">37</font> )) <font color="#a52a2a"><b>...</b></font> &lt;br&gt; <br> <font color="#a52a2a"><b>...</b></font> (MulExp (ReadExp <font color="#ff00ff">75</font> ) (MulExp (ReadExp <font color="#ff00ff">76</font> ) (ReadVarExp <font color="#ff00ff">4</font> ))) <font color="#0000ff">-- lisp? ;)</font></code> <br> <br>  If you count the brackets, it should converge 8).  What do we have in the leaves of the tree?  Constants, input ports, memory, and temporary variables.  How do we distinguish one from the other?  After all, according to the specification, we only have input ports and memory?  Where do constants come from, for example? <br><br>  Very simple.  If nobody writes in our cell, and everyone just reads from it, then this is a constant.  It makes sense to remove it from the ‚Äúmemory‚Äù and score it with a constant in the resulting code.  Similarly, temporary variables are separated from constant variables, as well as variables that should not exist at all, that is, they must be converted directly into expressions with brackets (see a little bit below). <br><br>  We continue.  The following section describes an AST for conditional operations (comparison with zero, from the specification).  Comparisons of five pieces, according to the results of the comparison, there is a choice from one or from another memory address. <br><br><blockquote> <code><font color="#2e8b57"><b>data</b></font> CmdOp <font color="#a52a2a"><b>=</b></font> Ltz <font color="#a52a2a"><b>|</b></font> Lez <font color="#a52a2a"><b>|</b></font> Eqz <font color="#a52a2a"><b>|</b></font> Gez <font color="#a52a2a"><b>|</b></font> Gtz <font color="#2e8b57"><b>deriving</b></font> Enum</code> </blockquote> <br>  Of interest is the construction of "deriving Enum".  It automatically assigns this type to the class Enum, and the types of this class have a method that allows to translate an instance of the type into an integer, and vice versa.  Will be used in the next paragraph. <br><br>  Now we will specify that the type CmdOp belongs to the class Show.  This class is used to translate values ‚Äã‚Äãof any type to string type, as mentioned above in ‚Äúderiving Show‚Äù.  In our case, we do not want the compiler itself to generate the default converting methods, but to implement our own method (function). <br><br><blockquote> <code><font color="#2e8b57"><b>instance</b></font> Show CmdOp <font color="#2e8b57"><b>where</b></font> &lt;br&gt; <br> show cmdOp <font color="#a52a2a"><b>=</b></font> [ <font color="#ff00ff">"&lt;0"</font> , <font color="#ff00ff">"&lt;=0"</font> , <font color="#ff00ff">"==0"</font> , <font color="#ff00ff">"&gt;=0"</font> , <font color="#ff00ff">"&gt;0"</font> ] <font color="#a52a2a"><b>!!</b></font> fromEnum cmdOp</code> </blockquote> <br>  Actually the function is show, it takes the cmdOp parameter, returns a string, one of the list.  The expression to the right of the equal sign means: transfer from value to integer (fromEnum, remember deriving Enum), then use this integer as an index (the "!!" function) to select from the list (list in square brackets).  Short and clear, but O (N), so what.  O (N) here means that to get the fifth element of the list, it will take 5 iterations (because a list is used here, not an array), and for N-th, therefore, N iterations, which is long.  There is a simple way to speed things up by writing case or using an array, but I saved the program line 8-) <br><br>  Next comes the function that translates Op into the language into which we compile.  We compile into Haskel, and therefore the following introduction is required: <br><br>  Our black box at the entrance has input ports, and its previous state, and the output has its own state and output ports.  A binary file compiled into Haskell will contain one function, which will have the same data as input and output.  Return the output ports will be as part of the structure.  Thus, the compiled file will contain: <br><br>  1) data description: <br><br> <code><font color="#2e8b57"><b>data</b></font> VMState <font color="#a52a2a"><b>=</b></font> VMState { m13, m55, m77, o11 <font color="#a52a2a"><b>::</b></font> Double } <font color="#0000ff">--    persistent mem</font></code> <br> <br>  2) the main function (discussed in detail below): <br><br> <code>nextState <font color="#a52a2a"><b>::</b></font> VMState <font color="#a52a2a"><b>-&gt;</b></font> (Double,Double, <font color="#a52a2a"><b>Double...</b></font> ) <font color="#a52a2a"><b>-&gt;</b></font> VMState&lt;br&gt; <br> getNextState x (i2,i3,i16000 <font color="#a52a2a"><b>...</b></font> ) <font color="#a52a2a"><b>=</b></font> ( <font color="#ff00ff">1</font> )&lt;br&gt; <br> <font color="#a52a2a"><b>let</b></font> t1 <font color="#a52a2a"><b>=</b></font> i2 <font color="#a52a2a"><b>+</b></font> i3 <font color="#a52a2a"><b>+</b></font> m55 x;&lt;br&gt; <br> t2 <font color="#a52a2a"><b>=</b></font> <font color="#a52a2a"><b>if</b></font> (i <font color="#a52a2a"><b>-</b></font> <font color="#ff00ff">16000</font> <font color="#a52a2a"><b>&gt;</b></font> <font color="#ff00ff">O</font> ) <font color="#a52a2a"><b>then</b></font> t1 <font color="#a52a2a"><b>*</b></font> (i16000 <font color="#a52a2a"><b>+</b></font> <font color="#ff00ff">1</font> ) <font color="#a52a2a"><b>else</b></font> <font color="#ff00ff">O</font> &lt;br&gt; <br> <font color="#a52a2a"><b>in</b></font> VMState { m13 <font color="#a52a2a"><b>=</b></font> t1 <font color="#a52a2a"><b>+</b></font> t2 <font color="#a52a2a"><b>*</b></font> <font color="#ff00ff">2</font> , m55 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">2</font> <font color="#a52a2a"><b>*</b></font> i3 <font color="#a52a2a"><b>.....</b></font> o10 <font color="#a52a2a"><b>=</b></font> (i2 <font color="#a52a2a"><b>+</b></font> <font color="#ff00ff">22</font> ) <font color="#a52a2a"><b>*</b></font> <font color="#ff00ff">576000.0</font> }</code> <br> <br>  3) the function that returns the state of the black box at time 0 - that is, the data that we will feed it iteration after iteration: <br><br> <code>initState <font color="#a52a2a"><b>=</b></font> VMState { m13 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">O</font> , m55 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">123.456</font> , <font color="#a52a2a"><b>...</b></font> o90 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">O</font> }</code> <br> <br>  Consider the points of each line.  The first declares the ‚Äústructure‚Äù of the data.  Its difference from C / Java structures is that its fields cannot be changed; it is only possible to get a new structure with some (either one or all) changed values ‚Äã‚Äãof the current structure.  It is written this way: <br><br> <code><font color="#a52a2a"><b>let</b></font> newStruct <font color="#a52a2a"><b>=</b></font> oldStruct { field5 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">7</font> , field10 <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">O</font> }</code> <br> <br>  Then, if desired, the old data can be thrown out. <br>  To read one field from a structure, use the syntax: <br><br> <code><font color="#a52a2a"><b>let</b></font> myFieldValue <font color="#a52a2a"><b>=</b></font> field5 newStruct</code> <br> <br>  Why so strange?  Because when a structure is declared, all functions are automatically declared to access its fields.  In particular, a function appears implicitly (for example): <br><br> <code>field5 <font color="#a52a2a"><b>::</b></font> VMState <font color="#a52a2a"><b>-&gt;</b></font> Double</code> <br> <br>  This means that the function receives the value of VMState as an input (in our example, we passed the whole newStruct at the top), and returns a numeric value with a floating point. <br>  Along the way, we understood what the method signatures look like (method name :: type).  We look at the main function <br><br> <code>nextState <font color="#a52a2a"><b>::</b></font> VMState <font color="#a52a2a"><b>-&gt;</b></font> (Double,Double, <font color="#a52a2a"><b>Double...</b></font> ) <font color="#a52a2a"><b>-&gt;</b></font> VMState</code> <br> <br>  There are no three dots in Haskel, I added them to illustrate that we will declare a tuple of as many doubles as we need.  The function takes 2 parameters, the first is VMState, the second consists of several values ‚Äã‚Äã(in our case, these are the values ‚Äã‚Äãof all ports), and this function returns the new value of VMState. <br><br>  The main function of an ideal VM has a syntax similar to the following: <br><br> <code>fun arg1 arg2 <font color="#a52a2a"><b>=</b></font> &lt;br&gt; <br> <font color="#a52a2a"><b>let</b></font> bind1 <font color="#a52a2a"><b>=</b></font> expr1; bind2 <font color="#a52a2a"><b>=</b></font> expr2&lt;br&gt; <br> <font color="#a52a2a"><b>in</b></font> exprResult&lt;br&gt; <br> <font color="#2e8b57"><b>where</b></font> bind3 a1 a2 a3 <font color="#a52a2a"><b>=</b></font> expr3&lt;br&gt; <br> bind4 a5 a6 <font color="#a52a2a"><b>=</b></font> expr4</code> <br> <br>  That is, we can define some reusable expressions in the "let" section, and then use them freely in the resulting expression (which is in the "in").  We can also define the same expressions in the "where" section, only there they are usually described not by variables, but by functions local (apparently) to the ambient function (fun).  Functions can also be described in the let section, but this is less convenient.  I will add that from where the values ‚Äã‚Äãfrom the ‚Äúlet‚Äù section are not visible. <br><br>  Further, I note that the ‚Äúif‚Äù construction in haskel is an expression.  There are no ‚Äúfor‚Äù constructs in the language itself, it is in a separate module and is a normal function.  As well as "while" and the like. <br><br>  In the light of the foregoing, we will continue to review the binary file compiler. <br><br>  The following function translates an AST element (of type Op) into a string representation in the result language (in Haskell).  The first parameter is a string containing the name of the parameter with the initial state (because we will generate read operations from it), in the formula (1) it will be ‚Äúx‚Äù.  In fact, I could coerce this name because it appears only once. <br><br><blockquote> <code>ast2haskell <font color="#a52a2a"><b>::</b></font> String <font color="#a52a2a"><b>-&gt;</b></font> Op <font color="#a52a2a"><b>-&gt;</b></font> String&lt;br&gt; <br> ast2haskell x op <font color="#a52a2a"><b>=</b></font> s op <font color="#2e8b57"><b>where</b></font> &lt;br&gt; <br> s (Const d) <font color="#a52a2a"><b>=</b></font> show d <font color="#0000ff">--    .</font> &lt;br&gt; <br> s (ReadExp r1) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"m"</font> <font color="#a52a2a"><b>++</b></font> (show r1) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" "</font> <font color="#a52a2a"><b>++</b></font> x&lt;br&gt; <font color="#0000ff">-- generate read access to memory</font> &lt;br&gt; <br> s (ReadVarExp r1) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"t"</font> <font color="#a52a2a"><b>++</b></font> (show r1)&lt;br&gt; <font color="#0000ff">-- to temporary variable</font> &lt;br&gt; <br> s (ReadPortExp r1) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"i"</font> <font color="#a52a2a"><b>++</b></font> (show r1)&lt;br&gt; <font color="#0000ff">--  to input port</font> &lt;br&gt; <br> s (SqrtExp op') <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"(sqrt "</font> <font color="#a52a2a"><b>++</b></font> s op' <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (AddExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"+"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (SubExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"-"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (MulExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"*"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (DivExp op1 (Const x)) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"/"</font> <font color="#a52a2a"><b>++</b></font> (show x) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (DivExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"(if "</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" /= 0 then "</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"/"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" else 0)"</font> &lt;br&gt; <br> s (IfExp cond opc op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"(if "</font> <font color="#a52a2a"><b>++</b></font> s opc <font color="#a52a2a"><b>++</b></font> show cond <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" then "</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" else "</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font></code> </blockquote> <br>  What do we have here?  The familiar construction fun param = expr where ...., but only immediately comes the call of one of the local functions.  Why?  Now we will understand.  First, we only note that the ‚Äús‚Äù function (from ‚Äústring‚Äù) has several definitions, one definition for each Op type constructor.  As a result, of course, only one function will be called, and immediately a specific object of type Op will be broken into its components, which will be given names: <br><br> <code>s <font color="#a52a2a"><b>::</b></font> Op <font color="#a52a2a"><b>-&gt;</b></font> String&lt;br&gt; <br> s (AddExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"+"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font></code> <br> <br>  This is an implementation of the s function for the Op type constructor named AddExp, which has two parameters: two AST branches that are added.  And the function s itself has one argument, so there are brackets around AddExp.  The result of this function will be a string glued together from pieces (operation ++ joins two lists; strings are lists too).  Here the brackets are pasted on the sides, and between them the string representations of both branches, between which a plus is glued.  The string representation of each branch, therefore, is calculated recursively, it is common practice in such problems.  And finally, the show function converts a number into a string, and also it is used for CmdOp (comparison condition with zero), which also belongs to the class Show (described above). <br><br>  Pay attention to the following definition: <br><br> <code>s (DivExp op1 (Const x)) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"/"</font> <font color="#a52a2a"><b>++</b></font> (show x) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (DivExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"(if "</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" /= 0 then "</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"/"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">" else 0)"</font></code> <br> <br>  It is great because both functions work on DivExp data, but to select the first one, it is necessary that the divisor in this node be constant!  For this case, a special, simpler code is generated, because here you do not need to check to 0. <br><br>  From this it follows that the definition of which function is called does not follow the ‚Äútype of constructor‚Äù, but is much more flexible: the input value in turn tries to ‚Äúclimb through‚Äù into each implementation of the function with the required name, and the function into which it is called is called .  In this case, DivExp will not crawl into the first function, in which the second parameter is initialized with something other than Const.  This is called Pattern Matching (not to be confused with string matching). <br><br>  Now, about what the ‚Äús‚Äù function was made for.  For convenience only.  Compare 2 pieces with it: <br><br> <code>ast2haskell x op <font color="#a52a2a"><b>=</b></font> s op <font color="#2e8b57"><b>where</b></font> &lt;br&gt; <br> s (SubExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"-"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font> &lt;br&gt; <br> s (MulExp op1 op2) <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"("</font> <font color="#a52a2a"><b>++</b></font> s op1 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"*"</font> <font color="#a52a2a"><b>++</b></font> s op2 <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")"</font></code> <br> <br>  and without it: <br><br> <code>ast2haskell x (SubExp op1 op2) = "("++ast2haskell x op1++"-"++ast2haskell x op2++")" <br> ast2haskell x (MulExp op1 op2) = "("++ast2haskell x op1++"*"++ast2haskell x op2++")"</code> <br> <br>  Conclusion: the code with the ‚Äús‚Äù function is shorter, and you do not need to constantly drag this ‚Äúx‚Äù, passing it on. <br><br>  Let us now consider a new topic - how decoding of an opcode is performed in an operation, which we consider to be of type Op.  Each operation initially lies at some address in a binary file.  For most operations, the same address is the destination address for the result of the operation (the result of addition and other operations - everything is put into ‚Äúmemory‚Äù at this address, for each operation of its own).  That is why we pass into the function a pair of ‚Äúopcode, its address‚Äù, and at the output we have an already initialized operation, in which, in addition to the destination address, additional arguments are initialized, for each operation, its own. <br><br>  In the opcode specification, they are decoded in a cascade, that is, if the most significant part of the opcode is zero, then the next piece looks like, otherwise it is a ready opcode. The most significant part is four high-order bits, that is, 4 bits upwards, starting from the 28th bit (28, 29, 30 , 31). <br><br>  To extract bits from Word32, we have defined a function (.%.) Here that can be used as an operation (infix, that is, to stand between two operands, like + or *).  Haskel's syntax allows you to define a function with the name of any characters, for example, "++++" This is defined as: <br><br> <code>( <font color="#a52a2a"><b>++++</b></font> ) a b <font color="#a52a2a"><b>=</b></font> sqrt(a <font color="#a52a2a"><b>*</b></font> a <font color="#a52a2a"><b>+</b></font> b <font color="#a52a2a"><b>*</b></font> b)</code> <br> <br>  or otherwise: <br><br> <code>a <font color="#a52a2a"><b>++++</b></font> b <font color="#a52a2a"><b>=</b></font> sqrt(a <font><b>*</b></font> a <font color="#a52a2a"><b>+</b></font> b <font color="#a52a2a"><b>*</b></font> b)</code> <br> <br>  and is used like this: <br><br> <code><font color="#a52a2a"><b>let</b></font> q <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">3</font> <font color="#a52a2a"><b>++++</b></font> <font color="#ff00ff">4</font> &lt;br&gt; <br> <font color="#a52a2a"><b>let</b></font> p <font color="#a52a2a"><b>=</b></font> ( <font color="#a52a2a"><b>++++</b></font> ) <font color="#ff00ff">3</font> <font color="#ff00ff">4</font></code> <br> <br>  Thus, it turns out very convenient.  Also, you can make any of the ‚Äúnormal‚Äù functions of the two arguments infix, see the example below with 'shiftL' (left shift).  For these purposes, the function name is taken in reverse quotes and placed between operands.  For infix operators, all priorities are valid, but this is not our topic now, but the function itself (.%.) Will be defined below. <br><br><blockquote> <code>disasm <font color="#a52a2a"><b>::</b></font> (Word32, Int) <font color="#a52a2a"><b>-&gt;</b></font> Op&lt;br&gt; <br> disasm (opcode, addr) <font color="#a52a2a"><b>=</b></font> disasm1 (opcode <font color="#a52a2a"><b>.%.</b></font> ( <font color="#ff00ff">28</font> , <font color="#ff00ff">4</font> )) <font color="#0000ff">--   ""</font> &lt;br&gt; <font color="#0000ff">--    </font> &lt;br&gt; <br> <font color="#2e8b57"><b>where</b></font> &lt;br&gt; <br> r1 <font color="#a52a2a"><b>=</b></font> recast <font color="#a52a2a"><b>$</b></font> opcode <font color="#a52a2a"><b>.%.</b></font> ( <font color="#ff00ff">14</font> , <font color="#ff00ff">14</font> ) <font color="#0000ff">--      </font> &lt;br&gt; <br> r2 <font color="#a52a2a"><b>=</b></font> recast <font color="#a52a2a"><b>$</b></font> opcode <font color="#a52a2a"><b>.%.</b></font> ( <font color="#ff00ff">O</font> , <font color="#ff00ff">14</font> )  nbsp; <font color="#0000ff">--  </font> &lt;br&gt; <br> r1' <font color="#a52a2a"><b>=</b></font> <font color="#0000ff">--       </font> &lt;br&gt; <br> disasm1 i <font color="#a52a2a"><b>=</b></font> [disasm2 <font color="#a52a2a"><b>$</b></font> opcode <font color="#a52a2a"><b>.%.</b></font> ( <font color="#ff00ff">24</font> , <font color="#ff00ff">4</font> ) , Add addr r1 r2,Sub addr r1 r2,Mul addr r1 r2, Div addr r1 r2,Output r1 r2,Phi addr r1 r2] <font color="#a52a2a"><b>!!</b></font> recast i <br></code> </blockquote><br>  What happens in disasm1?  The definition of the list (square brackets) is again selected by index (operation "!!").  The recast function is described below, it converts signed to unsigned, because we have contacted Word32, and not just Int - and Haskell doesn‚Äôt really like to interfere with them, this is not C. Well, what about the list in question?  In the zero index we are sent to decode the second stage (the operation code is encoded with 4 bits starting from 24 bits up).  Further operations are added to add, subtract, and further specifications.  Phi operation will be reviewed separately. <br><br><blockquote> <code>disasm2 i <font color="#a52a2a"><b>=</b></font> [Noop addr, Cmpz (decodeImm (opcode <font color="#a52a2a"><b>.%.</b></font> ( <font color="#ff00ff">21</font> , <font color="#ff00ff">3</font> ))) r1',&lt;br&gt; <br> Sqrt addr r1',Copy addr r1',Input addr r1'] <font color="#a52a2a"><b>!!</b></font> recast i&lt;br&gt;</code> </blockquote> <br>  The second cascade, which is the final one, consists of the same meat.  In the specification of r1 for these operations lies in the same place as r2 for the first cascade, therefore there is a synonym for r1 ', for beauty.  Also there is a selection from the list by index.  In the first (starting from zero) there is a complex expression - the constructor Cmpz, for which the argument is calculated by special decoding from a piece of opcode (type of comparison with zero): <br><br><blockquote> <code>decodeImm i <font color="#a52a2a"><b>=</b></font> [Ltz,Lez,Eqz,Gez,Gtz] <font color="#a52a2a"><b>!!</b></font> recast i <font color="#0000ff">--          enum (     ).</font></code> </blockquote> <br>  And here are the bit biting operations themselves - live broadcast from C. <br><br><blockquote> <code>mask x n <font color="#a52a2a"><b>=</b></font> x <font color="#a52a2a"><b>.&amp;.</b></font> (( <font color="#ff00ff">1</font> <font color="#a52a2a"><b>`shiftL`</b></font> n) <font color="#a52a2a"><b>-</b></font> <font color="#ff00ff">1</font> ) <font color="#0000ff">--  =  n    x</font> &lt;br&gt; <br> ( <font color="#a52a2a"><b>.%.</b></font> ) w32 (start,len) <font color="#a52a2a"><b>=</b></font> (w32 <font color="#a52a2a"><b>`shiftR`</b></font> start) <font color="#a52a2a"><b>`mask`</b></font> len <font color="#0000ff">-- ,  </font> &lt;br&gt;</code> </blockquote> <br>  And this function (recast) converts from signed to unsigned and vice versa, depending on the context.  It is not very effective, but it works normally in our task.  Here the types are not explicitly indicated, only their class is indicated (Integral).  Here, Haskel remarkably substitutes the necessary types in each case (Int or Word32) and for each of them there are operations fromInteger / toInteger.  Note that the types will be displayed in the compilation process, and not in runtime (which I remind just in case). <br><br><blockquote> <code>recast <font color="#a52a2a"><b>::</b></font> (Integral a, Integral b) <font color="#a52a2a"><b>=&gt;</b></font> a <font color="#a52a2a"><b>-&gt;</b></font> b&lt;br&gt; <br> recast x <font color="#a52a2a"><b>=</b></font> (fromInteger <font color="#a52a2a"><b>.</b></font> toInteger) x <font color="#0000ff">--  ,  "fromInteger (toInteger x)",  </font></code> </blockquote> <br>  and you can also write like this: <br><br><blockquote> <code>recast x <font color="#a52a2a"><b>=</b></font> fromInteger <font color="#a52a2a"><b>$</b></font> toInteger x <font color="#0000ff">--    ,   </font> &lt;br&gt; <br> <font color="#0000ff">--  ,    :   </font> &lt;br&gt; <br> <font color="#0000ff">--  $    </font> &lt;br&gt; <br> <font color="#0000ff">--   (  )  .</font> &lt;br&gt;</code> </blockquote> <br>  and you can also write like this: <br><br><blockquote> <code>recast <font color="#a52a2a"><b>=</b></font> fromInteger <font color="#a52a2a"><b>.</b></font> toInteger <font color="#0000ff">--  ,    .</font> <br> <font color="#0000ff">-- ,    ,   </font> <br> <font color="#0000ff">--   </font> <br></code> <br><br>  The end of part 1 (size limit), the second part <a href="http://san13.habrahabr.ru/blog/70179/">will follow</a> . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/68995/">https://habr.com/ru/post/68995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68987/index.html">The best age for starting a startup is 40 years</a></li>
<li><a href="../68988/index.html">Men, do you really want to know?</a></li>
<li><a href="../68989/index.html">Computer control via SMS</a></li>
<li><a href="../68990/index.html">Search@Mail.Ru: search preferences ratings</a></li>
<li><a href="../68992/index.html">Hacker help for broken hearts</a></li>
<li><a href="../68998/index.html">We leave in DOS, in normal, pure DOS</a></li>
<li><a href="../69000/index.html">Patterns and methods of their destruction</a></li>
<li><a href="../69001/index.html">Bit.ly overtook TinyURL</a></li>
<li><a href="../69003/index.html">PHP, Closures, use & references</a></li>
<li><a href="../69004/index.html">HTC Tattoo HTC's first budget Android smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>