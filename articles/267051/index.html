<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Retreat 
 A lot of time has passed from the last article I wrote, for which I apologize: the Unified State Exam, admission, the beginni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part one</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><h5>  Retreat </h5><br>  A lot of time has passed from the last article I wrote, for which I apologize: the Unified State Exam, admission, the beginning of studies.  Now, when the session is still far away, and the learning process does not take much time, I can continue to write articles about mastering our K1986BE92QI. <br><br><h5>  Work plan </h5><br>  In the comments to the previous articles I was asked to highlight not only the work with the microcontroller through the setting of registers, but also using SPL (Universal Library for auto-configuration of peripherals.).  When we first started, I wouldn‚Äôt do that, because the temptation to use SPL instead of manual tuning using CMSIS would be great, and you would very likely, contrary to common sense, start using SPL everywhere you could.  Now, having learned to work with some blocks of the periphery manually, we can touch the SPL and compare the efficiency of both approaches in a real task. <br><br><h5>  purpose </h5><br>  As a learning goal, let's blink the LED by means of PWM (Pulse Width Modulation), while adjusting its frequency with the buttons.  Buttons will also be polled in the interrupt caused by another timer, and at the time of polling we will invert the state of the second LED.  In the implementation of this task we need: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Set the I / O port pin connected to the LED for manual control.  This LED will show that we entered the interrupt and polled the buttons. <br>  2. Set the output of the I / O port connected to the second LED to timer control mode.  This is where the PWM signal from the first timer will be sent. <br>  3. Set the first timer to supply the PWM signal to the second LED. <br>  4. Set the timer for the interrupt call, in which we will poll the keys. <br>  5. Allow the use of interrupts at the timer level (for a specific event) and at the level of the general interrupt vector table from the second timer as a whole. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/bBR7Anb6qxo%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiLu1Pv6m-8SVZxDhoqlObtq-Tuvg" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h4>  Manual setting </h4><br><h5>  Timer 1. Implementation of PWM </h5><br>  With the work of the timer, we have already encountered <a href="http://habrahabr.ru/post/256577/">in this article</a> .  But at that time we had very different goals and the current setting is a bit more complicated than the one that was described in the article above. <br><br>  Let's start. <br><ol><li>  To begin with, we will create an empty function shell that will initialize the timer.  At the input it should take some value characterizing the speed of PWM.  She can have absolutely any name. <br><div class="spoiler">  <b class="spoiler_title">For example, such.</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         . void initTimerPWMled (uint32_t PWM_speed) { }</span></span></code> </pre> </div></div></li><li>  Further it is worth remembering the structure of the timer. <br><br><div class="spoiler">  <b class="spoiler_title">Timer structure.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/db9/f94/bc0/db9f94bc0d7e457d89f5803a25629c77.PNG"></div></div><br><br>  The structure of all three timers of our microcontroller is the same.  Each timer has 4 channels, each of which allows you to work in the ‚Äúcapture‚Äù mode and PWM.  We are interested in the latter.  Also, each channel has exits.  And 2: "direct" and inverted.  We are interested in "direct".  As output for outputting a PWM signal, we will use the output of the first channel of the first timer.  Before moving on to the registers, let's highlight the main task: our goal is to wait some time, the timer itself changes its state at its output cyclically. </li><li>  Before we start setting up the timer, we need to configure the output of the I / O port to work with the timer.  I talked about how to customize the pins of the I / O ports in great detail <a href="http://habrahabr.ru/post/255323/">here</a> . <br><br>  We decided to use the direct output of the first channel of the first timer. <br><br><div class="spoiler">  <b class="spoiler_title">The findings have the following names.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9aa/b1f/9e7/9aab1f9e730f4e39bab2af9aca0b054c.PNG"></div></div><br><br>  Therefore, we need a channel TMR1_CH1. <br><div class="spoiler">  <b class="spoiler_title">We find it.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/2fd/cca/a14/2fdccaa14c0448f68c6c4d42cd4e8530.PNG"></div></div>  As we see, it is connected by an alternative function to the channel PA1.  Despite the fact that there are more conclusions that are connected to TMR1_CH1, we will use PA1. <br>  To do this, we need to apply clocking to the port (and at the same time to timer 1) and transfer the output to the alternative function mode. <pre> <code class="cpp hljs">MDR_RST_CLK-&gt;PER_CLOCK |= RST_CLK_PCLK_TIMER1|RST_CLK_PCLK_PORTA; <span class="hljs-comment"><span class="hljs-comment">//      A. MDR_PORTA-&gt;OE |= (1&lt;&lt;1); // . MDR_PORTA-&gt;FUNC |= (2&lt;&lt;(1*2)); //   -  . MDR_PORTA-&gt;ANALOG |= (1&lt;&lt;1); // . MDR_PORTA-&gt;PWR |= (3&lt;&lt;(1*2)); //     .</span></span></code> </pre> </li><li>  Next, we need to allow the clock signal to be sent to the timer itself (we have already turned it on, but we didn‚Äôt give a signal from which it will count).  For this there is a register MDR_RST_CLK-&gt; TIM_CLOCK. <div class="spoiler">  <b class="spoiler_title">TIM_CLOCK</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/162/d9d/6ec/162d9d6ecb514c7280251ba807ef7af4.PNG"><img src="https://habrastorage.org/files/78d/096/d1c/78d096d1c0cb4208be3803eb9321b722.PNG"></div></div>  Here we only need to apply the clocking to the timer. <pre> <code class="cpp hljs">MDR_RST_CLK-&gt;TIM_CLOCK |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN; <span class="hljs-comment"><span class="hljs-comment">//    .</span></span></code> </pre> </li><li>  And now - the registers of the timer itself.  Despite the fact that the timer has a lot of registers - most of them copy each other, since the structure of the control registers for each channel is the same.  To begin, consider the registers of the entire timer, and then for a particular channel. <ol><li>  The CNT can be called the base.  It is the value in it that is compared with the ‚Äúreference‚Äù one and in the event of a coincidence some action takes place.  It is from him that the timer starts counting. <br><br>  In our case, it is enough that it is zero.  In spite of the fact that it had to be equal to zero when it was turned on, it is better to reset it just in case, since  It is possible that after a software reset, the value in it will be non-zero. <br><br><div class="spoiler">  <b class="spoiler_title">CNT</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/431/32b/6e2/43132b6e2a13483ca50e90bc116d21cd.PNG"></div></div><br><pre> <code class="cpp hljs">MDR_TIMER1-&gt;CNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   0.</span></span></code> </pre> </li><li>  Psg.  This register is responsible for dividing the input signal.  In our case, 8000000 pulses per second are fed to the timer input (since by default the controller frequency is 8 MHz = 8000000 Hz), and we did not use dividers before the timer.  As can be seen from the description, from the divider that we choose, we need to subtract 1 and put this number in the register.  Since  we plan to change the PWM frequency in the range from 0.5 Hz to 250 Hz (From slow blinking every 2 seconds to indistinguishable by a human eye flickering like a dim burning), then a suitable divider can be 32000. This number is in the 16-bit range numbers  Thus, every 32,000 ticks in the CNT will be decreasing / decreasing (depending on the setting) unit. <br><br><div class="spoiler">  <b class="spoiler_title">Psg</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/891/ce2/df3/891ce2df3ec6488baf9b87013f0f54c6.PNG"></div></div><pre> <code class="cpp hljs">MDR_TIMER1-&gt;PSG = <span class="hljs-number"><span class="hljs-number">32000</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     TIM_CLK/32000.</span></span></code> </pre> </li><li>  ARR.  It is with this number that the number in CNT will be compared.  Since we have 250 ticks - this is one second, we will choose half of this time, so that in a second the LED has time to change its state twice.  This is the number we will indicate when calling the timer initialization function. <div class="spoiler">  <b class="spoiler_title">ARR</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/045/a13/bba/045a13bbadea4b89a15adb6bf61de21b.PNG"></div></div><br><pre> <code class="cpp hljs">MDR_TIMER1-&gt;ARR = PWM_speed; <span class="hljs-comment"><span class="hljs-comment">// 1  250 .    2 .</span></span></code> </pre> </li><li>  With the general settings of the timer figured out.  Can be taken for setting the signal to exit.  For each channel, you can customize your signal.  In our case (for the first channel), the register is CH1_CNTRL.  As we agreed above, we must always have some kind of signal at the exit.  Either "0" - or "1".  We don‚Äôt need the ‚Äúdead zone‚Äù.  And we need both ‚Äú0‚Äù and ‚Äú1‚Äù to be equal intervals.  For these purposes there is a REF signal.  It can be either "1" or "0".  We can also change its values ‚Äã‚Äãwhenever CNT == ARR.  To do this, we need to write 0x03 (0b011) to the OCCM cell.  All other parameters suit us by default. <br><br><div class="spoiler">  <b class="spoiler_title">CH1_CNTRL</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b9a/363/036/b9a363036be545bbb138d59b9acc4c03.PNG"><img src="https://habrastorage.org/files/655/b73/09b/655b7309b02a4ad58fe9d878bfab3e1f.PNG"><img src="https://habrastorage.org/files/b91/e37/3a3/b91e373a39f34e9eab31a0e2aa4b4425.PNG"><img src="https://habrastorage.org/files/56d/433/af0/56d433af080442e28d98c1bc053355b1.PNG"></div></div><pre> <code class="cpp hljs">MDR_TIMER1-&gt;CH1_CNTRL = <span class="hljs-number"><span class="hljs-number">3</span></span>&lt;&lt;TIMER_CH_CNTRL_OCCM_Pos; <span class="hljs-comment"><span class="hljs-comment">//  REF,  CNT = CCR;</span></span></code> </pre> </li><li>  Now we need to configure the channel output.  We agreed to use the first one.  Here we need the register CH1_CNTRL1.  We have already formed a REF signal.  Now we just need to set up a ‚Äúdirect‚Äù output to the output and submit a REF to it.  It is important not to confuse the SELO and SELOE bit groups.  <b>SELO selects which signal goes to the output, and SELOE chooses whether the output is output or not</b> . <div class="spoiler">  <b class="spoiler_title">CH1_CNTRL1</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0a5/3b5/143/0a53b51433f04cb498c3d393d2d2f20a.PNG"><img src="https://habrastorage.org/files/f68/55b/a3a/f6855ba3ac734a21a46ac804268949c7.PNG"></div></div><pre> <code class="cpp hljs">MDR_TIMER1-&gt;CH1_CNTRL1 = (<span class="hljs-number"><span class="hljs-number">2</span></span>&lt;&lt;TIMER_CH_CNTRL1_SELO_Pos) <span class="hljs-comment"><span class="hljs-comment">//     c REF. | (1&lt;&lt;TIMER_CH_CNTRL1_SELOE_Pos); //     .</span></span></code> </pre> </li><li>  Now we just have to turn on the timer in the central register (I deliberately didn‚Äôt consider it before, as it should be used only after setting the entire timer). <div class="spoiler">  <b class="spoiler_title">CNTRL</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fcb/480/af9/fcb480af961045698173469475a11e94.PNG"><img src="https://habrastorage.org/files/72b/8e5/96c/72b8e596c75641288953e30a64a98253.PNG"><img src="https://habrastorage.org/files/39f/259/8c8/39f2598c8f664386ab16a3a287178f42.PNG"></div></div><pre> <code class="cpp hljs">MDR_TIMER1-&gt;CNTRL = TIMER_CNTRL_CNT_EN; <span class="hljs-comment"><span class="hljs-comment">//  .</span></span></code> </pre> </li><li>  As a result, we get a working function that initializes the timer in the PWM mode and the output, at which the logic levels oscillate. <div class="spoiler">  <b class="spoiler_title">Total initialization function TIMER1</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         . void initTimerPWMled (uint32_t PWM_speed) { MDR_RST_CLK-&gt;PER_CLOCK |= RST_CLK_PCLK_TIMER1|RST_CLK_PCLK_PORTA; //      A. MDR_RST_CLK-&gt;TIM_CLOCK |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN; //    . MDR_PORTA-&gt;OE |= (1&lt;&lt;1); // . MDR_PORTA-&gt;FUNC |= (2&lt;&lt;(1*2)); //   -  . MDR_PORTA-&gt;ANALOG |= (1&lt;&lt;1); // . MDR_PORTA-&gt;PWR |= (3&lt;&lt;(1*2)); //     . MDR_TIMER1-&gt;CNT = 0; //   0. MDR_TIMER1-&gt;PSG = 32000-1; //     TIM_CLK/32000. MDR_TIMER1-&gt;ARR = PWM_speed; // 1  250 .    2 . MDR_TIMER1-&gt;CH1_CNTRL = 3&lt;&lt;TIMER_CH_CNTRL_OCCM_Pos; //  REF,  CNT = CCR; MDR_TIMER1-&gt;CH1_CNTRL1 = (2&lt;&lt;TIMER_CH_CNTRL1_SELO_Pos) //     c REF. | (1&lt;&lt;TIMER_CH_CNTRL1_SELOE_Pos); //     . MDR_TIMER1-&gt;CNTRL = TIMER_CNTRL_CNT_EN; //  . }</span></span></code> </pre> </div></div></li></ol><br></li></ol><br><h5>  Timer 2. Calling interrupts for polling keys, changing the PWM frequency. </h5>  Now we are faced with the task of checking whether a key is pressed and, based on the click, change the frequency of our PWM.  We will interrogate the keyboard 25 times a second and without checking released pressing.  This will give us the opportunity to do a larger run-up of the PWM parameter when pressed. <br><ol><li>  Before setting the timer, we will configure the pins for all keys that are on our debug board. <div class="spoiler">  <b class="spoiler_title">They are connected as follows.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d6d/139/3cd/d6d1393cdb934136a65052d439ffec93.PNG"></div></div>  As we can see, the keys are connected to three different ports.  Therefore, we need to configure all three ports.  I note that the tightening and chattering capacitor protection is already present on the board and it is not necessary to turn on the internal tightening.  We have repeatedly come up against port configuration. <div class="spoiler">  <b class="spoiler_title">The final initialization code will look like this.</b> <div class="spoiler_text">  Defines. <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    . #define DOWN_MSK (1&lt;&lt;1) // PORTE #define SELECT_MSK (1&lt;&lt;2) // PORTC #define LEFT_MSK (1&lt;&lt;3) // PORTE #define UP_MSK (1&lt;&lt;5) // PORTB #define RIGHT_MSK (1&lt;&lt;6) // PORTB #define PWRMAX_UP_MSK (3&lt;&lt;2*5)// PORTB #define PWRMAX_RIGHT_MSK (3&lt;&lt;2*6) #define PWRMAX_SELECT_MSK (3&lt;&lt;2*2)// PORTC. #define PWRMAX_DOWN_MSK (3&lt;&lt;2*1)// PORTE. #define PWRMAX_LEFT_MSK (3&lt;&lt;2*3)</span></span></code> </pre> <br>  The setting function itself. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     B, C, E     , //   . //     inc . void initPinForButton (void) { MDR_RST_CLK-&gt;PER_CLOCK |= RST_CLK_PCLK_PORTB|RST_CLK_PCLK_PORTC|RST_CLK_PCLK_PORTE; //    B, C, E. MDR_PORTB-&gt;OE &amp;= ~((uint32_t)(UP_MSK|RIGHT_MSK)); // . MDR_PORTB-&gt;FUNC &amp;= ~((uint32_t)(UP_MSK|RIGHT_MSK)); //   - . MDR_PORTB-&gt;ANALOG |= UP_MSK|RIGHT_MSK; // . MDR_PORTB-&gt;PULL &amp;= ~((uint32_t)(UP_MSK|RIGHT_MSK|UP_MSK&lt;&lt;16|RIGHT_MSK&lt;&lt;16)); //  . MDR_PORTB-&gt;PD &amp;= ~((uint32_t)(UP_MSK|RIGHT_MSK|UP_MSK&lt;&lt;16|RIGHT_MSK&lt;&lt;16)); //     200  //  . MDR_PORTB-&gt;PWR |= PWRMAX_UP_MSK|PWRMAX_RIGHT_MSK; //    . MDR_PORTB-&gt;GFEN |= UP_MSK|RIGHT_MSK; //    (   10 ). MDR_PORTC-&gt;OE &amp;= ~((uint32_t)(SELECT_MSK)); // . MDR_PORTC-&gt;FUNC &amp;= ~((uint32_t)(SELECT_MSK)); //   - . MDR_PORTC-&gt;ANALOG |= SELECT_MSK; // . MDR_PORTC-&gt;PULL &amp;= ~((uint32_t)(SELECT_MSK|SELECT_MSK&lt;&lt;16)); //  . MDR_PORTC-&gt;PD &amp;= ~((uint32_t)(SELECT_MSK|SELECT_MSK&lt;&lt;16)); //     200 . //  . MDR_PORTC-&gt;PWR |= PWRMAX_SELECT_MSK; //   . MDR_PORTC-&gt;GFEN |= SELECT_MSK; //    (   10 ). MDR_PORTE-&gt;OE &amp;= ~((uint32_t)(DOWN_MSK|LEFT_MSK)); // . MDR_PORTE-&gt;FUNC &amp;= ~((uint32_t)(DOWN_MSK|LEFT_MSK)); //   - . MDR_PORTE-&gt;ANALOG |= DOWN_MSK|LEFT_MSK; // . MDR_PORTE-&gt;PULL &amp;= ~((uint32_t)(DOWN_MSK|LEFT_MSK|DOWN_MSK&lt;&lt;16|LEFT_MSK&lt;&lt;16)); //  . MDR_PORTE-&gt;PD &amp;= ~((uint32_t)(DOWN_MSK|LEFT_MSK|DOWN_MSK&lt;&lt;16|LEFT_MSK&lt;&lt;16)); //     200 . //  . MDR_PORTE-&gt;PWR |= PWRMAX_DOWN_MSK|PWRMAX_LEFT_MSK; //    . MDR_PORTE-&gt;GFEN |= DOWN_MSK|LEFT_MSK; //    (   10 ). }</span></span></code> </pre> </div></div></li><li>  Since all timers have the same structure, the setting of the second timer until a certain point will be identical to the setting of the previous one.  Also create a function that will initialize the timer. <div class="spoiler">  <b class="spoiler_title">I have it looks like this.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      25   . void initTimerButtonCheck (void) { }</span></span></code> </pre> </div></div></li><li>  Then everything is like in the first timer, only ARR is not 125 (half a second), but 10 (1 / 25th). <div class="spoiler">  <b class="spoiler_title">Filling registers.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">MDR_RST_CLK-&gt;PER_CLOCK |= RST_CLK_PCLK_TIMER2; <span class="hljs-comment"><span class="hljs-comment">//    2. MDR_RST_CLK-&gt;TIM_CLOCK |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN; //     . MDR_TIMER2-&gt;CNT = 0;//   0. MDR_TIMER2-&gt;PSG = 32000-1; //     TIM_CLK/32000. MDR_TIMER2-&gt;ARR = 10; // 1  250 .   25    =&gt; 250/25=10.</span></span></code> </pre> </div></div></li><li>  Next, we need to have an interrupt when we match the CNT and ARR.  For this we need a register of IE.  Of the variety of different cases causing an interruption, we need the simplest one: CNT_ARR_EVENT_IE. <div class="spoiler">  <b class="spoiler_title">IE</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/450/192/71a/45019271aac2412d92949532cb0d1df0.PNG"><img src="https://habrastorage.org/files/429/837/dea/429837deab964343902a22401cf45c87.PNG"><img src="https://habrastorage.org/files/61e/237/9c9/61e2379c9e1446d0838053d2a774b1d2.PNG"><img src="https://habrastorage.org/files/5cc/c59/905/5ccc599057c34855a2ccae3cb168e90a.PNG"></div></div><pre> <code class="cpp hljs">MDR_TIMER2-&gt;IE = TIMER_IE_CNT_ARR_EVENT_IE; <span class="hljs-comment"><span class="hljs-comment">//     CNT  ARR.</span></span></code> </pre> </li><li>  Now with CNT == ARR, we have an interrupt.  But it will not give us anything, because by default interrupts from the entire timer are prohibited.  You can fix this by enabling an interrupt from the entire timer in the NVIC controller.  In previous articles we have already dealt with it.  But then we flashed it in passing.  In order to enable or disable interrupts, CMSIS has its own functions.  You should not be afraid of them, because they are simple macros in one SI-command.  But they are great at improving code readability. <div class="spoiler">  <b class="spoiler_title">Here are some CMSIS commands we can use.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b35/c79/775/b35c797755c842568baa3bf83418e69a.PNG"></div></div>  From here, we need the NVIC_EnableIRQ function. <div class="spoiler">  <b class="spoiler_title">Its parameter can be obtained from the table in the file MDR32Fx.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* MDR32Fx Interrupt Number Definition */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> IRQn { <span class="hljs-comment"><span class="hljs-comment">/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/</span></span> NonMaskableInt_IRQn = <span class="hljs-number"><span class="hljs-number">-14</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*!&lt; 2 Non Maskable Interrupt */</span></span><span class="hljs-comment"><span class="hljs-comment">//!&lt; NonMaskableInt_IRQn HardFault_IRQn = -13, /*!&lt; 3 Hard Fault Interrupt *///!&lt; HardFault_IRQn MemoryManagement_IRQn = -12, /*!&lt; 4 Memory Management Interrupt *///!&lt; MemoryManagement_IRQn BusFault_IRQn = -11, /*!&lt; 5 Bus Fault Interrupt *///!&lt; BusFault_IRQn UsageFault_IRQn = -10, /*!&lt; 6 Usage Fault Interrupt *///!&lt; UsageFault_IRQn SVCall_IRQn = -5, /*!&lt; 11 SV Call Interrupt *///!&lt; SVCall_IRQn PendSV_IRQn = -2, /*!&lt; 14 Pend SV Interrupt *///!&lt; PendSV_IRQn SysTick_IRQn = -1, /*!&lt; 15 System Tick Timer Interrupt *///!&lt; SysTick_IRQn /*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/ CAN1_IRQn = 0, /*!&lt; CAN1 Interrupt *///!&lt; CAN1_IRQn CAN2_IRQn = 1, /*!&lt; CAN1 Interrupt *///!&lt; CAN2_IRQn USB_IRQn = 2, /*!&lt; USB Host Interrupt *///!&lt; USB_IRQn DMA_IRQn = 5, /*!&lt; DMA Interrupt *///!&lt; DMA_IRQn UART1_IRQn = 6, /*!&lt; UART1 Interrupt *///!&lt; UART1_IRQn UART2_IRQn = 7, /*!&lt; UART2 Interrupt *///!&lt; UART2_IRQn SSP1_IRQn = 8, /*!&lt; SSP1 Interrupt *///!&lt; SSP1_IRQn I2C_IRQn = 10, /*!&lt; I2C Interrupt *///!&lt; I2C_IRQn POWER_IRQn = 11, /*!&lt; POWER Detecor Interrupt *///!&lt; POWER_IRQn WWDG_IRQn = 12, /*!&lt; Window Watchdog Interrupt *///!&lt; WWDG_IRQn Timer1_IRQn = 14, /*!&lt; Timer1 Interrupt *///!&lt; Timer1_IRQn Timer2_IRQn = 15, /*!&lt; Timer2 Interrupt *///!&lt; Timer2_IRQn Timer3_IRQn = 16, /*!&lt; Timer3 Interrupt *///!&lt; Timer3_IRQn ADC_IRQn = 17, /*!&lt; ADC Interrupt *///!&lt; ADC_IRQn COMPARATOR_IRQn = 19, /*!&lt; COMPARATOR Interrupt *///!&lt; COMPARATOR_IRQn SSP2_IRQn = 20, /*!&lt; SSP2 Interrupt *///!&lt; SSP2_IRQn BACKUP_IRQn = 27, /*!&lt; BACKUP Interrupt *///!&lt; BACKUP_IRQn EXT_INT1_IRQn = 28, /*!&lt; EXT_INT1 Interrupt *///!&lt; EXT_INT1_IRQn EXT_INT2_IRQn = 29, /*!&lt; EXT_INT2 Interrupt *///!&lt; EXT_INT2_IRQn EXT_INT3_IRQn = 30, /*!&lt; EXT_INT3 Interrupt *///!&lt; EXT_INT3_IRQn EXT_INT4_IRQn = 31 /*!&lt; EXT_INT4 Interrupt *///!&lt; EXT_INT4_IRQn }IRQn_Type;</span></span></code> </pre> <br>  We need a second timer.  Therefore, our function will look like this. <pre> <code class="cpp hljs">NVIC_EnableIRQ(Timer2_IRQn); <span class="hljs-comment"><span class="hljs-comment">//      .</span></span></code> </pre> </div></div></li><li>  It remains only to enable the timer and our final function will be as follows. <div class="spoiler">  <b class="spoiler_title">Initialize timer 2 to poll buttons.</b> <div class="spoiler_text">  // Set the timer to generate interrupts 25 times per second. <br>  void initTimerButtonCheck (void) <br>  { <br>  MDR_RST_CLK-&gt; PER_CLOCK | = RST_CLK_PCLK_TIMER2;  // Enable timer clocking 2. <br>  MDR_RST_CLK-&gt; TIM_CLOCK | = RST_CLK_TIM_CLOCK_TIM2_CLK_EN;  // Feed clocking without a prescaler. <br>  MDR_TIMER2-&gt; CNT = 0;  // Count with 0. <br>  MDR_TIMER2-&gt; PSG = 32000-1;  // The timer TIM_CLK / 32000 goes to the timer. <br>  MDR_TIMER2-&gt; ARR = 10;  // 1 second 250 ticks.  We have 25 polls per second =&gt; 250/25 = 10. <br>  MDR_TIMER2-&gt; IE = TIMER_IE_CNT_ARR_EVENT_IE;  // Allow the interrupt on the combination of CNT and ARR. <br>  NVIC_EnableIRQ (Timer2_IRQn);  // Enable interrupt from the timer as a whole. <br>  MDR_TIMER2-&gt; CNTRL = TIMER_CNTRL_CNT_EN;  // Turn on the timer. <br>  } </div></div></li><li>  Now we need to create an interrupt handler.  His name is strictly fixed in the startup_MDR32F9Qx.s file.  There is only one interrupt vector for the entire timer.  All the names there are intuitive.  Ours is called Timer2_IRQHandler.  Create a function with empty input parameters.  And the first team needs to reset the interrupt flag, because of which we got here.  Otherwise, after exiting the interrupt, we will get back to its beginning.  It is also impossible to drop the flag at the end, because there is not enough time for it to be ‚Äúcompletely reset‚Äù and as a result we still fall into the interruption with the flag not thrown.  It is imperative that before exiting an interrupt there is at least one command dividing flag reset and exiting interrupt.  You can reset the flag in the register STATUS. <div class="spoiler">  <b class="spoiler_title">STATUS</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/71d/f4b/87c/71df4b87c4094386890562099d2a7280.PNG"><img src="https://habrastorage.org/files/3a0/590/d5f/3a0590d5fba24cd6a2b649830b67efc4.PNG"><img src="https://habrastorage.org/files/511/7bc/33a/5117bc33a55a4746befef294685316bb.PNG"></div></div>  Since we have only one event from the timer used, we can safely write "0" in the entire register.  If we didn‚Äôt have several events, we would have to first check which event occurred.  In our case, the function will be as follows. <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ MDR_TIMER2-&gt;STATUS = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  .   . //       . }</span></span></code> </pre> </li><li>  At the very beginning of the article, we decided that when entering an interrupt, we would change the state of the LED to show that the interrupt had been processed.  To do this, we need to use one of two custom LEDs connected to PC0 and PC1 pins. <div class="spoiler">  <b class="spoiler_title">Connecting LEDs.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/263/9c7/075/2639c70750da4e3cb12af78d12bbe970.PNG"></div></div>  I suggest using PC0 for this purpose (on the board it‚Äôs on the left).  And the LED connected to PC1 must be disconnected from the output of the microcontroller and connected with a wire to PA1 (our PWM pin). <div class="spoiler">  <b class="spoiler_title">The initialization of the LEDs will look like this.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  . #define LED0 (1&lt;&lt;0) // PORTC. #define LED1 (1&lt;&lt;1) // PORTC. #define PWRMAX_LED0 (3&lt;&lt;2*0) //    . #define PWRMAX_LED1 (3&lt;&lt;2*1) //   C     . void initPinPortCForLed (void) { MDR_RST_CLK-&gt;PER_CLOCK |= RST_CLK_PCLK_PORTC; //    C. MDR_PORTC-&gt;OE |= LED0|LED1; // . MDR_PORTC-&gt;FUNC &amp;= ~((uint32_t)(LED0|LED1)); //   - . MDR_PORTC-&gt;ANALOG |= LED0|LED1; // . MDR_PORTC-&gt;PULL &amp;= ~((uint32_t)(LED0|LED1|LED0&lt;&lt;16|LED1&lt;&lt;16)); //  . MDR_PORTC-&gt;PD &amp;= ~((uint32_t)(LED0|LED1|LED0&lt;&lt;16|LED1&lt;&lt;16)); //     200 . //  . MDR_PORTC-&gt;PWR |= PWRMAX_LED0|PWRMAX_LED1; //     . MDR_PORTC-&gt;GFEN &amp;= ~((uint32_t)(LED0|LED1)); //   . }</span></span></code> </pre> </div></div>  The function adjusts both LEDs, but since  the second is disconnected (jumper), then there will be no difference. </li><li>  It remains only to poll the keys and change the value in the ARR PWM timer.  But our buttons are connected to the 3rd different ports.  You can, of course, the old-fashioned way.  Take the values ‚Äã‚Äãfrom the whole port and use the mask to look at specific conclusions, but in this case it is much more convenient to use BitBanding.  If we don‚Äôt go into details, then each bit of the peripheral area (including I / O ports) has its own 32-bit cell.  In which either "1" or "0" is written.  Depending on the state of the bit.  You can work with them as with ordinary registers.  The entry "1" will give 1 in the desired bit of the real register.  ‚Äú0‚Äù is respectively 0. In order to get the addresses of these cells, you can use the very convenient <a href="http://catethysis.ru/calculators/">Catethysis</a> calculator.  Let us consider an example.  We have a UP key connected to pin 5 of port B. Go to the documentation and look at the address of the port register B. <div class="spoiler">  <b class="spoiler_title">We find there</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b45/957/8af/b459578aface42f48413d7487a104d75.PNG"></div></div>  We drive in this address in the ‚Äúregister‚Äù field, and in the ‚Äúbit‚Äù field we write 5. At the output we get 0x43600014.  Working with a cell at this address, we are working with bit 5 of port B. But it is impossible to simply write 0x43600014 = 1.  But * (uint32_t *) 0x43600014 = 1 - you can. <div class="spoiler">  <b class="spoiler_title">Now, in this way you can rewrite all the pins connected to the buttons.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . #define DOWN_FLAG *(uint32_t*)0x43900004 #define SELECT_FLAG *(uint32_t*)0x43700008 #define LEFT_FLAG *(uint32_t*)0x4390000c #define UP_FLAG *(uint32_t*)0x43600014 #define RIGHT_FLAG *(uint32_t*)0x43600018</span></span></code> </pre> </div></div>  Similarly, you can do for the LED. <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED0_FLAG *(uint32_t*)0x43700000</span></span></code> </pre> </li><li>  Now it remains only to record a poll of the buttons and a change in the ARR register of timer 1. <div class="spoiler">  <b class="spoiler_title">The final function will look like this.</b> <div class="spoiler_text">  int PWM_speed = 125; <br>  void Timer2_IRQHandler (void) <br>  { <br>  MDR_TIMER2-&gt; STATUS = 0;  // Reset the flag.  Be sure to be the first team. <br>  LED1_FLAG =! LED1_FLAG;  // Show that the interrupt was handled. <br>  if (UP_FLAG == 0) PWM_speed--;  // Check if any key is pressed.  If pressed, we do something with frequency. <br>  else if (DOWN_FLAG == 0) PWM_speed ++; <br>  else if (LEFT_FLAG == 0) PWM_speed--; <br>  else if (RIGHT_FLAG == 0) PWM_speed ++; <br>  if (PWM_speed &lt;1) PWM_speed = 1;  // Check that the frequency does not go beyond the range from 250 Hz to 0.5 Hz. <br>  else if (PWM_speed&gt; 500) PWM_speed = 500; <br>  MDR_TIMER1-&gt; ARR = PWM_speed;  // Change the frequency. <br>  } </div></div></li><li>  The main main function contains only an enumeration of all the above functions. <div class="spoiler">  <b class="spoiler_title">Looks like that.</b> <div class="spoiler_text">  int main (void) <br>  { <br>  initTimerPWMled (PWM_speed);  // Run PWM.  Parameter - PWM speed. <br>  initPinForButton ();  // Customize the buttons. <br>  initPinPortCForLed ();  // LED operation (key read). <br>  initTimerButtonCheck ();  // Initialize the timer. <br>  while (1) <br>  { <br>  } <br>  } </div></div></li></ol><br><h5>  Instead of conclusion </h5><br>  In this article we reviewed the implementation of the task without using the SPL library.  In the next article, we will accomplish the same task, but using only SPL and compare the results. <br><br>  <a href="https://cloud.mail.ru/public/N5uh/aHX4p6JQn">The final project.</a> <br><br><h5>  Small addition </h5><br>  At the moment, Milandr has released a new, revised version of SPL.  Unfortunately, not yet in the form of a full version.  In the current version, you cannot view the status of registers in keil windows.  But soon the full version will be released and this flaw will be fixed.  For those who want to try the new version - here is a link to a <a href="https://cloud.mail.ru/public/Dct5/58CNpVSaP">clean project</a> . <br><br>  Who needs windows - can still use the <a href="https://cloud.mail.ru/public/39iX/9eQkMNCez">stable old</a> . <br><div class="spoiler">  <b class="spoiler_title">List of previous articles.</b> <div class="spoiler_text"><ul><li>  1. <a href="http://habrahabr.ru/post/255199/">We turn from STM32F103 to K1986BE92QI.</a>  <a href="http://habrahabr.ru/post/255199/">Or the first acquaintance with the Russian microcontroller.</a> </li><li>  2. <a href="http://habrahabr.ru/post/255323/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255323/">Setup project in keil and flashing LED.</a> </li><li>  3. <a href="http://habrahabr.ru/post/255415/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255415/">System Timer (SysTick).</a> </li><li>  4. <a href="http://habrahabr.ru/post/255479/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255479/">Setting the clock frequency.</a> </li><li>  5. <a href="http://habrahabr.ru/post/255513/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255513/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/255513/">Part one: we generate a square and sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/255513/">Mastering the DAC (DAC).</a> </li><li>  6. <a href="http://habrahabr.ru/post/256091/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/256091/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256091/">Part two: generate a sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/256091/">Mastering DMA.</a> </li><li>  7. <a href="http://habrahabr.ru/post/256577/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/256577/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256577/">Part three: generate a sine wave.</a>  <a href="http://habrahabr.ru/post/256577/">A simple look at DMA + first acquaintance with timers.</a> </li><li>  8. <a href="http://habrahabr.ru/post/256621/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/256621/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256621/">Part Four: we create the digital part of a single-voiced and multi-voiced musical postcard.</a> </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/267051/">https://habr.com/ru/post/267051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267039/index.html">Private Cloud Appliance - the best virtualization and private cloud for data centers</a></li>
<li><a href="../267041/index.html">Dissect t-SNE</a></li>
<li><a href="../267045/index.html">System backup of virtual machines or how to save money organization</a></li>
<li><a href="../267047/index.html">Bot for sapper with a twist</a></li>
<li><a href="../267049/index.html">Ice started off: KC published a draft document on paperless transfer of .RU domains between registrars</a></li>
<li><a href="../267053/index.html">What can I learn from WhatsApp</a></li>
<li><a href="../267055/index.html">‚ÄúMade and forgotten‚Äù: Why is it not so in the layout of email-letters</a></li>
<li><a href="../267057/index.html">SYNful knock on the OS of Cisco Systems routers</a></li>
<li><a href="../267059/index.html">Overview of the Intent Sender plugin for Android Studio and certain features of its development</a></li>
<li><a href="../267061/index.html">Card game: we realize attack and we will find application of ShadowDOM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>