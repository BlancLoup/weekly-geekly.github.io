<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software renderer - 2: rasterization and attribute interpolation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. In the last article I described the mathematics, which is necessary to display a three-dimensional scene on the screen in the form of a grid ‚Äî we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software renderer - 2: rasterization and attribute interpolation</h1><div class="post__text post__text-html js-mediator-article">  Hey.  In the <a href="http://habrahabr.ru/post/243011/">last article</a> I described the mathematics, which is necessary to display a three-dimensional scene on the screen in the form of a grid ‚Äî  we stopped at the moment of obtaining the coordinates of the vertices in the space of the screen.  The next step is to ‚Äúfill‚Äù the polygons of which the object consists, i.e.  Search for pixels that are included in the image of an object on the screen.  The process of finding these points is called rasterization.  We also want to be able to texturize and illuminate objects ‚Äî to do this you need to be able to interpolate the attributes specified in the vertices (for example, texture coordinates, normals, color, and others). <br><br>  Our input data is a set of polygons (we will only consider triangles): the coordinates of their vertices (the coordinate system depends on the algorithm) and the values ‚Äã‚Äãof the attributes in each of these vertices, which will later be interpolated along the surface of the triangle.  There are several pitfalls that I will discuss in this article: <br><ul><li>  Pixel Fill Rule </li><li>  Accuracy </li><li>  Perspective correction with perspective-correct interpolation </li></ul><br>  I will consider three approaches to rasterization: <br><ul><li>  ‚ÄúStandard‚Äù algorithm using face tilt </li><li>  a number of algorithms based on the use of equations of the polygon (traversal-algorithms) </li><li>  uniform rasterization algorithm </li></ul><br>  Also at the end there will be a link to the project, which is an example of implementation, and there will also be code examples from there. <br><a name="habracut"></a><br><h4>  The basics </h4><br>  So, rasterization is the process of searching for pixels that are ‚Äúincluded‚Äù in a given polygon.  For a start, we will assume that it is enough for us to fill the polygon with a solid color - nothing superfluous. <br><br>  Imagine that we have the following triangle to display on the screen (all coordinates are already represented in screen space): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/99e/3f3/4f3/99e3f34f32c34b5287a6b7bdb9611259.png"><br><br>  What pixels need to paint over?  A pixel can be entirely outside the polygon, partially in the polygon and entirely in the polygon: <br><br><img src="https://habrastorage.org/files/2b7/cbb/fd9/2b7cbbfd93c24551b69a49a424656d54.png"><br><br>  Everything is simple for two cases: <br><ul><li>  Pixel is not included in the entire polygon (red color in the picture) - do not paint over </li><li>  Pixel enters the entire polygon (green color in the picture) - paint over </li></ul><br>  The third case (the pixel is partially inside the polygon) is more complicated.  The first solution that comes to mind is to assume that all such pixels are either included in the polygon or not.  But it leads to the wrong result.  Three-dimensional models that we are going to draw, consist of a set of triangles, which, in general, should not overlap each other.  Overlapping triangles do not make sense, since they only duplicate the already existing information.  Thus, many polygons have common faces.  The simplest example is a rectangle: <br><br><img src="https://habrastorage.org/files/691/364/56b/69136456b64f47b99969422291178b2a.png"><br><br>  Orange color indicates the pixels that are partially included in both polygons.  Now imagine that we rasterize both of these polygons.  If we decide that all pixels partially included in the polygon should be filled, we will get the same pixels filled twice (or more if there is a common vertex for more than two polygons).  This may not seem like a problem at first glance, but, in fact, it will lead to different artifacts using some techniques, such as alpha blending (drawing using the alpha channel to simulate transparency).  It also leads to a decrease in performance, because  the number of pixels for which we need to calculate attribute values ‚Äã‚Äãis increasing.  If, on the contrary, we decide that such pixels are not included in the final image and should not be filled, we will get ‚Äúholes‚Äù between polygons, which is unacceptable. <br><br>  Thus, we came to the understanding that when drawing adjacent polygons each pixel must be filled exactly once.  This is a requirement that both Direct3D and OpenGL comply with. <br><br>  The problem arises because of the need to display from continuous (screen coordinate system) to discrete (pixels on the monitor).  The traditional rasterization algorithm (when drawing without smoothing) solves this in the following way: a certain point (sample point) is assigned to each pixel, which is responsible for the pixel's entry into the polygon.  Also, it is at this point that the values ‚Äã‚Äãof all necessary attributes are considered.  In other words, all the space occupied by a pixel in the coordinate system of the screen is ‚Äúrepresented‚Äù by one point.  As a rule, this is the center: (0.5, 0.5): <br><br><img src="https://habrastorage.org/files/5bb/eeb/087/5bbeeb087331459c9ce72cc17541c1b8.png"><br><br>  Theoretically, you can take any point inside the pixel, instead of the center.  Other values ‚Äã‚Äãwill result in the image being ‚Äúshifted‚Äù by a pixel to one of the sides.  Also, in a situation with adjacent polygons, for pixels in which the vertices of the triangles are not located, the use of a point (0.5, 0.5) has a good property: this point enters the polygon that covers more than 50% of the area of ‚Äã‚Äãthe rectangle representing a pixel. <br><br>  Thus, if the center of a pixel enters a polygon, then it is considered that the pixel belongs to the polygon.  But now the following problem arises: what if two polygons have a common face that passes through the center of a pixel?  We already understood that a pixel should belong only to one of two triangles, but which one?  In the image below, this pixel is marked in red: <br><br><img src="https://habrastorage.org/files/461/5d1/147/4615d1147f4548a8a4abd883aadbe892.png"><br><br>  This problem is solved by the so-called ‚Äúfilling agreement‚Äù. <br><br><h5>  Filling Agreement </h5><br>  So, suppose we are faced with the situation described above - two polygons divide the face between each other, which runs exactly through the center of the pixel.  Our task is to find out which of the polygons this pixel belongs to. <br><br>  The de facto standard is the so-called top-left rule: it follows DirectX and most implementations of OpenGL.  The essence of this rule is as follows: if a face of a polygon passes through the center of a pixel, then this pixel belongs to the polygon in two cases - if it is the left face or the top face (hence the name). <br><br>  The concepts of left, right, top and bottom faces require explanation.  For now, we will not give exact definitions (we will do this when we get to the traversal algorithms), but we will describe them in a simpler language: <br><ul><li>  The top face is a horizontal face that is above all other faces. </li><li>  Bottom face is a horizontal face that is below all other faces. </li><li>  The left side is a face that is located on the left side of the triangle and is not horizontal. </li><li>  The right side is a face that is located on the right side of the triangle and is not horizontal. </li></ul><br>  Examples: <br><br><img src="https://habrastorage.org/files/cff/c23/fc1/cffc23fc1c3d421a9c04052ee2b8282f.png"><br><br>  Now consider the case of adjacent polygons.  If the face is adjacent, and is left in one polygon, then this same edge is right for all polygons that share this edge with this polygon.  A similar rule works for the upper and lower edges: <br><br><img src="https://habrastorage.org/files/914/6c3/983/9146c398307f419bb05aad503024a683.png"><br><br>  We can use this property to determine which of the adjacent polygons a pixel belongs to.  If we agree that a pixel, whose center lies on a common face, belongs only to polygons, in which this face is left, then it will not automatically belong to adjacent polygons, since for them this face is right.  And the same for the top face. <br><br>  In spite of the fact that the rule of the top and left face occurs most often, we can use any suitable combination.  For example, the rule of the bottom and left side, top and right, etc.  Direct3D obliges to use top-left rule, OpenGL is not so strict and allows you to use any rule that solves the problem of pixel ownership.  I will further suggest the use of top-left rule. <br><br><h5>  Accuracy </h5><br>  Consider the following two polygons: <br><br><img src="https://habrastorage.org/files/86b/f75/63c/86bf7563c62d4fdabd7e8ed0b9857a56.png"><br><br>  The second polygon can be obtained from the first as a result of rotation at a certain angle.  As a result, some pixels are additionally included in the final image (such pixels are marked in green), and some, on the contrary, disappear from it (marked in red).  Accordingly, we need to take into account the fractional parts of the coordinates of the vertices.  If we discard them, we get problems when drawing a non-static scene.  If, for example, you make the polygon rotate very slowly, then it will do it jerky - because the edges will ‚Äújump‚Äù sharply from one position to another, instead of correctly processing intermediate results.  The difference is easy to understand by comparing these two videos: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/q91PmSSNA84%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXvhXOjzMCYi6bP7KZbX659tyCug" frameborder="0" allowfullscreen=""></iframe><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/oButKL-5L8s%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhECPXe7OzDPmTi-zmie2NYrwioWQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Of course, in the case of a static scene, such problems will not arise. <br><br><habracut><h4>  Attribute Interpolation </h4><br>  Before proceeding directly to rasterization algorithms, let us dwell on the interpolation of attributes. <br><br>  An attribute is some information related to an object, which is necessary for its correct drawing according to a given algorithm.  Anything can be such an attribute.  One of the most frequent options are: color, texture coordinates, normal coordinates.  Attribute values ‚Äã‚Äãare specified at the vertices of the object grid.  When rasterizing polygons, these attributes interpolate along the surface of triangles and are used to calculate the color of each of the pixels. <br><br>  The simplest example (and a kind of analogue of the ‚Äúhello world‚Äù) is the drawing of a triangle, at each vertex of which there is one attribute ‚Äî the color: <br><br><img src="https://habrastorage.org/files/a2b/d98/635/a2bd986356d94d529c95bfc644d813fc.png"><br><br>  In this case, if we assign a color to each pixel of the polygon, which is the result of linear interpolation of the colors of the three vertices, we will get the following image: <br><br><img src="https://habrastorage.org/files/f63/5b2/228/f635b222835c43238e6912449596f092.png" width="200"><br><br>  The way in which interpolation is performed depends on the data we use in the drawing process, and they, in turn, depend on the algorithm that is used in rasterization.  For example, when using the "standard" algorithm, we can use simple linear interpolation of values ‚Äã‚Äãbetween two pixels, and when using traversal-algorithms, barycentric coordinates.  Therefore, we postpone it until the description of the algorithms themselves. <br><br>  Nevertheless, there is another important topic that needs to be addressed in advance: interpolation of attributes with perspective correction. <br><br>  The easiest way to interpolate is linear interpolation in screen space: after the polygon has been projected onto the projection plane, we interpolate the attributes along the surface of the triangle in a linear fashion.  It is important to understand that this interpolation is not correct, since it does not take into account the projection produced. <br><br>  Consider the projection of the line onto the projection plane <i>d = 1</i> .  At the initial and final vertices are set some attributes that vary linearly in the space of the camera (and in the world).  After the projection is made, these attributes do not grow linearly in screen space.  If, for example, we take the middle point in camera space ( <i>v = v0 * 0.5 + v1 * 0.5</i> ), then after the projection this point will not lie in the middle of the projected line: <br><br><img src="https://habrastorage.org/files/dd9/baa/142/dd9baa142b54446ead5d2f6c5249a893.png"><br><br>  This is easiest to notice when texturing objects (I will use simple texturing without filtering in the examples below).  I have not yet described the texturing process in detail (and this is the topic of a separate article), so for the time being I will limit myself to a brief description. <br><br>  When texturing at each vertex of the polygon, the attribute value of texture coordinates is specified (it is often called uv by the name of the corresponding axes).  These are the normalized coordinates (from <i>0</i> to <i>1</i> ) that determine which part of the texture will be used. <br>  Now imagine that we want to draw a textured rectangle and set the four values ‚Äã‚Äãof the uv attribute so that the texture is used entirely: <br><br><img src="https://habrastorage.org/files/8e2/e54/bbe/8e2e54bbe0c3484bbfd80f74c5515315.png"><br><br>  It seems that everything is not bad: <br><br><img src="https://habrastorage.org/files/e79/70c/8e1/e7970c8e1c7b4add85a084efac300451.png" width="200"><br><br>  However, this model is parallel to the projection plane, and therefore there should be no distortion due to the perspective.  Let's try to move the top two vertices by one along the <i>z</i> axis, and the problem will be immediately visible: <br><br><img src="https://habrastorage.org/files/9dc/d0e/939/9dcd0e9396d34002aaa9c1b14358ac05.png" width="200"><br><br>  Thus, it is necessary to consider the perspective when interpolating attributes.  The key fact to this is that, although <i>z</i> cannot be correctly interpolated in screen space, <i>1 / z</i> - it can.  Consider the line projection again: <br><br><img src="https://habrastorage.org/files/65a/536/21a/65a53621ae0e44fe85a17e980b0e54b1.png"><br><br><img src="https://habrastorage.org/files/033/7ad/f09/0337adf09ac745bf9c2ffd6c59b1ac8e.png"><br><br>  We also already know that along similar triangles: <br><br><img src="https://habrastorage.org/files/3ad/18d/89d/3ad18d89d2c248adaf9e0e06e8b3c721.png"><br><br>  Interpolating <i>x</i> in screen space, we get: <br><br><img src="https://habrastorage.org/files/b8b/e2e/978/b8be2e97898d4191ba33b8fae0dca31f.png"><br><br>  Interpolating <i>x</i> in camera space, we get: <br><br><img src="https://habrastorage.org/files/f8b/d4d/cdb/f8bd4dcdb6e949feb0af7c21174ea30c.png"><br><br>  These three equations are key and all subsequent formulas are derived from them.  I will not give a complete conclusion, since it is easy to do this on my own, and I will describe it only briefly, focusing on the results. <br><br>  Substituting these two equalities into the equation obtained from the ratios of the sides of the triangle, and simplifying all the expressions, we end up with the fact that the inverse of the <i>z-</i> coordinate can be linearly interpolated in screen space: <br><br><img src="https://habrastorage.org/files/83c/dd9/c12/83cdd9c12af3447e912b7f0ecd1fae98.png"><br><br>  It is important that in this expression interpolation occurs between the values ‚Äã‚Äãinverse of the <i>z</i> coordinates of the camera space. <br><br>  Further, suppose that at the vertices <i>A</i> and <i>B the</i> values ‚Äã‚Äãof a certain attribute are given, we denote them by <i>T1</i> and <i>T2</i> , which can also be linearly interpolated in the camera space: <br><br><img src="https://habrastorage.org/files/3ca/d2a/d7d/3cad2ad7d4b341ed81879b63e3d8dfc5.png"><br><br>  Using intermediate results from the above output, we can write down that the <i>Tc / Zc</i> value can also be correctly interpolated in screen space: <br><br><img src="https://habrastorage.org/files/77c/0c8/afd/77c0c8afd17b4d29b4fcc4a7909b4419.png"><br><br>  Summarizing, we obtained that <i>1 / Zc</i> and <i>Tc / Zc</i> can be linearly interpolated in screen space.  Now we can easily get the value of <i>Tc</i> : <br><br><img src="https://habrastorage.org/files/128/740/bbe/128740bbee024df1a068f262b600e941.png"><br><br>  Actually, the cost of prospectively correct interpolation lies mainly in this division.  If there is no great need for it, it is better to minimize the number of attributes for which it is used and to do with simple linear interpolation in screen space, if possible.  Below is the correct texturing result: <br><br><img src="https://habrastorage.org/files/f61/6e8/bea/f616e8bea78542b080fbecde57d8c515.png" width="200"><br><br>  To implement perspective correction, we need values ‚Äã‚Äãthat are inverse to the depth ( <i>z-</i> coordinate) of the vertices in the chamber space.  Recall what happens when you multiply by the projection matrix: <br><br><img src="https://habrastorage.org/files/d54/36e/e75/d5436ee75d074e45a77e562c1cce08c7.png"><br><br>  Vertices from camera space go to clipping space.  In particular, the <i>z-</i> coordinate is subject to certain changes (which will be needed later for the depth buffer) and no longer coincides with the <i>z-</i> coordinate vertex in the camera space, so we cannot use it.  And what coincides is the <i>w</i> -coordinate, since we explicitly put <i>z</i> in it from the chamber space (just look at the 4th column of the matrix).  In fact, we do not even need <i>z</i> itself, but <i>1 / z</i> .  And we actually get it "for free", because when we go to NDC we divide all the vertices by <i>z</i> (which lies in the w-coordinate): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w_inversed{ <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / vw }; vx *= w_inversed; vy *= w_inversed; vz *= w_inversed; <span class="hljs-comment"><span class="hljs-comment">// NDC to screen // ...</span></span></code> </pre> <br><br>  And, therefore, we can simply replace it with the opposite value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w_inversed{ <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / vw }; vx *= w_inversed; vy *= w_inversed; vz *= w_inversed; vw = w_inversed; <span class="hljs-comment"><span class="hljs-comment">// NDC to screen // ...</span></span></code> </pre><br><br><habracut><h4>  Rasterization algorithms </h4><br>  Below is a description of the three approaches to the rasterization of polygons.  Complete code samples will be absent, because a lot of it depends on the implementation, and this will be more confusing than help.  At the end of the article there will be a link to the project, and, if necessary, you can see the implementation code in it. <br><br><habracut><h5>  "Standard" algorithm </h5><br>  I called this algorithm ‚Äústandard‚Äù because it is the most frequently described rasterization algorithm for software renderers.  It is easier to understand than traversal-algorithms and rasterization in homogeneous coordinates, and, accordingly, easier to implement. <br><br>  So let's start with the triangle that we want to rasterize.  Suppose, to begin with, that this is a triangle with a horizontal bottom edge. <br><br><img src="https://habrastorage.org/files/03b/f35/3e9/03bf353e9a5a4538bbbc1a3d4a857a22.png"><br><br>  The essence of this algorithm is to sequentially move along the side faces and paint over the pixels between them.  To do this, first calculate the offset values ‚Äã‚Äãalong the <i>X</i> axis for each offset by one along the Y axis. <br><br><img src="https://habrastorage.org/files/4a8/0fc/9b0/4a80fc9b06914795a33157f4f81aa3fb.png"><br><br><img src="https://habrastorage.org/files/868/f50/b21/868f50b21ff24824a9031d52df904f8f.png"><br><br>  Then, the movement begins along the sides.  It is important that the movement starts from the nearest center, and not from the <i>Y-</i> coordinates of the vertex <i>v0</i> , since the pixels are represented by these points.  If the <i>Y</i> coordinate of <i>v0</i> already lies on the center, then we still move to the next center along this axis, since <i>v0</i> lies on both the left and the right side, which means this pixel should not be included in the image: <br><br><img src="https://habrastorage.org/files/07a/4de/783/07a4de783f9f4ef7892adb2acf80117d.gif"><br><br>  When we move on to the next line, we also start the movement only from the next center along the X axis. If the face passes through the center of the pixel, then on the left side we include the pixel in the image, but not on the right one. <br><br>  Similarly, the algorithm works for triangles with a horizontal upper side.  Those triangles, which do not have a single horizontal side, are simply divided into two triangles - one with the horizontal top and one with the horizontal bottom.  To do this, look for the intersection of the horizontal line passing through one of the vertices of the triangle (average along the <i>Y-</i> coordinate), with a different face: <br><br><img src="https://habrastorage.org/files/21f/d94/4b9/21fd944b90a7441c9716d64425d6fc3b.png"><br><br>  After that, each of these triangles is rasterized according to the algorithm above.  It is also necessary to correctly calculate the values ‚Äã‚Äãof z and w coordinates in the new vertex - for example, interpolate them.  Similarly, the presence of this vertex must be taken into account when interpolating attributes. <br><br>  Interpolation of attributes without perspective correction occurs as follows: when moving along the side faces, we calculate the interpolated attribute values ‚Äã‚Äãat the start and end points of the line that we are going to rasterize.  Then, these values ‚Äã‚Äãare linearly interpolated along this line.  If a perspective correction is needed for an attribute, then instead we interpolate <i>T / z</i> along the edges of the polygon (instead of just interpolating <i>T</i> , the attribute value), as well as <i>1 / z</i> .  Then, these values ‚Äã‚Äãat the start and end points of the line are interpolated along it and are used to get the total attribute value with perspective, according to the formula given above.  It must be remembered that the <i>1 / z</i> , to which I refer, actually lies in the w-coordinate of the vector after all the transformations produced. <br><br><habracut><h5>  Traversal algorithms </h5><br>  This is a whole group of algorithms using the same approach, based on the equations of the faces of the polygon. <br><br>  The face equation is the equation of the line on which this face lies.  In other words, it is an equation of a line passing through two vertices of a polygon.  Accordingly, each triangle is characterized by three linear equations: <br><br><img src="https://habrastorage.org/files/4ba/09c/053/4ba09c0530fa409f85ebfff9c1d59437.png"><br><br>  To begin with, we describe the equation of a straight line passing through two points (they are the pair of triangle vertices): <br><br><img src="https://habrastorage.org/files/0c8/431/d4e/0c8431d4efe44f318610a6572793821c.png"><br><br>  We can rewrite it as follows: <br><br><img src="https://habrastorage.org/files/ef0/32a/629/ef032a6292214aefb6b75de9f9f61406.png"><br><br><img src="https://habrastorage.org/files/f0b/2e7/5f0/f0b2e75f08b54a1891e33044f94522cb.png"><br><br><img src="https://habrastorage.org/files/ded/a19/af5/deda19af5f77417ea99e58f5a5e0c8a7.png"><br><br>  It is clear from the last expression that the vector n is perpendicular to the vector v0 - v1 (the coordinates are reversed, and the X-coordinate is taken with a minus sign).  Thus, n is the normal to the line formed by two vertices.  This is all the same equation of a straight line, and, therefore, substituting the point (x, y) there and getting a zero, we know that this point lies on a straight line.  What about the other values?  This is where the normal recording form comes in handy.  We know that the scalar product of two vectors calculates the length of the projection of the first vector onto the second, multiplied by the length of the second vector.  The first vector is the normal, and the second is the vector from the first vertex to the point (x, y): <br><br><img src="https://habrastorage.org/files/178/4a7/907/1784a790749c4ebbb79a5dbdfec8f218.png"><br><br>  And we have three possible options: <br><ul><li>  The value is 0 - the point lies on the line </li><li>  Value greater than 0 - the point lies in the positive half-plane </li><li>  Value less than 0 - the point lies in the negative half-plane </li></ul><br>  They are all shown below: <br><br><img src="https://habrastorage.org/files/541/d5d/182/541d5d1825744156882ec1dbc8b621dd.png"><br><img src="https://habrastorage.org/files/872/928/83e/87292883e19a4804b43242a5b16055ea.png"><br><img src="https://habrastorage.org/files/d6b/a9f/df3/d6ba9fdf375d409bb826801214392240.png"><br><br>  We can also set the equation of a line so that the normal points in the opposite direction - simply multiplying it by minus one.  In the following, I will assume that the equation is composed in such a way that the normal points to the inside of the triangle. <br><br>  Using these equations, we can define a triangle as the intersection of three positive half-planes. <br><br>  Thus, the common part of traversal-algorithms is as follows: <br><ul><li>  Calculate the values ‚Äã‚Äãof the equations of the faces for the point </li><li>  If all values ‚Äã‚Äãare positive, the pixel is filled.  If one of them is zero, then the pixel lies on one of the faces, and we use the top-left rule to decide whether the pixel belongs to the polygon. </li><li>  Move to the next pixel </li></ul><br>  Let us dwell on the implementation of top-left rule.  Now, when we operate on the normal to the face, we can give more rigorous definitions for the left and top faces: <br><ul><li>  The left side is the face whose normal has a positive x-coordinate (i.e. points to the right side) </li><li>  The top face is the face whose normal has a negative y-coordinate, in case the Y axis points up.  If the Y axis points down (I will stick with this option), then the y-coordinate at the upper edges is positive. </li></ul><br>  It is also important to note that the coordinates of the normal coincide with the coefficients <i>a</i> and <i>b</i> in the canonical straight line equation: <i>ax + by + c = 0</i> . <br><br>  Below is an example of a function that determines whether a pixel is in the positive half-plane relative to one of the faces (using the top-left rule).  It is enough for it to take three arguments per input: the value of the equation of a face at a point, and the coordinates of the normal: <br><br><div class="spoiler">  <b class="spoiler_title">Code example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> pipeline::is_point_on_positive_halfplane_top_left( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> edge_equation_value, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> edge_equation_a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> edge_equation_b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ,  top-left rule // if (std::abs(edge_equation_value) &lt; EPSILON) { if (std::abs(edge_equation_a) &lt; EPSILON) { // edge.a == 0.0f,    ,  ,   // //  y-  ,     //    return edge_equation_b &gt; 0.0f; } else { //  x-  ,     //    return edge_equation_a &gt; 0.0f; } } else { //  ,      return edge_equation_value &gt; 0.0f; } }</span></span></code> </pre><br></div></div><br>  Simple and useful optimization when calculating the values ‚Äã‚Äãof equations: if we know the value in a pixel with coordinates <i>(x, y)</i> , then to calculate the value at the point <i>(x + 1, y) it is</i> enough to add the value of the coefficient <i>a</i> .  Similarly, to calculate the value in <i>(x, y + 1), it</i> suffices to add the coefficient <i>b</i> : <br><br><img src="https://habrastorage.org/files/996/e1a/070/996e1a070502411fa2da0575bb005401.png"><br><br>  The next step is attribute interpolation and perspective correction.  For this, barycentric coordinates are used.  These coordinates, in which the point of the triangle is described as a linear combination of vertices (formally, implying that the point is the center of mass of the triangle, with the corresponding weight of the vertices).  We will use the normalized version - i.e.  the total weight of the three vertices is one: <br><br><img src="https://habrastorage.org/files/c77/eb8/ff5/c77eb8ff5eb74c2ba98067bc7cf18df1.png"><br><br><img src="https://habrastorage.org/files/aaf/837/ac0/aaf837ac0f7c427688e1aaf521a20bc5.png"><br><br>  This coordinate system also has a very useful property that allows them to be calculated: the barycentric coordinates are equal to the ratio of the areas of the triangles formed in the figure above to the total area of ‚Äã‚Äãthe triangle (for this reason they are also sometimes called areal coordinates): <br><br><img src="https://habrastorage.org/files/30c/0eb/a24/30c0eba24f504eba936063cd50e67fdb.png"><br><br><img src="https://habrastorage.org/files/154/de5/907/154de59079f243b5ad361648324f687e.png"><br><br>  The third coordinate can be calculated not through the areas of triangles, since the sum of the three coordinates is equal to one ‚Äî in fact, we have only two degrees of freedom. <br><br>  Now everything is ready for linear interpolation of attributes: the attribute value at a given point of the triangle is equal to the linear combination of barycentric coordinates and attribute values ‚Äã‚Äãat the corresponding vertices: <br><br><img src="https://habrastorage.org/files/3ba/e45/d12/3bae45d12c434e849987b329e232c96b.png"><br><br>  To correct the perspective, we use a different formula ‚Äî first, we calculate the interpolated <i>T / z</i> value, then the interpolated <i>1 / z</i> value, and then divide them into each other to get the final <i>T</i> value taking into account the perspective: <br><br><img src="https://habrastorage.org/files/8aa/848/d41/8aa848d41482450f885b38a1f66d9f48.png"><br><br>  The difference between the different traversal algorithms is how the pixels are selected for verification.  We will consider several options. <br><br><h6>  AABB algorithm </h6><br>  As the name implies, this algorithm simply builds the axis-aligned bounding box of the polygon, and traverses all the pixels inside it.  Example: <br><br><img src="https://habrastorage.org/files/3c4/7b3/176/3c47b31765374f24bef12ce2ea838c78.gif"><br><br><h6>  Backtracking algorithm </h6><br>  This algorithm consists of the following steps: <br><ul><li>  We start with the topmost pixel below the topmost one. </li><li>  Move to the left until we meet a pixel to the left of the polygon (backtracking) </li><li>  Move to the right and paint over the pixels until we meet a pixel to the right of the polygon. </li><li>  Go to the line below and start again with the second step. </li></ul><br>  This can be represented as follows: <br><br><img src="https://habrastorage.org/files/d74/c61/e09/d74c61e09965452d90a96f46bda4a668.gif"><br><br>  It is possible to check that the pixel is to the left of the polygon as follows - at least for one face, for which the normal points to the right (ie, a&gt; 0), the value of the equation for this face is negative. <br><br><h6>  Zigzag algorithm </h6><br>  This algorithm can be considered as an improved version of the backtracking algorithm.  Instead of ‚Äúidle‚Äù passing through the pixels in the line, until there is a pixel from which we can begin to move in the right direction, we memorize information about the pixel from which we started moving on the line, and then we pass through the pixels to the left and right of him <br><br><ul><li>  We start with the topmost pixel below the topmost one. </li><li>  Remember the position </li><li>  Move to the left and paint over the pixels included in the polygon, until we meet a pixel to the left of the polygon (backtracking) </li><li>  We return to the pixel from which we started (we remembered it in step 2) and move to the right, painting over the pixels entering the polygon until we meet the pixel outside the polygon </li><li>  Go to the line below and start again with the second step. </li></ul><br><br><img src="https://habrastorage.org/files/e52/307/8db/e523078dbbd3429aaff6a7b7dad03e8e.gif"><br><br><h5>  Rasterization Algorithm in Homogeneous Coordinates </h5><br>  This algorithm was originally described in the publication <a href="http://www.cs.unc.edu/~olano/papers/2dh-tri/2dh-tri.pdf">Triangle scan conversion using 2D homogeneous coordinates, Marc Olano &amp; Trey Greer</a> .  Its main advantages are the absence of the need for clipping and dividing by the w-coordinate during the transformation of the vertices (with the exception of a couple of reservations - they will be described later). <br><br>  First of all, suppose that, at the beginning of the rasterization, the <i>x</i> and <i>y</i> coordinates of the vertices contain values ‚Äã‚Äãthat are mapped to coordinates on the screen by simply dividing by the corresponding <i>w-</i> coordinate.  This may slightly change the vertex transformation code, provided that several rasterization algorithms are supported, since it does not include division by w-coordinate.  Coordinates in a homogeneous two-dimensional space are transmitted directly to the function that produces rasterization. <br><br>  Let us consider in more detail the question of linear interpolation of attributes along a polygon.  Since the value of the attribute (let's call it <i>p</i> ) grows linearly, it must satisfy the following equation (in three-dimensional space): <br><br><img src="https://habrastorage.org/files/be6/c41/cb7/be6c41cb730a49849262086cef9c6eda.png"><br><br>  Since the point <i>(x, y, z) is</i> projected onto the plane using homogeneous coordinates <i>(x, y, w)</i> , where <i>w = z</i> , we can also write this equation in homogeneous coordinates: <br><br><img src="https://habrastorage.org/files/1fd/f36/c74/1fdf36c74d894b10ad718c911de3dc22.png"><br><br>  Imagine that we know the coefficients <i>a</i> , <i>b</i> and <i>c</i> (we will consider finding them a little later).  During rasterization, we deal with the coordinates of pixels in the screen space, which are related to the coordinates in a homogeneous space by the following formula (this was our initial assumption): <br><br><img src="https://habrastorage.org/files/908/f29/90f/908f2990fc4e4216a7aa26edaa69542b.png"><br><br>  We can express the value of <i>p / w</i> using only coordinates in screen space, by dividing by w: <br><br><img src="https://habrastorage.org/files/910/c7e/511/910c7e511d604781b01540989274fdea.png"><br><br>  To get the correct value of <i>p</i> using screen coordinates, we only need to divide this value by <i>1 / w</i> (or, which is the same, multiply by <i>w</i> ): <br><br><img src="https://habrastorage.org/files/697/54f/f7a/69754ff7a5924b79ae4cd5badc678357.png"><br><br>  <i>1 / w</i> , in turn, can be calculated by a similar algorithm - it is enough to imagine that we have a certain parameter that is the same in all vertices: <i>p = [1 1 1]</i> . <br><br>  Now consider how we can find the coefficients <i>a</i> , <i>b</i> and <i>c</i> .  Since for each attribute its values ‚Äã‚Äãare given at the vertices of the polygon, we actually have a system of equations of the form: <br><br><img src="https://habrastorage.org/files/010/fb3/d1f/010fb3d1f03044d0906d9748d2c23888.png"><br><br>  We can rewrite this system in matrix form: <br><br><img src="https://habrastorage.org/files/dca/f1a/56d/dcaf1a56d5ff400b83b1460dbf9ac1f4.png"><br><br>  And the solution: <br><br><img src="https://habrastorage.org/files/080/938/6fd/0809386fd8274c28b6f4c2d513ed0149.png"><br><br>  It is important to note that we need to count only one inverse matrix per polygon ‚Äî then these coefficients can be used to find the correct attribute value at any point on the screen.  Also, since we need to calculate the determinant of the matrix to invert it, we get some auxiliary information, because the determinant also calculates the volume of the tetrahedron with vertices at the origin and points of the polygon multiplied by two (this follows from the definition of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BC%25D0%25B5%25D1%2588%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">mixed product of vectors</a> ).  If the determinant is zero, this means that the polygon cannot be drawn, since it is either degenerate, or it is turned edgewise with respect to the camera.  Also, the volume of a tetrahedron can be with a plus sign and a minus sign - and this can be used to cut off polygons that are turned "back" to the camera (the so-called backface culling).  If we consider the order of the vertices counterclockwise to be correct, then polygons with a positive determinant value should be skipped (provided that the left-side coordinate system is used). <br><br>  Thus, the question of interpolation of attributes is already resolved - we can calculate the correct value (taking into account the perspective) of any attribute at a given point on the screen.  It remains only to decide which points of the screen belongs to the polygon. <br><br>  Let us recall how the pixel belonging to the polygon was tested in traversal algorithms.  We calculated face equations, and then checked their values ‚Äã‚Äãat the desired point on the screen.  If they were all positive (or zero, but belonged to the left or upper edges), then we painted over the pixel.  Since we are already able to interpolate attributes along the surface of a triangle, we can use exactly the same approach, considering that we interpolate a certain pseudo-attribute that is zero along the face and some positive value (the most convenient is 1) at the opposite vertex (in fact, this is going through these faces): <br><br><img src="https://habrastorage.org/files/db4/8fe/25d/db48fe25dbda4f8ea849094b09da5355.png"><br><br>  Accordingly, the values ‚Äã‚Äãof these pseudo-attributes for each of the faces: <br><br><img src="https://habrastorage.org/files/c55/b8c/0f2/c55b8c0f2879495a866022c2b09f1b65.png"><br><br>  Using them we can calculate the corresponding coefficients <i>a</i> , <i>b</i> and <i>c</i> for each of the faces and get their equations: <br><br><img src="https://habrastorage.org/files/fe7/051/2b4/fe70512b45634746817c9ff4bd7eb1d3.png"><br><br>  Now we can interpolate their values ‚Äã‚Äãalong the surface of a triangle in a similar way and calculate their values ‚Äã‚Äãat the point we need.  If it is positive, or it is zero, but we are on the left and upper edges, the pixel is inside the polygon and must be painted over.  We can also apply a small optimization - we do not need the exact values ‚Äã‚Äãof the equations of the faces at all, its sign is enough.  Therefore, dividing by <i>1 / w</i> can be avoided, we can simply check the signs of <i>p / w</i> and <i>1 / w</i> - they should be the same. <br><br>  Since we operate with the same face equation, much of what is said in the section on traversal algorithms can also be applied to this algorithm.  For example, top-left rule can be implemented in a similar way, and the values ‚Äã‚Äãof face equations can be calculated incrementally, which is a useful optimization. <br><br>  When presenting this algorithm, I wrote that this algorithm does not require the implementation of clipping, since it operates in homogeneous coordinates.  This is almost entirely true, except for one case.  There may be situations when working with w-coordinates of points that are close to the origin of the coordinates (or coincide with it).  In this case, overflow may occur when interpolating attributes.  So a good idea would be to add another ‚Äúface‚Äù, which is located parallel to the <i>xy</i> plane and located at a distance of <i>z near</i> from the origin to avoid such errors. <br><br>  When describing traversal algorithms, I mentioned several options for selecting a set of pixels that should be checked for belonging to a triangle (axis aligned bounding box, backtracking, zigzag algorithms).  They can be applied here.  This is a situation in which it will still be necessary to divide the vertices by the w-coordinate to calculate the boundary values ‚Äã‚Äã(for example, the coordinates of the bounding box), we should only provide for situations where <i>w &lt;= 0</i> .  Of course, there are other ways.  Passing through all the pixels of the screen is obviously unsuccessful in terms of performance.  You can also use tile rasterization, the description of which is beyond the scope of this article. <br><br><h6>  That's all </h6><br>  A project where you can see examples of implementations: <a href="https://github.com/loreglean/lantern">github.com/loreglean/lantern</a> .  Pull requests with fixes and other things are welcome, it is better to write about errors in the code or questions about it in PM. </habracut></habracut></habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/257107/">https://habr.com/ru/post/257107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257093/index.html">SourceTalk (source code discussion service): release</a></li>
<li><a href="../257095/index.html">Happy birthday google</a></li>
<li><a href="../257097/index.html">7 things that every designer should know about the design of accessible sites</a></li>
<li><a href="../257101/index.html">Cyclomatic complexity: CSS logic</a></li>
<li><a href="../257105/index.html">Deploying Oracle Database 12c DBMS on Windows Server to InfoboxCloud Cloud</a></li>
<li><a href="../257109/index.html">Attackers use Linux / Mumblehard to compromise servers, part 1</a></li>
<li><a href="../257111/index.html">Effective work with text or how I reinvent the wheel.</a></li>
<li><a href="../257113/index.html">Writing a system of invitations (invitations) for your Meteor application</a></li>
<li><a href="../257115/index.html">Simple control of arduino via the Internet</a></li>
<li><a href="../257117/index.html">Lab penetration testing "Test lab v.7" is open</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>