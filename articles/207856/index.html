<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Customizing UICollectionViewLayout. In the name of art</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey all, ho! 

 Intro 
 I work as an ios-developer in a provincial city of a provincial country nearest (in relation to Russia) foreign countries. Abo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Customizing UICollectionViewLayout. In the name of art</h1><div class="post__text post__text-html js-mediator-article">  Hey all, ho! <br><br><h4>  Intro </h4><br>  I work as an ios-developer in a provincial city of a provincial country nearest (in relation to Russia) foreign countries.  About one and a half years ago, the country decided that I owed her something, specifically: I should have a year of my life, a year of <s>low</s> skilled labor, a year of dreams of returning home, to family and work ... - in a word, I was drafted into the army.  And behind this case, I somehow missed the release of iOS 6 with all its features, including the long overdue UICollectionView. <br>  Having finished with outfits, polygons, charter and other fascinating things, I returned home, started working again, and of course the project in which the customer needed to display data in the form of what the designers call the ‚Äúpinterest board‚Äù, that is, the UICollectionView itself, not long in coming. <br><a name="habracut"></a><br><h4>  Project </h4><br>  The project is something like an iPad-catalog for auctions of a company engaged in the evaluation of antiques.  I have no idea how the guys will react to their mention at the Habr√©, so I will not give any links, no design layouts, no real screenshots. <br>  The application, in principle, is not complicated, from the design delights only one thing alerted me a little - the view of the main screen.  It was supposed to be a collection of images of lots, arranged in three horizontal rows, with horizontal scrolling.  Middle row with a fixed element height and an arbitrary width (depending on the image proportions).  The height of the elements of the first and third rows should vary slightly downward, creating a sort of torn edges.  If you do not quite understand my dry description in letters, look at the screenshot at the end of the article - a sample of the final result - it should explain everything to you.  <a href="">Or here.</a> <br><br><h4>  UICollectionViewFlowLayout </h4><br>  This was the first attempt to spend a minimum of effort.  Since I have never encountered these elements before, my hope for Apple‚Äôs class was extremely strong.  For a start, I generally scored on torn edges, focusing simply on the output of the horizontal ‚Äúinterestboard‚Äù.  Unfortunately, it was not possible to slip on the ball. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Oh, the picture!</b> <div class="spoiler_text"><h6>  Figure # 0 - Developer assumes, and UICollectionViewFlowLayout has </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/edb/8fc/1dc/edb8fc1dcf1751973a482aa5e8cea7c9.png" alt="UICollectionViewFlowLayout"><br></div></div><br>  You can see two things in the screenshot. <br><ul><li>  First: UICollectionViewFlowLayout positions the elements so that the center of the element in the top row is above the center of the elements below.  One word, does not immediately roll. </li><li>  Second: as an example, I decided to post more unwritten pictures of avant-garde artists against the background of the masterpiece of the <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BB%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587,_%25D0%259A%25D0%25B0%25D0%25B7%25D0%25B8%25D0%25BC%25D0%25B8%25D1%2580_%25D0%25A1%25D0%25B5%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B8%25D1%2587">founder of Suprematism.</a> </li></ul><br><br><h4>  RFQuiltLayout </h4><br>  Either my googling skills are extremely weak, or <a href="https://github.com/bryceredd/RFQuiltLayout">RFQuiltLayout</a> is the only ready-made solution that seems to be rolling in my case. <br>  This class uses the blockPixels variable, which stores the default CGSize cell size.  Delegate method <br><br><pre><code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span>) blockSizeForItemAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath;</code> </pre> <br>  returns multipliers for blockPixels of each cell.  That is, if blockPixels = {100, 100}, and blockSizeForItemAtIndexPath = {2.2, 0.8}, then the size of the cell will be {220, 80}. <br>  In my opinion, a slightly strange system, I want to set blockPixels to {1, 1} and return the required size for an element in the delegate method, however, the allocation algorithm in this case thinks even for 15 elements for a long time, and for placing 100 elements it needs computational power abruptly than the iPad.  I did not have enough patience to disassemble the algorithm, so I selected the value {20, 20} for blockPixels using the matching method, which, with my 15 cells, gave a normal speed and good placement accuracy. <br>  To create torn edges, I had to use a small deception - in fact, I did not touch the cell sizes themselves, because at the placement stage I could not find out which row the cell was in, but when I installed the picture I checked the row and for the first and last rows I reduced the height pictures.  Images were slightly cropped at the top and bottom.  If the lot, the picture of which fell under circumcision, was a portrait, then people lost their heads and bottoms, if the lot was a Chinese figurine, the dragon was displayed without a crest, and on the Persian carpets my dirty hack cut the pile.  But the client was pleased, and therefore I was pleased, until the technical project was a little corrected.  Instead of a miserable 15 items, all lots should have been displayed on the main screen.  All one and a half thousand. <br><br><h4>  More art! </h4><br>  Fifteen hundred images of paintings, vases, jade figurines and everything else, no less beautiful.  The harsh truth was such that no third-party decisions saved me.  So it's time to write your placement manager. <br>  As one would expect, I did not manage to find any information in Russian (I didn‚Äôt really hope so), but the tutorials in English, where there wouldn‚Äôt be a lot of unnecessary and there would be at least a good bit of information, wouldn‚Äôt be forgotten either. first ten pages of search results.  As a result, my manual was, in fact, the <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html">documentation from Apple</a> and the RFQuiltLayout code mentioned above (by the way, I would like to express my gratitude to its author Bryce Redd). <br><br><h4>  So, SKRaggyCollectionViewLayout </h4><br>  Immediately apologize for the dumb class name. <br>  First, I defined a protocol for its delegate. <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKRaggyCollectionViewLayoutDelegate</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewDelegate</span></span></span><span class="hljs-class">&gt; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collectionLayout</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKRaggyCollectionViewLayout</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layout</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">preferredWidthForItemAtIndexPath</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSIndexPath</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">indexPath</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIEdgeInsets</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collectionLayout</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKRaggyCollectionViewLayout</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layout</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edgeInsetsForItemAtIndexPath</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSIndexPath</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">indexPath</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Since the delegate cannot affect the height of a cell in any way, he sends to the manager only the width that he would like to see in a particular cell.  Well and the method returning UIEdgeInsets (internal indents for a cell), where without it. <br>  And of course, the property that stores the number of rows is to walk so to walk, let the class be universal, and not just for the three rows! <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> numberOfRows;</code> </pre><br>  Now implementation. <br>  Apple tells us that if we don‚Äôt want to bother with all sorts of additional UICollectionView elements, such as the supplementary and decoration view, we need to override at least the following methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span>)collectionViewContentSize; - (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>*)layoutAttributesForElementsInRect:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)bounds; - (<span class="hljs-built_in"><span class="hljs-built_in">UICollectionViewLayoutAttributes</span></span>*)layoutAttributesForItemAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath; - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)shouldInvalidateLayoutForBoundsChange:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)newBounds;</code> </pre><br>  With the latter, everything is clear - return YES if newBounds does not match the current bounds of the collection. <br>  Let's leave the first method, easy to implement, for later, and go to the layoutAttributesForItemAtIndexPath method.  As is clear from its name, in it we must calculate the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayoutAttributes_class/Reference/Reference.html">UICollectionViewLayoutAttributes</a> for each item.  Objects of the UICollectionViewLayoutAttributes class contain a lot of information about the location of the object, including even transform3D, which allows you to create all sorts of beauty for the cells, but in our case, you can do with just a banal frame. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UICollectionViewLayoutAttributes</span></span> *)layoutAttributesForItemAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsets</span></span> insets = <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsZero</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate respondsToSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(collectionLayout:edgeInsetsForItemAtIndexPath:)]) { insets = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate collectionLayout:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> edgeInsetsForItemAtIndexPath:indexPath]; } <span class="hljs-comment"><span class="hljs-comment">// Get saved frame and edge insets for given path and create attributes object with them CGRect frame = [self frameForIndexPath:indexPath]; UICollectionViewLayoutAttributes* attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; attributes.frame = UIEdgeInsetsInsetRect(frame, insets); return attributes; }</span></span></code> </pre><br>  Actually, nothing interesting - we get the UIEdgeInsets from the delegate, if he gives them to us, we get the frame using the frameForIndexPath method, create and return attributes with the received UIEdgeInsets and CGRect.  But in the frameForIndexPath method, I also hide the main part of shamanism. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)frameForIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>*)path { <span class="hljs-comment"><span class="hljs-comment">// if there is saved frame for given path, return it NSValue *v = [self.framesByIndexPath objectForKey:path]; if (v) return [v CGRectValue]; // Find X-coordinate and a row which are the closest to the collection left corner. A cell for this path should be placed here. int currentRow = 0; float currentX = MAXFLOAT; for (int i = 0; i &lt; self.edgeXPositions.count; i++) { float x = [[self.edgeXPositions objectAtIndex:i] floatValue]; if (x &lt; currentX) { currentRow = i; currentX = x; } } // Calculate cell frame values based on collection height, current row, currentX, the number of rows and delegate's preferredWidthForItemAtIndexPath: value // If variableFrontierHeight is YES this value will be adjusted for the first and last rows float maxH = self.collectionView.frame.size.height; float rowMaxH = maxH / self.numberOfRows; float x = currentX; float y = rowMaxH * currentRow; float w = [self.delegate collectionLayout:self preferredWidthForItemAtIndexPath:path]; float h = self.collectionView.frame.size.height / self.numberOfRows; float newH = h; // Adjust height of the frame if we need raggy style if (self.variableFrontierHeight) { if (currentRow == 0) { float space = arc4random() % self.randomFirstRowVar; if (self.prevWasTallFirst) { space += self.fixedFirstRowVar; } self.prevWasTallFirst = !self.prevWasTallFirst; y += space; newH -= space; } else if (currentRow == self.numberOfRows - 1) { float space = arc4random() % self.randomLastRowVar; if (self.prevWasTallLast) { space += self.fixedLastRowVar; } self.prevWasTallLast = !self.prevWasTallLast; newH -= space; } } // Assure that we have preferred height more than 1 h = h &lt;= 1 ? 1.f : h; // Adjust frame width with new value of height to save cell's right proportions w = w * newH / h; // Save new calculated data ad return [self.edgeXPositions replaceObjectAtIndex:currentRow withObject:[NSNumber numberWithFloat:x + w]]; CGRect currentRect = CGRectMake(x, y, w, newH); NSValue *value = [NSValue valueWithCGRect:currentRect]; [self.indexPathsByFrame setObject:path forKey:value]; [self.framesByIndexPath setObject:value forKey:path]; return currentRect; }</span></span></code> </pre><br>  In case my macaroni code and half-English comments are not very clear, I will try to introduce more <s>chaos of</s> clarity with pseudo-code: <br><div class="spoiler">  <b class="spoiler_title">Here he is</b> <div class="spoiler_text">  <i>[we look through NSMutableDictionary, in which we saved the frames calculated earlier by the indexPath keys, if we find it is a victory, we don‚Äôt need to do anything else]</i> <i><br><br></i>  <i>[if calculations cannot be avoided, we estimate in which row the right border of the last frame is closest to the top of the table ‚Äî this is where we need to put the current element (such x coordinate for each row is stored in NSMutableArray edgeXPositions)]</i> <i><br><br></i>  <i>[now, knowing the row and position along the X axis, knowing the width required by the delegate for an element, we can calculate its position of its upper left corner;</i>  <i>knowing the height of the collection and the number of rows, we calculate at the same time the height of the element]</i> <i><br><br></i>  <i>[if we need the notorious ‚Äútorn edges‚Äù, and the row is the first or the last, we slightly reduce the calculated height]</i> <i><br><br></i>  <i>[we are reinsured in case the height is less than one, we reduce the width in proportion to the decrease in height]</i> <i><br><br></i>  <i>[save the resulting value to the indexPathsByFrame and framesByIndexPath dictionaries for quick access later and return from the method]</i> </div></div><br>  By the way, you need to remember to clear all of these indexPathsByFrame, framesByIndexPath and what else is cached in the invalidateLayout method.  Naturally, not missing [super invalidateLayout]. <br><br>  Back to contentSize.  Obviously, in our case with horizontal scrolling, it should look something like this: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span>)collectionViewContentSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.edgeX, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView.frame.size.height); }</code> </pre><br>  where edgeX is the X coordinate of the farthest located cell.  After all, we already know how all the cells are located.  Or do not know.  Or we still know ... To be sure, you need to override the prepareLayout method, remembering to call [super prepareLayout] in it, and calculate the frames for each cell <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)prepareLayout { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> prepareLayout]; <span class="hljs-comment"><span class="hljs-comment">// calculate and save frames for all indexPaths. Unfortunately, we must do it for all cells to know content size of the collection for (int i = 0; i &lt; [self.collectionView.dataSource collectionView:self.collectionView numberOfItemsInSection:0]; i++) { NSIndexPath *path = [NSIndexPath indexPathForItem:i inSection:0]; [self frameForIndexPath:path]; } }</span></span></code> </pre><br>  Yes, in the presence of hundreds of thousands of cells, the collection will not really hurry to load, but I do not see any other trivial way out. <br>  And in the end, it remains to override the last method - layoutAttributesForElementsInRect.  It is necessary to return the attributes for all elements that fall into this area.  It is called every time the collection is scrolled by the size of its frame.  Then it seems that all of this is cached, so the method will be called just contentSize.width / frame.size.width once. <br>  My implementation, as they say, ‚Äúin the forehead‚Äù: we look at the frames for each element, if they intersect with this area, we add to the returned array. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>*)layoutAttributesForElementsInRect:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)bounds { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">CGRectEqualToRect</span></span>(bounds, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutRect)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutAttributes; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutAttributes removeAllObjects]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutRect = bounds; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *allFrames = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.framesByIndexPath.allValues; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span> *frameValue <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFrames) { <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> rect = [frameValue <span class="hljs-built_in"><span class="hljs-built_in">CGRectValue</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">CGRectIntersectsRect</span></span>(rect, bounds)) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutAttributes addObject:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> layoutAttributesForItemAtIndexPath:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.indexPathsByFrame objectForKey:[<span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span> valueWithCGRect:rect]]]]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.previousLayoutAttributes; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">There should have been a picture, but it will not be</b> <div class="spoiler_text">  because the habr engine deletes it in a surprisingly brazen way every time after saving changes in the edited post <br></div></div><br><br>  Immediately after the euphoria over the fact that everything works as it should, was over, my internal workaholic rendered a verdict: optimize!  But the inner self, who turned out to be stronger than a workaholic, got the phrase ‚Äúpremature optimization‚Äù from the depths of his memory and, hiding behind the fact that, with ten thousand items, testing on the iPad 2 did not reveal any slowdowns, he decided to postpone the optimization for sometime afterwards. <br><br><h4>  Afterword </h4><br>  I hope that someone was interested, someone is useful, and the rest just had the patience to read this post.  Thanks for attention. <br>  Finally, some links: <br><ul><li>  <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html">Apple's Guide</a> </li><li>  <a href="http://www.skeuo.com/uicollectionview-custom-layout-tutorial">Hyde from some dude</a> - in my opinion, too much offtopic <br></li><li>  <a href="https://github.com/tralf/SKRaggyCollectionViewLayout">My github code</a> <br></li></ul><br><br>  <b>PS</b> I have already written here that there is no picture in the last spoiler.  I did the same operation three times - edited it, inserting the missing link, saved it, saw that the changes had occurred, closed the page, opened it again and cursed - the picture disappeared again.  Moreover, the link <b><a href="">Or here</a></b> , which should lead to the same picture, has ceased to perform its functional duties.  Trouble <br>  Just in case, I leave this unauthorized link here simply text <br>  <a href="">habr.habrastorage.org/post_images/0e1/0c7/be4/0e10c7be44690901268d5dfa9e532d0e.png</a> <br></div><p>Source: <a href="https://habr.com/ru/post/207856/">https://habr.com/ru/post/207856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207846/index.html">We compiled a snake in the browser</a></li>
<li><a href="../207848/index.html">MS-DOS, which we have never seen</a></li>
<li><a href="../207850/index.html">Why not play Tanki Online</a></li>
<li><a href="../207852/index.html">How were pictures of the rise of the Earth</a></li>
<li><a href="../207854/index.html">Begging for the future, or how I slept with a QR code in my hands under the Google office in New York</a></li>
<li><a href="../207860/index.html">New Year and project management</a></li>
<li><a href="../207862/index.html">No More Woof: dog-to-human translator</a></li>
<li><a href="../207864/index.html">Summing up the year</a></li>
<li><a href="../207868/index.html">What you should know when planning a Wi-Fi network</a></li>
<li><a href="../207870/index.html">Github + Markdown = Viewdocs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>