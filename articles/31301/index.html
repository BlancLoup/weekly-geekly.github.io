<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsim microformats</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microformats are a way to embed specific semantic data in the HTML we use today. The first question the XML guru would ask is: ‚ÄúWhy use HTML if XML al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsim microformats</h1><div class="post__text post__text-html js-mediator-article">  Microformats are a way to embed specific semantic data in the HTML we use today.  The first question the XML guru would ask is: ‚ÄúWhy use HTML if XML allows you to create the same semantics?‚Äù I will not list all the reasons why XML would be the best or worst choice for encoding data, or why microformats were HTML is selected as the base.  This article will focus on how the basic parsing rules work and how they differ from XML. <br><a name="habracut"></a><br><h2>  HTML Contact Information </h2><br><br>  One of the most popular and well-established microformats is hCard.  This is a vCard representation in HTML (‚Äúh‚Äù in hCard is short for ‚ÄúHTML vCard‚Äù).  You can read more about hCard <a href="http://microformats.org/wiki/hcard">on microformats wiki</a> .  A vCard contains basic information about a person or organization.  This format is widely used in address book applications as a way to back up and share contact information.  By the standards of the Internet, this is the old format, its specification is 1998 RFC2426.  This was before XML, so the syntax is plain text with some delimiters and start and end elements.  Take for example my information: <br><br><pre>  BEGIN: VCARD
 FN: Brian Suda
 N: Suda; Brian ;;;
 URL: http: //suda.co.uk
 END: VCARD </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This vCard file contains the BEGIN: VCARD and END: VCARD elements, which are containers that make the parser know when to stop collecting data.  There can be several vCards in one file, so this method beautifully groups the data into clear vCards.  FN stands for ‚Äúformatted name‚Äù, which is used as a name for display.  N is a structured name in which the proper name, surname, middle name (middle name), prefixes and suffixes are coded, and all this is separated when using a semicolon.  Finally, the URL is the address of the site associated with this contact. <br><br>  If we had to encode all this in XML, the result would probably look something like this: <br><br><pre>  &lt;vcard&gt;
     &lt;fn&gt; Brian Suda &lt;/ fn&gt;
     &lt;n&gt;
         &lt;given-name&gt; Brian &lt;/ given-name&gt;
         &lt;family-name&gt; Suda &lt;/ family-name&gt;
     &lt;/ n&gt;
     &lt;url&gt; http://suda.co.uk &lt;/ url&gt;
 &lt;/ vcard&gt; </pre><br><br>  Let's take a look at how we can mark the same data in HTML using microformats, which use rel, rev, and class attributes to encode semantics.  The class attribute is used in much the same way that elements are used in XML.  So the previous XML example is laid out in HTML like this: <br><br><pre>  &lt;div class = "vcard"&gt;
     &lt;div class = "fn"&gt; Brian Suda &lt;/ div&gt;
     &lt;div class = "n"&gt;
         &lt;div class = "given-name"&gt; Brian &lt;/ div&gt;
         &lt;div class = "family-name"&gt; Suda &lt;/ div&gt;
     &lt;/ div&gt;
     &lt;div class = "url"&gt; http://suda.co.uk &lt;/ div&gt;
 &lt;/ div&gt; </pre><br><br>  If this were all microformats are capable of, it would not be so interesting.  But no, microformats allow you to benefit from the semantics of existing HTML elements in order to explain where coded data can be found.  In this example, each element is a &lt;div&gt;, but this is not necessary.  This makes extracting data from HTML a little more difficult for the parser, but the author of the document becomes easier.  Microformats do not force authors to change the current structure of HTML or the style of publication.  In the end, people writing HTML are orders of magnitude larger than parser writers, so why not simplify the lives of authors? <br><br>  When I look at the previous XML example, I don‚Äôt like that I see ‚ÄúBrian Suda‚Äù twice, once in FN and then again in N. This is not a problem with HTML, we can combine these XML elements using space separated values class attribute.  A little known fact is that the class, rev and rel attributes can have a list of values ‚Äã‚Äãseparated by a space.  And if we combine FN and N, we get something like this: <br><br><pre>  &lt;div class = "n fn"&gt;
     &lt;div class = "given-name"&gt; Brian &lt;/ div&gt;
     &lt;div class = "family-name"&gt; Suda &lt;/ div&gt;
 &lt;/ div&gt; </pre><br><br>  Now the N property still has child properties, and the FN contains the same value as before.  As we remember, HTML compresses spaces, so the FN value is still ‚ÄúBrian Suda‚Äù, even though it is divided between two elements with spaces inside the divs. <br><br>  This is how we designated the ability to combine properties with the same magnitude.  The next thing that makes my eyes sore in the XML example is the way the URL is displayed, it does not look natural.  In XML, we are talking about data, but HTML is shown to people in a browser.  Coincidentally, we have a &lt;a&gt; element that has an href attribute that takes a URL value, and it also has a text value to display more human-friendly text.  We can continue to grind our HTML example by changing the &lt;div&gt; element to &lt;a&gt;: <br><br><pre>  &lt;a class="n fn url" href="http://suda.co.uk"&gt;
     &lt;span class = "given-name"&gt; Brian &lt;/ span&gt;
     &lt;span class = "family-name"&gt; Suda &lt;/ span&gt;
 &lt;/a&gt; </pre><br><br>  After switching to the &lt;a&gt; element, we need to replace the child divs with spans, because the &lt;a&gt; element can contain only children of the inline-level.  Microformats do not force authors to use certain elements, but it is recommended to use the most semantic for each case.  In the case of URLs, it is best to use &lt;a&gt;, so the parsing rules will change slightly (we will discuss this a little later). <br><br>  The final hCard microformat in HTML will look like the following: <br><br><pre>  &lt;div class = "vcard"&gt;
     &lt;a class="n fn url" href="http://suda.co.uk"&gt;
         &lt;span class = "given-name"&gt; Brian &lt;/ span&gt;
         &lt;span class = "family-name"&gt; Suda &lt;/ span&gt;
     &lt;/a&gt;
 &lt;/ div&gt; </pre><br><br>  In my opinion, this is much more intuitive, simple and compact than the example XML at the beginning.  People already publish blogrolls and links in this way, and all browsers recognize and stylize this information, and it‚Äôs easy to put it inside feeds. <br><br><h2>  Parsim with XSLT </h2><br><br>  Microformats are designed to work with HTML 4 and higher.  The disadvantage of using XSLT is that the document must be correctly formed, which is not necessary in HTML 4.  In HTML 4, the tags &lt;br&gt;, &lt;img&gt; and &lt;hr&gt; can be used without closing tags.  If you used another technology to extract microformats, like REGEX or DOM, this would be a different question, but with XSLT we first need to clean up the HTML.  There are two simple ways to do this: <a href="http://www.w3.org/People/Raggett/tidy/">TIDY</a> or a function like <a href="http://docs.python.org/lib/module-htmllib.html">HTMLlib</a> or <a href="http://is2.php.net/manual/en/function.dom-domdocument-loadhtml.php">loadHTML</a> , any of them will load the HTML document and convert it to valid for XSLT. <br><br>  Now that we know that we have a well-formed HTML document, we can start extracting these microformats.  The following is a very raw XSLT, far from perfect, but first you should have enough.  For further information, you can read the microformats.org <a href="http://microformats.org/wiki/">wiki</a> page on parsing, or use XSLT templates that do most of the hard work of extracting data (they are available on <a href="http://hg.microformats.org/">hg.microformats.org</a> ). <br><br>  All hCard data is contained within an element that has the class ‚Äúvcard‚Äù.  In our example, this is a &lt;div&gt;, but it can be any element, so we start with this: <br><br><pre>  // * [@ class = "vcard"] </pre><br><br>  This XPath expression searches for any item in the tree whose class is ‚Äúvcard‚Äù.  At first glance, he wonders that this will find all hCards, but the problem is that the class value may be a list of values ‚Äã‚Äãseparated by spaces.  Thus, the code class = "vcard myStyle" will not be selected by this XPath expression.  To fix this, we use the contains function: <br><br><pre>  // * [contains (@class, "vcard")] </pre><br><br>  This is better, now we will find any element in which the class attribute contains ‚Äúvcard‚Äù.  In the expression class = ‚Äúvcard myStyle‚Äù, ‚Äúvcard‚Äù will be successfully found, but there is another problem.  The contains function is not safe because it is a search by substring.  So the class = "my-vcard" will be found by the function contains () in the same way as the class = "vcard", despite the fact that my-vcard is not the correct name of a property that would mean that we have a microformat hCard.  False coincidence.  To fix this, you have to slightly conjure and surround the values ‚Äã‚Äãyou are looking for with spaces, and then look for a new value wrapped in spaces.  It sounds difficult, but in reality it is not. <br><br><pre>  // * [contains (concat ("", @ class, ""), "vcard")] </pre><br><br>  With spaces, the class ‚Äúmy-vcard‚Äù looks like ‚Äúmy-vcard‚Äù and will not contain the substring ‚Äúvcard‚Äù, which solves the problem of substrings.  In another case, the class ‚Äúvcard myStyle‚Äù will turn into ‚Äúvcard myStyle‚Äù, which contains ‚Äúvcard‚Äù, so the values ‚Äã‚Äãseparated by spaces are also found with this technique. <br><br>  Now that we know how to find the data, let's go through each hCard using XSLT and start outputting it as a vCard.  By this time, it's easy to see how using XSLT makes it easy to convert HTML data to almost any format.  For example, another HTML, XML, RDF, text vCard, CSV, SPARQL, JSON, or whatever else your heart desires. <br><br>  The for-each operator will find all the hCards on the page and create a vCard for each.  When creating a vCard, it applies the search patterns inside the hCard, such as FN, N and URL. <pre>  &lt;xsl: for-each select = "// * [contains (concat (" ", @ class," ")," vcard ")]"&gt;
     &lt;xsl: text&gt; BEGIN: VCARD &lt;/ xsl: text&gt;
     &lt;xsl: apply-templates /&gt;
     &lt;xsl: text&gt; END: VCARD &lt;/ xsl: text&gt;
 &lt;/ xsl: for-each&gt; </pre><br><br>  FN is a simple template that retrieves the value of an element with a class containing FN. <br><br><pre>  &lt;xsl: template match = "// * [contains (concat (" ", @ class," ")," fn ")]"&gt;
     &lt;xsl: text&gt; FN: &lt;/ xsl: text&gt; &lt;xsl: value-of select = "." /&gt;
 &lt;/ xsl: template&gt; </pre><br><br>  Template N is a bit more complicated.  First, he needs to find an element with a class containing N. Then he searches for child elements containing sub-properties of N, such as first and last name, and displays their values. <br><br><pre>  &lt;xsl: template match = "// * [contains (concat (" ", @ class," ")," n ")]"&gt;
     &lt;xsl: text&gt; N: &lt;/ xsl: text&gt;
     &lt;xsl: value-of select = "// * [contains (concat (" ", @ class," ")," family-name ")]" /&gt;
     &lt;xsl: text&gt;; &lt;/ xsl: text&gt;
     &lt;xsl: value-of select = "// * [contains (concat (" ", @ class," ")," given-name ")]" /&gt;
     &lt;xsl: text&gt; ;;; &lt;/ xsl: text&gt;
 &lt;/ xsl: template&gt; </pre><br><br>  The URL pattern uses the choose element to determine where the most semantic information for the URL value is located.  It checks whether an element with the class ‚Äúurl‚Äù is a &lt;a&gt; element.  If yes, then the address value is extracted from <a href="http://habrahabr.ru/users/href/" class="user_link">href</a> , otherwise the string content is used. <br><br><pre>  &lt;xsl: template match = "// * [contains (concat (" ", @ class," ")," url ")]"&gt;
     &lt;xsl: text&gt; URL: &lt;/ xsl: text&gt;
     &lt;xsl: choose&gt;
         &lt;xsl: when test = "local-name () = 'a'"&gt;
             &lt;xsl: value-of select = "@ href" /&gt;
         &lt;/ xsl: when&gt;
         &lt;xsl: otherwise&gt;
             &lt;xsl: value-of select = "." /&gt;
         &lt;/ xsl: otherwise&gt;
     &lt;/ xsl: choose&gt;
 &lt;/ xsl: template&gt; </pre><br><br>  The element &lt;a&gt; and many others carry their semantics in themselves.  In the original HTML example, the URL was encoded with a &lt;div&gt;, in this case, the content would be extracted, and the value of the URL would be the same.  This is just one of many signs that microformats differ from XML.  Parsing microformats data depends on the type and element of HTML they were encoded. <br><br>  It was a very brief overview of extracting data from microformat.  There are also rules depending on the type of vCard property and on which the HTML element is built.  For more information, visit the <a href="http://microformats.org/wiki">microformats wiki</a> , my PDF-book, <a href="http://www.oreilly.com/catalog/microformats/">Using Microformats</a> , or you can always email me, and also subscribe to the microformat mailing list if you have questions. </div><p>Source: <a href="https://habr.com/ru/post/31301/">https://habr.com/ru/post/31301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313000/index.html">Linux Foundation launches reload of javascript community</a></li>
<li><a href="../313002/index.html">Cisco SMB RV320 / 325 Secure Routers with Built-in WEB Filtering: Feature Overview</a></li>
<li><a href="../313004/index.html">New venture fund of Silicon Valley, who wants to save the world and earn money to boot</a></li>
<li><a href="../313006/index.html">Technostream announced a month of game development</a></li>
<li><a href="../313008/index.html">Current trends in ARPU in the world</a></li>
<li><a href="../313010/index.html">Preview Rambler.Android # 4</a></li>
<li><a href="../313012/index.html">DLP and protection of engineering data from plagiarism</a></li>
<li><a href="../313014/index.html">I see everything, hear everything, and write, and I say: mechanics for training lexical skills in the Aword application</a></li>
<li><a href="../313018/index.html">18 experts to follow if you work in the media</a></li>
<li><a href="../31302/index.html">Paul Graham: The Future of Web Startups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>