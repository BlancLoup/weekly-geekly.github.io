<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous programming - async performance: understand the costs of async and await</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is quite ancient, but not lost its relevance. When talking about async / await, as a rule, a link to it appears. I could not find the tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous programming - async performance: understand the costs of async and await</h1><div class="post__text post__text-html js-mediator-article"><p>  This article is quite ancient, but not lost its relevance.  When talking about async / await, as a rule, a link to it appears.  I could not find the translation into Russian, I decided to help someone who is not fluent. </p><br><hr><br><p>  Asynchronous programming for a long time was the realm of the most experienced developers with a burden to masochism - those who had enough free time, addiction and mental abilities to think about callbacks from callbacks in a non-linear flow of execution.  With the advent of Microsoft .NET Framework 4.5, C # and Visual Basic brought asynchrony to all of us, so that mere mortals can now write asynchronous methods almost as easily as synchronous ones.  Callbacks are no longer needed.  Explicit transmission (marshaling) of the code from one synchronization context to another is no longer necessary.  You no longer have to worry about how the results of an implementation or an exception move.  There is no need for tricks that distort the means of programming languages ‚Äã‚Äãfor the convenience of developing asynchronous code.  In short, there is no more hassle or headache. </p><a name="habracut"></a><br><p>  Of course, despite the fact that it is now easy to start writing asynchronous methods (see the articles by Eric Lippert [ <a href="https://msdn.microsoft.com/en-us/magazine/hh456401.aspx">Eric Lippert</a> ] and Mads Torgerssen [ <a href="https://msdn.microsoft.com/en-us/magazine/hh456403.aspx">Mads Torgersen</a> ] in this issue of <em>MSDN Magazine [OCTOBER 2011]</em> ), to really do this requires understanding what happens under the hood.  Every time a language or library raises a level of abstraction that a developer can use, this is inevitably accompanied by hidden costs that degrade performance.  In many cases, these costs are negligible, so they can be neglected in most cases with most programmers.  However, advanced developers should fully understand what costs are present in order to take the necessary measures and solve possible problems if they manifest themselves.  This is required when using asynchronous programming tools in C # and Visual Basic. </p><br><p>  In this article, I will describe the ins and outs of asynchronous methods, describe how asynchronous methods are implemented, and discuss some of the smaller costs.  Note that these are not recommendations to distort readable code into something that is difficult to maintain, in the name of micro-optimization and performance.  It‚Äôs just knowledge that will help diagnose problems you may encounter and a set of tools to overcome these problems.  In addition, this article is based on the .NET Framework version 4.5 preview, and the specific implementation details are likely to change in the final release. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Get a comfortable thinking model. </h4><br><p>  For decades, programmers have been using high-level C #, Visual Basic, F #, and C ++ programming languages ‚Äã‚Äãto develop productive applications.  This experience allowed programmers to evaluate the costs of various operations and to gain knowledge of the best development techniques.  For example, in most cases, the call to the synchronous method is relatively economical, especially if the compiler can embed the content of the called method directly at the calling point.  Therefore, developers are accustomed to breaking code into small, maintainable methods, without having to worry about the negative consequences of increasing the number of calls.  The thinking model of these programmers is designed to operate on method calls. </p><br><p>  With the advent of asynchronous methods, a new model of thinking is required.  C # and Visual Basic with their compilers are able to create the illusion that the asynchronous method works as its synchronous counterpart, although everything inside is completely different.  The compiler generates for the programmer a huge amount of code, very similar to the standard template, which the developers wrote to support asynchrony during what they needed to do with their hands.  Moreover, the code that the compiler generated contains calls to the .NET Framework library functions, further reducing the amount of work the programmer needs to perform.  To have the correct thinking model and use it to make informed decisions, it is important to understand what the compiler generates for you. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  More methods, fewer calls </h4><br><p>  When working with synchronous code, executing methods with empty content is practically worthless.  For asynchronous methods this is not the case.  Consider such an asynchronous method consisting of one instruction (and which, due to the absence of await operators, will be executed synchronously): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  The intermediate language decompiler (IL) will reveal the true contents of this function after compilation, displaying something similar to Figure 1. What was a simple one-liner turned into two methods, one of which belongs to the auxiliary class of the state machine.  The first is a stub method that has a signature similar to that written by a programmer (this method has the same name, the same scope, it takes the same parameters and returns the same type), but does not contain code written by the programmer.  It contains only the standard boilerplate for initial configuration.  The initial configuration code initializes the state machine necessary to represent the asynchronous method and starts it using the MoveNext service method call.  The type object of the state machine contains a variable with the execution state of the asynchronous method, allowing it to be saved when switching between asynchronous waiting points, if necessary.  It also contains the code that the programmer wrote, modified to ensure the transfer of execution results and exceptions to the returned Task object;  holding the current position in the method so that execution can continue from this position after resuming, etc. </p><br><p>  <strong>Figure 1</strong> Asynchronous Method Pattern </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  When you estimate how much the calls to asynchronous methods cost, remember this pattern.  The try / catch block in the MoveNext method is needed to prevent a possible attempt to embed this JIT method by the compiler, so at least we will get the cost of calling the method, while using the synchronous method, most likely, there will not be any call (provided that minimalistic content).  We will receive several calls to the Framework procedures (for example, SetResult).  As well as several write operations to the fields of the state machine object.  Of course, we need to compare all these costs with the costs for Console.WriteLine, which will probably prevail (they include the costs for locks, I / O, etc.). Pay attention to the optimizations that the environment does for you.  For example, a state machine object is implemented as a structure (struct).  This structure will be boxed in a managed heap only if the method needs to suspend execution, waiting for the operation to finish, and this will never happen in this simple method.  So the template of this asynchronous method will not require heap allocation.  The compiler and runtime will try to minimize the number of memory allocations. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  When not to use Async </h4><br><p>  The .NET Framework attempts to generate efficient implementations for asynchronous methods using various optimization methods.  Nevertheless, developers, based on their experience, often use their optimization methods, which can be risky and inappropriate for automation by the compiler and the runtime, as they try to use universal approaches.  If you do not forget about this, avoiding the use of async methods is beneficial in a number of specific cases, in particular, it concerns methods in libraries that can be used with more advanced settings.  This usually happens when it is known that the method can be executed synchronously, since the data on which it depends is already ready. </p><br><p>  When creating asynchronous methods, the .NET Framework developers spent a lot of time optimizing the number of memory management operations.  This is necessary because the memory management has the highest cost in the performance of the asynchronous infrastructure.  The operation of allocating memory for an object is usually relatively inexpensive.  Allocating memory for objects is similar to filling a cart in a supermarket ‚Äî you don‚Äôt waste anything when you put them in a cart.  Spending occurs when you pay at the checkout, taking out the wallet and giving decent money.  And if memory allocation happens easily, subsequent garbage collection can hit the application performance a lot.  When you start garbage collection, scanning and marking of objects that are currently located in memory, but do not have links, takes place.  The more objects are placed, the more time it takes to mark them.  In addition, the larger the number of large objects placed, the more often garbage collection is required.  This aspect of working with memory produces a global impact on the system: the more debris produced by asynchronous methods, the slower the application runs, even if micro tests do not demonstrate significant performance. </p><br><p>  For asynchronous methods that suspend their execution (waiting for data that is not yet ready), the environment must create an object of type Task, which will be returned from the method, since this object serves as a unique reference to the call.  However, often calls to asynchronous methods can be made without pausing.  Then the runtime environment can return the previously completed Task object from the cache, which is used again and again without the need to create new Task objects.  True, this is allowed only under certain conditions, for example, when an asynchronous method returns a non-generic Task object, or when a universal Task specifies a reference TResult, but returns null from the method.  Although the list of these conditions expands over time, it is still better if you know how the executing operation is implemented. <br></p><p>  Consider an implementation of this type as a MemoryStream.  MemoryStream is inherited from Stream, and overrides new methods implemented in .NET 4.5: ReadAsync, WriteAsync and FlushAsync, in order to provide a MemoryStream-specific code optimization.  Since the read operation is performed from the buffer allocated in memory, that is, it is actually a copy of the memory area, the best performance will be if ReadAsync is executed in synchronous mode.  Implementing this in an asynchronous method might look like this: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Simple enough.  And since Read is a synchronous call, and there are no await statements in the method for managing expectations, all calls to this ReadAsync will actually be executed synchronously.  Now let's consider the standard case of using streams, for example, the copy operation: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Please note that in the above example, the ReadAsync of the source stream is always called with the same buffer length parameter, which means it is very likely that the return value (the number of bytes read) will also be repeated.  With the exception of some rare circumstances, a ReadAsync implementation is unlikely to use the cached Task object as a return value, but you can do this. </p><br><p>  Consider another implementation of this method, shown in Figure 2. Using the advantages of its inherent aspects in standard scenarios for this method, we can optimize the implementation with the exception of memory allocation operations, which can hardly be expected from the runtime environment.  We can completely eliminate the memory allocation loss by re-returning the same Task object that was used in the previous ReadAsync call, if the same number of bytes were read.  And for such a low-level operation, which is likely to be very fast and will be called repeatedly, this optimization will have a significant effect, especially in the number of garbage collections. </p><br><p>  <strong>Figure 2</strong> Task Creation Optimization </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  A similar method of optimization by eliminating unnecessary creation of Task objects can be used if caching is needed.  Consider a method that is designed to get the content of a web page and its caching for subsequent hits.  In the form of an asynchronous method, this can be written as follows (using the System.Net.Http.dll library that is new for .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  This is a realization in the forehead.  And for calls to GetContentsAsync that do not find the data in the cache, the overhead of creating a new Task object can be neglected compared to the cost of getting data over the network.  However, in the case of receiving data from the cache, these costs become significant if you simply wrap up and give away the available local data. <br></p><p>  To eliminate these costs (if you need to achieve high performance), you can rewrite the method as shown in Figure 3. Now we have two methods: a synchronous public method and an asynchronous private method that is delegated to the open one.  The Dictionary collection now caches the created Task objects, not their contents, so future attempts to retrieve the content of the page that has already been successfully retrieved before can be performed by simply calling the collection to return an existing Task object.  Inside, you can take advantage of using the ContinueWith methods of the Task object, which allows us to save the executed object to the collection, if the page load was successful.  Of course, this code is more complex and requires great effort in development and support, as is usual in optimizing performance: I don‚Äôt want to spend time writing it until performance testing shows that these complications lead to its improvement, impressive and obvious.  What will be the improvements actually depends on the method of application.  You can take a test suite that simulates common use cases and evaluate the results to determine if the game is worth the candle. </p><br><p>  <strong>Figure 3</strong> Manually caching tasks </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Another optimization method associated with Task objects is to determine whether such an object should be returned from the asynchronous method.  Both C # and Visual Basic support asynchronous methods that return a null value (void), and Task objects are not created in them at all.  Asynchronous methods in libraries should always return Task and Task, since when developing a library you cannot know that they will not be used while waiting for completion.  However, when developing applications, methods that return void can find their place.  The main reason for the existence of such methods is to provide existing event-driven environments, such as ASP.NET and the Windows Presentation Foundation (WPF).  Using async and await, these methods make it easy to implement button handlers, page load events, and so on.  If you are going to use an asynchronous method with void, be careful with exception handling: exceptions to it will pop up in any SynchronizationContext that was active at the time the method was called. <br></p><h4 id="ne-zabyvayte-o-kontekste">  Do not forget the context </h4><br><p>  There are many different contexts in the .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext, and others (a huge number may suggest that the creators of the Framework were financially motivated to create new contexts, but I know for sure that this is not true).  Some of these contexts strongly influence asynchronous methods, not only in terms of functionality, but also in performance. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext plays a significant role for asynchronous methods.  A ‚Äúsynchronization context‚Äù is just an abstraction for marshaling a delegate call with the specifics of a particular library or environment.  For example, WPF has a DispatcherSynchronizationContext for representing a user interface (UI) flow for a Dispatcher: sending a delegate to this synchronization context causes the delegate to be queued for execution by the Dispatcher in its flow.  ASP.NET provides AspNetSynchronizationContext, which is used to ensure that asynchronous operations involved in processing an ASP.NET request are consistently performed and linked to the correct HttpContext state.  Well, etc.  In general, there are about 10 SynchronizationContext specializations in the .NET Framework, some open, some internal. </p><br><p>  When you wait for Tasks or other types of objects for which the .NET Framework can do this, objects that are waiting for them (for example, TaskAwaiter) capture the current SynchronizationContext at the moment when the wait (await) begins.  After the wait is complete, if the SynchronizationContext has been captured, the continuation of the asynchronous method is sent to this synchronization context.  Because of this, programmers who write asynchronous methods that are called from the UI stream do not need to manually marshal calls back to the UI stream in order to update the UI controls: this marshaling framework performs automatically. </p><br><p>  Unfortunately, this marshaling has its price.  For application developers who use await to implement their control flow, automatic marshaling is the right solution.  Libraries often have a different story.  For application developers, this marshaling is basically necessary in order for the code to control the context in which it runs, for example, to access the UI controls or to access the HttpContext corresponding to the desired ASP.NET request.  However, libraries are generally not required to meet this requirement.  As a result, automatic marshaling often brings completely unnecessary additional costs.  Let's look again at the code that copies data from one stream to another: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  If this copy is invoked from a UI thread, each read and write operation will cause the execution to be returned back to the UI stream.  In the case of a megabyte of data at the source and streams that read and write asynchronously (that is, most of their implementations), this means about 500 switches from the background thread to the UI stream.  To handle this behavior in the Task and Task types, the ConfigureAwait method has been created.  This method takes the continueOnCapturedContext parameter of a boolean type that controls marshaling.  If true (default), await automatically returns control to the captured SynchronizationContext.  If false is used, the synchronization context will be ignored, and the environment will continue to perform an asynchronous operation on the thread where it was interrupted.  The implementation of this logic will give a more efficient version of the copy code between the threads: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  For library developers, such acceleration is in itself sufficient to always think about using ConfigureAwait, except for rare conditions in which the library knows enough about the execution environment and it will need to execute a method with access to the correct context. </p><br><p>  In addition to performance, there is another reason for which you need to use ConfigureAwait when developing libraries.  Imagine that the CopyStreamToStreamAsync method, implemented with a version of the code without ConfigureAwait, is called from the UI stream in WPF, for example, like this: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = ‚Ä¶, dst = ‚Ä¶; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  In this case, the programmer had to write button1_Click as an asynchronous method, in which the Task is expected to be executed by the await operator, and not use the synchronous Wait method of this object.  The Wait method should be used in many other cases, but it will almost always be a mistake to use it to wait in the UI thread as shown here.  The Wait method will not return until the Task is completed.  In the case of CopyStreamToStreamAsync, its asynchronous stream tries to return execution with sending data to the captured SynchronizationContext, and cannot complete until such sendings are executed (because they are necessary to continue its work).  But these sendings, in turn, cannot be executed, because the UI thread that is supposed to process them is blocked by the Wait call.  This is a cyclic dependency, leading to a deadlock.  If CopyStreamToStreamAsync is implemented with ConfigureAwait (false), there will be no dependency and blocking. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext is an important part of the .NET Framework, but still, most programmers are blissfully unaware of its existence. ExecutionContext ‚Äì  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  (¬´¬ª)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     ‚Äúawait b‚Äù    Sum.      await,       Sum,  -       async ,   ¬´¬ª     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/458332/">https://habr.com/ru/post/458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45832/index.html">Search site</a></li>
<li><a href="../458324/index.html">Everything you need to get started with Vue.js</a></li>
<li><a href="../458326/index.html">Yandex opens datasets Toloki for researchers</a></li>
<li><a href="../458328/index.html">How to duplicate goals from Yandex. Metrics to Google Analytics</a></li>
<li><a href="../45833/index.html">Page-view pattern in javascript</a></li>
<li><a href="../458334/index.html">Continuous replication from old to new PostgreSQL using Slony</a></li>
<li><a href="../45834/index.html">SimpleModal - simple modal windows</a></li>
<li><a href="../458342/index.html">Texturing, or what you need to know to become an artist on surfaces. Part 1. Pixel</a></li>
<li><a href="../458344/index.html">Use asynchronous messaging to improve accessibility</a></li>
<li><a href="../458346/index.html">Solution of the task with pwnable.kr 01 - fd. File Descriptors and Processes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>