<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a singleton in a multithreaded application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 At the moment, it is difficult to imagine software running in one thread. Of course, there are a number of simple tasks for which one t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a singleton in a multithreaded application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/827/4a3/a15/8274a3a1593fa44fc63f72b08d7f6310.jpg"><br><br><h3>  Introduction </h3><br>  At the moment, it is difficult to imagine software running in one thread.  Of course, there are a number of simple tasks for which one thread is more than sufficient.  However, this is not always the case, and most of the tasks of medium or high complexity somehow use multithreading.  In this article I will talk about using singletones in a multithreaded environment.  Despite the seeming simplicity, this topic contains many nuances and interesting questions, so I think that it deserves a separate article.  The discussion of why to use singletons and also how to use them correctly will not be touched on here.  To clarify these issues, I recommend referring to my previous articles on various issues related to singletons <a href="http://habrahabr.ru/post/116577/">[1]</a> , <a href="http://habrahabr.ru/post/118368/">[2]</a> , <a href="http://habrahabr.ru/post/118550/">[3]</a> .  In this article we will talk about the impact of multithreading on the implementation of singletons and discussion of issues that emerge during development. <br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br>  In previous articles, the following implementation of a singleton was considered: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre> <br>  The idea of ‚Äã‚Äãthis function is quite simple and straightforward: for any type T we can create an instance of this type on demand, i.e.  ‚ÄúLazy‚Äù, and the number of instances created by this function does not exceed 1. If we do not need an instance, then there are no problems from the point of view of multithreading (and from the point of view of lifetime and other problems).  However, what happens if in our multi-threaded application at the same time 2 or more threads want to call this function with the same type T? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  C ++ Standard </h3><br>  Before answering this question from a practical point of view, I suggest that you familiarize yourself with the theoretical aspect, i.e.  let's get acquainted with the standard C ++.  Currently compilers support 2 standards: 2003 and 2011. <br><br><blockquote>  $ 6.7.4, C ++ 03 <br><br>  It means that the initial-initialization (8.5) has taken place.  A local object of the POD type (3.9) with static storage duration  In the case of the storage space in the area of ‚Äã‚Äãspace, it should not be lost.  Otherwise, this is the first time control passes through its declaration;  this an object is considered initialized upon completion of its initialization.  It will be your intention.  If the object is the initialized, the behavior is undefined. <br><br>  $ 6.7.4, C ++ 11 <br><br>  There is no need for any storage-blocking-rate (3.7.1) or thread-storage duration (3.7.2).  Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable.  It has been noted that this has been the case in the past year.  Otherwise, such a variable is initialized;  such a variable is considered initialized upon completion of its initialization.  It will be your intention.  <b>If the variable is being initialized, it should be the initialization (*)</b> .  If the declaration is not defined. <br><br>  (*) The implementation of the initializer <br></blockquote>  ( <i>highlighted by me</i> ) <br><br>  In short, the new standard says that if during the initialization of a variable (i.e. instantiation) the second thread tries to access the same variable, then it (the flow) must wait for the initialization to complete, and the implementation should not allow deadlock situations.  In the earlier standard about multithreading, as you can be sure, not a word is said. <br><br>  It now remains to find out which compilers really support the new standard, and which only try to pretend that they support.  To do this, we conduct the following experiment. <br><br><h3>  Experiment </h3><br>  When using multithreaded primitives, I will use the <a href="http://ultimatepp.org/">Ultimate ++</a> framework.  It is quite lightweight and easy to use.  In the framework of this article, this does not play a fundamental role (for example, you can use <a href="http://www.boost.org/">boost</a> ). <br><br>  For our experiment, we will write a class, the creation of which takes quite a long time: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A() { Cout() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     Thread::Sleep(10); //  10  if (++ x != 1) Cout() &lt;&lt; '2'; //  :    Cout() &lt;&lt; '}'; //    } ~A() { Cout() &lt;&lt; '~'; //   } int x; };</span></span></code> </pre><br>  At the initial moment of class creation, the value of x is 0, since  we plan to use it only from singleton, i.e.  with the word static, using which all POD types will be initialized to the value 0. Then we wait some time, emulating the duration of the operation.  At the end there is a check for the expected value, if it is different from one, then we give an error message.  Here I used the output of characters in order to more clearly show the sequence of operations.  I specifically did not use the message, because  this would require additional synchronization for multithreaded use, which we wanted to avoid. <br><br>  Next, we will write a function called when creating new threads: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ Cout() &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>+i); <span class="hljs-comment"><span class="hljs-comment">//   -    ,    A&amp; a = single&lt;A&gt;(); //    if (ax == 0) Cout() &lt;&lt; '0'; //  :    Cout() &lt;&lt; char('A'+i); //   -    }</span></span></code> </pre><br>  And we will call the threadFunction function at the same time from 5 threads, thereby emulating the situation when competitive access to the singleton occurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++ i) Thread::Start(callback1(threadFunction, i)); Thread::ShutdownThreads();</code> </pre><br>  For the experiment, I chose 2 compilers that are quite popular today: <b>MSVC</b> 2010 and <b>GCC</b> 4.5.  Testing was also conducted using the <b>MSVC</b> 2012 compiler, the result was fully consistent with the 2010 version, so I‚Äôll omit the mention of it later. <br><br>  Startup result for <b>GCC</b> : <br><blockquote>  ab {cde} ABCDE ~ <br></blockquote><br>  Startup result for <b>MSVC</b> : <br><blockquote>  ab {0cB0dCe00DE} A ~ <br></blockquote><br><h3>  Discussion of the results of the experiment </h3><br>  Discuss the results.  For <b>GCC</b> , the following happens: <br><ol><li>  start threadFunction function for thread 1 </li><li>  start threadFunction function for thread 2 </li><li>  start of singleton initialization </li><li>  start threadFunction function for thread 3 </li><li>  start threadFunction function for thread 4 </li><li>  start threadFunction function for thread 5 </li><li>  completion of singleton initialization </li><li>  exit from the threadFunction function consistently for all threads 1-5 </li><li>  completion of the program and destruction of singleton </li></ol><br>  There are no surprises here: the singleton is initialized only once and the threadFunction function completes its work only after the completion of the initialization of the singleton =&gt; <b>GCC</b> correctly initializes the object in a multithreaded environment. <br><br>  The situation with <b>MSVC is</b> somewhat different: <br><ol><li>  start threadFunction function for thread 1 </li><li>  start threadFunction function for thread 2 </li><li>  start of singleton initialization </li><li>  error: singleton is not initialized </li><li>  start threadFunction function for thread 3 </li><li>  exit from threadFunction function for thread 2 </li><li>  error: singleton is not initialized </li><li>  ... </li><li>  exit from threadFunction function for thread 5 </li><li>  completion of singleton initialization </li><li>  exit from threadFunction function for thread 1 </li><li>  completion of the program and destruction of singleton </li></ol><br>  In this case, the compiler for the first thread starts to initialize the singleton, and for the rest, it immediately returns an object that did not even have time to initialize.  Thus, <b>MSVC</b> does not ensure proper operation in a multi-threaded environment. <br><br><h3>  Analysis of the results of the experiment </h3><br>  Let's try to figure out the difference between the result obtained by the considered compilers.  To do this, compile and disassemble the code: <br><br>  <b>GCC</b> : <br><pre> <code class="hljs django"><span class="xml"><span class="xml">5 T&amp; single() 0x00418ad8 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+0</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: push %ebp 0x00418ad9 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: mov %esp,%ebp 0x00418adb </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: sub $0x28,%esp 6 { 7 static T t; 0x00418ade </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+6</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: cmpb $0x0,0x48e070 0x00418ae5 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+13</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: je 0x418af0 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">single</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">()+24&gt; 0x00418ae7 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+15</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: mov $0x49b780,%eax 0x00418aec </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+20</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: leave 0x00418aed </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+21</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: ret 0x00418af0 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+24</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: movl $0x48e070,(%esp) 0x00418af7 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+31</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: call 0x485470 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">__cxa_guard_acquire</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> 0x00418afc </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+36</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: test %eax,%eax 0x00418afe </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+38</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: je 0x418ae7 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">single</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">()+15&gt; 0x00418b00 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+40</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: movl $0x49b780,(%esp) 0x00418b07 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+47</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: call 0x4195d8 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">A::A()</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> 0x00418b0c </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+52</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: movl $0x48e070,(%esp) 0x00418b13 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+59</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: call 0x4855cc </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">__cxa_guard_release</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> 0x00418b18 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+64</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: movl $0x485f04,(%esp) 0x00418b1f </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+71</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: call 0x401000 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">atexit</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> 8 return t; 9 } 0x00418b24 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+76</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: mov $0x49b780,%eax 0x00418b29 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+81</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: leave 0x00418b2a </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+82</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">: ret</span></span></code> </pre><br>  It can be seen that before calling the constructor of object A, the compiler inserts a call to the synchronization functions: __cxa_guard_acquire / __ cxa_guard_release, which allows you to safely start the single function at the same time when initializing a singleton. <br><br>  <b>MSVC</b> : <br><pre> <code class="hljs perl">T&amp; single() { <span class="hljs-number"><span class="hljs-number">00</span></span>E5142<span class="hljs-number"><span class="hljs-number">0</span></span> mov eax,dword ptr fs:[<span class="hljs-number"><span class="hljs-number">00000000</span></span>h] <span class="hljs-number"><span class="hljs-number">00</span></span>E51426 <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0FFFFFFFFh <span class="hljs-number"><span class="hljs-number">00</span></span>E51428 <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset __ehhandler$??$single@UA@@@@YAAAUA@@XZ (0EE128Eh) <span class="hljs-number"><span class="hljs-number">00</span></span>E5142D <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax static T t; <span class="hljs-number"><span class="hljs-number">00</span></span>E5142E mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>E51433 mov dword ptr fs:[<span class="hljs-number"><span class="hljs-number">0</span></span>],esp ;   <span class="hljs-number"><span class="hljs-number">00</span></span>E5143A test byte ptr [<span class="hljs-string"><span class="hljs-string">`single&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (0F23944h)],al <span class="hljs-number"><span class="hljs-number">00</span></span>E5144<span class="hljs-number"><span class="hljs-number">0</span></span> jne single&lt;A&gt;+<span class="hljs-number"><span class="hljs-number">47</span></span>h (0E51467h) ;     <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>E51442 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> dword ptr [<span class="hljs-string"><span class="hljs-string">`single&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (0F23944h)],eax <span class="hljs-number"><span class="hljs-number">00</span></span>E51448 mov ecx,offset t (0F23940h) <span class="hljs-number"><span class="hljs-number">00</span></span>E5144D mov dword ptr [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> ;  :   <span class="hljs-number"><span class="hljs-number">00</span></span>E51455 call A::A (0E51055h) <span class="hljs-number"><span class="hljs-number">00</span></span>E5145A <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset <span class="hljs-string"><span class="hljs-string">`single&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`dynamic atexit destructor for '</span></span>t<span class="hljs-string"><span class="hljs-string">''</span></span> (0EED390h) <span class="hljs-number"><span class="hljs-number">00</span></span>E5145F call atexit (0EA0AD1h) <span class="hljs-number"><span class="hljs-number">00</span></span>E51464 add esp,<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } <span class="hljs-number"><span class="hljs-number">00</span></span>E51467 mov ecx,dword ptr [esp] <span class="hljs-number"><span class="hljs-number">00</span></span>E5146A mov eax,offset t (0F23940h) <span class="hljs-number"><span class="hljs-number">00</span></span>E5146F mov dword ptr fs:[<span class="hljs-number"><span class="hljs-number">0</span></span>],ecx <span class="hljs-number"><span class="hljs-number">00</span></span>E51476 add esp,0Ch <span class="hljs-number"><span class="hljs-number">00</span></span>E51479 ret</code> </pre><br>  Here the compiler uses the variable at address 0x0F23944 to check initialization.  If the object has not yet been initialized, then this value is set to one, and then the initialization of the singleton is simply called.  It can be seen that no synchronization is provided, which explains the result obtained as a result of our experiment. <br><br><h3>  A simple solution </h3><br>  You can use a fairly simple solution that solves our problem.  To do this, before creating an object, we will use a mutex to synchronize access to the object: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        struct StaticLock : Mutex::Lock { StaticLock() : Mutex::Lock(mutex) { Cout() &lt;&lt; '+'; } ~StaticLock() { Cout() &lt;&lt; '-'; } private: static Mutex mutex; }; Mutex StaticLock::mutex; template&lt;typename T&gt; T&amp; single() { StaticLock lock; //   mutex.lock() static T t; //   return t; //  mutex.unlock()    }</span></span></code> </pre><br>  Startup Result: <br><br><blockquote>  ab + {cde} -A + -B + -C + -D + -E ~ <br></blockquote><br>  Sequence of operations: <br><ol><li>  start threadFunction function for thread 1 </li><li>  start threadFunction function for thread 2 </li><li>  global lock take: mutex.lock () </li><li>  start of singleton initialization </li><li>  start threadFunction function for thread 3 </li><li>  start threadFunction function for thread 4 </li><li>  start threadFunction function for thread 5 </li><li>  completion of singleton initialization </li><li>  global lock removal: mutex.unlock () </li><li>  exit from threadFunction function for thread 1 </li><li>  global lock take: mutex.lock () </li><li>  global lock removal: mutex.unlock () </li><li>  exit from threadFunction function for thread 2 </li><li>  ... </li><li>  exit from threadFunction function for thread 5 </li><li>  completion of the program and destruction of singleton </li></ol><br>  Such an implementation completely eliminates the problem of returning an uninitialized object: before starting the initialization, mutex.lock () is called, and after the initialization is completed, mutex.unlock () is called.  The remaining threads wait for the initialization to complete before starting to use it.  However, this approach has a significant disadvantage: the lock is always used, regardless of whether the object is already initialized or not.  To improve performance, I would like the synchronization to be used only at the time when we want to gain access to an object that has not yet been initialized (as implemented for <b>GCC</b> ). <br><br><h3>  Double-checked locking pattern </h3><br>  To implement the above idea, an approach called the <a href="http://ru.wikipedia.org/wiki/Double_checked_locking">Double-checked locking pattern ( <b>DCLP</b> )</a> or the ‚Äúdouble-check lock‚Äù design pattern is often used.  Its essence is described by the following set of actions: <br><ol><li>  condition check: initialized or not?  If yes, then we immediately return the object link </li><li>  take the lock </li><li>  check the condition a second time, if initialized - then remove the lock and return the link </li><li>  we initialize singlton </li><li>  change the condition to "initialized" </li><li>  remove the lock and return the link </li></ol><br>  From this sequence of actions it becomes clear where this name comes from: we check the condition 2 times, first before blocking, and then immediately after.  The idea is that the first check may not mean that the object is not initialized, for example, in the case when 2 threads entered this function at the same time.  In this case, both threads get the status: ‚Äúnot initialized‚Äù, and then one of them takes the lock, and the other waits.  So, the waiting thread on the lock, if you do not make an additional check, will reinitialize the singleton, which can lead to dire consequences. <br><br>  DCLP can be illustrated by the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T* pt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,   { StaticLock lock; if (pt == 0) //  ,   pt = new T; } return *pt; }</span></span></code> </pre><br>  Here, the pointer to our created type acts as a condition: if it is zero, then the object must be initialized.  It would seem that everything is fine: there are no performance problems, everything works fine.  However, it turned out that not everything is so rosy.  At one time it was even thought that this was not a pattern, but an <a href="http://softncoffee.blogspot.com/2010/08/double-checked-locking.html">anti-</a> pattern, i.e.  it should not be used, because  leads to subtle mistakes.  Let's try to figure out what's the matter. <br><br>  Well, firstly, such a singleton will not be deleted, although this is not a very big problem: the lifetime of a singleton coincides with the time of the application, so the operating system will clean it up itself (unless, of course, some nontrivial processing is required, such as writing in message log or sending a specific request to the database to change the application status record). <br><br>  The second more serious problem is the following line: <br><br><pre> <code class="cpp hljs">pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T;</code> </pre><br>  Consider this in more detail.  This line can be rewritten as follows (I will omit exception handling for short): <br><br><pre> <code class="cpp hljs">pt = <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-comment"><span class="hljs-comment">//     new (pt) T; // placement new:      </span></span></code> </pre><br>  Those.  memory is allocated first, and then the object is initialized by calling its constructor.  So, it may turn out that the memory has already been allocated, the pt value has been updated, and the object has not yet been created.  Thus, if any thread performs the first check outside the lock, the single function will return a reference to the memory that was allocated but not initialized. <br><br>  Let us now try to correct both problems described above. <br><br><h3>  Proposed approach </h3><br>  Let's introduce 2 functions for creating a singleton: we will use one as if we have a single-threaded application, and the other for multi-threaded use: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      template&lt;typename T&gt; T&amp; singleUnsafe() { static T t; return t; } //       template&lt;typename T&gt; T&amp; single() { static T* volatile pt; if (pt == 0) { T* tmp; { StaticLock lock; tmp = &amp;singleUnsafe&lt;T&gt;(); } pt = tmp; } return *pt; }</span></span></code> </pre><br>  The idea is as follows.  We know that our initial implementation (now the singleUnsafe function) works fine in a single-threaded application.  Therefore, all we need is call serialization, which is achieved by properly using locks.  In a sense, there are also 2 checks here, only the first check outside the lock uses the pointer, and the second the internal variable that is generated by the compiler.  It also uses the volatile keyword to prevent reordering of operations in case of over-optimization by the compiler.  It is also worth noting that the assignment of the pt pointer occurs outside of locks.  This is done so that the processor does not reorder operations during the execution of the code. <br><br>  The result of compiling such an implementation is shown below: <br><br><pre> <code class="hljs perl">template&lt;typename T&gt; T&amp; single() { ;   <span class="hljs-number"><span class="hljs-number">000</span></span>83B3<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0FFFFFFFFh <span class="hljs-number"><span class="hljs-number">000</span></span>83B32 <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset __ehhandler$??$single@UA@@@@YAAAUA@@XZ (0A13B6h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B37 mov eax,dword ptr fs:[<span class="hljs-number"><span class="hljs-number">00000000</span></span>h] <span class="hljs-number"><span class="hljs-number">000</span></span>83B3D <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-number"><span class="hljs-number">000</span></span>83B3E mov dword ptr fs:[<span class="hljs-number"><span class="hljs-number">0</span></span>],esp <span class="hljs-number"><span class="hljs-number">000</span></span>83B45 <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx static T* volatile pt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt == <span class="hljs-number"><span class="hljs-number">0</span></span>) ;     <span class="hljs-number"><span class="hljs-number">000</span></span>83B46 mov eax,dword ptr [pt (0E3950h)] <span class="hljs-number"><span class="hljs-number">000</span></span>83B4B test eax,eax <span class="hljs-number"><span class="hljs-number">000</span></span>83B4D jne single&lt;A&gt;+<span class="hljs-number"><span class="hljs-number">7</span></span>Dh (<span class="hljs-number"><span class="hljs-number">83</span></span>BADh) { T* tmp; { StaticLock lock; ;   EnterCriticalSection    <span class="hljs-number"><span class="hljs-number">000</span></span>83B4F <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset staticMutex (0E3954h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B54 mov dword ptr [esp+<span class="hljs-number"><span class="hljs-number">4</span></span>],offset staticMutex (0E3954h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B5C call dword ptr [__imp__EnterCriticalSection@4 (0ED6A4h)] tmp = &amp;singleUnsafe&lt;T&gt;(); <span class="hljs-number"><span class="hljs-number">000</span></span>83B62 mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>83B67 mov dword ptr [esp+0Ch],<span class="hljs-number"><span class="hljs-number">0</span></span> ;   <span class="hljs-number"><span class="hljs-number">000</span></span>83B6F test byte ptr [<span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (0E394Ch)],al <span class="hljs-number"><span class="hljs-number">000</span></span>83B75 jne single&lt;A&gt;+<span class="hljs-number"><span class="hljs-number">68</span></span>h (<span class="hljs-number"><span class="hljs-number">83</span></span>B98h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B77 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> dword ptr [<span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (0E394Ch)],eax <span class="hljs-number"><span class="hljs-number">000</span></span>83B7D mov ecx,offset t (0E3948h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B82 mov byte ptr [esp+0Ch],al ;  :   <span class="hljs-number"><span class="hljs-number">000</span></span>83B86 call A::A (<span class="hljs-number"><span class="hljs-number">1105</span></span>Fh) <span class="hljs-number"><span class="hljs-number">000</span></span>83B8B <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset <span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`dynamic atexit destructor for '</span></span>t<span class="hljs-string"><span class="hljs-string">''</span></span> (0AD4D0h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B9<span class="hljs-number"><span class="hljs-number">0</span></span> call atexit (<span class="hljs-number"><span class="hljs-number">60</span></span>BB1h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B95 add esp,<span class="hljs-number"><span class="hljs-number">4</span></span> } ;   LeaveCriticalSection    <span class="hljs-number"><span class="hljs-number">000</span></span>83B98 <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> offset staticMutex (0E3954h) <span class="hljs-number"><span class="hljs-number">000</span></span>83B9D call dword ptr [__imp__LeaveCriticalSection@4 (0ED6ACh)] pt = tmp; ;    pt    <span class="hljs-number"><span class="hljs-number">000</span></span>83BA3 mov dword ptr [pt (0E3950h)],offset t (0E3948h) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pt; } <span class="hljs-number"><span class="hljs-number">000</span></span>83BAD mov ecx,dword ptr [esp+<span class="hljs-number"><span class="hljs-number">4</span></span>] ;     eax <span class="hljs-number"><span class="hljs-number">000</span></span>83BB1 mov eax,dword ptr [pt (0E3950h)] <span class="hljs-number"><span class="hljs-number">000</span></span>83BB6 mov dword ptr fs:[<span class="hljs-number"><span class="hljs-number">0</span></span>],ecx <span class="hljs-number"><span class="hljs-number">000</span></span>83BBD add esp,<span class="hljs-number"><span class="hljs-number">10</span></span>h <span class="hljs-number"><span class="hljs-number">000</span></span>83BC<span class="hljs-number"><span class="hljs-number">0</span></span> ret</code> </pre><br>  I added comments to the assembly code so that it was clear what was going on.  It is interesting to note the exception handling code: a rather impressive piece.  It can be compared with the <b>GCC</b> code, where tables are used when promoting a stack with zero overhead in the absence of a generated exception.  If you look at the code for the x64 platform of the <b>MSVC</b> compiler, then you can see a slightly different approach to exception handling: <br><br><pre> <code class="hljs perl">template&lt;typename T&gt; T&amp; single() { <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40160<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401602 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">,30</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function"> 000000013</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F401606</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qword</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptr</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">+20</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function">],0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFFFFFFFFFFFFFFEh</span></span></span><span class="hljs-function"> 000000013</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F40160F</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qword</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptr</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">+48</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function">],</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rbx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pt</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401614 mov rax,qword ptr [pt (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F5890h)] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40161B test rax,rax <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40161E jne single&lt;A&gt;+<span class="hljs-number"><span class="hljs-number">75</span></span>h (<span class="hljs-number"><span class="hljs-number">13</span></span>F401675h) { T* tmp; { StaticLock lock; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40162<span class="hljs-number"><span class="hljs-number">0</span></span> lea rbx,[staticMutex (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F58A0h)] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401627 mov qword ptr [lock],rbx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40162C mov rcx,rbx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40162F call qword ptr [__imp_EnterCriticalSection (<span class="hljs-number"><span class="hljs-number">13</span></span>F50CCC0h)] ; nop !!! <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401635 nop tmp = &amp;singleUnsafe&lt;T&gt;(); <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401636 mov eax,dword ptr [<span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F588Ch)] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40163C lea rdi,[t (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F5888h)] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401643 test al,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401645 jne single&lt;A&gt;+<span class="hljs-number"><span class="hljs-number">65</span></span>h (<span class="hljs-number"><span class="hljs-number">13</span></span>F401665h) <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401647 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> eax,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40164A mov dword ptr [<span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`local static guard'</span></span> (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F588Ch)],eax <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40165<span class="hljs-number"><span class="hljs-number">0</span></span> mov rcx,rdi <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401653 call A::A (<span class="hljs-number"><span class="hljs-number">13</span></span>F401087h) <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401658 lea rcx,[<span class="hljs-string"><span class="hljs-string">`singleUnsafe&lt;A&gt;'::`</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'::`dynamic atexit destructor for '</span></span>t<span class="hljs-string"><span class="hljs-string">''</span></span> (<span class="hljs-number"><span class="hljs-number">13</span></span>F4A6FF0h)] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40165F call atexit (<span class="hljs-number"><span class="hljs-number">13</span></span>F456664h) ; nop !!! <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401664 nop } <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401665 mov rcx,rbx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401668 call qword ptr [__imp_LeaveCriticalSection (<span class="hljs-number"><span class="hljs-number">13</span></span>F50CCD0h)] pt = tmp; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40166E mov qword ptr [pt (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F5890h)],rdi } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pt; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401675 mov rax,qword ptr [pt (<span class="hljs-number"><span class="hljs-number">13</span></span>F4F5890h)] } <span class="hljs-number"><span class="hljs-number">000000013</span></span>F40167C mov rbx,qword ptr [rsp+<span class="hljs-number"><span class="hljs-number">48</span></span>h] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401681 add rsp,<span class="hljs-number"><span class="hljs-number">30</span></span>h <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401685 <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-number"><span class="hljs-number">000000013</span></span>F401686 ret</code> </pre><br>  I specifically noted the nop instructions.  They are used as markers in the promotion of a stack in the event of an exception being thrown.  This approach also has no overhead for executing code in the absence of a generated exception. <br><br><h3>  findings </h3><br>  So, it is time to formulate conclusions.  The article shows that different compilers relate differently to the new standard: <b>GCC makes</b> every effort to adapt to modern realities and correctly handles the initialization of singletons in a multi-threaded environment;  <b>MSVC</b> lags slightly behind, so a careful implementation of the singleton described in the article is required.  This approach is a universal and efficient implementation without serious synchronization overhead. <br><br><h3>  PS </h3><br>  This article is an introduction to multi-threading questions.  It solves the problem of access in case of creating a singleton object.  Further use of his data raises other serious questions, which will be discussed in detail in the next article. <br><br><h3>  Update </h3><br>  The implementation of the singleton was corrected taking into account comments to the article. <br><br><h3>  Literature </h3><br>  [1] <a href="http://habrahabr.ru/post/116577/">Habrahabr: Using the Singleton pattern</a> <br>  [2] <a href="http://habrahabr.ru/post/118368/">Habrahabr: Singleton and object lifetime</a> <br> [3] <a href="http://habrahabr.ru/post/118550/">:      </a> <br> [4] <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">Final Committee Draft (FCD) of the C++0x standard</a> <br> [5] <a href="http://openassist.googlecode.com/files/C%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf">C++ Standard ‚Äî ANSI ISO IEC 14882 2003</a> <br> [6] <a href="http://ultimatepp.org/">Ultimate++: C++ cross-platform rapid application development framework</a> <br> [7] <a href="http://www.boost.org/">Boost C++ libraries</a> <br> [8] <a href="http://ru.wikipedia.org/wiki/Double_checked_locking">Wikipedia: Double-checked locking</a> <br> [9] <a href="http://softncoffee.blogspot.com/2010/08/double-checked-locking.html">,  double-checked locking</a> </div><p>Source: <a href="https://habr.com/ru/post/150276/">https://habr.com/ru/post/150276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150267/index.html">MVC pattern implementation using the example of creating a business card site in PHP</a></li>
<li><a href="../150269/index.html">Russia's foreign intelligence service creates bots for social networks for 30 million rubles</a></li>
<li><a href="../150271/index.html">Two-factor Authorization on Linux server</a></li>
<li><a href="../150273/index.html">ABBYY Labs. Q & A: the beginning</a></li>
<li><a href="../150274/index.html">Proper use of QThread</a></li>
<li><a href="../150277/index.html">Interview: how would you say no?</a></li>
<li><a href="../150279/index.html">Winning Apple in court will not prevent the development of Android</a></li>
<li><a href="../150280/index.html">Which SIP server to choose: SER, OpenSER, Kamailio, OpenSIPS? What do they have in common and what is the difference?</a></li>
<li><a href="../150283/index.html">ZTE welcomes Habr</a></li>
<li><a href="../150285/index.html">Nekki internship program</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>