<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Strings in the AVR code memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In our company, we write programs for AVR series controllers. In this article I want to describe how we create strings located in code memory. 

 Init...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Strings in the AVR code memory</h1><div class="post__text post__text-html js-mediator-article">  In our company, we write programs for AVR series controllers.  In this article I want to describe how we create strings located in code memory. <br><br>  Initially, it was required that the following code should not give errors, but in the end get a much more powerful tool than expected. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pStr = PSTR(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . // error: statement-expressions are not allowed outside functions nor in template-argument lists int main() {‚Ä¶}</span></span></code> </pre> <a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Those who are not aware of the problem of working with memory in AVR microcontrollers can watch the spoiler</b> <div class="spoiler_text">  AVR controllers use two independent address spaces: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  for code </li><li>  for RAM and registers. </li></ul><br>  The GCC compiler uses a two-byte pointer that provides access to the first 64K code memory (the rest can only be used for instructions) or to the entire RAM. <br><br>  But to find out by the pointer in which memory the variable is located is not possible.  Because of this, separate functions appeared in the avr-gcc library for working with the code memory and the strings located in it.  They are marked with the ‚Äú_P‚Äù suffix at the end of the function name.  For example, strcpy_P is an analogue of the function strcpy, which takes a pointer to a string in code memory. <br><br>  Unfortunately, the compiler cannot check where the variable will be used and place it there, and therefore the programmer needs to take care of it himself.  Accordingly, it has become necessary to label the variables located in the code memory with the PROGMEM keyword in order to clearly indicate that we intend to work with the code. <br><br>  This, however, does not negate the need for the programmer to monitor the correct use of variables. <br></div></div><br>  Most of the inconvenience we delivered the line.  String literals are objects located in RAM, which means they occupy both RAM and code memory (you need to take values ‚Äã‚Äãfor initialization from somewhere).  Again, they are not suitable for working with functions that work with code memory.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dest[<span class="hljs-number"><span class="hljs-number">20</span></span>]; strcpy_P(dest, <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>); }</code> </pre> <br>  This code will lead to undefined consequences, since it will take data from code memory located at the same address as the string ‚ÄúHello world!‚Äù In RAM. <br><br>  For these cases, the PSTR (text) macro was provided in the avr library, which returns a pointer to a string located in the code memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dest[<span class="hljs-number"><span class="hljs-number">20</span></span>]; strcpy_P(dest, PSTR(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>)); }</code> </pre> <br>  Now this code works and does not even take up RAM.  But it is necessary to bring this macro beyond the limits of any function, it stops working. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pStr = PSTR(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . // error: statement-expressions are not allowed outside functions nor in template-argument lists int main() {‚Ä¶}</span></span></code> </pre> <br>  I had to write something like this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> PROGMEM caption1[]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> caption1[] = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pStr = caption1;</code> </pre> <br>  This is a contrived example, but imagine that instead of pStr, we are initializing some kind of user structure that is waiting for a pointer to a string. <br><br>  First of all, it was necessary to initialize the menu structure.  All initialization had to be done statically, at compile time. <br><br>  Therefore, we began to look for a reliable way to get a pointer to a string in the code memory.  This helped us to template classes.  For a template class, you can create a static variable located in the code memory and get a pointer to it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> value&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProgmemChar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> PROGMEM v; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> value&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ProgmemChar&lt;value&gt;::v = value; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pChar = &amp;(ProgmemChar&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;::v);</code> </pre> <br>  But do not pass the string parameter in the template.  Therefore, we decided to break the string into characters.  As we break the string into characters, I will show further, but for now I will show a simple example of a string in code memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch2, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch3, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch4, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch5&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProgmemString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> PROGMEM v[<span class="hljs-number"><span class="hljs-number">5</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch2, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch3, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch4, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch5&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ProgmemString&lt;ch1, ch2, ch3, ch4, ch5&gt;::v[<span class="hljs-number"><span class="hljs-number">5</span></span>] = {ch1, ch2, ch3, ch4, ch5}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pStr = ProgmemString&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;::v;</code> </pre> <br>  This example works for strings that are exactly 4 characters in length and ends with 0 at the end.  And the string ProgmemString &lt;'a', 0, 0, 0, 0&gt; will also occupy 5 bytes. <br><br>  To solve this problem, we used a partial specialization of the template class, adding the size of the string to the template.  Here is the basic template class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... L&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pstr</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  Now back to the problem of breaking a string into characters.  To be honest, this is still a problem for us, since we could not come up with anything better than to write a macro that N takes the i-th (from 0 to N-1) character from the source string. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPLIT_TO_CHAR_4(STR) STR[0], STR[1], STR[2], STR[3]</span></span></code> </pre> <br>  This macro breaks the string, which must be at least four characters, into characters.  In this case, N = 4. <br><br>  If we look at the code after the preprocessor, we would see the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  I agree that this is a long text, but we have come to terms with it.  Moreover, the compiler itself already produces only four characters. <br><br>  A more important problem was taking a character with a large index.  For a large N (and we want all our lines to be shorter than N), there will definitely be a case when we want to take a character outside of the line, which will result in a compilation error. <br><br>  The first working option was the following way: <br><br><ol><li>  Add to the source line a string consisting of the character '\ 0' and having a length of N characters.  Adding was carried out as follows: #define ADD_STR (STR) STR "\ 0 \ 0 \ ... \ 0". </li><li>  We perform an SPLIT_TO_CHAR operation on the resulting string. </li></ol><br>  This method works, but is guaranteed to increase the code after the preprocessor by N * N characters.  As a result, we quickly get the compiler limit. <br><br>  Fortunately, with the arrival of c ++ 11 and constexpr functions, we managed to get rid of the extra characters using the character selector class.  For brevity, it is called _CS (Char Selector). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CS</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> _CS(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;s)[n]) :s(s), l(n){} <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt; l ?s[i] :<span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  I looked at the code of this class quite a while on Habr√©, but I cannot now find exactly where (thanks to the author). <br>  The code for the character splitting macro has become simpler: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPLIT_TO_CHAR(STR) _CS(STR)[0], _CS(STR)[1], ‚Ä¶, _CS(STR)[N-1]</span></span></code> </pre> <br>  It now remains to put everything together: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    template&lt;size_t S, char... L&gt;struct _PStr; //  ,    .     10  #define ARGS01(P, S) P##00 S #define ARGS02(P, S) ARGS01(P, S),P##01 S #define ARGS03(P, S) ARGS02(P, S),P##02 S #define ARGS04(P, S) ARGS03(P, S),P##03 S #define ARGS05(P, S) ARGS04(P, S),P##04 S #define ARGS06(P, S) ARGS05(P, S),P##05 S #define ARGS07(P, S) ARGS06(P, S),P##06 S #define ARGS08(P, S) ARGS07(P, S),P##07 S #define ARGS09(P, S) ARGS08(P, S),P##08 S #define ARGS0A(P, S) ARGS09(P, S),P##09 S //       ( 0  10 ).     0. template&lt;char... L&gt;struct _PStr&lt;0x00, L...&gt;{static const char PROGMEM v[];}; template&lt;char... L&gt;const char _PStr&lt;0x00, L...&gt;::v[] = {0}; template&lt;ARGS01(char _,), char... L&gt;struct _PStr&lt;0x01, ARGS01(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS01(char _,), char... L&gt;const char _PStr&lt;0x01, ARGS01(_,), L...&gt;::v[] = {ARGS01(_,), 0}; template&lt;ARGS02(char _,), char... L&gt;struct _PStr&lt;0x02, ARGS02(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS02(char _,), char... L&gt;const char _PStr&lt;0x02, ARGS02(_,), L...&gt;::v[] = {ARGS02(_,), 0}; template&lt;ARGS03(char _,), char... L&gt;struct _PStr&lt;0x03, ARGS03(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS03(char _,), char... L&gt;const char _PStr&lt;0x03, ARGS03(_,), L...&gt;::v[] = {ARGS03(_,), 0}; template&lt;ARGS04(char _,), char... L&gt;struct _PStr&lt;0x04, ARGS04(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS04(char _,), char... L&gt;const char _PStr&lt;0x04, ARGS04(_,), L...&gt;::v[] = {ARGS04(_,), 0}; template&lt;ARGS05(char _,), char... L&gt;struct _PStr&lt;0x05, ARGS05(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS05(char _,), char... L&gt;const char _PStr&lt;0x05, ARGS05(_,), L...&gt;::v[] = {ARGS05(_,), 0}; template&lt;ARGS06(char _,), char... L&gt;struct _PStr&lt;0x06, ARGS06(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS06(char _,), char... L&gt;const char _PStr&lt;0x06, ARGS06(_,), L...&gt;::v[] = {ARGS06(_,), 0}; template&lt;ARGS07(char _,), char... L&gt;struct _PStr&lt;0x07, ARGS07(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS07(char _,), char... L&gt;const char _PStr&lt;0x07, ARGS07(_,), L...&gt;::v[] = {ARGS07(_,), 0}; template&lt;ARGS08(char _,), char... L&gt;struct _PStr&lt;0x08, ARGS08(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS08(char _,), char... L&gt;const char _PStr&lt;0x08, ARGS08(_,), L...&gt;::v[] = {ARGS08(_,), 0}; template&lt;ARGS09(char _,), char... L&gt;struct _PStr&lt;0x09, ARGS09(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS09(char _,), char... L&gt;const char _PStr&lt;0x09, ARGS09(_,), L...&gt;::v[] = {ARGS09(_,), 0}; template&lt;ARGS0A(char _,), char... L&gt;struct _PStr&lt;0x0A, ARGS0A(_,), L...&gt;{static const char PROGMEM v[];}; template&lt;ARGS0A(char _,), char... L&gt;const char _PStr&lt;0x0A, ARGS0A(_,), L...&gt;::v[] = {ARGS0A(_,), 0}; //   struct _CS { template&lt;size_t n&gt; constexpr _CS(const char (&amp;s)[n]) :s(s), l(n){} constexpr char operator [](size_t i){return i &lt; l ?s[i] :0;} const char *s = 0; const size_t l = 0; }; //      #define STR_UNION(...) __VA_ARGS__ //  ,    ,    . SPS = StaticProgramString. #define SPS(T) STR_UNION(_PStr&lt;_CS(T).l - 1, ARGS0A(_CS(T)[0x, ])&gt;::v)</span></span></code> </pre> <br>  Let us analyze the main macro by elements: <br><br><ul><li>  _Pstr &lt;size_t S, char ... L&gt; :: v - a pointer to a string of length S and containing the characters L, </li><li>  _CS (T) .l - 1 - the size of the original string without a zero at the end, </li><li>  ARGS0A (_CS (T) [0x,]) is a macro that takes the first 10 characters from the source string. </li></ul><br>  For each line will be selected its own specialization of the template, suitable for the length of the line. <br><br><hr><br>  Summing up, I would like to say that with the help of this macro we managed to implement not only getting a pointer to a string in the code, no matter where this macro is applied, but also two more distinct advantages over the PSTR: <br><br><ul><li>  For each unique line created using SPS, only one instance of the line will be created, because the static template field is created only once for the entire project.  Of course, modern compilers can optimize the use of strings, but only as part of compiling a single cpp file. <br><br></li><li>  The string is created with a globally accessible name, which is necessary for use as a template parameter. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedType</span></span></span><span class="hljs-class"> {</span></span> T value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } }; NamedType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, SPS(<span class="hljs-string"><span class="hljs-string">""</span></span>)&gt; var1 = {<span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre><br>  These template classes allowed us to collect metadata about variables in the project, which allowed us to simplify development by an order of magnitude, while at the same time improving the user interface and customization flexibility.  But that's another story. </div><p>Source: <a href="https://habr.com/ru/post/311874/">https://habr.com/ru/post/311874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311860/index.html">I am here ... I wrote a track record for time. 628 minutes</a></li>
<li><a href="../311862/index.html">100% online airway or How to tame the booking system</a></li>
<li><a href="../311866/index.html">The new program is able to recover information hidden by pixelation.</a></li>
<li><a href="../311870/index.html">Themeforest Alternative for Those Who Want to Sell WordPress Themes</a></li>
<li><a href="../311872/index.html">Warm lamp rake of a small business on the example of a single store in Vladimir</a></li>
<li><a href="../311876/index.html">I find out dearly by the retina: modern methods of identification by biometric indicators</a></li>
<li><a href="../311878/index.html">How we connected Parallels Desktop and Office 365</a></li>
<li><a href="../311890/index.html">Google Drive as a backup storage for Linux based VPS server</a></li>
<li><a href="../311892/index.html">Peter Hinchens: For thirty-five years, as a necromancer, I breathed life into dead iron with a code</a></li>
<li><a href="../311894/index.html">Easy to start, hard to finish or about the death of startups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>