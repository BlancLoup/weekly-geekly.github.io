<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scala vs Kotlin (translation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our team, similarly to the author of the article, has been moving from Scala to Kotlin as the main language for almost a year. My opinion largely coin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scala vs Kotlin (translation)</h1><div class="post__text post__text-html js-mediator-article"><p>  <i>Our team, similarly to the author of the article, has been moving from Scala to Kotlin as the main language for almost a year.</i>  <i>My opinion largely coincides with the author, so I offer you a translation of his interesting article.</i> </p><br><p>  It has been a decent time since I did not update the blog.  Already a year, I switched from Scala, my main language, to Kotlin.  The language borrowed a lot of good things that I liked in Scala, while managing to avoid many of the pitfalls and ambiguity that Scala has. </p><br><p>  Below I want to give examples that I like in Scala and Kotlin, as well as their comparison in how they are implemented in both languages. </p><a name="habracut"></a><br><h4>  <b>Declaration and type inference</b> </h4><br><p>  What I particularly like in both languages ‚Äã‚Äãis that they are both statically typed with type derivation.  This gives you the opportunity to fully utilize the power of static typing without bulky code <i>declarations</i> ( <i>orig .: declarative boiler plate</i> ).  In most cases this works in both languages.  Both languages ‚Äã‚Äãalso show a preference for immutable types along with an optional variable type declaration after its name. </p><br><p>  Sample code will be the same in both languages: </p><br><p>  Declaration of an immutable variable with the name <i>age</i> and type <i>Int</i> : </p><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Variable variable declaration of type <i>String</i> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeting = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span></code> </pre> <br><p>  Both languages ‚Äã‚Äãsupport lambda functions as first-class objects that can be assigned to variables or passed as parameters to functions: </p><br><p>  <u>Scala</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> double = (i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; { i * <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  <u>Kotlin</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> double = {i: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; i * <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><h4>  <b><i>Data</i> / <i>Case</i> classes</b> </h4><br><p>  Scala and Kotlin have a similar concept of data classes, which are representations of the <i>data model object</i> . </p><br><h5>  <b>Scala approach</b> </h5><br><p>  In Scala, these are <i>case</i> classes that look like this: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><ul><li>  There is an <i>apply</i> method (no need to use the <i>new</i> keyword when creating an instance) <br></li><li>  Access methods are declared for each <i>property</i> (if the <i>property is</i> declared as a <i>var,</i> then the <i>setter</i> method will also be present) <br></li><li>  <i>toString</i> , <i>equal</i> and <i>hashCode are</i> intelligently declared. <br></li><li>  There is a copy function <br></li><li>  There is an <i>unapply</i> method (which allows using these classes in <i>pattern matching</i> ) <br></li></ul><br><h5>  <b>Approach in <i>kotlin</i></b> </h5><br><p>  Kotlin calls these classes as <i>data class</i> </p><br><pre> <code class="scala hljs">data <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Key features: </p><br><ul><li>  Methods for access are declared for each <i>property</i> (if <i>property is</i> declared as a <i>var,</i> then the <i>setter</i> method will also be present).  This is not an exclusive feature of <i>data</i> classes, the statement is true for any classes in Kotlin. <br></li><li>  Reasonably declared <i>toString</i> , <i>equal</i> and <i>hashCode</i> <br></li><li>  Copy function <br></li><li>  <i>component1..componentN</i> function.  By analogy, used as <i>unapply</i> . <br></li><li>  Implements <i>JavaBean</i> <i>getter</i> and <i>setter</i> required for <i>Java</i> frameworks such as Hibernate, Jackson, unchanged. <br></li></ul><br><p>  In Kotlin, there is no need for a special <i>apply</i> method, nor is the need for the <i>new</i> keyword to initialize a class.  So this is a standard constructor declaration like any other class. </p><br><h4>  <b>Comparison</b> </h4><br><p>  Basically the <i>case</i> and <i>data</i> classes are similar. </p><br><p>  The example below looks the same in both languages: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jack = <span class="hljs-type"><span class="hljs-type">Person</span></span>(<span class="hljs-string"><span class="hljs-string">"jack"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> olderJack = jack.copy(age = <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  In general, I found the <i>data</i> and <i>case</i> classes interchangeable in everyday use.  In Kotlin there are some restrictions on the inheritance of <i>data</i> classes, but this was done out of good intentions with regard to the implementation of the <i>equals</i> and <i>componentN</i> functions in order to avoid pitfalls. </p><br><p>  In the Scala <i>case,</i> classes are more powerful in <i>pattern matshing</i> compared to how Kotlin works with <i>data</i> classes in 'when' blocks that lack this. </p><br><p>  The Kotlin approach works better for existing Java frameworks, since  they look like normal <i>Java beans</i> to them. </p><br><p>  Both languages ‚Äã‚Äãallow you to pass parameters by name and allow you to specify a default value for them. </p><br><h4>  <b>Null Safely / Optionality</b> </h4><br><h5>  <b>Scala approach</b> </h5><br><p>  The Scala is <i>null safely</i> to use the monad <i>option</i> .  Simply put, <i>option</i> can be in one of two specific states: <i>Some (x)</i> or <i>None.</i> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anOptionInt: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  or </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anOptionInt: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">None</span></span></code> </pre> <br><p>  You can operate with <i>option</i> using the isDefined and getOrElse functions (to indicate the default value), but the more frequently used situation is when monads are used with <i>map</i> , <i>foreach</i> or <i>fold</i> operators, for which <i>option</i> is a collection containing 0 or 1 element. </p><br><p>  For example, you can calculate the sum of two optional variables as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n1Option: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n2Option: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (n1 &lt;- n1Option; n2 &lt;- n2Option) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> {n1 + n2 }</code> </pre> <br><p>  In Variable <i>sum</i> will be the value <i>Some (3)</i> .  An illustrative example of how <i>for</i> can be used as <i>foreach</i> or <i>flatMap</i> , depending on the use of the <i>yield</i> keyword. </p><br><p>  Another example: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Person</span></span>(<span class="hljs-string"><span class="hljs-string">"Jack"</span></span>, <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p &lt;- person; age &lt;- p.age)  {  println(<span class="hljs-string"><span class="hljs-string">s"The person is age </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$age</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><p>  The line "The person is age 1" will be printed. </p><br><h5>  <b>Approach in kotlin</b> </h5><br><p>  Kotlin borrows groovy syntax, quite practical in everyday use.  In Kotlin, all types are <i>non-nullable</i> and must be explicitly declared <i>nullable</i> using "?"  if they can contain <i>null</i> . </p><br><p>  The same example can be rewritten as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n1: <span class="hljs-type"><span class="hljs-type">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n2: <span class="hljs-type"><span class="hljs-type">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; n2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) n1 + n2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  This is much closer to the Java syntax, except that Kotlin <i>enforces</i> compile-time checks, <i>preventing nullable</i> variables from being used without being <i>null</i> -checked, so you should not be afraid of a NullPointerException.  Also, you cannot assign a <i>null to a</i> variable declared as <i>non-nullable</i> .  In addition, the compiler is smart enough to avoid <i>null</i> re-checking of a variable, which avoids multiple checking of variables like in Java. </p><br><p>  The equivalent Kotlin code for the second example will look like this: </p><br><pre> <code class="scala hljs">data <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">?</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Person</span></span>? = <span class="hljs-type"><span class="hljs-type">Person</span></span>(<span class="hljs-string"><span class="hljs-string">"Jack"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person?.age != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { printn(<span class="hljs-string"><span class="hljs-string">"The person is age ${person?.age}"</span></span>) }</code> </pre> <br><p>  Or an alternative using "let", which replaces the "if" block with: </p><br><pre> <code class="scala hljs">person?.age?.let { person(<span class="hljs-string"><span class="hljs-string">"The person is age $it"</span></span>) }</code> </pre> <br><h4>  <b>Comparison</b> </h4><br><p>  I prefer the approach in Kotlin.  It is much more readable and understandable, and it is easier to understand what happens in multiple nested levels.  The Scala approach is repelled by the behavior of monads, which of course some people like, but from my own experience I can say that the code is becoming too overloaded for small investments.  There are a huge number of pitfalls in this complication in using a <i>map</i> or <i>flatMap</i> , and you won‚Äôt even get a warning when compiling if you do something wrong in a monad jumble or using <i>pattern match</i> without searching for alternatives, which results in <i>runtime exception</i> which are not obvious. </p><br><p>  The approach to Kotlin also reduces the gap when integrating with Java code due to the fact that the types of it are nullable by default (the <i>author is not entirely correct here. Types of Java fall into an intermediate state between nullable and not-nullable, which can be refined in the future</i> ), while Scala has to support <i>null</i> as a concept without <i>null-safely</i> protection. </p><br><h4>  <b>Functional collections</b> </h4><br><p>  Scala, of course, supports the functional approach.  Kotlin is slightly less so, but the main ideas are supported. </p><br><p>  In the example below, there are no particular differences in the work of the <i>fold</i> and <i>map</i> functions: </p><br><p>  <u>Scala</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers = <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> doubles = numbers.map { _ * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sumOfSquares = doubles.fold(<span class="hljs-number"><span class="hljs-number">0</span></span>) { _ + _ }</code> </pre> <br><p>  <u>Kotlin</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers = <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> doubles = numbers.map { it * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sumOfSquares = doubles.fold(<span class="hljs-number"><span class="hljs-number">0</span></span>) {x,y -&gt; x+y }</code> </pre> <br><p>  Both languages ‚Äã‚Äãsupport the concept chain of "lazy" calculations.  For example, the output of 10 even numbers will be as follows: </p><br><p>  <u>Scala</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers = <span class="hljs-type"><span class="hljs-type">Stream</span></span>.from(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> squares = numbers.map { x =&gt; x * x } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> evenSquares = squares.filter { _%<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } println(evenSquares.take(<span class="hljs-number"><span class="hljs-number">10</span></span>).toList)</code> </pre> <br><p>  <u>Kotlin</u> </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers = sequence(<span class="hljs-number"><span class="hljs-number">1</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> squares = numbers.map { it * it } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> evenSquares = squares.filter { it%<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } println(evenSquares.take(<span class="hljs-number"><span class="hljs-number">10</span></span>).toList())</code> </pre> <br><h4>  <b><i>Implicit</i> conversion vs <i>extension</i> methods</b> </h4><br><p>  This is the area in which Scala and Kotlin diverge a little. </p><br><h5>  <b>Scala approach</b> </h5><br><p>  Scala has the concept of <i>implicit</i> transformations, which allows you to add extended functionality to a class thanks to automatic conversion to another class if necessary.  Example ads: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Helpers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWithTimes</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">x: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](f: =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = {     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> to x) { f     }   } } }</code> </pre> <br><p>  Then the code can be used as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Helpers</span></span>._ <span class="hljs-number"><span class="hljs-number">5.</span></span>times(println(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>))</code> </pre> <br><p>  This will output "Hello" 5 times.  This works due to the fact that when you call the function "times" (which actually does not exist in Int), the variable is automatically wrapped into an IntWithTimes object, in which the function is called. </p><br><h5>  <b>Approach in kotlin</b> </h5><br><p>  Kotlin uses <i>extension</i> functions for this functionality.  In Kotlin, in order to implement this functionality, you need to declare a regular function, only with a prefix in the form of the type for which the extension is being made. </p><br><pre> <code class="scala hljs">fun <span class="hljs-type"><span class="hljs-type">Int</span></span>.times(f: ()-&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {   f() } }</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-number"><span class="hljs-number">5.</span></span>times { println(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)}</code> </pre> <br><h4>  <b>Comparison</b> </h4><br><p>  The Kotlin approach corresponds to how I mainly use this feature in Scala, with a slight advantage in the form of a slightly more simplified and understandable record. </p><br><h4>  <b>Features of Scala which are not in Kotlin and for which I will not miss</b> </h4><br><p>  One of the best features of Kotlin for me is not even in the functionality that is, but more in the functionality that is not in Kotlin from Scala. </p><br><ul><li>  Call by name - It destroys readability.  If the function is passed it would be much easier to see that the pointer to the function is passed by simply viewing the code.  I do not see any advantages that it gives in comparison with the explicit transfer of lambda. <br></li><li>  Implicit Transformations - This is what I really hate.  This leads to a situation where the behavior of the code varies significantly depending on what was imported.  As a result, it is really hard to say which variable will be passed to the function without good support for the IDE. <br></li><li>  Overloaded <i>for</i> - The problem with multiple monads shown above. <br></li><li>  A mess with the optional syntax of <i>infix</i> and <i>postfix</i> operators - Kotlin is a bit more formalized.  As a result, the code in it is less than ambiguous, it is easier to read and it is not so easy for a simple typo to become an obvious mistake. <br></li><li>  Redefining operators to the maximum - Kotlin allows redefining only the main operators (+, -, etc.).  Scala allows you to use any sequence of characters.  Do I really need to know the difference between "~% #&gt;" and "~ + #&gt;"? <br></li><li>  Slow compile time. <br></li></ul><br><p>  <i>Thanks for attention.</i> <i><br></i>  <i>Original <a href="https://agilewombat.com/2016/02/01/scala-vs-kotlin/">Scala vs Kotlin</a></i> <i><br></i>  <i>PS In some places in the translation specifically left the words without translation (null, null safely, infix, postfix, etc.).</i> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308562/">https://habr.com/ru/post/308562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308552/index.html">Friday format: Mental models or approach to solving complex problems</a></li>
<li><a href="../308554/index.html">Starting programming is never too early: the look of a nine-year-old.</a></li>
<li><a href="../308556/index.html">Lua Meetup on September 2 at the Mail.Ru Group office</a></li>
<li><a href="../308558/index.html">Apple has released an emergency update for iOS</a></li>
<li><a href="../308560/index.html">iOS 9.3.5: security fixes and unsuccessful attack against a human rights defender from the United Arab Emirates</a></li>
<li><a href="../308564/index.html">Development of the game using plasticine animation</a></li>
<li><a href="../308566/index.html">Reverse engineering test crackme from Kaspersky Lab v2.0</a></li>
<li><a href="../308570/index.html">Unity's Forgotten Secret Weapon - UnityEvents</a></li>
<li><a href="../308574/index.html">Webinar: FreePBX. Office telephony: quick start</a></li>
<li><a href="../308578/index.html">Big Data hackathon from Innopolis University and Provectus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>