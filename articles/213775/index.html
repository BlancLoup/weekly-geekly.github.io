<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a driver for an LCD display under embedded linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to share my experience of writing linux drivers for the 320x240 color display from the manufacturer Newhavendisplays, namely NH...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a driver for an LCD display under embedded linux</h1><div class="post__text post__text-html js-mediator-article">  In this article I want to share my experience of writing linux drivers for the 320x240 color display from the manufacturer Newhavendisplays, namely NHD-5.7-320240WFB-CTXI-T1 under embedded linux.  The idea to write an article has ripened precisely because of the fact that there are not so many resources on writing framebufer (FB) drivers, especially in Russian.  The module was written far from under the newest kernel (2.6.30), so I admit that in FB interfaces a lot of things have changed since then.  But, nevertheless, I hope the article will be of interest to those interested in developing the linux kernel level.  I do not exclude that the implementation could be made simpler and more elegant, therefore comments and comments are welcome. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb2/e11/475/bb2e11475d3dd1002c56f188c932a100.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/278/4da/6b22784da00350740c2fd3e098c37e34.jpg"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Prehistory</b> <br><br>  Initially, the task was to write a driver, which could be accessed using standard tools such as QT embedded, to ultimately build a simple menu with icons and text for user interaction.  The platform was a scarf on the AT91SAM9G45, or rather, <a href="http://www.armdevs.com/IPC-SAM9G45.html">www.armdevs.com/IPC-SAM9G45.html</a> <br>  Streaming video was not planned.  The AT91SAM9G45 contains a fully functional built-in LCD controller with DMA support and a fairly high-speed bus, which could potentially have a decent speed for video, but alas, hardwired, it is not compatible with SSD1963.  Therefore, it was decided to use an ordinary GPIO interface for this purpose, as the only available alternative. <br><br>  <b>Controller Interface SSD1963</b> <br><br>  The controller interface is easiest to present in the form of a picture from the datasheet of the display: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/845/377/030/8453770308dad4952e14a7b56c9df89d.png"><br><br>  From the point of view of the driver developer, we are interested in the DB0 - DB7 pins.  This is an 8-bit data bus, and DC, RD, WR, CS, RES pins are used to control the data transfer process on the SSD1963. <br>  As for the format of the transmitted data, this display uses the 888 format. What it means: 8 bytes - Red, 8 bytes - Green, 8 bytes - Blue.  Still quite often in the displays of this type can be found options 555, 565, etc., but this is not our case.  The format of the transmitted data is shown in the figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0aa/11e/a63/0aa11ea63534ab5a6fb02e81dbc3bc77.png"><br><br>  Before the first data byte is put on the bus, the CS and WR pins must switch from 1 to 0. And after the data byte is set, CS and WR switches from 0 to 1, which actually transfers the byte data to the controller SSD1963.  More detailed waveforms of signals can be viewed in the datasheet on the controller.  <a href="http://www.newhavendisplay.com/app_notes/SSD1963.pdf">www.newhavendisplay.com/app_notes/SSD1963.pdf</a> <br><br>  In the source code, the interface will be described with arrays of GPIO pins: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nhd_data_pin_config[] = { AT91_PIN_PE13, AT91_PIN_PE14, AT91_PIN_PE17, AT91_PIN_PE18, AT91_PIN_PE19, AT91_PIN_PE20, AT91_PIN_PE21, AT91_PIN_PE22 }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nhd_gpio_pin_config[] = { AT91_PIN_PE0, <span class="hljs-comment"><span class="hljs-comment">// RESET AT91_PIN_PE2, // DC AT91_PIN_PE5, // CLK AT91_PIN_PE6, // RD AT91_PIN_PE1 // WR };</span></span></code> </pre> <br><br>  The transfer function of bytes on this interface is: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nhd_write_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> command, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; at91_set_gpio_output(AT91_PIN_PE12, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//R/D for (i=0; i&lt;ARRAY_SIZE(nhd_data_pin_config); i++) at91_set_gpio_output(nhd_data_pin_config[i], (value&gt;&gt;i)&amp;0x01); if (command) at91_set_gpio_output(AT91_PIN_PE10, 0); //D/C else at91_set_gpio_output(AT91_PIN_PE10, 1); //D/C at91_set_gpio_output(AT91_PIN_PE11, 0); //WR at91_set_gpio_output(AT91_PIN_PE26, 0); //CS at91_set_gpio_output(AT91_PIN_PE26, 1); //CS at91_set_gpio_output(AT91_PIN_PE11, 1); //WR }</span></span></code> </pre><br><br>  As you can see, using this function, you can send commands (for example, to configure the display) and data in the form of pixels to the LCD controller. <br><br>  <b>Framebuffer core model</b> <br><br>  As you know, the linux kernel provides interfaces for different types of device drivers ‚Äî char drivers, block drivers, usb drivers, etc. The Framebuffer driver is also a separate subsystem in the Linux driver model.  The main structure that is used to represent the FB driver is the <i>struct fb_info</i> in <i>linux / fb.h.</i>  By the way, this header file will also be interesting to fans of humor in the linux code of the kernel, since it contains an interesting define - <br>  <i>#define STUPID_ACCELF_TEXT_SHIT</i> .  I think the name speaks for itself.  But, back to the <i>fb_info</i> structure.  We will be interested in two structures that it contains - <i>fb_var_screeninfo</i> and <i>fb_fix_screeninfo</i> .  We initialize them with the parameters of our display. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_fix_screeninfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_fix</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initdata</span></span></span><span class="hljs-class"> = {</span></span> .id = <span class="hljs-string"><span class="hljs-string">"SSD1963"</span></span>, .type = FB_TYPE_PACKED_PIXELS, .visual = FB_VISUAL_TRUECOLOR, .accel = FB_ACCEL_NONE, .line_length = <span class="hljs-number"><span class="hljs-number">320</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_var_screeninfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_var</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initdata</span></span></span><span class="hljs-class"> = {</span></span> .xres = <span class="hljs-number"><span class="hljs-number">320</span></span>, .yres = <span class="hljs-number"><span class="hljs-number">240</span></span>, .xres_virtual = <span class="hljs-number"><span class="hljs-number">320</span></span>, .yres_virtual = <span class="hljs-number"><span class="hljs-number">240</span></span>, .width = <span class="hljs-number"><span class="hljs-number">320</span></span>, .height = <span class="hljs-number"><span class="hljs-number">240</span></span>, .bits_per_pixel = <span class="hljs-number"><span class="hljs-number">32</span></span>, .transp = {<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .red = {<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .green = {<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .blue = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .activate = FB_ACTIVATE_NOW, .vmode = FB_VMODE_NONINTERLACED, };</code> </pre><br><br>  In our case, 4 bytes will be allocated per pixel: 8-Red, 8-Green, 8-Blue, 8-Transparent <br>  Let me explain some of the fields of the structures: <br><br>  <i>.type</i> is a way to allocate bits that describe pixels in memory.  Packed pixels means that the bytes (in our case, 8888 will be placed one after the other). <br><br>  <i>.visual</i> - display color depth.  In our case, this is truecolor - 24bit color depth <br><br>  <i>.accel</i> - hardware acceleration <br><br>  <i>.transp, red, green, blue</i> - just set our 8,8,8,8 format in the form of three fields - <i>offset, length</i> and <i>msb_right</i> . <br><br>  Also, in order to register our driver in the kernel, it is necessary to describe two more entities - the device (device) and the driver (driver).  We describe the FB device ( <i>struct ssd1963</i> ), which will contain the pages of our video memory ( <i>struct ss1963_page</i> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_page</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> must_update; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pages_count; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_page</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = ssd1963_probe, .remove = ssd1963_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"ssd1963"</span></span> } };</code> </pre><br><br>  <b>Initialization</b> <br><br>  As with any other Linux kernel module, we describe a couple of init / remove functions.  Let's start with init.  Framebuffer drivers are usually registered in the system as <i>platform_driver</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; ret = platform_driver_register(&amp;ssd1963_driver); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { pr_err(<span class="hljs-string"><span class="hljs-string">"%s: unable to platform_driver_register\n"</span></span>, __func__); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } module_init(ssd1963_init);</code> </pre><br><br>  In turn, the Platform driver calls the probe function for a specific driver, which performs all the necessary operations ‚Äî allocating memory, reserving resources, initializing structures, etc.  Here is an example of the <i>ssd1963_probe</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *dev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// Allocating memory for ssd1663 device item = kzalloc(sizeof(struct ssd1963), GFP_KERNEL); if (!item) { dev_err(&amp;dev-&gt;dev, "%s: unable to kzalloc for ssd1963\n", __func__); ret = -ENOMEM; goto out; } item-&gt;dev = &amp;dev-&gt;dev; dev_set_drvdata(&amp;dev-&gt;dev, item); // Initializing fb_info struct using kernel framebuffer API info = framebuffer_alloc(sizeof(struct ssd1963), &amp;dev-&gt;dev); if (!info) { ret = -ENOMEM; dev_err(&amp;dev-&gt;dev, "%s: unable to framebuffer_alloc\n", __func__); goto out_item; } item-&gt;info = info; //Here info-&gt;par pointer is commonly used to store private data // In our case, we can use it to store pointer to ssd1963 device info-&gt;par = item; info-&gt;dev = &amp;dev-&gt;dev; info-&gt;fbops = &amp;ssd1963_fbops; info-&gt;flags = FBINFO_FLAG_DEFAULT; info-&gt;fix = ssd1963_fix; info-&gt;var = ssd1963_var; ret = ssd1963_video_alloc(item); if (ret) { dev_err(&amp;dev-&gt;dev, "%s: unable to ssd1963_video_alloc\n", __func__); goto out_info; } info-&gt;screen_base = (char __iomem *)item-&gt;info-&gt;fix.smem_start; ret = ssd1963_pages_alloc(item); if (ret &lt; 0) { dev_err(&amp;dev-&gt;dev, "%s: unable to ssd1963_pages_init\n", __func__); goto out_video; } info-&gt;fbdefio = &amp;ssd1963_defio; fb_deferred_io_init(info); ret = register_framebuffer(info); if (ret &lt; 0) { dev_err(&amp;dev-&gt;dev, "%s: unable to register_frambuffer\n", __func__); goto out_pages; } ssd1963_setup(item); ssd1963_update_all(item); return ret; out_pages: ssd1963_pages_free(item); out_video: ssd1963_video_free(item); out_info: framebuffer_release(info); out_item: kfree(item); out: return ret; }</span></span></code> </pre><br><br>  A few comments on the function.  Here we are consistently: <br>  - Allocate memory for our device <i>ssd1963</i> <br>  - We allocate memory and initialize the fb_info <i>structure</i> , first with default values ‚Äã‚Äã( <i>framebuffer_alloc</i> ), since we don‚Äôt need to change many parameters, and then with specific values ‚Äã‚Äãfor our driver, like <i>fb_var_screeninfo, fb_fix_screeninfo</i> and <i>fb_ops</i> , which we will consider a little later. <br>  - Allocates memory for a continuous buffer of pixels in virtual memory, which will be used to record user-space processes. <br>  - Select the <i>ssd1963_page</i> for each page in the virtual memory of the framebuffer.  Each <i>ssd1963_page</i> will contain the address of the beginning of the page buffer relative to the common FB buffer, the shift in x, the shift in y, and the length of the page buffer.  In our case, the framebuffer capacity = <i>line_length * height = 320 * 4 * 240 = 307200</i> bytes.  For this buffer capacity, we need line_length * height / PAGE_SIZE = 307200/4096 = 75 pages.  Note how they will be located in the memory FB.  Understanding this page layout will come in handy when we look at the ssd1963_copy function a little later: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b6/5a7/ffd/1b65a7ffd5e587bbb8142f9b3bb86025.jpg" width="600" height="300"><br><br>  - We register our FB in the system ( <i>register_framebuffer</i> ) and initialize the pending data update procedure ( <i>fb_deferred_io_init</i> ), more about this in the section ‚Äú <i>Framebuffer</i> Operations‚Äù. <br>  - <i>ssd1963_setup</i> configures the required GPIOs on the AT91SAM9G45 CPU and performs the initial setup of the LCD controller.  The initial configuration algorithm in the form of sending a set of mysterious bytes in hex is taken from the documentation on SSD1963, therefore I will only give here a part of the function: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ssd1963 *item)</span></span></span><span class="hljs-function"> </span></span>{ nhd_init_gpio_regs(); <span class="hljs-comment"><span class="hljs-comment">//initializations of pins in nhd_data-gpio_pin_config at91_set_gpio_output(AT91_PIN_PE27, 0); //RESET udelay(5); at91_set_gpio_output(AT91_PIN_PE27, 1); //RESET udelay(100); nhd_write_data(NHD_COMMAND, 0x01); //Software Reset ... nhd_write_to_register(0xe0, 0x03); //LOCK PLL nhd_write_data(NHD_COMMAND, 0xb0); //SET LCD MODE TFT 18Bits nhd_write_data(NHD_DATA, 0x0c); //SET MODE 24 bits &amp; hsync+Vsync+DEN ‚Ä¶ }</span></span></code> </pre><br><br>  - <i>ssd1963_update_all</i> sets the <i>must_update = 1</i> flag for all pages and initiates the mechanism for updating the display in the deferred context by calling <i>schedule_delayed_work (&amp; item-&gt; info-&gt; deferred_work, fbdefio-&gt; delay);</i> <br><br>  So, you have dealt with init, with the remove function, everything is much simpler, freeing the allocated memory, and returning the FB structure to the kernel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info) { unregister_framebuffer(info); ssd1963_pages_free(item); ssd1963_video_free(item); framebuffer_release(info); kfree(item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <b>Framebuffer operations</b> <br><br>  So, it's time to consider the <i>fb_ops</i> structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_fbops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .fb_read = fb_sys_read, .fb_write = ssd1963_write, .fb_fillrect = ssd1963_fillrect, .fb_copyarea = ssd1963_copyarea, .fb_imageblit = ssd1963_imageblit, .fb_setcolreg = ssd1963_setcolreg, .fb_blank = ssd1963_blank, };</code> </pre><br><br>  I don‚Äôt include all the structure methods here, the curious reader will be able to find them in the source code of the module or in any other driver in the kernel code in the <i>drivers / video</i> directory.  As you may have guessed, the fb_ops structure describes the actions that our driver can perform.  Fortunately, the kernel developers have partially facilitated our work by providing standard functions for working with FB with <i>sys_</i> or <i>fb_sys suffix</i> , for example <i>fb_sys_read</i> .  We only need to add functionality to our implementation of functions from <i>fb_ops</i> ( <i>ssd1963_read, ssd1963_write</i> , etc.) that allows us to update the data in our improvised video memory when the need arises. <br><br>  For example, the <i>ssd1963_fillrect</i> function would look like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_fillrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_fillrect *rect)</span></span></span><span class="hljs-function"> </span></span>{ sys_fillrect(p, rect); ssd1963_touch(p, rect-&gt;dx, rect-&gt;dy, rect-&gt;width, rect-&gt;height); }</code> </pre><br><br>  Obviously, the <i>fb_fillrect</i> system call <i>will</i> update the video data in a specific rectangular area of ‚Äã‚Äãthe screen, so we need to specify which pages we need to refresh by marking them with the <i>must_update</i> flag, and then manually triggering the video memory update procedure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_touch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_deferred_io</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fbdefio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fbdefio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, ystart, yend; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbdefio) { <span class="hljs-comment"><span class="hljs-comment">//Touch the pages, so the deferred io will update them. for (i=0; i&lt;item-&gt;pages_count; i++) { ystart=item-&gt;pages[i].y; yend=item-&gt;pages[i].y+(item-&gt;pages[i].len/info-&gt;fix.line_length)+1; if (!((y+h)&lt;ystart || y&gt;yend)) { item-&gt;pages[i].must_update=1; } } //Schedule the deferred IO to kick in after a delay. schedule_delayed_work(&amp;info-&gt;deferred_work, fbdefio-&gt;delay); } }</span></span></code> </pre><br><br>  Updating data in video memory occurs in the form of a deferred context.  User-space application working with graphics, will not wait for the completion of the recording of each frame in the video memory, which is quite logical.  Deferred processing in <i>fb_info</i> is defined as a <i>fb_deferred_io</i> structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_deferred_io</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963_defio</span></span></span><span class="hljs-class"> = {</span></span> .delay = HZ / <span class="hljs-number"><span class="hljs-number">20</span></span>, .deferred_io = &amp;ssd1963_update, };</code> </pre><br>  <i>Ssd1963_update</i> function with prototype <br>  <i>void ssd1963_update (struct fb_info * info, struct list_head * pagelist);</i> <br>  does not update all pages, but only pages that were modified as a result of user-space being rewritten by the process, or as a result of a system call, such as <i>fb_fillrect</i> and company.  Accordingly, the function has the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *info, struct list_head *pagelist)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssd1963</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; list_for_each_entry(page, pagelist, lru) { item-&gt;pages[page-&gt;index].must_update=<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//Copy changed pages. for (i=0; i&lt;item-&gt;pages_count; i++) { if (item-&gt;pages[i].must_update) { item-&gt;pages[i].must_update=0; ssd1963_copy(item, i); } } }</span></span></code> </pre><br><br>  At this stage, you probably wondered what the <i>ssd1963_copy</i> function <i>does</i> .  It does all the ‚Äúdirty‚Äù work of transferring data from video memory pages to an artificially created, 8-bit GPIO-based bus. <br><br>  <b>Ssd1963_copy function</b> <br><br>  Here it is necessary to recall the figure, which depicts how our pages in memory correspond to the pixels of the display.  We see, for example, that <i>page [0]</i> stores information for the top three lines of the display, 320 pixels each, and 64 pixels for the 4th line.  We have 75 such pages, and the picture from the picture, and as it is not difficult to notice, <i>page [5]</i> will look the same - 3 lines of 320 and one each of 64. Accordingly, the function that takes the page index as a parameter will contain a <i>switch (index% 5)</i> and, depending on the offset for each specific page, send data to the ‚Äúwindow‚Äù allocated to it in the display memory.  The function is quite long, so I will give only its part <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssd1963_copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ssd1963 *item, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> x,y, startx, endx, starty, endy, offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; x = item-&gt;pages[index].x; y = item-&gt;pages[index].y; buffer = item-&gt;pages[index].buffer; len = item-&gt;pages[index].len; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (index%<span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; startx = x; starty = y; endx = <span class="hljs-number"><span class="hljs-number">319</span></span>; endy = y+<span class="hljs-number"><span class="hljs-number">2</span></span>; len = <span class="hljs-number"><span class="hljs-number">960</span></span>; nhd_set_window(startx, endx, starty, endy); nhd_write_data(NHD_COMMAND, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; len; count++) { nhd_write_data(NHD_DATA,(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((buffer[count+offset])&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//red nhd_write_data(NHD_DATA,(unsigned char)((buffer[count+offset])&gt;&gt;8)); //green nhd_write_data(NHD_DATA,(unsigned char)(buffer[count+offset])); //blue } offset = len; startx = x; starty = y+3; endx = x+63; endy = y+3; len = 64; nhd_set_window(startx, endx, starty, endy); nhd_write_data(NHD_COMMAND, 0x2c); for (count = 0; count &lt; len; count++) { nhd_write_data(NHD_DATA,(unsigned char)((buffer[count+offset])&gt;&gt;16)); //red nhd_write_data(NHD_DATA,(unsigned char)((buffer[count+offset])&gt;&gt;8)); //green nhd_write_data(NHD_DATA,(unsigned char)(buffer[count+offset])); //blue } break; case 1: ‚Ä¶.</span></span></code> </pre><br><br>  Here the <i>nhd_set_window</i> function configures using the already known <i>nhd_write_data (NHD_COMMAND, ...);</i>  display area in which data will be written (pixels). <br>  <i>nhd_write_data (NHD_COMMAND, 0x2c);</i>  - the command to the LCD controller that the data flow will now follow. <br><br>  And finally, a screenshot of the ts_calibrate program from the tslib package on the device with the display. <br>  Who is interested - I can send the full code of the module: <br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/b51/b5b/7cbb51b5b70fce6695d46a46889e90a7.jpg"></div><p>Source: <a href="https://habr.com/ru/post/213775/">https://habr.com/ru/post/213775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213765/index.html">Elastic Search in enterprise projects</a></li>
<li><a href="../213767/index.html">The first flash card microSD 128 GB</a></li>
<li><a href="../213769/index.html">10 trends in the mobile gaming market in 2014</a></li>
<li><a href="../213771/index.html">STM32 - correctly use the built-in flash</a></li>
<li><a href="../213773/index.html">VkInviter - inviting assistant administrator of VKontakte groups</a></li>
<li><a href="../213779/index.html">Reverse side of freedom of freelancing</a></li>
<li><a href="../213783/index.html">Hacking accounts through the form and event. "XSS" to avoid confusion with cascading style sheets</a></li>
<li><a href="../213785/index.html">Duplicate code search plugin for QtCreator</a></li>
<li><a href="../213787/index.html">The harsh life of a game tester</a></li>
<li><a href="../213789/index.html">Humidity Controller Atmega328</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>