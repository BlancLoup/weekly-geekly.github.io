<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.1 - OpenGL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. A few weeks ago I started a series of translations of articles on studying OpenGL. But on Article 4, one Khabrovsk commander noted that my tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.1 - OpenGL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  Hello.  A few weeks ago I started a series of translations of articles on studying OpenGL.  But on Article 4, one Khabrovsk commander noted that my translations could violate the license for which the training materials provided in the original article are distributed.  And indeed, my translations violated the license.  To resolve this problem, I turned to the authors of that set of lessons, but I could not get a normal answer.  For this reason, I contacted the author of another, no less (and perhaps even more) steep set of lessons on OpenGL: <a href="http://learnopengl.com/">Joey de Vries</a> .  And he gave full permission to translate his set of lessons.  His lessons are much more extensive than the last set, so these translations will last for a long time.  And I promise it will be interesting.  Interested please under the cat. <br><habracut></habracut><br>  I also got up at a crossroads: either I will describe all the basics like creating a window and context in one article, so as not to produce articles, but in this case, not everyone will master such a huge article;  or I will also, as before, translate based on the hierarchy of the original.  I decided to choose the second option. <br><br>  At the expense of lessons on Vulkan: unfortunately it‚Äôs hard for me to write lessons on this API now because of the scarce video card at the moment, which simply does not support the Vulkan API, so the lessons on this API will be only after updating the video card. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br>  Part 5. Advanced Lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li></ol><br></div></div><br><br><h1>  Part 1.1 - OpenGL </h1><br><br><h2>  Introduction </h2><br>  Before we begin our journey, we should understand what OpenGL is.  Mostly OpenGL is understood as an API (Application Programming Interface), which provides a large set of functions that we can use to manage graphics and images.  But in fact, OpenGL is more of a specification developed and maintained by the <a href="http://www.khronos.org/">Khronos Group</a> . <br><br>  The OpenGL specification describes what the result of each specific function will be and what it should do.  And already the <i>implementation of</i> these specifications lies on the shoulders of developers.  And since the specification does not describe the details of the implementation, various OpenGL implementations, respectively, have the right to exist, at least as long as they meet the specifications. <br><br>  People who develop OpenGL libraries are often video card manufacturers.  Each video card you buy supports specific versions of OpenGL from a set of libraries developed for this series of video cards.  When using the Apple system, OpenGL libraries are supported by Apple; under Linux, there are combinations of versions from suppliers and custom adaptations of these libraries.  It also means that if the version of OpenGL you are using shows a strange behavior, it means, with a high probability, this is a mistake made by video card manufacturers. <br><br><blockquote>  Since most implementations are developed by video card manufacturers, it is necessary to update the video card drivers to fix bugs.  This is one of the reasons why almost all the lessons recommend updating the drivers on a video card. </blockquote><br>  Khronos publicly posted all the specifications for all versions of OpenGL.  An interested reader can find the OpenGL 3.3 specifications (this is the version of OpenGL we will use) <a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf">here</a> .  Specifications perfectly show the rules of all functions. <br><br><h2>  Core-profile and Immediate mode (Instant Mode) </h2><br>  Previously, using OpenGL involved developing in Immediate mode (also known as a fixed function pipeline), which was easy to use for drawing graphics.  Most of the functionality of OpenGL was hidden in libraries and the developers did not have the freedom to understand the calculations made by OpenGL. <br><br>  The developers demanded more flexibility in the development and later the specification became more flexible, and the developers got more control over the process of drawing their graphics.  Immediate mode was easy to use and understand, but it was extremely inefficient.  For this reason, the specification indicated Immediate mode as obsolete, and from version 3.2 began to motivate programmers to use the Core-profile mode, which excluded all outdated functionality. <br><br>  When using core-profile, OpenGL forces us to use modern practices.  When we try to use outdated functions, OpenGL throws an error and stops drawing.  The advantages of using modern practices are flexibility and efficiency, but unfortunately there is a greater difficulty in learning.  Immediate mode is a great abstraction and it hides a large amount of <b>real work</b> done by OpenGL and therefore it was easy to learn, but it‚Äôs hard to figure out how OpenGL actually works.  The modern approach requires the developer to fully understand OpenGL and graphical programming in general, and although it is a bit more complicated, such a scheme allows for greater flexibility and efficiency. <br><br>  This is the reason why our lessons are based on Core-Profile OpenGL version 3.3. <br>  Although it is a bit more complicated, but worth it. <br><br>  Much newer versions of OpenGL have now been released (at the time of writing 4.5) and you may ask: why should we learn OpenGL 3.3 when 4.5 is already released?  The answer is pretty simple.  All older versions of OpenGL, starting from version 3.3, do not add various useful features without changing the basic mechanics.  Newer versions simply provide slightly more efficient or more convenient ways to perform the same operations.  As a result, all concepts and techniques applicable to OpenGL 3.3 can be applied to new versions of OpenGL. <br><br><blockquote>  Using the latest versions of OpenGL has one problem.  Only modern video cards will be able to execute the latest APIs. </blockquote><br><h2>  Extensions </h2><br>  An excellent feature of OpenGL is support for extensions.  At a time when video card manufacturers are introducing new technology or a new extensive optimization for rendering, an extension related to this event appears in the drivers.  If the hardware on which the application is running supports the extension, then the developer can use the functionality provided by this extension for more advanced, or efficient graphics rendering.  Thus, a graphic programmer can use new technologies without waiting for their implementation in new versions of OpenGL, simply by checking the support of the technology with a video card.  Often, if an extension is in high demand, it is implemented as part of the next version of OpenGL. <br><br>  The developer only needs to check the availability of the extension (or use the extension library).  This approach allows the programmer to perform actions more efficiently, based on the extensions he has: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GL_ARB_extension_name) { <span class="hljs-comment"><span class="hljs-comment">//    .    } else { //   :  -. }</span></span></code> </pre> <br>  With OpenGL 3.3, we rarely need extensions, but when needed, the necessary instructions will be provided. <br><br><h2>  State machine </h2><br>  OpenGL is essentially a large finite state machine: a set of variables that defines the behavior of OpenGL.  The state of OpenGL basically means the context of OpenGL.  In the process of using OpenGL, we often change states, set some options, manage buffers, and then draw using the current context. <br><br>  When we tell OpenGL that we want to start drawing, for example, lines, instead of triangles, we change the state of OpenGL by changing the option responsible for how OpenGL should draw.  After changing the state of OpenGL, to drawing lines, all subsequent drawing functions will draw lines instead of triangles. <br><br>  While working with OpenGL, we will go through several state-changing functions that will change the context, and several state-changing functions that perform actions depending on the current state of OpenGL.  As long as you keep in mind the fact that OpenGL is a large state machine, most of the functionality will be clear to you. <br><br><h2>  Objects </h2><br>  OpenGL libraries are written in C and have multiple branches, but this is mainly the C library.  Since most of the constructs from the C language is not translated to high-level languages, OpenGL was developed using a large number of abstractions.  One such abstraction is the system of objects in OpenGL. <br><br>  An object in OpenGL is a set of options that represent a subset of the states of OpenGL.  For example, we can create an object that describes the window drawing configuration;  we can set the size, the number of colors and so on.  Such an object can be represented by a C-like structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_name</span></span></span><span class="hljs-class"> {</span></span> GLfloat option1; GLuint option2; GLchar[] name; };</code> </pre><br><blockquote>  <b>Primitive types</b> <br>  Note that when using OpenGL, it is recommended to use primitives defined by OpenGL.  Instead of using float, write it with added GL.  Same for int, uint char, bool, and so on.  OpenGL defines memory markup for its GL primitives for cross-platform support, since some operating systems may have different markup.  Using OpenGL primitives allows you to achieve full cross-platform of your application. </blockquote><br>  Every time we want to use objects, we basically write it something like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// OpenGL  struct OpenGL_Context { ... object* object_Window_Target; ... };</span></span></code> </pre><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   GLuint objectId = 0; glGenObject(1, &amp;objectId); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     glBindObject(GL_WINDOW_TARGET, objectId); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   GL_WINDOW_TARGET glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800); glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        glBindObject(GL_WINDOW_TARGET, 0);</span></span></code> </pre> <br>  This small piece of code is something you'll often see while working with OpenGL.  In the beginning, we create an object and save a link to it as an identification number (id).  (The real object data is hidden in the implementation).  Then we bind the object to the required part of the context (The location of the window target from the example is given as `GL_WINDOW_TARGET`).  Then we set the values ‚Äã‚Äãof the window options and, in the end, untie the object by setting the id to 0. The values ‚Äã‚Äãset by us continue to be stored in the object that we can access via <i>objectId</i> and restore them to the <i>GL_WINDOW_TARGET</i> object <i>again</i> . <br><blockquote>  This code only shows an example of how OpenGL works.  Later real examples will be presented. </blockquote><br>  The main feature of these objects is that we can declare a lot of objects in our application, set their options and whenever we run operations using the OpenGL state, we can simply bind the object with our preferred settings.  For example, there may be objects with 3D model data or something that we want to draw on this model.  Possession of several objects allows you to simply switch between them in the process of drawing. <br><br><h2>  let's start </h2><br>  Now you know a little about OpenGL both about the specification and about the library.  We learned an approximate algorithm of work and several features used by OpenGL.  Do not be discouraged if something is misunderstood, then we will go through all the stages step by step and you will see enough examples to sort out all the OpenGL intricacies.  If you are ready to start, then we can start creating an OpenGL context and our first window right here. <br><br><h2>  Additional resources </h2><br><ul><li>  <a href="https://www.opengl.org/">opengl.org</a> : the official OpenGL site; </li><li>  <a href="https://www.opengl.org/registry/">OpenGL registry</a> : a repository of OpenGL specifications and all its extensions for all versions of OpenGL. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/310790/">https://habr.com/ru/post/310790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310776/index.html">From physicists to Data Science (From science engines to office plankton). The second part of</a></li>
<li><a href="../310778/index.html">Security Week 38: Firefox vulnerability, Windows hacking via Safe Mode and Tesla via Wifi</a></li>
<li><a href="../310782/index.html">Code Evolution Visualization</a></li>
<li><a href="../310784/index.html">How to develop an application for automation almost not knowing how to program. I'll have to learn IDE ...</a></li>
<li><a href="../310788/index.html">We build our full stack on JavaScript: Client</a></li>
<li><a href="../310792/index.html">Mobile VR development with Oculus and Gear VR</a></li>
<li><a href="../310794/index.html">Data structures for the smallest</a></li>
<li><a href="../310798/index.html">Setting up voice gateways Huawei eSpace IAD on the example of working with Asterisk PBX</a></li>
<li><a href="../310800/index.html">Michael Pryor, Trello: How to build a product for the mass market. Continuation</a></li>
<li><a href="../310802/index.html">Major processing plans to withdraw from the Russian market, possibly due to hacker actions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>