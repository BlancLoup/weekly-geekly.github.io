<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>typeof Everything and duck misunderstandings</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone who uses wonderful JavaScript for whatever purpose, wondered: why does typeof null mean ‚Äúobject‚Äù ? typeof from the function returns "function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>typeof Everything and duck misunderstandings</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/w2/mj/_p/w2mj_pc_kr_unyrw31d2f27xdra.jpeg" alt="image"></p><br><p>  Everyone who uses wonderful <strong>JavaScript</strong> for whatever purpose, wondered: why does <em>typeof null</em> mean <em>‚Äúobject‚Äù</em> ?  <em>typeof</em> from the function returns <em>"function"</em> , but from <em>Array</em> - <em>"object"</em> ?  and where is <em>getClass</em> in your praised classes?  And although most of them are easily and naturally answered by a <a href="https://www.ecma-international.org/ecma-262/5.1/">specification</a> or <a href="http://2ality.com/2013/10/typeof-null.html">historical facts</a> , I would like to draw a little line ... more for myself. </p><br><p>  If, reader, in your tasks too <em>typeof</em> and <em>instanceof</em> are not enough, and you want some specifics, not <em>"objects"</em> , then it may be useful.  Oh yeah, about the ducks: they will be too, just a little wrong. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-voprosa">  Brief Background </h2><br><p>  To reliably get the type of a variable in JavaScript has always been a non-trivial task, certainly not for a beginner.  In most cases, it is of course not required, simply: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// awesome code around the object }</span></span></code> </pre> <br><p>  and now you don‚Äôt catch <code>Cannot read property of null</code> - a local analogue of NPE.  Familiar? </p><br><p>  And then we began to increasingly use functions as constructors, and sometimes it is useful to inspect the type of object created in this way.  But just using <em>typeof</em> from the instance does not work, since we correctly get the <em>"object"</em> . </p><br><p>  Then it was still normal to use the prototype OOP model in JavaScript, remember?  We have some object, and through a link to its prototype we can find the <em>constructor</em> property that points to the function with which the object was created.  And then a bit of magic with <em>toString</em> from the function and regular expressions and here it is the result: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Sometimes such interviews were asked, but why? </p><br><p>  Yes, we could just save the prototype with a special property of the string representation of the type and receive it from the object via the prototype chain: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; Type.prototype.typeName = <span class="hljs-string"><span class="hljs-string">'Type'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type; o.typeName; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Type</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Only two times you have to write <em>"Type"</em> : in the function declaration and in the property. </p><br><p>  For the built-in objects (like <em>Array</em> or <em>Date</em> ), we had the <a href="https://learn.javascript.ru/class-instanceof">secret property</a> <em>[[Class]]</em> , which could be hooked through <em>toString</em> from the standard <em>Object</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">object</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Array</span></span></span></span><span class="xml"><span class="hljs-tag">]"</span></span></span></span></code> </pre> <br><p>  Now we have classes, and the custom types have finally become entrenched in the language: this is no longer any LiveScript for you;  we write supported code in large quantities! </p><br><p>  Around the same time, <em>Symbol.toStringTag</em> and <em>Function.name appeared</em> , with which we can take our <em>typeof</em> in a new way. </p><br><p>  In general, before we proceed further, I want to note that the issue under consideration evolves on StackOverflow along with the language and rises from the editorial board to the editorial board: <a href="https://stackoverflow.com/questions/332422/get-the-name-of-an-objects-type">9 years ago</a> , <a href="https://stackoverflow.com/questions/4456336/finding-variable-type-in-javascript">7 years ago</a> , <a href="https://stackoverflow.com/questions/24403732/check-if-array-is-empty-does-not-exist-js">not so long ago,</a> or <a href="https://stackoverflow.com/questions/4059147/check-if-a-variable-is-a-string-in-javascript">this</a> and <a href="https://stackoverflow.com/questions/38160195/class-property-in-es2015">this</a> . </p><br><h2 id="tekuschee-polozhenie-del">  Current state of affairs </h2><br><p>  We <a href="https://habr.com/post/414495/">have already examined</a> <em>Symbol.toStringTag</em> and <em>Function.name</em> in sufficient detail.  In short, the internal symbol <em>toStringTag</em> is a modern <em>[[Class]]</em> , only we can redefine it for our objects.  And the <em>Function.name</em> property is the same <em>typeName</em> from the example institutionalized in almost all browsers: returns the name of the function. </p><br><p>  Without hesitation, you can define this function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; any !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor === <span class="hljs-string"><span class="hljs-string">'function'</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor.name === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any.constructor.name; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(any).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><ol><li>  If a variable is an object, then: <br>  1.1.  If the object is overridden <em>toStringTag</em> , then return it; <br>  1.2.  If the object has a <em>constructor</em> function and the function has a <em>name</em> property, then return it; </li><li>  Finally, use the <em>toString</em> method of the <em>Object object</em> , which will do <a href="https://www.ecma-international.org/ecma-262/8.0/index.html">all the polymorphic work</a> for absolutely any other variable for us. </li></ol><br><p>  Object with <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> kitten = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]: <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span> }; getTag(kitten); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Class with <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span>; } } getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Using <em>constructor.name</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{} getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Dog</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  ‚Üí More examples can be found in <a href="https://github.com/cerberus-ab/jsobj-analyzer">this repository.</a> </p><br><p>  Thus, it is now quite simple to determine the type of any variable in JavaScript.  This function allows you to uniformly check variables for type and use a simple <em>switch expression</em> instead of <a href="https://learn.javascript.ru/class-instanceof">duck checks</a> in polymorphic functions.  I have never liked the approach based on duck typing that if something has a <em>splice</em> property, is it an array or something? </p><br><h2 id="kakie-to-nepravilnye-utki">  Some wrong ducks </h2><br><p>  Understanding the type of a variable according to the presence of certain methods or properties is of course a matter for everyone and depends on the situation.  But I will take this <em>getTag</em> and inspect some things of the language. </p><br><h3 id="klassy">  Classes? </h3><br><p>  My favorite duck in javascript are classes.  The guys who started writing in JavaScript with ES-2015 happen to be unaware that these classes are.  And the truth is: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'John'</span></span>); user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  We have the keyword <em>class</em> , constructor, some methods, even <em>extends</em> .  We also create an instance of this class through <em>new</em> .  It looks like a class in its usual sense - it means a class! </p><br><p>  However, when you start adding new methods in <em>real-time</em> to the "class", and at the same time they become immediately accessible to the already created instances, some are lost: </p><br><pre> <code class="javascript hljs">Person.prototype.hello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Is not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">not</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  <strong>Don't do that!</strong> </p><br><p>  And not some reliably know that this is just syntactic sugar over the prototype model, because conceptually nothing has changed in the language.  If you call <em>getTag</em> from <em>Person</em> , you get <em>"Function"</em> , rather than the fictitious <em>"Class"</em> , and this is worth remembering. </p><br><h3 id="drugie-funkcii">  Other features </h3><br><p>  There are several ways to declare a function in JavaScript: <em>FunctionDeclaration</em> , <em>FunctionExpression,</em> and recently <em>ArrowFunction</em> .  We all know when and what to use: things are quite different.  Moreover, if you call <em>getTag</em> from a function declared by any of the proposed options, we get <em>"Function"</em> . </p><br><p>  In fact, there are more ways in a language to define a function.  Add to the list at least the considered <em>ClassDeclaration</em> , then asynchronous functions and generators, etc.: <em>AsyncFunctionDeclaration</em> , <em>AsyncFunctionExpression</em> , <em>AsyncArrowFunction</em> , <em>GeneratorDeclaration</em> , <em>GeneratorExpression</em> , <em>ClassExpression</em> , <em>MethodDefinition</em> (the list is not complete).  And it seems they say so and what?  All of the above behaves as a function - it means that <em>getTag</em> will also return <em>"Function"</em> .  But there is one feature: all options are certainly functions, but not all directly - <em>Function</em> . </p><br><p>  There are <a href="https://www.ecma-international.org/ecma-262/8.0/index.html">built-in</a> <em>Function</em> <a href="https://www.ecma-international.org/ecma-262/8.0/index.html">subtypes</a> : </p><br><blockquote>  The function constructor is designed to be subclassable. <br>  Except for the built-in subclasses and subclasses. </blockquote><p>  We have a <em>Function</em> and within it are the <em>GeneratorFunction</em> and <em>AsyncFunction</em> inherited from it with its constructors.  This emphasizes that asinks and generators have their own unique nature.  And as a result: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(resolve, ms)); } getTag(sleep); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">AsyncFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  At the same time, we cannot instantiate such a function through the <em>new</em> operator, and its call returns us a <em>Promise</em> : </p><br><pre> <code class="javascript hljs">getTag(sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Promise</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Example with generator function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i += <span class="hljs-number"><span class="hljs-number">1</span></span>; } getTag(incg); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">GeneratorFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Calling such a function returns an instance to us ‚Äî the <em>Generator</em> object: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inc = incg(<span class="hljs-number"><span class="hljs-number">0</span></span>); getTag(inc); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Generator</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  The <em>toStringTag</em> symbol is rightly redefined for asinks and generators.  But <em>typeof</em> for any function will show <em>"function"</em> . </p><br><h3 id="vstroennye-obekty">  Embedded objects </h3><br><p>  We have things like <em>Set</em> , <em>Map</em> , <em>Date,</em> or <em>Error</em> .  Applying <em>getTag</em> to them will return <em>"Function"</em> , because these are the functions ‚Äî the constructors of iterable collections, dates, and errors.  From the instances we get, respectively - <em>"Set"</em> , <em>"Map"</em> , <em>"Date"</em> and " <em>Error</em> ". </p><br><p>  But watch out!  there are still objects like <em>JSON</em> or <em>Math</em> .  If you hurry, you can assume a similar situation.  But no!  this is completely different - embedded single objects.  They are not instantiable ( <code>is not a constructor</code> ).  Calling <em>typeof</em> will return <em>"object"</em> (who would doubt).  But <em>getTag</em> will refer to <em>toStringTag</em> and get <em>"JSON"</em> and <em>"Math"</em> .  This is the last observation that I want to share. </p><br><h2 id="davayte-bez-fanatizma">  Let's go without fanaticism </h2><br><p>  I was a little deeper than the usual question about the type of a variable in JavaScript quite recently, when I decided to write my own <a href="https://github.com/cerberus-ab/jsobj-analyzer">simple object inspector</a> for dynamic code analysis (indulge).  The material does not just publish in <em>Abnormal programming</em> , since you do not need it in production: there is <em>typeof</em> , <em>instanceof</em> , <em>Array.isArray</em> , <em>isNaN</em> and everything else that is worth remembering when performing the necessary checks.  In most projects, it does TypeScript, Dart or Flow.  I just like <strong>javascript</strong> ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427253/">https://habr.com/ru/post/427253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427243/index.html">See the Light: Our Call for Standardization of the Protocol for Messaging between Robo Mobiles</a></li>
<li><a href="../427245/index.html">Group voice mail and call recording management in 3CX PBX</a></li>
<li><a href="../427247/index.html">Web App with IoC Starter. Basic request mapping using ioc context, ioc web and ioc orm</a></li>
<li><a href="../427249/index.html">By the structure of the material of the printed item, you can determine the model of the 3D printer and the specific device.</a></li>
<li><a href="../427251/index.html">The US Department of Homeland Security seized reconstituted Apple laptop batteries, calling them fake</a></li>
<li><a href="../427255/index.html">Cowon D2: musical long-liver</a></li>
<li><a href="../427257/index.html">Cameron Craig: Seven Lessons Learned in 10 Years of Managing Apple's PR Department</a></li>
<li><a href="../427259/index.html">What the Turing Test actually tests</a></li>
<li><a href="../427263/index.html">Be a security ninja: webinar recording and bonus level</a></li>
<li><a href="../427265/index.html">Protobuffers are wrong</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>