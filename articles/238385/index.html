<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>XNA 3D: an introduction to custom shader and a little bit of a prototype</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrahabr! Unfortunately, for a long time did not write on Habr. Personal affairs were completely opposed to sit down and write a couple of articl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>XNA 3D: an introduction to custom shader and a little bit of a prototype</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c03/d85/f19/c03d85f19fb34ea498f6748a590cf0f7.png"><br><br>  Hi, Habrahabr!  Unfortunately, for a long time did not write on Habr.  Personal affairs were completely opposed to sit down and write a couple of articles on game development.  Maybe it is for the better. During these two years I have gained a lot of experience and are always happy to share it.  It is worth noting that I completely refused to create 2D games: I do not mind them, but developing games in 3D is much more interesting and fun!  Traditionally, <b>XNA 4.0</b> will be used as a tool, why is <b>XNA 4.0 a</b> dear listener?  And all because, he still remains relevant for indie developers.  We have a language with a very low entry - C #.  There is the same <b>XNA</b> framework with the necessary initial classes / structures and algorithms.  And there is <b>DirectX</b> with shader support, right up to <b>Shader Model 3.0</b> .  If you, <i>%% username</i> , read me for the first time, you can read my articles dated 2012 as well.  Not to say that they are 100% relevant, that there are no errors in them, but they can give a certain base.  As it is probably understandable, I will only write about <b>3D</b> : I did not fully define the list of topics, but I think that I will form them pretty quickly. <br><br>  So far, exactly conceived two articles: <br><ul><li>  ‚ÄúXNA 3D: an introduction to <b>custom shader</b> and a little bit of a prototype‚Äù </li><li>  ‚ÄúXNA 3D: <b>HDR</b> vs <b>LDR</b> , the implementation of <b>HDR</b> " </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now I‚Äôll give an introduction to the <b>custom shader</b> and implement a simple prototype of the <b>FEZ</b> game. <br><a name="habracut"></a><br><br><h4>  Introduction </h4><br>  When we worked with <b>2D</b> - we <a href="http://habrahabr.ru/post/128286/">didn't bother with</a> any matrices, we just gave our textures and their position to the local <b>SpriteBatch</b> , and he drew them to us.  But I want to say: that everything that he draws is <b>3D</b> : only one of the coordinates is zero (in the <b>XNA</b> , the <b>Z</b> coordinate), well, a special projection is used (about them later).  Projection - transfer of coordinates from 3D space to 2D screen space.  Also, one of the overloads of the <b>SpriteBatch</b> method supports a parameter in the form of a matrix: through it we made the camera.  And now we give analogies with <b>3D</b> .  Those coordinates that we passed to <b>SpriteBatch</b> as the position of the texture (as well as its rotation and size) - this is called the <i><b>world transformation</b></i> (as well as the world matrix).  That matrix parameter in <b>SpriteBatch.Begin</b> is the <b><i>view matrix</i></b> .  And a special projection matrix, which we cannot change in <b>SpriteBatch</b> .  And now once again from a different angle: any model consists of points - called <b>vertices</b> , the whole position (transformation) of these vertices is a local coordinate system.  Next, we need to make them global, thanks to this - we can use the same model and draw it in different places with different rotation / size.  After that, we have to shift this transformation to the camera.  And after we calculated the final transformations, we project them from 3D space to screen 2D. <br><br><h4>  Graphic device: shader and models </h4><br>  I covered the topic of <a href="http://habrahabr.ru/post/134819/">shaders</a> in past articles and how post-image processing is done using them.  We used only pixel shaders.  In fact, everything is more complicated.  In addition to pixel shaders, there are vertex ones (I consider the situation before <b>SM3.0</b> inclusive).  These shaders operate on vertices, not pixels.  Those.  performed for each vertex.  Here we have the magic of transformation.  Let's try to create a new <b>.fx</b> file in <b>XNA</b> and analyze it: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float4x4</span></span> World; <span class="hljs-attribute"><span class="hljs-attribute">float4x4</span></span> View; <span class="hljs-attribute"><span class="hljs-attribute">float4x4</span></span> Projection;</code> </pre> <br><br>  The first three lines are just our matrices.  All these values ‚Äã‚Äãare taken from the so-called <i>constant buffer</i> (about the buffers a little later).  Next comes the implementation of the input-output structures: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexShaderInput</span></span></span><span class="hljs-class"> </span></span>{ float4 <span class="hljs-type"><span class="hljs-type">Position</span></span> : <span class="hljs-type"><span class="hljs-type">POSITION0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexShaderOutput</span></span></span><span class="hljs-class"> </span></span>{ float4 <span class="hljs-type"><span class="hljs-type">Position</span></span> : <span class="hljs-type"><span class="hljs-type">POSITION0</span></span>; };</code> </pre><br><br>  This is the simplest implementation of the vertex shader's input-output: we get the vertex position on the <b>POSITION0</b> channel and, as output data, provide information for the next part of the graphics pipeline (already transformed data) - the <i>rasterizer</i> . <br>  Well, the last part of the <b>.fx</b> file is the shaders themselves: <br><br><pre> <code class="hljs pgsql">VertexShaderOutput VertexShaderFunction(VertexShaderInput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { VertexShaderOutput output; <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = mul(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.Position, World); <span class="hljs-type"><span class="hljs-type">float4</span></span> viewPosition = mul(worldPosition, <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>); output.Position = mul(viewPosition, Projection); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; } <span class="hljs-type"><span class="hljs-type">float4</span></span> PixelShaderFunction(VertexShaderOutput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) : COLOR0 { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>  The vertex shader gets the position of the vertex in the ‚Äúmodel‚Äù space, then leads to the global, specific and ultimately to the screen.  Well, the pixel shader fills everything with red. <br><br><h4>  A little bit about matrices </h4><br>  I will not go into the details of these matrices (there is a lot of such information: because it is quite common): I will just say how this is in <b>XNA</b> . <br><br>  <b>The world</b> matrix is ‚Äã‚Äãdefined by the <b>Scale Rotation Translation</b> view: <br><br><pre> <code class="hljs markdown">Matrix world = Matrix.CreateScale(x, y, z) <span class="hljs-bullet"><span class="hljs-bullet">* Matrix.CreateFromYawPitchRoll(y, p, r) *</span></span> Matrix.CreateTranslation(x, y, z);</code> </pre> <br><br>  Multiplication of matrices is noncommutative, so order is important here. <br>  <b>View</b> matrix (camera matrix): <br><br><pre> <code class="hljs pgsql">Matrix <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> = Matrix.CreateLookAt(vpos, targetpos, up);</code> </pre> <br><br>  Generally speaking, you can use the <b>SRT</b> matrix, but in <b>XNA</b> there is a convenient tool to make it easier. <br>  <i>Vpos</i> is the camera position, <i>targetpos</i> is the point where the camera is looking, and <i>up</i> is the upward vector (usually <i>Vector3.Up</i> ). <br><br>  Well, the last and most important thing is the projection matrix.  In the most standard case, there are two of them: <i>orthographic</i> projection and <i>perspective</i> .  Looking ahead, orthographic is used for 2D (and to some extent for isometric), and promising in other cases (for example, 3D shooters). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2f/e66/a94/d2fe66a9406192add1cbf6f6d5e2a38c.png" alt="image"></div><br><br>  Our eye is designed in such a way that we perceive all objects in a perspective projection, i.e.  the more distant the object, the less it seems to us.  The orthogonal projection at first glance looks strange, because the size of the object does not depend on the distance to it.  It is like if we viewed the scene from an infinitely long distance.  That is why it is used for 2D games, because  we do not need to consider the distance to a specific polygon. <br><br><h4>  Model view </h4><br>  When loading a model from a hard disk, we load (in the simplest case) the following information: <br><br>  <b>POSITION</b> - vertex position. <br>  <b>NORMAL</b> is the vertex normal. <br>  <b>TEXCOORD</b> - texture coordinate (UV-scan). <br><br>  This information is called vertex <i>channels</i> (as with the Red channel analogy of an RGB space). <br><br>  And also, we load the special information which is called as <b>indexes</b> .  Now let's try to make it out. <br><br>  We need to draw a square, the square consists of four points.  The graphics device operates <u>with</u> triangles <u>only</u> .  Any shape can be divided into triangles.  And now, if you describe this square for a graphic device, you will need <b>6</b> vertices ( <b>3</b> for each triangle).  But I want to replace that some vertices (or rather their positions) will be equal in this case.  For this, a special <b>index buffer</b> was invented.  Imagine that we have 4 support vertexes that describe a square: <i>v1, v2, v3, v4</i> .  And now you can build an <i>index buffer</i> : <i>[0, 1, 2, 1, 2, 3]</i> - the graphic device for these indices will find and use vertices from the vertex buffer: <i>[v1, v2, v3, v2, v3, v4]</i> .  This approach is very convenient, because  greatly reduces the volume of the <i>vertex buffer</i> , as well as expands the functionality for drawing.  For example, you can set a large vertex buffer (an extremely slow operation), and then draw certain parts of the model ‚Äî changing only the index buffer (a fast operation compared to installing a vertex buffer). <br>  <b>XNA</b> has the following classes: <b>VertexBuffer</b> and <b>IndexBuffer</b> .  We will not consider creating them directly in the code, and for this we will use the loading of a simple model. <br><br>  Create a simple model and save it in FBX format: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/768/193/60d/76819360d0f24186bc70a915da6f76bd.png"></div><br><br>  After that - we can extract the already created <i>VertexBuffer</i> and <i>IndexBuffer</i> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">_vertexBuffer</span></span> = boxModel.Meshes[<span class="hljs-number"><span class="hljs-number">0</span></span>].MeshParts[<span class="hljs-number"><span class="hljs-number">0</span></span>].VertexBuffer; <span class="hljs-attribute"><span class="hljs-attribute">_indexBuffer</span></span> = boxModel.Meshes[<span class="hljs-number"><span class="hljs-number">0</span></span>].MeshParts[<span class="hljs-number"><span class="hljs-number">0</span></span>].IndexBuffer;</code> </pre> <br><br>  <i><b>Attention!</b></i>  <i><b>This case is only suitable for the simplest model with one untransformed mesh.</b></i>  <i><b>A complex model may have several vertex / index buffers.</b></i>  <i><b>Also, parts of a model can have their own transformation in model space.</b></i> <br><br><h4>  Implementation </h4><br>  Now everything is ready and let's make some prototype.  There is such a great indie game - <b>FEZ</b> .  Many of my friends asked how such a gameplay is possible in terms of implementation?  In fact, there is nothing abstruse, just use the orthogonal (orthographic) projection (and the information about the world is contained in the 3D view, in contrast to the classic 2D game) with the ability to rotate the world. <br><br>  A little description of the gameplay with Wikipedia: <br>  <i>Fez is presented in the form of a 2D platformer in which Gomez can walk, jump, climb and manipulate objects.</i>  <i>Nevertheless, the player can at any time shift perspectives, rotating the world 90 degrees relative to the screen.</i>  <i>This allows you to detect doors and aisles, and also causes the platform to rebuild.</i>  <i>Since the volume is not typical 2D-games, the player can (and must) use this mechanics to perform actions that are usually impossible in this 3D-world.</i>  <i>For example, standing on a moving platform and shifting perspective by 90 degrees, Gomez can move to another platform that was previously on the opposite side of the screen.</i>  <i>Returning to the original perspective after moving, it turns out that Gomez has moved a long distance.</i> <i><br></i> <br><br>  And the video of the gameplay itself: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/irjf1mOQXbE%3Ffeature%3Doembed&amp;xid=25657,15700022,15700043,15700186,15700191,15700253&amp;usg=ALkJrhgjDgx8CnloxyZ5ewGRglEIT-QV_w" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Let's start! </h5><br>  Load the base geometry: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Model</span></span> boxModel = Content.Load&lt;Model&gt;(<span class="hljs-string"><span class="hljs-string">"simple_cube"</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">_vertexBuffer</span></span> = boxModel.Meshes[<span class="hljs-number"><span class="hljs-number">0</span></span>].MeshParts[<span class="hljs-number"><span class="hljs-number">0</span></span>].VertexBuffer; <span class="hljs-attribute"><span class="hljs-attribute">_indexBuffer</span></span> = boxModel.Meshes[<span class="hljs-number"><span class="hljs-number">0</span></span>].MeshParts[<span class="hljs-number"><span class="hljs-number">0</span></span>].IndexBuffer;</code> </pre><br><br>  Load two simple 16x16 textures: <br><br><pre> <code class="cs hljs">_simpleTexture1 = Content.Load&lt;Texture2D&gt;(<span class="hljs-string"><span class="hljs-string">"simple_texture1"</span></span>); _simpleTexture2 = Content.Load&lt;Texture2D&gt;(<span class="hljs-string"><span class="hljs-string">"simple_texture2"</span></span>);</code> </pre><br><br>  And load the previously created shader (effect) (.fx): <br><br><pre> <code class="cs hljs">_effect = Content.Load&lt;Effect&gt;(<span class="hljs-string"><span class="hljs-string">"simple_effect"</span></span>);</code> </pre><br><br>  The whole thing we do in the method: <b>LoadContent</b> . <br><br>  And now let's try to draw our model ( <b>Draw</b> method): <br><br><div class="spoiler">  <b class="spoiler_title">Simple rendering</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//   GraphicsDevice.SetVertexBuffer(_vertexBuffer); GraphicsDevice.Indices = _indexBuffer; //   Matrix <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> = Matrix.CreateLookAt(Vector3.One * <span class="hljs-number"><span class="hljs-number">2</span></span>f, Vector3.Zero, Vector3.Up); Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(<span class="hljs-number"><span class="hljs-number">45</span></span>f), GraphicsDevice.Viewport.AspectRatio, <span class="hljs-number"><span class="hljs-number">0.01</span></span>f, <span class="hljs-number"><span class="hljs-number">100</span></span>f); <span class="hljs-type"><span class="hljs-type">float</span></span> dt = (<span class="hljs-type"><span class="hljs-type">float</span></span>)gameTime.TotalGameTime.TotalSeconds; Matrix world = Matrix.CreateFromYawPitchRoll(dt, dt, dt); //     _effect.Parameters["View"].SetValue(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); _effect.Parameters["Projection"].SetValue(projection); _effect.Parameters["World"].SetValue(world); //    _effect.CurrentTechnique.Passes[<span class="hljs-number"><span class="hljs-number">0</span></span>].Apply(); //   GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _vertexBuffer.VertexCount, <span class="hljs-number"><span class="hljs-number">0</span></span>, _indexBuffer.IndexCount / <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre></div></div><br><br>  <b>Attention!</b>  <b>Such a case is only suitable for the simplest shader with one pass.</b>  <b>A complex shader can have several passes.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/020/2e1/69c/0202e169c07f492bbdea4ca75c732e70.png"></div><br><br>  Here we used a perspective projection with a viewing angle of 45 degrees.  Everything is working.  Now, we need to set the texture of our model.  When saving a model from <b>Cinema 4D</b> to <b>FBX</b> format, the following channels were available: <b>POSITION</b> , <b>NORMAL</b> , <b>TEXCOORD</b> (UV).  Let's return to our shader and add one of the channels to the input / output data: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> VertexShaderInput { float4 Position : POSITION0; float2 UV : TEXCOORD0; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> VertexShaderOutput { float4 Position : POSITION0; float2 UV : TEXCOORD0; };</code> </pre><br><br>  These will be our texture coordinates.  The texture coordinate links the vertex to a position on a two-dimensional texture. <br>  And in the vertex shader, pass without changes: <br><br><pre> <code class="cs hljs">output.UV = input.UV;</code> </pre><br><br>  After the rasterization stage, we get the <b>TEXCOORD0</b> values ‚Äã‚Äãinterpolated (in a triangle) and we can get the texture color values ‚Äã‚Äãin the pixel shader: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelShaderFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VertexShaderOutput input</span></span></span><span class="hljs-function">) : COLOR0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(TextureSampler, input.UV); }</code> </pre><br><br>  But in order to get the color values ‚Äã‚Äãof the texture on UV - you need to set this very texture.  To do this, there are <b>samplers</b> that, in addition to the texture itself, contain information about what to do if, on a rasterized triangle, the texture on the screen turned out to be too large or small. <br><br>  Since  we set the parameters explicitly in the shader, keep the tradition and create a sampler in the shader: <br><br><pre> <code class="cs hljs">texture Texture; sampler2D TextureSampler = sampler_state { Texture = &lt;Texture&gt;; };</code> </pre><br><br>  Well, let's set the texture as a parameter: <br><pre> <code class="cs hljs">_effect.Parameters[<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>].SetValue(_simpleTexture1);</code> </pre><br><br>  We see: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2fb/a38/2ff/2fba382ff22a4e88afc8e8c5c1136661.png"></div><br><br>  But since  the texture on the screen turned out to be more than <b>16x16</b> - it was interpolated according to the settings of the sampler.  This is not what we need, so let's change the filtering in the sampler: <br><br><pre> <code class="cs hljs">texture Texture; sampler2D TextureSampler = sampler_state { Texture = &lt;Texture&gt;; MipFilter = POINT; MinFilter = POINT; MagFilter = POINT; };</code> </pre><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/baa/0ba/734/baa0ba734f714c5589d7d875b1a82bfb.png"></div><br><br>  By the way, I talked about filtering in articles <a href="http://habrahabr.ru/post/128286/">earlier</a> . <br><br>  Now everything is set up and it's time to combine our 2D and 3D.  We introduce the <b>Block</b> class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Block</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlockType { First, Second } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix Transform; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BlockType Type; }</code> </pre><br><br>  Where <b>Transform</b> is our world matrix for an object. <br><br>  And a simple generation of these blocks: <br><br><div class="spoiler">  <b class="spoiler_title">Block generation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _createPyramid(Vector3 basePosition, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> basesize, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> baseheight, Block.BlockType type) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; h &lt; baseheight; h++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = basesize - h * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; size; j++) { Block block = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Block(); Vector3 position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( -(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)size / <span class="hljs-number"><span class="hljs-number">2f</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)i, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)h, -(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)size / <span class="hljs-number"><span class="hljs-number">2f</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)j) + basePosition; block.Transform = Matrix.CreateTranslation(position); block.Type = type; _blocks.Add(block); } } }</code> </pre></div></div><br><br>  Well, the ability to draw a lot of models with different transformations: <br><br><div class="spoiler">  <b class="spoiler_title">Rendering</b> <div class="spoiler_text"><pre> <code class="cs hljs">GraphicsDevice.SetVertexBuffer(_vertexBuffer); GraphicsDevice.Indices = _indexBuffer; Matrix view = Matrix.CreateLookAt(Vector3.One * <span class="hljs-number"><span class="hljs-number">10f</span></span>, Vector3.Zero, Vector3.Up); Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(<span class="hljs-number"><span class="hljs-number">45f</span></span>), GraphicsDevice.Viewport.AspectRatio, <span class="hljs-number"><span class="hljs-number">0.01f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>); _effect.Parameters[<span class="hljs-string"><span class="hljs-string">"View"</span></span>].SetValue(view); _effect.Parameters[<span class="hljs-string"><span class="hljs-string">"Projection"</span></span>].SetValue(projection); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Block block <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _blocks) { Matrix world = block.Transform; _effect.Parameters[<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>].SetValue(_simpleTexture1); _effect.Parameters[<span class="hljs-string"><span class="hljs-string">"World"</span></span>].SetValue(world); _effect.CurrentTechnique.Passes[<span class="hljs-number"><span class="hljs-number">0</span></span>].Apply(); GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _vertexBuffer.VertexCount, <span class="hljs-number"><span class="hljs-number">0</span></span>, _indexBuffer.IndexCount / <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre></div></div><br><br>  And the last stage - create our world: <br><br><pre> <code class="cs hljs">_createPyramid(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-7f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.5f</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, Block.BlockType.First); _createPyramid(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">7f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, Block.BlockType.Second); _createPyramid(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">7f</span></span>, <span class="hljs-number"><span class="hljs-number">-7f</span></span>, <span class="hljs-number"><span class="hljs-number">7f</span></span>), <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, Block.BlockType.First);</code> </pre><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8a9/f09/162/8a9f09162cc9417e9a534fce708d96fd.png"></div><br><br>  It remains the most important thing, the creation of the desired projection and the ability to rotate our world. <br><br>  We will set the projection as follows: <br><br><pre> <code class="cs hljs">Matrix projection = Matrix.CreateOrthographic(<span class="hljs-number"><span class="hljs-number">20f</span></span> * GraphicsDevice.Viewport.AspectRatio, <span class="hljs-number"><span class="hljs-number">20f</span></span>, <span class="hljs-number"><span class="hljs-number">-100f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre><br><br>  Where <i>20f</i> - a kind of ‚Äúzoom‚Äù.  A <i>-100f</i> and <i>100f</i> near and far edge of clipping. <br><br>  And species: <br><br><pre> <code class="cs hljs">Matrix view = Matrix.CreateRotationY(MathHelper.PiOver2 * _rotation);</code> </pre><br><br>  Where <i>_rotation</i> is rotation.  For ‚Äúsoft‚Äù rotation, you can use the <b>MathHelper.SmoothStep</b> function, which is nothing more than a <b>cubic lerp</b> . <br><br>  For rotation, we introduce four variables: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* ROTATION */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _rotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _rotationTo; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _rotationFrom; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _rotationDelta;</code> </pre><br><br>  And update our <b>Update</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Rotation control</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyboardState.IsKeyDown(Keys.Left) &amp;&amp; _prevKeyboardState.IsKeyUp(Keys.Left) &amp;&amp; _rotationDelta &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { _rotationFrom = _rotation; _rotationTo = _rotation - <span class="hljs-number"><span class="hljs-number">1f</span></span>; _rotationDelta = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyboardState.IsKeyDown(Keys.Right) &amp;&amp; _prevKeyboardState.IsKeyUp(Keys.Right) &amp;&amp; _rotationDelta &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { _rotationFrom = _rotation; _rotationTo = _rotation + <span class="hljs-number"><span class="hljs-number">1f</span></span>; _rotationDelta = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_rotationDelta &lt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { _rotationDelta += (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)gameTime.ElapsedGameTime.TotalSeconds * <span class="hljs-number"><span class="hljs-number">2f</span></span>; _rotation = MathHelper.SmoothStep(_rotationFrom, _rotationTo, _rotationDelta); }</code> </pre></div></div><br><br>  I‚Äôll draw your attention to the fact that <b>gameTime.ElapsedGameTime is</b> used <b>here</b> : in moments when changes in a variable in a game occur gradually, you need to take this value into account, because  FPS <u>can be different for everyone</u> . <br><br>  And finally, a few words about the implementation of the world.  You can generate a world (physical) for each rotation when loading a level and rotating it to check whether the player is able to go to the desired level from the current position and what position he will go to. <br><br><h4>  Comment on the prototype </h4><br>  Of course, there are a lot of problems in this prototype: for example, faces that we will never see (if I wrote about the dynamic construction of geometry, then the article would have grown many times).  In addition, the whole thing - you can implement without a <b>custom shader</b> , using <b>BasicEffect</b> .  But for future articles it is important to understand how to make a <b>custom shader</b> <u>without</u> binding to the model. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/WdGlDX7J0r0%3Ffeature%3Doembed&amp;xid=25657,15700022,15700043,15700186,15700191,15700253&amp;usg=ALkJrhjNmVqy8__t2tgGyCQoUj3WZyXuZA" frameborder="0" allowfullscreen=""></iframe><br><br>  Source code + binary: <a href="">here</a> <br><br><h4>  Conclusion </h4><br>  In this article, I made some introduction and showed a prototype of the famous game, where no perspective is used as a projection.  After this introduction, I plan to explain some of the game development chips in three dimensions, I will try to introduce in some detail the shaders (both pixel and vertex).  Also introduce some techniques, such as <b>HDR</b> , <b>Deferred Rendering</b> (I used to do this for 2D, but that method is more likely modified with Forward rendering than with Deferred-technique), <b>VTF</b> .  Well, since I publish exclusively on habrahabr, I always welcome comments and suggestions: if you don‚Äôt know how something works in a game (especially AAA class games are welcome), or you are interested in the implementation of a particular effect, then <u>Feel free to write a comment</u> .  I will try to tell about it as much as possible. <br><br>  <i>PS The best motivation for me is your interest.</i> <i><br></i>  <i>PSS we are all human and we make mistakes and therefore, if you find a mistake in the text - write me a personal message, and do not rush to write an angry comment!</i> </div><p>Source: <a href="https://habr.com/ru/post/238385/">https://habr.com/ru/post/238385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238373/index.html">Google changed the developer agreement, leaving the right to remove applications from user devices</a></li>
<li><a href="../238375/index.html">IBM Watson gets closer to business and regular users.</a></li>
<li><a href="../238377/index.html">UDP and C # async / await</a></li>
<li><a href="../238379/index.html">Who is blocking the Chinese firewall?</a></li>
<li><a href="../238381/index.html">VmWare Hands-on Labs 2014</a></li>
<li><a href="../238387/index.html">Global Internet penetration, where Thor is most used and why Russia is so poor: some curious infographics about the global network</a></li>
<li><a href="../238389/index.html">Startup Creation Guide, Part 9, and The Truth About Venture Investors</a></li>
<li><a href="../238395/index.html">Search filter by Skype message</a></li>
<li><a href="../238397/index.html">Bitcoin The unsolvable problem of decentralization</a></li>
<li><a href="../238403/index.html">The Windows Phone and Windows app store developer accounts have become perpetual, for only $ 19!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>