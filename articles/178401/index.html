<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Processing and classification of requests. Part Three: Correcting Typos</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Misprints are sometimes useful for cheering the reader. Search engines appreciate humor while not able to, and the words typed with errors, lead them ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Processing and classification of requests. Part Three: Correcting Typos</h1><div class="post__text post__text-html js-mediator-article">  Misprints are sometimes useful for cheering the reader.  Search engines appreciate humor while not able to, and the words typed with errors, lead them to confusion, which as a result distresses the user.  To prevent these phenomena, there are automatic "correction" typos, they are spellcheckers. <br><br>  More than enough has already been written about various approaches to correcting typos, so in this article I will not repeat what is already known, but I will show you how to write a spell checker from scratch - simple, but quite capable.  All that is needed for this is a list of correct words and a bit of C ++. <br><br><img src="https://habrastorage.org/storage2/edd/640/c99/edd640c99dc52a9257faa983a6263eb1.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  I took the list of words <a href="">here</a> , but any other dictionary will do.  We will store it in the prefix tree (it is Trie).  Here is its somewhat <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">exotic</a> , not quite <a href="http://en.wikipedia.org/wiki/Radix_tree">optimal</a> , quite <a href="http://stackoverflow.com/questions/6806173/why-should-not-i-subclass-inherit-standard-containers">dangerous</a> , but perhaps the most <a href="http://en.wikipedia.org/wiki/KISS_principle">concise</a> implementation: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trie_t</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span>&gt; { }</code> </pre> <br>  The <code>trie_t</code> structure inherits all <code>map</code> methods.  The keys of this <code>map</code> <code>trie_t</code> letters of words, and the values ‚Äã‚Äãare again <code>trie_t</code> structures that inherit ... and so on.  Somewhat meditative, but for the prototype it will do. <br><br>  Add a node weight to the structure, it will come in handy later: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trie_t</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span>() : w(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} }</code> </pre><br>  Write the words in the tree will be using this function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> &amp; add( <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> &amp; t, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; s ) { t.w++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !s.empty() ? add( t[ s[<span class="hljs-number"><span class="hljs-number">0</span></span>] ], s.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) : t[<span class="hljs-string"><span class="hljs-string">'$'</span></span>]; }</code> </pre><br>  It works like this: we take the first character of a word, write it into the key of the map, we get a link to the corresponding subtree (if necessary, it is created right there).  Recursively write the rest of the string to this subtree.  When the string is exhausted, we add to the last node a ‚Äústop sign‚Äù - the key ' <code>$</code> ' with an empty subtree. <br><br>  After reading the words from the specified file, we will add them all to the dictionary: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> glossary; <span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( argv[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">] )</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> word; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( getline( fi, word ) ) add( glossary, word );</code> </pre><br>  As a result, the number of words that have passed through this node will be recorded in the <code>w</code> field of each tree node. <br><br>  What can you do with all this?  You can print the contents of the tree by sorting the keys and subtrees of each node with the inherited iterator: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trie_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span>&gt;::const_iterator it = t.begin(); it != t.end(); ++it ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( it-&gt;first == <span class="hljs-string"><span class="hljs-string">'$'</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print( it-&gt;second, prefix + it-&gt;first ); }</code> </pre><br>  You can determine the presence or absence of a given word in the tree: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_known</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trie_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; s )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !s.empty() ? is_known( t[ s[<span class="hljs-number"><span class="hljs-number">0</span></span>] ], s.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) : t.find(<span class="hljs-string"><span class="hljs-string">'$'</span></span>) != t.end(); }</code> </pre><br>  In this function, although it works correctly, for the sake of brevity, an error has been made.  I will not correct it, since we will no longer need such a ‚Äúclear‚Äù search. <br><br><h4>  Fuzzy search </h4><br>  If you imagine a tree as a certain repeatedly forking road, then the function of searching for a word is a traveler walking along this road.  The traveler is given a route (search word), and in accordance with it he moves from node to node, crossing out the passed letters of the route.  If the letters run out, it remains to check whether the ‚Äústop sign‚Äù is visible. <br><br>  Now imagine that the traveler, as it were simultaneously sent in all directions at once.  Each of its clones at each fork behaves in the same way, and so on, until someone comes to each of the terminations (that is, the leaves of the tree).  The total number of travelers will be equal to the number of words recorded in the tree, and each of them will pass along its own individual trajectory. <br><br>  Let all of them were originally given the same word route.  At each transition, each traveler, as before, crosses out one letter in his copy of the route.  But if the real direction of the transition does not coincide with the crossed out letter, the traveler receives a penalty.  As a result, at the end of the journey, each person will have some debt accumulated.  Line up all in a row, sorted in ascending order of this magnitude. <br><br>  If the search word is present in the dictionary, then one traveler will go all the way without penalties - he will be the first in the sorted list.  If there is no word in the dictionary, then the leader will be the one who has traveled with a minimum number of violations. <br><br>  Actually, this is almost the entire algorithm.  The trick is that the path traversed by the leader will be the closest correction of a given word (or the word itself if there are no typos), and the number of violations (deviations from a given route) is the number of typos. <br><br><h4>  On your marks </h4><br>  It is more correct, of course, to call the road a tree, forks - knots, travelers - hypotheses, and deviations from the route - editing operations.  But let them remain as they are, somehow livelier.  We introduce a structure storing all information about the traveler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rambler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> todo; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> * road; <span class="hljs-keyword"><span class="hljs-keyword">rambler_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; t, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; d, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span> * r ) : todo( t ), done( d ), cost( c ), road( r ) {} };</code> </pre><br>  The fields store the following: <br><ul><li>  <code>todo</code> is the way to go.  Initially, this is the travel route, that is, the word to be corrected.  At the end there is an empty line. </li><li>  <code>done</code> - the passable part of the path.  At the beginning - an empty line, at the end - a list of passed nodes, that is, the corrected word. </li><li>  <code>cost</code> - the amount of fines imposed.  At the start - zero, at the finish - as it will. </li><li>  <code>road</code> - the location of the traveler.  In the beginning - the root of the tree, in the end - one of the leaves. </li></ul><br>  So, the traveler is at the starting point, you can go: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">rambler_t</span></span> R( word, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;glossary );</code> </pre><br><br><h4>  First step </h4><br>  All possible directions can be iterated with the help of an iterator, which is already useful when printing a dictionary: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">trie_t</span></span>&gt;::const_iterator it = R.road-&gt;begin(); it != R.road-&gt;end(); ++it ) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dest = it-&gt;first; <span class="hljs-comment"><span class="hljs-comment">//   const trie_t * road = it-&gt;second; //   //     }</span></span></code> </pre><br>  After completing the step, the values ‚Äã‚Äãof the structure fields will change as follows: <br><br><pre> <code class="cpp hljs">R.done = R.done + dest; R.todo = R.todo.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>); R.road = R.road[ dest ];</code> </pre><br>  There are two options with payment.  If the chosen direction coincides with the ‚Äúgeneral line‚Äù, then the transition is free, otherwise +1: <br><br><pre> <code class="cpp hljs">R.cost = R.cost + ( dest == todo[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre><br>  Ok, the first step is done.  Rather, a lot of first steps at once - instead of a lonely wanderer, a whole team appeared: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">rambler_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">team_t</span></span>;</code> </pre><br>  It remains only to repeat step by step, increasing the team until everyone reaches their destination point ... Stop.  There is a nuance, and not one. <br><br>  The above ‚Äúturn is not there‚Äù, corresponding to the replacement of the letter of the word by another letter - only one of the varieties of typos.  There are at least two more: deletion and insertion. <br><br><h4>  Deletion </h4><br>  This is the situation ‚Äúpaid, but did not go‚Äù: we delete the first letter from <code>todo</code> , self-fined, but do not make the transition and do not add anything to the <code>done</code> . <br><br><pre> <code class="cpp hljs">R.done = R.done; R.todo = R.todo.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>); R.road = R.road; R.cost = R.cost + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  As a result, the letter from <code>todo</code> simply lost along the way, which is equivalent to its removal. <br><br><h4>  Insert </h4><br>  Here, on the contrary, ‚Äúrunning on the spot‚Äù: we move deep into the tree, add a letter to <code>done</code> , but do not cross out anything from <code>todo</code> . <br><br><pre> <code class="cpp hljs">R.done = R.done + dest; R.todo = R.todo; R.road = R.road[ dest ]; R.cost = R.cost + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  The completed letter in <code>done</code> arises out of plan, from nowhere, which is tantamount to inserting it. <br><br><h4>  Fathers and Sons </h4><br>  Since at each step there is some <s>parallelization of the worlds of</s> an increase in the number of objects, we will not modify the parameters of the traveler, but create new ones in his image and likeness.  The following function unites everything: it receives as input to the traveler, filling out two vectors of travelers at the exit in accordance with the given route, the keys of the tree node and the rules described above. <br>  Those who will continue to move into the <code>team</code> vector, and <code>finished</code> to the <code>finished</code> , that is, those who have <code>todo</code> empty, and the current tree node contains the end-of-word <s>bucks</s> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step_forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rambler_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; R, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">team_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; team, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">team_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; finished )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> next = R.todo[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  const string &amp; todo = next ? R.todo.substr(1) : ""; for( map&lt;char, trie_t&gt;::const_iterator it = R.road-&gt;begin(); it != R.road-&gt;end(); ++it ) { const trie_t * road = &amp;it-&gt;second; //  char dest = it-&gt;first; //  if ( next == dest ) team.push_back( rambler_t( todo, //    R.done + dest, R.cost, road )); else { team.push_back( rambler_t( todo, //  R.done + dest, R.cost + 1, road )); team.push_back( rambler_t( R.todo, //  R.done + dest, R.cost + 1, road )); if ( !next &amp;&amp; dest == '$' ) finished.push_back( R ); // ! } } if ( next ) team.push_back( rambler_t( todo, //  R.done, R.cost + 1, R.road )); }</span></span></code> </pre><br><br><h4>  Natural selection </h4><br>  And the second nuance: by generating an avalanche of new and new participants at every step, we act irrationally.  Crowds idly wandering about a tree are poorly managed, most of them are useless and only devour resources.  We introduce restrictions and arrange a competition for them - let them run. <br><br>  First, we will assign the maximum allowable amount of fines, and we will throw out all those who exceeded it, deviating too much from the given path. <br><br>  Secondly, we will drop all those who are lagging behind.  True, there is a risk that among the exiled outsiders, someone could sprint to catch up with the leaders at the very end of the race, but for the sake of optimization you will have to put up with it. <br><br>  In order to identify those lagging behind, let us estimate each person‚Äôs chances for success, that is, that the rest of the way will be passed without disqualification for exceeding the maximum amount.  Chance will be estimated as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ramb_chances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rambler_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( ( a.road-&gt;w + <span class="hljs-number"><span class="hljs-number">1</span></span> ) * ( a.done.size() + <span class="hljs-number"><span class="hljs-number">1</span></span> ) ) / ( <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; a.cost ); }</code> </pre><br>  Why is there a logarithm?  What are the bit shifts?  Why is the function exactly like that?  You can try to explain.  Obviously, the greater the amount of fines already received, the less likely to reach the end.  And the more words in a subtree, the higher the probability of finding at least one suitable among them.  And the length of the path already traveled, as it indicates ‚Äúendurance‚Äù. <br><br>  It must be admitted that the latter is very far-fetched by the ears.  But in any heuristics the main thing is to work.  This one works.  And, anyway, we are nearing completion.  Denote the maximum amount of penalties as <code>max_cost</code> , the maximum size of a team as <code>team_size</code> . <br><br>  Put the first mover at the beginning of all the roads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">team_t</span></span> walkers, leads; walkers.push_back( <span class="hljs-keyword"><span class="hljs-keyword">rambler_t</span></span>( word, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;glossary ) );</code> </pre><br>  We make a step by generating the next ‚Äúgeneration‚Äù: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">team_t</span></span> next_g; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; walkers.size(); ++i ) step_forward( walkers[i], next_g, leads );</code> </pre><br>  In <code>leads</code> who complete their path are written, the <code>next_g</code> are not reached yet.  We sort still not descending their chances to reach: <br><br><pre> <code class="cpp hljs">sort( next_g.begin(), next_g.end(), ramb_chance_cmp );</code> </pre><br>  And we repeat all this until there is still someone to move on.  Ignore those whose fines exceeded <code>max_cost</code> , and those who are not included in the <code>team_size</code> best: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !walkers.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">team_t</span></span> next_g; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; min( walkers.size(), team_size ); ++i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( walkers[i].cost &lt; max_cost ) step_forward( walkers[i], next_g, leads ); walkers.swap( next_g ); sort( walkers.begin(), walkers.end(), ramb_chance_cmp ); }</code> </pre><br>  By the way, <code>leads</code> may have several structures with the same <code>done</code> lines.  Guess where they are from? <br>  Leave only the unique elements: <br><br><pre> <code class="cpp hljs">sort( leads.begin(), leads.end(), ramb_done_cmp ); <span class="hljs-comment"><span class="hljs-comment">//   done leads.resize( distance( leads.begin(), unique( leads.begin(), leads.end(), ramb_uniq ) ) ); //   sort( leads.begin(), leads.end(), ramb_chance_cmp ); //  </span></span></code> </pre><br>  That's almost all. <br><br>  Add all of the above into the <code>spellcheck</code> function, pass our word into it, the maximum penalty and the number of candidates.  You can use: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( getline( <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span>, word ) ) { <span class="hljs-keyword"><span class="hljs-keyword">team_t</span></span> fixed = spellcheck( word, word.size()/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; word &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fixed.size(); ++i ) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; fixed[i].done &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; fixed[i].cost &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  The limit of 512 candidates and the maximum deviation in half the length of a given word I picked up manually.  With such parameters, the algorithm's performance is approximately 10 words per second; it copes with the words <code></code> , <code></code> , <code></code> and the <code></code> , but does not turn <code></code> into <code></code> . <br><br>  Now absolutely everything.  Let's get started, run.  And here is an example of the work of our simple but effective mechanism for correcting typos: <br><br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">3</span></span>   <span class="hljs-number"><span class="hljs-number">3</span></span>   <span class="hljs-number"><span class="hljs-number">3</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  It is evident that not all of his results are perfect, but this is fixable. <br><br><h4>  Results of the way </h4><br>  I'm sure many people have learned in the description of one of the varieties of an informed search - <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">the A * algorithm</a> , or rather, its variation - the A * algorithm with iterative deepening and restriction on memory.  Of course, the described algorithm is only the first, rough approximation to what is actually used in battle. <br><br>  What else can a real combat spell checker know? <br><br><ul><li>  In our reference dictionary there are only the original forms of words, so he will correct the <code> </code> on the <code> </code> , which is wrong.  It is necessary to have an idea about morphology, or to include all forms of words in the dictionary.  The first is better, but harder. </li></ul><br><ul><li>  All words are equal.  This leads to inaccuracies in choosing the best hypothesis: <br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre>  The problem will be solved if you add information about the frequency of use of words. </li></ul><br><ul><li>  All errors are equal.  Hence the uncertain results: <br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre>  Corrected by grading penalties in accordance with the probability of each possible error.  Replacing <code></code> more likely than <code></code> per <code></code> , so a <code></code> more likely. </li></ul><br><ul><li>  Punto Switching.  It's simple.  Add a table of correspondence of the form <code>q-</code> , <code>w-</code> , <code>a-</code> and one more type of typo - change of the layout.  Is done. </li></ul><br><ul><li>  Gluing and sticking words.  This is somewhat more complicated.  It is necessary to teach the ‚Äútravelers‚Äù to jump from the leafy nodes of the tree to its root and separately handle the gaps in their ‚Äúroutes‚Äù. </li></ul><br><ul><li>  Context fixes.  The same words in different situations should be corrected in different ways.  For example, <code> </code> and <code> </code> , <code> </code> and <code> </code> , a <code> </code> and a <code> </code> .  To correct such typos, statistical data and / or grammar rules are needed.  In other words, the language model.  This is another story. </li></ul><br><br><h4>  Side effects </h4><br>  It would be wrong not to mention the possibilities of the described approach that are beyond the scope of our task. <br><br><ul><li>  If you cancel the penalties for adding characters to the end of the specified "route", then we get the solution to the problem of <b>auto-completion</b> . </li></ul><br><ul><li>  If we insert into the program a table of phonetic correspondence of symbols, we obtain a system for the recognition of <b>transliteration of</b> any degree of ambiguity.  The algorithm will find the most likely word. <br><pre> <code class="bash hljs"> ‚Üí j, zh, g, dj j ‚Üí , , ,  ...</code> </pre> </li></ul><br><ul><li>  Tree transitions according to the rules given by the correspondence of numbers and letters will turn the spellchecker into the <b>T9</b> set system: <br><pre> <code class="bash hljs"> 2 ‚Üí  ... 9 ‚Üí </code> </pre> </li></ul><br><ul><li>  The cost of the error, calculated not on the probabilities of misprints, but solely on the distances between the keys (or rather, their images on the touch screen), forms the basis of the system of ‚Äúsliding‚Äù word entry - <b>Swype</b> . </li></ul><br><ul><li>  The task of fuzzy search is part of speech recognition systems, handwritten texts ... However, enough.  This has already been written very much indeed. </li></ul><br><br>  The full text of the program can be found <a href="http://pastebin.com/qxPHVAhY">here</a> .  The program is slightly longer than Peter Norvig's famous nanosellchecker, but it is far superior in its capabilities, not inferior in performance. <br><br>  Thanks for attention! <br><br><h4>  Useless links </h4><br><ul><li>  Inspiration Source: <a href="http://times.cs.uiuc.edu/duan9/fr090-duan.pdf">Online Spelling Correction for Query Completion</a> </li><li>  The world's shortest spell checker by <a href="http://norvig.com/spell-correct.html">Peter Norvig</a> </li><li>  <a href="">1200 ways to write the word "classmates"</a> - can be used to calculate the error model </li><li>  Alternative approaches: <a href="http://habrahabr.ru/post/123320/">one</a> , <a href="http://habrahabr.ru/post/114997/">two</a> , <a href="http://habrahabr.ru/post/105450/">three</a> </li></ul><br><br>  <i>Mikhail Dolinin,</i> <i><br></i>  <i>search request manager</i> </div><p>Source: <a href="https://habr.com/ru/post/178401/">https://habr.com/ru/post/178401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178381/index.html">System Center 2012 Operations Manager + SP1 from Microsoft Architect!</a></li>
<li><a href="../178385/index.html">Last days of discounts for the conference # MBLT13</a></li>
<li><a href="../178387/index.html">Another game abstraction from Notch - Drop</a></li>
<li><a href="../178389/index.html">Employee Opera Software on trial for transferring production secrets in favor of Mozilla</a></li>
<li><a href="../178393/index.html">Implementing API Call Interception</a></li>
<li><a href="../178403/index.html">Add Web API for a C ++ program using the POCO library</a></li>
<li><a href="../178405/index.html">Correctly free up resources in java</a></li>
<li><a href="../178407/index.html">Automate Web Application Testing</a></li>
<li><a href="../178409/index.html">Java String Internal Representation Changes</a></li>
<li><a href="../178415/index.html">The company AMLogic is preparing to release a new single-chip platform - AML8726-M8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>