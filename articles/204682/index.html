<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize image processing in C ++ using SIMD. Median filter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Earlier in the introductory article, I brought up a list of problems that a developer will have to face if he wants to optimize the opt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize image processing in C ++ using SIMD. Median filter</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Earlier in the introductory <a href="http://habrahabr.ru/post/204234/">article,</a> I brought up a list of problems that a developer will have to face if he wants to optimize the optimization of image processing using SIMD instructions.  Now it's time for a concrete example to show how the above problems can be solved.  I thought for a long time which algorithm to choose for the first example, and decided to dwell on median filtering.  Median filtering is an effective way to suppress noise that inevitably appears on digital cameras in conditions of low scene illumination.  This algorithm is quite resource-intensive - for example, when processing a gray image with a 3x3 median filter, about 50 operations per image point are required.  But at the same time, it operates only with 8-bit numbers and it requires relatively little input data to work.  These circumstances make the algorithm simple enough for SIMD optimization and at the same time allow you to get a very significant acceleration from it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/345/b91/540/345b91540c0d1cf5ff1f9775753abca1.png" alt="image"><br><a name="habracut"></a><br><br>  For reference, I remind the essence of the algorithm: <br><ul><li>  For each point of the original image, a certain neighborhood is taken (in our case, 3x3). </li><li>  The points of this neighborhood are sorted by increasing brightness. </li><li>  The midpoint (5th for the 3x3 filter) of the sorted neighborhood is recorded in the final image. </li></ul><br>  For the first example, I decided to simplify the task and consider the case of a gray image (8 bits per pixel) without taking into account boundary effects ‚Äî for this, the central part of a somewhat larger image was taken for filtering.  Of course, in real problems, the boundary points of the image should be calculated using a special algorithm, and sometimes the implementation of these specific algorithms can occupy most of the code, but we will focus on these issues another time.  In addition, for similar reasons, it is assumed that the image width is a multiple of 32. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Scalar version of the algorithm </h4><br><h5>  1st scalar version </h5><br>  In this initial implementation, the problem was solved head-on: the neighborhood for each point of the original image was copied into an auxiliary array, which was then sorted using the function std :: sort (). <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = src[<span class="hljs-number"><span class="hljs-number">-1</span></span>]; a[<span class="hljs-number"><span class="hljs-number">1</span></span>] = src[<span class="hljs-number"><span class="hljs-number">0</span></span>]; a[<span class="hljs-number"><span class="hljs-number">2</span></span>] = src[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">9</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ Load(src - stride, a + <span class="hljs-number"><span class="hljs-number">0</span></span>); Load(src, a + <span class="hljs-number"><span class="hljs-number">3</span></span>); Load(src + stride, a + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">9</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(a, a + <span class="hljs-number"><span class="hljs-number">9</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MedianFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcStride, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstStride)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; ++y) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; ++x) { Load(src + x, srcStride, a); Sort(a); dst[x] = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>)a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; } src += srcStride; dst += dstStride; } }</code> </pre> <br><br><h5>  2nd scalar version </h5><br>  The previous method, however, immediately shows a bottleneck - this is the standard sorting function.  It is designed to sort an array of arbitrary size, it has a lot of internal checks, so it will most likely not be the optimal solution for this problem, where the array is small and has a fixed size.  In addition, it is not at all necessary for us to sort the array completely; it is enough that in the 4th element we have the value we need.  Therefore, we can apply the ‚Äúnetwork‚Äù sorting method (also known as the bitonic sorting method): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    { if(a &gt; b) { int t = a; a = b; b = t; } } inline void Sort(int a[9]) //    { Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[1]); Sort(a[3], a[4]); Sort(a[6], a[7]); Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[3]); Sort(a[5], a[8]); Sort(a[4], a[7]); Sort(a[3], a[6]); Sort(a[1], a[4]); Sort(a[2], a[5]); Sort(a[4], a[7]); Sort(a[4], a[2]); Sort(a[6], a[4]); Sort(a[4], a[2]); }</span></span></span></span></code> </pre><br><br><h5>  3rd scalar version </h5><br>  Although the first method turned out to be much faster than zero (see the test result below), but it still has one bottleneck - there are a lot of conditional transitions in this method.  As you know, modern processors do not like them very much, since they have a pipeline architecture and the possibility of an extraordinary execution of several commands in one clock cycle.  Both for the first and for the second conditional transitions are extremely undesirable, since the processor must stop and wait for the results of the calculations in order to find out which branch of the program it should go further.  Fortunately, the sorting of two 8-bit values ‚Äã‚Äãis quite possible to implement without conditional transitions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = a - b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = ~(d &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); b += d&amp;m; a -= d&amp;m; }</code> </pre><br><br>  The result of these preliminary scalar code optimizations is the following version of the median filter: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = src[<span class="hljs-number"><span class="hljs-number">-1</span></span>]; a[<span class="hljs-number"><span class="hljs-number">1</span></span>] = src[<span class="hljs-number"><span class="hljs-number">0</span></span>]; a[<span class="hljs-number"><span class="hljs-number">2</span></span>] = src[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">9</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ Load(src - stride, a + <span class="hljs-number"><span class="hljs-number">0</span></span>); Load(src, a + <span class="hljs-number"><span class="hljs-number">3</span></span>); Load(src + stride, a + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = a - b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = ~(d &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); b += d&amp;m; a -= d&amp;m; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">9</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    { Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[1]); Sort(a[3], a[4]); Sort(a[6], a[7]); Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[3]); Sort(a[5], a[8]); Sort(a[4], a[7]); Sort(a[3], a[6]); Sort(a[1], a[4]); Sort(a[2], a[5]); Sort(a[4], a[7]); Sort(a[4], a[2]); Sort(a[6], a[4]); Sort(a[4], a[2]); } void MedianFilter(const uint8_t * src, size_t srcStride, size_t width, size_t height, uint8_t * dst, size_t dstStride) { int a[9]; for(size_t y = 0; y &lt; height; ++y) { for(size_t x = 0; x &lt; width; ++x) { Load(src + x, srcStride, a); Sort(a); dst[x] = (uint8_t)a[4]; } src += srcStride; dst += dstStride; } }</span></span></span></span></code> </pre><br><br>  This version is already significantly (about 5-6 times) ahead of our initial version of the algorithm in speed.  And it is based on it that we will implement the SIMD algorithm optimization, as well as carry out a comparison of the speed of the scalar and vector versions of the algorithm. <br><br><h4>  SIMD version of the algorithm </h4><br>  To illustrate the optimization of the median filtering algorithm using SIMD, I use two sets of instructions SSE2 and AVX2, missing the MMX extension, which is currently outdated and has more historical interest. Fortunately, in order to use SIMD instructions, it is not necessary to use the assembler .  Most modern C ++ compilers have intrinsics support (built-in functions with which you can use various processor extensions).  Programming using intrinsics is practically the same as programming in pure C. Intrinsic functions are converted by the compiler directly into processor instructions, although working directly with processor registers remains hidden from the programmer.  In most cases, a program using intrinsics is not inferior in speed to a program written in assembler. <br><br><h5>  SSE2 version </h5><br>  The SSE2 integer commands are defined in the &lt;emmintrin.h&gt; header file.  The basic type is __m128i - 128 bit vector, which, depending on the context, can be interpreted as a set of 2 64 bit, 4 32 bit, 8 x 16 bit, 16 x 8 bit signed or unsigned numbers.  As you can see, they support not only vector arithmetic operations, but also vector logic operations, as well as vector data loading and unloading operations.  Below is the optimization of the median filter using SSE2 instructions.  The code, I think, is pretty intuitive. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; emmintrin.h &gt; inline void Load(const uint8_t * src, __m128i a[3]) { a[0] = _mm_loadu_si128((__m128i*)(src - 1)); // 128      16    a[1] = _mm_loadu_si128((__m128i*)(src)); a[2] = _mm_loadu_si128((__m128i*)(src + 1)); } inline void Load(const uint8_t * src, size_t stride, __m128i a[9]) { Load(src - stride, a + 0); Load(src, a + 3); Load(src + stride, a + 6); } inline void Sort(__m128i&amp; a, __m128i&amp; b) { __m128i t = a; a = _mm_min_epu8(t, b); //  2- 8       16   b = _mm_max_epu8(t, b); //  2- 8       16   } inline void Sort(__m128i a[9]) //    { Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[1]); Sort(a[3], a[4]); Sort(a[6], a[7]); Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[3]); Sort(a[5], a[8]); Sort(a[4], a[7]); Sort(a[3], a[6]); Sort(a[1], a[4]); Sort(a[2], a[5]); Sort(a[4], a[7]); Sort(a[4], a[2]); Sort(a[6], a[4]); Sort(a[4], a[2]); } void MedianFilter(const uint8_t * src, size_t srcStride, size_t width, size_t height, uint8_t * dst, size_t dstStride) { __m128i a[9]; for(size_t y = 0; y &lt; height; ++y) { for(size_t x = 0; x &lt; width; x += sizeof(__m128i)) { Load(src + x, srcStride, a); Sort(a); _mm_storeu_si128((__m128i*)(dst + x), a[4]); // 128      16    } src += srcStride; dst += dstStride; } }</span></span></span></span></code> </pre><br><br><h4>  AVX2 version </h4><br>  The AVX2 integer commands are defined in the &lt;immintrin.h&gt; header file.  The base type is __m256i - 256 bit vector, which, depending on the context, can be interpreted as a set of 4 64 bit, 8 32 bit, 16 16 bit, 32 8 bit signed or unsigned numbers.  Although the AVX2 instruction set largely repeats the SSE2 instruction set (taking into account the doubled width of the vector), but it also contains quite a lot of instructions that have no analogues in SSE2.  Below is the optimization of the median filter using AVX2 instructions. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; immintrin.h &gt; inline void Load(const uint8_t * src, __m256i a[3]) { a[0] = _mm256_loadu_si256((__m128i*)(src - 1)); // 256      32    a[1] = _mm256_loadu_si256((__m128i*)(src)); a[2] = _mm256_loadu_si256((__m128i*)(src + 1)); } inline void Load(const uint8_t * src, size_t stride, __m256i a[9]) { Load(src - stride, a + 0); Load(src, a + 3); Load(src + stride, a + 6); } inline void Sort(__m256i&amp; a, __m256i&amp; b) { __m256i t = a; a = _mm256_min_epu8(t, b); //  2- 8       32   b = _mm256_max_epu8(t, b); //  2- 8       32   } inline void Sort(__m256i a[9]) //    { Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[1]); Sort(a[3], a[4]); Sort(a[6], a[7]); Sort(a[1], a[2]); Sort(a[4], a[5]); Sort(a[7], a[8]); Sort(a[0], a[3]); Sort(a[5], a[8]); Sort(a[4], a[7]); Sort(a[3], a[6]); Sort(a[1], a[4]); Sort(a[2], a[5]); Sort(a[4], a[7]); Sort(a[4], a[2]); Sort(a[6], a[4]); Sort(a[4], a[2]); } void MedianFilter(const uint8_t * src, size_t srcStride, size_t width, size_t height, uint8_t * dst, size_t dstStride) { __m256i a[9]; for(size_t y = 0; y &lt; height; ++y) { for(size_t x = 0; x &lt; width; x += sizeof(__m256i)) { Load(src + x, srcStride, a); Sort(a); _mm256_storeu_si256((__m256i*)(dst + x), a[4]); // 256      32    } src += srcStride; dst += dstStride; } }</span></span></span></span></code> </pre><br><br>  <i><b>Note:</b> To get maximum acceleration from optimization, the code that contains AVX2 instructions should be compiled with the following compiler option: (/ arch: AVX for Visual Studio 2012, -march = core-avx2 for GCC).</i>  <i>In addition, it is very desirable that the code does not include the alternation of AVX2 and SSE2 instructions, since switching the operating mode of the processor in this case will adversely affect the overall performance.</i>  <i>Based on the above, it is advisable to have the AVX2 and SSE2 versions of the algorithms in different ".cpp" files.</i> <br><br><h4>  Testing </h4><br>  Testing was performed on gray images of 2 MB (1920 x 1080).  To improve the accuracy of measuring time, the tests were run several times.  The execution time was obtained by dividing the total test execution time by the number of runs.  The number of runs was chosen in such a way that the total execution time was not less than 1 second, which should provide two signs of accuracy when measuring the execution time of the algorithms.  The algorithms were compiled with maximum optimization for 64 bit Windows 7 on Microsoft Visual Studio 2012 and run on an iCore-7 4770 processor (3.4 GHz). <br><br><table width="720" border="1"><tbody><tr><td colspan="3">  Execution time, ms </td><td colspan="3">  Relative acceleration </td></tr><tr><td>  Best scalar </td><td>  SSE2 </td><td>  AVX2 </td><td>  Best scalar / SSE2 </td><td>  Best Scalar / AVX2 </td><td>  SSE2 / AVX2 </td></tr><tr><td>  24.814 </td><td>  0.565 </td><td>  0.424 </td><td>  43.920 </td><td>  58.566 </td><td>  1.333 </td></tr></tbody></table><br><br><h4>  Conclusion </h4><br>  As can be seen from the result of the tests, the acceleration of the median filtering algorithm from using SIMD instructions on modern processors can reach from 40 to 60 times.  As it seems to me, this is a sufficient value to bother with optimization (if, of course, execution speed is important in your program).  In this publication I tried to simplify the code used as much as possible. <br>  So beyond the framework there were issues related to the alignment of data, with the processing of boundary points, and much more. <br>  I will try to reveal these questions in the following articles.  If the reader is interested in how the combat code that implements this functionality will look like, then he will be able to find it <a href="http://sourceforge.net/projects/simd/">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/204682/">https://habr.com/ru/post/204682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204666/index.html">MPEG-DASH in nginx-rtmp-module: live video in a browser without flash</a></li>
<li><a href="../204668/index.html">Waited, waited and waited! OpenMP 4.0</a></li>
<li><a href="../204670/index.html">Mail.Ru Group Technologies Forum in Nizhny Novgorod</a></li>
<li><a href="../204678/index.html">Clone VCL components</a></li>
<li><a href="../204680/index.html">Beeline and beta testers</a></li>
<li><a href="../204684/index.html">8 HTML elements that you do not use (and should)</a></li>
<li><a href="../204686/index.html">Choosing a CASE tool for developing processes in BPMN</a></li>
<li><a href="../204688/index.html">The biggest bitcoin scam is happening right now</a></li>
<li><a href="../204692/index.html">Modern software design technologies in the context of communication theory and decomposition method</a></li>
<li><a href="../204696/index.html">DVHack 2013. It was great. Or the first hackathon in the Far East</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>