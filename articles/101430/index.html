<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Variadic templates in C ++ 0x</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Those who read the book ‚ÄúModern Programming in C ++‚Äù by Andrei Alexandrescu know that there is an extensive class of tasks (in the field of metaprogra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Variadic templates in C ++ 0x</h1><div class="post__text post__text-html js-mediator-article">  Those who read the book ‚ÄúModern Programming in C ++‚Äù by Andrei Alexandrescu know that there is an extensive class of tasks (in the field of metaprogramming using templates) when it is necessary to specify a variable (previously unknown) number of arguments when instantiating.  Typical examples of such tasks: <br>  - Description of tuples (tuples) <br>  - Description of types like options <br>  - Description of functors (in this case the list of types of arguments depends on the signature of the function) <br>  - Classification of types according to predefined sets <br>  - etc. <br><br>  In each such task, the exact number of types passed to the corresponding template as arguments is difficult to determine in advance.  And, generally speaking, depends on the desires and needs of those who intend to use the corresponding template class. <br>  Within the framework of the current C ++ standard, there is no convenient solution to such problems.  Templates can take a strictly defined number of parameters and nothing else.  A. Alexandrescu (in the book mentioned above) proposes a general solution based on the so-called.  ‚ÄúType lists‚Äù, in which types are represented as a simply linked list, implemented by means of recursive templates.  An alternative solution (used, for example, in boost :: variant and boost :: tuple) is to declare a template class with a large number of parameters to which (all but the first) are assigned some default value.  Both of these solutions are partial and do not cover the whole range of possible tasks.  Therefore, in order to eliminate the shortcomings of existing solutions and simplify the code, the new standard offers C ++ to developers a new option for declaring templates?  ‚ÄúTemplates with a variable number of parameters‚Äù or, in the original, ‚Äúvariadic templates‚Äù. <br><br><a name="habracut"></a><br><h4>  Simple use cases </h4><br>  The declaration of a template with a variable number of parameters is as follows: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> ... Types&gt; <br>  <font color="Blue">class</font> VariadicTemplate <br>  { <br>  }; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Similarly, templates with a variable number of non-type parameters are declared: <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Ints&gt; <br>  <font color="Blue">class</font> VariadicTemplate <br>  { <br>  }; <br><br>  It should be noted here that emulation of this under the current standard is a very nontrivial task (if not to say that it is not feasible). <br>  In addition to template classes, you can also declare template functions with a variable number of parameters.  Similar ads might look like this: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> ... Type&gt; <br>  <font color="Blue">void</font> printf ( <font color="Blue">const</font> <font color="Blue">char</font> * format, Type ... args); <br><br>  It is obvious that such kind of template parameters (they are called ‚Äúparameter packages‚Äù or ‚Äúparameters packs‚Äù) cannot be used everywhere where ordinary (single) template parameters can be used.  It is acceptable to use parameter packages in the following contexts: <br><ul><li>  In the enumeration of the base classes of the template (base-specifier-list); </li><li>  In the initialization list of data members in the constructor (mem-initializer-list); </li><li>  In initialization lists (initializer-list) </li><li>  In the parameter lists of other templates (template-argument-list); </li><li>  In the specification of exceptions (dynamic-exception-specification); </li><li>  In the attribute list (attribute-list); </li><li>  In the list of capture lambda functions (capture-list). </li></ul><br>  Depending on where exactly the parameter package is used, the elements of this package are interpreted accordingly.  The use of the parameter package itself is called ‚Äúpack expansion‚Äù (pack expansion), and is recorded in the code as follows: <br><br> <code>Types ...</code> <br> <br>  Where Types is the name of the parameter package. <br>  For example, for such a template declaration: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> ... Types&gt; <br>  <font color="Blue">class</font> VariadicTemplate <br>  { <br>  }; <br><br>  Possible options for the parameter package disclosure might look like this: <br>  <font color="Blue">class</font> VariadicTemplate: <font color="Blue">public</font> Types ... <font color="Green">// expansion to the list of base classes.</font>  <font color="Green">'public types' - pattern</font> <br>  { <br>  <font color="Green">// ...</font> <br>  <font color="Green">// Expand to another parameter list.</font>  <font color="Green">Pattern - Types</font> <br>  <font color="Blue">typedef</font> OtherVariadicTemplate &lt;Types ...&gt; OtherVT; <br>  <font color="Green">// More difficult option.</font>  <font color="Green">Pattern - Types *</font> <br>  <font color="Blue">typedef</font> OtherVariadicTemplate &lt;Types * ...&gt; SomeOtherVT; <br>  <font color="Green">// Expand to function parameter list.</font>  <font color="Green">The pattern is Types, a args is a new parameter list:</font> <br>  <font color="Blue">void</font> <font color="Blue">operator</font> () (Types ... arg) <br>  { <br>  <font color="Green">// Expand to argument list when calling function</font> <br>  foo (&amp; args ...); <br>  } <br>  <font color="Green">// Expansion in the initialization list in the constructor:</font> <br>  VariadicTemplate (): Types () ... <br>  }; <br><br>  The term "pattern" here refers to a piece of code surrounding the name of a parameter package, which will be repeated when the corresponding package is opened.  In the above example, if you carry out the expansion of the parameters manually, you get the template instantiation: <br>  <font color="Green">/ * ... * /</font> VariadicTemplate &lt; <font color="Blue">int</font> , <font color="Blue">char</font> , <font color="Blue">double</font> &gt; <font color="Green">/ * ... * /</font> <br><br>  Will be disclosed as follows: <br>  <font color="Blue">class</font> VariadicTemplate: <font color="Blue">public</font> <font color="Blue">int</font> , <font color="Blue">public</font> <font color="Blue">char</font> , <font color="Blue">public</font> <font color="Blue">double</font> <br>  { <br>  <font color="Green">// ...</font> <br>  <font color="Blue">typedef</font> OtherVariadicTemplate &lt; <font color="Blue">int</font> , <font color="Blue">char</font> , <font color="Blue">double</font> &gt; OtherVT; <br>  <font color="Blue">typedef</font> OtherVariadicTemplate &lt; <font color="Blue">int</font> *, <font color="Blue">char</font> *, <font color="Blue">double</font> *&gt; SomeOtherVT; <br>  <font color="Blue">void</font> <font color="Blue">operator</font> () ( <font color="Blue">int</font> args1, <font color="Blue">char</font> args2, <font color="Blue">double</font> args3) <br>  { <br>  foo (&amp; args1, &amp; args2, &amp; args3); <br>  } <br>  VariadicTemplate (): <font color="Blue">int</font> (), <font color="Blue">char</font> (), <font color="Blue">double</font> () <font color="Green">// obviously, this code will be non-compiled for such a type list</font> <br>  }; <br><br>  As a fairly simple example of using templates with a variable number of parameters, we can give an implementation of a functor.  This implementation looks like this: <br>  # <font color="Blue">include</font> &lt; <font color="Blue">iostream</font> &gt; <br><br>  <font color="Green">// Declare a generic version of the template that stores the function pointer.</font>  <font color="Green">In this case, all the possible types that can come in the template</font> <br>  <font color="Green">// in the process of instantiation, we pack in the parameter package</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> ... Args&gt; <font color="Blue">struct</font> FunctorImpl; <br><br>  <font color="Green">// Specialize the template for a pointer to simple functions.</font>  <font color="Green">In this case, we indicate that the parameter package contains the type of the returned</font> <br>  <font color="Green">// values ‚Äã‚Äã(R) and arguments (Args).</font>  <font color="Green">From these two parameters (simple and batch), then we form the signature of the function</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> R, <font color="Blue">typename</font> ... Args&gt; <br>  <font color="Blue">struct</font> FunctorImpl &lt;R (Args ...)&gt; <br>  { <br>  <font color="Green">// Describes the type of pointer to the function with the desired signature.</font>  <font color="Green">At the same time, we open the parameter package.</font> <br>  <font color="Blue">typedef</font> R (* FT) (Args ...); <br><br>  FunctorImpl (FT fn): m_fn (fn) {;} <br><br>  <font color="Green">// Declare a function call operator in such a way that it takes exactly as many parameters as input as arguments</font> <br>  <font color="Green">// at the stored function type.</font> <br>  R <font color="Blue">operator</font> () (Args ... args) <br>  { <br>  <font color="Green">// Call the function passing it all the received arguments</font> <br>  <font color="Blue">return</font> m_fn (args ...); <br>  } <br><br>  FT m_fn; <br>  }; <br><br>  <font color="Green">// Declare the general dispatcher pattern</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> FT&gt; <br>  <font color="Blue">struct</font> Functor: <font color="Blue">public</font> FunctorImpl &lt;FT&gt; <br>  { <br>  Functor (): FunctorImpl &lt;FT&gt; ( <font color="Blue">NULL</font> ) {;} <br>  Functor (FT fn): FunctorImpl &lt;FT&gt; (fn) {;} <br>  }; <br><br>  <font color="Blue">int</font> plus_fn ( <font color="Blue">int</font> a, <font color="Blue">int</font> b) { <font color="Blue">return</font> a + b;} <br>  <font color="Blue">int</font> minus_fn ( <font color="Blue">int</font> a, <font color="Blue">int</font> b) { <font color="Blue">return</font> a - b;} <br>  <font color="Blue">int</font> increment ( <font color="Blue">int</font> &amp; a) { <font color="Blue">return</font> a ++;} <br><br>  <font color="Blue">int</font> main () <br>  { <br>  Functor &lt; <font color="Blue">int</font> ( <font color="Blue">int</font> , <font color="Blue">int</font> )&gt; plus (plus_fn); <br>  Functor &lt; <font color="Blue">int</font> ( <font color="Blue">int</font> , <font color="Blue">int</font> )&gt; minus (minus_fn); <br>  Functor &lt; <font color="Blue">int</font> ( <font color="Blue">int</font> &amp;)&gt; inc (increment); <br><br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; plus ( <font color="Maroon">10</font> , <font color="Maroon">20</font> ) &lt;&lt; <font color="Maroon">""</font> &lt;&lt; minus ( <font color="Maroon">10</font> , <font color="Maroon">20</font> ) &lt;&lt; <font color="Blue">std</font> :: <font color="Blue">endl</font> ; <br><br>  <font color="Blue">int</font> a = <font color="Maroon">100</font> ; <br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; inc (a) &lt;&lt; <font color="Maroon">""</font> ; <br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; a &lt;&lt; <font color="Blue">std</font> :: <font color="Blue">endl</font> ; <br>  } <br><br>  The result of executing this code is quite expected: <br><br>  30 -10 <br>  100 101 <br><br>  and the code is simple and straightforward.  For comparison, you can see the files with the implementation of boost :: function. <br>  The templates described above are easy to specialize for pointers to member functions: <br>  <font color="Green">// Declare specialization of the function container for the pointer to the member function, specifying the same parameter package</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> T, <font color="Blue">typename</font> R, <font color="Blue">typename</font> ... Args&gt; <br>  <font color="Blue">struct</font> FunctorImpl &lt;R (T :: *) (Args ...)&gt; <br>  { <br>  <font color="Blue">typedef</font> R (T :: * FT) (Args ...); <br>  <font color="Blue">typedef</font> T HostType; <br><br>  FunctorImpl (FT fn = <font color="Blue">NULL</font> , T * obj = <font color="Blue">NULL</font> ): m_fn (fn), m_obj (obj) {;} <br><br>  <font color="Green">// Declare two variants of the function call operator - for the case when the functor is used as a "closure", and when the object</font> <br>  <font color="Green">// for which the method is called, is passed as the first argument</font> <br>  R <font color="Blue">operator</font> () (Args ... args) <br>  { <br>  (m_obj -&gt; * m_fn) (args ...); <br>  } <br><br>  R <font color="Blue">operator</font> () (T * obj, Args ... args) <br>  { <br>  (obj -&gt; * m_fn) (args ...); <br>  } <br><br>  FT m_fn; <br>  T * m_obj; <br>  }; <br><br><br>  <font color="Green">// Declare a closing class that accepts an object in the constructor for which a member function will be called.</font>  <font color="Green">It looks very simple.</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> FT&gt; <br>  <font color="Blue">struct</font> Closure: <font color="Blue">public</font> FunctorImpl &lt;FT&gt; <br>  { <br>  <font color="Blue">typedef</font> <font color="Blue">typename</font> FunctorImpl &lt;FT&gt; :: HostType HostType; <br>  Closure (HostType * obj, FT fn): FunctorImpl &lt;FT&gt; (fn, obj) {;} <br>  }; <br><br>  <font color="Green">// Use</font> <br>  <font color="Blue">class</font> A <br>  { <br>  <font color="Blue">public</font> : <br>  A ( <font color="Blue">int</font> base = <font color="Maroon">0</font> ): m_base (base) {;} <br>  <font color="Blue">int</font> foo ( <font color="Blue">int</font> a) { <font color="Blue">return</font> a + m_base;} <br><br>  <font color="Blue">private</font> : <br>  <font color="Blue">int</font> m_base; <br>  }; <br><br>  A b1 ( <font color="Maroon">10</font> ), b2; <br>  Closure &lt; <font color="Blue">int</font> (A :: *) ( <font color="Blue">int</font> )&gt; a_foo (&amp; b1, &amp; A :: foo); <br>  <font color="Green">// You may notice that the general implementation of the functor also works correctly with pointers to member functions</font> <br>  Functor &lt; <font color="Blue">int</font> (A :: *) ( <font color="Blue">int</font> )&gt; b_foo (&amp; A :: foo); <br><br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; a_foo ( <font color="Maroon">20</font> ) &lt;&lt; <font color="Maroon">""</font> &lt;&lt; b_foo (&amp; b2, <font color="Maroon">20</font> ) &lt;&lt; <font color="Maroon">""</font> &lt;&lt; b_foo (&amp; b1, <font color="Maroon">20</font> ) &lt;&lt; <font color="Blue">std</font> :: <font color="Blue">endl</font> ; <br><br>  The above example is quite simple and clearly demonstrates the basic features of templates with a variable number of parameters.  Analyzing it, you can determine the following general pattern of using templates with a variable number of parameters: <br>  1. The most common template is declared, the last parameter of which is described as a package of parameters.  In the example it is <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> ... Args&gt; <font color="Blue">struct</font> FunctorImpl; <br><br>  2. Partial specializations of this template are defined, specifying one or another part of the parameter package.  In the given example, this definition <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> R, <font color="Blue">typename</font> ... Args&gt; <br>  <font color="Blue">struct</font> FunctorImpl &lt;R (Args ...)&gt; <br><br>  3. In some cases, specialization may require taking into account that the parameter package may be empty.  This, generally speaking, is permissible. <br>  It should be remembered that in the case of template classes, parameters packed in a package can be specified starting from the head of the package.  It is impossible to specify the parameters starting from the tail of the packet (due to the fact that the parameter packet can only close the list of template parameters).  With respect to template functions, there is no such limitation. <br><br><h4>  More complex cases </h4><br>  As noted above, parameter packages can contain not only types, but also non-types.  For example: <br>  // Declare a template that accepts a variable number of integers <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Nums&gt; <br>  <font color="Blue">struct</font> NumsPack <br>  { <br>  <font color="Green">// Declare a static array whose size is equal to the number of actually passed arguments</font> <br>  <font color="Blue">static</font> <font color="Blue">int</font> m_nums [ <font color="Blue">sizeof</font> ... (Nums)]; <br>  <font color="Green">// And also declare an enumeration that saves the number of elements in the array</font> <br>  <font color="Blue">enum</font> {nums_count = <font color="Blue">sizeof</font> ... (Nums)}; <br>  }; <br><br>  <font color="Green">// Initialize the static array</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Nums&gt; <br>  <font color="Blue">int</font> NumsPack &lt;Nums ...&gt; :: m_nums [] = {Nums ...}; <br>  Verification code: <br>  <font color="Blue">typedef</font> NumsPack &lt; <font color="Maroon">10</font> , <font color="Maroon">20</font> , <font color="Maroon">30</font> , <font color="Maroon">40</font> , <font color="Maroon">50</font> &gt; Nums_5; <br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; Nums_5 :: nums_count &lt;&lt; <font color="Blue">std</font> :: <font color="Blue">endl</font> ; <br>  <font color="Blue">for</font> ( <font color="Blue">int</font> n = <font color="Maroon">0</font> ; n &lt;Nums_5 :: nums_count; ++ n) <br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; Nums_5 :: m_nums [n] &lt;&lt; <font color="Maroon">""</font> ; <br>  <font color="Blue">std</font> :: <font color="Blue">cout</font> &lt;&lt; <font color="Blue">std</font> :: <font color="Blue">endl</font> ; <br><br>  prints to the console expected <br>  five <br>  10 20 30 40 50 <br><br>  The sizeof ... (Nums) construction shown in this example is used to get the number of parameters in a package.  In it, Nums is the name of the parameter package.  Unfortunately, the design of templates with a variable number of parameters is such that it is the only thing that can be done with a parameter package (besides its disclosure).  It is impossible to get a parameter from a package by its index, for example, or to perform any more complicated manipulations within the framework of a new draft standard. <br><br>  When opening packages, you can apply more complex patterns.  For example, in the above code, you can do the following replacement: <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Nums&gt; <br>  <font color="Blue">int</font> NumsPack &lt;Nums ...&gt; :: m_nums [] = {Nums * <font color="Maroon">10</font> ...}; <br><br>  which results in a different sequence on the screen: <br>  100 200 300 400 500 <br><br>  In general, the specific type of pattern depends on the context in which it is revealed.  Moreover, the pattern may contain mention of more than one parameter set.  In this case, all the packages mentioned in the pattern will be revealed synchronously, and therefore the number of actual parameters in them must match. <br><br>  This situation can occur when you need to define tuples of values.  Suppose it is necessary to organize a universal functor-composer whose task is to transfer to a certain function the results of the execution of specified functions for a certain argument.  Let there be some set of functions: <br>  <font color="Blue">double</font> fn1 ( <font color="Blue">double</font> a) <br>  { <br>  <font color="Blue">return</font> a * <font color="Maroon">2</font> ; <br>  } <br><br>  <font color="Blue">int</font> fn2 ( <font color="Blue">int</font> a) <br>  { <br>  <font color="Blue">return</font> a * <font color="Maroon">3</font> ; <br>  } <br><br>  <font color="Blue">int</font> fn3 ( <font color="Blue">int</font> a) <br>  { <br>  <font color="Blue">return</font> a * <font color="Maroon">4</font> ; <br>  } <br><br>  And two operations: <br>  <font color="Blue">int</font> test_opr ( <font color="Blue">int</font> a, <font color="Blue">int</font> b) <br>  { <br>  <font color="Blue">return</font> a + b; <br>  } <br><br>  <font color="Blue">int</font> test_opr3 ( <font color="Blue">int</font> a, <font color="Blue">int</font> b, <font color="Blue">int</font> c) <br>  { <br>  <font color="Blue">return</font> a + b * c; <br>  } <br><br>  It is necessary to write a universal functor, the application of the function call operation to which would lead to the execution of such code: <br> <code>test_opr(f1(x), f2(x));</code> <br>  or <br> <code>test_opr3(f1(x), f2(x), f3(x));</code> <br> <br>  The functor must take as input an operation and a list of functions whose results must be passed as arguments to this operation.  The framework for defining such a functor may look as follows: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">class</font> Compositor <br>  { <br>  <font color="Blue">public</font> : <br>  Compositor (Op op, F ... fs); <br>  }; <br><br>  The first problem that needs to be solved is how to save the transferred functions.  To do this, you can apply multiple inheritance from classes that directly store data of a specified type: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> T&gt; <br>  <font color="Blue">struct</font> DataHolder <br>  { <br>  T m_data; <br>  }; <br><br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">class</font> Composer: <font color="Blue">public</font> DataHolder &lt;F&gt; ... <br>  { <br>  <font color="Green">// ...</font> <br>  }; <br><br>  But here the first problem arises - if there are several functions in the list of transferred functions that have the same type, then the code will not compile, because the same class will be present in the list of base classes.  To eliminate this ambiguity, the types in the package can be indexed.  For this, an auxiliary type ‚Äútuple of integers‚Äù will be used, containing numbers from 0 to the specified as parameter N: <br>  <font color="Green">// Determine the class of the actual tuple</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs&gt; <font color="Blue">struct</font> IndexesTuple <br>  { <br>  }; <br><br>  <font color="Green">// Determine the general view of the template used to generate a tuple</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> Num, <font color="Blue">typename</font> Tp = IndexesTuple &lt;&gt;&gt; <br>  <font color="Blue">struct</font> IndexTupleBuilder; <br><br>  <font color="Green">// Define a specialization that generates a sequence of numbers in the form of a package of integer parameters.</font> <br>  <font color="Green">// To do this, the second parameter in the template declaration is not the type of the tuple itself, but the previously formed</font> <br>  <font color="Green">// package.</font>  <font color="Green">To obtain the final package, we inherit from the generated template, adding a new number to the package.</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> Num, <font color="Blue">int</font> ... Idxs&gt; <br>  <font color="Blue">struct</font> IndexTupleBuilder &lt;Num, IndexesTuple &lt;Idxs ... &gt;&gt;: IndexTupleBuilder &lt;Num - <font color="Maroon">1</font> , IndexesTuple &lt;Idxs ..., <font color="Blue">sizeof</font> ... (Idxs) &gt;&gt; <br>  { <br>  }; <br><br>  <font color="Green">// Recursion-terminating specialization.</font>  <font color="Green">Contains a final typedef that defines a tuple with the desired set of numbers</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs&gt; <br>  <font color="Blue">struct</font> IndexTupleBuilder &lt; <font color="Maroon">0</font> , IndexesTuple &lt;Idxs ... &gt;&gt; <br>  { <br>  <font color="Blue">typedef</font> IndexesTuple &lt;Idxs ...&gt; Indexes; <br>  }; <br><br>  As a result, you can use this template as follows: <br>  <font color="Blue">typedef</font> <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Maroon">6</font> &gt; Indexes; <br>  In this case, Indexes will be equivalent to IndexesTuple &lt;0, 1, 2, 3, 4, 5&gt; <br><br>  In order for this class to be used in the implementation of the composer, you must enter an intermediate base class, which will inherit from the classes with data.  In addition, each class with data will be supplied with its own unique index: <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> idx, <font color="Blue">typename</font> T&gt; <br>  <font color="Blue">struct</font> DataHolder <br>  { <br>  DataHolder (T <font color="Blue">const</font> &amp; data): m_data (data) {;} <br><br>  T m_data; <br>  }; <br><br>  <font color="Green">// First, declare a generic pattern that accepts a tuple as input.</font>  <font color="Green">We don‚Äôt need to ad directly in this form, but</font> <br>  <font color="Green">// it is required for subsequent specialization.</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> IdxsTuple, <font color="Blue">typename</font> ... F&gt; <font color="Blue">struct</font> ComposerBase; <br><br>  <font color="Green">// Specialize the general template, retrieving the parameter package from the tuple.</font> <br>  <font color="Green">// In this case, the template is declared with two parameter packages.</font>  <font color="Green">This is allowed, because packages can be uniquely separated.</font> <br>  <font color="Green">// Inheritance uses a pattern in which two parameter packages are mentioned at once.</font>  <font color="Green">This allows you to uniquely compare</font> <br>  <font color="Green">// elements of an integer tuple and a list of function types.</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> ComposerBase &lt;IndexesTuple &lt;Idxs ...&gt;, F ...&gt;: <font color="Blue">public</font> DataHolder &lt;Idxs, F&gt; ... <br>  { <br>  <font color="Green">// And here the pattern contains three packages at once - a package with indices, a package of function types and a package of arguments.</font>  <font color="Green">All this is revealed in the list</font> <br>  <font color="Green">// initialize the constructor.</font> <br>  ComposerBase (F ... fs): DataHolder &lt;Idxs, F&gt; (fs) ... {;} <br>  }; <br><br>  <font color="Green">// Inherit the composer's template from the above template containing the actual data</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> Composer: <font color="Blue">public</font> ComposerBase &lt; <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Blue">sizeof</font> ... (F)&gt; :: Indexes, F ...&gt; <br>  { <br>  Op m_op; <br>  <font color="Blue">public</font> : <br>  <font color="Green">// Declare the constructor</font> <br>  Composer (Op op, F <font color="Blue">const</font> &amp; ... fs): m_op (op), Base (fs ...) {;} <br>  }; <br><br>  In order to complete the composer‚Äôs implementation, it is necessary to define a function call operator.  For convenience of its definition, the type of the return value is first determined: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> Composer: <font color="Green">/ * ... * /</font> <br>  { <br>  Op m_op; <br>  <font color="Blue">public</font> : <br>  <font color="Blue">typedef</font> decltype (m_op ((* (F *) <font color="Blue">NULL</font> ) ( <font color="Maroon">0</font> ) ...)) result_t; <br>  <font color="Green">// ...</font> <br>  }; <br><br>  To determine the type of the return value, another new C ++ construction is used - decltype.  The result of its use (in this case) is the type of value returned by the function.  The design looks a bit strange.  It is equivalent in meaning <br>  decltype (op (fs (0) ...)) <br>  But since the class fs is not defined in the class scope, the operator is applied to the converted to a reference to the type of the function NULL. <br><br>  Now everything is ready to define the function call operator.  Since the classes that store the functions participating in the composition take an integer index as one of the template parameters, this operator is implemented through an auxiliary function to which all the same integer tuple is passed: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> Composer: <font color="Green">/ * ... * /</font> <br>  { <br>  Op m_op; <br>  <font color="Blue">public</font> : <br>  ret_type <font color="Blue">operator</font> () ( <font color="Blue">int</font> x) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> MakeCall (x, Indexes ()); <br>  } <br>  <font color="Blue">private</font> : <br>  <font color="Green">// It uses the same trick as in the definition of the ComposerBase class.</font>  <font color="Green">Tuple type is used to ‚Äúcatch‚Äù</font> <br>  <font color="Green">// package of integer indices</font> <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs&gt; <br>  ret_type MakeCall ( <font color="Blue">int</font> x, IndexesTuple &lt;Idxs ...&gt; <font color="Blue">const</font> &amp;) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> m_op (DataHolder &lt;Idxs, F&gt; :: m_data (x) ...); <br>  } <br>  }; <br>  It remains only to define a function that facilitates the creation of instances of this class: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  Composer &lt;Op, F ...&gt; Compose (Op op, F ... fs) <br>  { <br>  <font color="Blue">return</font> Composer &lt;Op, F ...&gt; (op, fs ...); <br>  } <br><br>  and the composer is ready.  A couple of examples of its use: <br>  <font color="Blue">auto</font> f = MakeOp (test_opr, fn1, fn2); <br>  <font color="Blue">auto</font> ff = MakeOp (test_opr3, fn1, fn2, fn3); <br>  <font color="Blue">auto</font> ff1 = MakeOp (test_opr3, fn1, fn2, [=] ( <font color="Blue">int</font> x) { <font color="Blue">return</font> f (x) * <font color="Maroon">5</font> ;});  <font color="Green">// here, the last parameter to the composer is the lambda function.</font> <br><br>  The complete definition of a template composer class is as follows: <br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> ComposerBase &lt;IndexesTuple &lt;Idxs ...&gt;, F ...&gt;: <font color="Blue">public</font> DataHolder &lt;Idxs, F&gt; ... <br>  { <br>  ComposerBase (F ... fs): DataHolder &lt;Idxs, F&gt; (fs) ... {;} <br>  }; <br><br><br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">struct</font> Composer: <font color="Blue">public</font> ComposerBase &lt; <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Blue">sizeof</font> ... (F)&gt; :: Indexes, F ...&gt; <br>  { <br>  Op m_op; <br>  <font color="Blue">public</font> : <br>  <font color="Blue">typedef</font> ComposerBase &lt; <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Blue">sizeof</font> ... (F)&gt; :: Indexes, F ...&gt; Base; <br>  <font color="Blue">typedef</font> decltype (m_op ((* (F *) <font color="Blue">NULL</font> ) ( <font color="Maroon">0</font> ) ...)) result_t; <br><br>  Composer (Op op, F <font color="Blue">const</font> &amp; ... fs): m_op (op), Base (fs ...) {;} <br><br>  result_t <font color="Blue">operator</font> () ( <font color="Blue">int</font> x) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> MakeCall (x, <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Blue">sizeof</font> ... (F)&gt; :: Indexes ()); <br>  } <br>  <font color="Blue">private</font> : <br><br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs&gt; <br>  result_t MakeCall ( <font color="Blue">int</font> x, IndexesTuple &lt;Idxs ...&gt; <font color="Blue">const</font> &amp;) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> m_op (DataHolder &lt;Idxs, F&gt; :: m_data (x) ...); <br>  } <br>  }; <br><br>  Also this class could be implemented on the basis of STL tuples (std :: tuple).  In this case, the DataHolder class would not be necessary.  In this case, the implementation of the composer will be as follows: <br>  <font color="Blue">template</font> &lt; <font color="Blue">typename</font> Op, <font color="Blue">typename</font> ... F&gt; <br>  <font color="Blue">class</font> TupleComposer <br>  { <br>  Op m_op; <br>  <font color="Blue">std</font> :: tuple &lt;F ...&gt; m_fs; <br>  <font color="Blue">public</font> : <br>  <font color="Blue">typedef</font> decltype (m_op ((* (F *) <font color="Blue">NULL</font> ) ( <font color="Maroon">0</font> ) ...)) result_t; <br><br>  TupleComposer (Op op, F ... fs): m_op (op), m_fs (fs ...) {;} <br><br>  result_t <font color="Blue">operator</font> () ( <font color="Blue">int</font> x) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> MakeCall (x, <font color="Blue">typename</font> IndexTupleBuilder &lt; <font color="Blue">sizeof</font> ... (F)&gt; :: Indexes ()); <br>  } <br>  <font color="Blue">private</font> : <br><br>  <font color="Blue">template</font> &lt; <font color="Blue">int</font> ... Idxs&gt; <br>  result_t MakeCall ( <font color="Blue">int</font> x, IndexesTuple &lt;Idxs ...&gt; <font color="Blue">const</font> &amp;) <font color="Blue">const</font> <br>  { <br>  <font color="Blue">return</font> m_op ( <font color="Blue">std</font> :: get &lt;Idxs&gt; (m_fs) <br>  (x) ...); <br>  } <br>  }; <br><br>  This option looks a little easier. <br><br><h4>  Some more tricks </h4><br>  Expansion of the parameter package in the context of the ‚Äúinitialization list‚Äù provides the programmer with a considerable freedom of action, since in this case the pattern can be a full-fledged expression.  For example, the sum of the numbers passed as arguments can be calculated as follows: <br>  <font color="blue">template</font> &lt; <font color="blue">typename</font> ... T&gt; <br>  <font color="blue">void</font> ignore (T ...) {;} <br><br>  <font color="blue">template</font> &lt; <font color="blue">typename</font> ... T&gt; <br>  <font color="blue">int</font> CalcSum (T ... nums) <br>  { <br>  <font color="blue">int</font> ret_val = <font color="blue">0</font> ; <br>  ignore (ret_val + = nums ...); <br>  <font color="blue">return ret_val;</font> <br>  } <br><br>  Check if there are any positive numbers among the transferred numbers - like this: <br>  <font color="blue">template</font> &lt; <font color="blue">typename</font> ... T&gt; <br>  <font color="blue">bool</font> HasPositives (T ... nums) <br>  { <br>  <font color="blue">bool</font> ret_val = <font color="blue">true</font> ; <br>  ignore (ret_val = ret_val &amp;&amp; nums&gt; = <font color="blue">0</font> ...); <br>  <font color="blue">return ret_val;</font> <br>  } <br><br>  But when using this method, we must not forget that the sequence of calculations of the arguments, strictly speaking, is not defined, and in what order the operations will be performed - it is impossible to say in advance. <br><br>  Summarizing, we can say that templates with a variable number of parameters are a very powerful tool that appears in the C ++ language.  They are deprived of the obvious shortcomings of the existing types of lists (or other emulations of similar behavior), and allow them to express rather complex concepts with a relatively small amount of code.  The constructions given in this article can be compared with similar ones made in the framework of the current standard (for this you can look into the source files boost :: bind, boost :: function, boost :: tuple).  But they are not without some flaws.  Chief among them is the limited number of contexts in which parameter packages can be expanded.  In particular, packages cannot be expanded inside lambda functions (a corresponding request is sent to the standardization committee, but will this request be satisfied?), Packages cannot be expanded into expressions so that you can write, for example, like this: <br>  auto result = args + ...; <br>  package elements cannot be accessed by index. <br></div><p>Source: <a href="https://habr.com/ru/post/101430/">https://habr.com/ru/post/101430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../101418/index.html">Nokia Vice President on the company's upcoming plans</a></li>
<li><a href="../101419/index.html">Problem with servers July 1</a></li>
<li><a href="../101420/index.html">Unprofitable Skype goes to IPO</a></li>
<li><a href="../101423/index.html">Amorphous Metal Alloys</a></li>
<li><a href="../101426/index.html">CDNvideo - new CDN network in Runet</a></li>
<li><a href="../101431/index.html">A simple way to slightly unload initialization javascript on the page</a></li>
<li><a href="../101432/index.html">2 mouse = 2 cursor</a></li>
<li><a href="../101435/index.html">KDE SC 4.5 release</a></li>
<li><a href="../101439/index.html">ShopStyle</a></li>
<li><a href="../101440/index.html">How to avoid becoming a spammer with your cozy mailing list</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>