<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making cards like Tinder on Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tinder - we all know that this is a dating application, where you can simply reject or accept someone with a swipe right or left. This card reader ide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making cards like Tinder on Swift</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2b7/15f/817/2b715f8176b64a1ccc7ec9afd35f7028.png" alt="image"><br><br>  Tinder - we all know that this is a dating application, where you can simply reject or accept someone with a swipe right or left.  This card reader idea is now used in tons of applications.  This way of displaying data is for you if you are tired of using table and collection views.  There are many textbooks on this issue, but this project took me a long time. <br><a name="habracut"></a><br>  You can see the full project on my <a href="https://github.com/Onaeem26/TinderSwipeInterface">Github</a> . <br><br>  First of all, I would like to pay tribute to the Phill Farrugia post on this issue, and then the <a href="https://www.youtube.com/playlist%3Flist%3DPLHDMmeIMXj8VH2Q-ASaS__bwIV7vpyu00">YouTube</a> series in Big Mountain Studios on a similar topic.  So how do we make this interface?  I got help with Phil's publishing on this topic.  Essentially, the idea is to create UIViews and insert them as subviews into the container view.  Then, using the index, we will give each UIView some horizontal and vertical insertion and slightly change its width.  Further, when we swipe one map, all frames of the views will be swapped according to the new index value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We'll start by creating a container view in a simple ViewController. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//MARK: - Properties var viewModelData = [CardsDataModel(bgColor: UIColor(red:0.96, green:0.81, blue:0.46, alpha:1.0), text: "Hamburger", image: "hamburger"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.64, blue:0.96, alpha:1.0), text: "Puppy", image: "puppy"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.63, blue:0.49, alpha:1.0), text: "Poop", image: "poop"), CardsDataModel(bgColor: UIColor(red:0.69, green:0.52, blue:0.38, alpha:1.0), text: "Panda", image: "panda"), CardsDataModel(bgColor: UIColor(red:0.90, green:0.99, blue:0.97, alpha:1.0), text: "Subway", image: "subway"), CardsDataModel(bgColor: UIColor(red:0.83, green:0.82, blue:0.69, alpha:1.0), text: "Robot", image: "robot")] var stackContainer : StackContainerView! //MARK: - Init override func loadView() { view = UIView() view.backgroundColor = UIColor(red:0.93, green:0.93, blue:0.93, alpha:1.0) stackContainer = StackContainerView() view.addSubview(stackContainer) configureStackContainer() stackContainer.translatesAutoresizingMaskIntoConstraints = false configureNavigationBarButtonItem() } override func viewDidLoad() { super.viewDidLoad() title = "Expense Tracker" stackContainer.dataSource = self } //MARK: - Configurations func configureStackContainer() { stackContainer.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true stackContainer.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -60).isActive = true stackContainer.widthAnchor.constraint(equalToConstant: 300).isActive = true stackContainer.heightAnchor.constraint(equalToConstant: 400).isActive = true }</span></span></code> </pre> <br>  As you can see, I created my own class called SwipeContainerView and simply configured stackViewContainer using automatic constraints.  Nothing wrong.  The SwipeContainerView will be 300x400 in size and will be centered on the X axis and only 60 pixels above the middle of the Y axis. <br><br>  Now that we have configured the stackContainer, we will go to the StackContainerView subclass and load all kinds of maps into it.  Before this, we will create a protocol that will have three methods: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  Think of this protocol as a TableViewDataSource.  Compliance of our ViewController class with this protocol will allow transferring information about our data to the SwipeCardContainer class.  It has three methods: <br><br><ol><li>  <code>numberOfCardsToShow () -&gt; Int</code> : Returns the number of cards we need to show.  This is just a dataset counter. </li><li>  <code>card(at index: Int) -&gt; SwipeCardView</code> : returns SwipeCardView (we will create this class in one moment) </li><li>  <code>EmptyView</code> -&gt; We will not do anything with it, but once all the cards have been removed, calling this delegate method will return an empty view with some message (I will not implement it in this particular lesson, try it yourself) </li></ol><br>  Check the view controller with this protocol: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewModelData.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>() card.dataSource = viewModelData[index] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> card } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  In the first method, the number of elements in the data array will be returned.  In the second method, create a new SwipeCardView () instance and send the array data for this index, and then return the SwipeCardView instance. <br><br>  SwipeCardView is a subclass of UIView, in which there is a UIImage, UILabel and a gesture recognizer.  More on this later.  We will use this protocol to communicate with the container view. <br><br><pre> <code class="swift hljs">stackContainer.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  When the above code works, the reloadData function is called, which then calls these data source functions. <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">StackViewContainer</span></span>: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { . . <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSource: <span class="hljs-type"><span class="hljs-type">SwipeCardsDataSource?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { reloadData() } } ....</code> </pre> <br>  ReloadData function: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reloadData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } setNeedsLayout() layoutIfNeeded() numberOfCardsToShow = datasource.numberOfCardsToShow() remainingcards = numberOfCardsToShow <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) } }</code> </pre> <br>  In the reloadData function, we first get the number of cards and store it in the variable numberOfCardsToShow.  Then assign it to another variable named remainingCards.  In the for loop, we create a map that is an instance of SwipeCardView using the index value. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) }</code> </pre> <br>  In fact, we want at least 3 cards to appear at a time.  Therefore, we use the min function.  CardsToBeVisible is a constant equal to 3. If numberOfToShow is greater than 3, then only three cards will be displayed.  We create these maps from the protocol: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span></code> </pre> <br>  The addCardView () function is simply used to insert maps as subviews. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cardView: SwipeCardView, atIndex index: Int)</span></span></span></span> { cardView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addCardFrame(index: index, cardView: cardView) cardViews.append(cardView) insertSubview(cardView, at: <span class="hljs-number"><span class="hljs-number">0</span></span>) remainingcards -= <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  In this function, we add cardView to the view hierarchy, and by adding cards as a subview, we reduce the remaining cards by 1. Once we add cardView as a subview, we set the frame of these cards.  For this we use another function addCardFrame (): <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: Int, cardView: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cardViewFrame = bounds <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> horizontalInset = (<span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.horizontalInset) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> verticalInset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verticalInset cardViewFrame.size.width -= <span class="hljs-number"><span class="hljs-number">2</span></span> * horizontalInset cardViewFrame.origin.x += horizontalInset cardViewFrame.origin.y += verticalInset cardView.frame = cardViewFrame }</code> </pre> <br>  This addCardFrame () logic is taken directly from Phil's post.  Here we set the map frame according to its index.  The first card with index 0 will have a frame, just like a container.  Then we change the origin of the frame and the width of the map in accordance with the insert.  Thus, we add the card a little to the right of the card above, reduce its width, and also necessarily pull the cards down to create the feeling that the cards are stacked on top of each other. <br><br>  Once this is done, you will see that the cards are stacked on top of each other.  Pretty good! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bee/8f0/83e/bee8f083e7dfc5e9dbc70ed6a95d398a.png" alt="image"><br><br>  However, now we need to add a swipe gesture to the map view.  Let's now turn our attention to the SwipeCardView class. <br><br><h3>  SwipeCardView </h3><br>  The swipeCardView class is a regular subclass of UIView.  However, for reasons known only to Apple engineers, it is incredibly difficult to add shadows to a UIView with a rounded corner.  To add shadows to map views, I create two UIViews.  One of them is shadowView, and then swipeView to it.  Essentially, shadowView has a shadow and that's it.  SwipeView has rounded corners.  On swipeView, I added a UIImageView, UILabel to show data and images. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> swipeView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span></code> </pre> <br>  Configure shadowView and swipeView: <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureShadowView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { shadowView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() shadowView.backgroundColor = .clear shadowView.layer.shadowColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>.black.cgColor shadowView.layer.shadowOffset = <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: <span class="hljs-number"><span class="hljs-number">0</span></span>, height: <span class="hljs-number"><span class="hljs-number">0</span></span>) shadowView.layer.shadowOpacity = <span class="hljs-number"><span class="hljs-number">0.8</span></span> shadowView.layer.shadowRadius = <span class="hljs-number"><span class="hljs-number">4.0</span></span> addSubview(shadowView) shadowView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> shadowView.leftAnchor.constraint(equalTo: leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.rightAnchor.constraint(equalTo: rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.topAnchor.constraint(equalTo: topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureSwipeView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { swipeView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() swipeView.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">15</span></span> swipeView.clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.addSubview(swipeView) swipeView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> swipeView.leftAnchor.constraint(equalTo: shadowView.leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.rightAnchor.constraint(equalTo: shadowView.rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.bottomAnchor.constraint(equalTo: shadowView.bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.topAnchor.constraint(equalTo: shadowView.topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Then I added a gesture recognizer to this kind of map and the recognition function calls the selector function.  This selector function has a lot of scrolling, tilting logic, etc.  Let's get a look: <br><br><pre> <code class="swift hljs"> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handlePanGesture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIPanGestureRecognizer)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> sender.state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .ended: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.transform = .identity card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  The first four lines in the above code are: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y)</code> </pre> <br>  First we get an idea of ‚Äã‚Äãthe gesture.  Next, we use the translation method to find out how many times a user has hit a card.  The third row essentially gets the midpoint of the parent container.  The last line where we set card.center.  When the user swipes the card, the center of the card increases by the translated value x and the translated value y.  To get this anchoring behavior, we essentially change the center point of the map from fixed coordinates.  When the translation of the gestures ends, we return it back to the card.center. <br><br>  In the case of state.ended: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  We check if card.center.x is greater than 400 or if card.center.x is less than -65.  If so, then we discard these cards by changing the center. <br><br>  If swipe right: <br><br><pre> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x + 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  If svayp left: <br><br><pre> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x - 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  If the user ends the gesture in the middle between 400 and -65, then we will reset the center of the map.  We also call the delegate method when the swipe ends.  More on this later. <br><br>  To get this tilt when you swipe on the map;  I will be brutally honest.  I used a bit of geometry and used different perpendicular and base values, and then I used the tan function to get the angle of rotation.  Again, this was just a trial and error method.  Using point.x and container width as two perimeters seemed to work well.  Feel free to experiment with these values. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation)</code> </pre> <br>  Now let's talk about the delegate function.  We will use the delegate function to communicate between SwipeCardView and ContainerView. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> }</code> </pre> <br>  This function will take into account the form in which the swipe occurred, and we will take several steps to remove it from the subviews, and then redo all the frames for the cards under it.  Here's how: <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.removeFromSuperview() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remainingcards &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = datasource.numberOfCardsToShow() - remainingcards addCardView(cardView: datasource.card(at: newIndex), atIndex: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } } }</code> </pre> <br>  First remove this view from the super view.  Once this is done, check if there is any card left.  If so, we will create a new index for the map to be created.  We will create newIndex by subtracting the total number of cards to show with the rest of the cards.  Then we add the map as a subview.  However, this new map will be the lowest, so that the 2 sent by us will essentially guarantee that the frame being added is at the index 2 or at the very bottom. <br><br>  To animate frames of other cards, we will use an index of subviews.  To do this, we will create an array of visibleCards, which will contain all the subviews of the container as an array. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visibleCards: [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subviews <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] ?? [] }</code> </pre> <br>  The problem, however, is that the visibleCards array will have an inverted index of subviews.  Thus, the first card will be third, the second will remain in second place, and the third will be in the first position.  To prevent this from happening, we will run the array of visibleCards in reverse order to get the actual index of the subview, not how they are located in the array of visibleCards. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) }</code> </pre> <br>  So now we will update the frames of the rest of the cardViews. <br><br>  That's all.  This is an ideal way to present a small amount of data. </div><p>Source: <a href="https://habr.com/ru/post/448664/">https://habr.com/ru/post/448664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448654/index.html">Mozilla WebThings - gateway setup</a></li>
<li><a href="../448656/index.html">Big Brother is watching yourself ... or a map with a history of movements in HomeAssistant</a></li>
<li><a href="../448658/index.html">What can be done through the OBD connector in the car</a></li>
<li><a href="../448660/index.html">In this position, you will be a bad developer.</a></li>
<li><a href="../448662/index.html">"Russia 404": the option is not for show</a></li>
<li><a href="../448666/index.html">How we chose the service for electronic document management with customers</a></li>
<li><a href="../448668/index.html">Agile: the biggest ideological issue in IT</a></li>
<li><a href="../448670/index.html">Embedded Systems Interface Design</a></li>
<li><a href="../448672/index.html">Webinar - Two-factor authentication and e-mail in VMware Horizon View infrastructure using products from Aladdin R. D</a></li>
<li><a href="../448674/index.html">Moss and Mammoths (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>