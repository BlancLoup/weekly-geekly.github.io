<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating systems from scratch; level 1 (upper half)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's time for the next part. This is the second half of the translation labs №1 . In this release we will write peripheral drivers (timer, GPIO, UART)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating systems from scratch; level 1 (upper half)</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" width="300" src="https://habrastorage.org/webt/xe/fo/_b/xefo_bq51g7flcuspvxcqv7buvm.gif">  It's time for the next part.  This is the second half of the translation <a href="https://web.stanford.edu/class/cs140e/assignments/1-shell/">labs №1</a> .  In this release we will write peripheral drivers (timer, GPIO, UART), we will implement the XMODEM protocol and one utility.  Using all this we will write a command shell for our kernel and a bootloader that will allow us not to poke the microSD card back and forth. </p><br><p>  <a href="https://habrahabr.ru/post/351082/">The younger half</a> . <br>  Start reading is worth with <a href="https://habrahabr.ru/post/349248/">zero labs</a> . </p><a name="habracut"></a><br><h2 id="faza-3-ne-rakovina-not-a-seashell">  Phase 3: <em>Not</em> a Seashell </h2><br><img align="right" width="250" src="https://habrastorage.org/webt/el/sp/fk/elspfkqphnjqduv6ghenmeryqho.jpeg"><br><p>  This time we will write a couple of drivers for the integrated peripherals.  We are interested in the built-in timer, GPIO and UART.  They will be enough for us to write the built-in command line, and a little later it will come in handy for creating a bootloader (which will somewhat simplify further work). </p><br><blockquote>  <strong>What is a driver?</strong> <br><br>  The term <em>driver</em> or device driver is software that directly interacts with a certain hardware device, controls it, etc.  Drivers provide a higher level interface for the devices they control.  Operating systems interact with device drivers to build an even higher level of abstraction over them (for the sake of convenience, of course!).  For example, the Linux kernel provides ALSA (Advanced Linux Sound Architecture), an API for audio that interacts with drivers, which in turn communicate directly with sound cards. </blockquote><br><h3 id="subfaza-a-nachalo-raboty">  Subphase A: Getting Started </h3><br><p> In the rest of the assignment, we will work inside the turnip <code>os</code> , which will be used not only in this part, but throughout the rest of the course.  It is this repository that will eventually become the operating system. </p><br><p>  I recommend the following directory structure for the lab and everything else in relation to this course: </p><br><pre> <code class="hljs cpp">cs140e ├── <span class="hljs-number"><span class="hljs-number">0</span></span>-blinky │ ├── Makefile │ ├── phase3 │ └── phase4 ├── <span class="hljs-number"><span class="hljs-number">1</span></span>-shell │ ├── ferris-wheel │ ├── getting-started │ ├── <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>-vec │ ├── ttywrite │ ├── <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> │ └── xmodem └── os ├── Makefile ├── bootloader ├── kernel ├── pi ├── <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> └── <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span></code> </pre> <br><p>  Convenient and neat.  <code>0-blinky</code> and <code>1-shell</code> belong to the previous and current labs, and you can get <code>os</code> here like this: </p><br><pre> <code class="hljs lua">git clone https://web.stanford.edu/class/cs140e/<span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.git <span class="hljs-built_in"><span class="hljs-built_in">os</span></span> git checkout master</code> </pre> <br><p>  Make sure everything is properly located and run <code>make</code> inside <code>os/kernel</code> .  If all goes well, the command will succeed. </p><br><h4 id="struktura-proekta">  Project structure </h4><br><p>  The <code>os</code> directory contains the following set of subdirectories: </p><br><ul><li>  <code>pi</code> is a library containing drivers and some low-level code for our OS. </li><li>  <code>volatile</code> - the second version of the same library from phase 2 </li><li>  <code>std</code> - minimal stub of the standard Rust library </li><li>  <code>bootloader</code> - bootloader, which we will write in phase 4 </li><li>  <code>kernel</code> - the main core of the OS </li></ul><br><p>  All driver code is in the <code>pi</code> library.  <code>pi</code> uses the <code>volatile</code> library and (optionally) <code>std</code> .  <code>kernel</code> and <code>bootloader</code> use <code>pi</code> to communicate with devices.  And besides this depend on <code>std</code> .  <code>volatile</code> does not depend on anything.  Graphically, these relationships will look something like this: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/f56/601/76bf566010cd9299e88ae5ab3c2e9d55.svg"><br><h4 id="proshivka">  Firmware </h4><br><p>  We need to update the firmware raspberry before continuing.  You can download this all with the command <code>make fetch</code> from the <code>os</code> directory.  It will load the necessary materials into the <code>files/</code> daddy.  Copy <code>firmware/bootcode.bin</code> , <code>firmware/config.txt</code> and <code>firmware/start.elf</code> to the root of the microSD card.  You can copy <code>act-led-blink.bin</code> from the last part, rename to <code>kernel8.img</code> .  So you can check that everything works.  There should blink green LED on the very Malinka. </p><br><h4 id="obnovlyonnyy-volatile">  Updated <code>volatile</code> </h4><br><p>  This library from the <code>os</code> folder is slightly different from the code that was studied in phase 2. The changes make it a little easier to use this in the context of writing device drivers.  The main differences are: </p><br><ol><li>  <code>UniqueVolatile</code> replaced by <code>Unique&lt;Volatile&gt;</code> </li><li>  Added type <code>Reserved</code> , which can absolutely nothing and is used as a stub </li></ol><br><p>  There is another, more significant difference.  All types from the library wrap <code>T</code> , not <code>*mut T</code>  This allows us to use any raw addresses without wrapping them, but casting them like this: <code>0x1000 as *mut Volatile&lt;T&gt;</code> .  In addition, we can specify a structure containing fields wrapped in <code>Volatile</code> .  Something like this: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registers</span></span></span></span> { REG_A: Volatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;, REG_B: Volatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; } <span class="hljs-comment"><span class="hljs-comment">//    .  `Registers`   `0x4000`  . //     `u32`     `u8`      // (. ). let x: *mut Registers = 0x4000 as *mut Registers; //       `unsafe`. //   Rust        unsafe { //   Rust      (*x).REG_A.write(434); let val: u8 = (*x).REG_B.read(); }</span></span></code> </pre> <br><blockquote>  <strong>What is <code>#[repr(C)]</code> ?</strong> <br><br>  The postscript <code>#[repr(C)]</code> forces Rust to form structures in memory just like in Sishechka.  Without this, Rust has the right to optimize the order of fields and indents in the memory between them.  When we work with raw pointers, in most cases we mean quite a specific structure in memory.  Accordingly, <code>#[repr(C)]</code> allows us to state that Rust will allocate the structure in memory exactly as we assume. </blockquote><br><h4 id="yadro">  Core </h4><br><p>  The <code>os/kernel</code> directory contains blanks for our OS kernel code.  A call to <code>make</code> inside this directory will collect our nucleolus.  The result of the build will be in the subdirectory <code>build/</code> .  In order to run this business you will need to copy <code>build/kernel.bin</code> to the root of the microSD card under the name <code>kernel8.img</code> .  Currently, the kernel does nothing.  By the end of this phase, the core will contain an interactive text shell with which to talk. </p><br><p>  The <code>kernel</code> crate depends on the crate <code>pi</code> .  You can see <code>extern crate pi;</code>  in <code>kernel/src/kmain.rs</code> and an entry about this in <code>Cargo.toml</code> .  Those.  We can unambiguously use all types and constructions declared in <code>pi</code> . </p><br><h4 id="dokumentaciya">  Documentation </h4><br><p>  When writing drivers, the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">manual on the BCM2837 peripherals</a> is very useful <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">to us</a> . </p><br><h3 id="subfaza-b-sistemnyy-taymer">  Subphase B: System Timer </h3><br><img align="right" width="300" src="https://habrastorage.org/webt/5e/0q/da/5e0qdabefzeatjkwov_yvpoqah0.gif"><br><p>  In this subphase, we will write a driver for the built-in timer.  The main work is carried out in the files <code>os/pi/src/timer.rs</code> and <code>os/kernel/src/kmain.rs</code> .  The timer is documented on page 172 (section 12) of the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">BCM2837 peripheral manual</a> . </p><br><p>  First, look at the code that already exists in <code>os/pi/src/timer.rs</code> .  At least these parts are: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMER_REG_BASE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = IO_BASE + <span class="hljs-number"><span class="hljs-number">0x3000</span></span>; <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registers</span></span></span></span> { CS: Volatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;, CLO: ReadVolatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;, CHI: ReadVolatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;, COMPARE: [Volatile&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;; <span class="hljs-number"><span class="hljs-number">4</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span> { registers: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Registers } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Timer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Timer { Timer { registers: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(TIMER_REG_BASE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Registers) }, } } }</code> </pre> <br><p>  There is one line of code with <code>unsafe</code> that you should pay attention to first.  In this line, the <code>TIMER_REG_BASE</code> address in <code>*mut Registers</code> cast, and then immediately turned into <code>&amp;'static mut Registers</code> .  In fact, we are reporting growing that we should have a static link to the structure at <code>TIMER_REG_BASE</code> . </p><br><p>  What exactly is there at <code>TIMER_REG_BASE</code> ?  On page 172 you can find the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">manual</a> that <code>0x3000</code> is offset from the beginning of the periphery for the timer.  Those.  <code>TIMER_REG_BASE</code> is the address from which the registers of the timer itself begin.  After one line with <code>unsafe</code> we can use the <code>registers</code> field for quite secure access to all this.  For example, we can read the register <code>CLO</code> using <code>self.registers.CLO.read()</code> or write to <br>  <code>CS</code> with <code>self.registers.CS.write()</code> . </p><br><blockquote>  <strong>Why can't we write to the <code>CLO</code> and <code>CHI</code> registers?</strong>  [restricted-reads] 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The BCM2837 documentation states that the <code>CLO</code> and <code>CHI</code> registers are read only.  Our code provides this property.  How?  What prevents us from writing to <code>CLO</code> and <code>CHI</code> ? </blockquote><br><hr><br><blockquote>  <strong>What exactly is not safe?</strong> <br><br>  In short, <code>unsafe</code> is a marker for the Rust compiler, saying that you take control of memory security.  The compiler will not protect you from memory problems in these pieces of code.  In <code>unsafe</code> portions of the code, Rust allows you to do everything that you can do in Nyashny Xi.  Can <del>  rob caravans </del>  free enough to cast one type to another, play with raw signs, create lifetimes. <br><br>  However, note that the code in the <code>unsafe</code> block can be <em>very dangerous</em> .  You need to make sure that what you are doing in the insecure section is actually safe.  It is more complicated than it seems at first glance.  Especially for the reason that the security concepts in Rust are stricter than in other languages.  We must try not to use <code>unsafe</code> at all.  As far as possible of course.  For things like operating systems, we need to use <code>unsafe</code> if we want to communicate directly with the hardware.  But we will limit the use of it as much as possible. <br><br>  If you want to read the moar about <code>unsafe</code> - you should look at <a href="https://doc.rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html">chapter 1 of the Nomicon</a> .  There and further on this little book you can learn a lot from the useful for a variety of strong witchcraft in Rust. </blockquote><br><h4 id="realizaciya-drayvera">  Driver implementation </h4><br><p>  Implement <code>Timer::read()</code> from <code>os/pi/src/timer.rs</code> .  Then the <code>current_time()</code> , <code>spin_sleep_us()</code> and <code>spin_sleep_ms()</code> methods can be found nearby.  Comments and the names of these functions fully indicate their expected functionality.  To implement <code>Timer::read()</code> will need to read the BCM2837 documentation in the appropriate section.  At the very least, you should understand which registers will need to be read to get the entire 64-bit value of the timer.  You can build <code>pi</code> crate with the <code>cargo build</code> .  Although it will be faster to simply check the correctness of the written with the help of <code>cargo check</code> . </p><br><h4 id="testirovanie-drayvera">  Driver testing </h4><br><p>  It will not be superfluous to make sure that the <code>spin_sleep_ms()</code> function is implemented correctly.  To do this, write the appropriate code in <code>kernel/src/kmain.rs</code> . </p><br><p>  Copy the LED flashing code from phase 4 zero labs.  Instead of the sleep function, which is simply spinning in a loop, you should use our <code>spin_sleep_ms()</code> function to create pauses between blinks.  Recompile the kernel and load it onto a memory card named <code>kernel8.img</code> .  Start everything up and make sure that the LED is blinking at the frequency you have planned.  Try to set a different delay size and make sure everything works.  Yes, constantly poking back and forth microsd-card is quite tiring.  By the end of this part we will have a bootloader that will solve this problem. </p><br><p>  If your implementation of the driver for the timer works, then you can go to the next subphase. </p><br><h3 id="subfaza-c-gpio">  Subphase C: GPIO </h3><br><p>  In this subphase, we will write a generic, independent of a specific pin number, GPIO driver.  The main work is carried out in the files <code>os/pi/src/gpio.rs</code> and <code>os/kernel/src/kmain.rs</code> .  GPIO documentation can be found on page 89 (section 6) of the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">BCM2837 peripherals manual</a> . </p><br><h4 id="konechnye-avtomaty">  State machines </h4><br><img align="right" width="300" src="https://habrastorage.org/webt/ky/vq/iy/kyvqiyboj_hkq7loatvhftziot4.png"><br><p>  All hardware devices can in fact be considered <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">finite automata</a> ( <a href="https://en.wikipedia.org/wiki/Finite-state_machine">eng</a> ).  They are initialized with some state and go to other states explicitly or not.  At the same time, the devices provide different functionality depending on the current state.  In other words, in some specific states, only a certain set of transitions to other states is operable. </p><br><p>  Most programming languages ​​make it impossible to precisely follow the semantics of finite automata.  But this certainly does not apply to Rust.  Rust allows us to follow this semantics quite clearly.  This is what we will use to implement a more secure GPIO driver.  Our driver will ensure that each GPIO pin will always be used correctly.  At compile time. </p><br><blockquote>  * <em>It looks like some kind of research ...</em> <br><br>  You caught me.  In essence, this is my area of ​​study at this time.  - <a href="https://sergio.bz/">Sergio</a> </blockquote><p>  Below you can see the state diagram for a subset of the GPIO state machine property (for one pin): </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4be/988/562/4be988562f7c765cc7c7568ad7c0707a.svg"><br><p>  Our goal is to implement it all in Rust.  To begin with, this diagram tells us sobsna: </p><br><ul><li>  GPIO starts from <code>START</code> </li><li>  From the <code>START</code> state we can go to the following states: <br><ol><li>  <code>ALT</code> , which has no transitions to other states </li><li>  <code>OUTPUT</code> - with two available transitions to itself: <code>SET</code> and <code>CLEAR</code> </li><li>  <code>INPUT</code> - with one jump by name <code>LEVEL</code> </li></ol></li></ul><br><blockquote>  <strong>What transitions did you use in lab 0?</strong>  [blinky-states] <br><br>  When you wrote the code for Phase 4 from Labs 0, you essentially implicitly implemented a subset of our state machine.  What state transitions did this take place? </blockquote><p>  We will use the Rust type system to provide assurances that the pin can only <code>SET</code> and <code>CLEAR</code> if it is in the <code>OUTPUT</code> state and only in <code>LEVEL</code> if in the <code>INPUT</code> state.  Take a look at the <code>GPIO</code> structure declaration from the <code>pi/src/gpio.rs</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span></span>&lt;State&gt; { pin: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, registers: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Registers, _state: PhantomData&lt;State&gt; }</code> </pre> <br><p>  The structure has one generalized argument named <code>State</code> .  It is used only by <code>PhantomData</code> and no one else.  Actually for the sake of such <a href="https://doc.rust-lang.org/nightly/std/marker/struct.PhantomData.html">PhantomData</a> it exists: in order to convince Rust that the structure somehow uses a generalized argument.  We are going to use <code>State</code> as a marker of the state of the <code>Gpio</code> .  At the same time, we still need to ensure that a specific value for this parameter cannot be created. </p><br><p>  Macro <code>state!</code>  generates types that seem to be there, but you can't create them.  In this case, it generates a list of states in which <code>Gpio</code> can be: </p><br><pre> <code class="rust hljs">states! { Uninitialized, Input, Output, Alt } <span class="hljs-comment"><span class="hljs-comment">//        -  : enum Input { }</span></span></code> </pre> <br><p>  It <em>looks</em> weird.  Why do we need to create enums without any possible values?  They have one nice touch.  They can not be created.  But they can be used as markers.  No one can ever pass us a value of type <code>Input</code> because it cannot be created.  They live and exist only at the level of types and nowhere else. </p><br><p>  Then you can implement methods for each state with the appropriate set of transitions: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Gpio&lt;Output&gt; { <span class="hljs-comment"><span class="hljs-comment">///   pub fn set(&amp;mut self) { ... } ///   pub fn clear(&amp;mut self) { ... } } impl Gpio&lt;Input&gt; { ///      pub fn level(&amp;mut self) -&gt; bool { ... } }</span></span></code> </pre> <br><p>  This is similar to the guarantee that <code>Gpio</code> can be <code>Gpio</code> only in a strictly defined way, depending on the state.  Not bad, huh?  But how do we achieve these states?  To do this, we have the <code>Gpio::transition()</code> method: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Gpio&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span></span>&lt;S&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Gpio&lt;S&gt; { Gpio { pin: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pin, registers: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.registers, _state: PhantomData } } }</code> </pre> <br><p>  This method allows you to easily and freely transfer <code>Gpio</code> from one state to another.  Receives <code>Gpio</code> in state <code>T</code> and gives <code>Gpio</code> in state <code>S</code>  Note that it works for any <code>S</code> and <code>T</code>  We must use this method very carefully.  If we make a mistake in all this, then our driver can be considered written incorrectly. </p><br><p>  In order to use <code>transition()</code> we need to specify the type <code>S</code> for <code>Gpio&lt;S&gt;</code> .  We provide Rust with enough information so that he can get it all out on his own.  For example, the implementation of the method <code>into_output</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_output</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Gpio&lt;Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.into_alt(Function::Output).transition() }</code> </pre> <br><p>  This method requires that its return type be <code>Gpio&lt;Output&gt;</code> .  When the Rust type system looks at the <code>transition()</code> call, it looks for a <code>Gpio::transition()</code> method that <code>Gpio&lt;Output&gt;</code> returns.  It finds a method that returns <code>Gpio&lt;S&gt;</code> , which exists for any <code>S</code>  Accordingly, instead of <code>S</code> you can safely substitute <code>Output</code> .  As a result, it converts <code>Gpio&lt;Alt&gt;</code> (from the function <code>into_alt</code> ) to <code>Gpio&lt;Output&gt;</code> . </p><br><blockquote>  <strong>What will be wrong if the client can transfer arbitrary states?</strong>  [fake-states] <br><br>  Think about what happens if we let the user code freely choose the initial state for the <code>Gpio</code> structure.  What can go wrong? </blockquote><br><hr><br><blockquote>  <strong>Why is this all possible only in Rust?</strong> <br><br>  Notice the little fact that <code>into_</code> transitions use the semantics of the move.  This means that as soon as <code>Gpio</code> goes into another state, it can no longer be available in the previous state.  Until the type implements <code>Clone</code> , <code>Copy</code> and some other duplication methods, the reverse transition is not available.  No other language can do that.  Even <code>C++</code> .  Such a witch at the time of compiling with all the guarantees is only here.  (A guru in the pros or anything else may try to challenge this statement) </blockquote><br><h4 id="realizaciya-drayvera-1">  Driver implementation </h4><br><p>  Write all the necessary code instead of <code>unimplemented!()</code> In the file <code>pi/src/gpio.rs</code>  From the comments and signatures of all these methods can be understood <del>  by deduction </del>  their expected functionality.  It is worth it to consult the documentation (page 89, section 6 of the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">BCM2837 manual</a> ).  Do not forget about the utility of <code>cargo check</code> . </p><br><blockquote>  Hint: remember that you can create arbitrary lexical scopes with curly braces <code>{ ... }</code> . </blockquote><br><h4 id="testirovanie-drayvera-1">  Driver testing </h4><br><p>  Obviously, to test the driver, we need to write some code in the <code>kernel/src/kmain.rs</code> . </p><br><p>  This time, instead of reading / writing directly into the registers themselves, we will use our driver to flash the LED.  By turning on / off the GPIO pin number 16. At the same time, the whole code will look much cleaner and more elegant.  Compile the kernel, load it on the card with the name <code>kernel8.img</code> and run the malinka with it all.  The LED should flash exactly the same as before. </p><br><p>  Now you can connect more LEDs.  Use the GPIO pins numbered 5, 6, 13, 19, and 26. Refer to the diagram with pin numbers from the zero labs to determine their physical location.  Let the core flash as many LEDs as you wish! </p><br><blockquote>  <strong>Which blinking pattern have you chosen?</strong>  [led-pattern] <br><br>  What scheme did you decide to turn on / off the LEDs?  You can choose many options to your taste.  But if the choice is tight - you can turn them on and off in a circle. <img src="https://habrastorage.org/getpro/habr/post_images/e69/067/2be/e690672be6ea89379572f91082dbb110.svg" alt="image"></blockquote><p>  As soon as your GPIO driver becomes fully operational, you can proceed to the next subphase. </p><br><h3 id="subfaza-d-uart">  Subphase D: UART </h3><br><p>  In this subphase, we will write a mini UART device driver, which is embedded in the percent of our raspberry.  Most of the work is done in the files <code>os/pi/src/uart.rs</code> and <code>os/kernel/src/kmain.rs</code> .  The Mini UART is documented on pages 8 and 10 (sections 2.1 and 2.2) of the <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">BCM2837 manual</a> . </p><br><h4 id="uart-universal-asynchronous-rxtx">  UART: Universal Asynchronous RX / TX </h4><br><p>  <abbr title="universal asynchronous receiver-transmitter"><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a> ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2591%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA">ru</a> )</abbr> or Universal Synchronous ReceiverTransmitter is a device and a serial protocol for communicating hardware with just two wires.  These are the same two wiring (rx / tx) that were used in phase 1 of the zero labs in order to connect the UART device on the CP2102 USB module to the UART device on a malink.  On the UART, you can send any data: text, binary files, pictures with cats and what else there is enough imagination.  As an example, right in the next sub-phase, we will write an interactive shell that will read from the UART on the Malinka and write to the UART on the CP2102.  In phase 4, we will transfer binary information in about the same way. </p><br><p>  The UART protocol has several configuration parameters.  Both the receiver and transmitter must be configured identically in order for it to work.  These are the parameters: </p><br><ul><li>  <strong>Data Size</strong> - the length of one frame with data (8 or 9 bits) </li><li>  <strong>Parity Bit</strong> - whether to send the parity bit (control bit) after the data </li><li>  <strong>Stop Bits</strong> - how many bits will be used to determine if the data has been transmitted (1 or 2 bits) </li><li>  <strong>Baud Rate</strong> - transmission rate in bits per second </li></ul><br><p>  Mini UART does not support parity bits and only supports one stop bit.  Thus, we only need to configure the baud rate and frame length.  A little more about the UART itself can be found in a document called <a href="https://web.stanford.edu/class/cs140e/notes/lec4/uart-basics.pdf">Basics of UART Communication</a> (needs translation?). </p><br><h4 id="realizaciya-drayvera-2">  Driver implementation </h4><br><p>  At this stage, we have all the necessary tools for writing a device driver without having to paint each step.  My congratulations! </p><br><p>  The task is to implement everything you need in the file <code>pi/src/uart.rs</code>  You need to add the contents of the <code>Registers</code> structure.  In this case, use a variant of the <code>Volatile</code> type with the <em>minimum necessary</em> set of possibilities for each register.  Registers that are read-only should use <code>ReadVolatile</code> .  If only <code>WriteVolatile</code> allowed, then <code>WriteVolatile</code> .  For reserved space there is <code>Reserved</code> .      <code>new()</code>    115200 ( 270)      8 .     <code>unimplemented!()</code>  ,      .     <code>fmt::Write</code> , <code>io::Read</code>  <code>io::Write</code>   <code>MiniUart</code> . </p><br><blockquote> :      <code>LCR</code> , <code>BAUD</code>  <code>CNTL</code>   <code>new</code> / <br><br> :   GPIO   . </blockquote><br><h4 id="testirovanie-drayvera-2">   </h4><br><p>  ,   ( <code>kernel/src/kmain.rs</code> ),       .       : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { write_byte(read_byte()) }</code> </pre> <br><p>  <code>screen /dev/&lt;_&gt; 115200</code>    UART. <code>screen</code>       TTY  .   ,          .  Those.     .          : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { write_byte(read_byte()) write_str(<span class="hljs-string"><span class="hljs-string">"&lt;-"</span></span>) }</code> </pre> <br><p>       ,     —     . </p><br><h3 id="subfaza-e-the-shell">  E: The Shell </h3><br><p>          UART        .      <code>os/kernel/src/console.rs</code> , <code>os/kernel/src/shell.rs</code>  <code>os/kernel/src/kmain.rs</code> . </p><br><h4 id="console"> <code>Console</code> </h4> <br><img title="My feelings from the constant replay of the word console in this part" align="right" width="300" src="https://habrastorage.org/webt/vh/6r/2k/vh6r2kfoqsmlnhejqikmsle1yuk.gif"><br><p>  ,   ,   -    /  . Unix        <code>stdin</code>  <code>stdout</code>   .    <code>Console</code>    . <code>Console</code>     <code>kprint!</code>  <code>kprintln!</code>  .       ,   <code>print!</code>  <code>println!</code>  .    .     <code>Console</code>  ,     . </p><br><p>   <code>os/kernel/src/console.rs</code> .        <code>Console</code> .    <em></em> -  <code>MiniUart</code> .        .       .       <code>MiniUart</code>     <code>MiniUart</code>   <code>Console</code> . </p><br><h4 id="globalnaya-izmenyaemost">   </h4><br><p>     —  ,    .    Rust.    Rust          .        ,     ?    ,    <code>unsafe</code> .  :   Rust'y,     , ..   ,          ""   .      ,  . Rust         .     : </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      ! fn make_mut&lt;T&gt;(value: &amp;T) -&gt; &amp;mut T { unsafe { /*      */ } }</span></span></code> </pre> <br><p>      .    .      ,  ,    <code>unsafe</code>    Rust. ,         .     "      ".  Those.            .   . </p><br><p>  ,       .  ,                    .           ,   ( <code>&amp;</code> ).      ,        ( <code>&amp;T -&gt; &amp;mut</code>    ). </p><br><p>      .   ,      ,   : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span></span>&lt;T&gt;(value: &amp;T) -&gt; Locked&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { lock(value); cast value to Locked&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Locked&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { unlock(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value) } }</code> </pre> <br><p>    <a href="https://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html">Mutex</a>       .   —  ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mut</span></span></span></span>&lt;T&gt;(value: &amp;T) -&gt; Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref_count(value) != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>() } ref_count(value) += <span class="hljs-number"><span class="hljs-number">1</span></span>; cast value to Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { ref_count(value) -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><p>   ,   <a href="https://doc.rust-lang.org/nightly/std/cell/struct.RefCell.html">RefCell::borrow_mut()</a> .      —      ,     : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mut</span></span></span></span>&lt;T&gt;(value: &amp;T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref_count(value) != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ref_count(value) += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(cast value to Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt;) } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Mut&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { ref_count(value) -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><p>   <a href="https://doc.rust-lang.org/nightly/std/cell/struct.RefCell.html">RefCell::try_borrow_mut()</a> .        " ":    .  <code>Console</code>    <code>Mutex</code> .   <code>std::Mutex</code>        —     .    .     <code>kernel/src/mutex.rs</code> .       ,     ,      ,     Rust.         <code>Mutex</code> ,   ,    . </p><br><p>  So.     <code>CONSOLE</code>  <code>kernel/src/console.rs</code> .       <code>kprint!</code>  <code>kprintln!</code> ,     .  ,       <code>Console</code> —             <code>Console</code> .     <code>CONSOLE</code>     <code>Console</code> . </p><br><blockquote> <strong>Rust          <code>Sync</code> .</strong> <br><br>      <code>T</code>  <code>static</code> ,   <code>T</code>   <code>Sync</code> .    ,  Rust       .        , Rust  ,    .  <code>Send</code>  <code>Sync</code> ,    Rust    . </blockquote><br><hr><br><blockquote> **       <code>&amp;mut T</code> ? [drop-container] <br><br>   ,        ,   <code>Drop</code> .     ,     <code>&amp;mut T</code> ? </blockquote><br><hr><br><blockquote> <strong>   <code>write_fmt</code> ?</strong> [write-fmt] <br><br>   <code>_print</code>  <code>write_fmt</code>   <code>MutexGuard</code> (   <code>Mutex&lt;Console&gt;::lock()</code> .     <code>write_fmt</code>      ? </blockquote><br><h4 id="realizaciya-i-testirovanie-console">    <code>Console</code> </h4><br><p>  ,      <code>unimplemented!()</code>   <code>kernel/src/console.rs</code> .     <code>kprint!</code>  <code>kprintln!</code>  ,     <code>kernel/src/kmain.rs</code> ,       ,      .       ,   <code>print!</code>  <code>println!</code>  .  <code>screen /dev/&lt;-&gt; 115200</code>    . </p><br><blockquote> <strong>      ...</strong> <br><br>    <code>println!</code>       —    Rust.        <code>printf</code> .  Rust   , ,        .      . , ?    . </blockquote><br><hr><br><blockquote> :    <code>Console</code>   :     . </blockquote><br><h4 id="realizaciya-obolochki">   </h4><br><p><img src="https://habrastorage.org/getpro/habr/post_images/da0/be2/6f2/da0be26f288b7f89b876830970c43e68.gif" alt="Finished product"></p><br><p>           .    <code>kernel/src/shell.rs</code> .     <code>Command</code> .  <code>Command::parse()</code>           <code>Command</code> .   <code>parse</code>             <code>args</code>  <code>StackVec</code> ,  <code>buf</code>   .      <code>Command::path()</code> . </p><br><p>      ( <code>Command</code> , <code>StackVec</code> , <code>Console</code>  <code>CONSOLE</code> , <code>kprint!</code> , <code>kprintln!</code>  ,     )    <code>shell</code> .      <code>prefix</code>  ,    .         <code>"&gt; "</code> .        ,      .     <abbr title="Infinitely">ad-infinitum</abbr> .             .        <code>echo</code> . </p><br><p>  ,      : </p><br><ul><li>    <code>echo $a $b $c</code> ,    <code>$a $b $c</code> </li><li>   <code>\r</code>  <code>\n</code>   <code>enter</code> ,    </li><li>  backspace  delete (ASCII 8  127)     </li><li>    (ASCII 7),       </li><li>  <code>unknown command: $command</code>    <code>$command</code> </li><li>     </li><li>     ,   </li><li>     512  </li><li>   64    </li><li>          <code>prefix</code> ,      </li><li>  <code>error: too many arguments</code>      </li></ul><br><p>  <code>shell</code> .     <code>kernel/src/kmain.rs</code> .      SOS,         ,   .       ,   .     —  .      . </p><br><blockquote> : <br><br>   <code>b'a'</code>   <code>u8</code>      <code>'a'</code> <br><br>  <code>\u{b}</code>           ASCII <code>b</code> <br><br>     <code>\r</code>  <code>\n</code>     <br><br>  ,      backspace,  ,   backspace <br><br>  <code>StackVec</code>    <br><br>  <a href="https://doc.rust-lang.org/nightly/std/str/fn.from_utf8.html">std::str::from_utf8</a>      </blockquote><br><hr><br><blockquote> <strong>    <code>std</code> !</strong> <br><br> ,       <code>std</code>   .   .  ,  ,      <code>xargo doc --open</code>   <code>os/std</code> . </blockquote><br><hr><br><blockquote> <strong>       ?</strong> [shell-lookback] <br><br>        .  ,       . </blockquote><br><h2 id="faza-4-zagruzchik">  4:  </h2><br><p>      ,       ,     Raspberry Pi.     <code>os/bootloader/src/kmain.rs</code> </p><br><p>   ,        MicroSD- <em></em> . ,    ,        .         ,  . </p><br><p>   —  "",   ,   XMODEM  UART.         ,     .      <code>ttywrite</code>     .              : </p><br><ul><li>        </li><li>  <code>ttywrite -i -.bin /dev/&lt;-&gt;</code> </li></ul><br><h3 id="zagruzka-dvoichnyh-faylov">    </h3><br><p>   Raspberyy Pi 3     <code>kernel8.img</code>   <code>0x80000</code> .    ,   ,   <code>kernel8.img</code>  <code>0x80000</code>      ARM'    (program counter)  <code>0x80000</code> .     ,         .  ,         <code>0x80000</code> . </p><br><p>     (linker,   ).      .        : ,    .    ,         .          <code>os/kernel/ext/layout.ld</code> (   ).   ,     <code>0x80000</code> .            <code>0x80000</code> . </p><br><p>  ,        ,         <code>0x80000</code> .     .        <code>0x80000</code> .  Those.                  !      .             .          .      .  How? </p><br><h3 id="sozdanie-prostransva">   </h3><br><p>       .     <code>os/bootloader/ext/layout.ld</code> ,   ,    <code>0x4000000</code>     .     ,           <code>0x80000</code> .               <code>kernel_address</code>   <code>config.txt</code> .         <code>bootloader/ext/config.txt</code> . ,        .  Those.     MicroSD-. </p><br><p>       <code>0x80000</code>  <code>0x4000000</code>         ""  . </p><br><blockquote> <strong>  63.5 ?</strong> [small-kernels] <br><br>  ,  ,   ,  .        —           .  ,   .      ? <br><br> ,           .    macOS    -  <code>/System/Library/Kernels/kernel</code> .    <code>/mach_kernel</code> .  Linux  -  <code>/boot/</code>     <code>vmlinuz</code> , <code>vmlinux</code>  <code>bzImage</code> .      ?       63.5 ? </blockquote><br><h3 id="realizaciya-zagruzchika">   </h3><br><p>      <code>bootloader/src/kmain.rs</code> .      ,  ,        .    <code>const</code>   .     <code>jump_to</code> ,       <code>addr</code> .           .         <code>pi</code>   <code>xmodem</code>     UART,           ,     .   ,     . </p><br><p>  ,         XMODEM,      ( 750 ).         .        —          .  ,     —  .     <code>os/kernel/build/kernel.bin</code>     <code>ttywrite</code> .     —     ,       <code>screen</code> . </p><br><blockquote> <strong>  ?</strong> [bootloader-timeout] <br><br>               .        ? </blockquote><br><hr><br><blockquote>      <code>config.txt</code> ,      ! <br><br> : <br><br>    <code>kmain()</code>   15  . <br><br> <a href="https://doc.rust-lang.org/nightly/std/slice/fn.from_raw_parts_mut.html">std::slice::from_raw_parts_mut</a>     . <br><br>  <code>&amp;mut [u8]</code>  <code>io::Write</code> . </blockquote><p> <strong>UPD</strong> <a href="https://habrahabr.ru/post/352414/">  </a> </p></div><p>Source: <a href="https://habr.com/ru/post/351774/">https://habr.com/ru/post/351774/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351764/index.html">Data center with interesting physical protection</a></li>
<li><a href="../351766/index.html">T-commerce: how online sales work with Telegram</a></li>
<li><a href="../351768/index.html">How we changed paid Slack to open-source Rocket.Chat</a></li>
<li><a href="../351770/index.html">Gartner released a new quadrant of monitoring solutions for 2018 (and at the same time missed 2017)</a></li>
<li><a href="../351772/index.html">Minifikation programming language</a></li>
<li><a href="../351782/index.html">Ping-Pong algorithm or criticism of the Reverse Polish Notation</a></li>
<li><a href="../351784/index.html">15 ways to turn brainstorming into a “fire” result</a></li>
<li><a href="../351790/index.html">Benefits, risks and secrets of in-app advertising</a></li>
<li><a href="../351792/index.html">Profile of non-ideal customer. What clients to refuse and why it is vital</a></li>
<li><a href="../351794/index.html">Seminar Dino Esposito March 29 in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>