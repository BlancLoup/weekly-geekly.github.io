<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QtQuick / QML as a game UI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article has been updated with useful comments. Many thanks to all the commentators for important clarifications and additions. 

 In games with a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QtQuick / QML as a game UI</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cf7/ae7/bf9/cf7ae7bf9b3a4905bf24974292a5523e.png" width="50%" align="left">  <i>The article has been updated with useful comments.</i>  <i>Many thanks to all the commentators for important clarifications and additions.</i> <br><br>  In games with a complicated UI, creating your own library for its display and tools for easy editing can be a very long and difficult task.  Which I really want to decide once and for all, and not to do it again in each new project, and even in each new company. <br><br>  The solution is to use ready-made universal UI libraries.  Their current generation is represented by such ‚Äúmonsters‚Äù as <a href="http://www.autodesk.com/products/scaleform/overview">Scaleform</a> and <a href="http://coherent-labs.com/">Coherent UI</a> , although if you so want to write UI in HTML, then you can just take <a href="http://www.awesomium.com/">Awesomium</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unfortunately, this trio, with all its advantages, has one major drawback - terrible brakes, especially on mobile devices (a few years ago, I personally watched the Scaleform‚Äôs almost empty screen consume 50% of the frame time on iPhone4). <br><br>  Against this background, I was always wondering why no one uses <a href="http://www.qt.io/developers/">Qt</a> in games, a library that has worked well in desktop applications.  In fact, this statement is not quite right - in the Qt project Wiki there is a <a href="https://wiki.qt.io/Qt_Based_Games">list of</a> games, however there are almost no modern professional projects in it. <br><br>  However, the reason why the familiar old <a href="http://doc.qt.io/qt-5/qtwidgets-index.html">Qt Widgets are</a> not used in games lies on the surface: they are not designed for use with the OpenGL or DirectX render.  Attempts to cross them give pretty bad performance <a href="http://www.shamusyoung.com/twentysidedtale/%3Fp%3D15904">even on the desktop</a> , but there's nothing to say about mobile phones. <br><br>  However, Qt has a much more suitable library for this task for quite some time: <a href="http://doc.qt.io/qt-5/qtquick-index.html">QtQuick</a> .  Its controls by default are rendered at an accelerated rate, and the ability to set the UI description in text format is great for quick customization and changing the look of the game. <br><br>  However, I still have not heard about using Qt in professional game development.  There were no articles on the topic either, so I decided to figure it out myself - whether everyone knows something, which I don‚Äôt know (but don‚Äôt tell!), Or simply don‚Äôt see a good opportunity to save on development time. <br><a name="habracut"></a><br><h1>  Arguments against: </h1><br><br>  I'll start with the thing that is the most distant from technical issues, namely <a href="https://www.qt.io/licensing/">licensing</a> .  Qt uses a dual license - LGPL3 and commercial.  This means that if you are interested in, including platforms, where dynamic linking is not possible (iOS), then you have to fork out $ 79 a month for each employee of ‚Äúusing‚Äù Qt.  ‚ÄúUse‚Äù is, as I understand it, at least just to build a project with libraries, that is, you have to pay for each programmer on the project. <br><br>  <a href="https://habrahabr.ru/users/chalkerx/" class="user_link">ChALkeRx</a> <i>clarifies that to use static linking, it is not necessary to buy a commercial license or upload the source code - just lay out the object files, a set of which will allow you to rebuild your application with a new static version of Qt.</i> <br><br>  Money is not very big, but still not free.  And there is another very interesting point: it is desirable to get a commercial Qt license as soon as you start using Qt in your project.  Otherwise, when you try to get a license, you will be offered to "contact our specialists to discuss the conditions."  They are understandable: not only in our country, smart citizens would have guessed using the free version for the whole development for five years, and only to build a license for 1 month to build the final build! <br><br>  Perhaps the most important technical argument against Qt is its weight.  A practically empty desktop application using QML takes up more than 40Mb (with dynamic DLL linking).  On Android, the sizes will be slightly smaller, about 25Mb (in the uncompressed form - the APK will be noticeably lighter), but for a mobile platform this is just VERY much!  Qt offer a crutch that allows you to install libraries on a user's phone once, and use them from different applications ( <a href="https://play.google.com/store/apps/details%3Fid%3Deu.licentia.necessitas.ministro%26hl%3Dru">Ministro</a> ), but this crutch is obviously available only on Android, but we would like to somehow solve the issue with the sizes on iOS and Windows Phone ... <br><br>  However, lamenting over the fattened libraries, do not forget that the competitors - the Scaleform and Coherent mentioned above - are not much better in this respect, both of them give out empty applications in tens of megabytes.  Unity is a little easier, but still, about 10Mb.  Therefore, here Qt strongly loses only its own, optimized for the task of development. <br><br>  Finally, I mention another potential flaw - Qt is not ready for use under the Web (Emscripten).  Most developers are not very important, but here we are, for example, engaged in this direction, and here it is impossible to use Qt, although work is <a href="http://vps2.etotheipiplusone.com:30176/redmine/projects/emscripten-qt/wiki/Demos">being</a> done in this direction. <br><br><h1>  Arguments for: </h1><br><br>  The main argument for using QtQuick / QML is a convenient UI description format, as well as a visual editor for it.  Plus, a large ready-made set of controls. <br><br>  It is worth mentioning the possibility to write some part of the UI code in JavaScript inside QML, for example, any simple arithmetic connecting the state of the fields of different objects - an opportunity that is very rarely available in self-made UI libraries (and often necessary). <br><br>  However, it is worth noting that Qt Designer is not a Visual Studio form designer.  Even for the basic controls that come with Qt, it does not allow editing all their possible properties (for example, because they can be added dynamically).  In particular, you will not be able to assign a <a href="https://jryannel.wordpress.com/2010/02/14/button-with-image-background/">picture</a> to the <a href="https://jryannel.wordpress.com/2010/02/14/button-with-image-background/">button</a> for the pressed and released position through the editor.  And this is just the beginning of the problems.  On the other hand, by combining the use of a visual and text editor, all these problems can be overcome.  Just do not expect that you can give Qt Designer to the artist, and he will set everything up for you without getting into the textual representation. <br><br>  Performance, according to my feelings, is acceptable for QtQuick.  In the latest release of Qt 5.7, it was promised that it would be noticeably improved with new QtQuick Controls 2.0, sharpened for mobile platforms. <br><br><h1>  Technical features </h1><br><br>  We now turn to the most interesting - the technical features of the use of Qt in the game. <br><br><h2>  Main loop </h2><br><br>  The first thing to face is that Qt prefers to be the master of the main loop.  At the same time, many game engines also claim this.  Someone will have to give up.  In my case, the <a href="https://bitbucket.org/nyan_developer/nya-engine/overview">Nya engine</a> that we use at work breaks up without any problems with the main loop, and, after minimal initialization, easily uses the OpenGL context created by Qt.  But even if your engine refuses to release the main loop of tenacious legs, this is not the end of the world.  It is enough in your loop to call the processEvents method on the Qt application class.  An example implementation is shown on <a href="http://stackoverflow.com/questions/22121664/how-to-implement-a-game-loop-with-c-and-qtquick">StackOverflow</a> , along with criticism. <br><br>  <a href="https://habrahabr.ru/users/dmitrysokolov/" class="user_link">DmitrySokolov</a> <i>points out that there are at least two ways to make friends with the Qt render and your engine: first, you can render your scene into a texture that will be drawn as one of the components of the QtQuick stage graph, as described in <a href="http://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html">Mixing Scene Graph and OpenGL</a> .</i>  <i>Secondly, you can use the <a href="http://doc.qt.io/qt-5/qquickrendercontrol.html">QQuickRenderControl</a> object.</i>  <i>Regarding the latter, there is a <a href="https://habrahabr.ru/post/247477/">useful article</a> on Habr√©, which, in particular, demonstrates the possibility of using two (spherical) contexts for Qt and the game render, so as not to bother so much with states.</i> <br><br>  If you went by handing the main loop to Qt, then the question arises - when will we render our game?  The QQuickView object, into which the UI is loaded for display, provides the <i>beforeRendering</i> and <i>afterRendering</i> signals to which you can subscribe.  The first one will work to render the UI - here it‚Äôs time to render most of the game scene.  The second is after the UI is drawn, and here you can draw some more beautiful particle, well, or all of a sudden some modelki, which are supposed to be on top of the UI (say, the character's 3d doll in the equipment window).  IMPORTANT!  When connecting signals, specify the type of connection <i>Qt :: ConnectionType :: DirectConnection</i> , otherwise you will get an error due to an attempt to access the OpenGL context from another thread. <br><br>  At the same time, you should not forget to forbid Qt to clear the screen before drawing the UI - otherwise all our works will be <i>erased (setClearBeforeRendering (false)</i> ). <br><br>  Also, in afterRendering, it makes sense to call the update function from QQuickView.  The fact is that usually Qt saves our time and money, and as long as nothing has changed in it, there will be no redrawing of the UI, and as a result it will not cause these same before / afterRendering, and we will not be able to draw anything either.  Calling update will force everything to be drawn again at the next frame.  If you want to limit the number of frames per second, then you can immediately sleep. <br><br><h2>  Something else about drawing </h2><br><br>  It is necessary to remember about the fact that we have a common OpenGL context with Qt.  This means that you need to handle it with care.  First, Qt will do whatever it wants with it.  Therefore, when we have to draw something ourselves (in before or in afterRendering), then first, we need to make this context current ( <i>m_qt_wnd-&gt; openglContext () -&gt; makeCurrent (m_qt_wnd)</i> ), and second, set He needs all the settings we need.  In Nya engine, this is done with a single call to apply_state (true), but in your engine it can be more difficult. <br><br>  Secondly, after we have drawn our <i>own</i> , it is necessary to return the context to the state Qt <i>satisfies</i> , calling <i>m_qt_wnd-&gt; resetOpenGLState ();</i> <br><br>  By the way, it is worth considering that since OpenGL context creates Qt and not your engine, you need to make sure that your engine does not do anything extra before the context is created.  To do this, you can subscribe to the <i>openglContextCreated</i> signal, well, or do initialization in the first call to beforeRendering. <br><br><h2>  QML Interactions </h2><br><br>  So, here our game draws its own scene, on top - Qt draws its controls, but so far all this does not communicate with each other.  So you can not live. <br><br>  If you write your code in QtCreator, or in another IDE, to which the call to the Qt-shnogo code generator (MOC) is miraculously bolted, then your life will be simple.  It is enough to connect the slots and signals by names, and QML will receive calls from C ++, and vice versa. <br><br>  <a href="https://habrahabr.ru/users/coderush/" class="user_link">CodeRush</a> <i>indicates that MOC is fairly easy to tie to any of the popular IDEs, since Qt has a means of generating projects from .pro files:</i> <i><br><br></i> <blockquote>  <i>For VS, the project from the .PRO file is generated like this:</i> <i><br><br></i>  <i>qmake -tp vc path / to / project / file.pro</i> <i><br><br></i>  <i>For Xcode, like this:</i> <i><br><br></i>  <i>qmake -spec macx-xcode path / to / project / file.pro</i> <i><br></i> </blockquote><br>  <a href="https://habrahabr.ru/users/al_sh/" class="user_link">al_sh</a> <i>reminds of <a href="http://visualstudiogallery.msdn.microsoft.com/c89ff880-8509-47a4-a262-e4fa07168408">Add-In for Visual Studio 2013 &amp; 2015</a></i> <br><br>  However, you may want to live without MOC.  It is possible!  But you have to get some crutches out of the cushion. <br><br><h3>  Here (QML -&gt; C ++) </h3><br><br>  Qt now supports two ways to connect signals and slots - the old, by name, and the new, by pointers.  So, with QML you can contact only by name.  This means, firstly, that it is impossible to hang a lambda on the signal from QML (sob-sob, but I so wanted C ++ 11!), And secondly - that you have to have an object in which the slot is declared, and this object should to be a QObject successor, and inside yourself to have a Q_OBJECT macro, for code generation.  And we have no code generation.  What to do?  That's right, taking objects in which all slots have already been declared, and therefore they do not need code generation. <br><br>  In fact, this is generally a very useful approach, which, with some probability, you will already need.  We will use the <b>QSignalMapper</b> helper class.  This class has exactly one slot - map ().  You can attach as many signals as you want from as many objects as you like.  In response, QSignalMapper for each received signal will generate another signal - mapped (), adding to it the previously registered ID of the object that generated the signal, or even a pointer to it.  How to use it?  Very simple. <br><br>  Create a separate QSignalMapper for each type of signals that can come from QML (clicked for buttons, etc.).  Further, when we in C ++ need to subscribe to a signal from an object in QML, we associate this signal with the desired QSignalMapper, and already its mapped () signal is associated with its class, or even lambda (at this level C ++ 11 already works , cheers cheers).  At the entrance we will receive the object ID, and according to it we will understand what we should do with it: <br><br><pre><code class="cpp hljs">QObject *b1 = m_qt_wnd-&gt;rootObject()-&gt;findChild&lt;QObject*&gt;( <span class="hljs-string"><span class="hljs-string">"b1"</span></span> ); QObject::connect( b1, SIGNAL( clicked() ), &amp;m_clickMapper, SLOT( <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() ) ); QObject *b2 = m_qt_wnd-&gt;rootObject()-&gt;findChild&lt;QObject*&gt;( <span class="hljs-string"><span class="hljs-string">"b2"</span></span> ); QObject::connect( b2, SIGNAL( clicked() ), &amp;m_clickMapper, SLOT( <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() ) ); m_clickMapper.setMapping( b1, <span class="hljs-string"><span class="hljs-string">"b1"</span></span> ); m_clickMapper.setMapping( b2, <span class="hljs-string"><span class="hljs-string">"b2"</span></span> ); QObject::connect( &amp;m_clickMapper, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(QSignalMapper::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp;)&gt;(&amp;QSignalMapper::mapped), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;sender ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sender == <span class="hljs-string"><span class="hljs-string">"b1"</span></span> ) m_speed *= <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sender == <span class="hljs-string"><span class="hljs-string">"b2"</span></span> ) m_speed /= <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; } );</code> </pre> <br><br>  In the test project code, a link to which you will find at the end of the article, there is an example of wrapping this mechanism for a little more convenient use. <br><br>  <a href="https://habrahabr.ru/users/zifix/" class="user_link">Zifix</a> <i>indicates that there is another way for QML -&gt; C ++ to interact - throw a C ++ object into QML, and pull it from there.</i>  <i>To do this, the object must be a QObject descendant and contain the Q_OBJECT macro processed by the code generator, and also add it to the context:</i> <i><br><br></i> <pre> <i><code class="cpp hljs">SignalsHub signal; engine.rootContext()-&gt;setContextProperty(QLatin1String(<span class="hljs-string"><span class="hljs-string">"signal"</span></span>), &amp;signal);</code></i> </pre> <i><br></i> <br><br><h3>  There (C ++ -&gt; QML) </h3><br><br>  Here, an ambush awaits us without code generation - there is no way to link a signal from C ++ to a slot in QML (more precisely, there are ways, but for my taste, they are too complicated).  On the other hand, why? <br><br>  In fact, we have as many as two (well, OK, one and a half) ways.  First, you can directly change the properties of QML objects from C ++ code, <i>calling</i> them <i>setProperty ("propName", value)</i> .  That is, if you just need to affix a new text to some field, then you can.  Obviously, this method of interaction is rather limited in all senses, but in fact you cannot even imagine for yourself how much.  The fact is that an attempt to touch the properties of QML objects from the render thread will lead to an error.  That is, here from these most before / afterRendering it is impossible to touch anything.  And you there already, probably, the game logic was written?  :) I - yes. <br><br>  What to do?  Firstly, you can start a timer in the main thread, which will be triggered once every N seconds and process the game logic.  And let render render separately.  We'll have to synchronize them somehow, but this is a solvable question. <br><br>  But if you do not want to do that, then there is a way out!  We cannot send QML signals, we cannot write property, but suddenly we can call functions.  Therefore, if you need to pause the UI, then it is enough to declare a function in it that will effect your impact (say, setNewText), and then call it from C ++ via invokeMethod: <br><br><pre> <code class="cpp hljs">QVariant a1 = <span class="hljs-string"><span class="hljs-string">"NEW TEXT"</span></span>; m_fps_label-&gt;metaObject()-&gt;invokeMethod( m_fps_label, <span class="hljs-string"><span class="hljs-string">"setText"</span></span>, Q_ARG(QVariant, a1) );</code> </pre><br><br>  An important point: the arguments for such a call can only be of type QVariant, and you need to use this macro, Q_ARG.  Also, if a method can return something, you will need to specify Q_RETURN_ARG (QVariant, referenceToReturnVariable). <br><br>  <a href="https://habrahabr.ru/users/tzlom/" class="user_link">tzlom</a> <i>clarifies that this way you can call not only functions, but also signals and slots declared in QML.</i>  <i>In this case, if you specify the Qt :: QueuedConnection parameter, the call will be made deferred, in the stream in which this can be done exactly</i> <br><br>  <a href="https://habrahabr.ru/users/zifix/" class="user_link">Zifix</a> <i>says that the technique described above with procide a C ++ object in QML context can also be used to bind signals in the direction of C ++ -&gt; QML.</i>  <i>This will avoid searching for QML objects in C ++ code, that is, reducing the poor connectivity ‚Äúby name‚Äù between C ++ and QML.</i> <i><br><br></i> <pre> <i><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  Connections { target: signal // signal -    C++ - ,    onHello: { console.log("Hello from ++!"); }); } //   Component.onCompleted: { signal.onHello.connect(function() { //   C++-   -  QML console.log("Hello from ++!"); }); }</span></span></code></i> </pre> <i><br></i> <br><br><h2>  Resources </h2><br><br>  In principle, we are already almost all good.  And if for all games all resources would simply lie in clear form next to the executable file, an article on this could be completed.  Unfortunately, life is a bit wrong: resources in games are often packed, and even in some special format of their own.  Which game engine is able to efficiently stream from disk to memory and all that. <br><br>  There is a desire to push all the resources associated with the UI to the same place where the other resources of the game lie.  Moreover, they can not always be clearly divided - sometimes the same texture can be used in the 3D scene and in the UI.  At the same time, I really want to see in the QML file that we still have written ‚Äúsource: images / button_up.png‚Äù, so that during development, while the resources are not packed, we could edit the UI in Qt Designer, without writing plugins to it. <br><br>  And at this moment we are waiting for the most severe, and very offensive bummer.  In fact, we need to slip Qt our resource system under the guise of a file system.  But the support of virtual file systems in the form of <b>QAbstractFileEngine</b> in version 5.x was safely <a href="http://doc.qt.io/qt-5/sourcebreaks.html">cut out</a> "due to performance problems" ( <a href="http://comments.gmane.org/gmane.comp.lib.qt.general/33251">discussion</a> ).  I do not know what and what heel was written there.  All our games work great with VFS, combining several sources of resources, and do not complain about performance.  The most annoying is that Qt authors didn‚Äôt suggest replacements. <br><br>  However, so far this class has not been cut out to the end, but only ‚Äúprivatized‚Äù, so if you like to live risky, you can use it by connecting the private library and the hider. <br><br>  The authors have left one crutch - in QMLEngine you can register <b>QQuickImageProvider</b> .  With it, you can at least load textures from your system. <br><br>  In order for QMLEngine to use your QQuickImageProvider, rather than climbing directly to a file, you must specify the path to the image in the QML file not just ‚Äúimages / button_up.png‚Äù, but ‚Äúimage: /my_provider/images/button_up.png‚Äù (where ‚Äúmy_provider‚Äù - the name with which you registered your successor to the QQuickImageProvider in QMLEngine).  Obviously, if you do this, you will immediately stop seeing the pictures in Qt Designer, which knows nothing about your custom provider and does not want to know. <br><br>  There is no such crutch that could not be supported with another crutch!  In QMLEngine, you can register another class - <b>QQmlAbstractUrlInterceptor.</b>  All the URLs that are loaded during the processing of a QML file pass through this same Interceptor.  And then they can be replaced by something.  What we need!  As soon as we see that the URL type is UrlString, and, for reliability, the URL itself contains the text ".png", we immediately do: <br><br><pre> <code class="cpp hljs">QUrl result = path; QString short_path = result.path().right( result.path().length() - m_base_url.length() ); result.setScheme( <span class="hljs-string"><span class="hljs-string">"image"</span></span> ); result.setHost( <span class="hljs-string"><span class="hljs-string">"my_provider"</span></span> ); result.setPath( short_path ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result;</code> </pre><br><br>  <b>setScheme</b> is for QML to understand that you need to look for a suitable ImageProvider <br>  <b>setHost</b> is the name of our provider <br>  <b>setPath</b> - and here it is necessary to clarify.  The fact is that the Interceptor URLs come already supplemented with the base url of our QMLEngine.  By default, this is QDir :: currentPath.  Obviously, this is completely inconvenient for us, so we have to cut an unnecessary piece of the path in order to get, as a result, ‚Äúimage: / my_provider‚Äù instead of some ‚Äúfile: /// C: /Work/Test/images/button_up.png‚Äù /images/button_up.png. " <br><br><h2>  Resources 2 - False Footprint </h2><br><br>  In order to amuse the public, I will tell you how I tried to deceive Qt and load ALL resources from my system. <br><br>  QMLEngine also contains a third type of class that can be set for it ‚Äî this is <b>NetworkAccessManagerFactory</b> .  The indigestible name hides the ability to set up its own http request handler.  What if, I thought, we‚Äôll replace QML files with QQmlAbstractUrlInterceptor with http requests, and in our NetworkAccessManagerFactory (or rather NetworkAccessManager and NetworkReply) actually open files from our resource system? <br><br>  The plan worked almost to the very end :) URLs are intercepted, http-requests are replaced, even qml files are successfully loaded.  That's just when trying to read the contents of the qmldir service file with http QQMLTypeLoader makes assert :( And I could not get around this behavior. And without this, the whole idea is useless - we cannot import our QML modules from our resource system. <br><br><h2>  Redux Resources </h2><br><br>  By the way, Qt also has its own resource system!  It allows you to compile resources into an rcc file, and then use them from there.  For this, deep in the depths of Qt, its own virtual file system is made, which, if the resource has the prefix qrc: / or even simply: /, loads it not from disk, but from where it is necessary.  Unfortunately, ‚Äúfrom where it is necessary‚Äù is still not from our resource system. <br><br>  There are two ways to register a source of resources.  Both are calls to different overloads of the QResource :: registerResource static function.  The first one takes as input the name of the resource file on disk.  Everything is clear - read from the disk and use it.  The second - takes a bare pointer to some rccData.  The documentation at this point concisely states that this function registers rccData as a resource.  And further still grinds some nonsense about files.  This is the result of an unsuccessful copy-paste, wandering from version to version without changes. <br><br>  An investigation of the source code of the second registerResource overload showed that it did take the contents of the rcc file as input.  Why is the data size not transmitted along with the pointer?  It turns out - because Qt does not want to check anything, but wants to read-read-read and access violation.  In this place, the library expects to receive high-quality binary data that has at least a header (the magic letters "qres" and data about the size and other properties of the remaining part of the memory block).  Until a valid header is read, Qt will cheerfully read any memory you give it.  Not very reliable, but okay. <br><br>  It would seem that this option suits us - you can read the rcc file from our resource system, stick it into the QResource, and then use all the resources with the prefix qrc: / without any problems.  In part, it is.  But remember that before registering data in a resource system, you will have to completely load it into memory.  Therefore, stuffing all UI textures into one rcc is probably a bad idea.  You have to either prepare a separate set for each screen, or, for example, put only QML files in rcc, and load pictures from your resource system using the method described above via Interceptor + ImageProvider. <br><br><h2>  Release preparation </h2><br><br>  If you think that after you have overcome all the Qt software problems, wrote your code, drew a beautiful UI and packed resources, everything is ready for release - this is not entirely true. <br><br>  The fact is that Qt is a lot of DLLs and QML modules.  In order to distribute your program, all this good will have to carry with you.  But in order to carry it, you first need to find it, but it is hidden by the corners of the huge Qt installation directory.  Qt Creator will find everything and put it where it should be, but if we still use another IDE ... Hands to cut out all the necessary DLLs and other files - the task is difficult and tedious, and most importantly - it is easy to make a mistake. <br><br>  Here, the Qt authors went along with simple programmers, and provided tools such as windeployqt and androiddeployqt.  Under each platform, such a tool is yours, with its keys and behaves differently.  For example, windeployqt accepts a path to your main executable file and a directory with your QML files, and at the output it simply copies all the necessary DLL and other files to the specified location.  Then do it yourself. <br><br>  But androiddeployqt - this is the same harvester, engaged in the assembly of the APK package, and the devil knows what.  On iOS, the situation is similar. <br><br><h1>  findings </h1><br><br>  So, can QtQuick / QML be used to create UI in games?  My short experience of integration and use of this library showed that, in principle, it is possible.  But a lot depends on specific goals and restrictions. <br><br>  Let's say if you are ready to use QtCreator for development - a significant part of the minor inconvenience disappears automatically, but if for some reason you want to stay with your beloved Visual Studio, XCode or vi, then you need to get ready for some pain. <br><br>  If you are developing a game for PC, or it is a very large mobile project with hundreds of megabytes of resources (there are such things), then 25-40 MB of libraries are not a problem for you.  If you write another kazualka for Android, and even with an eye on the Chinese or Iranian markets, with their recommended 50MB per application, you should think about it three times before taking up most of this not too payload. <br><br>  However, if you desperately don‚Äôt want to write your UI library, QtQuick / QML, it seems to me, outperforms competitors in performance, if not in size and not in usability. <br><br>  Integration of Qt into the project is not too complicated, but it can force to change the logic of the main loop and initialization.  In the new project, this is almost certainly possible to survive, but changing quickly the UI from another to QtQuick / QML is unlikely to happen without much suffering. <br><br>  Qt's documentation is pretty good, but sometimes it's lying or incomplete.  In these cases, you have to go into the source code - and it‚Äôs very good that it is completely open!  Its volumes are solid, but in fact it‚Äôs quite possible to figure out how something loads or works. <br><br>  Compared to Scaleform and Coherent, another disadvantage is that Scaleform allows designers to create interfaces in familiar Adobe programs, and Coherent can hire an HTML specialist to develop the UI.  Developing a QML UI will require collaboration between a programmer and a designer.  However, in the end, it still comes to this when problems begin with the performance and behavior of the UI inside the game. <br><br>  In general, you have to decide, as usual, by yourself! <br><br>  You can get the Qt integration example code with the Nya engine on GitHub <a href="https://github.com/MaxSavenkov/nya_qt">MaxSavenkov / nya_qt</a> . </div><p>Source: <a href="https://habr.com/ru/post/303722/">https://habr.com/ru/post/303722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303710/index.html">Application on API hh.ru. We recommend vacancies for your resume</a></li>
<li><a href="../303712/index.html">Edsger Dijkstra: in search of the ‚Äúshortest path‚Äù to conscious programming</a></li>
<li><a href="../303714/index.html">Building perfect optics in Zemax</a></li>
<li><a href="../303716/index.html">HL7: Your HL7 CDA document does not comply with the standard</a></li>
<li><a href="../303718/index.html">Comments on the problem in Bitrix24 with commit for Mercurial</a></li>
<li><a href="../303724/index.html">Full list of tools and utilities for Microsoft SQL Server</a></li>
<li><a href="../303726/index.html">Node.js web scraping and bot protection</a></li>
<li><a href="../303730/index.html">My experience using WebRTC in an iOS application</a></li>
<li><a href="../303732/index.html">Mobius 2016: a new way of mobile development</a></li>
<li><a href="../303734/index.html">ONLYOFFICE: open like never before</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>