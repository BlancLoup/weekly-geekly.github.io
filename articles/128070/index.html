<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another Monad Guide (part 2: >> = and return functions)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By mike vanier 

 Two fundamental monadic operations 
 Remember, I said that monads generalize composition and application of functions? Here we will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another Monad Guide (part 2: >> = and return functions)</h1><div class="post__text post__text-html js-mediator-article">  By mike vanier <br><br><h4>  Two fundamental monadic operations </h4><br>  Remember, I said that monads generalize composition and application of functions?  Here we will talk about it here.  Be patient, we will need some time. <br><br>  By this time, I hope you have at least a vague feeling of the monads, what they are and what they are used for.  I have already mentioned one of the features of functional programming - the composition of functions, thanks to which we create new functions by combining the old ones.  Functional programmers are constantly talking about "combinability" {1}, meaning that if something in the programming language is not combined, then it costs little.  Similarly, our newly appeared monadic functions would not be as useful if they were not arranged as they really are.  But we still will see, for their composition it is impossible to use the standard function ‚Äúdot‚Äù (.) Of the Haskell language.  We will come to the conclusion that something more is needed here, and we define two fundamental monadic operations (or, for a start, their types). <br><a name="habracut"></a><br>  Suppose we have such monadic functions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> m c </blockquote><br><br>  for some monad <font color="blue">m</font> .  If you want a more specific example, you can imagine that <font color="blue">f</font> and <font color="blue">g</font> are functions in the <font color="blue">IO</font> monad: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c </blockquote><br><br>  However, the same is true for other monads.  Recall (for the case of <font color="blue">IO</font> ) that the function <font color="blue">f</font> takes a value of type <font color="blue">a</font> and outputs a value of type <font color="blue">b</font> , and in the process, it may interact with input / output ( <font color="blue">IO</font> ).  The function <font color="blue">g</font> , in turn, takes a value of type <font color="blue">b</font> and outputs a value of type <font color="blue">c</font> , and in the process, perhaps, works with input / output.  Using the composition of these functions, we hope to get the function <font color="blue">h</font> : <br><br><blockquote>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c </blockquote><br><br>  that is, the result is a function that takes a value of type <font color="blue">a</font> , displays a value of type <font color="blue">c,</font> and in the process works with I / O (where I / O is a combination of what <font color="blue">f</font> and <font color="blue">g do</font> ).  In pseudo-language, we could write it like this: <br><br><blockquote>  connect function: <br>  <font>(</font> f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <font>)</font> <br>  with function: <br>  <font>(</font> g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <font>)</font> <br>  To obtain: <br>  <font>(</font> h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <font>)</font> </blockquote><br><br>  However, in Haskell, the composition operator (dot) knows nothing about the type of <font color="blue">IO</font> , so it will not work with our functions <font color="blue">f</font> and <font color="blue">g</font> .  For comparison, let's look at pure functions with ordinary types <font color="blue">p</font> , <font color="blue">q</font> , <font color="blue">r</font> without any <font color="blue">IO</font> : <br><br><blockquote>  p <font color="#339933">::</font> a <font color="#339933">-&gt;</font> b <br>  q <font color="#339933">::</font> b <font color="#339933">-&gt;</font> c <br>  r <font color="#339933">::</font> a <font color="#339933">-&gt;</font> c </blockquote><br><br>  Operators (.) And (&gt;.&gt;) Are suitable here: <br><br><blockquote>  <font>(</font> <font color="#339933">.</font> <font>)</font> <font color="#339933">::</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  r <font color="#339933">=</font> q <font color="#339933">.</font>  p <br>  <font>(</font> <font color="#339933">&gt;.&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  r <font color="#339933">=</font> p <font color="#339933">&gt;.&gt;</font> q </blockquote><br><br>  But none of them will work with monadic functions: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <br>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <br>  g <font color="#339933">.</font>  f <font color="#339933">-&gt;</font> typing error <font color="#339933">!</font>  Mismatch between <font color="#cccc00">IO</font> b and b <br>  f <font color="#339933">&gt;.&gt;</font> g <font color="#339933">-&gt;</font> typing error <font color="#339933">!</font>  Mismatch between <font color="#cccc00">IO</font> b and b </blockquote><br><br>  You cannot use a monadic value of type <font color="blue">IO b</font> if type <font color="blue">b</font> is required.  (This is the most common error of monadic programs in Haskell.) We need a special function of monadic composition, which I call <font color="blue">mcompose</font> (from "monadic compose").  She has the following type: <br><br><blockquote>  mcompose <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m c <font>)</font> </blockquote><br><br>  It works for any monad, including the <font color="blue">IO</font> monad.  Substituting <font color="blue">IO</font> , we get the corresponding function definition: <br><br><blockquote>  mcompose <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <font>)</font> </blockquote><br><br>  We could use it to compose the monadic functions <font color="blue">f</font> and <font color="blue">g</font> .  The type of the function <font color="blue">h</font> would be correct: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <br>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <br>  h <font color="#339933">=</font> f `mcompose` g </blockquote><br><br>  (Here, the <font color="blue">mcompose</font> function <font color="blue">is</font> surrounded by inverse apostrophes. This is elegant syntactic sugar, which allows you to make an infix operator from a two-argument function. Do not forget that the operators in Haskell are simply functions placed between their operands.) The <font color="blue">mcompose</font> function (or operator if you want) is capable of: <br><br><ol><li>  take an initial value of type <font color="blue">a</font> ; </li><li>  apply the function <font color="blue">f</font> to it (the usual application of functions) and get the result of type <font color="blue">IO b</font> ; </li><li>  take a value of type <font color="blue">IO b</font> from function <font color="blue">f</font> and extract the value of type <font color="blue">b</font> (this is what we cannot do); </li><li>  take the value of type <font color="blue">b</font> and apply the function <font color="blue">g</font> to it (again, the usual application of functions) to get the value of type <font color="blue">IO c</font> , which is the desired result. </li></ol><br><br>  The only thing we can not do yet is step (3), to get a value of type <font color="blue">b</font> from a value of type <font color="blue">IO b</font> .  Let's come up with an <font color="blue">extract</font> function that we could use to extract.  Here is its type: <br><br><blockquote>  extract <font color="#339933">::</font> <font color="#cccc00">IO</font> b <font color="#339933">-&gt;</font> b </blockquote><br><br>  And if we generalize to all monads, we get: <br><br><blockquote>  extract <font color="#339933">::</font> m b <font color="#339933">-&gt;</font> b </blockquote><br><br>  It turns out that if such a function existed, it would level off all the advantages of monads and pure functional programming!  There is a reason we need monads.  We want to keep special concepts of computation (monadic functions) separate from pure functions, because otherwise there would be no guarantee that pure functions are pure.  This is an important point, and I'm going to spend some time on it, and then we will return to the monadic composition. <br><br><blockquote>  * Note on the margins. * In fact, for some monads there is an equivalent of the <font color="blue">extract</font> function, which does not entail any problems.  However, I must say that the <font color="blue">extract</font> function generalized to all monads is prohibited. </blockquote><br><br>  We would like to know for sure that functions without monadic types are pure.  Although generally in Haskell, monadic functions are pure, because they are made as pure functions that return a monadic value.  But we want to ensure that non-monadic (pure) functions will not even try to work with monadic values.  Then they will surely be clean.  For example, pure function <font color="blue">hh</font> type <br><br><blockquote>  hh <font color="#339933">::</font> a <font color="#339933">-&gt;</font> c </blockquote><br><br>  will never invoke a read / write operation (with a file or console), because otherwise it would have had type <br><br><blockquote>  hh <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c </blockquote><br><br>  Such guarantees, backed by a type system, are one of Haskell‚Äôs main strengths.  They allow us, one look at the definition of a function, to be 100% sure that it does not interact with input / output (for example). <br><br>  However, if we had the <font color="blue">extract</font> function, we could compose <font color="blue">hh</font> , a supposedly clean function from unclean I / O operators: <br><br><blockquote>  ff <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  gg <font color="#339933">::</font> b <font color="#339933">-&gt;</font> c <br>  hh <font color="#339933">=</font> ff <font color="#339933">&gt;.&gt;</font> extract <font color="#339933">&gt;.&gt;</font> gg <font color="#5d478b">- or the same: hh = gg.</font>  <font color="#5d478b">extract.</font>  <font color="#5d478b">ff</font> </blockquote><br><br>  Even if it was never assumed that the <font color="blue">hh</font> function would do input / output, you could create it using extract and the usual composition operator, and the type <font color="blue">hh</font> would be clean ‚Äî but inside it would still perform input / output operations.  And it would not be possible to separate <font color="blue">IO</font> (as well as other monadic calculations) from pure calculations.  (But this is one of the main reasons for the introduction of monads.) Note, by the way, that this situation is exactly the same with most conventional programming languages, which is why their type systems do not guarantee that the functions are clean.  Unlike Haskell, we like its mechanism for pure functions, its type system, which requires pure functions to be pure, which is why there is no <font color="blue">extract</font> function in Haskell. <br><br>  There is one small problem with what I just said: in general, this is a lie.  There is an unsafePerformIO function with type <font color="blue">IO a -&gt; a</font> , that is, this is the <font color="blue">extract</font> version for the <font color="blue">IO</font> monad.  The word ‚Äúunsafe‚Äù hints that you should avoid this function if you don‚Äôt know what exactly you want to do, or are not ready for strange malfunctions.  I have never had to use <font color="blue">unsafePerformIO</font> , but there are legal cases, for example, deep in the implementation of Haskell compilers.  Just forget that I told you this, ok?  I feel embarrassed because of this.  Excuse me.  {3} <br><br>  But - we will continue.  At this point, we have established: (a) - the composition of monadic functions is needed;  (b) - the usual composition operator is not suitable for this, because we cannot reduce monadic types to ordinary ones;  and (c) - you cannot set the <font color="blue">extract</font> function, because it will spoil the purity of the whole language.  So what do we do? <br><br>  Well, first of all, let's try to invent something simpler than <font color="blue">mcompose</font> .  Let's say a certain function <font color="blue">mapply</font> (monadic application), which has the following type: <br><br><blockquote>  mapply <font color="#339933">::</font> m b <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> m c </blockquote><br><br>  And if we descend from common monads to <font color="blue">IO</font> , we get: <br><br><blockquote>  mapply <font color="#339933">::</font> <font color="#cccc00">IO</font> b <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> c </blockquote><br><br>  It is called <font color="blue">mapply</font> because of its similarity to the usual operator using functions.  Recall, for example, the <font color="blue">&gt; $&gt;</font> operator, previously defined in a similar way: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt; $&gt;</font> <font>)</font> <font color="#339933">::</font> b <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> c </blockquote><br><br>  Same as <font color="blue">mapply</font> , only there is no ‚Äúm‚Äù (types are not monadic).  <font color="blue">mcompose is</font> trivially expressed through <font color="blue">mapply</font> : <br><br><blockquote>  mcompose <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m c <font>)</font> <br>  mcompose f g x <font color="#339933">=</font> <font>(</font> f x <font>)</font> `mapply` g <font color="#5d478b">- or: mapply (f x) g</font> </blockquote><br><br>  Since the arrow ( <font color="blue">-&gt;</font> ) in the type definition is right associative, we can omit the parentheses of the last element: <br><br><blockquote>  mcompose <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> a <font color="#339933">-&gt;</font> m c <br>  mcompose f g x <font color="#339933">=</font> <font>(</font> f x <font>)</font> `mapply` g </blockquote><br><br>  Maybe this version of <font color="blue">mcompose</font> is easier to understand than the previous one, but they are the same thing.  It is worth noting that <font color="blue">x</font> is of type <font color="blue">a</font> , and the type of result is <font color="blue">mc</font> .  Here is what we do here: we apply the function <font color="blue">f</font> to <font color="blue">x</font> to get a value of type <font color="blue">mb</font> ;  then we pass this value (of type <font color="blue">mb</font> ) and the function <font color="blue">g</font> to <font color="blue">mapply</font> , thus obtaining the value of type <font color="blue">mc</font> we are interested in.  It turns out that we do not need to have the <font color="blue">mcompose</font> function <font color="blue">somewhere</font> ;  if we already have a <font color="blue">mapply</font> , through it we can write <font color="blue">mcompose ourselves</font> .  And, in fact, <font color="blue">mapply</font> is one of two fundamental monadic operations.  It is usually called ‚Äúbind‚Äù (‚Äúbind‚Äù) and is written as a character infix operator <font color="blue">&gt;&gt; =</font> : <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m b </blockquote><br><br>  It is worth noting that I slightly changed the definition of the type: I replaced <font color="blue">b</font> with <font color="blue">a</font> and <font color="blue">c</font> with <font color="blue">b</font> .  But this is not important, since <font color="blue">a</font> , <font color="blue">b</font> , <font color="blue">c</font> are type variables, they work with any types. <br><br>  I would like to emphasize that the <font color="blue">&gt;&gt; =</font> operator is extremely abstract.  Its first argument is a value of type <font color="blue">ma</font> , where <font color="blue">a</font> can be any type at all, and <font color="blue">m</font> any monadic type constructor.  The second argument is the function <font color="blue">a -&gt; mb</font> , where <font color="blue">a</font> and <font color="blue">b</font> are also any types, and <font color="blue">m</font> is, again, any monadic type constructor.  Finally, the return value is of type <font color="blue">mb</font> , where <font color="blue">b</font> can be any type and <font color="blue">m</font> can be any monadic type constructor.  (For experienced Haskell programmers, such type definitions become second nature, but for newbies this can be difficult.) You can specialize the definition up to the <font color="blue">IO</font> monad, and get a monadic application operator on the <font color="blue">IO</font> monad: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b </blockquote><br><br>  We will soon see that the Haskell type system allows the use of the generic <font color="blue">&gt;&gt; =</font> operator for a wide variety of monads (is that cool, right?). <br><br>  Suppose that we have the operator <font color="blue">&gt;&gt; =</font> , with it we can connect <font color="blue">f</font> and <font color="blue">g</font> to get <font color="blue">h</font> : <br><br><blockquote>  <font color="#5d478b">- suppose we are given:</font> <br>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> m c <br><br>  <font color="#5d478b">- definition h:</font> <br>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m c <br>  h x <font color="#339933">=</font> f x <font color="#339933">&gt;&gt; =</font> g </blockquote><br><br>  We can also rewrite <font color="blue">h</font> in a different way: <br><br><blockquote>  h <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> f x <font color="#339933">&gt;&gt; =</font> g </blockquote><br><br>  where <font color="blue">\ x -&gt; ...</font> is, as mentioned earlier, the designation of anonymous functions in Haskell {4} (in this case with one argument <font color="blue">x</font> );  both versions of <font color="blue">h</font> mean the same thing.  Using <font color="blue">mcompose</font> , we can write the following equation: <br><br><blockquote>  h <font color="#339933">=</font> f `mcompose` g <font color="#339933">=</font> mcompose f g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> </blockquote><br><br>  That is, our <font color="blue">mcompose</font> is defined as <br><br><blockquote>  mcompose f g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> </blockquote><br><br>  In fact, Haskell already has the standard monadic composition operator <font color="blue">&gt; =&gt;</font> : <br><br><blockquote>  f <font color="#339933">&gt; =&gt;</font> g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font color="#5d478b">is the same as (f `mcompose` g) but shorter.</font> </blockquote><br><br>  Assuming that we have a monadic application operator <font color="blue">&gt;&gt; =</font> , we could easily specify a monadic composition operator <font color="blue">&gt; =&gt;</font> .  Hence, the monadic application operator (bind-operator) is conceptually important.  Further we will see that for each monad a specific operator <font color="blue">&gt;&gt; = is</font> defined, which differs from all the others;  This task is very well solved by the Haskell type classes.  By the way, in the GHC compiler, the operator <font color="blue">&gt; =&gt; is</font> defined in the <font color="blue">Control.Monad</font> module. <br><br>  Now let's remember that we recorded the usual use statement in two ways: <br><br><blockquote>  <font>(</font> <font color="#339933">$</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> a <font color="#339933">-&gt;</font> b </blockquote><br><br>  and <br><br><blockquote>  <font>(</font> <font color="#339933">&gt; $&gt;</font> <font>)</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> b </blockquote><br><br>  Which of these operators to apply depends on the order in which we wanted to pass the arguments.  (It is great to define both operators in order to use them when it is convenient.) We can also write the monadic operator of application in two ways.  The first method is the bind-operator <font color="blue">&gt;&gt; =</font> with type <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m b </blockquote><br><br>  which is analogous to the usual use statement <font color="blue">&gt; $&gt;</font> .  A monadic application operator is given trivially, taking arguments in the reverse order: <br><br><blockquote>  <font>(</font> <font color="#339933">= &lt;&lt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m a <font color="#339933">-&gt;</font> m b <br>  f <font color="#339933">= &lt;&lt;</font> x <font color="#339933">=</font> x <font color="#339933">&gt;&gt; =</font> f </blockquote><br><br>  You can also take the <font color="blue">flip</font> function, which takes a function of two arguments and returns the same function, but with the reverse order of the arguments: <br><br><blockquote>  <font>flip</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  <font>flip</font> f <font color="#339933">=</font> \ x y <font color="#339933">-&gt;</font> f y x </blockquote><br><br>  Operator <font color="blue">= &lt;&lt;</font> through it is defined as: <br><br><blockquote>  <font>(</font> <font color="#339933">= &lt;&lt;</font> <font>)</font> <font color="#339933">=</font> <font>flip</font> <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> </blockquote><br><br>  You will get extra functional grade points {5} if your definitions are as brief as this. <br><br>  And again: we can specify a monadic composition operator for the reverse order of the operands: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt; =&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#5d478b">- already</font> <br><br>  <font>(</font> <font color="#339933">&lt;= &lt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m c <font>)</font> <br>  <font>(</font> <font color="#339933">&lt;= &lt;</font> <font>)</font> <font color="#339933">=</font> <font>flip</font> <font>(</font> <font color="#339933">&gt; =&gt;</font> <font>)</font> </blockquote><br><br>  So, we have defined monadic operators of application and composition for any order of operands, as we did with ordinary (non-monadic) operators.  In practice, however, Haskell programmers use the <font color="blue">&gt;&gt; =</font> operator most of all (or, at least, I use it most of all). <br><br>  If you understood all this, congratulations!  All the hardest is over.  I hope.  {6} <br><br>  There is another fundamental monadic operation that I am going to talk about.  For seed, consider the following scenario.  Suppose you need to combine the monadic function with a non-monadic one.  In other words, you have these functions: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b <font color="#5d478b">- monadic</font> <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> c <font color="#5d478b">- nonmonadic</font> </blockquote><br><br>  The problem is as follows.  You cannot use the normal composition function for <font color="blue">f</font> and <font color="blue">g</font> , because <font color="blue">mb</font> is not the same as <font color="blue">b</font> .  And the monadic composition also does not fit, - it knows nothing about the type <font color="blue">b -&gt; c</font> , it needs the monadic type <font color="blue">b -&gt; mc</font> .  What are you going to do? <br><br>  If you had the <font color="blue">extract</font> function parsed earlier, you could combine the two functions in this way: <br><br><blockquote>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> c <br>  h <font color="#339933">=</font> f <font color="#339933">&gt;.&gt;</font> extract <font color="#339933">&gt;.&gt;</font> g </blockquote><br><br>  but we have already found out that this is impossible.  That is, we are forbidden to combine the non-monadic function and the monadic function in order to obtain a non-monadic function (because it would violate the purity of the entire language).  And we are <i>allowed to</i> combine monadic and nonmonadic, if the result is again a monadic function.  Like this: <br><br><blockquote>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m c <br>  h <font color="#339933">=</font> f <font>[</font> somehow combine with <font>]</font> g </blockquote><br><br>  Well, we know that monadic composition is no good, because <font color="blue">g has an</font> incorrect type (which must be <font color="blue">b -&gt; mc</font> ).  However, it would be <i>useful</i> if we could convert a regular function to a monadic one.  Let the function that performs such a transformation be called <font color="blue">functionToMonadicFunction</font> . <br><br><blockquote>  functionToMonadicFunction <font color="#339933">::</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> </blockquote><br><br>  The function <font color="blue">h</font> can now be written differently: <br><br><blockquote>  h <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m c <br>  h <font color="#339933">=</font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> functionToMonadicFunction g <font>)</font> </blockquote><br><br>  It turns out that all that is needed is to define a function <font color="blue">functionToMonadicFunction</font> , and this is very simple, because a monadic function already exists with the name (possibly confusing) <font color="blue">return</font> .  She has the following type: <br><br><blockquote>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m a </blockquote><br><br>  where <font color="blue">a</font> is any type, and <font color="blue">m</font> is any monadic type constructor.  The <font color="blue">return</font> function converts a normal value to the corresponding monadic value for any monad <font color="blue">m</font> , and that is all it does.  Here we are now using it. <br><br>  If you have a <font color="blue">return</font> , then <font color="blue">functionToMonadicFunction</font> is expressed through it simply: <br><br><blockquote>  functionToMonadicFunction <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <br>  functionToMonadicFunction f <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> <font>return</font> <font>(</font> f x <font>)</font> </blockquote><br><br>  Or, if you want to be cool, you can use the composition of functions: <br><br><blockquote>  functionToMonadicFunction <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <br>  functionToMonadicFunction f <font color="#339933">=</font> <font>return</font> <font color="#339933">.</font>  f </blockquote><br><br>  Or even: <br><br><blockquote>  functionToMonadicFunction <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <br>  functionToMonadicFunction <font color="#339933">=</font> <font>(</font> <font>return</font> <font color="#339933">.</font> <font>)</font> </blockquote><br><br>  The last example involved a great Haskell feature called "sections."  All three options are equivalent. <br><br>  Notice that I replaced the type letters again: <font color="blue">b</font> with <font color="blue">a</font> and <font color="blue">c</font> with <font color="blue">b</font> ;  what letter will be in type does not matter.  The main idea of ‚Äã‚Äãthis is that with the help of <font color="blue">return</font> we can connect monadic and nonmonadic functions, getting monadic again.  <font color="blue">return</font> is the second fundamental monadic operation. <br><br><blockquote>  * Marginal notes. * If you program mostly in an imperative style, the word <font color="blue">return</font> may seem somewhat irritating to you.  Just remember that this is <i>not a</i> keyword in Haskell, and <i>nothing</i> returns from the function.  Try not to think about <font color="blue">return</font> as <font color="blue">return</font> in an imperative programming language. </blockquote><br><br>  The name "return" actually came from the understanding of monadic values ‚Äã‚Äãas "actions".  In this sense, the <font color="blue">return</font> function takes a simple value and produces a monadic value.  This monadic value is already ‚Äúdoing something‚Äù, and the result will be the original value.  It is also worth noting that in fact <font color="blue">return</font> is a monadic function.  Putting these two thoughts together, you can conclude (or at least guess) that <font color="blue">return</font> is a monadic version of the identity function (this function maps the value to itself, that is, <font color="blue">\ x -&gt; x</font> ).  We will return to this when we talk about monad laws. <br><br>  Let's take the return into circulation by connecting our monadic function <font color="blue">f</font> with the nonmonadic function <font color="blue">g</font> to get the monadic <font color="blue">h</font> . <br><br><blockquote>  h <font color="#339933">=</font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> <font>return</font> <font color="#339933">.</font> g <font>)</font> </blockquote><br><br>  And this is the correct entry, since <font color="blue">return.</font>  <font color="blue">g</font> converts <font color="blue">g</font> to a monadic function. <br><br>  After all that has been said, you are probably wondering how many more monadic operations we will have to plow before we define them all.  As usual Professor Farnsworth used to say: ‚ÄúGood news!‚Äù There are only two of them!  For convenience, we have set up some more not so important operations, but of them only <font color="blue">&gt;&gt; =</font> and <font color="blue">return</font> must be. <br><br>  There is another rather peculiar moment with <font color="blue">return</font> .  It is said that the <font color="blue">return</font> type looks like <font color="blue">a -&gt; ma</font> .  When we say, for example, <font color="blue">return 10</font> , what will be the type of this expression?  It can be <font color="blue">IO Int</font> , <font color="blue">Maybe Int,</font> or some other monadic <font color="blue">Int</font> .  How do we know what a monad is worth?  After all, the monadic value of <font color="blue">IO Int</font> is not at all the same as <font color="blue">Maybe Int</font> ;  so we are not just interested in the right type, we want to understand <i>what</i> this value is - <font color="blue">return 10</font> ! <br><br>  In Haskell, the meaning of <font color="blue">return 10</font> is determined by the context.  The type validator (type checker) must make sure that the functions take arguments with the necessary types, so if <font color="blue">return 10 is</font> passed to the function where <font color="blue">IO Int</font> is expected, then <font color="blue">return 10</font> will be treated as <font color="blue">IO Int</font> .  (The same rule holds true for other monads.) In other words, the value of <font color="blue">return 10</font> depends on the type in the context of which it is used.  If you wish, you can explicitly specify the type of <font color="blue">return 10</font> expression using, for example, a record ( <font color="blue">return 10 :: IO Int</font> ), but this is rarely necessary. <br><br>  Let's sum up what was said. <br><br><ul><li>  There are two fundamental monadic operations: ‚Äúbind‚Äù (operator <font color="blue">&gt;&gt; =</font> ) and <font color="blue">return</font> . </li><li>  Bind operator is a monadic application operator.  Through it, you can specify a monadic composition operator, which looks like this: <font color="blue">&gt; =&gt;</font> . </li><li>  The <font color="blue">return statement</font> converts normal values ‚Äã‚Äãto monadic ones.  With its help, the function of transforming ordinary functions into monadic functions is determined. </li></ul><br><br><h4>  And what does monadic application and monadic composition really <i>mean</i> ? </h4><br>  At this point you should already understand the mechanisms of monadic composition and monadic application, but this is not the same as intuitively understanding their meaning.  Let's try to clarify the situation. <br><br>  So, we said that it is impossible to set the function <font color="blue">extract</font> , which would do the usual from a monadic value.  However, if we need to combine two monadic functions into a third one, somehow we will still have to extract the usual values ‚Äã‚Äãfrom the monadic functions. <br><br><blockquote>  <font>(</font> <font color="#339933">&gt; =&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m c <font>)</font> <br>  f <font color="#339933">&gt; =&gt;</font> g <font color="#339933">=</font> <font color="#5d478b">{- something -}</font> </blockquote><br><br>  Here it is shown: the function <font color="blue">f</font> takes a value of type <font color="blue">a</font> and returns a monadic value of type <font color="blue">mb</font> ;  The <font color="blue">g</font> function takes a value of type <font color="blue">b</font> and returns a value of type <font color="blue">mc</font> .  And this, of course, <i>looks</i> as if somewhere inside the usual meaning is ‚Äúunpacked‚Äù from the monadic.  We also discussed that we can define a monadic composition <font color="blue">&gt; =&gt;</font> in terms of monadic application ( <font color="blue">&gt;&gt; =</font> ).  Look again at <font color="blue">&gt;&gt; =</font> : <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m b <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> m c <font>)</font> <font color="#339933">-&gt;</font> m c <br>  mv <font color="#339933">&gt;&gt; =</font> g </blockquote><br><br>  where <font color="blue">mv</font> is some monadic value of type <font color="blue">mb</font> .  And after all, too - without any <font color="blue">extract</font> , - how does a value of type <font color="blue">b</font> come from a value of type <font color="blue">mb</font> , in order to pass it to <font color="blue">g</font> <br><br>  The answer for all monads is different.  Each monad has its own way of ‚Äúunpacking‚Äù the monadic value in order to transfer it as usual to another monadic function.  In other words, the operator <font color="blue">&gt;&gt; = is</font> specific for all monads, and in its implementation it is hidden how the monadic value is unpacked and passed on.  Also, each monad has its own <font color="blue">return statement</font> . <br><br>  From now on, I will use a slightly different terminology for arbitrary monads.  The <font color="blue">&gt;&gt; =</font> operator accepts an input monadic value (also known as ‚Äúaction‚Äù), ‚Äúunpacks‚Äù it into a normal (non-monadic) value (unpacking for all monads looks different), and then passes this normal value to a monadic function.  It already produces a monadic value (‚Äúaction‚Äù) and returns the final result. <br><br>  Now that we have learned all of this, let's talk about the type class " <font color="blue">Monad</font> ".  Later we will look at the definition of the operator <font color="blue">&gt;&gt; =</font> for some monads, and you will learn how unpacking is done there. <br><br><h4>  <font color="blue">Monad</font> type class </h4><br>  <font color="blue">&gt;&gt; =</font> - <i>this is the</i> monadic application operator, and <font color="blue">return</font> <i>is the</i> function of converting a normal value to any monadic one.  So I said above.  However, this terminology is inaccurate, since it was also said that each monad must have its own versions of these operators / functions that are different from the others.  On the other hand, it is not at all good to call the operators <font color="blue">&gt;&gt; =</font> and <font color="blue">return</font> in different ways.  We would get unpleasant things like this: <br><br><blockquote>  IO <font color="#339933">&gt;&gt; =</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  IOreturn <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> a <br><br>  Maybe <font color="#339933">&gt;&gt; =</font> <font color="#339933">::</font> <font color="#cccc00">Maybe</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> b <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> b <br>  Maybereturn <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> a </blockquote><br><br>  What I wrote in Haskell will not pass the syntax check.  You cannot mix alphabetic and non-alphabetic characters in identifiers, and you cannot also capitalize the first letter of a function. <br><br>  The problem is beautifully solved by Haskell's ‚Äútype classes‚Äù.  (Remember, I said that the manual would be easier if you are already familiar with type classes? Type classes have nothing to do with classes from OOP, these are completely different things. Haskell type classes look more like compile-time interfaces).  A type class is a way of saying that for a heap of different types there are different embodiments of like functions (or operators).  So, for example, the class of types <font color="blue">Eq</font> contains the operator <font color="blue">==</font> with the type <font color="blue">a -&gt; a -&gt; Bool</font> (where all <font color="blue">a</font> is the same type).  For type <font color="blue">a to</font> belong to the type <font color="blue">class Eq</font> , there must be a suitable operator <font color="blue">== for it</font> (comparison for equality).  The numeric types <font color="blue">Int</font> and <font color="blue">Float</font> belong to the class of types <font color="blue">Eq</font> (you can also say that they are instances of class <font color="blue">Eq</font> ), which means that each of them has its own meaningful operator <font color="blue">==</font> .  In Haskell, this is written as follows: <br><br><blockquote>  <font>class</font> <font color="#cccc00">Eq</font> a <font>where</font> <br>  <font>(</font> <font color="#339933">==</font> <font>)</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">Bool</font> <br><br>  <font>instance</font> <font color="#cccc00">eq</font> <font color="#cccc00">int</font> <font>where</font> <br>  <font>(</font> <font color="#339933">==</font> <font>)</font> <font color="#339933">=</font> intEquals <font color="#5d478b">- the type of intEquals is: (Int -&gt; Int -&gt; Bool)</font> <br><br>  <font>instance</font> <font color="#cccc00">eq</font> <font color="#cccc00">float</font> <font>where</font> <br>  <font>(</font> <font color="#339933">==</font> <font>)</font> <font color="#339933">=</font> floatEquals <font color="#5d478b">- the floatEquals type is: (Float -&gt; Float -&gt; Bool)</font> </blockquote><br><br>  It is considered that <font color="blue">intEquals</font> is a comparison function for <font color="blue">Int</font> , and <font color="blue">floatEquals</font> is considered to be <font color="blue">Float</font> .  (I have not yet said about the inequality operator; there is the same idea.) That's all.  Now we can use the <font color="blue">==</font> operator to compare integers and real numbers with each other.  Or to compare any objects, as long as there is a corresponding instance of the <font color="blue">Eq</font> type <font color="blue">class</font> .  And it is very convenient.  In the meantime, note that <font color="blue">==</font> requires that the elements being compared have the same type;  you can't compare, say, <font color="blue">Int</font> and <font color="blue">Float</font> . <br><br>  We go further.  I repeat that I said: all monads in Haskell are type constructors, and we showed that all monads provide an independent implementation of the <font color="blue">&gt;&gt; =</font> operator and <font color="blue">return</font> functions.  From these two theses we can conclude that there is a type class called (you guessed it) <font color="blue">Monad</font> , which was originally defined as: <br><br><blockquote>  <font>class</font> <font color="#cccc00">Monad</font> m <font>where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m b <br>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m a </blockquote><br><br>  The <font color="blue">Monad</font> type class is not much more complicated than <font color="blue">Eq</font> .  It is necessary to define only two functions / operator, - not such a big deal, because we already know this.  The types of the two functions / operators are the same as those discussed above. <br><br>  The oddity with the <font color="blue">Monad</font> type class is that it is not the same as <font color="blue">Eq</font> .  <font color="blue">Monad</font> is a ‚Äúclass constructor‚Äù for which instances (indicated by <font color="blue">m</font> ) are not types, but type constructors;  we have already seen that all monads must be type constructors.  This is how we define an instance of the class constructor (for example, the <font color="blue">Maybe</font> monad is taken): <br><br><blockquote>  <font>instance</font> <font color="#cccc00">Monad</font> <font color="#cccc00">Maybe</font> <font>where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">=</font> <font color="#5d478b">{- version (&gt;&gt; =) for Maybe -}</font> <br>  <font>return</font> <font color="#339933">=</font> <font color="#5d478b">{- the version for Maybe-}</font> </blockquote><br><br>  For regular classes and for constructors of classes, the same record is chosen, which may confuse you a little, but a little practice, and everything will fall into place.  Perhaps it would be better if Haskell used this notation: <br><br><blockquote>  constructorClass <font color="#cccc00">Monad</font> m <font>where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m b <br>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m a <br><br>  constructorInstance <font color="#cccc00">Monad</font> <font color="#cccc00">Maybe</font> <font>where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">=</font> <font color="#5d478b">{- The Maybe version of (&gt;&gt; =) -}</font> <br>  <font>return</font> <font color="#339933">=</font> <font color="#5d478b">{- the Maybe version of return -}</font> </blockquote><br><br>  But it is too detailed.  There is usually enough context to understand what is going on. <br><br>  And now let's analyze a simple example, and then we will talk about the <font color="blue">Monad</font> type class. <br><br><h4>  Example </h4><br>  One of the simplest programs with the <font color="blue">IO</font> monad reads text from the terminal and prints it back (with a new line at the end).  Naturally, <font color="blue">getLine</font> and <font color="blue">putStrLn</font> are used for this.  Recall their types: <br><br><blockquote>  <font>getLine</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font color="#cccc00">String</font> <br>  <font>putStrLn</font> <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br>  For them, you cannot use the monadic composition operator <font color="blue">&gt; =&gt;</font> , because <font color="blue">getLine</font> has the form of a monadic value, and not a monadic function.  But we <i>can</i> take the operator <font color="blue">&gt;&gt; =</font> : <br><br><blockquote>  readAndPrintLine <font color="#339933">=</font> <font>getLine</font> <font color="#339933">&gt;&gt; =</font> <font>putStrLn</font> </blockquote><br><br>  We perform here the (monadic) application of the monadic function <font color="blue">putStrLn</font> to the monadic value of <font color="blue">getLine</font> .  In terms of ‚Äúactions‚Äù that we talked about earlier, we can think of it this way: <font color="blue">getLine</font> is an ‚Äúaction‚Äù that reads a line of text from a terminal and ‚Äúreturns‚Äù its monadic value;  operator <font color="blue">&gt;&gt; =</font> "unpacks" the entered string from a monadic value, passing it to <font color="blue">putStrLn</font> ;  <font color="blue">putStrLn</font> in turn prints it to the terminal and returns nothing (actually returns empty <font color="blue">()</font> as a monadic value). <br><br>  We could write this explicitly: <br><br><blockquote>  readAndPrintLine <font color="#339933">=</font> <font>getLine</font> <font color="#339933">&gt;&gt; =</font> <font>(</font> \ s <font color="#339933">-&gt;</font> <font>putStrLn</font> s <font>)</font> </blockquote><br><br>  Notice that the record <font color="blue">(\ s -&gt; putStrLn s)</font> is exactly the same as the simple function <font color="blue">putStrLn</font> , by analogy with the record <font color="blue">(\ x -&gt; cos x)</font> , which is nothing but <font color="blue">cos</font> .  So we have not changed anything important here.  But it becomes clearer how <i>something</i> (a string of text), when returned from <font color="blue">getLine</font> , is passed to <font color="blue">putStrLn</font> and printed in the terminal. <br><br>  We will dwell on this simple example and its variations in the next article in the series, as soon as we learn other functions of the <font color="blue">Monad</font> class. <br><br><h5>  Content </h5><br>  <a href="http://habrahabr.ru/blogs/Haskell/127556/">Part 1: The Basics</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128070/">Part 2: functions &gt;&gt; = and return</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128538/">Part 3: Monad Laws</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/129909/">Part 4: Maybe Monad and List Monad</a> <br><br><h5>  Notes </h5><br>  {1} The original is ‚Äúcomposability‚Äù. <br>  {3} In the original, ‚ÄúExcuse me while I go wash my hands.‚Äù Is a practically untranslatable steady expression expressing the author‚Äôs confusion, his removal from what was said and self-accusation.  Here, I think, the Russian phrase ‚ÄúI wash my hands‚Äù would be out of place. ‚ÄúAt the beginning of the next paragraph, the sentence‚Äú OK, I'm back. ‚ÄùIs meant that the author returned after washing his hands.  Replaced to maintain meaning. <br>  {4} Another name for anonymous functions: lambda functions. <br>  {5} In the original, ‚Äúextra points for functional coolness‚Äù <br>  {6} In the original - the steady expression "It's all downhill from here".  It has an ironic sense that combines two opposites: 1. Climbed to a height, the descent will be easier;  2. It will only get worse. </div><p>Source: <a href="https://habr.com/ru/post/128070/">https://habr.com/ru/post/128070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128063/index.html">Functional thinking: Thinking functionally, Part 1</a></li>
<li><a href="../128064/index.html">Steam switches to prices in rubles! Officially!</a></li>
<li><a href="../128066/index.html">Anonymous introduced their own software for Twitter</a></li>
<li><a href="../128067/index.html">How fast will Windows 8 turn on?</a></li>
<li><a href="../128068/index.html">Google showed how much energy the company's cloud services consume.</a></li>
<li><a href="../128071/index.html">Entry to robotics circles based on FML 239 (Peter)</a></li>
<li><a href="../128073/index.html">Develop applications for Windows Phone Mango on HTML5 and JavaScript</a></li>
<li><a href="../128074/index.html">New office of Yandex in Kiev</a></li>
<li><a href="../128076/index.html">PIE 1.0 Beta 5 released</a></li>
<li><a href="../128078/index.html">Generate PDF barrels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>