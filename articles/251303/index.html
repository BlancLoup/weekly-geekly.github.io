<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>16 months of functional programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of "Habrakhabr" a translation of the article "16 Months of Functional Programming" . All my comments will be in italics. 

 In thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>16 months of functional programming</h1><div class="post__text post__text-html js-mediator-article">  <em>I offer the readers of "Habrakhabr" a translation of the article <a href="http://www.vasinov.com/blog/16-months-of-functional-programming/">"16 Months of Functional Programming"</a> .</em>  <em>All my comments will be in italics.</em> <br><br>  In this article I want to share with you my experience in functional programming.  I feel that in general over the past 16 months I have become better versed in computer science and computers than in the previous 10 years, and all this thanks to my immersion in Scala and the world of functional programming.  The reason functional programming leads you to continuous development is that each task needs to be rethought again.  Sometimes it is impossible to believe that most standard tasks can be solved in a different way and - boom!  - the functional approach offers the best solution and it is shocking. <br><a name="habracut"></a><br>  So what happened to me during these 16 months?  Having closed my startup, I began to look for an interesting project for work.  He received a temporary job as a consultant in <a href="http://2lemetry.com/">2lemetry</a> , which later resulted in full-time work with immersion in functional programming, working with MQTT brokers and distributed systems.  While working at 2lemetry, Scala had a strong influence on me.  I had to reject my ideas about programming and learn everything from scratch. <br><br>  In this article I want to talk about some concepts of functional programming that impressed me.  My goal is to spark a spark in the minds of programmers who already have experience with languages ‚Äã‚Äãlike Java, Ruby and Python.  Do not worry about the fact that some code on Scala, which I cite in this article, may be incomprehensible to you.  The purpose of this code is to demonstrate the concepts of functional programming in general terms.  It is also worth mentioning that Scala is not a pure functional language, i.e.  Some things may seem inconvenient when mixing them with OOP.  I will try to point out such moments. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Content:</b> <br><br><ul><li>  Immutable state </li><li>  Functions </li><li>  Option type and pattern matching </li><li>  One-liners and for-generators </li><li>  Type system </li><li>  Lazy calculations and infinite data structures </li><li>  What's next? </li></ul><br><h2>  Immutable state </h2><br>  My first experience with Scala was fairly typical: I started working on a large project with the feeling that Scala is like Java with some cool additions and some features from Ruby.  How much I was wrong!  My code contained a changeable state wherever possible, and I did not understand why immutable lists and variables could be useful.  How to change values ‚Äã‚Äãin immutable lists?  How to change values ‚Äã‚Äãin fixed maps <em>(map)</em> ?  How to work with immutable state in cycles? <br><br>  To demonstrate the benefits of the <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B8%25D0%25B7%25D0%25BC%25D0%25B5%25D0%25BD%25D1%258F%25D0%25B5%25D0%25BC%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">unmodified state,</a> I will show two versions of the same program, one in Java, the other in Scala.  The following Java code filters the list of users by activity flag, sorts it by ID, then retrieves the list of names from these filtered users: <br><br><pre><code class="scala hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> firstName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> lastName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span> active; <span class="hljs-comment"><span class="hljs-comment">//     ,    } public static List&lt;String&gt; activeById(List&lt;User&gt; us) { List&lt;User&gt; users = new ArrayList&lt;User&gt;(); for (User u: us) { if (u.getActive()) users.add(u); } Collections.sort(users, new Comparator&lt;User&gt;() { public int compare(User a, User b) { return a.getId() - b.getId(); } }); List&lt;String&gt; finalUsers = new ArrayList&lt;String&gt;(); for (User u: users) { finalUsers.add(u.getLastname()); } return finalUsers; } List&lt;User&gt; inputUsers = new ArrayList&lt;User&gt;(); inputUsers.add(new User(11, "Nick", "Smith", false)); inputUsers.add(new User(89, "Ken", "Pratt", true)); inputUsers.add(new User(23, "Jack", "Sparrow", true)); List&lt;User&gt; activeUsersById = activeById(inputUsers)</span></span></code> </pre> <br>  <em>The author of the original article in the comments indicated that this code would be simpler for Java 8.</em>  <em>He replied that his task was to show a generally accepted imperative approach when working with data.</em> <br><br>  This is the typical Java code for version 8: each collection is modified by a set of actions.  In addition, the entire code is somewhat verbose, in each part of the <b>activeById</b> code you tell the computer what you want it to do with the data instead of describing how the data should be processed from beginning to end.  Here is the same program written in a functional style: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, firstname: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, lastname: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, active: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activeById</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">us: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span></span>= us.filter(_.active).sortBy(_.id).map(_.lastname) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activeUsersById = activeById(<span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-string"><span class="hljs-string">"Nick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Smith"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-string"><span class="hljs-string">"Ken"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pratt"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"Jack"</span></span>, <span class="hljs-string"><span class="hljs-string">"Sparrow"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ))</code> </pre><br>  <em>Unlike the Java example, the code is given in full, i.e.</em>  <em>you can run it in this form and it will work.</em> <br><br>  The code looks cleaner and shorter compared to the imperative approach, because there is no state to monitor.  The <b>activeById</b> function takes one argument (a list of users) and passes it through a chain of functions that are part of the language.  It is important to note that the <b>filter</b> , <b>sortBy</b> and <b>map</b> functions were not chosen randomly.  These functions are well described and studied by adherents of functional programming. <br><br>  Rubisty should have noticed that this sample code is very similar to what they write in Ruby.  Yes, this code may look similar, but the underlying state mechanism is very different.  The problem with Ruby is that it does not maintain a constant state.  Each variable and data structure can potentially be changed and this leads to the fact that you can not trust anything.  In Scala, there are vals (read-only variables) and immutable collections that are truly immutable. <br><br>  In the end, what gives us immutability?  From a practical point of view, your code will be cleaner, less error prone (you always know what is in your collections and read-only variables) and better abstracted.  Another big benefit from the immutability of the state is that when writing <em>concurrent</em> programs you will not be bothered that one stream can damage the data used in another stream. <br><br><h2>  Functions </h2><br>  Functional programming is about functions (surprise?).  There are various kinds of functions and techniques of functional composition that are used in functional programming. <br><br>  Pure functions are one of the pillars of functional programming.  A pure function is a function that depends only on its input parameters.  It returns the result without changing the external state.  The <b>sin (x: Double)</b> or <b>md5 (s: String)</b> functions are excellent examples of pure functions that depend only on the input parameters and always return the expected result, since  they do not rely on the state of the surrounding world.  These factors make pure functions easy to test and less prone to bugs. <br><br>  Obviously, not all tasks can be implemented using pure functions.  For example, I / O, logging, reading and writing to the database, etc.  In functional programming, there are models and abstractions that allow you to implement these unclean abstractions in their pure form, which leads to cleaner and more composable code. <br><br>  Functions in Scala are <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25B0">first class objects</a> .  This means that not only class methods can be declared and called.  In addition, they can be used as a standalone data type.  You can pass a function to another function and return another function from the function.  You can save a function in a variable or in a data structure.  You can work with it as a literal without somehow calling it <em>(lambda function)</em> .  Example: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ints = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) ints.filter(n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Look at <b>n =&gt; n% 2 == 0</b> , the full form <b>(n) =&gt; {n% 2 == 0}</b> , this is a function with no name <em>(lambda function)</em> that checks whether the number is even.  You can pass a lambda function as an argument to another function, or use it as a return value. <br><br>  Functions can be nested in other functions.  This is a useful feature when you need to recursively call a subroutine <em>(subroutines)</em> that you do not want to place in the scope that goes beyond the limits of your function. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = { <span class="hljs-meta"><span class="hljs-meta">@annotation</span></span>.tailrec <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>], l: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = s <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> =&gt; l <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Cons</span></span>(h, t) =&gt; go(t(), h() +: l) } go(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]()).reverse }</code> </pre><br>  In this example, we would not want the <b>go</b> function to be available in the same scope as the <b>toList</b> function, because its implementation is necessary only for the <b>toList</b> function and in the scope in which the <b>toList</b> function is <b>located</b> , there may be another function called <b>go</b> . <br><br>  Currying and partial application of a function is a purely mathematical concept that is well used in functional languages.  This allows us to save partially called functions into variables and transfer them to other functions. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormattedRecord</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loadRecordsFor</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">r: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Resource</span></span></span></span><span class="hljs-class"><span class="hljs-params">, since: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Record</span></span>] = ??? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatRecords</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">Long</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Record</span></span>], since: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">FormattedRecord</span></span>] = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userRecordsLoader = loadRecordsFor(<span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-number"><span class="hljs-number">36</span></span>), _: <span class="hljs-type"><span class="hljs-type">Long</span></span>) formatRecords(userRecordsLoader, <span class="hljs-type"><span class="hljs-type">System</span></span>.currentTimeMillis - <span class="hljs-number"><span class="hljs-number">86400000</span></span>)</code> </pre><br>  <em>???</em>  <em>- means ad without definition</em> <br><br>  In this example, we have two template functions <b>loadRecordsFor</b> and <b>formatRecords</b> .  We partially applied <b>loadRecordsFor</b> for some user and saved the result in the <b>userRecordsLoader</b> variable.  Then we call <b>formatRecords</b> with the <b>userRecordsLoader</b> parameter, since  this variable corresponds to the signature of the <b>formatRecords</b> function <em>(i.e., call the formatRecords function with the first argument, the partially applied function)</em> .  This kind of functional composition is quite convenient in many situations and makes the code less rigid. <br><br>  <em>This example is not very indicative.</em>  <em>I believe that the author did not disclose the subject of currying.</em> <br><br><h2>  Option type and pattern matching </h2><br>  Option data type is an abstraction that represents optional values.  It may seem that it is not particularly necessary, but in everyday work it is an extremely powerful mechanism for representing null, empty, broken objects and variable values. <br><br>  The Option type is a container that contains a value of a specific type, represented as <b>Some [T]</b> or containing nothing, represented as <b>None</b> .  The use of this type in our code allows us to forget about the countless cases of exceptions when accessing a <em>null pointer exceptions</em> or any type incompatibility, whenever null values ‚Äã‚Äãare retrieved. <br><br>  Let's look at an example: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Project</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, priority: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, description: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsAccessor</span></span></span><span class="hljs-class"> </span></span>{ find(id: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Project</span></span>] = ??? } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project = <span class="hljs-type"><span class="hljs-type">ProjectsAccessor</span></span>.find(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre><br>  Here we are trying to get a record about the project from the database, but we don‚Äôt know if there is a project with such an ID.  Instead of returning null or throwing an exception, we return <b>Some [Project]</b> or <b>None</b> , since  when declaring the <b>find</b> method, we specified the return type as <b>Option [Project]</b> . <br><br>  Container types allow us to use another powerful tool - <em>pattern matching (pattern matching)</em> .  Pattern matching is an approach to data processing based on their structure.  If we want to process the result of calling the <b>find</b> method from the example above and get the name of the project, we can do something like: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ProjectsAccessor</span></span>.find(<span class="hljs-number"><span class="hljs-number">123</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(p) =&gt; p.name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> }</code> </pre><br>  We compare with the sample the result of the <b>find</b> method to verify the existence of a project.  If it exists, then its name is returned, otherwise we return an empty string.  At first glance, this may look like a switch-case statement in Java, but in fact they are very different.  When matching with the sample, you can add non-trivial logic to the templates: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ProjectsAccessor</span></span>.find(<span class="hljs-number"><span class="hljs-number">123</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(p) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> until <span class="hljs-number"><span class="hljs-number">5</span></span> contains p.priority =&gt; p.name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(p) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name == <span class="hljs-string"><span class="hljs-string">"Default Project"</span></span> =&gt; p.name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(p) =&gt; <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> }</code> </pre><br>  You can also compare the result based on the current structure of the object: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptionWrapper</span></span></span></span>(p: <span class="hljs-type"><span class="hljs-type">Project</span></span>) = p <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Project</span></span>(_, _, _, <span class="hljs-type"><span class="hljs-type">None</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"No description."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Project</span></span>(id, _, _, <span class="hljs-type"><span class="hljs-type">Some</span></span>(d)) =&gt; <span class="hljs-string"><span class="hljs-string">s"Project </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$id</span></span></span><span class="hljs-string">'s description: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$d</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  This approach to processing complex logical constructions is more compact and straightforward compared with if-operators and a cumbersome switch-case. <br><br><h2>  <em>One-Liners</em> and for-generators </h2><br>  One of the great features of a functional composition is the functional chains.  Instead of constantly repeating repetitive actions on collections using loops, you can do it with one elegant expression or one-liner.  For example: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Participant</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, active: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ps</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-type"><span class="hljs-type">Participant</span></span>(<span class="hljs-string"><span class="hljs-string">"Jack"</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-type"><span class="hljs-type">Participant</span></span>(<span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-type"><span class="hljs-type">Participant</span></span>(<span class="hljs-string"><span class="hljs-string">"Bob"</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) ps.filter(_.score &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>).filter(_.active).map(_.copy(active = <span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  In this one-liner, we collected all subscribers whose result is less than 50 and which are still active, then we changed the status of the selected subscribers to false.  In the end, we got a <b>List (Participant (Jack, 34, false))</b> .  There are quite a large number of situations in which such one-liners save programmers time and dramatically reduce the amount of code. <br><br>  If the one-liner becomes too opaque, then it can always be broken using the for-generator.  The example above can be rewritten into an equivalent expression: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { loser &lt;- ps <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> loser.score &lt; <span class="hljs-number"><span class="hljs-number">50</span></span> activeLoser &lt;- <span class="hljs-type"><span class="hljs-type">Some</span></span>(loser) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> activeLoser.active deactivatedLoser &lt;- <span class="hljs-type"><span class="hljs-type">Some</span></span>(activeLoser.copy(active = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deactivatedLoser</code> </pre><br>  This expression is more verbose than a one-liner, but in cases where the logic becomes too opaque, this technique really helps to improve the readability of the code while retaining all the advantages of immutability and function chains. <br><br>  <em><a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html">In Scala, for-generator is syntactic sugar for a chain of functions.</a></em> <br><br><h2>  Type system </h2><br>  After programming in Ruby, strict typing in Scala felt like a burden, because I used it as a javist.  I added a detailed description of types everywhere and did not use <em>generic</em> functions.  Needless to say, this was the wrong approach to work.  Some functional languages ‚Äã‚Äãhave an advanced type system with properties that are not used by programmers in popular languages.  These properties allow the code to be more flexible and composable.  Let's go over some of them. <br><br>  Type inference is the ability of a compiler to guess the type of an expression without being explicitly indicated by the programmer.  In some cases, Scala cannot guess the type without a hint.  Let's look at an example: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//          def nameStartsWith(ns: Seq[String], n: String): Seq[String] = // Scala       , ..     Seq.empty ns.foldLeft(Seq.empty[String]) { //   -      (l, r) =&gt; if(r.startsWith(n)) r +: l else l } //        val names = Seq("Bob", "Alice", "Ann") nameStartsWith(names, "A") //  List(Ann, Alice)</span></span></code> </pre><br>  This example shows both sides of type inference in Scala: you must explicitly specify types, but in some cases, such as when you pass a lambda function as an argument <em>(l, r) =&gt; ...</em> , you can omit the types.  In pure functional languages ‚Äã‚Äãsuch as Haskell, you hardly ever have to specify the type in programs <em>(controversial statement)</em> .  The compiler is smart enough to output them. <br><br>  <em>It is worth noting that when declaring a function it was not necessary to specify the type of the return value, the Scala compiler will output it itself.</em> <br><br>  Type constraints are another important concept in functional programming.  In general, this means that you can specify a class hierarchy when declaring a generic type.  In Java, you can use generalizations to define a type at runtime and still consider your code as type-safe.  For example, to declare a generic list of elements of some type, you must use an interface (Java code): <b>public interface MyList &lt;T&gt;</b> .  If you want to declare a list, say, containing mappings <em>(Map)</em> , but you do not know which implementation of mappings will be used, then you need to specify an upper limit for the type in your interface <b>public interface MyList &lt;T extends Map&gt;</b> .  Now you can use a list filled with such types as <b>Hashtable</b> , <b>LinkedHashMap</b> , <b>HashMap</b> and <b>TreeMap</b> or in other words all descendants of the <b>Map</b> interface.  However, no other type can be used, since  marked upper bound.  Here is an example of using Scala's upper bound: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToInts</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">AnyVal</span></span>](es: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = { es.map(f(_)) }</code> </pre><br>  <b>AnyVal</b> is the parent of classes such as <b>Double</b> , <b>Float</b> , <b>Int,</b> and many other <em>(scalar types)</em> .  In this function, we simply declared that type <b>T</b> would be a descendant of <b>AnyVal</b> .  You can also specify a lower bound for the type, like <b>[T&gt;: Int]</b> this will correspond to parents of type <b>Int</b> .  You can also mix type boundaries for various generalizations in the function signature: <b>[T&gt;: Int &lt;: Any]</b> . <br><br>  One of the important properties of an advanced type system is <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">covariance and contravariance</a> .  In Java, if you have <b>class List &lt;T&gt;</b> , <b>List &lt;Object&gt;,</b> and <b>List &lt;String&gt;</b> , then they will be unconnected or invariant.  On the other hand, there are covariant arrays, i.e.  <b>String []</b> is a subtype of type <b>Object []</b> .  Since arrays are mutable in some cases, you can get an <b>ArrayStoreException</b> exception at <b>runtime</b> .  In Scala, arrays are invariant by default, and immutable collections (or container types) are covariant <b>[+ A]</b> .  Since they are unchangeable, all potential errors will be detected at compile time, and not runtime.  Another possibility is to specify the container as a countervariant <b>[-A]</b> .  Countervariance means that the container with the parent type is a subtype of the container with the child type.  Here's how it works: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvariantContainer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CovariantContainer</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContravariantContainer</span></span></span><span class="hljs-class">[-</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Admin</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inv1</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">InvariantContainer</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] = <span class="hljs-type"><span class="hljs-type">InvariantContainer</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] <span class="hljs-comment"><span class="hljs-comment">// works val inv2: InvariantContainer[User] = InvariantContainer[Admin] // doesn't work val cov1: CovariantContainer[User] = CovariantContainer[User] // works val cov2: CovariantContainer[User] = CovariantContainer[Admin] // works val con1: ContravariantContainer[User] = ContravariantContainer[User] // works val con2: ContravariantContainer[User] = ContravariantContainer[Admin] // doesn't work val con3: ContravariantContainer[User] = ContravariantContainer[Person] // works</span></span></code> </pre><br>  Covariance and countervariance are widely used in the implementation of collections and hot-webs when specifying the type of function. <br><br>  The last advanced type feature that I would like to touch on is the bounds of the view <em>(view bounds)</em> .  Suppose you need to perform operations on numbers, but some of them are represented as strings (ie, ‚Äú123‚Äù or 123).  How do you do it?  In a simple case, like this one, you can convert strings to numbers manually or, in more complex cases, write your own converter, and then explicitly call it to convert data from one type to another.  In weakly typed languages ‚Äã‚Äãsuch as Ruby, the interpreter will dynamically convert strings to numbers.  You might be surprised that Scala has a way to implement this behavior without losing type safety. <br><br>  <em>As far as I understand, the author is mistaken with Ruby, for example, such code will not work <b>[10, ‚Äú20‚Äù]. Min</b> .</em>  <em>In this case, it would be more correct to cite PHP as an example.</em> <br><br>  For this to work in Scala (let's use the standard function <b>math.min ()</b> for an example), all you need to do is define an implicit converter for your types: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strToInt</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">String</span></span>) = x.toInt math.min(<span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Here Scala will look for implicit conversions from string to number.  After finding the <b>strToInt</b> function based on its signature, it will be applied to all strings passed to <b>math.min</b> without an explicit call to <b>strToInt</b> .  If you have not declared an implicit conversion, the compiler will throw an exception.  <em>And if you declare and try to pass a string that is not a number, you will get an exception in runtime.</em> <br><br>  What if we want to write a magic function that finds an implicit conversion for itself?  It is very easy!  All you need to do is declare a view boundary that tells the compiler to search for an implicit conversion: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strToInt</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">String</span></span>) = x.toInt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">halfIt</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span> &lt;% <span class="hljs-type"><span class="hljs-type">Int</span></span>](x: <span class="hljs-type"><span class="hljs-type">A</span></span>) = x / <span class="hljs-number"><span class="hljs-number">2</span></span> halfIt(<span class="hljs-string"><span class="hljs-string">"20"</span></span>)</code> </pre><br>  The result of calling <b>halfIt (‚Äú20‚Äù)</b> will be 10 as expected.  The boundary of the form <b>[A &lt;% Int]</b> expects <b>Int</b> or all that can be considered <b>Int</b> .  In our case, this is a string that can be implicitly converted to a number. <br><br><h2>  Lazy calculations and infinite data structures </h2><br>  The concept of lazy computing does not directly exist in non-functional languages, but it is easy to grasp.  Look at the usual condition: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expensiveOperation</span></span></span></span>() = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a == b) || expensiveOperation()) <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br>  In most imperative languages, the operator <b>||</b>  computes predicates <b>(a == b)</b> and <b>expensiveOperation () is</b> lazy, i.e.  <b>expensiveOperation ()</b> will not be called until <b>if (a == b)</b> is <b>true</b> <em>(i.e., as long as <b>a</b> is equal to <b>b</b> )</em> .  And <b>expensiveOperation ()</b> will be called if <b>if (a == b)</b> returns <b>false</b> .  Lazy calculations in Scala allow you to define similar behavior in different contexts. <br><br>  You can define variables as <b>lazy</b> , i.e.  they will not be calculated until they are addressed for the first time, in contrast to ordinary variables that are calculated upon declaration.  After a single calculation, the lazy variable remembers its value. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, price: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, orders: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Order</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cheapOrders: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">Order</span></span>] = orders.filter(_.price &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expensiveOrders: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">Order</span></span>] = orders.filter(_.price &gt;= <span class="hljs-number"><span class="hljs-number">50</span></span>) }</code> </pre> <br>  In this example, we have a <b>case class</b> for representing the user, which contains lists of orders.  Unlike conventional properties, <b>cheapOrders</b> and <b>expensiveOrders</b> will not be calculated at the time of class initialization <em>(that is, at the time the object is created from the class)</em> .  They are calculated when we refer to them directly.  Why not use the method?  The problem is that we can have expensive computations or every time there are calls to the database when we call the method.  Lazy variables retain their results on first access, which can lead to effective optimizations in some cases. <br><br>  <em>In other languages, they use the technique of <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">memoisation</a> , which can also be considered as lazy calculations.</em> <br><br>  Another example of deferred computing is passing arguments by name <em>(call-by-name)</em> .  Usually, the function arguments are evaluated before they are passed to it.  However, in some cases it is useful to calculate the argument passed in when it is required. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Admin</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loadAdminsOrUsers</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">needAdmins: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params">, loadAdmins: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Admin</span></span></span></span><span class="hljs-class"><span class="hljs-params">], loadUsers: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needAdmins) loadAdmins <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> loadUsers }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have three by-name parameters with potentially expensive database access operations. We would not want all of them to be completed before they fall into our method. The arrow </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> means that we are passing in the function itself, and not the value it returns. Now we can call her when we need it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lazy calculations and by-name parameters are used to implement one of the most powerful functional programming constructs - infinite data structures. In imperative programming, all your data structures have a certain size, which is actually excellent for most cases, but sometimes it is unknown what size the data structure will be. With deferred calculations, it is possible to declare a data structure in general form without its full content until you need it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this sounds good in theory, but will it work? </font><font style="vertical-align: inherit;">Let's use an infinite data structure called stream to generate prime numbers. </font><font style="vertical-align: inherit;">In Java, to generate prime numbers, you can write a function that would generate prime numbers up to a certain limit. </font><font style="vertical-align: inherit;">Then you could call this function to generate a list of N prime numbers and pass it somewhere. </font><font style="vertical-align: inherit;">If you need another list of prime numbers, you will have to recalculate your list from scratch. </font><font style="vertical-align: inherit;">In Scala, we can do something like:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> primes: <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generatePrimes</span></span></span><span class="hljs-function"> </span></span>(s: <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = s.head #:: generatePrimes(s.tail filter (_ % s.head != <span class="hljs-number"><span class="hljs-number">0</span></span>)) generatePrimes(<span class="hljs-type"><span class="hljs-type">Stream</span></span>.from(<span class="hljs-number"><span class="hljs-number">2</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The syntax may seem confusing to you, but in this case it does not matter. </font><font style="vertical-align: inherit;">The key is what you can do with this data structure. </font><font style="vertical-align: inherit;">Let's say that you need to get the first 5 primes greater than 100. This is easy using our stream:</font></font><br><br><pre> <code class="scala hljs">primes.filter(_ &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>).take(<span class="hljs-number"><span class="hljs-number">5</span></span>).toList</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This functional chain will return a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List (101, 103, 107, 109, 113)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - as expected. The cool thing is that you can transfer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to any other functions without having to reassemble it every time. You can also use chains of functions (like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the example above) and pass this expression already without generating an intermediate result. This allows us to compose abstractions and sculpt programs like plasticine.</font></font><br><br><h2>  What's next? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope I am interested in functional programming. </font><font style="vertical-align: inherit;">For me, writing about it was very exciting. </font><font style="vertical-align: inherit;">I admit that much remains to be learned and learned in this area. </font><font style="vertical-align: inherit;">My goal is to start digging deeper into functional programming theory, such as typed lambda calculus, type theory, and category theory. </font><font style="vertical-align: inherit;">I also want to learn Haskell - a pure functional programming language, and I hope that it will bear fruit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I read thanks to all who read it!</font></font></div><p>Source: <a href="https://habr.com/ru/post/251303/">https://habr.com/ru/post/251303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251293/index.html">What bugs did LibreOffce find in PVS-Studio?</a></li>
<li><a href="../251295/index.html">Data compression methods</a></li>
<li><a href="../251297/index.html">Ekspozzer - creating a panorama from a video, averaging a video stream</a></li>
<li><a href="../251299/index.html">Lamp showing the weather forecast</a></li>
<li><a href="../251301/index.html">Administration of computers on the local network before loading the operating system</a></li>
<li><a href="../251307/index.html">node-seq in a new way (again about asynchrony)</a></li>
<li><a href="../251309/index.html">IBM invites to the ‚ÄúSoftlayer Introduction‚Äù webinar</a></li>
<li><a href="../251311/index.html">Implementation of the universal aquarium controller</a></li>
<li><a href="../251313/index.html">Wi-Fi is good, but it is normal. Practice using Ruckus in the office</a></li>
<li><a href="../251315/index.html">Wordpress Benefits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>