<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static analysis of printf-like functions in C using libclang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Compared with many modern languages, C often seems extremely primitive and insecure. And one of the frequent complaints about the language is the impo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static analysis of printf-like functions in C using libclang</h1><div class="post__text post__text-html js-mediator-article">  Compared with many modern languages, C often seems extremely primitive and insecure.  And one of the frequent complaints about the language is the impossibility of access from the code to its internal representation.  In other languages, this is traditionally done by mechanisms, such as reflections, and is quite convenient to use. <br><br>  However, with the advent of libclang, you can write your own analyzers and code generators directly at compile time, eliminating a fairly large number of problems in the early stages of work.  The combination of static general analysis tools (coverity, clang-scan), analysis tools for a particular project, as well as the discipline of writing code, allows us to significantly improve the quality and security of code written in C.  Of course, this will not guarantee that haskell or even rust gives you, but it allows you to significantly optimize the development process, especially in the case when rewriting a huge project in another language is an impossible task. <br><br>  In this article, I would like to share the experience of creating a static analysis plug-in format argument for functions similar to printf.  In the course of writing the plugin, I had a lot of digging through the sources and doxygen of the libclang documentation, so I found it useful to do some review for those who want to step on this thorny path, but are not yet sure whether to waste time collecting information.  The article will not be pictures, and even pictures of the vomiting unicorns, I'm sorry. <br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br>  I had a problem with analyzing printf like functions in the project ( <a href="https://rspamd.com/">https://rspamd.com</a> ) for a long time: the standard printf from libc did not suit me for many reasons: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> when printing to the buffer, printf (3) tries to parse the entire format string entirely, even if it includes huge null-terminated lines, and the destination buffer is very small: <code>snprintf(buf, 16, "%s", str)</code> , where <code>str</code> is very long string;  this behavior was of no use to me </li><li>  printf understands fixed length integers extremely poorly (uint32_t, uitn64_t) </li><li>  I wanted to print my own data structures, for example, fixed length strings without a '\ 0' at the end </li><li>  I wanted more ‚Äúadvanced‚Äù formatting flags: hex encoding, human readable integers, and so on </li><li>  I wanted to be able to type in my own data structures, for example, automatically expandable lines </li></ul><br><br>  Therefore, in due time I took printf from nginx and adapted it for my tasks.  Sample code can be found <a href="">here</a> .  This approach has one drawback - it completely disables the work of the standard query string analyzer from the compiler, and the general static analyzers are unable to understand what arguments mean.  However, this problem is ideally solved with the help of an abstract syntax tree (AST) of the compiler, access to which is provided through libclang. <br>  The AST processing plugin should perform the following tasks: <br><br><ul><li>  Parsing the query string and extracting all <b>'%'</b> arguments from it </li><li>  Comparison of the number of arguments in the query string and the functions passed </li><li>  Ability to check the type of each argument (including complex types) </li><li>  Ability to test functions that take the query string in different positions (for example, <i>printf / fprintf / snprintf</i> ) </li></ul><br><br><h3>  Compilation and work with the plugin </h3><br>  Despite the fact that there are enough examples of working with libclang on the Internet, most of them are dedicated to analyzing definitions rather than analyzing expressions, besides, for some reason many examples are written in Python, writing in which there is a beautiful (in my opinion) C + +11 I absolutely did not want to (although compile time prototypes in C + + - this is the main serious drawback). <br><br>  The first problem I encountered was that different versions of llvm provide different APIs.  In addition, for example, the osx assembly llvm, installed via macports, turned out to be inoperable from the word "no way".  Therefore, I just installed llvm on my linux sandbox and worked specifically with this version - 3.7.  However, this code should also work on 3.6+. <br><br>  The second problem was the assembly system.  My project uses cmake, so I wanted, of course, to use it to build a plugin.  The idea was that with the option turned on, build the plugin, and then use it to build the rest of the code.  First of all, as was the case with cmake, I had to write a package in order to find llvm and libclang in the system, the arrangement of CXX flags (for example, the inclusion of the c ++ 11 standard).  Unfortunately, due to the inoperability of llvm in osx, it completely broke off the integration with the wonderful IDE <a href="https://www.jetbrains.com/clion/">CLion</a> , which I use for everyday work, so I had to write code without add-ons and other amenities offered by IDE. <br><br>  Compiling the plugin did not cause any special problems: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">FIND_PACKAGE</span></span>(LLVM REQUIRED) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(CLANGPLUGINSRC plugin.cc printf_check.cc) <span class="hljs-keyword"><span class="hljs-keyword">ADD_LIBRARY</span></span>(rspamd-clang SHARED <span class="hljs-variable"><span class="hljs-variable">${CLANGPLUGINSRC}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET_TARGET_PROPERTIES</span></span>(rspamd-clang PROPERTIES COMPILE_FLAGS <span class="hljs-string"><span class="hljs-string">"${LLVM_CXX_FLAGS} ${LLVM_CPP_FLAGS} ${LLVM_C_FLAGS}"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span></span> <span class="hljs-variable"><span class="hljs-variable">${LIBCLANG_INCLUDE_DIR}</span></span> LINKER_LANGUAGE CXX) <span class="hljs-keyword"><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span></span>(rspamd-clang <span class="hljs-variable"><span class="hljs-variable">${LIBCLANG_LIBRARIES}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">LINK_DIRECTORIES</span></span>(<span class="hljs-variable"><span class="hljs-variable">${LLVM_LIBRARY_DIRS}</span></span>)</code> </pre><br>  But with the inclusion of it to work with the rest of the code there were problems.  First, cmake showed remarkable artificial intelligence, grouping compiler options for some reason, turning <code>-Xclang opt1 -Xclang opt2</code> into <code>-Xclang opt1 opt2</code> , which completely broke the compilation.  Found a way out through direct installation <code>CMAKE_C_FLAGS</code> : <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (ENABLE_CLANG_PLUGIN <span class="hljs-keyword"><span class="hljs-keyword">MATCHES</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(CMAKE_C_FLAGS <span class="hljs-string"><span class="hljs-string">"${CMAKE_C_FLAGS} -Xclang -load -Xclang ${CMAKE_CURRENT_BINARY_DIR}/../clang-plugin/librspamd-clang.so -Xclang -add-plugin -Xclang rspamd-ast"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ()</code> </pre><br>  As you can see, we had to explicitly specify the path to the resulting library, which potentially broke down the system operation under osx (where dylib is used instead of .so), but this was of minor importance due to the inoperability of llvm under osx.  The second problem was that if you specify <code>-Xclang -plugin</code> , as recommended in almost all examples, clang stops compiling the source code (that is, it does not generate object files), performing only an analysis.  The way out was to replace <code>-Xclang -plugin</code> with <code>-Xclang -add-plugin</code> , which was found after some meditation on the issue of Google. <br><br><h3>  Writing plugin </h3><br>  In this part, I would not like to strongly focus on the basics of creating plugins - quite a lot of material is devoted to this.  In short, a plugin is created using the static method <code>clang::FrontendPluginRegistry::Add</code> , which registers the plugin for clang.  This method is a template method, and it accepts a class type that inherits from <code>clang::PluginASTAction</code> and defines the necessary methods in it: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RspamdASTAction</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PluginASTAction { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span> &lt;ASTConsumer&gt; CreateASTConsumer (CompilerInstance &amp;CI, llvm::StringRef) override { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::make_unique&lt;RspamdASTConsumer&gt; (CI); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseArgs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CompilerInstance &amp;CI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;args)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintHelp</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(llvm::raw_ostream &amp;ros)</span></span></span><span class="hljs-function"> </span></span>{ ros &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Nothing here\n"</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FrontendPluginRegistry::Add &lt;rspamd::RspamdASTAction&gt; X (<span class="hljs-string"><span class="hljs-string">"rspamd-ast"</span></span>, <span class="hljs-string"><span class="hljs-string">"rspamd ast checker"</span></span>);</code> </pre><br>  The main interesting method is the <code>CreateASTConsumer</code> method, which tells the clang that the resulting object must be called at the stage when the compiler has translated the code into the syntax tree.  All further work is carried out in ASTConsumer, which in turn defines the <code>HandleTranslationUnit</code> method, which, in fact, gets the context of the syntax tree.  <code>CompilerInstance</code> used to control the compiler, for example, to generate errors and warnings, which is extremely convenient when working with a plugin.  The entire ASTConsumer is described as: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RspamdASTConsumer</span></span></span><span class="hljs-class"> : public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ASTConsumer</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompilerInstance</span></span></span><span class="hljs-class"> &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Instance</span></span></span><span class="hljs-class">; public: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RspamdASTConsumer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompilerInstance</span></span></span><span class="hljs-class"> &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Instance</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Instance</span></span></span><span class="hljs-class">) { } void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HandleTranslationUnit</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ASTContext</span></span></span><span class="hljs-class"> &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">) override { rspamd::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrintfCheckVisitor</span></span></span><span class="hljs-class"> v(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Instance</span></span></span><span class="hljs-class">); v.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TraverseDecl</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getTranslationUnitDecl</span></span></span><span class="hljs-class"> ()); } };</span></span></code> </pre><br>  Here we create ASTVisitor, which visits the tree nodes, and perform a compile tree traversal.  In this class, in fact, all the work on the analysis of the function call is done.  This class is defined extremely simply (using the <a href="http://herbsutter.com/gotw/_100/">pimpl idiom</a> ): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintfCheckVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> clang::RecursiveASTVisitor&lt;PrintfCheckVisitor&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;impl&gt; pimpl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PrintfCheckVisitor (clang::ASTContext *ctx, clang::CompilerInstance &amp;ci); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintfCheckVisitor (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCallExpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(clang::CallExpr *E)</span></span></span></span>; };</code> </pre><br>  The main idea is the inheritance from the <code>clang::RecursiveASTVisitor</code> , which performs tree traversal, and the definition of the <code>VisitCallExpr</code> method, which is called when it is in a function call tree.  In this method (proxied in pimpl), the main work is performed on parsing functions and their arguments.  The method starts like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCallExpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallExpr *E)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> callee = dyn_cast&lt;NamedDecl&gt; (E-&gt;getCalleeDecl ()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { llvm::errs () &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Bad callee\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fname = callee-&gt;getNameAsString (); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos_it = printf_functions.find (fname); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos_it != printf_functions.end ()) {</code> </pre><br>  In this piece of code, we get the definition (declaration) of the function from the expression and extract the function name.  Next we look in the <code>printf_functions</code> hash, whether this function is of interest to us: <br><br><pre> <code class="hljs objectivec">printf_functions = { {<span class="hljs-string"><span class="hljs-string">"rspamd_printf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"rspamd_default_log_function"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, {<span class="hljs-string"><span class="hljs-string">"rspamd_snprintf"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"rspamd_fprintf"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>} };</code> </pre><br>  The number indicates the position of the query string in the arguments.  Further, if the function interests us, we extract the query string and analyze it (for this I wrote an automaton, which is somewhat beyond the scope of this article): <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> args = E-&gt;getArgs (); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = pos_it-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> query = args[pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!query-&gt;isEvaluatable (*pcontext)) { print_warning (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> (<span class="hljs-string"><span class="hljs-string">"cannot evaluate query"</span></span>), E, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pcontext, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } clang::Expr::EvalResult r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!query-&gt;EvaluateAsRValue (r, *pcontext)) { print_warning (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> (<span class="hljs-string"><span class="hljs-string">"cannot evaluate rvalue of query"</span></span>), E, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pcontext, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qval = dyn_cast&lt;StringLiteral&gt; ( r.Val.getLValueBase ().get&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Expr *&gt; ()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!qval) { print_warning (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> (<span class="hljs-string"><span class="hljs-string">"bad or absent query string"</span></span>), E, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pcontext, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  In this passage, it is important that we first try to <em>calculate the</em> query string, if possible.  This is useful, for example, if the query string is formed with the help of an expression.  Unfortunately, working with values ‚Äã‚Äãin libclang is quite difficult: you need to take an expression, evaluate it (EvaluateAsRValue), take a result that can already be converted to LValue, and then to <code>StringLiteral</code> .  If the calculation is not needed, then you can take <code>Expr *</code> directly and bring it to <code>StringLiteral</code> , which greatly simplifies the code. <br><br>  Next, I analyzed the query string and received a vector of such structures: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintfArgChecker</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">arg_parser_t</span></span> parser; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> precision; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_unsigned; ASTContext *past; CompilerInstance *pci; PrintfArgChecker (<span class="hljs-keyword"><span class="hljs-keyword">arg_parser_t</span></span> _p, ASTContext *_ast, CompilerInstance *_ci) : parser (_p), past (_ast), pci(_ci) { width = <span class="hljs-number"><span class="hljs-number">0</span></span>; precision = <span class="hljs-number"><span class="hljs-number">0</span></span>; is_unsigned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintfArgChecker () { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Expr *e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser (e, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre><br>  Each such structure contains a call method that takes an argument ( <code>Expr *</code> ) and checks its type against the specified one.  Then we just check all the arguments after the query string for the types: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsers-&gt;size () != E-&gt;getNumArgs () - (pos + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { std::ostringstream err_buf; err_buf &lt;&lt; <span class="hljs-string"><span class="hljs-string">"number of arguments for "</span></span> &lt;&lt; fname &lt;&lt; <span class="hljs-string"><span class="hljs-string">" missmatches query string '"</span></span> &lt;&lt; qval-&gt;getString ().<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> () &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', expected "</span></span> &lt;&lt; parsers-&gt;size () &lt;&lt; <span class="hljs-string"><span class="hljs-string">" args"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">", got "</span></span> &lt;&lt; (E-&gt;getNumArgs () - (pos + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &lt;&lt; <span class="hljs-string"><span class="hljs-string">" args"</span></span>; print_error (err_buf.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> (), E, this-&gt;pcontext, this-&gt;ci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto i = pos + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; E-&gt;getNumArgs (); i++) { auto arg = args[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parsers-&gt;at (i - (pos + <span class="hljs-number"><span class="hljs-number">1</span></span>)) (arg)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } }</code> </pre><br>  The <code>print_error</code> function <code>print_error</code> interesting because it can print a compilation error and stop the compilation process.  This is done through <code>CompilerInstance</code> , but in a rather non-obvious way: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_error</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Expr *e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASTContext *ast, CompilerInstance *ci)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> loc = e-&gt;getExprLoc (); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;diag = ci-&gt;getDiagnostics (); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> id = diag.getCustomDiagID (DiagnosticsEngine::Error, <span class="hljs-string"><span class="hljs-string">"format query error: %0"</span></span>); diag.Report (loc, id) &lt;&lt; err; }</code> </pre><br>  Accordingly, to display a warning, you need to use <code>DiagnosticsEngine::Warning</code> . <br><br>  Type analysis is performed, in general, by two methods.  One can check built-in types, for example, long / int, etc., and the second is complex types, for example, structures.  For checking simple types, use <code>clang::BuiltinType::Kind</code> , which defines all types known to Klang.  Possible values ‚Äã‚Äãcan be searched in <code>/usr/include/clang/AST/BuiltinTypes.def</code> (for Linux).  There are two subtleties: <br><br><ul><li>  Fixed size int can be differently matched with the built-in type, so you need to do checks like <code>if (sizeof (int32_t) == sizeof (int)) {...} if (sizeof (int32_t) == sizeof (long)) {...}</code> </li><li>  Arguments can be aliases to other types, so first you need to get rid of these aliases, for example <code>typedef my_int int</code> </li></ul><br>  The final function of checking simple types looks like this: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool check_builtin_type (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Expr *arg, struct PrintfArgChecker *ctx, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::vector &lt;BuiltinType::Kind&gt; &amp;k, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string &amp;fmt) { auto type = arg-&gt;getType ().split ().Ty; auto desugared_type = type-&gt;getUnqualifiedDesugaredType (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!desugared_type-&gt;isBuiltinType ()) { print_error ( std::string (<span class="hljs-string"><span class="hljs-string">"not a builtin type for "</span></span>) + fmt + <span class="hljs-string"><span class="hljs-string">" arg: "</span></span> + arg-&gt;getType ().getAsString (), arg, ctx-&gt;past, ctx-&gt;pci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } auto builtin_type = dyn_cast&lt;BuiltinType&gt; (desugared_type); auto kind = builtin_type-&gt;getKind (); auto found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto kk : k) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kind == kk) { found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!found) { print_error ( std::string (<span class="hljs-string"><span class="hljs-string">"bad argument for "</span></span>) + fmt + <span class="hljs-string"><span class="hljs-string">" arg: "</span></span> + arg-&gt;getType ().getAsString () + <span class="hljs-string"><span class="hljs-string">", resolved as: "</span></span> + builtin_type-&gt;getNameAsCString (ctx-&gt;past-&gt;getPrintingPolicy ()), arg, ctx-&gt;past, ctx-&gt;pci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  As you can see, the <code>getUnqualifiedDesugaredType</code> method is used to remove aliases, and the <code>arg-&gt;getType()</code> method is used to get the type of expression from the expression.  But this method returns the qualified type (for example, including the <code>const</code> specifier), which is not needed for this task, so the <code>split</code> type is <code>split</code> , and only the pure type is taken from the resulting structure. <br><br>  For complex types, you must select the name of the structure, enumeration or union.  The check function looks like this: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool check_struct_type (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Expr *arg, struct PrintfArgChecker *ctx, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string &amp;sname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string &amp;fmt) { auto type = arg-&gt;getType ().split ().Ty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!type-&gt;isPointerType ()) { print_error ( std::string (<span class="hljs-string"><span class="hljs-string">"bad string argument for %s: "</span></span>) + arg-&gt;getType ().getAsString (), arg, ctx-&gt;past, ctx-&gt;pci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } auto ptr_type = type-&gt;getPointeeType ().split ().Ty; auto desugared_type = ptr_type-&gt;getUnqualifiedDesugaredType (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!desugared_type-&gt;isRecordType ()) { print_error ( std::string (<span class="hljs-string"><span class="hljs-string">"not a record type for "</span></span>) + fmt + <span class="hljs-string"><span class="hljs-string">" arg: "</span></span> + arg-&gt;getType ().getAsString (), arg, ctx-&gt;past, ctx-&gt;pci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } auto struct_type = desugared_type-&gt;getAsStructureType (); auto struct_decl = struct_type-&gt;getDecl (); auto struct_def = struct_decl-&gt;getNameAsString (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (struct_def != sname) { print_error (std::string (<span class="hljs-string"><span class="hljs-string">"bad argument '"</span></span>) + struct_def + <span class="hljs-string"><span class="hljs-string">"' for "</span></span> + fmt + <span class="hljs-string"><span class="hljs-string">" arg: "</span></span> + arg-&gt;getType ().getAsString (), arg, ctx-&gt;past, ctx-&gt;pci); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  Since we assume that the argument is not a structure, but a pointer to it, we first define the type of the pointer using <code>type-&gt;getPointeeType().split().Ty</code> .  Then we perform desugaring and find the type declaration: <code>struct_type-&gt;getDecl()</code> .  After that, checks are done in a rather trivial way. <br><br><h3>  results </h3><br>  Of course, after writing the plugin, I began to check how it works on my main code.  There were simple problems with types: <br><br><pre> [44%] Building C object src / CMakeFiles / rspamd-server.dir / libutil / map.co
 src / libutil / map.c: 906: 46: error: format error query for% z arg: guint, resolved as: unsigned int
                 msg_info_pool ("read hash of% z elements", g_hash_table_size
                                                            ^
 src / libutil / logger.h: 190: 9: note: expanded from macro 'msg_info_pool'
         __VA_ARGS__)
         ^
 1 error generated.
</pre><br><br>  So serious problems: <br><pre> [45%] Building C object src / CMakeFiles / rspamd-server.dir / libserver / protocol.co
 src / libserver / protocol.c: 373: 45: error: format query argument: bad argument 'f_str_tok' for% V arg: rspamd_ftok_t *
                                         msg_err_task ("bad from header: '% V'", h-&gt; value);
                                                                                ^
 src / libutil / logger.h: 164: 9: note: expanded from macro 'msg_err_task'
         __VA_ARGS__)
         ^
 1 error generated.
 [44%] Building C object src / CMakeFiles / rspamd-server.dir / libstat / tokenizers / osb.co
 src / libstat / tokenizers / osb.c: 128: 48: error: format query: string% argument:% gsize
                                         msg_warn ("siphash key is too short:% s", keylen);
                                                                                   ^
 src / libutil / logger.h: 145: 9: note: expanded from macro 'msg_warn'
         __VA_ARGS__)
         ^
 1 error generated.
</pre><br>  As well as problems with the number of arguments: <br><br><pre> [46%] Building C object src / CMakeFiles / rspamd-server.dir / libmime / mime_expressions.co
 src / libmime / mime_expressions.c: 780: 3: error: format query number for arguments rspamd_default_log_function missmatches query string
       'process test regexp% s for url% s returned FALSE', expected 2 args, got 1 args
                 msg_info_task ("process test regexp% s for url% s returned FALSE",
                 ^
 src / libutil / logger.h: 169: 30: note: expanded from macro 'msg_info_task'
 #define msg_info_task (...) rspamd_default_log_function (G_LOG_LEVEL_INFO, \
                              ^
 1 error generated.
</pre><br>  A total of 47 issues with format query were found, which can be seen in the following commit: <a href="http://git.io/v8Nyv">http://git.io/v8Nyv</a> <br><br>  Plugin code is available <a href="https://github.com/vstakhov/rspamd/tree/master/clang-plugin">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/270743/">https://habr.com/ru/post/270743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270733/index.html">Video transmission at frequencies up to 100 MHz in PC</a></li>
<li><a href="../270735/index.html">"Ua-hosting.company" or how to become a hosting provider from scratch and generate traffic more than the whole of Belarus</a></li>
<li><a href="../270737/index.html">Video reports from the SPB .NET Community</a></li>
<li><a href="../270739/index.html">VoIP Network Security</a></li>
<li><a href="../270741/index.html">New ICQ, or as we received Editors' Choice</a></li>
<li><a href="../270745/index.html">Cloud for development companies: how Robots Can Dream made a project for the FINA World Cup 2015</a></li>
<li><a href="../270747/index.html">7 key benefits of Dell technical support</a></li>
<li><a href="../270753/index.html">I2P: Signature and EdDSA Signature Verification</a></li>
<li><a href="../270755/index.html">New version of HP Vertica Excavator (7.2)</a></li>
<li><a href="../270757/index.html">Creating an enterprise - the solution of tomorrow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>