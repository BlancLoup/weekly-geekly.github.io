<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2048 at Erlang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably for a week of the 2048 game on Habr√© I do not have time, but the article is not so much about the game as about the websocket server on Erlan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2048 at Erlang</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/371/aaa/1cf/371aaa1cf74630ed981f46c07cf49682.png" alt="image" align="left">  Probably for a week of the 2048 game on Habr√© I do not have time, but the article is not so much about the game as about the websocket server on Erlang.  A little background.  When I started playing in 2048, I just could not stop it.  To the detriment of work and family.  Therefore, I decided that the bot should play for me.  But the snag is that the game is client-side, which is why there is no global rating and it‚Äôs not so convenient to play without a browser.  That's why I decided to make the server part where the rating would be.  And where could my bot play without a browser. <br><a name="habracut"></a><br><br>  I note that this is my first project on Erlang.  Many programmers are afraid of Erlang, assuming that it is difficult.  But actually it is not.  Plus, I will try to highlight moments that are not entirely obvious to the newcomer to Erlang. <br><br>  To simplify a lot of things are hard.  But I am always glad to constructive criticism and comments. <br>  The github link is <a href="https://github.com/peinguin/erl2048">erl2048</a> . <br>  Reference to the working draft - <a href="http://2048.php.poltava.ua/">erl2048</a> .  But, I think, he will live not for long under a habraeffekt. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Javascript </h4><br>  Oddly enough - I'll start with JS.  I have not changed the original files so that they can be updated from the primary repository, if necessary.  I used: <br><ul><li>  main.css; </li><li>  animframe_polyfill.js for requestAnimationFrame; </li><li>  html_actuator.js for all animations </li><li>  keyboard_input_manager.js for keyboard events, and, as practice has shown, nothing; </li></ul><br>  I created the file "main.js".  The logic is simple - the browser sends events to the server, and then updates the field.  Fortunately, animframe_polyfill is designed in such a way that it accepts the generated grid. <br><br>  What I added.  Connection initialization: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> websocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Websocket(SERVER); websocket .connect() .done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myGame = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyGame(websocket); });</code> </pre> <br>  Quickly wrote a wrapper over "Websocket".  It is very simple to provide the source code here. <br>  Start a new game: <br><br><pre> <code class="javascript hljs">self.restart = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">)</span></span>{ websocket.send(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({ <span class="hljs-attr"><span class="hljs-attr">action</span></span>:<span class="hljs-string"><span class="hljs-string">'start'</span></span> })); };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Make a move:</b> <div class="spoiler_text"><pre> <code class="javascript hljs">self.move = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">direction</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 0: up, 1: right, 2:down, 3: left if(!toMove){ return false; } if(direction === 0){ direction = 'up'; }else if(direction === 1){ direction = 'right'; }else if(direction === 2){ direction = 'down'; }else if(direction === 3){ direction = 'left'; } websocket.send(JSON.stringify({ action:'move', value: direction })); };</span></span></code> </pre><br></div></div><br>  And the biggest. <br><div class="spoiler">  <b class="spoiler_title">Processing server response:</b> <div class="spoiler_text"><pre> <code class="javascript hljs">self.wsHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> game = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(evt.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(game.grid){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = {<span class="hljs-attr"><span class="hljs-attr">cells</span></span>: []}; game.grid.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">column, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> row = []; column.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cell){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cell.mergedFrom){ cell.mergedFrom.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tile</span></span></span><span class="hljs-function">)</span></span>{ tile[<span class="hljs-string"><span class="hljs-string">'x'</span></span>] = x; tile[<span class="hljs-string"><span class="hljs-string">'y'</span></span>] = y; }); } row.push({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: cell.value, <span class="hljs-attr"><span class="hljs-attr">x</span></span>: x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: y, <span class="hljs-attr"><span class="hljs-attr">previousPosition</span></span>: cell.previousPosition, <span class="hljs-attr"><span class="hljs-attr">mergedFrom</span></span>: cell.mergedFrom }); } }); grid.cells.push(row); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scores = game.scores, bestScore = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(scores &amp;&amp; scores.length&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ bestScore = scores[<span class="hljs-number"><span class="hljs-number">0</span></span>].score; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scoresEl.firstChild) { scoresEl.removeChild(scoresEl.firstChild); } scores.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">score</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'Div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'Div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scoreEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'Div'</span></span>); div.setAttribute(<span class="hljs-string"><span class="hljs-string">"class"</span></span>, <span class="hljs-string"><span class="hljs-string">'score'</span></span>); name.setAttribute(<span class="hljs-string"><span class="hljs-string">"class"</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); scoreEl.setAttribute(<span class="hljs-string"><span class="hljs-string">"class"</span></span>, <span class="hljs-string"><span class="hljs-string">'score'</span></span>); name.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(score.name)); scoreEl.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(score.score)); div.appendChild(name); div.appendChild(scoreEl); scoresEl.appendChild(div); }); } actuator.actuate(grid, { <span class="hljs-attr"><span class="hljs-attr">score</span></span>: game.score, <span class="hljs-attr"><span class="hljs-attr">bestScore</span></span>: bestScore, <span class="hljs-attr"><span class="hljs-attr">score</span></span>: game.score, <span class="hljs-attr"><span class="hljs-attr">won</span></span>: game.won, <span class="hljs-attr"><span class="hljs-attr">over</span></span>: game.over, <span class="hljs-attr"><span class="hljs-attr">keepPlaying</span></span>: game.keepPlaying }); } <span class="hljs-comment"><span class="hljs-comment">//playername actuator if(game.user){ if(playername.value !== playername){ playername.value = game.user.name; } } };</span></span></code> </pre><br></div></div><br>  As you can see, the game is completely server dependent, because all the calculations take place there.  Not like, for example, in my game <a href="https://github.com/peinguin/tictoe">Tic tac toe</a> , where the logic is duplicated. <br>  In fact, I did not understand why x and y are used in the original in Tile, so the server does without them.  And on the client already I finish, that actuator has eaten. <br>  Also from the server comes a list of the top 10 best players.  This is an innovation of my version.  And the player can change his nickname.  No registrations and protections.  Entered the name and play.  It is necessary to point the box with the best score to see the overall rating.  It looks like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/d55/7c5/676d557c538760bde84b61e70816b413.png"><br><br>  Using native keyboard_input_manager is not very good.  Because now not all characters can be entered into the nickname input field.  But you can paste your nickname from the clipboard. <br>  Plus, I have implemented not all the functionality.  The part that is responsible for the "loss" is still closed with a plug, but this does not really affect the gameplay.  And to continue the game after winning is not possible.  But the win has not happened yet. <br><br><h4>  Erlang </h4><br>  This part will be described in more detail.  First you need to install rebar.  You can do it <a href="https://github.com/basho/rebar">from here</a> .  Rebar can generate initial files, but I created them manually. <br>  ‚ÄúRebar.config‚Äù is used to automatically download and build dependencies. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">% The next option is required so we can use lager. {erl_opts, [{parse_transform, lager_transform}]}. {lib_dirs,["deps"]}. % Our dependencies. {deps, [ {'lager', ".*", { git, "git://github.com/basho/lager.git", "master"} }, {'cowboy', ".*", { git, "git://github.com/extend/cowboy.git", "master"} }, {'mochiweb', ".*", { git, "git://github.com/mochi/mochiweb.git", "master"} }, {'sqlite3', ".*", { git, "git://github.com/alexeyr/erlang-sqlite3.git", "master"} } ]}.</span></span></code> </pre></div></div><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># rebar gd # rebar co</span></span></code> </pre><br>  To download and compile dependencies.  You may need to install ‚Äúlibsqlite3-dev‚Äù for the sqlite driver. <br><br>  To start the server I use: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># rebar compile skip_deps=true; erl -pa ebin deps/*/ebin -eval 'starter:start().' -noshell -detached</span></span></code> </pre><br>  After that, the game will be available on port 8080.  In fact, learning how to launch a project was the most difficult.  Further - easier.  I created a special starter module that runs all dependencies and the application. <br><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(starter)</span></span>. -export([start/<span class="hljs-number"><span class="hljs-number">0</span></span>]). start() -&gt; application:start(ranch), application:start(crypto), application:start(cowlib), application:start(cowboy), application:start(inets), application:start(mochiweb), application:start(erl2048).</code> </pre><br>  Now consider the contents of the directory "src".  The first is the ‚Äúerl2048.app.src‚Äù file.  I do not know, in fact, what it is for, but I added my project just in case. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="erlang hljs">{application, erl2048, [ {description, <span class="hljs-string"><span class="hljs-string">"2048 game server."</span></span>}, {vsn, <span class="hljs-string"><span class="hljs-string">"1"</span></span>}, {modules, []}, {registered, [erl2048_sup]}, {applications, [ kernel, stdlib, cowboy ]}, {mod, {erl2048_app, []}}, {env, []} ]}.</code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">erl2048_sup.erl</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% Feel free to use, reuse and abuse the code in this file. %% @private -module(erl2048_sup). -behaviour(supervisor). %% API. -export([start_link/0]). %% supervisor. -export([init/1]). %% API. -spec start_link() -&gt; {ok, pid()}. start_link() -&gt; supervisor:start_link({local, ?MODULE}, ?MODULE, []). %% supervisor. init([]) -&gt; Procs = [], {ok, {{one_for_one, 10, 10}, Procs}}.</span></span></code> </pre></div></div><br>  I understand that this thing ensures that the application does not fall and restarts if necessary.  Took from the example - decided to leave. <br><br>  Now the main application file is ‚Äúerl2048_app.erl‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% Feel free to use, reuse and abuse the code in this file. %% @private -module(erl2048_app). -behaviour(application). %% API. -export([start/2]). -export([stop/1]). %% API. start(_Type, _Args) -&gt; Dispatch = cowboy_router:compile([ {'_', [ {"/", cowboy_static, {file, "../client/index.html"}}, {"/websocket", ws_handler, []}, {"/static/[...]", cowboy_static, {dir, "../client/static"}} ]} ]), {ok, _} = cowboy:start_http(http, 100, [{port, 8080}], [{env, [{dispatch, Dispatch}]}]), {ok, _} = db:start_link(), erl2048_sup:start_link(). stop(_State) -&gt; {ok, _} = db:stop(), ok.</span></span></code> </pre></div></div><br>  Here I can already explain something.  First, the cowboy routes are compiled.  Then the cowboy starts and the database connection. <br>  In the role of subd performs sqlite.  I also considered Postgresql, mongoDB and Redis.  But I stopped at sqlite, as it is the easiest.  Plus stores data after a restart.  But, I think, it will create a greater load on the application because of what it will rather fall.  Anyway - the module code: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(db)</span></span>. -export([start_link/<span class="hljs-number"><span class="hljs-number">0</span></span>,stop/<span class="hljs-number"><span class="hljs-number">0</span></span>]). -export([insert/<span class="hljs-number"><span class="hljs-number">2</span></span>, select/<span class="hljs-number"><span class="hljs-number">0</span></span>, createUser/<span class="hljs-number"><span class="hljs-number">1</span></span>, changeName/<span class="hljs-number"><span class="hljs-number">2</span></span>]). start_link() -&gt; {ok, PID} = sqlite3:open(db, [{file, <span class="hljs-string"><span class="hljs-string">"db.sqlite3"</span></span>}]), Tables = sqlite3:list_tables(db), <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lists:member(<span class="hljs-string"><span class="hljs-string">"scores"</span></span>, Tables) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; sqlite3:create_table(db, scores, [{id, integer, [{primary_key, [asc, autoincrement]}]}, {userid, integer}, {score, integer}]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lists:member(<span class="hljs-string"><span class="hljs-string">"users"</span></span>, Tables) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; sqlite3:create_table(db, users, [{id, integer, [{primary_key, [asc, autoincrement]}]}, {name, text}]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, {ok, PID}. stop() -&gt; sqlite3:close(db). select() -&gt; Ret = sqlite3:sql_exec(db, <span class="hljs-string"><span class="hljs-string">"select users.name, scores.score from scores LEFT JOIN users ON (users.id = scores.userid) ORDER BY score desc;"</span></span>), [{columns,_},{rows,Rows}] = Ret, formatScores(Rows). insert(Score, Player) -&gt; [{columns,_},{rows,Rows}] = sqlite3:sql_exec(db, <span class="hljs-string"><span class="hljs-string">"SELECT score FROM scores WHERE userid = ?"</span></span>, [{<span class="hljs-number"><span class="hljs-number">1</span></span>,Player}]), DBScore = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length(Rows) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; element(<span class="hljs-number"><span class="hljs-number">1</span></span>,hd(Rows)); <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Score &gt; DBScore -&gt; sqlite3:delete(db, scores, {userid, Player}), sqlite3:write(db, scores, [{userid, Player}, {score, Score}]), sqlite3:sql_exec(db, <span class="hljs-string"><span class="hljs-string">"DELETE FROM scores WHERE id IN (SELECT id FROM scores ORDER BY score desc LIMIT 1 OFFSET 10)"</span></span>); <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; undefined <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. formatScores([]) -&gt; []; formatScores([{Name, Score} | Rows]) -&gt; [{struct, [{name, Name},{score, Score}]} | formatScores(Rows)]. createUser(UserName) -&gt; sqlite3:write(db, users, [{name, UserName}]). changeName(Id, NewName) -&gt; sqlite3:update(db, users, {id, Id}, [{name, NewName}]).</code> </pre></div></div><br><br>  Let's move on to the module that handles websocket connections. <br><br><div class="spoiler">  <b class="spoiler_title">ws_handler.erl</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(ws_handler)</span></span>. -behaviour(cowboy_websocket_handler). -export([init/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([websocket_init/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([websocket_handle/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([websocket_info/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([websocket_terminate/<span class="hljs-number"><span class="hljs-number">3</span></span>]). init({tcp, http}, _Req, _Opts) -&gt; {upgrade, protocol, cowboy_websocket}. websocket_init(_TransportName, Req, _Opts) -&gt; State = {struct, [ { user, { struct, [{id, null},{name, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"Player"</span></span>&gt;&gt;}] } } ]}, {ok, Req, State}. websocket_handle({text, Msg}, Req, State) -&gt; Message = mochijson2:decode(Msg, [{format, proplist}]), Action = binary_to_list(proplists:get_value(&lt;&lt;<span class="hljs-string"><span class="hljs-string">"action"</span></span>&gt;&gt;, Message)), {NewState, Response} = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Action <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"start"</span></span> -&gt; TmpState = game:init(State), {TmpState, TmpState}; <span class="hljs-string"><span class="hljs-string">"move"</span></span> -&gt; TmpState = game:move(list_to_atom(binary_to_list(proplists:get_value(&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value"</span></span>&gt;&gt;, Message))), State), {TmpState, TmpState}; <span class="hljs-string"><span class="hljs-string">"newName"</span></span> -&gt; NewName = proplists:get_value(&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value"</span></span>&gt;&gt;, Message), JsonData = element(<span class="hljs-number"><span class="hljs-number">2</span></span>, State), User = proplists:get_value(user, JsonData), {struct,UserJsonData} = User, Id = proplists:get_value(id, UserJsonData), db:changeName(Id, NewName), TmpState = {struct, [ { user, { struct, [ { name, NewName },{ id, Id } ] } } | proplists:delete(user, JsonData) ]}, { TmpState, {struct, [{ user, { struct, [ { name, NewName },{ id, Id } ] } }]} }; _Else -&gt; State <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, {reply, {text, mochijson2:encode(Response)}, Req, NewState}; websocket_handle(_Data, Req, State) -&gt; {ok, Req, State}. websocket_info({send, Msg}, Req, State) -&gt; {reply, {text, Msg}, Req, State}; websocket_info(_Info, Req, State) -&gt; {ok, Req, State}. websocket_terminate(_Reason, _Req, _State) -&gt; ok.</code> </pre></div></div><br>  At first I did not understand how it all works.  It turns out that everything is very simple.  There is a state that is set when the connection is established.  And that is passed to each request handler for each client.  The main method here is ‚Äúwebsocket_handle‚Äù.  It accepts the message and the status and returns the response and status. <br>  JSON format is used for communication.  In Erlang, it is represented by a structure like: <br><br><pre> <code class="erlang hljs">{struct, [ {key1, Value1}, {key2, Value2}, .... ]}</code> </pre><br><br>  Now directly the game files.  The easiest "tile.erl". <br><br><div class="spoiler">  <b class="spoiler_title">tile.erl</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(tile)</span></span>. -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, init/<span class="hljs-number"><span class="hljs-number">0</span></span>, prepare/<span class="hljs-number"><span class="hljs-number">2</span></span>]). prepare(null, _) -&gt; null; prepare(Tile, { X, Y }) -&gt; { struct, [ {value, proplists:get_value(value, element(<span class="hljs-number"><span class="hljs-number">2</span></span>, Tile))}, {mergedFrom, null}, {previousPosition, {struct, [{ x, X - <span class="hljs-number"><span class="hljs-number">1</span></span>},{ y, Y - <span class="hljs-number"><span class="hljs-number">1</span></span> }]}} ] }. init(Value) -&gt; { struct, [ {value, Value}, {mergedFrom, null}, {previousPosition, null} ] }. init() -&gt; init(<span class="hljs-number"><span class="hljs-number">2</span></span>).</code> </pre></div></div><br>  Only knows how to create a new tile and save the previous position. <br>  "Grid.erl" is more complicated. <br><br><div class="spoiler">  <b class="spoiler_title">grid.erl</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(grid)</span></span>. -export([ build/<span class="hljs-number"><span class="hljs-number">0</span></span>, cellsAvailable/<span class="hljs-number"><span class="hljs-number">1</span></span>, randomAvailableCell/<span class="hljs-number"><span class="hljs-number">1</span></span>, insertTile/<span class="hljs-number"><span class="hljs-number">3</span></span>, availableCells/<span class="hljs-number"><span class="hljs-number">1</span></span>, cellContent/<span class="hljs-number"><span class="hljs-number">2</span></span>, removeTile/<span class="hljs-number"><span class="hljs-number">2</span></span>, moveTile/<span class="hljs-number"><span class="hljs-number">3</span></span>, size/<span class="hljs-number"><span class="hljs-number">0</span></span>, withinBounds/<span class="hljs-number"><span class="hljs-number">1</span></span>, cellAvailable/<span class="hljs-number"><span class="hljs-number">2</span></span> ]). -define(SIZE, <span class="hljs-number"><span class="hljs-number">4</span></span>). size() -&gt; ?SIZE. build() -&gt; [[null || _ &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>, ?SIZE)] || _ &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>, ?SIZE)]. availableCells(Grid) -&gt; lists:append( setY( availableCells(Grid, <span class="hljs-number"><span class="hljs-number">1</span></span>) ) ). availableCells([Grid | Tail ], N) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_list(Grid) -&gt; [{availableCells(Grid, <span class="hljs-number"><span class="hljs-number">1</span></span>), N} | availableCells(Tail, N +<span class="hljs-number"><span class="hljs-number">1</span></span>)]; availableCells([Grid | Tail ], N) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Grid =:= null <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; [ N | availableCells(Tail, N +<span class="hljs-number"><span class="hljs-number">1</span></span>)]; <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; availableCells(Tail, N +<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; availableCells([], _) -&gt; []. setY([{Cell, Y}|Tail]) -&gt; [ setY(Cell, Y) | setY(Tail)]; setY([]) -&gt; []. setY([Head | Tail], Y) -&gt; [ {Head, Y} | setY(Tail, Y)]; setY([], _) -&gt; []. cellsAvailable(Grid) -&gt; length(availableCells(Grid)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>. randomAvailableCell(Grid) -&gt; Cells = availableCells(Grid), lists:nth(random:uniform(length(Cells)) ,Cells). insertTile({X, Y}, Tile, Grid) -&gt; Row = lists:nth(Y,Grid), lists:sublist(Grid,Y - <span class="hljs-number"><span class="hljs-number">1</span></span>) ++ [ lists:sublist(Row,X - <span class="hljs-number"><span class="hljs-number">1</span></span>) ++ [Tile] ++ lists:nthtail(X,Row)] ++ lists:nthtail(Y,Grid). cellContent({ X, Y }, Grid) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> withinBounds({ X, Y }) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; lists:nth(X,lists:nth(Y,Grid)); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; null <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. removeTile({ X, Y }, Grid) -&gt; insertTile({X, Y}, null, Grid). moveTile(Cell, Cell, Grid) -&gt; Grid; moveTile(Cell, Next, Grid) -&gt; insertTile(Next, grid:cellContent(Cell, Grid), removeTile(Cell, Grid)). withinBounds({X, Y}) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>), (X =&lt; ?SIZE), (Y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>), (Y =&lt; ?SIZE) -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>; withinBounds(_) -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>. cellAvailable(Cell, Grid) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> grid:withinBounds(Cell) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; cellContent(Cell, Grid) =:= null; <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre></div></div><br>  Pay attention to the availableCells.  In Erlang, you need to use recursion to the maximum.  But here I was too clever by myself.  First generated sheet, which contained sheets with one coordinate and the second coordinate.  And then he made the second to the first.  I decided not to do more.  The remaining functions, I think, are obvious. <br>  And, the main file of the game.  This is called ‚Äúgame.erl‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">game.erl</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(game)</span></span>. -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, move/<span class="hljs-number"><span class="hljs-number">2</span></span>]). init(State) -&gt; StateUser = proplists:get_value(user, element(<span class="hljs-number"><span class="hljs-number">2</span></span>, State)), StateUserJsonData = element(<span class="hljs-number"><span class="hljs-number">2</span></span>, StateUser), User = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> proplists:get_value(id, StateUserJsonData) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> null -&gt; Name = proplists:get_value(name, StateUserJsonData), {rowid, Id} = db:createUser(Name), { struct, [{name, Name},{id, Id}]}; _Else -&gt; StateUser <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, { struct, [ {grid ,addStartTiles(grid:build())}, {user , User}, {score,<span class="hljs-number"><span class="hljs-number">0</span></span>}, {scores, db:select()}, {won, false}, {over, false}, {keepPlaying, false} ] }. addStartTiles(Grid, <span class="hljs-number"><span class="hljs-number">0</span></span>) -&gt; Grid; addStartTiles(Grid, N) -&gt; NewGrid = addRandomTile(Grid), addStartTiles(NewGrid, N - <span class="hljs-number"><span class="hljs-number">1</span></span>). addStartTiles(Grid) -&gt; addStartTiles(Grid, <span class="hljs-number"><span class="hljs-number">2</span></span>). addRandomTile(Grid) -&gt; random:seed(now()), <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> grid:cellsAvailable(Grid) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> random:uniform(<span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; Tile = tile:init(); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Tile = tile:init(grid:size()) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, grid:insertTile(grid:randomAvailableCell(Grid), Tile, Grid); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Grid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. getVector(left) -&gt; { -<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; getVector(up) -&gt; { <span class="hljs-number"><span class="hljs-number">0</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span> }; getVector(right) -&gt; { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; getVector(down) -&gt; { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }. buildTraversals() -&gt; Traver = lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>, grid:size()), { Traver, Traver }. buildTraversals({ <span class="hljs-number"><span class="hljs-number">1</span></span> , _ }) -&gt; { T1, T2} = buildTraversals(), { lists:reverse(T1), T2 }; buildTraversals({ _ , <span class="hljs-number"><span class="hljs-number">1</span></span> }) -&gt; { T1, T2} = buildTraversals(), { T1, lists:reverse(T2) }; buildTraversals({ _ , _ }) -&gt; buildTraversals(). prepareTiles( [{_Key, _Value} | _Tail ] ) -&gt; JsonData = [{_Key, _Value} | _Tail ], [{ grid, prepareTiles(proplists:get_value(grid, JsonData)) } | proplists:delete(grid, JsonData) ]; prepareTiles( Grid ) -&gt; prepareTiles( Grid, <span class="hljs-number"><span class="hljs-number">1</span></span>). prepareTiles([], _) -&gt; []; prepareTiles([Row | Tail], Y) -&gt; [ prepareTileY(Row, <span class="hljs-number"><span class="hljs-number">1</span></span>, Y) | prepareTiles(Tail, Y + <span class="hljs-number"><span class="hljs-number">1</span></span>)]. prepareTileY([], _, _) -&gt; []; prepareTileY([Cell | Tail], X, Y) -&gt; [prepareTileX(Cell, X, Y) | prepareTileY(Tail, X + <span class="hljs-number"><span class="hljs-number">1</span></span>, Y) ]. prepareTileX(Tile, X, Y) -&gt; tile:prepare(Tile, {X, Y}). process_travesals_y([], _, _, JsonData) -&gt; JsonData; process_travesals_y(_, [], _, JsonData) -&gt; JsonData; process_travesals_y([ Y | Tail ], TraversalsX, Vector, JsonData) -&gt; process_travesals_y( Tail, TraversalsX, Vector, process_travesals_y( Y, TraversalsX, Vector, JsonData) ); process_travesals_y(Y, [ X | Tail ], Vector, JsonData) -&gt; process_travesals_y(Y, Tail, Vector, process_travesals_y( Y, X, Vector, JsonData )); process_travesals_y( Y, X, Vector, JsonData ) -&gt; moveTile({ X, Y }, Vector, JsonData). findFarthestPosition({X, Y}, {VecX, VecY}, Grid) -&gt; Next = { X + VecX, Y + VecY }, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> grid:cellAvailable(Next, Grid) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; findFarthestPosition(Next, {VecX, VecY}, Grid); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; { {X, Y}, Next <span class="hljs-comment"><span class="hljs-comment">% Used to check if a merge is required } end. moveTile(Cell, Vector, JsonData) -&gt; Grid = proplists:get_value(grid, JsonData), Tile = grid:cellContent(Cell, Grid), case Tile =:= null of true -&gt; JsonData; false -&gt; { Farthest, Next } = findFarthestPosition(Cell, Vector, Grid), {struct, CurrJsonData} = Tile, CurrValue = proplists:get_value(value, CurrJsonData), NextTile = if Next =:= null -&gt; null; true -&gt; grid:cellContent(Next, Grid) end, {NextValue, NextMerged} = if NextTile =:= null -&gt; {null, null}; true -&gt; NextJsonData = element(2, NextTile), {proplists:get_value(value, NextJsonData), proplists:get_value(mergedFrom, NextJsonData)} end, if CurrValue =:= NextValue, NextMerged =:= null -&gt; MergedValue = CurrValue * 2, Merged = { struct, [ {value, MergedValue}, {mergedFrom, [Tile,NextTile]}, {previousPosition, null} ] }, NewGrid = grid:insertTile(Next, Merged, grid:removeTile(Cell, Grid)), % Update the score Score = proplists:get_value(score, JsonData) + MergedValue, % The mighty 2048 tile Won = if MergedValue =:= 2048 -&gt; true; true -&gt; false end, Removed = proplists:delete(score, proplists:delete(won, proplists:delete(grid, JsonData))), [ {grid,NewGrid}, {won,Won}, {score,Score} | Removed ]; true -&gt; [ { grid, grid:moveTile(Cell, Farthest, proplists:get_value(grid, JsonData)) } | proplists:delete(grid, JsonData) ] end end. move(left, State) -&gt; move(getVector(left), State); move(right, State) -&gt; move(getVector(right), State); move(up, State) -&gt; move(getVector(up), State); move(down, State) -&gt; move(getVector(down), State); move(Vector, State) -&gt; {struct, JsonData} = State, case proplists:get_value(over, JsonData) or ( proplists:get_value(won, JsonData) and (not proplists:get_value(keepPlaying, JsonData)) ) of true -&gt; State; _Else -&gt; PreparedJsonData = updateBestScore(prepareTiles(JsonData)), { TraversalsX, TraversalsY } = buildTraversals(Vector), NewJsonData = process_travesals_y( TraversalsY, TraversalsX, Vector, PreparedJsonData ), NewGrid = proplists:get_value(grid, NewJsonData), Grid = proplists:get_value(grid, PreparedJsonData), if NewGrid =/= Grid -&gt; %If changed - add new tile {struct, UserJsonData} = proplists:get_value(user, NewJsonData), NewScore = proplists:get_value(score, NewJsonData), Score = proplists:get_value(score, PreparedJsonData), case NewScore &gt; Score of true -&gt; db:insert( proplists:get_value(score, NewJsonData), proplists:get_value(id, UserJsonData) ); _Else -&gt; undefined end, Over = case movesAvailable(NewGrid) of true -&gt; false; fale -&gt; true % Game over! end, Removed = proplists:delete(grid, proplists:delete(over, NewJsonData)), {struct,[{ grid, addRandomTile(NewGrid) }, { over, Over } | Removed ]}; true -&gt; %return state otherwise {struct,PreparedJsonData} end end. movesAvailable(_) -&gt; true. updateBestScore(JsonData) -&gt; [{ scores, db:select() } | proplists:delete(scores, JsonData) ].</span></span></code> </pre></div></div><br>  The init function creates a new user if one has not been created.  Or takes from the previous game. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State)</span></span></span><span class="hljs-function"> -&gt;</span></span> StateUser = proplists:get_value(user, element(<span class="hljs-number"><span class="hljs-number">2</span></span>, State)), StateUserJsonData = element(<span class="hljs-number"><span class="hljs-number">2</span></span>, StateUser), User = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> proplists:get_value(id, StateUserJsonData) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> null -&gt; Name = proplists:get_value(name, StateUserJsonData), {rowid, Id} = db:createUser(Name), { struct, [{name, Name},{id, Id}]}; _Else -&gt; StateUser <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, { struct, [ {grid ,addStartTiles(grid:build())}, {user , User}, {score,<span class="hljs-number"><span class="hljs-number">0</span></span>}, {scores, db:select()}, {won, false}, {over, false}, {keepPlaying, false} ] }.</code> </pre><br>  The main function is move.  Responsible for the recalculation of the playing field.  There were difficulties, mainly due to the lack of functional programming experience. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(left, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> move(getVector(left), State); move(right, State) -&gt; move(getVector(right), State); move(up, State) -&gt; move(getVector(up), State); move(down, State) -&gt; move(getVector(down), State); move(Vector, State) -&gt; {struct, JsonData} = State, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> proplists:get_value(over, JsonData) or ( proplists:get_value(won, JsonData) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> proplists:get_value(keepPlaying, JsonData)) ) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; State; _Else -&gt; PreparedJsonData = updateBestScore(prepareTiles(JsonData)), { TraversalsX, TraversalsY } = buildTraversals(Vector), NewJsonData = process_travesals_y( TraversalsY, TraversalsX, Vector, PreparedJsonData ), NewGrid = proplists:get_value(grid, NewJsonData), Grid = proplists:get_value(grid, PreparedJsonData), <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NewGrid =/= Grid -&gt; <span class="hljs-comment"><span class="hljs-comment">%If changed - add new tile {struct, UserJsonData} = proplists:get_value(user, NewJsonData), NewScore = proplists:get_value(score, NewJsonData), Score = proplists:get_value(score, PreparedJsonData), case NewScore &gt; Score of true -&gt; db:insert( proplists:get_value(score, NewJsonData), proplists:get_value(id, UserJsonData) ); _Else -&gt; undefined end, Over = case movesAvailable(NewGrid) of true -&gt; false; fale -&gt; true % Game over! end, Removed = proplists:delete(grid, proplists:delete(over, NewJsonData)), {struct,[{ grid, addRandomTile(NewGrid) }, { over, Over } | Removed ]}; true -&gt; %return state otherwise {struct,PreparedJsonData} end end.</span></span></code> </pre><br>  For example, to find out if a move was completed, I compare the old state with the new one.  An external variable is not used as in the JS version.  I do not know whether this will reduce performance.  And then I check if the account has changed in order not to make unnecessary queries to the database. <br>  In general, with the functional approach, it is rarely necessary to transfer many parameters to a function.  What confuses me most is that I pass in TraversalsY, TraversalsX, Vector in process_travesals_y, although TraversalsY and TraversalsX already depend on Vector.  But I decided to leave it for now. <br>  In order not to repeat the experience of ‚ÄúavailableCells‚Äù, I have described the process_travesals_y function more, but now it goes separately in X and separately in Y. And as a result, for each non-zero element of the playing field, calls ‚ÄúmoveTile‚Äù.  Which, in principle, almost completely corresponds to the JS-original. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cell, Vector, JsonData)</span></span></span><span class="hljs-function"> -&gt;</span></span> Grid = proplists:get_value(grid, JsonData), Tile = grid:cellContent(Cell, Grid), <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Tile =:= null <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; JsonData; <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; { Farthest, Next } = findFarthestPosition(Cell, Vector, Grid), {struct, CurrJsonData} = Tile, CurrValue = proplists:get_value(value, CurrJsonData), NextTile = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Next =:= null -&gt; null; <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; grid:cellContent(Next, Grid) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, {NextValue, NextMerged} = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextTile =:= null -&gt; {null, null}; <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; NextJsonData = element(<span class="hljs-number"><span class="hljs-number">2</span></span>, NextTile), {proplists:get_value(value, NextJsonData), proplists:get_value(mergedFrom, NextJsonData)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurrValue =:= NextValue, NextMerged =:= null -&gt; MergedValue = CurrValue * <span class="hljs-number"><span class="hljs-number">2</span></span>, Merged = { struct, [ {value, MergedValue}, {mergedFrom, [Tile,NextTile]}, {previousPosition, null} ] }, NewGrid = grid:insertTile(Next, Merged, grid:removeTile(Cell, Grid)), <span class="hljs-comment"><span class="hljs-comment">% Update the score Score = proplists:get_value(score, JsonData) + MergedValue, % The mighty 2048 tile Won = if MergedValue =:= 2048 -&gt; true; true -&gt; false end, Removed = proplists:delete(score, proplists:delete(won, proplists:delete(grid, JsonData))), [ {grid,NewGrid}, {won,Won}, {score,Score} | Removed ]; true -&gt; [ { grid, grid:moveTile(Cell, Farthest, proplists:get_value(grid, JsonData)) } | proplists:delete(grid, JsonData) ] end end.</span></span></code> </pre><br><br>  On it, I think, the story about processing websocket of requests by means of Erlang is finished.  I am pleased to answer all questions. </div><p>Source: <a href="https://habr.com/ru/post/216517/">https://habr.com/ru/post/216517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216503/index.html">FBI detained a Russian programmer on a tip from Microsoft</a></li>
<li><a href="../216505/index.html">What do children think about games?</a></li>
<li><a href="../216511/index.html">Verimatrix - Problem or Solution</a></li>
<li><a href="../216513/index.html">Arduino. The best book according to readers</a></li>
<li><a href="../216515/index.html">Review iconBIT NetTAB Mercury LX: the current 3.8-inch smartphone "for a hundred bucks"</a></li>
<li><a href="../216519/index.html">Yandex.Money cannot be mapped to a non-Russian bank</a></li>
<li><a href="../216523/index.html">What every participant of a large MMO project should know</a></li>
<li><a href="../216525/index.html">On the crest of technology: a meeting in joy - does it happen?</a></li>
<li><a href="../216527/index.html">Dictionary of words</a></li>
<li><a href="../216533/index.html">Hosting provider vs. DDoS attack. REG.RU Solution - Professional Outsourcing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>