<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What to do the processor when there is nothing to do?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It would be reasonable to assume that it would be quite easy for the kernel to do nothing ‚Äî but it is not. At the 2018 Kernel Recipes conference, Rafa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What to do the processor when there is nothing to do?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/4d6/056/8ed/4d60568ede6023ffb669539747f5e46f.jpg" align="left">  It would be reasonable to assume that it would be quite easy for the kernel to do nothing ‚Äî but it is not.  At the <a href="https://kernel-recipes.org/en/2018/">2018 Kernel Recipes</a> conference, <a href="https://www.linkedin.com/in/rafael-wysocki-092a4b90/">Rafael Vysotsky</a> talked about what processors are doing, when they have nothing to do, how it processes the core, what current strategies have problems, and how his recent work on the <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B5%25D0%25B7%25D0%25B4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D1%258B">inactivity cycle</a> improved the situation with power consumption of systems that do nothing . <br><br>  The idle cycle, one of the subsystems of the kernel that Vysotsky supports, controls what the CPU does when it does not need to run any processes.  Vysotsky gave all the definitions very precisely: CPU is an entity that can receive instructions from the memory and execute them simultaneously with other entities in the same system that deal with the same.  On the simplest single-processor system with one core, this core is the CPU.  If the processor has several cores, then each of these cores is a CPU.  If each of the cores has several interfaces for the simultaneous execution of instructions - Intel calls such a system " <a href="https://ru.wikipedia.org/wiki/Hyper-threading">hyperthreading</a> " - then each of these threads will be a CPU. <br><a name="habracut"></a><br>  The CPU stays idle when it has no tasks to perform.  Or, more precisely, the Linux kernel has several internal dispatch classes, one of which is a special idle class.  If there are no tasks on this CPU in any of the classes, excluding the inactivity class, then the CPU is considered inactive.  If the hardware does not allow this, then the CPU will have to carry out useless instructions until the real work is done.  However, this is an extremely inefficient use of electricity, so most processors support several low-power states, into which the core translates them until they are needed to do useful work. <br><br>  In the state of inaction can not just enter or exit.  It takes time to enter and exit, and in addition, when you enter this state, the power consumption of the current state slightly increases, and when you exit it, the power consumption of the state into which the processor goes.  And although the deeper the state of inactivity, the less energy the processor consumes, the cost of entering and exiting to such states increases.  This means that in the case of short periods of inactivity, the best use of computer resources will be shallow inaction;  for longer periods, the cost of going into a deeper state of inaction will be justified by an increase in the amount of energy saved.  Therefore, it is in the interests of the kernel to predict how long the processor will be inactive, before deciding how deep the inactivity state it needs.  This is the task of the inactivity cycle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this cycle, the scheduler notices that the CPU is inactive, since it does not have any tasks that could be assigned to it.  Then the scheduler calls the regulator, which tries to give the best prediction of a suitable inaction state that you can enter.  Now in the core there are two regulators, menu and ladder.  They are used in different cases, but both are trying to do roughly the same thing: to monitor the state of the system when the CPU goes into inactivity state and the time it has spent inactive.  This is done in order to predict how long the CPU will go into a state of inactivity in it, and, therefore, which state is best suited for this situation. <br><br>  This job is especially complicated by the CPU scheduler timer.  The scheduler starts this timer to divide the access time to the CPU: if you need to perform several tasks on one processor, each of them can be performed only slightly, and then periodically set aside in favor of another task.  This timer does not need to be performed on an idle CPU, since there are no tasks between which the CPU needs to be divided.  Moreover, if the timer is allowed to run on an idle CPU, it will not allow the controller to select deep idle states, limiting the intervals during which the CPU is idle.  Therefore, in kernels up to 4.16, the scheduler turned off the timer before calling the controller.  When the CPU was awakened by an interrupt, the scheduler decided whether there were any necessary tasks to perform, and if they were there, the timer would restart. <br><br>  If the regulator predicts a long idle period, and this period really turns out to be long, then the regulator ‚Äúwins‚Äù: the CPU goes into a state of deep inactivity, and energy is saved.  But if the regulator predicts a long period of inactivity, and this period turns out to be short, then the regulator ‚Äúloses‚Äù, since the cost of entering a deep inaction does not pay off by saving energy in a short period of inactivity.  Even worse, when the regulator predicts a short period of inactivity - then it ‚Äúloses‚Äù regardless of the duration of the downtime: if the period was long, he missed the opportunity to save, and if short, then the costs of stopping and restarting the timer were wasted.  Or, in other words, since resources are spent on stopping and starting the timer, it makes no sense to stop it when the controller predicts a short idle period. <br><br>  Vysotsky decided to try changing the regulator's work, but came to the conclusion that the main problem is that the timer is stopped before the regulator is called, that is, before the recommended inactivity state becomes known.  He returned an inactivity cycle in kernel 4.17 so that the decision to stop the timer was made after the regulator issued its recommendation.  If he predicted a long simple, the timer stops so as not to wake the CPU ahead of time.  If the idle time is assumed to be short, the timer is left so as not to waste resources on outages.  This means that the timer also performs the security function, waking up the CPU if it turned out to be simple longer than predicted, and giving the regulator a second chance for the right decision. <br><br>  When an idle CPU wakes up through an interrupt, whether it is a non-stopped timer or another event, the scheduler immediately decides whether there is work.  If there is work, the timer is restarted if necessary.  If not, the controller is called.  Since this means that the controller can now be called and when the timer is running and when it is not working, the controller must be called to take this into account. <br><br>  After examining the table of winnings and losses, Vysotsky believes that the changes he made will improve the picture.  In the case of the prediction of a long inactivity, the timer still stops, so nothing changes here;  we win, if the idle period is long, and lose, if short.  But if a short period of downtime is predicted, we win: if the period turns out to be short, we will save on stopping and starting the timer, and if it is long, the non-stopped timer will wake us up and make it possible to make another prediction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/c12/2dc/989c122dcc3ec2c085e65f4e057c05a0.jpg"></div><br>  Since game theory cannot serve as a full-fledged substitute for the real situation, Vysotsky tested this approach on many systems.  The graph above is typical for all tested systems;  It shows the dependence of energy consumption on the time of an inactive system.  The green line is the old inactivity cycle, the red is the new one.  Under the new scheme of energy consumed less, in addition, it is more predictable.  Not all tested CPUs had such a big gap between the lines, but they all showed a flat red line under uneven green.  As Vysotsky said, this new scheme less often predicts short periods of inactivity, but more often it turns out to be right about their short duration. <br><br>  Answering a question from the audience, Vysotsky said that this work depends on the architecture.  In particular, it will benefit from Intel processors, since they have a sufficiently large array of inactivity states, from which the controller can choose the one that is needed, which will give it the best chance of success in the case of a correct prediction;  but ARM processors will also benefit from the new circuit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/97d/331/64897d33160279143469c00ef7041157.png"></div><br>  A 20% drop in power consumption in a state of inactivity may seem like a minor achievement, but in reality this is not the case.  Any system that wants to cope well enough with peak loads should have a power reserve in normal mode, which will manifest itself during inactivity.  The graph above shows the processor usage for the year on my server, which is engaged in mail, file transfer, VPN, NTP, etc.  Yellow color means simple time.  Saving 20% ‚Äã‚Äãof this energy would have pleased my provider, and for the planet it would be better. </div><p>Source: <a href="https://habr.com/ru/post/427419/">https://habr.com/ru/post/427419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427407/index.html">Meta-clustering with error minimization, and why I think the brain works that way</a></li>
<li><a href="../427409/index.html">The book "Brilliant Agile. Flexible project management with Agile, Scrum and Kanban</a></li>
<li><a href="../427413/index.html">Fight for resources, part 4: Remarkably coming out</a></li>
<li><a href="../427415/index.html">Use Node.js to work with large files and raw data sets.</a></li>
<li><a href="../427417/index.html">With humor about 8-inch diskettes (in the 70s there were only such)</a></li>
<li><a href="../427421/index.html">How genealogical sites make it easier to catch killers</a></li>
<li><a href="../427423/index.html">City2Share: e-and autonomous vehicles in Munich logistics hubs</a></li>
<li><a href="../427427/index.html">How come to IT: about the interns and the June (the result of a survey of "My Circle")</a></li>
<li><a href="../427429/index.html">GUI frameworks - on stream</a></li>
<li><a href="../427431/index.html">How Android works, part 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>