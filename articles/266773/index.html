<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MVVM nuances in Ext JS when developing components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. A lot of time passed since the release of Ext JS 5, where they presented the possibility of developing applications using the MVVM pattern. Dur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MVVM nuances in Ext JS when developing components</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/post/266773/"><img src="https://habrastorage.org/files/fc4/334/ad8/fc4334ad8b4d4a8690ce4e9a17be6937.jpeg" align="right" width="50%"></a>  Hello.  A lot of time passed since the release of Ext JS 5, where they presented the possibility of developing applications using the MVVM pattern.  During this time I managed to face some difficulties that I would like to talk about. <br><br>  To begin with, in Ext JS 4 (and previously in Sencha Touch) when creating components, their configuration properties were declared in the <i>config</i> object, for each of which a getter and setter were automatically created.  Although it might be a bit tedious to manually write all the handlers, this was the standard approach. <br><br>  In the fifth version of Ext JS, using MVVM, one could easily get rid of a good part of the routine: remove the configuration properties and their handlers, and instead bind to the desired property or formula ViewModel'and.  The code became much smaller, and readability better. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But I was worried about the issue of encapsulation.  What if during the development process I want to bring some of the functionality into a separate component for reuse?  Do I need to create my own ViewModel?  How to change the state of a component: contact its ViewModels directly, or is it worth using the configuration properties and their public setters? <br><br>  Thoughts about this and other issues, as well as examples with a file - under the cut. <br><a name="habracut"></a><br><h2>  Part 1. Use the ViewModel </h2><br>  Let's try to create, for example, a table of some users.  So that she can add and delete records, but if necessary, switch to read only mode.  I also want the delete button to contain the name of the selected user. <br><br><h3>  Example 1. Standard approach </h3><br>  How would we do this without using MVVM? <br><br><img src="https://habrastorage.org/files/aca/edc/7d6/acaedc7d658548a59c934204ad88747e.PNG"><br><br>  <a href="https://fiddle.sencha.com/">View in Sencha Fiddle</a> <br><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.UsersGrid</b> <div class="spoiler_text"><pre><code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.UsersGrid'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.grid.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">config</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/** @cfg {Boolean} Read only mode */</span></span> readOnly: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, <span class="hljs-attr"><span class="hljs-attr">defaultListenerScope</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'addButton'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'removeButton'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">selectionchange</span></span>: <span class="hljs-string"><span class="hljs-string">'grid_selectionchange'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">updateReadOnly</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">readOnly</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.down(<span class="hljs-string"><span class="hljs-string">'#addButton'</span></span>).setDisabled(readOnly); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.down(<span class="hljs-string"><span class="hljs-string">'#removeButton'</span></span>).setDisabled(readOnly); }, <span class="hljs-attr"><span class="hljs-attr">grid_selectionchange</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self, selected</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rec = selected[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rec) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.down(<span class="hljs-string"><span class="hljs-string">'#removeButton'</span></span>).setText(<span class="hljs-string"><span class="hljs-string">'Remove '</span></span> + rec.get(<span class="hljs-string"><span class="hljs-string">'name'</span></span>)); } } });</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Setting Read only mode</b> <div class="spoiler_text"><pre> <code class="javascript hljs">readOnlyButton_click: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.down(<span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>).setReadOnly(self.pressed); }</code> </pre><br></div></div><br>  Pretty verbose, but understandable: the entire logic of the component is inside.  It is necessary to make a reservation that you can use ViewControllers, and this will also be considered part of the component, but in the examples I will do without them. <br><br><h3>  Example 2. Add MVVM </h3><br>  Remove code handlers and replace them with bind bindings. <br><br>  <a href="https://fiddle.sencha.com/">View in Sencha Fiddle</a> <br><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.UsersGrid</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.UsersGrid'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.grid.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">reference</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'addButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'removeButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove {usersgrid.selection.name}'</span></span> } }], <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span> }] });</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Setting Read only mode</b> <div class="spoiler_text"><pre> <code class="javascript hljs">readOnlyButton_click: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.down(<span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>).getViewModel().set(<span class="hljs-string"><span class="hljs-string">'readOnly'</span></span>, self.pressed); }</code> </pre><br></div></div><br>  Looks much better, right?  Especially if you imagine that the input parameters other than readOnly can be much larger - then the difference will be enormous. <br><br>  Comparing these examples, some questions arise: <br><br>  <i><b>Question 1. Where were we supposed to create the ViewModel?</b></i>  <i><b>Was it possible to describe it in an external container?</b></i> <br><br>  ‚ÄúOn the one hand, it is possible, but then we get a strong connection: every time we transfer this component to another place, we will have to remember to add the readOnly property in the ViewModel and the new container.  It is so easy to make a mistake and in general the parent container does not need to know about the internals of the components that are added to it. <br><br>  <i><b>Question 2. What is the reference?</b></i>  <i><b>Why did we register it inside the component?</b></i> <br><br>  - Reference is the analog component id in the ViewModel'and.  We registered it because for the Remove button there is a binding to the name of the selected user, and without specifying the reference it will not work. <br><br>  <i><b>Question 3. Is it right to do this?</b></i>  <i><b>What if I want to add two instances to one container - will they have one reference?</b></i> <br><br>  - Yes, and this is of course wrong.  We need to think about how to solve it. <br><br>  <i><b>Question 4. Is it correct to access the ViewModel'i component from the outside?</b></i> <br><br>  - In general, it will work, but this is again an appeal to the internals of the component.  I, in theory, should not be interested in whether it has a ViewModel or not.  If I want to change its state, then I have to call the appropriate setter as it was once intended. <br><br>  <i><b>Question 5. Is it possible to still use the configuration properties, and at the same time bind to their values?</b></i>  <i><b>After all, the documentation for this case is the <a href="https://docs.sencha.com/extjs/6.0/6.0.0-classic/">publishes</a> property?</b></i> <br><br>  - You can and this is a good idea.  Except, of course, problems with explicitly specifying the reference in the binding.  Setting the readOnly mode in this case will be the same as in Example 1 ‚Äî via the public setter: <br><br><div class="spoiler">  <b class="spoiler_title">Example 3. Fiddle.view.UsersGrid</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.UsersGrid'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.grid.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">reference</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">config</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">publishes</span></span>: [<span class="hljs-string"><span class="hljs-string">'readOnly'</span></span>], <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'addButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{usersgrid.readOnly}'</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'removeButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{usersgrid.readOnly}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove {usersgrid.selection.name}'</span></span> } }], <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span> }] });</code> </pre><br></div></div><br>  <a href="https://fiddle.sencha.com/">View in Sencha Fiddle</a> <br><br><h3>  Something else </h3><br>  This concerns the last question.  If we bind from the external container to the property of the internal component (for example, to the selected row of the table), the binding will not work ( <a href="https://fiddle.sencha.com/">proof</a> ).  This happens as soon as the internal component has its own ViewModel - changes in properties are published only to it (or, more precisely, first in the hierarchy).  At the official forum, this question was raised several times - and while silence, there is only a registered requester (EXTJS-15503).  Ie, if you look at the picture from the KDPV from this point of view, you get this: <br><br><img src="https://habrastorage.org/files/a9a/614/de3/a9a614de3da84d6b9bb43cc40ca08c82.png"><br><br>  Those.  container 1 can bind to all internal components except container 2. That, in turn, is the same, except container 3. Because all components publish property changes only in the first ViewModel hierarchy, starting with its own. <br><br>  Too much information?  Let's try to figure it out. <br><br><hr><br><br><h2>  Part 2. For work! </h2><br> <a href="http://lurkmore.to/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25BC"><img src="https://habrastorage.org/files/98b/2e9/d0d/98b2e9d0d9b948e196acc2dbf781fd0b.jpg" width="300"></a> <br><br>  <i>A WARNING.</i>  <i>The solutions described below are experimental.</i>  <i>Use them with care, because backward compatibility is not guaranteed in all cases.</i>  <i>Comments, corrections and other help are welcome.</i>  <i>Go!</i> <br><br>  So, for starters, I would like to formulate my vision of developing components with MVVM: <br><br><ol><li>  To change the state of a component, use configuration properties and their public setters. </li><li>  Have the ability to bind to their own configuration properties (inside the component). </li><li>  Have the ability to bind to the properties of the component outside, regardless of whether it has its own ViewModel or not. </li><li>  Do not think about the uniqueness of names within the data hierarchy of ViewModels. </li></ol><br><br><h4>  Fix number 1.  Post changes up </h4><br>  Let's start with something simpler, for example, from point 3. Here it‚Äôs about the <code>Ext.mixin.Bindable</code> impurity <code>Ext.mixin.Bindable</code> and its <a href="https://docs.sencha.com/extjs/6.0/6.0.0-classic/source/Bindable.html">publishState</a> method.  If you look inside, we will see that the changes are published in the ViewModel, which is the first in the hierarchy.  Let's make sure that the parent ViewModel knows about this too: <br><br><pre> <code class="javascript hljs">publishState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, vm = me.lookupViewModel(), parentVm = me.lookupViewModel(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), path = me.viewModelKey; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path &amp;&amp; property &amp;&amp; parentVm) { path += <span class="hljs-string"><span class="hljs-string">'.'</span></span> + property; parentVm.set(path, value); } Ext.mixin.Bindable.prototype.publishState.apply(me, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre><br><br><table><tbody><tr><th>  Before </th><th>  After </th></tr><tr><td><img src="https://habrastorage.org/files/833/d58/0c7/833d580c7fa84149aad40f37e29e0326.png" width="100%"></td><td><img src="https://habrastorage.org/files/a19/8fd/bf5/a198fdbf5ac24842914a7fe4e92832cf.png" width="100%"></td></tr></tbody></table><br>  <a href="https://fiddle.sencha.com/">Demo on Sencha Fiddle</a> . <br><br><h4>  Fix number 2.  We bind to our own configuration properties </h4><br>  With regards to <abbr title="Have the ability to bind to their own configuration properties (inside the component).">paragraph 2</abbr> .  It seems unfair that there is an opportunity to attach to the properties of the component from the outside, but not from the inside.  Rather, with <code>reference <br></code> <code>reference <br></code>  - it is possible, but since we decided that this is not a very beautiful option, then at least manually we can do better: <br><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.UsersGrid</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.UsersGrid'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.grid.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">selection</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">config</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'addButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'removeButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove {selection.name}'</span></span> } }], <span class="hljs-comment"><span class="hljs-comment">// ... updateReadOnly: function (readOnly) { this.getViewModel().set('readOnly', readOnly); }, updateSelection: function (selection) { this.getViewModel().set('selection', selection); } });</span></span></code> </pre><br></div></div><br>  <a href="https://fiddle.sencha.com/">Sencha Fiddle demo</a> <br><br>  Looks better, right?  Outside, we bind with the <code>reference</code> , and from the inside - without.  Now whatever it is, the component code does not change.  Moreover, now we can add two components to one container, give them our own names <code>reference <br></code> <code>reference <br></code>  - and everything will work! <br><br>  Automate?  Add to the previous <code>publishState</code> method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property &amp;&amp; vm &amp;&amp; vm.getView() == me) { vm.set(property, value); }</code> </pre><br>  That's all.  Assess how concise bindings have become to their configuration properties: <br><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.UsersGrid</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.UsersGrid'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.grid.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'usersgrid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">config</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">publishes</span></span>: [<span class="hljs-string"><span class="hljs-string">'readOnly'</span></span>], <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'addButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove'</span></span>, <span class="hljs-attr"><span class="hljs-attr">itemId</span></span>: <span class="hljs-string"><span class="hljs-string">'removeButton'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-string"><span class="hljs-string">'{readOnly}'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Remove {selection.name}'</span></span> } }], <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">dataIndex</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span> }] });</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ext.ux.mixin.Bindable</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* global Ext */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * An override to notify parent ViewModel about current component's published properties changes * and to make own ViewModel contain current component's published properties values. */</span></span> Ext.define(<span class="hljs-string"><span class="hljs-string">'Ext.ux.mixin.Bindable'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">initBindable</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Ext.mixin.Bindable.prototype.initBindable.apply(me, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); me.publishInitialState(); }, <span class="hljs-comment"><span class="hljs-comment">/** Notifying both own and parent ViewModels about state changes */</span></span> publishState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, vm = me.lookupViewModel(), parentVm = me.lookupViewModel(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), path = me.viewModelKey; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path &amp;&amp; property &amp;&amp; parentVm) { path += <span class="hljs-string"><span class="hljs-string">'.'</span></span> + property; parentVm.set(path, value); } Ext.mixin.Bindable.prototype.publishState.apply(me, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property &amp;&amp; vm &amp;&amp; vm.getView() == me) { vm.set(property, value); } }, <span class="hljs-comment"><span class="hljs-comment">/** Publish initial state */</span></span> publishInitialState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, state = me.publishedState || (me.publishedState = {}), publishes = me.getPublishes(), name; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> publishes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state[name] === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { me.publishState(name, me[name]); } } } }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ Ext.Array.each([Ext.Component, Ext.Widget], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Class</span></span></span><span class="hljs-function">) </span></span>{ Class.prototype.initBindable = Ext.ux.mixin.Bindable.prototype.initBindable; Class.prototype.publishState = Ext.ux.mixin.Bindable.prototype.publishState; Class.mixin([Ext.ux.mixin.Bindable]); }); });</code> </pre><br></div></div><br>  <a href="https://fiddle.sencha.com/">Demo on Sencha Fiddle</a> . <br><br><h4>  Fix number 3.  Separate ViewModels and Components </h4><br>  The most difficult: <abbr title="Do not think about the uniqueness of names within the data hierarchy of ViewModels.">point 4</abbr> .  For the purity of the experiment, the previous fixes are not used.  Given: two nested components with the same configuration property - <code>color</code> .  Everyone uses the ViewModel to bind to this value.  Required: bind the property of the internal component to the property of the external.  Let's try? <br><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.OuterContainer</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.OuterContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, config: { color: null }, items: [{ xtype: 'textfield', fieldLabel: 'Enter color', listeners: { change: 'colorField_change' } }, { xtype: 'displayfield', fieldLabel: 'Color', bind: '{color}' }, { xtype: 'innercontainer', bind: { color: '{color}' } }], colorField_change: function (field, value) { this.setColor(value); }, updateColor: function (color) { this.getViewModel().set('color', color); } })</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fiddle.view.InnerContainer</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.InnerContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, config: { color: null }, items: [{ xtype: 'displayfield', fieldLabel: 'Color', bind: '{color}' }], updateColor: function (color) { this.getViewModel().set('color', color); } })</span></span></code> </pre><br></div></div><br>  <a href="https://fiddle.sencha.com/">Demo on Sencha Fiddle</a> . <br><br><img src="https://habrastorage.org/files/0ed/af0/635/0edaf0635c474f7bace75a70671074ea.PNG"><br><br>  It looks simple, but does not work.  Why?  Because if you look closely, the following forms of recording are absolutely identical: <br><br>  Option 1. <table><tbody><tr><td><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.OuterContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, items: [{ xtype: 'innercontainer', bind: { color: '{color}' } }] // ... })</span></span></code> </pre><br></td><td><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.InnerContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, config: { color: null }, items: [{ xtype: 'displayfield', fieldLabel: 'Color', bind: '{color}' }] // ... })</span></span></code> </pre><br></td></tr></tbody></table><br><br>  Option 2. <table><tbody><tr><td><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.OuterContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, items: [{ xtype: 'innercontainer' }] // ... })</span></span></code> </pre><br></td><td><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.InnerContainer'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... viewModel: { data: { color: null } }, config: { color: null }, bind: { color: '{color}' }, items: [{ xtype: 'displayfield', fieldLabel: 'Color', bind: '{color}' }] // ... })</span></span></code> </pre><br></td></tr></tbody></table><br><br>  Attention, question!  To the <code>color</code> property of whose ViewModel and we are in the internal container?  Oddly enough, in both cases - to the inside.  At the same time, judging by the documentation and the picture from the header, the data of the ViewModel and external container are the prototype for the data of the ViewModel and internal.  And since  the latter has the <code>color</code> value redefined, then when the prototype value changes, the heir has the old value ( <code>null</code> ).  Those.  In principle, there is no glitch - it should be so. <br><br>  How can you get out of the situation?  The most obvious thing is to remove the <code>color</code> from the internal ViewModel'i.  Then we also have to remove the <code>updateColor</code> handler.  And the configuration property is also in the firebox!  Let's hope that the parent container will always have a ViewModel with the <code>color</code> property. <br><br>  Or not?  Hope is not what we are dealing with.  Another option is to reassign all configuration properties (and ViewModel fields) so that there is no duplication (in theory): <code>outerContainerColor</code> and <code>innerContainerColor</code> .  But this is also unreliable.  In big projects there are so many names, and generally it‚Äôs not very beautiful. <br><br>  Here it would be great, when describing an external container, to specify a binding somehow like this: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.OuterContainer'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'innercontainer'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'{outercontainer.color}'</span></span> <span class="hljs-comment"><span class="hljs-comment">//   } }] })</span></span></code> </pre><br><br>  I will not torment, it can also be done: <br><br><div class="spoiler">  <b class="spoiler_title">Ext.ux.app.SplitViewModel + Ext.ux.app.bind.Template</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** An override to split ViewModels data by their instances */</span></span> Ext.define(<span class="hljs-string"><span class="hljs-string">'Ext.ux.app.SplitViewModel'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">override</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewModel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">config</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/** @cfg {String} ViewModel name */</span></span> name: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-comment"><span class="hljs-comment">/** @cfg {String} @private name + sequential identifer */</span></span> uniqueName: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-comment"><span class="hljs-comment">/** @cfg {String} @private uniqueName + nameDelimiter */</span></span> prefix: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> }, <span class="hljs-attr"><span class="hljs-attr">nameDelimiter</span></span>: <span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-attr"><span class="hljs-attr">expressionRe</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^(?:\{[!]?(?:(\d+)|([a-z_][\w\-\.|]*))\})$/i</span></span>, <span class="hljs-attr"><span class="hljs-attr">uniqueNameRe</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/-\d+$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">privates</span></span>: { <span class="hljs-attr"><span class="hljs-attr">applyData</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newData, data</span></span></span><span class="hljs-function">) </span></span>{ newData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedData(newData); data = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedData(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([newData, data]); }, <span class="hljs-attr"><span class="hljs-attr">applyLinks</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">links</span></span></span><span class="hljs-function">) </span></span>{ links = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedData(links); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([links]); }, <span class="hljs-attr"><span class="hljs-attr">applyFormulas</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">formulas</span></span></span><span class="hljs-function">) </span></span>{ formulas = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedData(formulas); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([formulas]); }, <span class="hljs-attr"><span class="hljs-attr">bindExpression</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, callback, scope, options</span></span></span><span class="hljs-function">) </span></span>{ path = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedPath(path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([path, callback, scope, options]); } }, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">descriptor, callback, scope, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ext.isString(descriptor)) { descriptor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedDescriptor(descriptor); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([descriptor, callback, scope, options]); }, <span class="hljs-attr"><span class="hljs-attr">linkTo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, reference</span></span></span><span class="hljs-function">) </span></span>{ key = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedPath(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([key, reference]); }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ path = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedPath(path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([path]); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ext.isString(path)) { path = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedPath(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ext.isObject(path)) { path = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedData(path); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callParent([path, value]); }, <span class="hljs-attr"><span class="hljs-attr">applyName</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ name = name || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type || <span class="hljs-string"><span class="hljs-string">'viewmodel'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }, <span class="hljs-attr"><span class="hljs-attr">applyUniqueName</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ id = id || Ext.id(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName() + <span class="hljs-string"><span class="hljs-string">'-'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; }, <span class="hljs-attr"><span class="hljs-attr">applyPrefix</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix</span></span></span><span class="hljs-function">) </span></span>{ prefix = prefix || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUniqueName() + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameDelimiter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefix; }, <span class="hljs-comment"><span class="hljs-comment">/** Apply a prefix to property names */</span></span> getPrefixedData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name, newName, value, result = {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { value = data[name]; newName = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPrefixedPath(name); result[newName] = value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }, <span class="hljs-comment"><span class="hljs-comment">/** Get a descriptor with a prefix */</span></span> getPrefixedDescriptor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">descriptor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> descriptorParts = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expressionRe.exec(descriptor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!descriptorParts) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> descriptor; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = descriptorParts[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '{foo}' -&gt; 'foo' descriptor = descriptor.replace(path, this.getPrefixedPath(path)); return descriptor; }, /** Get a path with a correct prefix Examples: foo.bar -&gt; viewmodel-123|foo.bar viewmodel|foo.bar -&gt; viewmodel-123|foo.bar viewmodel-123|foo.bar -&gt; viewmodel-123|foo.bar (no change) */ getPrefixedPath: function (path) { var nameDelimiterPos = path.lastIndexOf(this.nameDelimiter), hasName = nameDelimiterPos != -1, name, isUnique, vmUniqueName, vm; if (hasName) { // bind to a ViewModel by name: viewmodel|foo.bar name = path.substring(0, nameDelimiterPos + this.nameDelimiter.length - 1); isUnique = this.uniqueNameRe.test(name); if (!isUnique) { // replace name by uniqueName: viewmodel-123|foo.bar vm = this.findViewModelByName(name); if (vm) { vmUniqueName = vm.getUniqueName(); path = vmUniqueName + path.substring(nameDelimiterPos); } else { Ext.log({ level: 'warn' }, 'Cannot find a ViewModel instance by a specifed name/type: ' + name); } } } else { // bind to this ViewModel: foo.bar -&gt; viewmodel-123|foo.bar path = this.getPrefix() + path; } return path; }, /** Find a ViewModel by name up by hierarchy @param {String} name ViewModel's name @param {Boolean} skipThis Pass true to ignore this instance */ findViewModelByName: function (name, skipThis) { var result, vm = skipThis ? this.getParent() : this; while (vm) { if (vm.getName() == name) { return vm; } vm = vm.getParent(); } return null; } }); /** This override replaces tokenRe to match a token with nameDelimiter */ Ext.define('Ext.ux.app.bind.Template', { override: 'Ext.app.bind.Template', tokenRe: /\{[!]?(?:(?:(\d+)|([a-z_][\w\-\.|]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi });</span></span></code> </pre><br></div></div><br><br>  Now we write like this (only another symbol instead of a dot, since it is reserved): <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Fiddle.view.OuterContainer'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">viewModel</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'outercontainer'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'innercontainer'</span></span>, <span class="hljs-attr"><span class="hljs-attr">bind</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'{outercontainer|color}'</span></span> } }] })</code> </pre><br>  <a href="https://fiddle.sencha.com/">Demo on Sencha Fiddle</a> . <br><br><img src="https://habrastorage.org/files/8c0/1fe/5fa/8c01fe5fa1e94c208bd3b97ce3bb4161.PNG"><br><br>  Those.  we wrote a more specific <code>bind</code> with the <abbr title="name / alias">name of the</abbr> ViewModel'and.  When rendering the ViewModel code in a separate file, the name can be omitted - it will be taken from <abbr title="after the dot: alias: 'viewmodel.outercontainer'"><code>alias</code></abbr> .  Everything, no more changes are required.  You can attach to your ViewModel in the old fashioned way without a prefix.  We specify it for nested components that have (or may appear) their own ViewModel. <br><br>  Under the hood of this extension, the prefix consisting of its name ( <code>name</code> or <code>alias</code> ) and a unique <code>id</code> (as for components) is added to the fields of the ViewModel.  Then, at the time of initialization of the components, it is added to the names of all the bindings. <br><br><h4>  What does this give? </h4><br>  ViewModels data will be divided by hierarchy.  In the bindings it will be concretely visible, on the property of whose ViewModel'and they refer.  Now you can not worry about duplicating properties within the hierarchy of ViewModels.  You can write reusable components without looking at the parent container.  In conjunction with the previous fixes in complex components, the amount of code is reduced drastically. <br><br>  <a href="https://fiddle.sencha.com/">The last example with fixes ‚Ññ‚Ññ 1-3</a> <br><br>  But at this stage backward compatibility is partially lost.  Those.  if you, developing components, relied on the presence of some properties in the ViewModel and parent component, then the last fix will break everything for you: you will need to add a prefix to the binding corresponding to the name / alias of the parent ViewModel. <br><br><h3>  Total </h3><br>  The source code for the extensions is on GitHub, welcome: <br>  <a href="https://github.com/alexeysolonets/extjs-mvvm-extensions">github.com/alexeysolonets/extjs-mvvm-extensions</a> <br><br>  We used them in several projects - the flight is more than normal.  Besides the fact that we write less code, a clearer understanding of how the components are connected appeared - everything became crystal clear, the head no longer hurts <s>and dandruff disappeared</s> . <br><br>  For myself, there is one question: leave the last extension in the form of a global one, which affects all ViewModels and <code>override</code> , or render it as a class from which to inherit?  The second solution seems to be more democratic, but will it not cause more confusion?  In general, this question is still open. <br><br>  What were your nuances when developing c MVVM?  Discuss? </div><p>Source: <a href="https://habr.com/ru/post/266773/">https://habr.com/ru/post/266773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266753/index.html">Walking across tiles</a></li>
<li><a href="../266757/index.html">With 100,000,000 days a year</a></li>
<li><a href="../266759/index.html">PostgreSQL 9.5: what's new? Part 2. TABLESAMPLE</a></li>
<li><a href="../266761/index.html">Managing complexity in ruby ‚Äã‚Äãon rails projects. Part 1</a></li>
<li><a href="../266767/index.html">The digest of interesting materials for the mobile # 120 developer (September 7-13)</a></li>
<li><a href="../266775/index.html">The most outdated infrastructure you can buy for money.</a></li>
<li><a href="../266777/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 176 (September 7 - 13, 2015)</a></li>
<li><a href="../266779/index.html">We write our own Bitcoin payment gateway</a></li>
<li><a href="../266781/index.html">Logging JDBC requests and their parameters in an existing application</a></li>
<li><a href="../266783/index.html">About the habits of our users and technical support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>