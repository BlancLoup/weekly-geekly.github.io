<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bash scripts, part 9: regular expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bash scripts: start 
 Bash scripts, part 2: loops 
 Bash scripts, part 3: command line options and keys 
 Bash scripts, part 4: input and output 
 Bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bash scripts, part 9: regular expressions</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="https://habrahabr.ru/company/ruvds/blog/325522/">Bash scripts: start</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/325928/">Bash scripts, part 2: loops</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326328/">Bash scripts, part 3: command line options and keys</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326594/">Bash scripts, part 4: input and output</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326826/">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327248/">Bash scripts, part 6: functions and library development</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327530/">Bash scripts, part 7: sed and word processing</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327754/">Bash scripts, part 8: awk data processing language</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327896/">Bash scripts, part 9: regular expressions</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328346/">Bash scripts, part 10: practical examples</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328436/">Bash scripts, part 11: expect and automate interactive utilities</a> </blockquote><br>  In order to fully process texts in bash scripts using sed and awk, you just need to deal with regular expressions.  Implementations of this most useful tool can be found literally everywhere, and although all regular expressions are arranged in a similar way, they are based on the same ideas, working with them in different environments has certain features.  Here we talk about regular expressions that are suitable for use in Linux command line scripts. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/327896/"><img src="https://habrastorage.org/files/803/892/bfe/803892bfe548499aa763df324d40fd01.png"></a> <br><br>  This material is intended as an introduction to regular expressions, designed for those who may be completely unaware of what it is.  So let's start from the beginning. <br><a name="habracut"></a><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><h2>  <font color="#3AC1EF">What are regular expressions?</font> </h2><br>  For many, when they first see regular expressions, the thought immediately arises that there is a senseless jumble of symbols in front of them.  But this, of course, is far from the case.  Take a look at this regular expression, for example. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs tex">^([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span>]+)@([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>]+)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>([a-zA-Z]{2,5})<span class="hljs-formula"><span class="hljs-formula">$</span></span></code> </pre> <br>  In our opinion, even an absolute newcomer will immediately understand how it is arranged and why it is necessary :) If you are not completely clear, just read on and everything will fall into place. <br>  A regular expression is a pattern, using which programs like sed or awk filter texts.  Templates use ordinary ASCII characters that represent themselves, and so-called metacharacters, which play a special role, for example, allowing you to refer to certain groups of characters. <br><br><h2>  <font color="#3AC1EF">Regular Expression Types</font> </h2><br>  Implementations of regular expressions in various environments, for example, in programming languages ‚Äã‚Äãlike Java, Perl and Python, in Linux tools like sed, awk and grep, have certain features.  These features depend on the so-called regular expression engines that interpret patterns. <br>  Linux has two regular expression engines: <br><br><ul><li>  Engine that supports the standard POSIX Basic Regular Expression (BRE). </li><li>  Engine that supports the standard POSIX Extended Regular Expression (ERE). </li></ul><br>  Most Linux utilities are at least compliant with the POSIX BRE standard, but some utilities (including sed) understand only a subset of the BRE standard.  One of the reasons for this limitation is the desire to make such utilities as fast as possible in word processing. <br><br>  The POSIX ERE standard is often implemented in programming languages.  It allows you to use a large number of tools when developing regular expressions.  For example, it can be special sequences of characters for frequently used patterns, such as searching individual words in a text or sets of numbers.  Awk supports the ERE standard. <br><br>  There are many ways to develop regular expressions that depend on the programmer‚Äôs opinion and on the features of the engine for which they are created.  It‚Äôs not easy to write universal regular expressions that any engine can understand.  Therefore, we will focus on the most commonly used regular expressions and consider the features of their implementation for sed and awk. <br><br><h2>  <font color="#3AC1EF">POSIX BRE Regular Expressions</font> </h2><br>  Perhaps the simplest BRE pattern is a regular expression for finding the exact occurrence of a sequence of characters in a text.  Here's what the search string looks for in sed and awk: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | sed -n <span class="hljs-string"><span class="hljs-string">'/test/p'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/51e/066/ce151e066cd663f4df98e840831073ca.png"></div><br>  <i><font color="#999999">Find text by pattern in sed</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/8f4/b47/9de8f4b471c6480e773c3de4301b5d0b.png"></div><br>  <i><font color="#999999">Awk text search pattern</font></i> <br><br>  You may notice that the search for a given template is performed without taking into account the exact location of the text in the string.  In addition, the number of entries does not matter.  After the regular expression finds the specified text anywhere in the line, the line is considered suitable and passed for further processing. <br><br>  When working with regular expressions, it is necessary to take into account that they are case sensitive: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/Test/{print $0}'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a34/14c/d2c/a3414cd2cb6e497e44544ea3fa306f1f.png"></div><br>  <i><font color="#999999">Regular expressions are case sensitive</font></i> <br><br>  The first regular expression of matches did not find, since the word "test", starting with a capital letter, is not found in the text.  The second, configured to search for words written in capital letters, found in the stream a suitable line. <br><br>  In regular expressions, you can use not only letters, but also spaces and numbers: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test 2 again"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test 2/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aab/022/60a/aab02260a27124770cd425bd16c66a83.png"></div><br>  <i><font color="#999999">Search for a piece of text containing spaces and numbers</font></i> <br><br>  Spaces are perceived by the regular expression engine as ordinary characters. <br><br><h2>  <font color="#3AC1EF">Special symbols</font> </h2><br>  When using different characters in regular expressions, it is necessary to consider some features.  So, there are some special characters, or metacharacters, the use of which in a template requires a special approach.  Here they are: <br><br><pre> <code class="hljs bash">.*[]^<span class="hljs-variable"><span class="hljs-variable">${}</span></span>\+?|()</code> </pre> <br>  If one of them is needed in the template, it will need to be escaped with a backslash (backslash) - <code>\</code> . <br><br>  For example, if you need to find a dollar sign in the text, it must be included in the template, preceded by the escape character.  Let's say there is a file <code>myfile</code> with the following text: <br><br><pre> <code class="hljs cs">There <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> my pocket</code> </pre> <br>  The dollar sign can be detected using this pattern: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/\$/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e2/056/628/2e2056628c28fd1d141bf3cc9d7253a7.png"></div><br>  <i><font color="#999999">Using a special character in a pattern</font></i> <br><br>  In addition, the backslash is also a special character, so if you need to use it in a template, it will also need to be escaped.  It looks like two slashes coming one after the other: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"\ is a special character"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/\\/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47a/18f/06c/47a18f06c8a463f39d15da1f8bfd677a.png"></div><br>  <i><font color="#999999">Backslash Escaping</font></i> <br><br>  Although forward slash is not included in the above list of special characters, trying to use it in a regular expression written for sed or awk will result in an error: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"3 / 2"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'///{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/066/8a1/e77/0668a1e77511ed32970f60b26cd597e7.png"></div><br>  <i>Incorrect use of a forward slash in a pattern</i> <br><br>  If it is needed, it should also be screened: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"3 / 2"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/\//{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/de2/d8a/13dde2d8afe39a863e124712188a95b2.png"></div><br>  <i><font color="#999999">Forward slash escaping</font></i> <br><br><h2>  <font color="#3AC1EF">Anchor symbols</font> </h2><br>  There are two special characters to bind a template to the beginning or end of a text line.  The symbol ‚Äúcover‚Äù - <code>^</code> allows you to describe sequences of characters that are at the beginning of text lines.  If the pattern you are looking for appears elsewhere in the string, the regular expression will not respond to it.  This symbol looks like this: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"welcome to likegeeks website"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/^likegeeks/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"likegeeks website"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/^likegeeks/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b64/da5/ad1/b64da5ad11297c7f97de46f83dcda1da.png"></div><br>  <i><font color="#999999">Search for a template at the beginning of a line</font></i> <br><br>  The <code>^</code> symbol is designed to search for a pattern at the beginning of a line, while the case of characters is also taken into account.  Let's see how this will affect the processing of a text file: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/^this/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fb/810/f9b/1fb810f9bb775d412ae5c3748e78e42c.png"></div><br>  <i><font color="#999999">Search for a template at the beginning of a line in the text from a file</font></i> <br><br>  When using sed, if you put a cap somewhere inside the pattern, it will be perceived as any other ordinary character: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This ^ is a test"</span></span> | sed -n <span class="hljs-string"><span class="hljs-string">'/s ^/p'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ee/eba/d80/6eeebad801eeb799f1208331658ee6ef.png"></div><br>  <i><font color="#999999">A cap that is not at the beginning of the pattern in sed</font></i> <br><br>  In awk, when using the same pattern, this symbol must be escaped: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This ^ is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/s \^/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/a19/a69/fbba19a69e7814891f9d4c89e11c8414.png"></div><br>  <i><font color="#999999">A cap that is not at the beginning of an awk pattern</font></i> <br><br>  With the search for fragments of text located at the beginning of the line we figured out.  What if you need to find something located at the end of the line? <br><br>  This will help us dollar sign - <code>$</code> , which is the anchor character of the end of the line: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test$/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9a/040/0d5/b9a0400d5b963002ac59d3fc895f8f4f.png"></div><br>  <i><font color="#999999">Search for text at the end of the line</font></i> <br><br>  In the same pattern, you can use both anchor symbols.  Perform the processing of the file <code>myfile</code> , the contents of which are shown in the figure below, using this regular expression: <br><br><pre> <code class="hljs swift">$ awk '/^this <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a test$/{<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>}' myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/21b/87b/d1521b87b3ec1b32658b612b590c0f99.png"></div><br>  <i><font color="#999999">A pattern that uses special beginning and ending line characters.</font></i> <br><br>  As you can see, the template responded only to the line that fully corresponds to the specified sequence of characters and their location. <br><br>  Here's how, using anchor characters, to filter empty lines: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'!/^$/{print $0}'</span></span> myfile</code> </pre> <br>  In this template used the symbol of negation, an exclamation mark - <code>!</code>  .  Through the use of such a pattern, it searches for lines containing nothing between the beginning and end of the line, and thanks to the exclamation mark, only lines that do not match this pattern are printed. <br><br><h2>  <font color="#3AC1EF">Dot symbol</font> </h2><br>  The dot is used to search for any single character, except for the newline character.  Pass the file <code>myfile</code> this regular expression, the contents of which are shown below: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/.st/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/2d7/200/4a52d7200df95c30531ccc7a4a4924b1.png"></div><br>  <i><font color="#999999">Using a point in regular expressions</font></i> <br><br>  As can be seen from the displayed data, only the first two lines from the file correspond to the pattern, since they contain the sequence of characters "st", preceded by another character, while the third line does not contain a suitable sequence, but in the fourth one it is, but is in the very beginning of the line. <br><br><h2>  <font color="#3AC1EF">Character classes</font> </h2><br>  A dot matches any single character, but what if you need to flex more flexibly the set of desired characters?  In this situation, you can use classes of characters. <br><br>  With this approach, you can organize the search for any character from a given set.  To describe a class of characters, square brackets are used - <code>[]</code> : <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/[oi]th/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/e0a/644/f84e0a6441893131f42b3892486d467d.png"></div><br>  <i><font color="#999999">Character Class Description in Regular Expression</font></i> <br><br>  Here we are looking for a sequence of characters "th", in front of which there is a character "o" or a character "i". <br><br>  Classes are very helpful if you search for words that can begin with both uppercase and lowercase letters: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"this is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/[Tt]his is a test/{print $0}'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/[Tt]his is a test/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/f65/8a2/3d9f658a231a01771a5fc209b1cd086a.png"></div><br>  <i><font color="#999999">Search for words that may begin with a lowercase or uppercase letter</font></i> <br><br>  Character classes are not limited to letters.  Other symbols can be used here.  It is impossible to say in advance in what situation classes will be needed - it all depends on the problem to be solved. <br><br><h2>  <font color="#3AC1EF">Negation of character classes</font> </h2><br>  Character classes can also be used to solve the inverse problem described above.  Namely, instead of searching for characters included in a class, you can organize a search for everything that is not included in the class.  In order to achieve this behavior of a regular expression, in front of the list of class symbols you need to put a <code>^</code> .  It looks like this: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/[^oi]th/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba4/ae6/853/ba4ae6853c092785c6c9db33bee0e9d8.png"></div><br>  <i><font color="#999999">Search for non-class characters</font></i> <br><br>  In this case, the sequences of characters "th" will be found, before which there is neither "o" nor "i". <br><br><h2>  <font color="#3AC1EF">Character ranges</font> </h2><br>  In character classes, you can describe character ranges using a dash: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/[ep]st/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/f12/8aa/646f128aa44e661a023b6e721d81f020.png"></div><br>  <i><font color="#999999">Description of character range in character class</font></i> <br><br>  In this example, the regular expression responds to a sequence of characters "st", in front of which is any character located, in alphabetical order, between the characters "e" and "p". <br><br>  Ranges can be created from numbers as well: <br><br><pre> <code class="hljs markdown">$ echo "123" | awk '/[<span class="hljs-string"><span class="hljs-string">0-9</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0-9</span></span>][<span class="hljs-string"><span class="hljs-string">0-9</span></span>]/' $ echo "12a" | awk '/[<span class="hljs-string"><span class="hljs-string">0-9</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0-9</span></span>][<span class="hljs-string"><span class="hljs-string">0-9</span></span>]/'</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/810/1e4/48b/8101e448b27a7c9cb9c56fc0434adc0a.png"></div><br>  <i><font color="#999999">Regular expression to search for any three numbers</font></i> <br><br>  There may be several ranges in the character class: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/[a-fm-z]st/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e9/999/623/7e99996235e70b1dc907315343ae9b01.png"></div><br>  <i><font color="#999999">A multi-range character class.</font></i> <br><br>  This regular expression will find all the st strings in front of which there are characters from the ranges <code>af</code> and <code>mz</code> . <br><br><h2>  <font color="#3AC1EF">Special character classes</font> </h2><br>  In BRE there are special classes of characters that can be used when writing regular expressions: <br><br><ul><li>  <code>[[:alpha:]]</code> - matches any alphabetic character written in upper or lower case. </li><li>  <code>[[:alnum:]]</code> - matches any alphanumeric character, namely, characters in the ranges <code>0-9</code> , <code>AZ</code> , <code>az</code> . </li><li>  <code>[[:blank:]]</code> - matches the space and tab. </li><li>  <code>[[:digit:]]</code> - any numeric character from <code>0</code> to <code>9</code> . </li><li>  <code>[[:upper:]]</code> - uppercase alphabetic characters - <code>AZ</code> . </li><li>  <code>[[:lower:]]</code> - lowercase alphabetic characters - <code>az</code> . <br></li><li>  <code>[[:print:]]</code> - matches any printable character. </li><li>  <code>[[:punct:]]</code> - matches punctuation. </li><li>  <code>[[:space:]]</code> - whitespace characters, in particular - space, tab, <code>NL</code> , <code>FF</code> , <code>VT</code> , <code>CR</code> characters. </li></ul><br>  You can use special classes in templates like this: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/[[:alpha:]]/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/[[:digit:]]/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc123"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/[[:digit:]]/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e2/386/e8b/4e2386e8bce40ead25463d12945199f0.png"></div><br>  <i><font color="#999999">Special classes of characters in regular expressions</font></i> <br><br><h2>  <font color="#3AC1EF">Star symbol</font> </h2><br>  If you put an asterisk in the template after the character, it will mean that the regular expression will work if the character appears in the string any number of times - including the situation when the character in the string is missing. <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/tes*t/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tessst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/tes*t/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f7/04b/9ad/0f704b9ad0e6db2349a5257a35a42b8f.png"></div><br>  <i><font color="#999999">Using the * symbol in regular expressions</font></i> <br><br>  This template character is usually used to work with words that constantly contain typos, or for words that allow different variants of correct spelling: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"I like green color"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/colou*r/{print $0}'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"I like green colour "</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/colou*r/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb8/bbd/4a6/fb8bbd4a6cda3194f5438e44ec0d19a2.png"></div><br>  <i><font color="#999999">Search for a word with different spellings</font></i> <br><br>  In this example, the same regular expression responds to both the word ‚Äúcolor‚Äù and the word ‚Äúcolor‚Äù.  This is due to the fact that the symbol ‚Äúu‚Äù, after which the asterisk stands, may either be absent or occur several times in a row. <br><br>  Another useful feature arising from the features of the asterisk symbol is to combine it with a dot.  This combination allows the regular expression to respond to any number of any characters: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'/this.*test/{print $0}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/078/f43/49a/078f4349a99b37584cfc11404d373178.png"></div><br>  <i><font color="#999999">A pattern that responds to any number of any characters.</font></i> <br><br>  In this case, no matter how many and what characters are between the words "this" and "test". <br><br>  The asterisk can be used with character classes: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"st"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/s[ae]*t/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"sat"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/s[ae]*t/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"set"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/s[ae]*t/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b4/3c8/413/0b43c8413d2fd63352a82d6cb3a1909e.png"></div><br>  <i><font color="#999999">Using asterisks with character classes</font></i> <br><br>  In all three examples, the regular expression works, because the asterisk after the character class means that if any number of characters ‚Äúa‚Äù or ‚Äúe‚Äù is found, and also if they cannot be found, the string will match the specified pattern. <br><br><h2>  <font color="#3AC1EF">POSIX ERE Regular Expressions</font> </h2><br>  POSIX ERE templates that support some Linux utilities may contain additional characters.  As already mentioned, awk supports this standard, but sed does not. <br><br>  Here we look at the symbols most frequently used in ERE-templates, which will be useful to you when creating your own regular expressions. <br><br><h3>  <font color="#3AC1EF">‚ñç Question mark</font> </h3><br>  The question mark indicates that the preceding character may occur in the text once or not at all.  This character is one of the metacharacters of repetitions.  Here are some examples: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tet"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/tes?t/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/tes?t/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tesst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/tes?t/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/6ae/758/9e66ae7580f900e395dd762497f36a39.png"></div><br>  <i><font color="#999999">Question mark in regular expressions</font></i> <br><br>  As you can see, in the third case, the letter ‚Äús‚Äù occurs twice, so the regular expression does not respond to the word ‚Äútesst‚Äù. <br><br>  The question mark can also be used with character classes: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]?st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]?st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tast"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]?st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"taest"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]?st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teest"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]?st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/fe3/1e3/be8fe31e3f05cf44b2176c9e300bbc74.png"></div><br>  <i><font color="#999999">Question Mark and Character Classes</font></i> <br><br>  If there are no characters from the class in the string, or one of them occurs once, the regular expression is triggered, however, if two characters appear in the word, the system no longer finds a pattern match in the text. <br><br><h3>  <font color="#3AC1EF">‚ñçSymbol "plus"</font> </h3><br>  The plus symbol in the pattern indicates that the regular expression will find the search term if the preceding symbol is encountered in the text one or more times.  At the same time, such a construction will not react to the absence of a symbol: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te+st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teest"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te+st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te+st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/5c9/a06/d645c9a064e8c4af30d83ee3a21c6f56.png"></div><br>  <i><font color="#999999">The plus symbol in regular expressions</font></i> <br><br>  In this example, if the ‚Äúe‚Äù character is not in the word, the regular expression engine will not find any matching pattern in the text.  The plus symbol also works with character classes - in this way it looks like an asterisk and a question mark: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]+st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]+st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teast"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]+st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teeast"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/t[ae]+st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c77/6a7/78e/c776a778eabbfcf0dd0a77f98c26175c.png"></div><br>  <i><font color="#999999">The plus sign and character classes</font></i> <br><br>  In this case, if the string contains any character from the class, the text will be considered corresponding to the pattern. <br><br><h3>  <font color="#3AC1EF">‚ñçPair brackets</font> </h3><br>  The curly braces that can be used in ERE patterns are similar to the characters discussed above, but they allow you to more accurately specify the required number of occurrences of the preceding character.  You can specify a restriction in two formats: <br><br><ul><li>  <code>n ‚Äî</code> number specifying the exact number of the desired occurrences <br></li><li>  <code>n, m ‚Äî</code> two numbers that are interpreted as: "at least n times, but not more than m". <br></li></ul><br>  Here are examples of the first option: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1}st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ac/c40/2e5/4acc402e59676f3630b5b73d12ff7cfa.png"></div><br>  <i><font color="#999999">Curly brackets in patterns, finding the exact number of occurrences</font></i> <br><br>  In older versions of awk, you had to use the <code>--re-interval</code> command line <code>--re-interval</code> in order for the program to recognize intervals in regular expressions, but you don‚Äôt need to do this in newer versions. <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teest"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teeest"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/te{1,2}st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ba/0c0/3f5/7ba0c03f5020b615812530ca2af99b13.png"></div><br>  <i><font color="#999999">The interval specified in braces</font></i> <br><br>  In this example, the character "e" should occur in the string 1 or 2 times, then the regular expression will respond to the text. <br><br>  Braces can also be used with character classes.  There are already familiar to you principles: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span> | awk  <span class="hljs-string"><span class="hljs-string">'/t[ae]{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> | awk  <span class="hljs-string"><span class="hljs-string">'/t[ae]{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teest"</span></span> | awk  <span class="hljs-string"><span class="hljs-string">'/t[ae]{1,2}st/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"teeast"</span></span> | awk  <span class="hljs-string"><span class="hljs-string">'/t[ae]{1,2}st/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/e97/03a/88ee9703a9d01a0200e19f6bef7096b3.png"></div><br>  <i><font color="#999999">Braces and character classes</font></i> <br><br>  The template will react to the text in the event that in it one or two times the symbol ‚Äúa‚Äù or the symbol ‚Äúe‚Äù occurs. <br><br><h3>  <font color="#3AC1EF">Symbol of the logical "or"</font> </h3><br>  Symbol <code>|</code>  - vertical bar, means in regular expressions the logical "or".  When processing a regular expression containing several fragments separated by such a sign, the engine will consider the analyzed text to be suitable if it matches any of the fragments.  Here is an example: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is a test"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test|exam/{print $0}'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is an exam"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test|exam/{print $0}'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"This is something else"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/test|exam/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b5/5b7/4f1/3b55b74f1cf11a6aafdbd4839413d31c.png"></div><br>  <i><font color="#999999">Logical "or" in regular expressions</font></i> <br><br>  In this example, the regular expression is configured to search for the text ‚Äútest‚Äù or ‚Äúexam‚Äù in the text.  Note that between the fragments of the template and the symbol separating them <code>|</code>  There should be no spaces. <br><br><h2>  <font color="#3AC1EF">Regular Expression Fragment Grouping</font> </h2><br>  Regular expression fragments can be grouped using parentheses.  If you group a certain sequence of characters, it will be perceived by the system as a normal character.  That is, for example, it will be possible to apply repetition metacharacters to it.  Here's what it looks like: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Like"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/Like(Geeks)?/{print $0}'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"LikeGeeks"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/Like(Geeks)?/{print $0}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/c80/df7/c78c80df73aa2c9817f53df90a067ad8.png"></div><br>  <i><font color="#999999">Regular Expression Fragment Grouping</font></i> <br><br>  In these examples, the word "Geeks" is enclosed in parentheses, after this construction comes a question mark.  Recall that the question mark means ‚Äú0 or 1 repetition‚Äù, as a result, the regular expression will respond to the ‚ÄúLike‚Äù line and to the ‚ÄúLikeGeeks‚Äù line. <br><br><h2>  <font color="#3AC1EF">Practical examples</font> </h2><br>  After we took apart the basics of regular expressions, it's time to do something useful with their help. <br><br><h3>  <font color="#3AC1EF">‚ñçCounting the number of files</font> </h3><br>  Let's write a bash script that counts the files in directories that are written to the PATH environment variable.  In order to do this, you will need, first, to create a list of paths to directories.  We do this with sed, replacing colons with spaces: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$PATH</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/:/ /g'</span></span></code> </pre> <br>  The replace command supports regular expressions as patterns for text search.  In this case, everything is extremely simple, we are looking for the colon symbol, but no one bothers to use here and anything else - it all depends on the specific task. <br>  Now you have to go through the list in a loop and perform the necessary actions there to calculate the number of files.  The general scheme of the script will be as follows: <br><br><pre> <code class="hljs bash">mypath=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$PATH</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/:/ /g'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$mypath</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Now we will write the full text of the script, using the <code>ls</code> to get information about the number of files in each of the directories: <br><br><pre> <code class="hljs mel">#!/bin/bash mypath=$(echo $PATH | sed <span class="hljs-string"><span class="hljs-string">'s/:/ /g'</span></span>) count=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $mypath <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> check=$(<span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> $directory) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $check <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> count=$[ $count + <span class="hljs-number"><span class="hljs-number">1</span></span> ] done echo <span class="hljs-string"><span class="hljs-string">"$directory - $count"</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span> done</code> </pre> <br>  When you run the script, it may turn out that some directories from the <code>PATH</code> do not exist, however, this will not prevent it from counting files in existing directories. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75b/6ef/697/75b6ef697cb8244cb70599f42d80c663.png"></div><br>  <i><font color="#999999">File counting</font></i> <br><br>  The main value of this example lies in the fact that using the same approach, one can solve much more complicated problems.   ‚Äî    . <br><br><h3> <font color="#3AC1EF">‚ñç   </font> </h3><br>  -     ,      ,  ,   . ,   ‚Äî  ,    ‚Äî  - .         .     . , ,  : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">username</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">hostname</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">com</span></span></code> </pre> <br>  , <code>username</code> ,    -    .  ,  , ,  ,  ¬´¬ª.      @. <br><br>   ,        ,      .     : <br><br><pre> <code class="hljs tex">^([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span>]+)@</code> </pre> <br>      : ¬´          ,    ,    ,       @¬ª. <br><br>  ‚Äî    ‚Äî <code>hostname</code> .     ,     ,       : <br><br><pre> <code class="hljs tex">([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>]+)</code> </pre> <br>       .      ,       (,      ),    .   ,         : <br><br><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>([a-zA-Z]{2,5})<span class="hljs-formula"><span class="hljs-formula">$</span></span></code> </pre> <br>    : ¬´   ,  ‚Äî  2  5  ,     ¬ª. <br><br>       ,   : <br><br><pre> <code class="hljs tex">^([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span>]+)@([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>]+)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>([a-zA-Z]{2,5})<span class="hljs-formula"><span class="hljs-formula">$</span></span></code> </pre> <br>     ,  : <br><br><pre> <code class="hljs tex"><span class="hljs-formula"><span class="hljs-formula">$ echo "name@host.com" | awk '/^([a-zA-Z0-9_</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span></span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span></span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span></span><span class="hljs-formula">]+)@([a-zA-Z0-9_</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span></span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span></span><span class="hljs-formula">]+)</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span></span><span class="hljs-formula">([a-zA-Z]{2,5})$</span></span>/{print <span class="hljs-formula"><span class="hljs-formula">$0}' $</span></span> echo "name@host.com.us" | awk '/^([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span>]+)@([a-zA-Z0-9_<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>]+)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>([a-zA-Z]{2,5})<span class="hljs-formula"><span class="hljs-formula">$/{print $</span></span>0}'</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/f01/a60/9a5f01a6058b364523a8241e5f35c344.png"></div><br> <i><font color="#999999">       </font></i> <br><br> ,   awk    , ,        . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>        ,       ,    , ,        .     ‚Äî      .   ,   ‚Äî  ,     ,    ,   ,       ,     . <br><br>           bash-,      .     -  . <br><br>  Dear readers!            ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/327896/">https://habr.com/ru/post/327896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327886/index.html">SeaMonkey Project officially requests support</a></li>
<li><a href="../327888/index.html">Ros. Navigation stack</a></li>
<li><a href="../327890/index.html">Ruby on Rails agreement. Part 1</a></li>
<li><a href="../327892/index.html">Email is personal data?</a></li>
<li><a href="../327894/index.html">Implementing a NetFlow sensor on an FPGA + CPU - flexibly and quickly</a></li>
<li><a href="../327898/index.html">Six programming paradigms that change your view of code</a></li>
<li><a href="../327900/index.html">Automate non-automated, or about Xamarin in real projects</a></li>
<li><a href="../327904/index.html">Twitter: intercepting the management of views and thoughts</a></li>
<li><a href="../327908/index.html">Acronis Backup 12.5 (now and) Advanced: long-awaited release</a></li>
<li><a href="../327910/index.html">Functional security, part 7 of 7. Methods of ensuring information and functional security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>