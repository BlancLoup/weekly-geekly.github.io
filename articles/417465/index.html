<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of text entry binding methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Some time ago, I became a participant in a project to develop a software product designed to analyze patient records and data on heal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of text entry binding methods</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p>  Some time ago, I became a participant in a project to develop a software product designed to analyze patient records and data on health status received from medical organizations with the aim of forming a single medical card.  For a long time, the team could not develop an approach to combining patient data.  The starting point was the study of the source codes of the <a href="https://www.openempi.org/">Open EMPI</a> (Open Enterprise Master Patient Index) solution, which pushed us to the string-like analysis algorithms.  From this point on, a more in-depth study of the materials began, which made it possible to create a layout first and then a working solution. </p><br><p>  So far, at various presentations, one has to hear a lot of questions about the logic of the work of such products, from which I conclude that a review of methods for linking text records will be interesting to a wide circle of readers. </p><br><p>  The material is a translation of the wikipedia article ‚Äú <a href="https://en.wikipedia.org/wiki/Record_linkage">Record linkage</a> ‚Äù with copyright amendments. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  What is text linking? </h2><br><p>  The term <em>‚Äúlinking text records‚Äù</em> (record linkage) describes the process of attaching text records from one data source to records from another, provided that they describe the same object.  In computer science, this is called <em>‚Äúdata matching‚Äù</em> or <em>‚Äúobject identity problem</em> . <em>‚Äù</em>  Sometimes alternative definitions are used, such as <em>‚Äúidentification‚Äù</em> , <em>‚Äúbinding</em> , <em>‚Äú duplicate detection ‚Äù</em> , <em>‚Äú deduplication ‚Äù</em> , <em>‚Äú record mapping ‚Äù</em> , <em>‚Äú object identification ‚Äù</em> , which describe the same concept.  This terminological abundance led to the separation of approaches for processing and structuring information - <em>linking records</em> and <em>linking data</em> .  Although they both define the identification of matching objects by different sets of parameters, the term ‚Äúlinking text records‚Äù is commonly used when it comes to <em>‚Äúessence‚Äù of a</em> person, while ‚Äúdata binding‚Äù means the possibility of linking any web resource between data sets, using accordingly the broader concept of the identifier, namely the URI. </p><br><h2 id="zachem-eto-nuzhno">  Why do you need it? </h2><br><p>  When developing software products for building automated systems used in various fields related to the processing of human personal data (health care, history, statistics, education, etc.), it is necessary to identify data on accounting subjects coming from various sources. </p><br><p>  However, when collecting descriptions from a large number of sources, problems arise that make it difficult for them to identify unambiguously.  These problems include: </p><br><ul><li>  typos; </li><li>  field permutations (for example, in the patronymic name); </li><li>  the use of abbreviations and abbreviations; </li><li>  the use of different formats of identifiers (dates, document numbers, etc.). </li><li>  phonetic distortions; </li><li>  etc. </li></ul><br><p>  The quality of the primary data directly affects the outcome of the binding process.  Because of these problems, often data sets are sent to processing, which, although they describe the same object, these records look different.  Therefore, on the one hand, all transferred record identifiers are evaluated for applicability to use in the identification process, and on the other hand, the records themselves are normalized or standardized in order to bring them into a single format. </p><br><h2 id="ekskurs-v-istoriyu">  History tour </h2><br><p>  The initial idea of ‚Äã‚Äãlinking records was expressed by Gilbert Dunn (Halbert L. Dunn), publishing in 1946 an article in the American Journal of Public Health entitled ‚ÄúRecord Linkage‚Äù. </p><br><p>  Later, in 1959, the article "Automatic Linkage of Vital Records" in the journal Science, Howard B. Newcombe laid the probabilistic basis of the modern theory of string binding, which in 1969 was developed and consolidated by Ivan Fellegi and Alan Santer (Alan Sunter).  Their work ‚ÄúA Theory For Record Linkage‚Äù is still a mathematical rationale for many binding algorithms. </p><br><p>  The main development of the algorithms received in the 90s of the last century.  Then from different areas (statistics, archives, epidemiology, history, and others) algorithms that are now used in software products, such as the <em>Jaro-Winkler</em> (Jaro-Winkler distance) <em>similarity (</em> distance) and <em>Levenshtein</em> distance, came to us. However, some solutions, such as the Soundex phonetic algorithm, appeared much earlier - in the 20s of the last century. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Text entry comparison algorithms </h2><br><p>  There are <em>deterministic</em> and <em>probabilistic</em> algorithms for comparing text entries.  The <em>deterministic</em> algorithms are based on the complete coincidence of the attributes of the records.  Probabilistic algorithms allow one to calculate the degree of correspondence of the attributes of records and on the basis of this to decide on the possibility of their connection. </p><br><h3 id="determinirovannye-algoritmy">  Deterministic Algorithms </h3><br><p>  The easiest way to compare strings is based on clear rules, when links between objects are generated based on the number of matching attributes of data sets.  That is, two entries match each other through a deterministic algorithm if all or some of their attributes are identical.  Deterministic algorithms are suitable for comparing subjects described by a data set that are identified by a common identifier (for example, the Insurance number of an individual personal account in the Pension Fund - SNILS) or have several representative identifiers (date of birth, gender, etc.) that can be trusted. </p><br><p>  It is possible to apply deterministic algorithms when clearly structured (standardized) data sets are passed to processing. </p><br><p>  For example, it has the following set of text entries: </p><br><table><thead><tr><th>  No </th><th>  SNILS </th><th>  Name </th><th>  Date of Birth </th><th>  Floor </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Clara </td><td>  12.26.1946 </td><td>  F </td></tr></tbody></table><br><table><thead><tr><th>  No </th><th>  SNILS </th><th>  Name </th><th>  Date of Birth </th><th>  Floor </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  12.26.1946 </td><td>  2 </td></tr></tbody></table><br><p>  It was said earlier that the simplest deterministic algorithm is the use of a unique identifier, which is supposed to uniquely identify a person.  For example, we will assume that all records that have the same identifier value (SNILS) are described by the same subject, otherwise they are different subjects.  The deterministic connection in this case will generate the following pairs: A1 and A2, A3 and B1.  B2 will not be associated with A1 and A2, since it does not have an identifier value, although it coincides in content with the indicated entries. </p><br><p>  These exceptions lead to the need to supplement the deterministic algorithm with new rules.  For example, in the absence of a unique identifier, you can use other attributes such as name, date of birth and gender.  In the above example, this additional rule again does not give a match B2 and A1 / A2, because now the names differ - there is a phonetic distortion of the last name. </p><br><p>  This problem can be solved using the methods of phonetic analysis, but when changing the name (for example, in the case of marriage), you will need to resort to applying the new rule, for example, comparing the date of birth or allow differences in the available attributes of the record (for example, gender). </p><br><p>  The example clearly illustrates that the deterministic algorithm is very sensitive to the quality of the data, and an increase in the number of attributes of records can lead to a significant increase in the number of applied rules, which greatly complicates the use of deterministic algorithms. </p><br><p>  Moreover, the use of deterministic algorithms is possible, if there is a verified data set (master directory) with which the incoming information is compared.  However, in the case of a constant replenishment of the master directory itself, it may be necessary to completely restructure existing links, which makes the use of deterministic algorithms time-consuming or simply impossible. </p><br><h3 id="veroyatnostnye-algoritmy">  Probabilistic algorithms </h3><br><p> Probabilistic algorithms for linking string records use a wider set of attributes than deterministic ones, and for each attribute a weighting factor is calculated that determines the ability to influence the connection in the final assessment of the probability of conformity of the estimated records.  Entries with a final weight above a certain threshold are considered linked, records with a final weight below the threshold are considered unrelated.  Couples that score the value of the total weight from the middle of the range are considered candidates for binding and can be considered later (for example, by the operator), who will decide to merge (link) or leave unrelated.  Thus, unlike deterministic algorithms, which are a set of a large number of clear (programmed) rules, probabilistic algorithms can be adapted to the quality of data by selecting threshold values ‚Äã‚Äãand do not require reprogramming. </p><br><p>  So, probabilistic algorithms assign weight coefficients ( <em>u</em> and <em>m</em> ) to attributes of the record, with the help of which their conformity or non-conformity with each other will be determined. </p><br><p>  The coefficient u determines the probability that the identifiers of two independent entries coincide randomly.  For example, the u-probability of the month of birth (when there are twelve equally distributed values) will be 1 \ 12 = 0.083.  Identifiers with values ‚Äã‚Äãthat are unevenly distributed will have different probabilities for different values ‚Äã‚Äã(sometimes including missing values). </p><br><p>  The coefficient m is the probability that the identifiers in the compared pairs match each other or are quite similar - for example, in the case of high probability using the Jaro-Winkler algorithm or low probability using the Lowenstein algorithm.  In the case of full compliance of attributes of records, this value should be set to 1.0, but given the low probability of this, the coefficient should be estimated differently.  This assessment can be made on the basis of a preliminary analysis of a data set, for example, by manually <em>‚Äúlearning‚Äù a</em> probabilistic algorithm when identifying a large number of matching and mismatching pairs or by iteratively launching an algorithm to select the most appropriate m-coefficient value. </p><br><p>  If the m-probability is defined as 0.95, then the correspondence coefficients \ discrepancies for the month of birth will look like this: </p><br><table><thead><tr><th>  Metrics </th><th>  Share links </th><th>  Percentage of values, not references </th><th>  Frequency </th><th>  Weight </th></tr></thead><tbody><tr><td>  Conformity </td><td>  m = 0.95 </td><td>  u = 0.083 </td><td>  m \ u = 11.4 </td><td>  ln (m / u) / ln (2) ‚âà 3.51 </td></tr><tr><td>  Mismatch </td><td>  1-m = 0.05 </td><td>  1-u = 0.917 </td><td>  (1-m) / (1-u) ‚âà 0.0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) ‚âà -4.20 </td></tr></tbody></table><br><p>  Similar calculations should be made for other record identifiers in order to determine their compliance and non-compliance rates.  Then, each identifier of one record is compared with the corresponding identifier of another record to determine the total weight of the pair: the weight of the corresponding pair is added to the total result with a cumulative total, while the weight of the non-corresponding pair is subtracted from the total result.  The resulting amount is compared with the identified thresholds to determine whether to bind or not bind the analyzed pair automatically or pass it on to the operator. </p><br><h4 id="blokirovanie">  Blocking </h4><br><p>  Determining the compliance \ mismatch thresholds is the balance between obtaining acceptable sensitivity (the proportion of related records detected by the algorithm) and the predictive value of the result (i.e. accuracy, as measures of the actually matching each other's records related by the algorithm).  Since the determination of thresholds can be a very difficult task, especially for large data sets, a method known as <em>blocking</em> is often used to increase the efficiency of calculations.  Attempts to perform a comparison between records for which significant discrepancies ( <em>discrimination</em> ) in the values ‚Äã‚Äãof basic attributes are detected are blocked.  This leads to an increase in accuracy due to a decrease in sensitivity. </p><br><p>  For example, locking based on phonetic coding of the last name reduces the total number of comparisons required and increases the likelihood that the links between the records will be correct, since the two attributes are already consistent, but could potentially miss the entries related to the same person whose last name is changed (for example, as a result of marriage).  The month of birth lock is a more stable indicator that can be adjusted only if there is an error in the source data, but provides a more modest benefit in positive predictive value and loss of sensitivity, since it creates twelve different groups of extremely large data sets and does not increase the speed calculations </p><br><p>  Thus, the most effective systems for linking text records often use several blocking passes to group data in various ways in order to prepare groups of records that must later be passed on for analysis. </p><br><h4 id="mashinnoe-obuchenie">  Machine learning </h4><br><p>  Recently, various methods of machine learning have been used to link text entries.  In his work, published in 2011, Randall Wilson showed that the classical algorithm for the probabilistic linking of text records is equivalent to the naive Bayes algorithm and experiences the same problems from the assumption of independence of classification features.  To improve the accuracy of the analysis, the author proposes to use the basic model of a neural network called a single-layer perceptron, the use of which allows one to substantially exceed the results obtained using traditional probabilistic algorithms. </p><br><h2 id="foneticheskoe-kodirovanie">  Phonetic coding </h2><br><p>  <a href="https://habr.com/post/114947/">Phonetic algorithms</a> match the same codes to two words that are similar in pronunciation, which allows comparison of such words based on their phonetic similarity. </p><br><p>  Most phonetic algorithms are designed to analyze words of the English language, although recently some algorithms have been modified for use with other languages, or were originally created as national solutions (for example, Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  The classic algorithm for comparing two strings by their sound is Soundex (short for Sound index).  It sets the same code for strings that have similar sound in English.  Soundex was originally used by the National Archives Administration in the 1930s to retrospectively analyze population censuses from 1890 to 1920. </p><br><p>  The authors of the algorithms are Robert Russell (Robert C. Russel) and Margaret King Odell (Margaret King Odell), who patented it in the 20s of the last century.  The algorithm itself became popular in the second half of the last century when it became the subject of several articles in popular science journals in the USA and was published in D. Knut's monograph ‚ÄúThe Art of Programming‚Äù. </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Since Soundex is only suitable for English, some researchers have attempted to modify it.  In 1985, Gary Mokotoff and Randy Daitch proposed a variant of the Soundex algorithm, designed to match Eastern European (including Russian) surnames with a fairly high quality. </p><br><h3 id="metaphone">  Metaphone </h3><br><p>  In the 90s, Lawrence Philips (Lawrence Philips) proposed an alternative variant of the Soundex algorithm, which was called Metaphone.  The new algorithm used a larger set of English pronunciation rules due to which it was more accurate.  Later, the algorithm was modified to be used in other languages ‚Äã‚Äãbased on transcription using the letters of the Latin alphabet. </p><br><h3 id="russkiy-metaphone">  Russian Metaphone </h3><br><p>  In 2002, an article by Pyotr Kankowski was published in the 8th edition of the Programmer magazine, telling about his adaptation of the English version of the Metaphone algorithm.  This version of the algorithm transforms the original words in accordance with the rules and norms of the Russian language, taking into account the phonetic sound of unstressed vowels and possible ‚Äúmergers‚Äù of consonants in pronunciation. </p><br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  As a result of several iterations, the project team for the development of a software product, which was mentioned in the introduction, produced an architectural solution, the scheme of which is shown in the figure. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  Textual descriptions of patients are accepted through the REST service and stored in the repository (card database) without any changes.  Since our system works with medical data, the <a href="http://hl7.org/fhir/">FHIR</a> (Fast Healthcare Interoperability Resources) standard was chosen for information exchange.  Information about the received patient card is transferred to the message queue for further analysis and decision making about establishing a connection. </p><br><p>  The first card is processed by the <em>‚ÄúFast Analyzer‚Äù</em> operating according to a deterministic algorithm.  If all the rules of the deterministic algorithm have worked, then it creates a record in a separate storage (DB of links) with reference to the card being processed.  The record contains, in addition to the identifier of the analyzed card, the date of connection and a conditional identifier that identifies the globally-identified patient.  Other cards are further referenced to this global identifier, thereby forming an array describing a specific individual. </p><br><p>  If the deterministic algorithm has not found a match, then the card information is transmitted via the message queue to the ‚ÄúFull analyzer‚Äù. </p><br><p>  The full analyzer implements a mixed comparison algorithm (probabilistic and deterministic).  The work of the complete analyzer consists of a series of successive stages.  In some simplification, the stages can be represented as follows: </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p>  <strong>Stage 1. Selection of candidate cards</strong> <br>  At this stage, using phonetic algorithms from the database of cards, those in which names similar in sound are found are selected.  An array of selected cards after normalization is transferred to the processing stage 2. </p><br><p>  <strong>Stage 2. Name Analysis</strong> <br>  Using the Jaro-Winkler algorithm, we determine the probability of specifying names in the compared cards that refer to the same individual (patient). </p><br><p>  <strong>Stage 3. Identifier Analysis</strong> <br>  Next, the matching of other attributes of the patient record, such as passport numbers, MHI (compulsory health insurance) and SNILS, as well as gender and date of birth, is analyzed. </p><br><p>  <strong>Stage 4. Final similarity score</strong> <br>  At the final step, the points obtained during the analysis at each of the stages are summed up.  The total value is compared with the empirically obtained boundary values.  If the sum of points is higher than the bounding bound, then a record is created in the link store, similar to the logic of the fast analyzer.  If the sum of points is lower than the bounding limit, but higher than the limit that uniquely determines the difference between cards, then the analyzed card is transferred to a visual assessment by the system operator. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/417465/">https://habr.com/ru/post/417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417453/index.html">Organization of internships for students: rakes and tricks</a></li>
<li><a href="../417457/index.html">Frontend Conf Moscow - client-side and deep and wide</a></li>
<li><a href="../417459/index.html">Know your JIT: closer to the car</a></li>
<li><a href="../417461/index.html">Ivan Tulup: asynchronism in JS under the hood</a></li>
<li><a href="../417463/index.html">Unexpected meeting. Chapter 17</a></li>
<li><a href="../417469/index.html">Five selfish reasons to work reproducibly</a></li>
<li><a href="../417471/index.html">Simple Solder MK936 SMD. DIY soldering station on SMD components</a></li>
<li><a href="../417473/index.html">Secure storage with DRBD9 and Proxmox (Part 1: NFS)</a></li>
<li><a href="../417475/index.html">Glusterfs + erasure coding: when you need a lot, cheap and reliable</a></li>
<li><a href="../417477/index.html">Hot workplace (Hot desking)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>