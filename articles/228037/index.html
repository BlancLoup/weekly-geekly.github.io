<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inheritance grammars in Sprache (or another customizable expression calculator for .NET)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article demonstrates the technique of creating parsers using grammar inheritance. Inheritance allows you to describe new grammars based on existin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inheritance grammars in Sprache (or another customizable expression calculator for .NET)</h1><div class="post__text post__text-html js-mediator-article">  The article demonstrates the technique of creating parsers using grammar inheritance.  Inheritance allows you to describe new grammars based on existing ones by adding new rules or redefining inherited ones, which greatly simplifies the implementation of new parsers.  Changes in the basic grammar are automatically available in all generated grammars.  The main field of application of such technology is the support of several dialects or versions of languages. <br><a name="habracut"></a><br>  Support for grammar inheritance exists in some parser generators (for example, in ANTLR, Nitra), and is automatically available in tools that use object-oriented languages ‚Äã‚Äãas DSL languages ‚Äã‚Äãfor describing grammars (for example, Sprache and Irony). <br><br>  As an example of an application for an article, a custom expression expression calculator library with support for user-defined functions and variables is taken.  The calculator compiles strings into LINQ expressions that are easily converted to strongly typed delegates.  Unlike interpreting calculators like NCalc, compiled expressions do not differ in any way from methods written in C #.  An example of using the finished calculator: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var expr = calc.ParseExpression("Sin(y/x)", x =&gt; 2, y =&gt; System.Math.PI); var func = expr.Compile(); Console.WriteLine("Result = {0}", func()); //   calc.RegisterFunction("Mul", (a, b, c) =&gt; a * b * c); expr = calc.ParseExpression("2 ^ Mul(PI, a, b)", a =&gt; 2, b =&gt; 10); Console.WriteLine("Result = {0}", func.Compile()());</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Sprache Short Review </h4><br>  Sprache is a minimalist functional library for building combinatorial parsers.  As the authors of the library say modestly, it occupies an intermediate position between regular expressions and full-fledged parser building tools like ANTLR. <br><br>  I would say that Sprache is an excellent tool, excellent for a fairly wide range of tasks and has a special appeal as it encourages step-by-step development of grammars and TDD.  Of course, combinatorial parsers have certain drawbacks (for example, difficulties in diagnosing and recovering from errors), but such details are irrelevant for the topic of this article. <br><br>  A parser in Sprache is a function that transforms an input string into some other object.  Unlike most compiler building tools, Sprache does not use code generation.  Parsers are defined directly in the program text, and you can immediately use them to parse the text.  This allows you to write unit tests for them in parallel with the description of the parsers, which is very convenient.  Here is an example of a simple parser that takes a line of repeated letters A: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parseA = Parse.Char(<span class="hljs-string"><span class="hljs-string">'A'</span></span>).AtLeastOnce();</code> </pre><br>  Simple parsers are combined into more complex parsers.  For the combination of parsers, Sprache defines the mass of extension-methods (for example, Or, And, Many, etc.), however, the definition of parsers as LINQ queries is particularly impressive: <br><br><pre> <code class="cs hljs">Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; identifier = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> leading <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.WhiteSpace.Many() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Letter.Once() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rest <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.LetterOrDigit.Many() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> trailing <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.WhiteSpace.Many() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function"> new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first.Concat(rest</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = identifier.Parse(<span class="hljs-string"><span class="hljs-string">" abc123 "</span></span>); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"abc123"</span></span>, id);</code> </pre><br>  The combination of all the rules, or grammar of a language, in Sprache usually looks like a static class with parser fields.  For more information about Sprache, you can read in a review article for which there is a translation at habr√©: <br><br>  <a href="http://habrahabr.ru/post/127642/">We build DSL on C # using parser combinators</a> <br><br><h4>  Calculator device </h4><br>  Our calculator can work in three modes: simple, scientific and customizable. <br><br>  A simple calculator supports regular arithmetic operations on floating-point numbers, unary minus and parentheses.  Scientific mode adds support for binary and hexadecimal numbers, exponential notation and calls to any functions from the System.Math class, and in custom mode, you can use parameters and register your own functions (with the possibility of overloading). <br><br>  Each following mode supports all features of previous modes and adds new ones.  In the same way, a hierarchy of classes of grammars will be arranged that describe the input expressions languages ‚Äã‚Äãof the calculator.  The calculator parser is a function that converts the input string to a LINQ expression, which can be compiled into a delegate and called as a normal function: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = <span class="hljs-string"><span class="hljs-string">"4*(1/1-1/3+1/5-1/7+1/9-1/11+1/13-1/15+1/17-1/19+10/401)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = calc.ParseExpression(expr).Compile(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = func();</code> </pre><br><h4>  Simple calculator </h4><br>  An example from the delivery of Sprache, the ultra-compact LinqyCalculator, is taken as the basis for a simple calculator.  The grammar is broken down into rules so as to simplify the creation of LINQ expressions at compile time: <br><br><pre> <code class="cmake hljs">Expr ::= Term (<span class="hljs-string"><span class="hljs-string">"+"</span></span>|<span class="hljs-string"><span class="hljs-string">"-"</span></span> Term)* Term ::= InnerTerm (<span class="hljs-string"><span class="hljs-string">"*"</span></span>|<span class="hljs-string"><span class="hljs-string">"/"</span></span>|<span class="hljs-string"><span class="hljs-string">"%"</span></span> InnerTerm)* InnerTerm ::= Operand (<span class="hljs-string"><span class="hljs-string">"^"</span></span> Operand) Operand ::= NegativeFactor | Factor NegativeFactor ::= <span class="hljs-string"><span class="hljs-string">"-"</span></span> Factor Factor ::= <span class="hljs-string"><span class="hljs-string">"("</span></span> Expr <span class="hljs-string"><span class="hljs-string">")"</span></span> | Constant Constant ::= Decimal</code> </pre><br>  Usually Sprache parsers are declared as static lambda functions.  This does not suit us, because they cannot be redefined in descendant classes, so the rules will be declared as virtual properties. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// : public static readonly Parser&lt;Expression&gt; ExpressionInParentheses = from lparen in Parse.Char('(') from expr in Expr from rparen in Parse.Char(')') select expr; // : protected virtual Parser&lt;Expression&gt; ExpressionInParentheses { get { return from lparen in Parse.Char('(') from expr in Expr from rparen in Parse.Char(')') select expr; } }</span></span></code> </pre><br>  After this alteration, the grammar slightly increases in size, but now any rules can be redefined in descendant classes.  In order to write unit tests for each rule, you will have to declare parser properties as public or protected internal. <br><br>  I will not give the full text of the grammar of a simple calculator, it can be viewed on the <a href="">githaba</a> .  In its content, he practically repeats the standard example of LinqyCalculator from the delivery of Sprache. <br><br><h4>  Scientific Calculator </h4><br>  Since the scientific calculator can at least be the same as the usual, its class is inherited from the grammar of a simple calculator.  To support binary and hexadecimal numbers, add new rules: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Binary { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Parse.IgnoreCase(<span class="hljs-string"><span class="hljs-string">"0b"</span></span>).Then(x =&gt; Parse.Chars(<span class="hljs-string"><span class="hljs-string">"01"</span></span>).AtLeastOnce().Text()).Token(); } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Hexadecimal { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Parse.IgnoreCase(<span class="hljs-string"><span class="hljs-string">"0x"</span></span>).Then(x =&gt; Parse.Chars(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEFabcdef"</span></span>).AtLeastOnce().Text()).Token(); } }</code> </pre><br>  Defining new rules is not enough, because the basic grammar does not know at what point they can be applied.  Since binary and hexadecimal numbers are a kind of constant, we add them to the Constant parser. <br><br>  Note: the Binary and Hexadecimal parsers return a string, and the Constant parser returns a LINQ expression.  You will need helper methods that convert strings to Expression.Constant (double).  Constant parser ready with support for decimal, binary and hexadecimal numbers will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> Parser&lt;Expression&gt; Constant { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hexadecimal.Select(x =&gt; Expression.Constant((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)ConvertHexadecimal(x))) .Or(Binary.Select(b =&gt; Expression.Constant((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)ConvertBinary(b)))) .Or(<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Constant); } }</code> </pre><br>  To support functions in expressions, two more rules are needed: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Identifier { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Parse.Letter.AtLeastOnce().Text().Token(); } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;Expression&gt; FunctionCall { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Identifier <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lparen <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">'('</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> expr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Expr.DelimitedBy(Parse.Char(<span class="hljs-string"><span class="hljs-string">','</span></span>).Token()) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rparen <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">')'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, expr.ToArray(</span></span></span><span class="hljs-function">))</span></span>; } }</code> </pre><br>  The CallFunction helper method simply generates a LINQ expression to call a static one from the System.Math class with the specified name: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Expression[] parameters</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInfo = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Math).GetMethod(name, parameters.Select(e =&gt; e.Type).ToArray()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParseException(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Function '{0}({1})' does not exist."</span></span>, name, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">","</span></span>, parameters.Select(e =&gt; e.Type.Name)))); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Call(methodInfo, parameters); }</code> </pre><br>  Since the basic grammar knows nothing about the new rules, you need to include them in some rule of the basic grammar.  Here, finding the right rule is not as easy as in the case of constants.  The appropriate rule will be determined by the priority of the function call operation. <br><br>  It is easy to see that this priority should be the highest - the same as the operation of brackets.  For example, when calculating the expression Sin (2) ^ Cos (3), you first need to calculate the values ‚Äã‚Äãof the functions, and then perform the exponentiation operation. <br><br>  In basic grammar, parenthesis appears in the Factor rule, so we need to override it: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> Parser&lt;Expression&gt; Factor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Factor.XOr(FunctionCall); } }</code> </pre><br><h4>  Add custom functions </h4><br>  For the most sophisticated version of the calculator, let's create a new class based on a scientific calculator.  Adding custom functions obviously will not require the introduction of new grammar rules, because the syntax of expressions remains the same.  Only the method that calls functions is changed.  Pseudocode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Expression[] parameters</span></span></span><span class="hljs-function">)</span></span> {       name, {         parameters; } <span class="hljs-comment"><span class="hljs-comment">//       System.Math return base.CallFunction(name, parameters); }</span></span></code> </pre><br>  Any custom function for a calculator can be represented as a delegate Func &lt;double [], double&gt;.  Named functions are conveniently stored in the dictionary: Dictionary &lt;string, Func &lt;double [], double &gt;&gt;.  To allow overloading of functions, it‚Äôs enough to attach the number of parameters to the name: <br><br><pre> <code class="cs hljs"><span class="hljs-string"><span class="hljs-string">"Min:2"</span></span> ‚Äî  Min    <span class="hljs-string"><span class="hljs-string">"Min:5"</span></span> ‚Äî  Min   </code> </pre><br>  As a result, the above pseudocode will turn into something like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Expression[] parameters</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     var mangledName = name + ":" + parameters.Length; if (CustomFuctions.ContainsKey(mangledName)) { return Expression.Call(...); //      } //   System.Math return base.CallFunction(name, parameters); }</span></span></code> </pre><br>  A certain complexity is the expression Expression.Call, which must be generated to call a user-defined function.  The point is that Expression.Call can call only existing methods, which obviously do not include user functions.  To get out in this situation, it is enough to define the following method in the calculator class: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallCustomFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mangledName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] parameters</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomFuctions[mangledName](parameters); }</code> </pre><br>  This method will call the expression Expression.Call, which we will form when compiling.  We will only need to convert the list of parameters into a single array parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Expression[] parameters</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     var mangledName = name + ":" + parameters.Length; if (CustomFuctions.ContainsKey(mangledName)) { //   var newParameters = new List&lt;Expression&gt;(); newParameters.Add(Expression.Constant(mangledName)); newParameters.Add(Expression.NewArrayInit(typeof(double), parameters)); //  this.CallCustomFunction(mangledName, double[]); var callCustomFunction = new Func&lt;string, double[], double&gt;(CallCustomFunction).Method; return Expression.Call(Expression.Constant(this), callCustomFunction, newParameters.ToArray()); } //   System.Math return base.CallFunction(name, parameters); }</span></span></code> </pre><br><h4>  Adding Parameters </h4><br>  To support the parameters, a grammar refinement will be required: a new rule and an update of the old rules.  A parameter is simply an identifier that can occur in the same place as a constant or function call: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;Expression&gt; Parameter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Identifier; } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> Parser&lt;Expression&gt; Factor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Parameter.Or(<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Factor); } }</code> </pre><br>  Here we meet a conflict for the first time.  The fact is that in the Factor rule there are now two alternatives that both begin with an identifier: a parameter and a function.  If the parser meets an identifier, it cannot determine the parameter in front of it or the function until it looks ahead.  If the identifier is followed by the bracket "(", then this is a function, otherwise - a parameter. <br><br>  As far as I know, Sprache does not help in the search for such conflicts.  Find them only by gazing.  You add rules, write unit tests for them, and at one point you discover that some tests do not pass, reporting parsing errors.  The case of parameters and functions is quite trivial, but more often the search for and the elimination of conflicts is a serious task that takes a lot of time and effort. <br><br>  To resolve the conflict between parameters and functions, we can define a parameter as "Identifier, not followed by a bracket".  Such a rule will not lead to conflict, since it eliminates ambiguity.  It looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Parser&lt;Expression&gt; Parameter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-comment"><span class="hljs-comment">// identifier not followed by a '(' is a parameter reference return from id in Identifier from n in Parse.Not(Parse.Char('(')) select GetParameterExpression(id); } }</span></span></code> </pre><br>  The Parse.Not parser is similar to negative lookahead in regular expressions: it does not change the pointer of the current character and works successfully if the parser passed to it, in this case Parse.Char ('('), fails. <br><br>  As in the case of calling functions, we need to somehow generate an expression that returns the value of the parameter.  It is time to decide how parameters will be passed to the calculator.  At first glance, we can deal with the parameters in the same way as with user-defined functions: register them in a special Dictionary &lt;string, double&gt;, which is stored in the calculator: <br><br><pre> <code class="cs hljs">calc.Parameters[<span class="hljs-string"><span class="hljs-string">"MyPI"</span></span>] = <span class="hljs-number"><span class="hljs-number">355</span></span>/<span class="hljs-number"><span class="hljs-number">113</span></span>d; calc.Parameters[<span class="hljs-string"><span class="hljs-string">"MyE"</span></span>] = <span class="hljs-number"><span class="hljs-number">2.718</span></span>d;</code> </pre><br>  Compilation of a call to such a parameter will be arranged in the same way as calling a user-defined function.  The calculator will generate a call to the GetParameterExpression method, passing it the name of the parameter.  If the parameter is not defined, you can try to find it among the constants of the System.Math class: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetParameterExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (Parameters.ContainsKey(id)) { //  this.GetParameterValue(id) var getParameterValue = new Func&lt;string, double&gt;(GetParameterValue).Method; return Expression.Call(Expression.Constant(this), getParameterValue, Expression.Constant(id)) as Expression; } //         System.Math var systemMathConstants = typeof(System.Math).GetFields(BindingFlags.Public | BindingFlags.Static); var constant = systemMathConstants.FirstOrDefault(c =&gt; c.Name == id); if (constant == null) { throw new ParseException(string.Format("Parameter or constant '{0}' does not exist.", id)); } //    System.Math return Expression.Constant(constant.GetValue(null)); }</span></span></code> </pre><br>  Trying to use such a calculator, we immediately find the inconvenience of such a storage of parameters.  Expressions calculator can compile a lot, and he has one parameter storage.  All expressions will use the same parameter pool bound to the calculator instance. <br><br><pre> <code class="cs hljs">calc.Parameters[<span class="hljs-string"><span class="hljs-string">"P"</span></span>] = <span class="hljs-number"><span class="hljs-number">3.14</span></span>d; calc.Parameters[<span class="hljs-string"><span class="hljs-string">"R"</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func1 = calc.ParseExpression(<span class="hljs-string"><span class="hljs-string">"2*P*R"</span></span>).Compile(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result1 = func1(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func2 = calc.ParseExpression(<span class="hljs-string"><span class="hljs-string">"R+P"</span></span>).Compile(); calc.Parameters[<span class="hljs-string"><span class="hljs-string">"P"</span></span>] = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result2 = func2();</code> </pre><br>  The common pool of parameters leads to the fact that expressions cannot be used in a multi-threaded program.  One stream will set one parameter value, the other stream will set another, and the result of the calculations will become undefined.  Obviously, for the transfer of parameters you need to come up with a mechanism more reliable. <br><br><h4>  Another way to pass parameters </h4><br>  It will be logical to bind the list of parameters not to the calculator, but to the expression.  To do this, you need to change the type of the calculator result expression: instead of Expression &lt;Func&gt;, you will need to generate Expression &lt;Func &lt;Dictionary &lt;string, double&gt;, double &gt;&gt;.  Here is what it might look like: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> function = calc.ParseFunction(<span class="hljs-string"><span class="hljs-string">"y/x"</span></span>).Compile(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;{ { <span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = function(parameters);</code> </pre><br>  For such a scheme would require not such a big alteration.  Instead of calling this.GetParameterValue, you only need to generate a call to the parameters dictionary: parameters [name].  The indexer in C # is compiled into a call to the get_Item method, so access to the parameter will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getItemMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;).GetMethod(<span class="hljs-string"><span class="hljs-string">"get_Item"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Call(ParameterExpression, getItemMethod, Expression.Constant(name));</code> </pre><br>  In order not to complicate the expression, we will not check whether there is a parameter with the specified name in the dictionary.  If there is no parameter, the Dictionary class itself will complain about it.  Here is the complete method for compiling parameters: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetParameterExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// try to find a constant in System.Math var systemMathConstants = typeof(System.Math).GetFields(BindingFlags.Public | BindingFlags.Static); var constant = systemMathConstants.FirstOrDefault(c =&gt; c.Name == name); if (constant != null) { // return System.Math constant value return Expression.Constant(constant.GetValue(null)); } // return parameter value: Parameters[name] var getItemMethod = typeof(ParameterList).GetMethod("get_Item"); return Expression.Call(ParameterExpression, getItemMethod, Expression.Constant(name)); }</span></span></code> </pre><br><h4>  Syntactic sugar for parameters </h4><br>  At the beginning of the article there is an example of using a calculator to calculate an expression with parameters: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = calc.ParseExpression(<span class="hljs-string"><span class="hljs-string">"Sin(y/x)"</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, y =&gt; System.Math.PI);</code> </pre><br>  Such syntax is read much better than creating and filling in Dictionary &lt;string, double&gt;.  It is convenient to use it when the list of valid parameters of the expression is fixed.  Although this has nothing to do with expression parsing itself, I‚Äôll explain how this method works: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression&lt;Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt; ParseExpression(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Expression&lt;Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;[] parameters) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parameters) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramName = p.Parameters.Single().Name; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramValue = p.Compile()(<span class="hljs-number"><span class="hljs-number">0</span></span>); paramList[paramName] = paramValue; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseExpression(text, paramList); }</code> </pre><br><h4>  Two words about unit tests </h4><br>  When developing parsers on Sprache, it is very convenient to write unit tests in parallel with the development of grammars.  Added a new parser - immediately wrote a set of tests to it (TDD supporters will do it in the reverse order).  Since the Sprache library does not analyze the grammar in any way, it cannot report problems like conflicts or left recursion (although it can track simple left recursion at the execution stage), and the unit test suite becomes the only support. <br><br>  Inheriting grammars adds additional responsibility to unit tests: for each class, you need to make sure that all the inherited rules continue to work and interact normally with the rules redefined in descendant classes.  For this, you can use the ForEachCalculator helper method, which runs the tests on all versions of the calculator: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEachCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action&lt;SimpleCalculator&gt; fact</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleCalculator(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScientificCalculator(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XtensibleCalculator() }) { fact(calc); } } [Fact] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExprCombinesTermsWithAddSubOperators</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ForEachCalculator(calc =&gt; { Assert.Equal(<span class="hljs-number"><span class="hljs-number">4</span></span>d, calc.Expr.Parse(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>).Execute()); Assert.Equal(<span class="hljs-number"><span class="hljs-number">2</span></span>d, calc.Expr.Parse(<span class="hljs-string"><span class="hljs-string">"2*3-4*1"</span></span>).Execute()); Assert.Throws&lt;ParseException&gt;(() =&gt; calc.Expr.Parse(<span class="hljs-string"><span class="hljs-string">"+"</span></span>)); }); }</code> </pre><br>  However, a more elegant solution, which is used in the unit tests of the calculator, is the inheritance of tests.  In the base class of tests, the virtual method CreateCalculator is defined, which creates a calculator for testing.  The base class of tests creates and tests the SimpleCalculator, its descendant is created by the ScientificCalculator tests, inheriting all the tests of the base class, but executing them for the descendant calculator, and so on. <br><br><h4>  Summary </h4><br>  So, we received three versions of the calculator, differing in a set of possibilities and syntax of input expressions.  Due to inheritance, most of the basic grammar rules are reused in descendant grammars, which makes it possible to focus the development on differences from the basic version.  The full source code for the calculator project is available on <a href="">github</a> . <br><br>  Grammar inheritance is a powerful technique, which in many cases allows keeping the grammar complexity under control and speeding up parser development.  In the case of the Sprache library, grammar inheritance seems to be a good tool, additionally encouraging decomposition and step-by-step development in parallel with unit testing. </div><p>Source: <a href="https://habr.com/ru/post/228037/">https://habr.com/ru/post/228037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228023/index.html">Work with geolocations in highload mode</a></li>
<li><a href="../228025/index.html">Discov3ry: extruder nozzle to a conventional 3D printer for working with ... chocolate cream, silicone, polyurethane, clay</a></li>
<li><a href="../228031/index.html">Variadic templates. Tuples, unpacking and more</a></li>
<li><a href="../228033/index.html">Westone Company History</a></li>
<li><a href="../228035/index.html">Astro Tracker Field Tests</a></li>
<li><a href="../228039/index.html">What experiments Facebook puts on its users</a></li>
<li><a href="../228041/index.html">Storage Performance</a></li>
<li><a href="../228043/index.html">Mobile marketing: how to distinguish "live" traffic from "garbage"</a></li>
<li><a href="../228047/index.html">8 things that are not worth living in Silicon Valley</a></li>
<li><a href="../228049/index.html">Preemptive multitasking on Z80 assembler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>