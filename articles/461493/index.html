<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Django 3.0 will be asynchronous</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrew Godwin published DEP 0009: Async-capable Django on May 9, and was approved by Django technical council on July 21, so you can hope that by the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Django 3.0 will be asynchronous</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Andrew Godwin published <a href="">DEP 0009: Async-capable Django</a> on May 9, and was approved <a href="https://docs.djangoproject.com/en/dev/internals/organization/">by</a> Django <a href="https://docs.djangoproject.com/en/dev/internals/organization/">technical council</a> on July 21, so you can hope that by the time Django 3.0 is released, they will be able to do something interesting.</em>  <em>It was already mentioned <a href="https://habr.com/en/post/454440/">somewhere in the comments of Habr</a> , but I decided to convey this news to a wider audience by translating it - primarily for those who, like me, do not particularly follow the news of Django.</em> </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1153030952915890177"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Asynchronous Python has been developed for many years, and in the Django ecosystem, we experimented with it in <a href="https://channels.readthedocs.io/en/stable/">Channels</a> with the primary focus on web socket support. </p><br><p>  As the ecosystem developed, it became apparent that while there was no urgent need to extend Django to support non-HTTP protocols such as web sockets, asynchronous support would provide many benefits for the traditional Django model-view-template framework. </p><br><p>  The benefits are described in the Motivation section below, but the general conclusion I came to is that we get so much from asynchronous Django that it is worth the hard work it takes.  I also believe that it is very important to make changes in an iterative, community-supported way that will not depend on one or two old contributors that might burn out. <a name="habracut"></a></p><br><p>  Although the document is referred to as the ‚ÄúFeature‚Äù DEP, all of this means that it is also partly a Process DEP.  The scope of the changes proposed below is incredibly large, and launching them as a traditional single-feature process is likely to fail. </p><br><p>  Of course, throughout this document, it is important to remember the Django philosophy, which is to keep everything safe and backward compatible.  The plan is not to remove synchronous Django - the plan is to keep it in its current form, but add asynchrony as an option for those who believe that they need additional performance or flexibility. </p><br><p>  Is this a gigantic job?  Of course.  But I feel that this allows us to significantly change the future of Django - we have the opportunity to take a proven framework, and an incredible community, and introduce a completely new set of options that were previously impossible. </p><br><p>  The web has changed, and Django should change with it, but in accordance with our ideals, be affordable, secure by default and flexible as projects grow and their needs change.  In the world of cloud data warehousing, service-oriented architecture and backend as the foundation of complex business logic, the ability to do things competitively is key. </p><br><p>  This DEP outlines a plan that I think will lead us there.  This is a vision that I really believe in and with which I will work to help do everything possible.  At the same time, careful analysis and skepticism are justified;  I ask for your constructive criticism, as well as your trust.  Django relies on a community of people and the applications they create, and if we need to determine the path to the future, we must do it together. </p><br><h2 id="kratkoe-opisanie">  Short description </h2><br><p>  We are going to add support for asynchronous representations, middleware, ORM and other important elements to Django. </p><br><p>  This will be done by running synchronous code in threads, gradually replacing it with asynchronous code.  Synchronous APIs will continue to exist and be fully supported, and over time will turn into synchronous wrappers for initially asynchronous code. </p><br><p>  ASGI mode will launch Django as a native asynchronous application.  WSGI mode will trigger a separate event loop each time Django is accessed, so that the asynchronous layer is compatible with the synchronous server. </p><br><p>  Multithreading around ORM is complex and requires a new concept of connection contexts and sticky threads to run synchronous ORM code. </p><br><p>  Many parts of Django will continue to work in sync, and our priority will be to support users writing views in both styles, letting them choose the best style for the presentation they are working on. </p><br><p>  Some functions, such as templates and caching, will need their own separate DEPs and studies on how to make them completely asynchronous.  This DEP mainly focuses on HTTP-middleware-view flow and ORM. </p><br><p>  There will be full backward compatibility.  The standard Django 2.2 project should run in asynchronous Django (be it 3.0 or 3.1) without change. </p><br><p>  This proposal is focused on the implementation of small, iterative parts with their gradual placement in the master branch to avoid problems with the long-lived fork and allow us to change course as problems are discovered. </p><br><p>  This is a good opportunity to attract new members.  We must finance the project so that this happens faster.  Funding should be on a scale that we are not used to. </p><br><h2 id="specifikaciya">  Specification </h2><br><p>  The overall goal is to make every single part of Django, which can be blocking - that is, not just CPU-bound computations - become asynchronous (run in an asynchronous event loop without locks). </p><br><p>  This includes the following features: </p><br><ul><li>  Intermediate layers (Middleware) </li><li>  Views </li><li>  ORM </li><li>  Patterns </li><li>  Testing </li><li>  Caching </li><li>  Form validation </li><li>  Email </li></ul><br><p>  However, this does not include such things as internationalization, which will not bring any performance gain, since this is a CPU-bound task that also runs quickly, or migrations that are single-threaded when launched through the management command. </p><br><p>  Each individual function that becomes asynchronous inside will also provide a synchronous interface that is backward compatible with the current API (in 2.2) for the foreseeable future - we could change it over time to make them better, but synchronous APIs will not go anywhere. </p><br><p>  An overview of how this is technically achieved is given below, and then specific implementation details for specific areas are given.  It is not exhaustive for all the functions of Django, but if we achieve this initial goal, we will include almost all use cases. </p><br><p>  The final part of this section, ‚ÄúProcedure,‚Äù also discusses how these changes can be implemented gradually and by several groups of developers in parallel, which is important for completing these changes with the help of volunteers in a reasonable amount of time. </p><br><h3 id="tehnicheskiy-obzor">  Technical review </h3><br><p>  The principle that allows us to maintain synchronous and asynchronous implementations in parallel is the ability to run one style inside another. </p><br><p>  Each function will go through three stages of implementation: </p><br><ul><li>  Only synchronous (we are here) </li><li>  Synchronous implementation with asynchronous wrapper </li><li>  Asynchronous implementation with synchronous wrapper </li></ul><br><h4 id="asinhronnaya-obyortka">  Asynchronous wrapper </h4><br><p>  First, the existing synchronous code will be wrapped in an asynchronous interface, which runs the synchronous code in the thread pool.  This will allow us to design and provide an asynchronous interface relatively quickly, without having to rewrite all available code for asynchrony. </p><br><p> The toolkit for this is already available in <a href="https://github.com/django/asgiref">asgiref</a> as a function <code>sync_to_async</code> , which supports things like exception handling or threadlocals (more on this below). </p><br><p>  Running code in threads will most likely not lead to increased productivity - the overhead that comes up will probably slow it down a bit when you just run normal linear code - but this will allow developers to start running something competitively and get used to new features. </p><br><p>  In addition, there are several parts of Django that are sensitive to starting in <em>the same</em> thread upon repeated access;  for example, processing transactions in a database.  If we wrapped some code in <code>atomic()</code> that would then access the ORM through random threads taken from the pool, the transaction would have no effect, since it is bound to a connection inside the thread in which the transaction was started. </p><br><p>  In such situations, a ‚Äústicky thread‚Äù is required in which the asynchronous context calls all the synchronous code in the same thread sequentially instead of pushing it into the thread pool, preserving the correct behavior of ORM and other thread-sensitive parts.  All parts of Django that we suspect need it, including the entire ORM, will use the <code>sync_to_async</code> version, which takes this into account, so everything is safe by default.  Users will be able to selectively disable this for competitive query execution - for more details see "ORM" below. </p><br><h4 id="asinhronnaya-realizaciya">  Asynchronous implementation </h4><br><p>  The next step is to rewrite the implementation of the function to asynchronous code and then present the synchronous interface through a wrapper that executes asynchronous code in a one-time event loop.  This is already available in <a href="https://github.com/django/asgiref">asgiref</a> as a function of <code>async_to_sync</code> . </p><br><p>  It is not necessary to rewrite all functions at once to quickly jump to the third stage.  We can focus our efforts on the parts that we can do well and that have the support of third-party libraries, while helping the rest of the Python ecosystem in things that require more work to implement native asynchrony;  This is discussed below. </p><br><p>  This general overview works with almost all Django functions that should become asynchronous, with the exception of those places for which Python does not provide asynchronous function equivalents that we already use.  The result will be either a change in how Django presents its API in asynchronous mode, or working with Python core developers to help develop Python asynchronous features. </p><br><h3 id="threadlocals">  Threadlocals </h3><br><p>  One of the basic details of the Django implementation that needs to be mentioned separately from most of the functions described below is threadlocals.  As the name implies, threadlocals work within a thread, and although Django keeps the <code>HttpRequest</code> object outside of threadlocal, we put several other things in it - for example, database connections or the current language. </p><br><p>  Using threadlocals can be divided into two options: </p><br><ul><li>  ‚ÄúContext locals‚Äù, where a value is needed within some stack-based context, such as a request.  This is necessary to set the current language. </li><li>  ‚ÄúTrue threadlocals‚Äù, where the protected code is actually unsafe for calling from another thread.  This is for connecting to the database. </li></ul><br><p>  At first glance, it might seem that ‚Äúcontext locals‚Äù can be resolved using the new <a href="https://docs.python.org/3/library/contextvars.html">contextvars</a> module in Python, but Django 3.0 will still have to support Python 3.6, while this module appeared in 3.7.  In addition, <code>contextvars</code> specifically designed to get rid of context when switching, for example, to a new stream, while we need to save these values ‚Äã‚Äãto allow the functions <code>sync_to_async</code> and <code>async_to_sync</code> to work normally as wrappers.  When Django will only support 3.7 and newer, we might consider using <code>contextvars</code> , but that would require a lot of work in Django. </p><br><p>  This has already been resolved with <a href="https://github.com/django/asgiref">asgiref</a> <code>Local</code> , which is compatible with coroutines and threads.  Now it does not use <code>contextvars</code> , but we can switch it to work with backport for 3.6 after some testing. </p><br><p>  True threadlocals, on the other hand, can simply continue to work in the current thread.  However, we must be more careful to prevent such objects from leaking into another stream;  when a view is no longer running in the same thread, but spawns a thread for each ORM call (during the ‚Äúsynchronous implementation, asynchronous wrapper‚Äù phase), some things that were possible in synchronous mode will not be possible in asynchronous. </p><br><p>  This will require special attention and the prohibition of some previously possible operations in asynchronous mode;  The cases we know of are described below in specific sections. </p><br><h3 id="odnovremennaya-podderzhka-sinhronnogo-i-asinhronnogo-interfeysov">  Simultaneous support for synchronous and asynchronous interfaces </h3><br><p>  One of the big problems that we will encounter when trying to port Django is that Python does not allow you to make synchronous and asynchronous versions of a function with the same name. </p><br><p>  This means that you can‚Äôt just take and make an API that works something like this: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   value = cache.get("foo") #   value = await cache.get("bar")</span></span></code> </pre> <br><p>  This is an unfortunate limitation of the way Python is implemented asynchronously, and there is no obvious workaround.  When something is called, you do not know whether you will be await or not, so there is no way to determine what needs to be returned. </p><br><p>  (Note: this is because Python implements asynchronous functions as ‚Äúa synchronous callable that returns a coroutine,‚Äù rather than something like ‚Äúcalling the <code>__acall__</code> method on an object.‚Äù Asynchronous context managers and iterators do not have this problem, because they have separate methods <code>__aiter__</code> and <code>__aenter__</code> .) </p><br><p>  With this in mind, we must place the namespaces of synchronous and asynchronous implementations separately from each other so that they do not conflict.  We could do this with the named argument <code>sync=True</code> , but this leads to confusing bodies of functions / methods and does not allow the use of <code>async def</code> , and also allows you to accidentally forget to write this argument.  A random call to a synchronous method when you wanted to call it asynchronously is dangerous. </p><br><p>  The proposed solution for most places in the Django code base is to provide a suffix for names of asynchronous implementations of functions - for example, <code>cache.get_async</code> in addition to synchronous <code>cache.get</code> .  Although this is an ugly solution, it makes it very easy to detect errors when viewing code (you should use <code>await</code> with the <code>_async</code> method). </p><br><h3 id="predstavleniya-i-obrabotka-http">  Views and HTTP Handling </h3><br><p>  Views are probably the cornerstone of the usefulness of asynchrony, and we expect most users to choose between asynchronous and synchronous code. </p><br><p>  Django will support two kinds of views: </p><br><ul><li>  Synchronous representations, defined, as now, by a synchronous function or class with synchronous <code>__call__</code> </li><li>  Asynchronous representations defined by an asynchronous function (returning a coroutine) or a class with asynchronous <code>__call__</code> . </li></ul><br><p>  They will be handled by <code>BaseHandler</code> , which will check the view received from the URL resolver and call it accordingly.  The base handler should be the first part of Django to become asynchronous, and we will need to modify the WSGI handler to call it in its own event loop using <code>async_to_sync</code> . </p><br><p>  Intermediate layers (middleware) or settings like <code>ATOMIC_REQUESTS</code> , which wrap the views in non-asynchronously safe code (for example, the <code>atomic()</code> block), will continue to work, but their speed will be affected (for example, the prohibition of parallel ORM calls inside the view with <code>atomic()</code> ) </p><br><p>  The existing <code>StreamingHttpResponse</code> class will be modified to be able to accept either a synchronous or asynchronous iterator, and then its internal implementation will always be asynchronous.  Similarly for <code>FileResponse</code> .  Since this is a potential backward incompatibility point for third-party code that directly accesses Response objects, we still need to provide a synchronous <code>__iter__</code> for the transition period. </p><br><p>  WSGI will continue to be supported by Django indefinitely, but the WSGI handler will move on to running asynchronous middleware and views in its own one-time event loop.  This is likely to lead to a slight decrease in performance, but in the initial experiments it did not have too much impact. </p><br><p>  All asynchronous HTTP functions will work inside WSGI, including long-polling and slow responses, but they will be as inefficient as they are now, taking up a thread / process for each connection.  ASGI servers will be the only ones that can efficiently support many concurrent requests, as well as handle non-HTTP protocols, such as WebSocket, for use by extensions like <a href="https://channels.readthedocs.io/en/stable/">Channels</a> . </p><br><h3 id="promezhutochnye-sloi">  Intermediate layers </h3><br><p>  While the previous section discussed mainly the request / response path, middleware needs a separate section because of the complexity inherent in their current design. </p><br><p>  Django middlewares are now arranged in the form of a stack in which each middleware gets <code>get_response</code> to run the next in order middleware (or the view for the lowest middleware on the stack).  However, we need to maintain a mixture of synchronous and asynchronous middleware for backward compatibility, and these two types will not be able to access each other natively. </p><br><p>  Thus, to ensure that middleware works, we will instead have to initialize each middleware with the get_response placeholder, which instead returns control back to the handler and handles both the transfer of data between the middleware and the view, as well as an exception throw.  In a way, it will eventually look like middleware of the Django 1.0 era from an internal point of view, although, of course, the user API will remain the same. </p><br><p>  We can declare synchronous middleware obsolete, but I recommend not doing this any time soon.  If and when we get to the end of the cycle of their obsolescence, we could then return the middleware implementation to a purely recursive stack model, as it is now. </p><br><h3 id="orm">  ORM </h3><br><p>  ORM is the largest part of Django in terms of code size and the most difficult to convert to asynchronous. </p><br><p>  This is largely due to the fact that the underlying database drivers are synchronous by design, and progress will be slow towards a set of mature, standardized, asynchronous database drivers.  Instead, we must design a future in which database drivers will initially be synchronous, and lay the foundation for contributors who will further develop asynchronous drivers iteratively. </p><br><p>  Problems with ORM fall into two main categories - threads and implicit blocking. </p><br><h4 id="potoki">  Streams </h4><br><p>  The main problem with ORM is that Django is designed around a single global <code>connections</code> object, which magically gives you the right connection for your current thread. </p><br><p>  In an asynchronous world - where all coroutines work in the same thread - this is not only annoying, but simply dangerous.  Without any additional security, a user accessing an ORM as usual risks breaking connection objects by accessing it from several different places. </p><br><p>  Fortunately, connection objects are at least portable between threads, although they cannot be called from two threads at the same time.  Django already cares about thread-safety for database drivers in the ORM code, and so we have a place to change its behavior to work properly. </p><br><p>  We will modify the <code>connections</code> object so that it understands both coroutines and threads - reusing some code from <code>asgiref.local</code> , but with the addition of additional logic.  Connections will be shared in asynchronous and synchronous code that calls each other - with context transfer via <code>sync_to_async</code> and <code>async_to_sync</code> - and synchronous code will be forced to execute sequentially in one sticky thread, so this will not work at the same time breaking thread-safety. </p><br><p>  This implies that we need a solution like a context manager to open and close a database connection, like <code>atomic()</code> .  This will allow us to provide consistent calls and sticky threads in this context and allow users to create multiple contexts if they want to open multiple connections.  It also gives us a potential way to get rid of magical global <code>connections</code> if we want to develop this further. </p><br><p>  At the moment, Django does not have connection lifecycle management that is independent of the signals from the handler class, and therefore we will use them to create and clear these ‚Äúconnection contexts‚Äù.  The documentation will also be updated to make it clearer how to properly handle connections outside the request / response cycle;  even in the current code, many users do not know that any long-running management team must periodically call <code>close_old_connections</code> to work correctly. </p><br><p>  Backward compatibility means that we must allow users access to <code>connections</code> from any random code at any time, but we will only allow this for synchronous code;  we will ensure that the code is wrapped in a ‚Äúconnection context‚Äù, if it is asynchronous, from day one. </p><br><p>  It might seem like it would be nice to add <code>transaction.atomic()</code> in addition to <code>transaction.atomic()</code> and require the user to run all the code inside one of them, but this can lead to confusion about what happens if you attach one of them is inside the other. </p><br><p>  Instead, I suggest creating a new <code>db.new_connections()</code> context manager that enables this behavior, and make it create a new connection whenever it is called, and allow arbitrary <code>atomic()</code> nesting inside it. </p><br><p>  Each time you <code>new_connections()</code> block, Django sets up a new context with new database connections.  All transactions that were performed outside the block continue;  any ORM calls inside the block work with a new connection to the database and will see the database from this point of view.  If transaction isolation is enabled in the database, as is usually done by default, this means that new connections within the block may not see the changes made by any uncommitted transactions outside it. </p><br><p>  In addition, the connections inside this <code>new_connections</code> block can themselves use <code>atomic()</code> to trigger additional transactions on these new connections.  Any nesting of these two context managers is allowed, but each time <code>new_connections</code> used, previously opened transactions are ‚Äúsuspended‚Äù and do not affect ORM calls until a new <code>new_connections</code> block is <code>new_connections</code> . </p><br><p>  An example of how this API might look: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_authors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pattern)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Create a new context to call concurrently async with db.new_connections(): return [ author.name async for author in Authors.objects.filter(name__icontains=pattern) ] async def get_books(pattern): # Create a new context to call concurrently async with db.new_connections(): return [ book.title async for book in Book.objects.filter(name__icontains=pattern) ] async def my_view(request): # Query authors and books concurrently task_authors = asyncio.create_task(get_authors("an")) task_books = asyncio.create_task(get_books("di")) return render( request, "template.html", { "books": await task_books, "authors": await task_authors, }, )</span></span></code> </pre> <br><p>  This is somewhat verbose, but the goal is also to add high-level shortcuts to enable this behavior (and also cover the transition from <code>asyncio.ensure_future</code> in Python 3.6 to <code>asyncio.create_task</code> in 3.7). </p><br><p>  With the help of this context manager and ‚Äústicky threads‚Äù within the same connection context, we guarantee that all code will be as secure as we can do it by default;  there is a possibility that the user can use the connection in one thread for two different parts of the request using <code>yield</code> , but this is <code>yield</code> possible now. </p><br><h4 id="neyavnye-blokirovki">  Implicit locks </h4><br><p>  Another problem with the current ORM design is that blocking (network-related) operations, in particular reading related fields, are encountered in model instances. </p><br><p>  If you take an instance of the model and then access <code>model_instance.related_field</code> , Django will transparently load the contents of the associated model and return it to you.  However, this is not possible in asynchronous code - blocking code should not be executed in the main thread, and there is no asynchronous access to attributes. </p><br><p>  Fortunately, Django already has a way out of this - <code>select_related</code> , which loads the related fields in advance, and <code>prefetch_related</code> for many-to-many relationships.  If you use ORM asynchronously, we will prohibit any implicitly blocking operations, such as background access to attributes, and instead return an error telling you to pre-extract the field. </p><br><p>  This has the added benefit of preventing slow code that executes N requests in a <code>for</code> loop, which is a common mistake of many new Django programmers.  This raises the entry barrier, but remember that asynchronous Django will be optional - users will still be able to write synchronous code if they wish (and this will be encouraged in the tutorial, since synchronous code is much more difficult to make mistakes). </p><br><p>  <code>QuerySet</code> , fortunately, can easily implement asynchronous generators and transparently support both synchronization and asynchrony: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> User.objects.all(): data.append(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> extract_important_info(user)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> render(<span class="hljs-string"><span class="hljs-string">"template.html"</span></span>, data)</code> </pre> <br><h4 id="drugoe">  Other </h4><br><p>  Parts of ORM associated with schema changes will not be asynchronous;  they should be called only from management teams.  Some projects already call them in submissions, but this is not a good idea anyway. </p><br><h3 id="shablony">  Patterns </h3><br><p>  The templates are now completely synchronous, and the plan is to leave them that way in the first step.     ,      ,     DEP. </p><br><p>  ,  Jinja2   ,              . </p><br><p>  ,         Django     ,       .  Jinja2       ,    ,        ,    . </p><br><p>       ,     <code>render_async</code> ,   <code>render</code> ;      ,   ,        . </p><br><h3 id="keshirovanie">  </h3><br><p>    Django      ‚Äî     <code>_async</code> -  (, <code>get_async</code> , <code>set_async</code> ). </p><br><p>   ,       API  <code>sync_to_async</code> ,    <code>BaseCache</code> . </p><br><p> ,     thread-safety   API ,   Django,        ,       .    ,     ORM, ,      . </p><br><h3 id="formy">  Forms </h3><br><p>         ,        ,    ,     <code>ModelForm</code>  ORM     . </p><br><p>  ,   -   <code>clean</code>  <code>save</code> ,  ,   . ,      ,  ,                         DEP. </p><br><h3 id="email">  Email </h3><br><p>         Django,      .    <code>send_mail_async</code>  <code>send_mail</code> ,   <code>async</code> -        (, <code>mail_admins</code> ). </p><br><p>         Django  ,    -  SMTP,     .  , ,      ,      ,   . </p><br><h3 id="testirovanie">  Testing </h3><br><p>     ,      Django  . </p><br><p>     ASGI-     <code>asgiref.testing.ApplicationCommunicator</code> .             assert'  . </p><br><p>    Django        ,    ,      .  ,      ‚Äî     ,    ,        HTTP    event loop,    WSGI. </p><br><p>                .  ,      ,      . </p><br><p>   ,     ,      .       <code>async def</code>    <code>@async_to_sync</code> ,       , ,    Django test runner. </p><br><p>        asyncio (   loop'  ,    )   , , ,   <code>DEBUG=True</code> .          ‚Äî   ,       ,       . </p><br><h3 id="websockets"> WebSockets </h3><br><p>       Django;      ,   Channels   ,        ASGI,      . </p><br><p>    ,         Channels,        ,     ASGI. </p><br><h3 id="poryadok-deystviy">  Procedure </h3><br><p>      ,     ,   .       ,          . </p><br><p>   ,                .         ,       ‚Äî         . </p><br><p>  ,      ,              .    ,   ORM,       ,  ,          . </p><br><p>   : </p><br><ul><li><p>   (  3.0) </p><br><ul><li>  HTTP,     (    ) </li><li>  async       ORM </li><li>    </li></ul><br></li><li><p>   (  3.1) </p><br><ul><li> ORM (     ) </li><li>  (     ) </li><li>  (     ) </li></ul><br></li><li><p>    </p><br><ul><li> ORM (       ) </li><li>  (    ) </li><li>  Email </li><li>  Forms </li></ul><br></li></ul><br><p>          ;      ,    .     ,   ,       , ,            . </p><br><p>   ,      -   ;            ,     ,        .    ,      ,  Django,     Django  async-only . </p><br><p>    ,  ,    DEP  ,   , , email  .         DBAPI ‚Äî  ,        core Python , , PEP,         . </p><br><h2 id="motivaciya">  Motivation </h2><br><p>     ,  , ,    .   Django      ,   -       ,    -;             . </p><br><p>          ,      - .         ,   ‚Äî  ,       ,       . </p><br><p>          Python ‚Äî   . -  Python       ,     ,       . </p><br><p>  Python            <code>asyncio</code> ,       ,         .     ,     ,     ,  ,      Django-size   . </p><br><h3 id="chto-eto-dayot">    </h3><br><p>       Django,     ¬´¬ª;    ,    ,      ‚Äî ,      Django ‚Äî     . </p><br><p>     ,       .      ,    API     ,   Django      -   . </p><br><p>      ,      ,  Django     .             ,    Django ORM ,     ,    ,      -. </p><br><p>  ,   , ‚Äî             .    -   long-poll   server-sent events.  Django          ,    -      . </p><br><h3 id="sinhronnost-vsyo-eschyo-imeet-znachenie">      </h3><br><p>     <em></em>    Django;         .   ,  ,             ,          . </p><br><p> Django          ,    .    ;  Django-   ,         ,  ,     ,     ,     . </p><br><p>      ,       --  Django      . </p><br><h3 id="obratnaya-sovmestimost">  backward compatibility </h3><br><p>  ,    .      ¬´ Django¬ª,       ;     ,        ,          . </p><br><p>  ,      ,     ,        ,    API Django,      ,      ,    Python 3,        API,        Django  Python. </p><br><h3 id="pomosch-python">  Python </h3><br><p> Python     .           Python,  ,    ,     . </p><br><p>   , Django ‚Äî   - Python   ‚Äî   ,    Python,        Python   .      ,       ,    ,        . </p><br><h3 id="privlechenie-novyh-uchastnikov">    </h3><br><p>      ,   Django,              .   ,  Django   ,       . </p><br><p>                   ‚Äî  ,  ,    ,   ,        . </p><br><p>  ,      ‚Äî      ,   , ‚Äî               Django (     ,       Python  ). </p><br><h3 id="chto-takoe-django">   Django? </h3><br><p>      ,   Django.   ,        <a href="https://en.wikipedia.org/wiki/Lawrence_Journal-World">Lawrence Journal-World</a>    ‚Äî    ,  , SPA ‚Äî  , ,    .  , ,   ,     ,     . </p><br><p>    ,   Django   ,   - ,    ‚Äî        ‚Äî     . , ,        ; ,     Django    , . </p><br><p>   ,     Django     .     ,       .    ,         ,    ,    ‚Äî ,        ,   . </p><br><h2 id="obosnovanie">  Justification </h2><br><p>    Django       django-developers   <a href="https://groups.google.com/d/msg/django-developers/Kw7-xV6TrSM/CdWe8OKOBwAJ"> </a>    ,        ,  ,   ,   DEP. </p><br><p>      , ,   ,      : </p><br><ul><li> :       master-        Django    . </li><li>  :     Django    ,    ,    ,     ,      Django       . </li><li> :    ,    ,      Django,   ,  Django.     ,   ,   ,      ,  . </li></ul><br><p>    <a href="https://channels.readthedocs.io/en/stable/">Channels</a>          DEP ;        Django      ,  . </p><br><p>   ,   ,     .  DEP    ,   ,       ‚Äî      Django           . </p><br><p>                 .     Django, ,     ,    WSGI    ,    event loop     ,      .         10%   ‚Äî     ,      .     ,      . </p><br><p>     ,  ,      (-  ,   Python    ).    ,     Django      ;     ,   ,     ,   Django   master-    . </p><br><p>  ,           ( ORM,    ..),      ;                 Python. </p><br><p>        ,      ,        Django,     ¬´¬ª  .   ,      ,              ,  ,     . </p><br><h3 id="alternativy">  Alternatives </h3><br><p>       ,   ,  , . </p><br><h4 id="asinhronnye-moduli-vmesto-_async-funkciy">    _async  </h4><br><p>        ,    ,     (, <code>django.core.cache.cache.get_async</code> ),               : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core.cache_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache cache.get(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>)</code> </pre> <br><p>   ,           ;   ,    ,        . </p><br><p>   ,    ,      ;       . </p><br><h4 id="fork-django">  Django </h4><br><p> -   ,      ;  ,        ,       ,       ‚Äî  . </p><br><p>           ,   ,     , ‚Äî   ,      . </p><br><h4 id="rasshirenie-channels">  Channels </h4><br><p>    ,    <a href="https://channels.readthedocs.io/en/stable/">Channels</a>      , ¬´¬ª  Django. ,     -     ,  ,         Django;      ORM,   HTTP/middleware flow    . </p><br><h4 id="ne-asyncio">  asyncio </h4><br><p>      event loop'  Python,   <code>asyncio</code>          ,   Django.   <code>await</code>  <code>async</code>  Python     event loop   . </p><br><p>   ,   <code>asyncio</code> ,     ; Django     ,        ,   .         Django        ;    , ,      async runtime,    ,    . </p><br><h4 id="greenletsgevent"> Greenlets/Gevent </h4><br><p>       Gevent,      ,      Python. </p><br><p>        ,       .   <code>yield</code>  <code>await</code> ,   API,    Django,       ,         .               ,     . </p><br><p>   ,      ,  ,     .      greenlet-safe   Django ORM   -   new-connection-context,  . </p><br><p>  ,      .   Django     ¬´ ¬ª    gevent, , ,      ,   . </p><br><h2 id="finansirovanie">  Financing </h2><br><p>             DEP. </p><br><p>   ,        ‚Äî        , ‚Äî     ,             (   ). </p><br><p>  ,       ,  -           .    <a href="https://www.djangoproject.com/fundraising/">Django Fellows</a>  ;     ‚Äî   ,           (  ), ,   ,  - . </p><br><p>       ‚Äî ,   Kickstarter  <code>migrations</code>  <code>contrib.postgres</code> ,    MOSS (Mozilla)  <a href="https://channels.readthedocs.io/en/stable/">Channels</a> .   ,   Django,  ,          . </p><br><p>     , <em></em>     .  ‚Äî      Python,    Django ‚Äî    ‚Äî       .        ,     Django/async,        . </p><br><p>                HTTP/middleware/view flow,     ,  ,  ,      ¬´ ¬ª,      . </p><br><p>     ,     ,     ,            (   ,  Fellows, /     ,     Channels,       ,   ),   ,       . </p><br><p>         ,         ,   ,        ,       Django,      . </p><br><h2 id="obratnaya-sovmestimost-1">  backward compatibility </h2><br><p> , ,   ,       ,            API. </p><br><p>   , ,        ,  , HTTP/middleware flow. ,    API,       APM,     . </p><br><p>  ,  ,   Django     ,     ,      .  ,   ORM  , ,   ‚Äî      ,  ORM             . </p><br><h2 id="etalonnaya-realizaciya">   </h2><br><p>  DEP  ,    ;       Django      . </p><br><p>   ,       <a href="https://github.com/django/asgiref">asgiref</a> ,       ,         .      Django         Django. </p><br><p>       <a href="https://channels.readthedocs.io/en/stable/">Channels</a> ,         Django,          Django. </p><br><h2 id="avtorskie-prava">  Copyright </h2><br><p>   <em>(  )</em>       <a href="">CC0 1.0 Universal</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/461493/">https://habr.com/ru/post/461493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46147/index.html">Selected: Grouping</a></li>
<li><a href="../461473/index.html">Debugging algorithms on graphs - now with pictures</a></li>
<li><a href="../461475/index.html">AMA with Habr. 1011</a></li>
<li><a href="../461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../461487/index.html">Mini CTF Tests</a></li>
<li><a href="../461497/index.html">Modern text rendering on Linux: part 1</a></li>
<li><a href="../461499/index.html">What languages ‚Äã‚Äãto translate your game in 2019</a></li>
<li><a href="../4615/index.html">FAS vs NWT: answer for dial-up</a></li>
<li><a href="../461501/index.html">Why in the US they are investigating the work of large IT companies</a></li>
<li><a href="../461503/index.html">Making the database available for remote connection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>