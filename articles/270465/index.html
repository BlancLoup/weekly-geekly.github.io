<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Matalysis in computer games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In many games, especially RPGs, stats are very important. Attack, defense, resistance, damage, penetration of armor, slips, etc. affect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Matalysis in computer games</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In many games, especially RPGs, stats are very important.  Attack, defense, resistance, damage, penetration of armor, slips, etc. affect the damage caused to the enemy or you receive from the enemy.  Most often, players prefer to stick to tactics - ‚Äúthe more and more immediately, the better.‚Äù  Such an approach is most likely caused not by a well-thought-out character development strategy, but by the lack of a detailed analysis of the game, laziness, or lack of information about the specific nature (specific calculation formula) of the influence of the ‚Äústats‚Äù on certain indicators.  Moreover, very often, according to the idea of ‚Äã‚Äãthe creators of the game, it is impossible to increase all the characteristics at the same time, and therefore choosing the right ‚Äúwhat and where to‚Äú pump in ‚Äùbecomes especially important. <br><br>  Next, we will discuss a method that in some cases will allow us to obtain an explicit formula for the dependence of some parameters on others (for example, the power of spells on intelligence, or the percentage reduction in damage received on protection).  This method is applicable where we have the ability to change one parameter and observe the changes that depend on it, the second one.  Moreover, this method is applicable in the case when the average value of the second parameter strictly depends on the first, but the second parameter itself is a random variable. <br><br>  The method will be described by the example of calculating the power of pet spells from the intellect, and the percentage of damage the player takes from the total amount of protection in the game ArcheAge.  Actually, the basis of the method is the ‚ÄúMethod of Least Squares‚Äù, which is very widely known and very often used in various fields.  Wolfram Mathematica (any version) will be used for calculations.  Actually, a step-by-step description of what needs to be done to obtain the law in question is the main value of this article.  Those familiar with the OLS and Wolfram Mathematica can go directly to examples. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Least Squares (OLS) </h4><a name="habracut"></a><br>  The MNC method is described in great detail in the literature; I will only describe the essence in general terms.  Let we know the general form of the dependence of one quantity on another.  From where you can learn the general view, I will explain later.  At the moment, for example, we take the dependence of the form y = a * x ^ 2 + b * x + c.  Where y is one value, and x is another.  In this case, a, b, c are some parameters.  And in order to completely surpass the dependence of one quantity on another, it is necessary to determine these parameters, because the type of dependence itself is assumed to be known. <br><br>  In the simplest case, one can find out the value of one quantity for a particular value of another quantity from observations, experiments, or some other sources.  You need three such pairs to create a complete system of equations and solve it with respect to the three unknown parameters a, b, c.  Moreover, in some cases this is enough in games. <br><br>  Everything gets complicated when one more term is added to the dependency function - namely, some random variable.  y = a * x ^ 2 + b * x + c + Random_Valichina.  It can be introduced by game developers specifically, such as the variation in damage, but it may have another reason.  The fact is that the exact value of a certain function may have in its record the number of digits larger than the size of the output field in the game menu.  In this case, a rounded value is displayed, and one cannot say the exact value is greater or less than what we can read in the game interface field.  Thus, we can say that rounding adds some random variable to us (it can be both negative and positive, but on average it is zero). <br><br>  When a random variable is added to the ‚Äúexact‚Äù dependence function y = a * x ^ 2 + b * x + c, then the actually observed, measured values ‚Äã‚Äãof y will not lie on the curve a * x ^ 2 + b * x + c, whatever there were parameters.  If neither the dispersion is too large (the mean value of the spread), the random values, the actually observed values ‚Äã‚Äãmarked on the coordinate plane will lie quite ‚Äúclose to the curve a * x ^ 2 + b * x, if we even know the parameters ab and c.  Some points can even get on this curve, because  it is quite possible that the random variable at some point simply assumed the value of zero.  But how then can we find the parameters of our function if even the points that we know do not lie on it?  MNC is to choose the parameters so that the distance from the points to the curve is minimal!  This is the main essence of the MNC. <br><br>  Here it is worth clarifying that the distance from the point to the curve means not the distance to the nearest point of the curve, but the difference between the value of the point (the point is a variable pair - the observed value of the function) and the ‚Äúexact‚Äù value of the function for the same value as the variable .  Generally speaking, in the ideal case, this difference is equal to the specific value of the very Random_Valichina at a given point.  It is also necessary to clarify what is needed so that the sum of all the differences between the observed values ‚Äã‚Äãand the ‚Äúexact‚Äù values ‚Äã‚Äãshould be minimal.  Unfortunately, there is often a temptation to throw out the most ‚Äúinconvenient‚Äù points that lag far behind the supposed ‚Äúexact‚Äù curve so that everything else looks better.  This can not be done, unless of course you are absolutely not sure that the measurement was taken erroneously.  And one more important point - the distance in this case is measured as a strictly positive value.  It doesn't matter if the observed point is higher than necessary or lower - the main thing is how far. <br><br>  General view of the dependence, as mentioned earlier y = a * x ^ 2 + b * x + c + Random_Valichina.  Moreover, from observations we know the observed value of pairs of both x, y.  We can measure steam as much as we want, and preferably the more the better!  (why so, read the literature).  To find the difference between the observed and the ‚Äúexact‚Äù value, one should subtract the measured values ‚Äã‚Äãof the y_measure values ‚Äã‚Äãand a * x_measure ^ 2 + b * x_measure + c.  That is, we believe that the variable is known precisely for us, and that with the exact parameters abc a * x_size ^ 2 + b * x_size + c is like the ‚Äúexact‚Äù value of our function.  From the resulting difference, you need to take the module to get the absolute value as already mentioned. (It is worth noting that, in fact, ‚Äúaccurate‚Äù means a curve that is closest to all points. Actually, we cannot calculate the exact value. But for want of Actually, it remains to be content with what can be calculated. <br><br>  If you are not used to this turn of events, then you should get used to it.  When there is no ideal, we use the best of what we have.) But it is inconvenient to work with the module, and it is simpler to square the resulting difference instead of the module.  And sum up all the squares of differences.  The resulting sum will be one very long function with many terms, but only three variables.  It remains only to find the values ‚Äã‚Äãof abc for which this function will be minimal.  Which is equivalent to finding the extrema of a function of several variables.  Which in turn (at first) glance is a trivial task of the analysis mat.  This is the least squares method. <br><br>  The apparent simplicity of the method plays a pretty bad trick when you need to write an algorithm for computing.  This is really quite a challenge, with a lot of pitfalls.  However, there are already implemented algorithms, which we will use, due to the fact that our goal is to use the OLS method, and not to write the next algorithm for its implementation. <cut><br><br><h5>  Wolfram mathematica </h5><br>  If you have never worked with programs like Mathematica MATLAB and Maple, then it's time to start.  If it‚Äôs very simple (so that you don‚Äôt be afraid to master them), then these programs are needed to solve systems of differential equations symbolically, or integrate symbolically, or draw a graph, and all this is done by a ‚Äúpolite request‚Äù in one line.  Just think, you write the equation, in a symbolic form (NOT NUMBER, all with letters, variables, parameters) and you get the same answer - in a general symbolic form.  Finding parameters using the ANC method is also possible.  (... and not only them, but these are details).  I advise you to try to play with Wolfram Mathematica.  Maybe someone will be more interesting if you find out the fact that from Mathematica there is access to databases of social networks, such as VKontakte.  (It is clear that only open data, but still) You can do some research yourself, using data from real people.  Their tastes, professions, interests, frequency of posts, and everything you want regarding sociology and people's behavior.  There are a lot of articles on how to work with Mathematica, but what is especially nice is the enormous number of examples in the built-in help - literally for all occasions.  This greatly simplifies the mastering of Mathematica (I will not respond so flatteringly about MATLAB: he, of course, has some advantages, but still my choice is for Mathematica). <br><br>  A few words about those functions that will be applied below.  To find the parameters of a function of a known type, in the presence of a set of observable (measured) data (to which a certain random value is added), the FindFit function is used.  To display an array of points, use the ListPlot function.  For plotting, simply Plot is used.  Arrays are usually enclosed in curly brackets {}, access to an array element is done through double square brackets [[]].  You can also use various functions to create an array, for example Table.  To display a graph and an array of points in one figure, the Show [{}] function from an array of two elements (or more) can be used, each of which can be any function for graphical display of data. <br><br><h4>  Examples </h4><br>  In most cases, games do not use too complex functions for the dependencies of some parameters on others.  The most commonly used linear functions are ax + b, or a relation of the form (ax + b) / (cx + d).  There is no clear rule for searching functions.  The developer can, if desired, make a very complex and confusing function, which is almost impossible to guess.  However, such cases are extremely rare.  The ratio of the form (ax + b) / (cx + d) is often used where the value to be limited from above is calculated, for example, the reduction of the damage received from the protection value.  Indeed, it makes no sense to introduce such a thing as damage reduction of more than 100%.  In such cases, when there are values ‚Äã‚Äãbounded above, it is best to start trying exactly with a function of the form y = (ax + b) / (cx + d). <br><br>  Let's try to find the dependence of the percentage of reduction of damage received on the value of protection.  For this we need to get a pair of numbers (protection, percentage).  This is done quite simply.  All items are removed from the character.  And then in turn, in different quantities, in different combinations are put on back.  Thus, we vary the value of protection, and watch how the percentage changes.  We write the results into an array, in this form. <br><br>  OurDefSource = {{637, 10.73}, {689, 11.5}, {462, 8.02}, {585, 9.94}, {358, 6.33}, {317, 5.64}, {281, 5.03}, {99, 1.83} , {0, 0}, {3668, 40.9}, {1287, 19.54}, {495, 8.54}, {2471, 31.8}, {4596, 46.44}}; <br><br>  After that, for the convenience of further graphical representation of points, it will be useful for us to find the minimum and maximum protection values.  And also sort our data.  Transpose from an array of two dimensional arrays makes an array of two one-dimensional arrays, to then calculate the minimum and maximum protection values. <br><br>  Def = Sort [OurDef, # 1 [[1]] &lt;# 2 [[1]] &amp;]; <br>  MaxDef = Last [Transpose [Def] [[1]]]; <br>  MinDef = First [Transpose [Def] [[1]]]; <br><br>  Then we set the general view of our function, and create an array of all the parameters that need to be found. <br><br>  Fdef [x _]: = (a * x + b) / (c * x + d); <br>  CoefsFdef = {a, b, c, d}; <br><br>  Then we use FindFit to search for parameters of a function of a certain type, using the data obtained experimentally. <br><br>  CoefsFdefFit = FindFit [Def, Fdef [x], CoefsFdef, x] <br><br>  After that, we show the form of the function with the parameters found (for this, ‚Äú/.‚Äù Is used) <br><br>  Fdef [x] /. CoefsFdefFit <br><br>  As a result, we get: (-1.1499 + 7.32728 x) / (388.234 + 0.0732995 x) <br><br>  I must say, the view is not very beautiful.  And I‚Äôll say right away that not very nice coefficients are used very rarely, due to the fact that it‚Äôs much easier for developers to work with some compact, visual coefficients.  But the result we received is a fraction, which we can reduce, something to put out for brackets.  We will lead to a more beautiful view.  If you look closely, you can see that the coefficients in front of x in the numerator and denominator are the same.  Divide the coefficient of x in the numerator of both parts of the fraction. <br><br>  (-0.156933+ x) / (52.9848_ + 0.0100036 x) <br><br>  As we remember, the variable x means the amount of protection in units.  Typical values ‚Äã‚Äãfor x are on the order of thousands.  Therefore, the numerical constant in the numerator can be neglected, which means that the general form of the function is actually somewhat different than we assumed, namely, without a constant in the numerator.  As for the denominator, the multiplier in front of x is very similar to 0.01.  The term in the denominator is very similar to 53.00.  Having made all these assumptions, and also multiplying the denominator by 100, we find that the percentage of damage taken is 100 * x / (5300 + x), where - x is the total amount of protection. <br><br>  To check how "beautiful" the formula corresponds to reality, we find the difference between the experimental points and the values ‚Äã‚Äãof our function. <br><br>  OurDiff = Fgood [x _]: = 100 * x / (5300 + x); <br>  OurDiff = Table [Fgood [Def [[i]] [[1]]] - Def [[i]] [[2]], {i, 1, Length [Def]}] <br>  Max [OurDiff] <br><br>  The maximum difference value is 0.00493997, which is less than half of the last significant (displayed) figure in the percent value.  Which is quite satisfactory. <br><br>  The result can be displayed on the chart. <br><br>  Show [{ListPlot [Def, PlotStyle -&gt; {Blue}], Plot [Fgood [x], {x, MinDef, MaxDef}, PlotStyle -&gt; {Green}]}] <br><br>  Full code for Mathematica: <br><br><pre><code class="hljs lua">OurDefSource = {{<span class="hljs-number"><span class="hljs-number">637</span></span>, <span class="hljs-number"><span class="hljs-number">10.73</span></span>}, {<span class="hljs-number"><span class="hljs-number">689</span></span>, <span class="hljs-number"><span class="hljs-number">11.5</span></span>}, {<span class="hljs-number"><span class="hljs-number">462</span></span>, <span class="hljs-number"><span class="hljs-number">8.02</span></span>}, {<span class="hljs-number"><span class="hljs-number">585</span></span>, <span class="hljs-number"><span class="hljs-number">9.94</span></span>}, {<span class="hljs-number"><span class="hljs-number">358</span></span>, <span class="hljs-number"><span class="hljs-number">6.33</span></span>}, {<span class="hljs-number"><span class="hljs-number">317</span></span>, <span class="hljs-number"><span class="hljs-number">5.64</span></span>}, {<span class="hljs-number"><span class="hljs-number">281</span></span>, <span class="hljs-number"><span class="hljs-number">5.03</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">1.83</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">3668</span></span>, <span class="hljs-number"><span class="hljs-number">40.9</span></span>}, {<span class="hljs-number"><span class="hljs-number">1287</span></span>, <span class="hljs-number"><span class="hljs-number">19.54</span></span>}, {<span class="hljs-number"><span class="hljs-number">495</span></span>, <span class="hljs-number"><span class="hljs-number">8.54</span></span>}, {<span class="hljs-number"><span class="hljs-number">2471</span></span>, <span class="hljs-number"><span class="hljs-number">31.8</span></span>}, {<span class="hljs-number"><span class="hljs-number">4596</span></span>, <span class="hljs-number"><span class="hljs-number">46.44</span></span>}}; Def = Sort[OurDefSource, #<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">[[1]]</span></span> &lt; #<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">[[1]]</span></span> &amp;]; MaxDef = Last[Transpose[Def]<span class="hljs-string"><span class="hljs-string">[[1]]</span></span>]; MinDef = First[Transpose[Def]<span class="hljs-string"><span class="hljs-string">[[1]]</span></span>]; Fdef[x_] := (a*x + b)/(c*x + d); CoefsFdef = {a, b, c, d}; CoefsFdefFit = FindFit[Def, Fdef[x], CoefsFdef, x] Fdef[x] /. CoefsFdefFit OurDiff = Fgood[x_] := <span class="hljs-number"><span class="hljs-number">100</span></span>*x/(<span class="hljs-number"><span class="hljs-number">5300</span></span> + x); OurDiff = Table[Fgood[Def<span class="hljs-string"><span class="hljs-string">[[i]]</span></span><span class="hljs-string"><span class="hljs-string">[[1]]</span></span>] - Def<span class="hljs-string"><span class="hljs-string">[[i]]</span></span><span class="hljs-string"><span class="hljs-string">[[2]]</span></span>, {i, <span class="hljs-number"><span class="hljs-number">1</span></span>, Length[Def]}] Max[OurDiff] Show[{ListPlot[Def, PlotStyle -&gt; {Blue}], Plot[Fgood[x], {x, MinDef, MaxDef}, PlotStyle -&gt; {Green}]}]</code> </pre> <br>  A similar approach also works successfully in calculating the formula for calculating the damage of a spell Poisonous breath of a pet. The turned witch from the Inta bonus from gear.  In this example, the general form of the function will be somewhat different.  If we assume that the formula for the pet will be similar to the formula for the character, then the inta is first converted to the power of spells, then something else is added to this power (from gear or buffs), after which the resulting spell power is converted by some formula to damage from a particular spell.  And often the damage from spells has a constant part, which does not depend on the power of spells.  Thus, the formula is supposed to be <br><br>  a51 + b51 * (c51 * x + y) <br><br>  where a51 is a constant in the calculation of a specific sang;  b51 is a multiplier in the formula sang;  c51 is the coefficient of proportionality between spell power and inta;  x is inta and y is a bonus boost to spell power from gear.  FindFit is able to work for a function of several variables.  As a result, we get: <br><br>  Damage to the spell Toxic Breath = 1669 + 4.8 * (1.25 * Inta + Bonus Power); <br><br>  It is worth noting that, in contrast to the character, the coefficient of proportionality of the spell power and inta is not 0.2 and 1.25, which means that the spell power from the spells of pets grows almost 6 times faster. <br><br>  For comparison: <br><br>  Lesser Hurricane 654 + 1.92 * (1.25 * x + y); <br>  ‚ÄúLittle Arrow‚Äù 980 + 2.88 * (1.25 * x + y); <br><br><h4>  findings </h4><br>  Thus, using a fairly simple method, you can get information about the laws and principles of the game.  Along the way, as was shown, we learned not only the dependence of one parameter on another, but also noticed something that we were not even looking for, like the coefficient c51.  Now, knowing the exact formula for the calculation, you can analyze and model which parameters and how to improve.  Thus, the character development strategy becomes more meaningful. <br><br>  This method does not apply to hacking the code, nor to anything else illegal.  But agree, this method allows you to see what is not clearly shown for all the others. <br><br><h4>  Conclusion </h4><br>  Matan helps even in games.  I hope the described example of the use of MNCs in games will increase your interest in matan. </cut></div><p>Source: <a href="https://habr.com/ru/post/270465/">https://habr.com/ru/post/270465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270453/index.html">Big data from A to Z. Part 3: Techniques and strategies for developing MapReduce-applications</a></li>
<li><a href="../270457/index.html">Apple TV</a></li>
<li><a href="../270459/index.html">Google Cloud Endpoints in Java: A Guide. Part 2 (Frontend)</a></li>
<li><a href="../270461/index.html">Web two-null shortcuts for Java</a></li>
<li><a href="../270463/index.html">Nginx + Lua + Redis. Effectively process the session and give the data</a></li>
<li><a href="../270469/index.html">Full Binary XML Replacement</a></li>
<li><a href="../270471/index.html">What's new and interesting in IntelliJ IDEA 15</a></li>
<li><a href="../270473/index.html">How to cook DTO?</a></li>
<li><a href="../270475/index.html">Draft Doctrine of Information Security of the Russian Federation</a></li>
<li><a href="../270479/index.html">Methods of treating various errors in Android Studio during project development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>