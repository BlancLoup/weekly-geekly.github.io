<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mill Fighting - 1: Interpolation Splines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, the lyrical hero challenges the optimal implementation of the classic polynomial Lagrange interpolator (Farrow), in the process of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mill Fighting - 1: Interpolation Splines</h1><div class="post__text post__text-html js-mediator-article">  In this article, the lyrical hero challenges the optimal implementation of the classic polynomial Lagrange interpolator (Farrow), in the process of the battle accidentally opens and proves the trivial useless math magic spell with which he tries to press the opponent, but according to the results of all rounds of the battle, a draw is fixed by the judges . <br><br><blockquote>  - Where do you see giants?  - Sancho Panza asked. <br>  - Yes, there they are, with huge hands, - answered his lord.  - Some of them have arm lengths of almost two miles. <br>  ‚ÄúHave mercy, se√±or,‚Äù Sancho said, ‚Äúthat what is seen there is not at all giants, but windmills;  what you take for their hands are the wings: they whirl from the wind and set the millstones in motion. <br>  ‚ÄúYou can see an inexperienced adventure seeker,‚Äù said Don Quixote, ‚Äúthese are giants.‚Äù  And if you are afraid, then drive off to the side and pray, and in the meantime I will join with them in a fierce and unequal battle ... </blockquote><br><a name="habracut"></a><br>  Once a friend of mine asked me to simulate a simple and low-cost variant of resampling (changing the sampling frequency) of a digital signal.  There were no special requirements for linear frequency response and phase response, and the desire to save time and memory was, therefore, some methods such as polyphase interpolating banks of FIR filters were immediately excluded from consideration, and the main attention was paid to local polynomial interpolation methods.  Polynomials are quick and easy to read, storage of their coefficients requires little memory, and using a single set of coefficients, you can calculate any values ‚Äã‚Äãwithin the original sampling interval. <br><br><h4>  Meet the enemy - the implementation of Farrow </h4><br>  It is known that through any N points (from here and further for definiteness we will consider a uniform grid - with the same step, although for many described techniques and methods this is not a prerequisite), so, through any N points with different x-coordinates, you can conduct a single polynomial of N-1 order uniquely determined by a set of N coefficients (read that LaTex on Habr√© is not directly, but through pictures that are heavy and short-lived, so I will only manage the upper-lower indices in html-tags): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      f (t) = a <sub>n</sub> t <sup>n</sup> + a <sub>n-1</sub> t <sup>n-1</sup> + ..... + a <sub>1</sub> t + a <sub>0</sub> <br><br>  For convenience of calculations, we normalize our uniform argument grid to integer values, using the example of four points, choose a convenient interval of the argument (Farrow chose from [-2, 1] with central interval from [-1, 0]) and write the system of linear equations from the condition of passing the polynomial through our 4 points: <br><br>  f (i) = y <sub>i</sub> <br>  where i = {-2, -1, 0, 1} <br><br>  You can decide as you like, even though Gauss can convert the matrix, but Farrow has optimized the number of operations to calculate the coefficients of this polynomial: <br><br>  a <sub>3</sub> = (y <sub>1</sub> - y <sub>-2</sub> ) / 6 + (y <sub>-1</sub> - y <sub>0</sub> ) / 2 <br>  a <sub>1</sub> = (y <sub>1</sub> - y <sub>-1</sub> ) / 2 - a <sub>3</sub> <br>  a <sub>2</sub> = y <sub>1</sub> - y <sub>0</sub> - a <sub>1</sub> - a <sub>3</sub> <br>  a <sub>0</sub> = y <sub>0</sub> <br><br>  Total operations: <br><ul><li>  1 multiplication by a constant (1/6) </li><li>  2 divisions by 2 (considered fast and in integer arithmetic and in floating point format) </li><li>  8 addition / subtraction </li></ul><br>  This polynomial is used to calculate values ‚Äã‚Äãthat fall in the central interval of the original four points: [-1, 0] (with the corresponding rationing of the argument); for other intervals, the polynomials are calculated in the same way from the four points surrounding them.  Very popular interpolator in narrow circles, deserved and revered.  And for some reason I immediately wanted to come up with something that could surpass this implementation in a certain sense, taking into account the number of operations for the calculation. <br><br><h4>  First challenger - Catmulla-Roma spline </h4><br>  You can see that both the sought polynom itself and all its derivatives are linear combinations of the unknown coefficients of the polynomial.  Therefore, we can set the conditions for the equality of derivatives of any order at the nodes of the grid to the given values, and obtain a linear system of equations for the polynomial coefficients.  Hermite's local cubic spline is based on four conditions: the values ‚Äã‚Äãof the polynomial and its first derivative at the edges of the interval.  And we can get the approximate values ‚Äã‚Äãof these derivatives at the right points by differentiating the interpolating Lagrange polynomial passing through them.  For example, we normalize the arguments of four points to the interval [-1, 2], take three points with arguments {-1, 0, 1} and draw a parabola through them, and calculate its coefficients.  And since we only need the value of the first derivative of this parabola at the center point 0, it is enough to calculate its coefficient for the first degree of the argument, and it will be used as a derivative for the construction of the spline.  The derivative at the right edge of the interval is calculated similarly.  As a result of a simple calculation, we obtain the following system of equations for the spline coefficients: <br><br>  f (i) = y <sub>i</sub> <br>  f '(i) = (y <sub>i + 1</sub> - y <sub>i-1</sub> ) / 2 <br>  where i = {0, 1} <br><br>  whose solution can be obtained in the following form: <br><br>  y ' <sub>0</sub> = (y <sub>1</sub> - y <sub>-1</sub> ) / 2 <br>  y ' <sub>1</sub> = (y <sub>2</sub> - y <sub>0</sub> ) / 2 <br><br>  a <sub>0</sub> = y <sub>0</sub> <br>  a <sub>1</sub> = y ' <sub>1</sub> <br>  a <sub>3</sub> = y ' <sub>0</sub> + y' <sub>1</sub> + 2 (y <sub>0</sub> - y <sub>1</sub> ) <br>  a <sub>2</sub> = y <sub>1</sub> - a <sub>3</sub> - a <sub>1</sub> - a <sub>0</sub> <br><br>  We can note that in the case of sequential (streaming) processing of input data, the derivative of the left boundary of the interval is the same as the derivative of the right boundary of the previous interval, which means that at each interval we need to calculate only one derivative - in the right boundary of the interval, and take the value in the left from memorized in the previous calculation in the right.  Using this saving on matches, we obtain the following number of operations for calculating the polynomial coefficients: <br><br><ul><li>  2 multiplication / division by 2 </li><li>  7 addition / subtraction </li></ul><br>  This particular case of the Hermite spline is called Catmulla-Roma. <br><br><h4>  The second challenger - Hermite spline at 6 points </h4><br>  If we estimate the derivatives in the edges of the central interval not by three, but by five points, then their calculation will become a bit more complicated, but the other formulas will not change: <br><br>  y ' <sub>0</sub> = ((y <sub>1</sub> - y <sub>-1</sub> ) - (y <sub>2</sub> - y <sub>-2</sub> ) / 8) 2/3 <br>  y ' <sub>1</sub> = ((y <sub>2</sub> - y <sub>0</sub> ) - (y <sub>3</sub> - y <sub>-1</sub> ) / 8) 2/3 <br><br>  a <sub>0</sub> = y <sub>0</sub> <br>  a <sub>1</sub> = y ' <sub>1</sub> <br>  a <sub>3</sub> = y ' <sub>0</sub> + y' <sub>1</sub> + 2 (y <sub>0</sub> - y <sub>1</sub> ) <br>  a <sub>2</sub> = y <sub>1</sub> - a <sub>3</sub> - a <sub>1</sub> - a <sub>0</sub> <br><br>  Taking into account the previous remark about the need to calculate only one derivative at each interval, the number of operations: <br><br><ul><li>  1 multiplication by a constant (2/3) </li><li>  2 multiplication / division by grade 2 </li><li>  9 addition / subtraction </li></ul><br><h4>  Comparison of options </h4><br>  By the number of operations, the spline of Catmulla-Roma significantly outperforms Farrow, Hermite 6 points slightly losing (by one addition).  It is also worth noting that both splines have first order smoothness (continuous zero and first derivatives) due to their construction, unlike Farrow, which does not ensure the continuity of the derivative.  But there remains the question of the accuracy of the approximation of functions by these splines.  The sine was chosen as a test function, it was approximated by the above spline variants for a different grid step, which is normalized to the relative value of the number of points per period.  The magnitude of the maximum deviation from the approximated function was measured.  The results are presented on the graph. When choosing the logarithmic scale, the dependences on both axes are almost linear, converging to one point as the sampling frequency decreases and approaches the Nyquist frequency (2 points per approximated test sinus period). <br><br><img src="https://habrastorage.org/files/2db/c78/329/2dbc78329051446598c726ae529c2e3a.png"><br><br>  The graph shows that the spline of Catmulla-Roma is inferior to Farrow in accuracy, and the latter is inferior to Hermite by 6 points, with almost the same number of operations required for the calculation.  It was not possible to win a clear victory, but in principle, the result is not bad. <br><br><h4>  Spell </h4><br>  We can develop the general idea of ‚Äã‚Äãthe Hermite spline on derivatives of any order.  For example, we construct a spline according to the following conditions: its values ‚Äã‚Äãat the edges of the interval coincide with the values ‚Äã‚Äãof the samples at these points, and the <b>second</b> derivatives at these points coincide with their estimates produced by parabolas through triples of points - that is, everything is like Catmull-Roma, only instead of the first, we will take the second derivatives - parabola, as a second-order polynomial, which will allow us to calculate them completely.  And here we are surprised to find that the spline constructed in this way fully coincides with our esteemed Farrow, who is actually Lagrange polynomial.  Those who wish can check this, I will even write a formula for evaluating the second derivative of a parabola on 3 points (although this is a trivial exercise): <br><br>  y '' <sub>i</sub> = y <sub>i + 1</sub> + y <sub>i-1</sub> - 2 y <sub>i</sub> <br><br>  Good match?  Random because there are few points and small polynomial order?  Numerically checking this fact on a different number of points and the order of polynomials, I was convinced that the spell works: <br><br>  <i>Suppose we have an interpolation polynomial constructed by some values ‚Äã‚Äãon an even number of points of a uniform grid.</i> <i><br><br></i>  <i>x <sub>-k</sub> , x <sub>- (k-1)</sub> , ... x <sub>0</sub> , x <sub>1</sub> , ... x <sub>k-1</sub> , x <sub>k</sub> , x <sub>k + 1</sub></i> <i><br><br></i>  <i>Then all the even derivatives of this polynomial at the point x <sub>0</sub> coincide with the derivatives of the same orders of the interpolation polynomial constructed from the points</i> <i><br><br></i>  <i>x <sub>-k</sub> , x <sub>- (k-1)</sub> , ... x <sub>0</sub> , x <sub>1</sub> , ... x <sub>k-1</sub> , x <sub>k</sub></i> <i><br><br></i>  <i>and at the point x <sub>1</sub> - a polynomial constructed by the points</i> <i><br><br></i>  <i>x <sub>- (k-1)</sub> , ... x <sub>0</sub> , x <sub>1</sub> , ... x <sub>k-1</sub> , x <sub>k</sub> , x <sub>k + 1</sub></i> <br><br>  Evidence.  Consider a function on a uniform grid of an odd number of points ‚Äî let's make an argument offset, giving the central node argument to 0 <br><br>  x <sub>-k</sub> , x <sub>- (k-1)</sub> , ... 0, x <sub>1</sub> , ... x <sub>k-1</sub> , x <sub>k</sub> <br><br>  There is its only interpolation polynomial P <sub>0</sub> (x).  Add to this set of points one more x <sub>k + 1</sub> (for the proof it does not matter, we add it to the right, left, or even to the middle and not to the nodes of the original grid).  Interpolation polynomial on an extended set of points, provided a uniform grid can be represented in the form of Newton <br><br>  P <sub>1</sub> (x) = P <sub>0</sub> (x) + A (xx <sub>-k</sub> ) (xx <sub>- (k-1)</sub> ) .... (x-0) .... (xx <sub>k-1</sub> ) (xx <sub>k</sub> ) <br><br>  where A is a constant.  Indeed, this additive additive requires zero values ‚Äã‚Äãat the points of the original polynomial, and the constant A is determined from the equality condition P <sub>1</sub> (x <sub>k + 1</sub> ) = y <sub>k + 1</sub> - the required value of the polynomial at the added point.  Due to the uniformity of the grid -x <sub>-i</sub> = <sub>xi</sub> , it means <br><br>  P <sub>1</sub> (x) = P <sub>0</sub> (x) + A (x <sup>2</sup> -x <sub>k</sub> <sup>2</sup> ) (x <sup>2</sup> -x <sub>k-1</sub> <sup>2</sup> ) .... (x <sup>2</sup> -x <sub>1</sub> <sup>2</sup> ) (x-0) <br><br>  Obviously, the right side is the sum of P <sub>0</sub> (x) and a polynomial with nonzero coefficients only for odd powers of the argument.  Hence, the coefficients for even degrees of the polynomials P <sub>1</sub> (x) and P <sub>0</sub> (x) coincide, and all even derivatives of any polynomial at zero are determined only by its corresponding coefficient with even degree of argument.  Thus, all the even derivatives of P <sub>1</sub> (x) and P <sub>0</sub> (x) coincide. <br>  The above reasoning is valid for any location of the added point x <sub>k + 1</sub> , in particular, when adding it to the right or left of the original grid.  Thus, the derivatives of even orders at the origin of the original polynomial and the polynomial with respect to the extended set of points coincide.  PM <br><br><h4>  Last round - Lagrange after Farrow with Lagrange via derivatives </h4><br>  Since the interpolation polynomial of minimal order is unique, we can, taking into account the spell we have just proved, build it through conditions on the values ‚Äã‚Äãof even derivatives at the edges of the central interval ‚Äî for example, a 5th order polynomial through 6 points according to 6 conditions: values ‚Äã‚Äãof counts and second and fourth derivatives calculated for every five points.  In this case, use the same optimization described above - calculation of derivatives only in the right boundary of each interval.  In the original formulation of passing a polynomial through all points, these invariants were not obvious.  Apply this to our original Lagrange by 4 points and optimize the number of operations.  I‚Äôll give the Matlab code of my version right away, and the participant's nickname _Anatoliy from the electronic forum, which independently and independently defeated Farrow before my experiments: <br><br><pre><code class="matlab hljs">clf reset N = <span class="hljs-number"><span class="hljs-number">10</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span>:N; y = <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, N); h = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; g = y(<span class="hljs-number"><span class="hljs-number">3</span></span>) - y(<span class="hljs-number"><span class="hljs-number">2</span></span>); d = g - y(<span class="hljs-number"><span class="hljs-number">2</span></span>) + y(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">plot</span></span>(x, y, <span class="hljs-string"><span class="hljs-string">'or'</span></span>, <span class="hljs-string"><span class="hljs-string">'LineWidth'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">hold</span></span> on; grid on; axis on; title([<span class="hljs-string"><span class="hljs-string">'    '</span></span>, ... <span class="hljs-string"><span class="hljs-string">'   3 , 2  .'</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">plot</span></span>(x(<span class="hljs-number"><span class="hljs-number">1</span></span>), y(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'b-'</span></span>, x(<span class="hljs-number"><span class="hljs-number">1</span></span>), y(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'g:'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">legend</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' Anatoliy'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span>:(N<span class="hljs-number"><span class="hljs-number">-2</span></span>) <span class="hljs-comment"><span class="hljs-comment">%  : 1 , 1 , 5  c = d; e = g; g = y(k+2) - y(k+1); d = g - e; b2 = c/2; b3 = (d - c)/6; b1 = e - b2 - b3; t = 0:h:1; f = b3.*t.^3 + b2.*t.^2 + b1.*t + y(k); plot(t+x(k), f, 'b-') %  _Anatoliy: 1 , 2 , 6  p = y(k) - y(k+1); q = (y(k+2) - y(k))/2; a3 = ( (y(k+2) - y(k-1))/3 + p )/2; a2 = p + q; a1 = q - a3; t = -1:h:0; f = a3.*t.^3 + a2.*t.^2 + a1.*t + y(k+1); plot(t+1+x(k), f, 'g:') end</span></span></code> </pre> <br>  As you can see, both codes contain fewer operations for calculating the polynomial coefficients, so in terms of sports, I believe that we both won.  Although there are opinions that this is saving on matches, that nowadays, when <s>space ships plow</s> everywhere there are mathematical co-processors with integrated operations with floating-point numbers, the speed of operations is comparable to the speed of moving the contents of registers and especially reading / writing memory to save / recovery of calculated values ‚Äã‚Äã- such optimizations do nothing, I still have a certain feeling of satisfaction with the results, despite their weak practical significance. </div><p>Source: <a href="https://habr.com/ru/post/282441/">https://habr.com/ru/post/282441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282427/index.html">Native advertising returns: Native Admob, RecyclerView and briefly about the rules</a></li>
<li><a href="../282429/index.html">We are looking for a replacement for Digital Ocean among domestic hosting companies</a></li>
<li><a href="../282431/index.html">Two languages, one Cup. Reflections on the RCC 2016 Rules</a></li>
<li><a href="../282433/index.html">Recognition of DGA domains. And what if neural networks?</a></li>
<li><a href="../282435/index.html">"And how well everything began ...", or the benefits of O-notation, not only for the analysis of algorithms</a></li>
<li><a href="../282443/index.html">MNP and Appearance API 1.0 - Voluntary Eating Cacti</a></li>
<li><a href="../282449/index.html">Silent revolution: the introduction of x86-architecture instead of RISC-machines for bank processing</a></li>
<li><a href="../282455/index.html">Why security experts prefer outdated email clients</a></li>
<li><a href="../282457/index.html">How to integrate TeamCity and Bitbucket Server</a></li>
<li><a href="../282459/index.html">Connect to the online broadcast! Opening conference Xamarin Evolve April 27</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>