<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing the RSA algorithm in the client-server architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Emergence of need 


 This article is devoted to one of the problems that I encountered while developing my own project. The project has a client-serv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing the RSA algorithm in the client-server architecture</h1><div class="post__text post__text-html js-mediator-article"><h3>  Emergence of need </h3><br><img src="http://img15.imageshack.us/img15/9316/rsaf.jpg"><br><br>  This article is devoted to one of the problems that I encountered while developing my own project.  The project has a client-server architecture, and is a business application.  Almost the first question after the implementation of data transmission over the network and the construction of the framework, it became necessary to encrypt the transmitted data.  The first possible algorithm (planning support for several) was chosen as the RSA encryption algorithm. <br><br>  The article will discuss the options for implementing the RSA algorithm on a client-server architecture, and an example of such an implementation in a real project. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h3>  RSA Algorithm Concept </h3><br>  I will not describe here the features of this algorithm, but I will tell you exactly how it can be used in the client-server architecture. <br>  A small introduction ... Actually, <a href="http://ru.wikipedia.org/wiki/RSA">RSA</a> (a literal abbreviation of the surnames Rivest-Shamir-Adleman) is a public-key cryptographic algorithm.  This means that the system generates two different keys - public and secret. <br><ul><li>  <b>The public</b> key is transmitted over an open (unprotected) channel, and is used to encrypt data. </li><li>  <b>The secret</b> key is stored only with the owner, and is used to decrypt any data encrypted with the public key. </li></ul>  Thus, we can transfer the public key to anyone, and receive messages encrypted with this key, which only we can decrypt (using the private key). <br><br><img title="Figure number 1. Public key concept" alt=" ‚Ññ1.   " src="http://img242.imageshack.us/img242/8223/14101982.jpg"><br><br>  This concept is presented in Figure 1, shown above. <br><br>  As you see, the key, after being generated by the <font color="blue">blue character,</font> is transmitted to the <font color="green">green character</font> over an unprotected channel in clear text.  Anyone can intercept it, but with it you can only <u>encrypt the</u> message. <br><br>  Therefore, the <font color="green">green character</font> easily obtains the public key and encrypts its message with this key. <br><br>  After that, he sends an encrypted message to the <font color="blue">blue character</font> , which decrypts using the private key. <br><br>  Within two people, the scheme is pretty simple.  However, if it is necessary to organize such a system on a client-server architecture, a number of additional questions arise, which we will consider below. <br><br><br><h3>  Client - server </h3><br><br>  So, for a start we will define keys.  As you remember, the recipient‚Äôs public key is required to <u>encrypt</u> messages.  Accordingly, the server requires the public key of the client, and the client needs the public key of the server.  Therefore, before starting the data transfer, it is necessary to exchange keys.  How this happens, we consider the figure number 2, which presents the process of key exchange. <br><br><img src="http://img707.imageshack.us/img707/4920/53437940.jpg"><br><br>  1. <font color="blue">The client</font> opens a connection to the <font color="green">server</font> and generates a keychain (public-secret);  then it sends the packet to the <font color="green">server</font> , in which it sends it its public key; <br>  2. <font color="green">The server</font> accepts the packet, reads and stores the public key of the <font color="blue">client</font> , generates its own keychain;  after that, it sends the packet to the <font color="blue">client</font> , in which it sends it its public key; <br>  3. <font color="blue">The client</font> accepts the packet, reads and stores the public key of the <font color="green">server</font> ; <br><br><br>  The exchange is completed in three stages.  Now both the server and the client have the public key of the interlocutor "at the other end of the line".  However, you immediately need to choose one of two solutions about how the server will generate keys for its clients: <br><br><br>  1. <font color="green">The server</font> generates one key for <u>all</u> <font color="blue">clients</font> ; <br>  2. <font color="green">The server</font> generates a new key for <u>each individual</u> <font color="blue">client</font> ; <br><br>  I think every one of you knows that the bigger the key, the greater its practical utility.  However, in the case of the RSA algorithm, key generation is not such a simple task, since it represents the basic computational complexity.  In addition, the algorithm is designed in such a way that the larger the key, the more data will need to be transmitted. <br><br>  <em>For example, when sending a message with a length of 5 bytes, and using a key with a length of 512 bits, the encrypted message will ‚Äúweigh‚Äù 64 kbytes.</em>  <em>This is due to the fact that the maximum amount of data that can be encrypted with such a key is 64-11 = 53 kB (11 kB is used for bit shifts).</em>  <em>If you need to encrypt more, we divide them into blocks of 53 KB each.</em>  <em>And if you take the key = 4096 bits, then the minimum block will be equal to 512K bytes, despite the fact that we encrypt only 5 bytes.</em> <em><br></em> <br><br>  <u>Therefore, it is necessary to solve</u> : <br><br>  1. Generate one big key for all <font color="blue">clients</font> that will generate extra traffic, use more processor resources (encrypting a message with a key of 4096 bits is much more difficult than out of 512), but eating less memory and hours killed for development; <br>  2. Alternatively, generate a small key for each <font color="blue">client</font> and ensure that the period of its use does not exceed the maximum allowable (breaking a key of 512 bits in length has long become a reality; the recommended length is at least 1024 bits); <br><br>  Everyone may have their own views on which account to choose, and much depends on the product being developed.  However, in this project it was decided to use the <u>second option</u> . <br><br><h3>  Generating and sending the key to the server </h3><br><br>  Our project uses a <a title="Information about the three-tier architecture on the wiki" href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D1%2591%25D1%2585%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">three-tier architecture</a> : client-server-database.  The server is written in Java, the client - in C #.  Below I will describe the implementation of encryption both on the server side and on the client side.  Let's start with the user - client. <br><br>  So, the connection to the server was successful, and it is ready to accept packets.  To do this, we create a key using the .NET class <a title="RSACryptoServiceProvider class information on MSDN" href="http://msdn.microsoft.com/ru-ru/library/system.security.cryptography.rsacryptoserviceprovider.aspx">RSACryptoServiceProvider</a> (C #): <br><br><blockquote><ol><li>  <font color="#0600FF">private</font> RSACryptoServiceProvider m_Rsa <font color="#008000">;</font> </li><li>  <font color="#0600FF">private</font> RSAParameters m_ExternKey <font color="#008000">;</font> </li><li>  <font color="#0600FF">private</font> RSAParameters m_InternKey <font color="#008000">;</font> </li><li></li><li>  <font color="#0600FF">public</font> CryptoRsa <font color="#000000">(</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  m_Rsa <font color="#008000">=</font> <font color="#008000">new</font> RSACryptoServiceProvider <font color="#000000">(</font> <font color="#FF0000">512</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  m_InternKey <font color="#008000">=</font> m_Rsa.  <font color="#0000FF">ExportParameters</font> <font color="#000000">(</font> <font color="#0600FF">true</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br><br>  In this listing, we see the <font color="blue">CryptoRsa</font> class <font color="blue">constructor</font> , which automatically generates a key with a length of 512 bits and exports key parameters (true indicates that it is necessary to export not only the public but also the secret key) to the <font color="green">m_InternKey</font> variable. <br><br>  Next, you need to save the public key in byte format and send it to the server.  To do this, you need to understand a little what RSA keys consist of.  In short, they consist of so-called open and secret exhibitors and a single module for both keys.  Accordingly, the public key is a public exponent and a module, the private key is a private exponent and a module.  More details can be found <a href="http://ru.wikipedia.org/wiki/RSA">here</a> in the chapter "The algorithm for creating public and secret keys." <br><br>  Write the open exponent to the output buffer (C #): <br><br><blockquote><ol><li>  <font color="#008080">// Write the length of the exponent -&gt; exponent -&gt; module</font> </li><li>  buf.  <font color="#0000FF">Write</font> <font color="#000000">(</font> <font color="#000000">(</font> <font color="#FF0000">Byte</font> <font color="#000000">)</font> m_InternKey. <font color="#0000FF">Exponent</font> . <font color="#0000FF">Length</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  buf.  <font color="#0000FF">Write</font> <font color="#000000">(</font> m_InternKey. <font color="#0000FF">Exponent</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  buf.  <font color="#0000FF">Write</font> <font color="#000000">(</font> m_InternKey. <font color="#0000FF">Modulus</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  In this case, the length of the exponent is needed in order to know exactly where the exponent ends and the module begins (when reading data on the server).  After recording, send the data to the server. <br><br>  After the server has received a packet with a key, you need to pick up the key from the packet and save it.  We look (Java): <br><br><blockquote><ol><li>  <font color="#666666">// Exponent Length</font> </li><li>  <font color="#000066">int</font> expLength <font color="#339933">=</font> packet.  <font color="#006633">readByte</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Get the exponent bytes</font> </li><li>  <font color="#000066">byte</font> <font color="#009900">[</font> <font color="#009900">]</font> exponent <font color="#339933">=</font> <font color="#000000">new</font> <font color="#000066">byte</font> <font color="#009900">[</font> expLength <font color="#009900">]</font> <font color="#339933">;</font> </li><li>  <font color="#003399">System</font> .  <font color="#006633">arraycopy</font> <font color="#009900">(</font> packet. <font color="#006633">Bytes</font> , packet. <font color="#006633">Offset</font> , exponent, <font color="#cc66cc">0</font> , expLength <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Get the module bytes</font> </li><li>  <font color="#000066">byte</font> <font color="#009900">[</font> <font color="#009900">]</font> modulus <font color="#339933">=</font> <font color="#000000">new</font> <font color="#000066">byte</font> <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#339933">+</font> packet.  <font color="#006633">Bytes</font> .  <font color="#006633">length</font> <font color="#339933">-</font> <font color="#009900">(</font> packet. <font color="#006633">Offset</font> <font color="#339933">+</font> expLength <font color="#009900">)</font> <font color="#009900">]</font> <font color="#339933">;</font> </li><li>  <font color="#003399">System</font> .  <font color="#006633">arraycopy</font> <font color="#009900">(</font> packet. <font color="#006633">Bytes</font> , packet. <font color="#006633">Offset</font> <font color="#339933">+</font> expLength, modulus, <font color="#cc66cc">1</font> , modulus. <font color="#006633">length</font> <font color="#339933">-</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Voodoo Magic</font> </li><li>  modulus <font color="#009900">[</font> <font color="#cc66cc">0</font> <font color="#009900">]</font> <font color="#339933">=</font> <font color="#cc66cc">0</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Save the key</font> </li><li>  <font color="#003399">RSAPublicKeySpec</font> rsaPubKeySpec <font color="#339933">=</font> <font color="#000000">new</font> <font color="#003399">RSAPublicKeySpec</font> <font color="#009900">(</font> <font color="#000000">new</font> <font color="#003399">BigInteger</font> <font color="#009900">(</font> modulus <font color="#009900">)</font> , <font color="#000000">new</font> <font color="#003399">BigInteger</font> <font color="#009900">(</font> exponent <font color="#009900">)</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li>  m_ExternPublicKey <font color="#339933">=</font> <font color="#009900">(</font> <font color="#003399">RSAPublicKey</font> <font color="#009900">)</font> <font color="#003399">KeyFactory</font> .  <font color="#006633">getInstance</font> <font color="#009900">(</font> <font color="#0000ff">"RSA"</font> <font color="#009900">)</font> .  <font color="#006633">generatePublic</font> <font color="#009900">(</font> rsaPubKeySpec <font color="#009900">)</font> <font color="#339933">;</font> </li></ol></blockquote><br><br>  I think that there is no need to comment on the code, except for a strange line, which I called "voodoo magic" :), where we set the first byte of the module to zero.  But the point is this - for reasons unknown to me, the RSA implementation in Java requires that the key module always start from scratch.  Perhaps this is due to having a module&gt; 0, since  when I tried to implement RSA in Java myself using large numbers (BigInteger), when the first byte was not equal to zero, it turned out to be a negative number.  I leave this question to you, gentlemen Habravchane, I will be very happy if someone explains this feature. <br><br>  Next comes the key generation by the server.  Consider the following piece of code (java): <br><br><blockquote><ol><li>  <font color="#666666">// Get and initialize the key generator</font> </li><li>  <font color="#003399">KeyPairGenerator</font> keyGen <font color="#339933">=</font> <font color="#003399">KeyPairGenerator</font> .  <font color="#006633">getInstance</font> <font color="#009900">(</font> <font color="#0000ff">"RSA"</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li>  keyGen.  <font color="#006633">initialize</font> <font color="#009900">(</font> Config. <font color="#006633">CRYPTO_KEY_NUM_BITS</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Generate a bundle</font> </li><li>  m_KeyPair <font color="#339933">=</font> keyGen.  <font color="#006633">genKeyPair</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  <font color="#666666">// Get public and private keys</font> </li><li>  m_InternPublicKey <font color="#339933">=</font> <font color="#009900">(</font> <font color="#003399">RSAPublicKey</font> <font color="#009900">)</font> <font color="#003399">KeyFactory</font> .  <font color="#006633">getInstance</font> <font color="#009900">(</font> <font color="#0000ff">"RSA"</font> <font color="#009900">)</font> .  <font color="#006633">generatePublic</font> <font color="#009900">(</font> </li><li>  <font color="#000000">new</font> <font color="#003399">X509EncodedKeySpec</font> <font color="#009900">(</font> m_KeyPair. <font color="#006633">getPublic</font> <font color="#009900">(</font> <font color="#009900">)</font> . <font color="#006633">getEncoded</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  m_InternPrivateKey <font color="#339933">=</font> <font color="#009900">(</font> <font color="#003399">RSAPrivateKey</font> <font color="#009900">)</font> <font color="#003399">KeyFactory</font> .  <font color="#006633">getInstance</font> <font color="#009900">(</font> <font color="#0000ff">"RSA"</font> <font color="#009900">)</font> .  <font color="#006633">generatePrivate</font> <font color="#009900">(</font> </li><li>  <font color="#000000">new</font> <font color="#003399">PKCS8EncodedKeySpec</font> <font color="#009900">(</font> m_KeyPair. <font color="#006633">getPrivate</font> <font color="#009900">(</font> <font color="#009900">)</font> . <font color="#006633">getEncoded</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#339933">;</font> </li></ol></blockquote><br><br>  I think everything is clear.  Although, of course, if you go deeper, you definitely need to google on the subject of creatures such as <a href="http://ru.wikipedia.org/wiki/X.509">X509</a> and <a href="http://en.wikipedia.org/wiki/PKCS">PKCS8</a> (X509EncodedKeySpec and PKCS8EncodedKeySpec). <br><br>  The next step is to send the keys to the server.  This is done in almost the same way as in the case of a client (Java): <br><br><blockquote><ol><li>  <font color="#666666">// Write the length of the exponent -&gt; exponent -&gt; module</font> </li><li>  bao.  <font color="#006633">write</font> <font color="#009900">(</font> exponent. <font color="#006633">length</font> <font color="#339933">&amp;</font> 0xff <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// write as byte</font> </li><li>  bao.  <font color="#006633">write</font> <font color="#009900">(</font> exponent <font color="#009900">)</font> <font color="#339933">;</font> </li><li>  bao.  <font color="#006633">write</font> <font color="#009900">(</font> modulus <font color="#009900">)</font> <font color="#339933">;</font> </li></ol></blockquote><br><br>  And finally, we get the key on the client side, read it and save it (C #): <br><br><blockquote><ol><li> <font color="#FF0000">Byte</font> expLength <font color="#008000">=</font> packet.  <font color="#0000FF">ReadByte</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#FF0000">byte</font> <font color="#000000">[</font> <font color="#000000">]</font> exponent <font color="#008000">=</font> <font color="#008000">new</font> <font color="#FF0000">byte</font> <font color="#000000">[</font> expLength <font color="#000000">]</font> <font color="#008000">;</font> </li><li>  Buffer  <font color="#0000FF">BlockCopy</font> <font color="#000000">(</font> packet. <font color="#0000FF">Bytes</font> , packet. <font color="#0000FF">Offset</font> , exponent, <font color="#FF0000">0</font> , expLength <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#FF0000">byte</font> <font color="#000000">[</font> <font color="#000000">]</font> modulus <font color="#008000">=</font> <font color="#008000">new</font> <font color="#FF0000">byte</font> <font color="#000000">[</font> packet.  <font color="#0000FF">Bytes</font> .  <font color="#0000FF">Length</font> <font color="#008000">-</font> <font color="#000000">(</font> packet. <font color="#0000FF">Offset</font> <font color="#008000">+</font> expLength <font color="#000000">)</font> <font color="#008000">-</font> <font color="#FF0000">1</font> <font color="#000000">]</font> <font color="#008000">;</font> </li><li>  Buffer  <font color="#0000FF">BlockCopy</font> <font color="#000000">(</font> packet. <font color="#0000FF">Bytes</font> , packet. <font color="#0000FF">Offset</font> <font color="#008000">+</font> expLength <font color="#008000">+</font> <font color="#FF0000">1</font> , modulus, <font color="#FF0000">0</font> , modulus. <font color="#0000FF">Length</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  m_ExternKey <font color="#008000">=</font> <font color="#008000">new</font> RSAParameters <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  m_ExternKey.  <font color="#0000FF">Exponent</font> <font color="#008000">=</font> exponent <font color="#008000">;</font> </li><li>  m_ExternKey.  <font color="#0000FF">Modulus</font> <font color="#008000">=</font> modulus <font color="#008000">;</font> </li></ol></blockquote><br><br>  That's all.  The client now has the server's public key in the <font color="green">m_ExternKey</font> variable, and the server has the client's public key in the <font color="green">m_ExternPublicKey</font> variable.  It remains only to organize the transfer of data.  It becomes even simpler (C #): <br><br><blockquote><ol><li>  <font color="#008080">// Import the key</font> </li><li>  m_rsa.  <font color="#0000FF">ImportParameters</font> <font color="#000000">(</font> m_ExternKey <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#008080">// Encrypt and write encrypted data to the buffer</font> </li><li>  buffer.  <font color="#0000FF">Write</font> <font color="#000000">(</font> m_Rsa. <font color="#0000FF">Encrypt</font> <font color="#000000">(</font> bytesToEncrypt, <font color="#0600FF">false</font> <font color="#000000">)</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  In the case of the server a little more complicated (Java): <br><br><blockquote><ol><li>  <font color="#000066">byte</font> <font color="#009900">[</font> <font color="#009900">]</font> cipherText <font color="#339933">=</font> <font color="#000066">null</font> <font color="#339933">;</font> </li><li>  Cipher cipher <font color="#339933">=</font> Cipher.  <font color="#006633">getInstance</font> <font color="#009900">(</font> <font color="#0000ff">"RSA / ECB / PKCS1Padding"</font> <font color="#009900">)</font> <font color="#339933">;</font> </li><li>  cipher  <font color="#006633">init</font> <font color="#009900">(</font> Cipher. <font color="#006633">ENCRYPT_MODE</font> , m_ExternPublicKey <font color="#009900">)</font> <font color="#339933">;</font> </li><li>  cipherText <font color="#339933">=</font> cipher.  <font color="#006633">doFinal</font> <font color="#009900">(</font> tempBytes <font color="#009900">)</font> <font color="#339933">;</font> </li><li></li><li>  bao.  <font color="#006633">write</font> <font color="#009900">(</font> cipherText <font color="#009900">)</font> <font color="#339933">;</font> </li></ol></blockquote><br><br>  The encrypted message is ready to be sent and decrypted by the recipient using the private key.  The only thing you should not forget is that the maximum message size that can be encrypted is equal to the key size minus 11 bytes.  Therefore, when encrypting, it is necessary to divide the data into blocks and encrypt them one by one.  Here is an example in C #: <br><br><blockquote><ol><li>  m_rsa.  <font color="#0000FF">ImportParameters</font> <font color="#000000">(</font> m_ExternKey <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  ByteBuffer buffer <font color="#008000">=</font> <font color="#008000">new</font> ByteBuffer <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#FF0000">int</font> dataLength <font color="#008000">=</font> bytesToEncrypt.  <font color="#0000FF">Length</font> <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> maxLength <font color="#008000">=</font> <font color="#000000">(</font> m_Rsa. <font color="#0000FF">KeySize</font> <font color="#008000">/</font> <font color="#FF0000">8</font> <font color="#000000">)</font> <font color="#008000">-</font> <font color="#FF0000">12</font> <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> iterations <font color="#008000">=</font> <font color="#000000">(</font> <font color="#FF0000">int</font> <font color="#000000">)</font> math.  <font color="#0000FF">Ceiling</font> <font color="#000000">(</font> <font color="#000000">(</font> <font color="#FF0000">float</font> <font color="#000000">)</font> bytesToEncrypt. <font color="#0000FF">Length</font> <font color="#008000">/</font> maxLength <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> Int32 i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> iterations <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">byte</font> <font color="#000000">[</font> <font color="#000000">]</font> tempBytes <font color="#008000">=</font> <font color="#008000">new</font> <font color="#FF0000">byte</font> <font color="#000000">[</font> </li><li>  <font color="#000000">(</font> dataLength <font color="#008000">-</font> maxLength <font color="#008000">*</font> i <font color="#008000">&gt;</font> maxLength <font color="#000000">)</font> <font color="#008000">?</font>  maxLength <font color="#008000">:</font> </li><li>  dataLength <font color="#008000">-</font> maxLength <font color="#008000">*</font> i <font color="#000000">]</font> <font color="#008000">;</font> </li><li></li><li>  Buffer  <font color="#0000FF">BlockCopy</font> <font color="#000000">(</font> bytesToEncrypt, maxLength <font color="#008000">*</font> i, tempBytes, <font color="#FF0000">0</font> , </li><li>  tempBytes.  <font color="#0000FF">Length</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  buffer.  <font color="#0000FF">PutEnd</font> <font color="#000000">(</font> m_Rsa. <font color="#0000FF">Encrypt</font> <font color="#000000">(</font> tempBytes, <font color="#0600FF">false</font> <font color="#000000">)</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li></li><li>  <font color="#0600FF">return</font> buffer.  <font color="#0000FF">Array</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  In Java, implement it yourself, there are changes - a couple of lines :) <br><br>  Of course, within the framework of this article I will not be able to cover the entire volume of the implementation of this functionality, but, I think, now you definitely have an idea of ‚Äã‚Äãhow to implement a secure channel for your clients using the RSA algorithm. <br><br></div><p>Source: <a href="https://habr.com/ru/post/90125/">https://habr.com/ru/post/90125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../90113/index.html">Evernote for iPad saw the light</a></li>
<li><a href="../90117/index.html">Every Google I / O visitor will receive a free Droid or Nexus in advance.</a></li>
<li><a href="../90121/index.html">The world's first "tablet phone"</a></li>
<li><a href="../90122/index.html">Creating a cascading menu with shortcuts to your favorite applications in the context menu of Windows 7</a></li>
<li><a href="../90123/index.html">DEVCONF 2010 - unique masterclasses and we extend the acceptance of applications for reports until April 12</a></li>
<li><a href="../90127/index.html">DEVCONF :: Perl - May 17, 2010 - call for applications extended to April 12</a></li>
<li><a href="../90130/index.html">Russian-English or a few words about the spelling of two languages ‚Äã‚Äãat once</a></li>
<li><a href="../90131/index.html">Federal Bailiff Service Opens Access to Debt Information</a></li>
<li><a href="../90138/index.html">Strange letters</a></li>
<li><a href="../90139/index.html">Microsoft for PHP programmers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>