<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Django-orm in search of LEFT JOIN</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It has long been no longer a secret that Django-ORM as a whole is stupid as a stick and is not capable of solving less serious tasks, and is especiall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Django-orm in search of LEFT JOIN</h1><div class="post__text post__text-html js-mediator-article">  It has long been no longer a secret that Django-ORM as a whole is stupid as a stick and is not capable of solving less serious tasks, and is especially stupid in those cases when it is necessary to influence from the outside on the formation of reasonable SQL queries.  About one of these cases and how I tried to deal with this - I will tell under the cut. <br><a name="habracut"></a><br>  It all started with the fact that picking the TecDoc database inspired me with the idea of ‚Äã‚Äãimplementing my own translation storage system in the database.  Without hesitation, I put up such models for the translation application and one for bullying: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translations</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(models.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span> text = models.TextField(null=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, blank=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) lng = models.SlugField(max_length=<span class="hljs-number"><span class="hljs-number">32</span></span>, choices=settings.LANGUAGES, db_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) des = models.ForeignKey(<span class="hljs-string"><span class="hljs-string">"Designations"</span></span>, db_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, related_name=<span class="hljs-string"><span class="hljs-string">'translations'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> verbose_name = _(<span class="hljs-string"><span class="hljs-string">"translation"</span></span>) verbose_name_plural = _(<span class="hljs-string"><span class="hljs-string">"translations"</span></span>) ordering = [<span class="hljs-string"><span class="hljs-string">'lng'</span></span>] <span class="hljs-comment"><span class="hljs-comment"># db_table='mlang_translations' class Designations(models.Model): "  ()     id" class Meta: verbose_name = _("designation") verbose_name_plural = _("designations") # db_table='mlang_designations' class Page(MPTTModel): content = models.ForeignKey('mlang.Designations', null=True, blank=True, related_name="+") keywords = models.ForeignKey('mlang.Designations', null=True, blank=True, related_name="+") description = models.ForeignKey('mlang.Designations', null=True, blank=True, related_name="+") title = models.ForeignKey('mlang.Designations', null=True, blank=True, related_name="+") code = models.CharField(max_length=256, db_index=True) parent = TreeForeignKey('self', null=True, blank=True) # db_table='flatpages_page'</span></span></code> </pre> <br><br>  It works as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many models refer to translation labels, after which you can get a translation for a field in one of the languages.  The number of requests in the simplest case will be <code>1 +  ,    *    </code> . <br>  As can be seen from the description of the models, the translated fields and the translations themselves refer to the same label, which makes it easy to force the label itself when selecting translations by direct JOIN of the translation to the desired field.  And this is where the tambourine dances begin. <br><br>  Perhaps we will start with the ‚Äúhead on‚Äù option, which is better not to use if there are no other options: <a href="https://docs.djangoproject.com/en/dev/topics/db/sql/">QuerySet.raw</a> and we get this code: <br><br><pre> <code class="python hljs">Page.objects.raw(<span class="hljs-string"><span class="hljs-string">""" select fpage.id id, content_translated.text content_translated, title_translated.text title_translated, keywords_translated.text keywords_translated, description_translated.text description_translated from flatpages_page fpage left join mlang_translations content_translated on fpage.content_id=content_translated.des_id and content_translated.lng=%s left join mlang_translations description_translated on fpage.description_id=description_translated.des_id and description_translated.lng=%s left join mlang_translations keywords_translated on fpage.keywords_id=keywords_translated.des_id and keywords_translated.lng=%s left join mlang_translations title_translated on fpage.title_id=title_translated.des_id and title_translated.lng=%s """</span></span>, params=[<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru"</span></span>])</code> </pre><br><br>  I do not need to paint pros and cons of this approach. <br>  Naturally, if there are many models and / or you need to receive translations in several views, and / or the fields change at some point, this will be a nightmare in reality. <br><br>  We are starting to actively google on the topic <code>django orm left join</code> order to get an equivalent SQL query, but the python / django way. <br><br>  The first thing that caught my eye was to fake a Q object, so that it turned into a LEFT JOIN: <a href="https://djangosnippets.org/snippets/257/">QLeftOuterJoin</a> , and if you google longer and more attentively, you can see that this solution is as old as mammoths and from about 2010 it does not work.  Attempts to launch success were unsuccessful. <br><br>  then, in Google‚Äôs output, we encounter a certain ‚Äú <a href="http://www.caktusgroup.com/blog/2009/09/28/custom-joins-with-djangos-queryjoin/">hack</a> ‚Äù out of the box above the QuerySet.query, which by standard means allows us to embed a custom INNER / LEFT JOIN into the QuerySet and for our experimental sample the code will look like this: <br><br><pre> <code class="python hljs"> qs = Page.objects.filter(id__isnull=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ,    . for field in Page._meta.local_fields: if field.rel is not None and field.rel.to is Designations: join = qs.query.join( (Page._meta.db_table, Translations._meta.db_table, ((field.name+'_id', 'des_id'),)), nullable=True, #  LEFT JOIN join_field=Translations._meta.get_field_by_name('des')[0] ) qs = qs.extra( select={ field.name+"_translated": join+'.text' }, where=[join+".lng=%s"], params=['ru'] )</span></span></code> </pre><br><br>  I'll tell you what's going on here: we iterate over all the fields of the Page model and for each ForeignKey (Designations) we generate a unique JOIN.  The docstring query.join says: <br><blockquote>  'join_cols' is a tuple of tuples containing columns to join on ((l_id1, r_id1), (l_id2, r_id2)) </blockquote><br>  Those.  With the 3rd element of the first argument, we can transfer a set of connecting fields for the condition, BUT we cannot do filtering within JOIN.  In consequence of this, where and param appeared in the qs.extra call, in our turn all our LEFT JOIN was broken into the usual INNER JOIN of the form: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> flatpages_pages, mlang_translations t1, mlang_translations_t2, ..... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t1.lng=<span class="hljs-string"><span class="hljs-string">'ru'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> t2.lng=<span class="hljs-string"><span class="hljs-string">'ru'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ......</code> </pre><br><br>  On the one hand, we can say - this is a feature, if one field is not translated, then we hide the entire record and give it to 404.  On the other hand, this is not the behavior that I want by default. <br><br>  Well, okay, go ahead with the normal django way described in the documentation: <a href="https://docs.djangoproject.com/en/dev/ref/models/querysets/">QuerySet.extra</a> and write the following auxiliary function to automatically generate translations for the desired model: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, lng, exclude=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> exclude <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(exclude, (list, tuple, set, frozenset,)): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'exclude must be iterable'</span></span>) fields = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> model._meta.fields: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field.rel <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> field.rel.to <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Designations: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> exclude <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> field.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> exclude: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> fields.append( [field.name, map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], field.rel.get_joining_columns())[<span class="hljs-number"><span class="hljs-number">0</span></span>]] ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> fields: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dict( tables=[ <span class="hljs-string"><span class="hljs-string">'"{trans._meta.db_table}" AS "trans_{pos}"'</span></span>.format(trans=Translations, pos=pos) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos, val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(fields) ], select={ column[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">"_translated"</span></span>: <span class="hljs-string"><span class="hljs-string">"trans_{0}.text"</span></span>.format(pos) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos, column <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(fields) }, where=[ <span class="hljs-string"><span class="hljs-string">"{model._meta.db_table}.{column[1]}=trans_{pos}.des_id and trans_{pos}.lng=%s"</span></span>.format(pos=pos, column=column, model=model) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos, column <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(fields) ], params=[lng] * len(fields) )</code> </pre><br><br>  It works quite simply: it iterates all the ForeignKey (Designations) from the transferred model and fills the dictionary for transfer to QuerySet.extra and the result is the following call: <br><br><pre> <code class="python hljs">Page.objects.extra(**translate(Page, lng))</code> </pre><br><br>  It looks beautiful, BUT these are the same eggs only in profile as in P2, only the thoroughbred INNER JOIN in the query text ... <br><br>  <b>upd:</b> As promised, I supplement the article with new and final results of the search for answers. <br><br>  All the above methods relied mainly on the documentation and some of the ‚Äúhacks‚Äù without much detail in how it works in general. <br>  So, if you look at the sources of the Query class in django.db.models.sql.query in particular, the join function itself can be noticed that the work with alias_map and join_map dictionaries is not bad.  join_map is nothing more than an ordinary dictionary where the tuples go, which we pass with the 1st argument when calling join, and the value is the alias tuple for the exact identification of join in the query.  alias_map uses the same alias as keys, and the descriptor of JOIN itself, which later will be converted to SQL.  The type and format of dexryptor is reduced to the form: <br><pre> <code class="python hljs">JoinInfo = namedtuple(<span class="hljs-string"><span class="hljs-string">'JoinInfo'</span></span>, <span class="hljs-string"><span class="hljs-string">'table_name rhs_alias join_type lhs_alias '</span></span> <span class="hljs-string"><span class="hljs-string">'join_cols nullable join_field'</span></span>)</code> </pre><br>  The conversion to SQL itself is hard-hardened, which completely eliminates the possibility of no-one monkey patching in the depths of django to add the ability to generate JOINs in smarter than <br><pre> <code class="sql hljs">LEFT OUTER JOIN table alias ON main_table.field=alias.field</code> </pre><br><br>  BUT, there is one weighty but: <br>  In pursuit of an elegant solution, I managed to overlook the fact that our left join from paragraph 2 as a whole is fully working and meets all the requirements, but is a little under-appreciated.  As written in all SQL: LEFT JOIN textbooks, NULL substitutes for all missing right samples, and therefore we can expand the WHERE condition so that n2 becomes an adequate JEFT JOIN equivalent to what was described at the very beginning of the article.  And the code from n2 will look like this: <br><pre> <code class="python hljs"> qs = Page.objects.filter(id__isnull=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    for field in Page._meta.local_fields: if field.rel is not None and field.rel.to is Designations: alias = qs.query.join( (Page._meta.db_table, Translations._meta.db_table, ((field.name+"_id", 'des_id',),)), nullable=True, join_field=Translations._meta.get_field_by_name("des")[0] ) qs = qs.extra( select={field.name+"_translated": alias+'.text'}, where=["{0}.lng='{1}' or {0}.lng is null".format(alias, 'ru')], #  or lng is null )</span></span></code> </pre><br>  at the output, we get data that are absolutely identical to SQL from Query.raw, only WHERE was complicated by transferring the filtering by language here, which diminished the readability of the final SQL and I can not unequivocally say how this affects the speed of execution of SQL at the database level relative to the original one.  In general, we can say that the problem was solved, I was able to get rid of a huge number of unnecessary queries to the database by building smarter queries to the database without writing pure SQL, which in turn guarantees the portability of the code between different DBMS. <br><br>  PS: I hope someone this little research will help to sleep more calmly. <br>  The source can be found on <a href="https://github.com/alexandr-nino/demo_ehop">github.com</a> . </div><p>Source: <a href="https://habr.com/ru/post/230507/">https://habr.com/ru/post/230507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230497/index.html">Announcement of the second meeting of Java User Group Ekaterinburg</a></li>
<li><a href="../230499/index.html">Jibo: ‚Äúsocial‚Äù robot for the whole family</a></li>
<li><a href="../230501/index.html">Animations on lambdas in C ++ 11</a></li>
<li><a href="../230503/index.html">Master in the USA. Fulbright Graduate Student Program. Part 1</a></li>
<li><a href="../230505/index.html">Why a Win32 application manifest?</a></li>
<li><a href="../230511/index.html">Unlocking a Lenovo Phone by Depth Methods</a></li>
<li><a href="../230513/index.html">CentOS 7 Overview. Part 1: Linux Containers</a></li>
<li><a href="../230515/index.html">How and why to protect Internet access in the enterprise - part 1</a></li>
<li><a href="../230517/index.html">Using OpenVPN TAP Interface on Synology NAS (with certificate authentication)</a></li>
<li><a href="../230519/index.html">The path to continuous integration. Selenium + TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>