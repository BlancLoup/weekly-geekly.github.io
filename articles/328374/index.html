<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thread safe std :: map with lock-free map performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Case studies and testing of a stream-safe pointer and contention-free shared-mutex 
 In this article, we show: additional optimizations, examples of u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thread safe std :: map with lock-free map performance</h1><div class="post__text post__text-html js-mediator-article"><h3>  <b>Case studies and testing of a stream-safe pointer and contention-free shared-mutex</b> </h3><br>  In this article, we show: additional optimizations, examples of use and testing of a thread-safe pointer developed by us with an optimized shared mutex. <b>Contfree_safe_ptr &lt;T&gt;</b> is equivalent to <b>safe_ptr &lt;T, contention_free_shared_mutex &lt;&gt;&gt;</b> <br>  At the end we will show comparative graphs of tests of our thread-safe pointer and one of the best lock-free algorithms from libCDS on Intel Core i5 / i7, Xeon, 2 x Xeon processors. <br><a name="habracut"></a><br>  Three related articles: <br><br><ol><li>  <a href="https://habrahabr.ru/post/328348/">Making any object thread safe</a> </li><li>  <a href="https://habrahabr.ru/post/328362/">Accelerate std :: shared_mutex 10 times</a> </li><li>  Thread safe std :: map with lock-free map performance </li></ol><br>  ‚Üí <a href="https://www.codeproject.com/Articles/1183446/Thread-safe-std-map-with-the-speed-of-lock-free-ma">My article in English</a> <br>  ‚Üí <a href="https://github.com/AlexeyAB/object_threadsafe">Examples and tests from all three articles</a> <br><br>  You can find the libCDS library with which we will compare our solution at the link: <a href="https://github.com/khizmax/libcds">github.com/khizmax/libcds</a> <br>  All tests in this article use this commit from libCDS: <a href="https://github.com/khizmax/libcds/tree/5e2a9854b0a8625183818eb8ad91e5511fed5898">github.com/khizmax/libcds/tree/5e2a9854b0a8625183818eb8ad91e5511fed5898</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <b>Different granularity of locks</b> </h2><br>  First, we will show how to optimally use shared-mutex, using the example of working with a table (an array of structures).  Referring to the experience of industrial databases.  For example, in the MSSQL DBMS, locks of different granularity are used ‚Äî a lock: one or several rows, a page, a extent, one section of a table, an index, the entire table, the entire database.  <a href="https://technet.microsoft.com/en-us/library/ms189849(v%3Dsql.105).aspx">https://technet.microsoft.com/en-us/library/ms189849 (v=sql.105).aspx</a> <br><br>  Indeed, if we work with one row for a long time and it is important for us that at this time the row is not changed by another thread, then there is no need to block the entire table all this time - it is enough to block only 1 row. <br><br><ul><li>  Lock the entire table with shared locking (shared) </li><li>  We are looking for the desired line or several lines. </li><li>  Then we block the found string. </li><li>  Unlock the table </li><li>  And working with a locked string </li></ul><br>  Then other threads will be able to work in parallel with the other lines. <br>  So far, we have only used table level locking, i.e.  blocked one or more tables. <br><br>  Or all the tables used in the expression were automatically locked until it was fully completed. <br><br><pre><code class="cpp hljs">(*safe_map_1)[<span class="hljs-string"><span class="hljs-string">"apple"</span></span>].first = <span class="hljs-string"><span class="hljs-string">"fruit"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// locked Table-1 (safe_map_1) // unlocked Table-1 safe_map_1-&gt;at("apple").second = safe_map_1-&gt;at("apple").second * 2; // locked Table-1 (safe_map_1) // unlocked Table-1 safe_map_1-&gt;at("apple").second = safe_map_2-&gt;at("apple").second*2; // locked Table-1(safe_map_1) and Table-2(safe_map_2) // unlocked Table-1 and Table-2</span></span></code> </pre> <br>  In other cases, we manually locked one or more tables using the RAII objects of the lock until the end of the <a href="http://en.cppreference.com/w/cpp/language/scope">scope of</a> these locks (until they are destroyed): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(safe_map_1)&gt; lock(safe_map_1); <span class="hljs-comment"><span class="hljs-comment">// locked Table-1 (safe_map_1) (*safe_map_1)["apple"].first = "fruit"; safe_map_1-&gt;at("apple").second = safe_map_1-&gt;at("apple").second * 2; // unlocked Table-1 } { lock_timed_any_infinity lock_all(safe_map_1, safe_map_2); // locked Table-1(safe_map_1) and Table-2(safe_map_2) safe_map_1-&gt;at("apple").second = safe_map_2-&gt;at("apple").second*2; //locked Table-1(safe_map_1) and Table-2(safe_map_2) safe_map_1-&gt;at("potato").second = safe_map_2-&gt;at("potato").second*2; //locked Table-1(safe_map_1) and Table-2(safe_map_2) // unlocked Table-1 and Table-2 }</span></span></code> </pre> <br>  Let's look at an example in which we randomly select an index to insert, then randomly one of four operations (insert, delete, update, read) and perform it on a thread-safe object of type <b>contfree_safe_ptr &lt;std :: map&gt;</b> . <br><br>  Example: [37] <a href="http://coliru.stacked-crooked.com/a/5b68b65bf2c5abeb">coliru.stacked-crooked.com/a/5b68b65bf2c5abeb</a> <br><br>  In this case, we will impose the following locks on the table: <br><br><ul><li>  Insert - eXclusive lock </li><li>  Delete - eXclusive lock </li><li>  Update - eXclusive lock </li><li>  Read - Shared lock </li></ul><br>  For Update or Read operations, we do: <br><br><ol><li>  Lock the entire table (xlock for Update, slock for Read) </li><li>  We search for the necessary line, we read or we change it </li><li>  Unlock the table </li></ol><br>  One iteration code of our example is 1: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rnd_index = index_distribution(generator); <span class="hljs-comment"><span class="hljs-comment">// 0 - container_size int const num_op = operation_distribution(generator);// insert_op, update_op, delete_op, read_op switch (num_op) { case insert_op: { safe_map-&gt;emplace(rnd_index, (field_t(rnd_index, rnd_index))); // insert with X-lock on Table break; } case delete_op: { size_t erased_elements = safe_map-&gt;erase(rnd_index); // erase with X-lock on Table } break; case update_op: { auto x_safe_map = xlock_safe_ptr(safe_map); // X-lock on Table auto it = x_safe_map-&gt;find(rnd_index); if (it != x_safe_map-&gt;cend()) { it-&gt;second.money += rnd_index; // still X-lock on Table (must necessarily be) } } break; case read_op: { auto s_safe_map = slock_safe_ptr(safe_map); // S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) { volatile int money = it-&gt;second.money; // still S-lock on Table (must necessarily be) // volatile here only to avoid optimization for unused money-variable } } break; default: std::cout &lt;&lt; "\n wrong way! \n"; break; }</span></span></code> </pre> <br>  Now we will make it so that during the Update operation the table is blocked by the read lock (shared), instead of the change lock (exclusive).  This will greatly speed up Update operations when using our ‚Äúwrite contention free shared mutex‚Äù that we developed earlier. <br>  In this case, multiple threads can simultaneously perform Update and Read operations on a single table.  For example, one thread reads one line, and another thread changes another line.  But if one thread tries to change the same line that another thread is reading, then in order to avoid Data-races we have to block the line itself when reading it and changing it. <br><br>  Example: [38] <a href="http://coliru.stacked-crooked.com/a/89f5ebd2d96296d3">coliru.stacked-crooked.com/a/89f5ebd2d96296d3</a> <br><br>  Now for Update or Read operations we do: <br><br><ol><li>  Lock the entire table with shared locking (shared) </li><li>  We are looking for the desired line or several lines. </li><li>  Then we block the found string (xlock for Update, slock for Read) </li><li>  And we work with a locked row (X / S-lock) and a locked table (S-lock) </li><li>  Unlock the string </li><li>  Unlock the table </li></ol><br>  Diff - what we changed: <br><br><img src="https://hsto.org/files/824/89e/c8d/82489ec8d82146f98879cfbbcc26080e.jpg" alt="image"><br><br>  One iteration code for our example is 2: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rnd_index = index_distribution(generator); <span class="hljs-comment"><span class="hljs-comment">// 0 - container_size int const num_op = operation_distribution(generator);// insert_op, update_op, delete_op, read_op switch (num_op) { case insert_op: { safe_map-&gt;emplace(rnd_index, (field_t(rnd_index, rnd_index))); // insert with X-lock on Table break; } case delete_op: { size_t erased_elements = safe_map-&gt;erase(rnd_index); // erase with X-lock on Table } break; case update_op: { auto s_safe_map = slock_safe_ptr(safe_map); // S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) { auto x_field = xlock_safe_ptr(it-&gt;second); x_field-&gt;money += rnd_index; // X-lock on field, still S-lock on Table (must necessarily be) } } break; case read_op: { auto s_safe_map = slock_safe_ptr(safe_map); // S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) { auto s_field = slock_safe_ptr(it-&gt;second); volatile int money = s_field-&gt;money; // S-lock on field, still S-lock on Table (must necessarily be) // volatile here only to avoid optimization for unused money-variable } } break; default: std::cout &lt;&lt; "\n wrong way! \n"; break; }</span></span></code> </pre> <br>  Here, for thread-safe string handling, we used safe_obj.  Inside safe_obj &lt;T&gt; there is an object of type T, and not a pointer to it, as in safe_ptr &lt;T&gt;.  Therefore, when using safe_obj, you do not need to separately allocate memory for the object itself and change the atomic reference counter, as is required in safe_ptr.  Therefore, the Insert and Delete operations are performed much faster with safe_obj than with safe_ptr. <br><br>  It should be noted that when copying safe_obj, not the pointer to the object is copied, but the object itself is copied, while previously blocking the initial and final safe_obj. <br><br>  Note: Strictly speaking, we do not block the entire line, but all fields of the line, except for the index of the line we are looking for.  Therefore, we called our object field, not row.  And also, to emphasize that in this way we can block not only one line, but even individual fields in one line, if we place them in separate safe_obj objects.  This would allow different threads to block different fields and work with them in parallel. <br><br>  Now we use the following locks for different operations: <br><br><img src="https://hsto.org/files/79a/474/8b9/79a4748b9de14de981ec5a8656013ad1.jpg" alt="image"><br><br>  This example is very fast for a large number of short time operations.  But we still hold the read lock (shared) on the table in the process of changing or reading a row (field).  And if we have rare but very long operations on the rows of the table, then all of this will hold the lock on the entire table for a long time. <br><br>  However, if according to the logic of your task it doesn‚Äôt matter that a row can be deleted by one thread, while another thread is reading or modifying the same row, then we only need to block the table for the duration of the search row.  And to avoid accessing the freed memory when another thread has deleted a string, we need to use std :: shared_ptr &lt;T&gt; - a pointer with an atomic thread-safe reference counter.  In this case, the memory will be released only when no thread has pointers to this string. <br><br>  Instead of safe_obj, we will use safe_ptr to protect the string.  This will allow us to copy the pointer to the string and use the thread-safe reference counter in std :: shared_ptr &lt;T&gt; which is contained in safe_ptr. <br><br>  Example: [39] <a href="http://coliru.stacked-crooked.com/a/f2a051abfbfd2716">coliru.stacked-crooked.com/a/f2a051abfbfd2716</a> <br><br>  Now for Update or Read operations we do: <br><br><ol><li>  Lock the entire table with shared locking (shared) </li><li>  We are looking for the desired line or several lines. </li><li>  Then we block the found string (xlock for Update, slock for Read) </li><li>  Unlock the table </li><li>  And working with a locked string (X / S-lock) as long as it takes. </li><li>  Unlock the string </li></ol><br>  Diff - what we changed: <br><br><img src="https://hsto.org/files/603/ab9/c93/603ab9c93e2145d49a18af0c9b7b643f.jpg" alt="image"><br><br>  Example-3: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rnd_index = index_distribution(generator); <span class="hljs-comment"><span class="hljs-comment">// 0 - container_size int const num_op = operation_distribution(generator);// insert_op, update_op, delete_op, read_op safe_ptr_field_t safe_nullptr; switch (num_op) { case insert_op: { safe_map-&gt;emplace(rnd_index, (field_t(rnd_index, rnd_index))); // insert with X-lock on Table break; } case delete_op: { size_t erased_elements = safe_map-&gt;erase(rnd_index); // erase with X-lock on Table } break; case update_op: { auto pair_result = [&amp;]() { auto s_safe_map = slock_safe_ptr(safe_map); // S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) return std::make_pair(it-&gt;second, true); // found else return std::make_pair(safe_nullptr, false); // null-value }(); // unlock Table if(pair_result.second) { auto x_field = xlock_safe_ptr(pair_result.first); // X-lock on field x_field-&gt;money += rnd_index; // if a long time is read } // unlock field } break; case read_op: { auto pair_result = [&amp;]() { auto s_safe_map = slock_safe_ptr(safe_map); // S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) return std::make_pair(it-&gt;second, true); // found else return std::make_pair(safe_nullptr, false); // null-value }(); // unlock Table if(pair_result.second) { auto s_field = slock_safe_ptr(pair_result.first); // S-lock on field volatile int money = s_field-&gt;money; // if a long time is read // volatile here only to avoid optimization for unused money-variable } // unlock field } break; default: std::cout &lt;&lt; "\n wrong way! \n"; break; }</span></span></code> </pre> <br>  Well-designed multi-threaded programs use short references to shared objects, so in the future we will use not the last but the penultimate example for short read operations. <br><br><h2>  <b>Disadvantages of Execute Around Idiom</b> </h2><br>  Let's look at possible problems and criticize our code.  In the previous chapter, we looked at a fairly convenient and high-performance example, explicitly setting the type of blocking for Update and Read operations, using functions: <br><br><ul><li>  <b>slock_safe_ptr ()</b> - read only </li><li>  <b>xlock_safe_ptr ()</b> - for reading and editing </li></ul><br>  Here, the lock is held until the end of the life of the <b>lock_obj</b> object returned by these functions: <b>auto lock_obj = slock_safe_ptr (sf_p);</b> <br>  However, for the Insert and Delete operations, implicit locks were used, i.e.  our safe_ptr &lt;std :: map&gt; object was blocked automatically using the Execute Around Pointer idiom, and unlocked immediately after the end of the Insert or Delete operation. <br><br>  Example: [40] <a href="http://coliru.stacked-crooked.com/a/89f5ebd2d96296d3">coliru.stacked-crooked.com/a/89f5ebd2d96296d3</a> <br><br>  But you can forget to use explicit locks on Update and Read operations.  In this case, safe_ptr &lt;std :: map&gt; will be unlocked immediately after the search operation ends, and then you continue to use: <br><br><ol><li>  found iterator that may be invalidated by another thread </li><li>  or found item that can be deleted by another thread </li></ol><br>  To partially solve this problem, instead of safe_ptr &lt;&gt; and safe_obj &lt;&gt;, you can use safe_hide_ptr &lt;&gt; and safe_hide_obj &lt;&gt; - they do not use Execute Around Pointer and you can only access members of the class after explicit blocking: <br><br><pre> <code class="cpp hljs"> safe_hide_obj&lt;<span class="hljs-keyword"><span class="hljs-keyword">field_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">spinlock_t</span></span>&gt; field_hide_tmp; <span class="hljs-comment"><span class="hljs-comment">//safe_obj&lt;field_t, spinlock_t&gt; &amp;field_tmp = field_hide_tmp; // conversion denied - compile-time error //field_hide_tmp-&gt;money = 10; // access denied - compile-time error auto x_field = xlock_safe_ptr(field_hide_tmp); // locked until x_field is alive x_field-&gt;money = 10; // access granted</span></span></code> </pre> <br>  Example: [41] <a href="http://coliru.stacked-crooked.com/a/d65deacecfe2636b">coliru.stacked-crooked.com/a/d65deacecfe2636b</a> <br><br>  If earlier you could be mistaken and write the following - the <b>erroneous</b> code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = safe_map-&gt;find(rnd_index); <span class="hljs-comment"><span class="hljs-comment">// X-lock, find(), X-unlock if (it != s_safe_map-&gt;cend()) volatile int money = it-&gt;second -&gt;money; // X-lock, operator=(), X-unlock</span></span></code> </pre> <br><br>  Now, such a call will not compile and will require explicit blocking of objects ‚Äî the <b>correct</b> code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s_safe_map = slock_safe_ptr(safe_map); <span class="hljs-comment"><span class="hljs-comment">// S-lock on Table auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) { auto s_field = slock_safe_ptr(it-&gt;second); volatile int money = s_field-&gt;money; // S-lock on field, still S-lock on Table // volatile here only to avoid optimization for unused money-variable } // S-unlock Table, S-unlock field</span></span></code> </pre> <br>  However, you still have the danger of using locks as temporary objects ‚Äî <b>not correctly</b> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = slock_safe_ptr(safe_map)-&gt;find(rnd_index); <span class="hljs-comment"><span class="hljs-comment">// S-lock, find(), S-unlock if (it != s_safe_map-&gt;cend()) { volatile int money = slock_safe_ptr(it-&gt;second)-&gt;money; // S-lock, =, S-unlock }</span></span></code> </pre> <br>  You have a choice: <br><br><ul><li>  Use <b>safe_ptr</b> and <b>safe_obj</b> to be able to explicitly or automatically (Execute Around Idiom) block your object </li><li>  Or use <b>safe_hide_ptr</b> and <b>safe_hide_obj</b> leaving only the ability to explicitly block your object. </li></ul><br>  It is up to you what to choose: <br><br><ul><li>  use convenient automatic locking (Execute Around Idiom) </li><li>  or slightly reduce the possibility of making a mistake by explicitly blocking </li></ul><br>  In addition, the following functions are planned to be <b>added</b> to the standard C ++ 17 for <b>std :: map &lt;&gt;</b> : <br><br><ul><li>  <b>insert_or_assign ()</b> - if there is an element then assign, if not, then insert </li><li>  <b>try_emplace ()</b> - if there is no element, then create an element </li><li>  <b>merge ()</b> - merge 2 maps to 1 </li><li>  <b>extract ()</b> - get the element, and remove it from the map </li></ul><br>  The introduction of such functions allows you to perform frequently used composite operations without using iterators - in this case, using Execute Around Idiom will always guarantee the flow-safety of these operations.  In general, avoiding iterators for all containers (except for std :: array and std :: vector arrays) is a big help in building multithreaded programs.  The less often you use iterators, the less likely you are to access an iterator that is invalid by this or another thread.  But the very idea of ‚Äã‚Äãiterators does not contradict the idea of ‚Äã‚Äãmultithreading, for example, the DBMS (Oracle, MSSQL) supports <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2580%25D1%2581%25D0%25BE%25D1%2580_(%25D0%25B1%25D0%25B0%25D0%25B7%25D1%258B_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">cursors</a> (analogs of iterators) and different isolation levels of translations (different consistency of multithreading). <br><br>  But whatever you choose: use Execute Around Idiom, use explicit locks for <b>safe_hide_ptr</b> , discard them and use standard std :: mutex locks ... or even write your own lock-free algorithms - you always have many opportunities to make a mistake. <br><br><img src="https://hsto.org/files/dab/db7/53f/dabdb753f3bb402aae5faef4f4f70f52.jpg" alt="image"><br><br><h2>  <b>We section the table - still we increase productivity</b> </h2><br>  Let's return again to the experience of industrial relational DBMS.  For example, in a DBMS, table partitioning may be used to improve performance.  In this case, instead of the entire table, you can block only the used partition (partition): <a href="https://technet.microsoft.com/en-us/library/ms187504(v%3Dsql.105).aspx">https://technet.microsoft.com/en-us/library/ms187504(v=sql.105).aspx</a> <br><br>  Although the DBMS does not normally lock the entire table for the Delete and Insert operations, and this is always true for Delete operations.  But for Insert operations, it is possible to perform very fast data loading into the table, the necessary condition of which is the exclusive table blocking: <br><br><ul><li>  MS SQL (dbcc traceon (610, -1)): INSERT INTO sales_hist WITH ( <b>TABLOCKX</b> ) </li><li>  Oracle: INSERT / * + <b>APPEND</b> * / INTO sales_hist <br>  <a href="https://docs.oracle.com/cd/E18283_01/server.112/e17120/tables004.htm">https://docs.oracle.com/cd/E18283_01/server.112/e17120/tables004.htm#i1009887</a> <br><blockquote>  Locking Considerations with Direct-Path INSERT <br>  During the INSERT, the database of the partitioned table locks.  If you‚Äôre not in use, you can‚Äôt make it.  But it is supported, but it is supported by the request before the insert operation. </blockquote></li></ul><br>  Since  our task is to create the fastest multithreaded container, then we also blocked the container entirely on Insert / Delete operations.  But now let's try blocking only part of our container. <br><br>  Let's try to implement our own partitioned ordered partitioned_map associative array and see how the performance increases.  We will block in it only the section currently required. <br><br>  The meaning is: <b>std :: map &lt;safe_ptr &lt;std :: map &lt;&gt;&gt;&gt;</b> <br>  Here the first <b>std :: map</b> will be constant and will contain sections (sub-tables). <br>  This will be a very simplified example where the number of sections is set in the constructor and does not change further. <br><br>  Each section is a stream-safe associative array <b>safe_ptr &lt;std :: map &lt;&gt;&gt;</b> . <br><br>  For maximum performance, the number of sections and their ranges must be such that the probability of accessing each section is the same.  If you have a key range of 0 - 1000000, and the read / update / insert / delete requests to the beginning of the range are greater than to the end of the range, then the sections with a small key value should be larger and their ranges smaller.  For example, 3 sections: [0 - 100000], [100001 - 400000], [400001 - 1000000]. <br><br>  But in our examples we will assume that query keys have a uniform distribution. <br>  Section ranges can be set in two ways: <br><br><ul><li>  safe_map_partitioned_t &lt;std :: string, int&gt; safe_map {"a", "f", "k", "p", "u"}; </li></ul><br>  safe_map_partitioned_t &lt;int, int&gt; (0, 100000, 10000); <br>  // set the boundaries of values ‚Äã‚Äã0 - 100000 and step for each section 10000 <br><br>  If, when accessing the container, the key goes beyond the section boundaries, then the request will address the nearest section ‚Äî  The program will work correctly. <br><br>  Example: [42] <a href="http://coliru.stacked-crooked.com/a/fc148b08eb4b0580">coliru.stacked-crooked.com/a/fc148b08eb4b0580</a> <br><br>  Also, for maximum performance, it is necessary to use the previously implemented "contention-free shared-mutex" inside <b>safe_ptr &lt;&gt;</b> , i.e.  the meaning is: <b>std :: map &lt;contfree_safe_ptr &lt;std :: map &lt;&gt;&gt;&gt;</b> <br>  Take the code from the previous example and add the code contfree_safe_ptr from the previous chapter. <br>  Replace: safe_map_partitioned_t &lt;std :: string, std :: pair &lt;std :: string, int &gt;&gt; <br>  To: safe_map_partitioned_t &lt;std :: string, std :: pair &lt;std :: string, int&gt;, contfree_safe_ptr&gt; <br>  Example: [43] <a href="http://coliru.stacked-crooked.com/a/23a1f7a3982063a1">coliru.stacked-crooked.com/a/23a1f7a3982063a1</a> <br>  This class safe_map_partitioned_t &lt;&gt; we did ‚ÄúJust for fun‚Äù, i.e.  It is not recommended to use it in real programs.  We just showed an example of how you can implement your own algorithms based on the contfree_safe_ptr &lt;&gt; pointer and contention_free_shared_mutex &lt;&gt; blocking. <br><br><h2>  <b>How to use</b> </h2><br>  First download the <b>safe_ptr.h</b> file from the repository root: <a href="https://github.com/AlexeyAB/object_threadsafe">github.com/AlexeyAB/object_threadsafe</a> <br>  Then include this file in your cpp-file: <b>#include "safe_ptr.h"</b> <br>  As an optimal use case, we will focus on Example 2 shown above - this is simple and highly productive: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> money, time; <span class="hljs-keyword"><span class="hljs-keyword">field_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t) : money(m), time(t) {} <span class="hljs-keyword"><span class="hljs-keyword">field_t</span></span>() : money(<span class="hljs-number"><span class="hljs-number">0</span></span>), time(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> safe_obj&lt;<span class="hljs-keyword"><span class="hljs-keyword">field_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">spinlock_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">safe_obj_field_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">// thread-safe ordered std::map by using execute around pointer idiom with contention-free shared-lock contfree_safe_ptr&lt; std::map&lt;int, safe_obj_field_t &gt; &gt; safe_map_contfree; bool success_op; switch (num_op) { case insert_op: slock_safe_ptr(test_map)-&gt;find(rnd_index); // find for pre-cache to L1 with temprorary S-lock test_map-&gt;emplace(rnd_index, field_t(rnd_index, rnd_index)); break; case delete_op: slock_safe_ptr(test_map)-&gt;find(rnd_index); // find for pre-cache to L1 with temprorary S-lock success_op = test_map-&gt;erase(rnd_index); break; case read_op: { auto s_safe_map = slock_safe_ptr(test_map); // S-lock on Table (must necessarily be) auto it = s_safe_map-&gt;find(rnd_index); if (it != s_safe_map-&gt;cend()) { auto x_field = xlock_safe_ptr(it-&gt;second); volatile int money = x_field-&gt;money; // get value x_field-&gt;money += 10; // update value } } break; default: std::cout &lt;&lt; "\n wrong way! \n"; break; }</span></span></code> </pre> <br>  <b>Insert and delete - change the map</b> : Because  our slock_safe_ptr () shared lock is as fast as possible, then before the change (insert_op or delete_op) we find the element we need to delete or closest to the one we need to insert using slock_safe_ptr (), which will be unlocked immediately after the find () operation.       ,            -L1    map.    test_map-&gt;emplace()    test_map-&gt;erase()        exclusive-lock    . Insert/delete ‚Äî   ,          ,     ‚Äî        shared-lock  exclusive-lock (       deadlock ‚Äî   ). <br><br> <b>Read and update ‚Äî ( map)      </b> :      (read_op)     ‚Äî         map (   map).       slock_safe_ptr()  map,              map.        s_safe_map,         xlock_safe_ptr()     ,     .  ,      {},   x_field        ,     s_safe_map      map. <br><br>        test_map ‚Äî          ‚Äî       . <br><br>       ,          <b>auto const&amp; some_ptr = test_map;</b> , ,    <b>some_ptr-&gt;find();</b>       (shared lock)     ,          <s><b>some_ptr-&gt;emplace();</b></s>  .            . <br><br>      <b>slock_safe_ptr(test_map)</b> ,    <b>slock_safe_ptr(test_map)-&gt;find();</b> ,     slock_safe_ptr(test_map)-&gt;emplace(); ‚Äî  .            . <br>         . <br><br><h2> <b>    safe_ptr</b> </h2><br>   .        . <br><br>    ‚Äì      (MOps),      0 ‚Äì 90%.           : insert, delete, update (  Update      std::map,       ). ,  15%  ‚Äì   : 5% insert, 5% delete, 5% update, 85% read.  : g++ 4.9.2 (Linux Ubuntu) x86_64 <br><br>       Linux (GCC 4.9.2)  Windows (MSVS2015): <a href="https://github.com/AlexeyAB/object_threadsafe/tree/master/benchmark">github.com/AlexeyAB/object_threadsafe/tree/master/benchmark</a> <br>    Clang++ 3.8.0  Linux    Makefile. <br><br>     16      Intel Xeon E5-2660 v3 2.6 GHz.       : <b>safe&lt;map,contfree&gt;&amp;rowlock</b> . <br><br>       CPU,     : <br><br> <b>numactl --localalloc --cpunodebind=0 ./benchmark 16</b> <br><br>    CPU,   : <b>./benchmark</b> <br><br><img src="https://hsto.org/files/128/eb1/699/128eb1699b5a4c51bb12fa9763d4faba.png" alt="image"><br>  Conclusion: <br><br><ul><li> ,    contfree-  contfree_safe_ptr&lt;map&gt;   ,   std::shared_mutex   safe_ptr&lt;map,std::shared_mutex&gt; </li><li>   ,    15%  std::mutex ,  std::shared_mutex (  safe_ptr&lt;map,std::mutex&gt; ,  safe_ptr&lt;map,std::shared_mutex&gt;) </li><li>   ,    30%   std:map ‚Äì 1 thread   contfree_safe_ptr&lt;map&gt;&amp;rowlock.              .  -       ,        . </li><li>       safe_map_partitioned&lt;,,contfree_safe_ptr&gt;,    ,  ¬´Just-for-fun¬ª ‚Äî         . </li><li>  15% ,  shared-mutex (  contfree_safe_ptr&lt;map&gt; &amp; rowlock)   8.37 Mops,  <b> 10  </b> ,   std::shared_mutex (  safe_ptr&lt;map, std::shared_mutex&gt;),    0.74 Mops. </li></ul><br>   ¬´contention-free shared-mutex¬ª     :   70   contention-free,     exclusive-lock.    ,  ¬´exclusive-lock¬ª std::mutex  ,  std::shared_mutex  15% . <br><br>        , ..       . <br><br>    main.cpp   : <b>const bool measure_latency = true;</b> <br>    : <b>numactl --localalloc --cpunodebind=0 ./benchmark 16</b> <br><img src="https://hsto.org/files/cdd/0ab/652/cdd0ab652e6e4e58ba5ebbf1ed93b5de.png" alt="image"><br><ul><li> ,  std::map &amp; std::mutex   safe_ptr&lt;map,std::mutex&gt;, ..    safe_ptr&lt;&gt;   -   ,    . </li><li>   ,    60% , contfree_safe_ptr&lt;map&gt;&amp;rowlock   ,  contfree_safe_ptr&lt;map&gt;.      ,        contfree_safe_ptr&lt;map&gt;&amp;rowlock     . </li></ul><br><h3> <b>  contfree_safe_ptr&lt;std::map&gt;    CDS-lib   desktop-CPU</b> </h3><br>     desktop-CPU,   . <br><br><img src="https://hsto.org/files/d17/df9/a71/d17df9a717c34b02ba3854d9c4f9c465.png" alt="image"><br><ul><li> ,       contfree_safe_ptr&lt;map&gt;   ,    lock-free-map   CDS-lib. </li><li>   ¬´Just-for-fun¬ª        safe_map_partitioned&lt;,,contfree_safe_ptr&gt;       1.7 . </li></ul><br><h3> <b>  contfree_safe_ptr&lt;std::map&gt;    CDS-lib  server-CPU</b> </h3><br>          CPU,    . <br><br>       Linux (GCC 4.9.2)  Windows (MSVS2015): <a href="https://github.com/AlexeyAB/object_threadsafe/tree/master/CDS_test">github.com/AlexeyAB/object_threadsafe/tree/master/CDS_test</a> <br>    Clang++ 3.8.0  Linux    Makefile. <br><br>      Xeon    ,      ,    : <br><br> <b>numactl --localalloc --cpunodebind=0 ./benchmark 16</b> <br><br>    CPU,   : <b>./benchmark</b> <br><br><img src="https://hsto.org/files/2c5/d6c/93b/2c5d6c93b48c464f8c7d2eb2f2254270.png" alt="image"><br><ul><li>  ,   16       ,      , lock-free   CDS-lib   ,  contfree_safe_ptr&lt;map&gt;.  Those.    lock-free  .       16 ,            8 ,  contfree_safe_ptr&lt;map&gt;  ,  lock-free . </li><li>   ¬´Just-for-fun¬ª-     safe_map_partitioned&lt;,,contfree_safe_ptr&gt;       ,    ,          . </li></ul><br>   ‚Äì      50% . <br><br>    main.cpp   : <b>const bool measure_latency = true;</b> <br>    : <b>numactl --localalloc --cpunodebind=0 ./benchmark 16</b> <br><br><img src="https://hsto.org/files/299/3f3/904/2993f39048694f9799a520c87dfbd5ac.png" alt="image"><br><br>    contfree_safe_ptr&lt;map&gt;     lock-free   8    ,    16  . <br><br><h2> <b>   .</b> </h2><br>          .                 . <br><br>          for(volatile int i = 0; i &lt; 9000; ++i);     - .      100 000        .   Intel Xeon E5-2686 v4 2.3 GHz       20.5 . <br><br>       Linux (GCC 4.9.2)  Windows (MSVS2015)  : <a href="https://github.com/AlexeyAB/object_threadsafe/tree/master/Real_app_bench">github.com/AlexeyAB/object_threadsafe/tree/master/Real_app_bench</a> <br>    Clang++ 3.8.0  Linux    Makefile. <br><br>    2-  : <b>2 x Intel Xeon E5-2686</b> v4 2.3 GHz (Broadwell)    : 36    <b>72  </b> (Hyper Threading). <br><br>     : <br><blockquote> <b>cd libcds <br> make <br> cd‚Ä¶ <br> make <br> ./benchmark</b> </blockquote><br><img src="https://hsto.org/files/4bd/437/949/4bd437949f934c51aa1a8c65e4c664d9.png" alt="image"><br><ul><li>    std::mutex  std::shared_mutex   std::map     lock-free-map    16 .    std::mutex&amp;std::map  std::shared_mutex&amp;std::map  ,   32   . </li><li>    -  contfree_safe_ptr&lt; std::map&lt;&gt; &gt;      lock-free-map    libCDS      1  64.    ,               20   . </li></ul><br><br>     ‚Äî    main.cpp  : <b>const bool measure_latency = true;</b> <br><br>    Linux  : <b>./benchmark</b> <br><br><img src="https://hsto.org/files/8e4/613/c15/8e4613c15d194c95915939cbec3597cb.png" alt="image"><br><ul><li> ,   64  std::mutex        ,   std::shared_mutex. </li><li>   -  contfree_safe_ptr&lt;std::map&lt;&gt;&gt;       lock-free-map   libCDS      1  64.      ,             20   . </li><li>  64    30 ,   20  ‚Äî    ,  10  ‚Äî  .  ,      30%   ,     <b>contfree_safe_ptr&lt;T&gt;</b>     (MOPS  -),   lock-free  libCDS. </li></ul><br>   lock-free  wait-free  (queue, stack ‚Ä¶)  libCDS    ,      . <br><br>  <b>Conclusion:</b> <br><br><ol><li>            , ..           8 ,         CDSlib: <a href="https://github.com/khizmax/libcds">github.com/khizmax/libcds</a> </li><li>    thread-safe    CDSlib ‚Äì  . </li><li>      -      ,         30%   ,          <b>contfree_safe_ptr&lt;&gt;</b>  ,  map-  CDSlib. </li><li>               ,    CDSlib,       <b>contfree_safe_ptr&lt;T&gt;</b> .   ,   lock-free        . </li></ol><br><h2> <b>     </b> </h2><br>           C++      Execute Around Pointer Idiom.                Contention-free shared-mutex.      lock-free   libCDS  lock-based   . <br><br>  ,     <b>safe_ptr.h</b> ,          : <a href="https://github.com/AlexeyAB/object_threadsafe">github.com/AlexeyAB/object_threadsafe</a> <br><br>               boost? </div><p>Source: <a href="https://habr.com/ru/post/328374/">https://habr.com/ru/post/328374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328364/index.html">Crystal High Performance Services, Newbie Introduction</a></li>
<li><a href="../328366/index.html">Build 2017: text translation. Day 2</a></li>
<li><a href="../328368/index.html">Distributed data structures (part 2, how it's done)</a></li>
<li><a href="../328370/index.html">Should I buy ECC memory?</a></li>
<li><a href="../328372/index.html">Metrics in machine learning tasks</a></li>
<li><a href="../328376/index.html">As an open password field in registration forms increases conversion</a></li>
<li><a href="../328378/index.html">Key announcements of the first day of the Build 2017 conference</a></li>
<li><a href="../328380/index.html">Docker in China: usage statistics and success stories</a></li>
<li><a href="../328382/index.html">Burp Suite: Swiss Army Knife for Testing Web Applications</a></li>
<li><a href="../328384/index.html">New possible leader among the leading cloud providers - Penguin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>