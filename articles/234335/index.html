<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is the use of ZooKeeper for admins and developers. Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Andrey Stepachev. At the end of last year, I spoke to my colleagues with a short story about what ZooKeeper is and how it can be use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is the use of ZooKeeper for admins and developers. Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello!  My name is Andrey Stepachev.  At the end of last year, I spoke to my colleagues with a short story about what <a href="http://zookeeper.apache.org/">ZooKeeper</a> is and how it can be used.  The report was originally designed for a wide range of audiences and can be useful for developers and administrators who want to figure out how it all works. </p><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><p>  Let's start with the story of the appearance of ZooKeeper.  First, as you know, Google wrote the <a href="http://research.google.com/archive/chubby.html">Chubby</a> service to manage their servers and their configuration.  At the same time solved the problem with distributed locks.  But Chubby had one peculiarity: in order to capture the locks, it was necessary to open the object, then close it.  Performance suffered from this.  Yahoo considered that they needed a tool with which they could build various systems for their cluster configurations.  This is the main purpose of ZooKeeper - storage and configuration management of certain systems, and locks turned out as a by-product.  As a result, the whole system was created to build various primitive synchronizations with client code.  In ZooKeeper itself, there are no obvious concepts for such queues, all this is implemented on the side of client libraries. </p><br><p>  It should be noted that the protocol used by Zookeeper is called ZAB, links to the protocol descriptions are given at the end of the article. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p><a name="habracut"></a><br>  The basis of ZooKeeper is a virtual file system, which consists of interconnected nodes, which represent the combined concept of a file and directory.  Each node of this tree can simultaneously store data and have subordinate nodes.  In addition, there are two types of nodes in the system: there are so-called persistent nodes that are saved to disk and never disappear, and there are ephemeral nodes that belong to a particular session and exist as long as it exists. </p><br><br><p><img src="https://habrastorage.org/files/950/0d2/6f4/9500d26f4db0439ca33dbc06c3c7f530.png"></p><br><br><p>  In the picture, the letters P are marked customers.  They establish sessions ‚Äî active connections to the ZooKeeper server, within which heartbeat packets are exchanged.  If during one third of the timeout we did not hear the heartbeat, after two thirds of the timeout, the client library will join the other ZooKeeper server until the session on the server has had time to disappear.  If the session disappears, the ephemeral nodes (indicated in blue in the diagram) disappear.  They usually have an attribute that indicates which session owns them.  Such nodes can not have children, it is strictly an object in which you can save some data, but you can not make dependent. </p><br><br><p>  The ZooKeeper developers thought that it would be very convenient to have it all in the form of a file system. </p><br><br><p>  The second basic thing for ZooKeeper is the so-called synchronous implementation of recording and <a href="https://ru.wikipedia.org/wiki/FIFO">FIFO</a> processing of messages.  The idea is that the entire sequence of commands in ZooKeeper is strictly ordered, i.e.  This system supports total ordering. </p><br><br><p><img src="https://habrastorage.org/files/3af/782/6e7/3af7826e78be4c72885f32b8cc3a2bef.png" width="640"></p><br><br><p>  All operations in ZooKeeper turns into this idempotent operation.  If we want to change some kind of node, then we create a record that we have changed it, while remembering the version of the node that was and will be.  Due to this, we can receive the same message many times, while we will know exactly at what point you can apply it.  Accordingly, any recording operations are carried out strictly sequentially in one stream, in one server (master).  There is a leader who is selected between several typewriters, and only he performs all the operations for writing.  Readings can occur from the replica.  In this case, the client runs a strict sequence of its operations.  Those.  if he sent the write and read operation, the write will be executed first.  Even though the read operation could be performed without blocking, the read operation will be performed only after the previous write operation has been completed.  Due to this, it is possible to implement predictable asynchronous systems with ZooKeeper.  The system itself is mainly focused on asynchronous operation.  The fact that client libraries implement a synchronous interface is for the convenience of the programmer.  In fact, the high performance of ZooKeeper ensures precisely asynchronous operation, as it usually happens. </p><br><br><p>  How does all this work?  There is one leader plus a few followers.  Changes are applied using a two-phase commit.  The main thing that ZooKeeper is focused on is that it works on TCP plus total ordering.  In general, the ZAB protocol (ZooKeeper Atomic Broadcast) is a simplified version of <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259F%25D0%25B0%25D0%25BA%25D1%2581%25D0%25BE%25D1%2581">Paxos</a> , which, as you know, is experiencing message reordering, able to deal with it.  ZAB does not know how to deal with this, it is initially focused on a completely ordered stream of events.  There is no parallel processing, but often it is not required, because the system is focused more on reading than on writing. </p><br><br><p><img src="https://habrastorage.org/files/ba7/a50/dd7/ba7a50dd74574cfaaf624928f4bc386e.png" width="640"></p><br><br><p>  For example, we have such a cluster, there are customers.  If customers now do the reading, they will see the value that the followers are now seeing, believe that now the value of a certain field is now 1. If we write 2 in some client, the follower will perform the operation through the leader and receive a new state as a result. </p><br><br><p><img src="https://habrastorage.org/files/f7f/209/940/f7f2099401074ce0a57fd3cab3239876.png" width="640"></p><br><br><p>  For the leader to be considered successful, the leader needs at least 2 of 3 machines to confirm that they have reliably saved these data.  Imagine that we have this follower, which is from 1, now, for example, in some Amsterdam or other remote DC.  He is behind the rest of the followers.  Consequently, the local machines will already see 2, and that remote follower, if the client reads from it before the follower has time to catch up with the master, he will see a lagging value.  In order for it to read the correct value, you need to send a special command so that ZooKeeper is forcibly synchronized with the master.  Those.  at least at the time of execution of the sync command, it will be known for sure that we received the state rather fresh in relation to the master.  This is called slow read.  Usually we read very quickly, but if everyone uses slow reading, it is clear that the entire cluster will always be read from the master.  Accordingly, there will be no scaling.  If we read quickly, allow ourselves to lag behind, then we can scale to read quite well. </p><br><br><h2>  Recipes of use </h2><br><h3>  Configuration management </h3><br><p>  The first and most basic application is configuration management.  We write some settings in Zookeper, for example, the URL of the connection with the base or just a flag that prohibits or allows some service inside our cluster to work.  Accordingly, cluster members subscribe to the configuration section and monitor its modifications. </p><br><br><p><img src="https://habrastorage.org/files/cb3/e53/061/cb3e53061e54403eb3144c2b18221569.png" width="640"></p><br><br><p>  If they have recorded a change, they can read it and somehow react to it.  Due to the so-called.  ephemeral nodes can be tracked, for example, whether the machine is still alive.  Or get a list of active machines.  If we have a set of workers, then we can register each of them.  And in the zukiper we will see all the machines that are really in touch.  Due to the presence of the timestamp of the last modification or the list of sessions, we can even predict how far behind our machines are.  If we see that the car starts to approach the timeout, you can take some action. </p><br><br><h3>  Rendezvous </h3><br><p>  Another option - the so-called rendezvous.  The idea is that there is a way for the workers and the dealer who gives them tasks. </p><br><br><p><img src="https://habrastorage.org/files/b00/f52/27e/b00f5227e358426aa9ae0dbda4558a23.png" width="640"></p><br><br><p>  We do not know in advance how many workers we have, they can connect and disconnect, we do not control this process.  To do this, you can create a directory of workers.  And when we have a new worker, he registers an ephemeral node, which will report that the worker is still alive, and, for example, his own catalog, where tasks for him will fall.  The leader will track the workers directory.  He will notice if one of the workers falls off at some point.  Having discovered this, he can, for example, transfer tasks from the queue to another worker.  Thus, we can build on ZooKeeper an easy task processing system. </p><br><br><h2>  Locks </h2><br><p>  Suppose a client has come.  He creates an ephemeral node.  Here you need to make a reservation that in addition to the usual ZooKeeper there are sequential nodes.  To them at the end can be attributed to some atomically growing sequence. </p><br><br><p><img src="https://habrastorage.org/files/099/fe3/29c/099fe329ce6b4f998528086d38b31713.png" width="640"></p><br><br><p>  The second client, coming to create another ephemeral node, receives a list of children and sorting them out, looking to see whether he is the first.  He sees that he is not the first, hangs up the event handler at first and waits for him to disappear. </p><br><br><p><img src="https://habrastorage.org/files/a02/28b/26f/a0228b26fa0d452f828e30201fd8a26a.png" width="640"></p><br><br><p> Why it is not necessary to hang up on the my-lock directory and wait when everything disappears there?  Because if you have a lot of cars trying to block something, then when lock ‚Äì 0001 disappears, you will have a storm of notifications.  The wizard will simply be busy sending notifications about one particular lock.  Therefore, it is better to link them in this way - one after another, so that they follow only the previous node.  They line up in a chain. </p><br><br><p><img src="https://habrastorage.org/files/da3/a92/244/da3a922445084c13948455506e18b974.png" width="640"></p><br><br><p>  When the first client releases the lock, deletes this entry, the second client sees it and believes that he now owns the lock, because  there is nobody ahead.  At the expense of the sequence, no one in front of him guaranteed to climb.  Accordingly, if the first client comes again, he will create a node at the end of the chain. </p><br><br><h2>  Performance </h2><br><p>  The graph below shows the write to read ratio along the x axis.  It is noticeable that with the increase in the number of write operations in percentage terms, the performance sags heavily. </p><br><br><p><img src="https://habrastorage.org/files/10f/b56/c5e/10fb56c5e7fb463eb438ffd14b67f5d8.png" width="640"></p><br><br><p>  These are the results of work in asynchronous mode.  Those.  operations are sent by 100. If they were sent one by one, the numbers along the y axis should be divided by 100. You can grow better by reading.  In ZooKeeper, in addition to the ability to build a quorum of, say, five machines that will guarantee data preservation, you can also make non-voting machines that act as repeaters: they simply read the events, but do not participate in the recording themselves.  Due to this, it turns out the advantage in writing. </p><br><br><table><tbody><tr><td>  Servers </td><td>  100% reads </td><td>  0% reads </td></tr><tr><td>  13 </td><td>  460k </td><td>  8k </td></tr><tr><td>  9 </td><td>  296k </td><td>  12k </td></tr><tr><td>  7 </td><td>  257k </td><td>  14k </td></tr><tr><td>  five </td><td>  165k </td><td>  18k </td></tr><tr><td>  3 </td><td>  87k </td><td>  21k </td></tr></tbody></table><br><br><p>  The table above shows how adding servers affects reading and writing.  It can be seen that the reading speed grows with the number, and if we increase the recording quorum, the performance drops. </p><br><br><p>  In the picture below you can see how ZooKeeper reacts to various failures.  The first case - the loss of a replica.  The second is the loss of a replica to which we are not attached. </p><br><br><p><img src="https://habrastorage.org/files/a4d/be7/fea/a4dbe7fea3fc46889e62d58b7202ff88.png"></p><br><br><p>  The fall of the leader for the zukiper conditionally critical.  With a good network, ZooKeeper can restore it in about 200 ms.  Sometimes a leader can be selected and a few minutes.  And at this moment if we try to lock lock, any attempts to write without an active leader will not lead to anything, we will have to wait for it to appear. </p><br><br><h2>  Delays </h2><table><tbody><tr><td>  <sup>severs</sup> / <sub>workers</sub> </td><td>  3 </td><td>  five </td><td>  7 </td><td>  9 </td></tr><tr><td>  one </td><td>  776 </td><td>  748 </td><td>  758 </td><td>  711 </td></tr><tr><td>  ten </td><td>  1831 </td><td>  1831 </td><td>  1572 </td><td>  1540 </td></tr><tr><td>  20 </td><td>  2470 </td><td>  2336 </td><td>  1934 </td><td>  1890 </td></tr></tbody></table><br><br><p>  The time in the table above is in nanoseconds.  Accordingly, the speed of reading ZooKeeper close to in-memory-databases.  In fact, this is a cache that always reads from memory.  In general, ZooKeeper database is always in memory.  The recording goes something like this: ZooKeeper writes a log of events, it is reset to disk according to the tick settings, and periodically the system makes a snapshot of the entire database.  Accordingly, if the base is too large or the disks are too busy, the delays can be compared with the timeout.  This test simulates the creation of a certain configuration: we have 1 kilobyte of data, first there is one synchronous create, then an asynchronous delete, it all repeats 50,000 times. </p><br><br><h2>  References: </h2><br>  <a href="http://web.stanford.edu/class/cs347/reading/zab.pdf">ZAB protocol - original document</a> <br>  <a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf">ZAB analysis and its implementation in ZK, slightly more human language than the original</a> </div><p>Source: <a href="https://habr.com/ru/post/234335/">https://habr.com/ru/post/234335/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234313/index.html">Interview Ilona Mask</a></li>
<li><a href="../234315/index.html">Flexible polyhedra</a></li>
<li><a href="../234321/index.html">Double Zen: two searches in one without tracking and SMS</a></li>
<li><a href="../234327/index.html">During the tests, the Falcon 9-R prototype exploded.</a></li>
<li><a href="../234331/index.html">How Gamma International was hacked</a></li>
<li><a href="../234341/index.html">Mail.Ru Group took on the chest a few dozen liters</a></li>
<li><a href="../234349/index.html">NASA is developing inertial robots for the study of asteroids</a></li>
<li><a href="../234351/index.html">The road to the moon or the second generation of spacecraft</a></li>
<li><a href="../234353/index.html">Web-gui for wget (light)</a></li>
<li><a href="../234355/index.html">VCStart startups: cloud CRM QuickOrder for the restaurant business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>