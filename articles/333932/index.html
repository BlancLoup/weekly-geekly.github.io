<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 2.2 - Lighting Basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The spread of light in the real world is an extremely complex phenomenon, depending on too many factors, and with limited computing resources, we cann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 2.2 - Lighting Basics</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  The spread of light in the real world is an extremely complex phenomenon, depending on too many factors, and with limited computing resources, we cannot afford to take into account all the nuances in the calculations.  Therefore, the lighting in OpenGL is based on the use of simplified mathematical models close to reality, which look quite similar, but are much easier to calculate.  These lighting models describe the physics of light based on our understanding of its nature.  One of these models is called <b>the Phong lighting model</b> .  The Phong model consists of three main components: background (ambient), diffuse / diffuse (diffuse) and glare (specular).  Below you can see what they are: </p><br><p><img src="https://habrastorage.org/web/e44/505/3eb/e445053eb0594dbab1a56728278ae06d.png" alt="Phong Lighting Model"></p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Menu</b> <div class="spoiler_text"><p>  Part 1 </p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2 </p><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <b>Lighting Basics</b> <br><ul><li>  <a href="https://habr.com/ru/post/333932/">Background lighting</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Diffuse lighting</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Normal vectors</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Diffuse color calculation</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Something else</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Illumination of mirror highlights</a> </li><li>  <a href="https://habr.com/ru/post/333932/">Exercises</a> </li></ul></li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Lighting maps</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple lighting</a> </li></ol><br><br><p>  Part 3 </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp and Mesh class</a> </li></ol></div></div><br><ul><li>  <b>Background lighting</b> : even in the darkest scene there is usually always some kind of light (moon, high beam), so objects are almost never completely black.  To simulate this, we use the ambient light constant, which will always give the object some hue. </li><li>  <b>Diffuse lighting</b> : imitates the effect of a directional light source on an object.  This is the most visually significant component of the lighting model.  The larger part of the object's surface facing the light source, the brighter it will be illuminated. </li><li>  <b>Illumination of mirror highlights</b> : imitates a bright spot of light (glare) that appears on shiny objects.  The color of the specular highlights is often closer to the color of the light source than to the color of the object. </li></ul><br><p>  To create visually interesting scenes, we need to simulate at least these 3 components of the light component.  Let's start with the simplest: with background lighting. </p><br><a name="02_ambient"></a><h2>  Background lighting </h2><br><p>  Light usually comes not from one, but from many sources of light being around us, even if we do not see them directly.  One of the properties of light is that it can be diffused and reflected in many directions, reaching places that are not in direct view;  Thus, light can be <i>reflected</i> from different surfaces and have an indirect effect on the lighting of the object.  Algorithms that take into account these properties of light are called <b>global illumination</b> algorithms, but they are labor-intensive and / or complex. </p><br><p>  Since we are not very fond of difficult and resource-intensive algorithms, we will begin with the use of a very simplified model of global illumination, namely, with <b>Background illumination</b> .  In the previous section, you saw how a dim constant color was used, which was added to the color of a fragment of an object, and this created the impression that there was ambient light in the scene, although there was no direct source of such light. </p><br><p>  Add background lighting to the scene is very simple.  To do this, take the color of the light source, multiply it by a small constant background illumination factor, then multiply the resulting value by the color of the object and use the calculated value as the fragment color: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> ambientStrength = <span class="hljs-number"><span class="hljs-number">0</span></span>.1f; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> ambient = ambientStrength * lightColor; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> result = ambient * objectColor; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span> = vec4(result, <span class="hljs-number"><span class="hljs-number">1</span></span>.0f); }</code> </pre> <br><p>  If you start the program now, you will see that the first component of the Phong lighting model has been successfully applied to your object.  The object is rather dark, but not completely, because background lighting is applied to it (note that the cube of the lamp has not changed, because we use another shader to render it).  The scene should look something like this: </p><br><p><img src="https://habrastorage.org/web/7f4/f5d/805/7f4f5d805ade467ab03377f28a11d9db.png" alt="Phong lighting component"></p><br><a name="03_diffuse"></a><h2>  Diffuse lighting </h2><br><p>  Background lighting itself does not produce any interesting results, but diffuse lighting has a very significant visual impact on the appearance of the object.  The more perpendicular to the direction of the rays of the light source are the fragments of the object, the greater the brightness of the diffuse component of the illumination.  To better understand diffuse lighting, take a look at the following image: </p><br><p><img src="https://habrastorage.org/web/db4/8a4/6d2/db48a46d2df34ad6824946f03423c7f1.png" alt="Phong Diffuse Lighting Component"></p><br>  p&gt; On the left, we see a beam emanating from a light source, aimed at some fragment of our object.  We need to measure the angle of incidence of the beam on the fragment.  The impact of the light source on the color of the fragment becomes maximum when perpendicular to the direction of the beam to the surface of the object.  To measure the angle between the light beam and the fragment, we use the so-called <b>normal vector</b> , which is perpendicular to the fragment surface (the normal vector is depicted as a yellow arrow);  we will talk about it later.  Then the angle between the two vectors can be easily calculated using the dot product. <br><p>  You may remember from the lesson on <a href="https://habrahabr.ru/post/319144/">transformations</a> that the smaller the angle between two unit vectors, the greater the result of the scalar product tends to 1.0.  When the angle between both vectors is 90 degrees, the scalar product of these vectors becomes equal to 0. The same applies to the angle Œò: the more becomes, the less influence the light source has on the color of the fragment. </p><br><blockquote><p>  Note that to obtain (only) the cosine of the angle between both vectors, we will work with unit vectors (vectors of unit length), so we must make sure that all vectors are normalized, otherwise the scalar product of vectors will return a result greater than the cosine value (see <a href="https://habrahabr.ru/post/319144/">Transformation</a> lesson). </p></blockquote><br><p>  Thus, the value returned from the dot product can be used to calculate the power of the light source on the color of the fragment;  This will lead to a different illumination of the fragments, depending on their orientation with respect to the direction of light rays. </p><br><p>  So, what do we need to calculate diffuse illumination? </p><br><p></p><ul><li>  Normal vector: vector perpendicular to the illuminated surface </li><li>  Directional light: direction vector, which is the difference between the position of the light source and the position of the fragment.  To calculate this ray, we need the coordinate of the light source and the coordinate of the fragment. </li></ul><br><a name="04_normals"></a><h3>  Normal vectors </h3><br><p>  The normal vector is a (unit) vector perpendicular to the surface constructed on a given vertex.  Since the vertex itself does not have a surface (this is just a point in space), adjacent vertices are used to find the normal vector.  To calculate the normals of the vertices of a cube, we can do a little trick and apply a vector product to the faces, but since the cube is a fairly simple shape, we add the normals to the vertex data manually.  An updated array of vertex data can be found <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting_vertex_data">here</a> .  Try to imagine the normals in the form of vectors directed perpendicular to the surfaces of the planes of the cube (the cube consists of 6 planes). </p><br><p>  Since we added additional data to the array of vertices, we need to update the vertex lighting shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 normal; ...</code> </pre> <br><p>  Now, after adding each vertex of the normal vector and updating the vertex shader, we also need to update the vertex attribute pointers.  Notice that the lamp object retrieves vertex data from the same array, but the vertex lamp shader does not use newly added normal vectors.  We do not need to update either the lamp shaders or its attributes, but due to the change in the size of the array of vertices, we need to change the setting of the attribute pointers. </p><br><pre> <code class="cpp hljs">glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), (GLvoid*)<span class="hljs-number"><span class="hljs-number">0</span></span>); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  For each vertex, we want to use only the first 3 float values, and skip the last 3 values, so we only need to update the stride parameter to a value equal to 6 sizes of the variable type GLfloat, that's all. </p><br><blockquote><p>  Working with an array of vertices, in which the shader does not use all the data, may not seem inefficient, but this data has already been loaded into the GPU memory from the array of the container object, so we do not need to load any new data.  In practice, this approach is more efficient than creating a new VBO for the lamp. </p></blockquote><br><p>  All lighting calculations are performed in a fragment shader, so we need to redirect normal vectors from the vertex shader to the fragment shader.  Let's do it: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">out</span></span> vec3 Normal; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_Position</span></span> = projection * view * model * vec4(position, <span class="hljs-number"><span class="hljs-number">1</span></span>.0f); <span class="hljs-attribute"><span class="hljs-attribute">Normal</span></span> = normal; }</code> </pre> <br><p>  It remains only to declare the corresponding input variable in the fragment shader: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 Normal;</code> </pre> <br><a name="05_diffuse"></a><h3>  Diffuse color calculation </h3><br><p>  Now we have a normal vector for each vertex, but we still need vectors with coordinates of the light source and the fragment.  Since the position of the light source is set to one variable that does not change, we will simply declare it in the fragment shader as a uniform variable: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 lightPos;</code> </pre> <br><p>  And then assign it a value in the game loop (or outside it, since the value of this variable does not change).  We use the <i>lightPos</i> vector announced in the previous lesson as the location of the light source: </p><br><pre> <code class="cpp hljs">GLint lightPosLoc = glGetUniformLocation(lightingShader.Program, <span class="hljs-string"><span class="hljs-string">"lightPos"</span></span>); glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);</code> </pre> <br><p>  The last thing you need is the position of the current fragment.  We are going to make all calculations of illumination in world space of coordinates, therefore, we will need the vertex positions needed in world coordinates.  The transformation of a vertex position into world coordinates is achieved by multiplying its position attribute only by the model matrix (without view and projection matrices).  This can easily be done in the vertex shader, so let's declare the output variable in it and calculate the coordinates of the vertex in the world space: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">out</span></span> vec3 FragPos; <span class="hljs-attribute"><span class="hljs-attribute">out</span></span> vec3 Normal; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_Position</span></span> = projection * view * model * vec4(position, <span class="hljs-number"><span class="hljs-number">1</span></span>.0f); <span class="hljs-attribute"><span class="hljs-attribute">FragPos</span></span> = vec3(model * vec4(position, <span class="hljs-number"><span class="hljs-number">1</span></span>.0f)); <span class="hljs-attribute"><span class="hljs-attribute">Normal</span></span> = normal; }</code> </pre> <br><p>  Finally, add the appropriate input variable to the fragment shader: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 FragPos;</code> </pre> <br><p>  Now that all the necessary variables have been set, we can start the lighting calculations in the fragment shader. </p><br><p>  The first thing we need to calculate is the direction vector between the light source and the fragment.  We have already said that this vector is the difference in the positions of the light source and the fragment.  As you may remember from the <a href="https://habrahabr.ru/post/319144/">transformation</a> lesson, we can easily calculate this difference by subtracting one vector from another.  We also want to make sure that all the vectors of interest to us are of unit length, so we normalize both the vector of the direction of the source of light and the vector of normals obtained by subtracting: </p><br><pre> <code class="hljs lisp">vec3 norm = normalize(<span class="hljs-name"><span class="hljs-name">Normal</span></span>)<span class="hljs-comment"><span class="hljs-comment">; vec3 lightDir = normalize(lightPos - FragPos);</span></span></code> </pre> <br><blockquote><p>  When calculating the lighting, we usually don‚Äôt care about the size of the vectors or their location;  we are only interested in directions.  Since only the orientation of the vectors is a significant characteristic, almost all calculations are performed with vectors of unit length, since this simplifies most calculations (for example, the dot product).  Therefore, when performing lighting calculations, always check whether you have normalized the corresponding vectors to ensure that they are really single.  The absence of vector normalization is a very common error. </p></blockquote><br><p>  Next, using the scalar product of the vectors <b>norm</b> and <b>lightDir</b> , we need to calculate the magnitude of the effect of diffuse illumination on the current fragment.  Then, this value is multiplied by the color of the light source, and as a result we get the diffuse illumination component, which will become darker as the angle between the vectors increases: </p><br><pre> <code class="hljs lisp">float diff = max(<span class="hljs-name"><span class="hljs-name">dot</span></span>(<span class="hljs-name"><span class="hljs-name">norm</span></span>, lightDir), <span class="hljs-number"><span class="hljs-number">0.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">; vec3 diffuse = diff * lightColor;</span></span></code> </pre> <br><p>  If the angle between the vectors is more than 90 degrees, then the result of the scalar product will be negative, and we will get a negative component of diffuse light.  For this reason, we use the <b>max</b> function, which returns the largest of the parameters passed to it, and ensures that the diffuse component of light (and, therefore, colors) will never be less than 0.0.  Lighting models for negative color values ‚Äã‚Äãdo not exist, so if you are not one of eccentric artists, it‚Äôs better to stay away from negative colors. </p><br><p>  Now that we have the background and diffuse components, we summarize their colors, and then multiply the result by the color of the object, thus obtaining the resulting color of the output fragment: </p><br><pre> <code class="hljs lisp">vec3 result = (<span class="hljs-name"><span class="hljs-name">ambient</span></span> + diffuse) * objectColor<span class="hljs-comment"><span class="hljs-comment">; color = vec4(result, 1.0f);</span></span></code> </pre> <br><p>  If your application (and shaders) are compiled successfully, you will see something like this: </p><br><p><img src="https://habrastorage.org/web/8be/898/c30/8be898c3078840bfb86610e125a01f61.png" alt="Phong background and diffuse lighting components"></p><br><p>  Together with the diffuse lighting component, the cube begins to look more realistic.  Try to imagine the normals of the planes of the cube, and then, moving around it to observe the brightness change, and see that as the angle between the normal and the direction of the light source increases, the fragments become darker. </p><br><p>  If you have any difficulties, feel free to compare your source code with the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting_diffuse">full source code</a> and <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting_diffuse%26type%3Dfragment">fragment shader code</a> . <br></p><br><a name="06_last_thing"></a><h3>  Something else </h3><br><p>  Currently, we transfer the vectors of the normals and the vertex shader directly to the fragment shader.  However, the calculations that we made in the fragment shader were performed in the coordinates of world space, so should we not transform the normal vectors into world coordinates as well?  Actually, they should, but this will not be as easy as multiplying the vector by the model matrix. </p><br><p>  First, the vectors of normals are only directions, and they do not represent specific positions in space.  In addition, the normals do not have a homogeneous component (the w-component of the vertex position).  This means that the movements produced by the model should not affect the normal vectors.  Therefore, if we want to multiply the normals to the matrix of the model, we must remove the part of the matrix responsible for the displacements, and take only the left upper matrix 3x3 in size (note, we could set the w-component of the normal vector to 0.0 and multiply it by 4x4 that will also eliminate the impact of shift values).  Thus, we apply to vectors of normals, only scale and rotation transformations. </p><br><p>  Secondly, if the model matrix performs non-uniform scaling, then the vertices of the coordinates of the vertices will be changed so that the normal vector <br>  will no longer be perpendicular to the surface, so we cannot transform the normals with such matrixes of the model either.  The following figure shows the effect produced on the normal vector of such a model matrix (with non-uniform scaling): </p><br><p><img src="https://habrastorage.org/web/27c/46a/1d1/27c46a1d16f54d469cb06fdea6729ca0.png" alt="Non-uniform normal scaling"></p><br><p>  Whenever we apply non-uniform scaling, the normals are no longer perpendicular to their surfaces, which distorts the lighting.  (Note: uniform scaling for normals is harmless, as this changes the direction of the vectors remain the same, and only their sizes change, which are easily corrected by normalization). </p><br><p>  A technique that solves this problem can be the use of another matrix of the model specifically designed for normal vectors.  This matrix is ‚Äã‚Äãcalled <b>the normal matrix</b> , it uses several linear algebraic operations to eliminate the effect of improper scaling of normals.  If you want to know how this matrix is ‚Äã‚Äãcalculated, then I suggest you the following <a href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/">article</a> . </p><br><p>  The matrix of normals is defined as ‚Äúthe transposed inverse 3x3 submatrix of the upper left corner of the model matrix‚Äù.  Whew, this is too much, and if you don‚Äôt quite understand what it all means, don‚Äôt worry;  we have not yet discussed the inverse and transposed matrices.  Please note that in many teaching examples the normal matrix is ‚Äã‚Äãcalculated by applying the above operations to the model-type matrix, but since we are working in world space (and not in the form space), we use only one model matrix. </p><br><p>  In the vertex shader, we can create a matrix of normals on our own using the inversion and transposition functions that work with any type of matrix.  Please note that we are reducing the matrix to the 3x3 type to ensure that the matrix loses its shifting properties and to provide the possibility of multiplying by the vec3 normal vector: </p><br><pre> <code class="hljs lisp">Normal = mat3(<span class="hljs-name"><span class="hljs-name">transpose</span></span>(<span class="hljs-name"><span class="hljs-name">inverse</span></span>(<span class="hljs-name"><span class="hljs-name">model</span></span>))) * normal<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  In the examples from the section on diffuse lighting, everything worked correctly because we did not perform any scaling operations on the object, so there was no need to use the normal matrix and it was possible to simply multiply the normals by the model matrix.  However, if you apply non-uniform scaling, then multiplying the normal vector by the normal matrix will become quite significant. </p><br><blockquote><p>  Converting matrices is an expensive operation even for shaders, so wherever possible, try to avoid performing similar calculations in shaders, especially since they will be done for each vertex of your scene.  For training purposes, this is permissible, but in application applications, you will most likely prefer to calculate the matrix of normals on the CPU, and before rendering it, transfer it to the shaders using a uniform variable (as well as the model matrix). </p></blockquote><br><a name="07_specular"></a><h2>  Illumination of mirror highlights </h2><br><p>  If you are not completely exhausted by all these calculations of illumination, then we can begin to complete acquaintance with the Phong model, adding the last component of the specular highlights. </p><br><p>  Illumination of specular highlights, as well as diffused illumination, is based on the vector of the direction of the light source and the normal of the surface of the object, but in addition, the position of the observer, that is, the direction in which the player looks at the fragment, is taken into account.  Specular lighting is based on the reflective properties of the light.  If we imagine the surface of the object in the form of a mirror, the illumination of the glare will be greatest in the place where we would see the light of the source reflected from the surface.  This effect is shown in the following image: </p><br><p><img src="https://habrastorage.org/web/47b/9f0/67c/47b9f067c063498681c6c289868e9e13.png" alt="Illumination scheme of mirror highlights"></p><br><p>  The reflection vector is calculated by reflecting the direction of light relative to the normal vector.  Then we calculate the angular distance between this reflection vector and the direction of gaze;  the smaller the angle between them, the greater the effect on the color of the fragment is the illumination of specular highlights.  As a result of this effect, when we look in the direction of the light source, we see a reflected flare on the surface of the object. </p><br><p>  The viewing vector is another additional variable necessary to calculate the illumination of specular highlights.  We can calculate it using the world coordinates of the observer‚Äôs point of view and the position of the fragment.  Then we calculate the intensity of the flare, multiply it by the color of the illumination and add it to the previously calculated components of the background and ambient lighting. </p><br><blockquote><p>  We decided to calculate the illumination in the global space, but most people prefer to do it in the space of the form.  The advantage of light calculations in view coordinates is that the observer position is always at (0,0,0), and it is not necessary to calculate it.  However, I believe that the calculation of coverage in world coordinates for educational purposes is more understandable.  If you still want to calculate the illumination in the view space, <br>  then you need to multiply all the corresponding vectors by the view matrix (don't forget to change the normal matrix too). </p></blockquote><br><p>  To obtain the coordinates of the observer in world space, we simply take the position vector of the camera object (which, of course, is the observer).  So let's add another uniform variable to the fragment shader and pass the corresponding camera position vector into it: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 viewPos;</code> </pre> <br><pre> <code class="cpp hljs">GLint viewPosLoc = glGetUniformLocation(lightingShader.Program, <span class="hljs-string"><span class="hljs-string">"viewPos"</span></span>); glUniform3f(viewPosLoc, camera.Position.x, camera.Position.y, camera.Position.z);</code> </pre> <br><p>  Now that we have all the necessary variables, we can calculate the intensity of the flare.  To begin with, we will set the average intensity value to the mirror flare so that it does not have a too strong effect: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> specularStrength = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f;</code> </pre> <br><p>  If we set this variable to 1.0f, we would get a very bright component of the specular flare, which would be excessive for the coral cube.  We will talk about the correct setting of all these light intensities and how they affect the objects in the next lesson.  In the meantime, we calculate the vector of gaze direction and the corresponding reflection vector about the axis, which is the normal: </p><br><pre> <code class="hljs lisp">vec3 viewDir = normalize(<span class="hljs-name"><span class="hljs-name">viewPos</span></span> - FragPos)<span class="hljs-comment"><span class="hljs-comment">; vec3 reflectDir = reflect(-lightDir, norm);</span></span></code> </pre> <br><p>  Notice that we have inverted the <b>lightDir</b> vector.  The <b>reflect</b> function expects the first vector to indicate the direction <b>from the</b> light source to the fragment position, but the <b>lightDir</b> vector currently points in the opposite direction, that is, from the fragment <b>to the</b> light source (the direction depends on the order of subtraction of the vectors we did when calculating the <b>lightDir</b> vector ).  Therefore, to obtain the correct reflection vector, we reverse its direction by <b>inverting the lightDir</b> vector. ,       ,      <b>norm</b> . </p><br><p>      .     : </p><br><pre> <code class="hljs lisp">float spec = pow(<span class="hljs-name"><span class="hljs-name">max</span></span>(<span class="hljs-name"><span class="hljs-name">dot</span></span>(<span class="hljs-name"><span class="hljs-name">viewDir</span></span>, reflectDir), <span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">32</span></span>)<span class="hljs-comment"><span class="hljs-comment">; vec3 specular = specularStrength * spec * lightColor;</span></span></code> </pre> <br><p>          (   ),      32- .   32   .    ,     ,   ,       .     ,         : </p><br><p><img src="https://habrastorage.org/web/329/700/805/3297008051eb4102a03398b8645b5de6.png" alt="Mirror highlights"></p><br><p>   ,      ,      32.            ,       : </p><br><pre> <code class="hljs lisp">vec3 result = (<span class="hljs-name"><span class="hljs-name">ambient</span></span> + diffuse + specular) * objectColor<span class="hljs-comment"><span class="hljs-comment">; color = vec4(result, 1.0f);</span></span></code> </pre> <br><p>         .         -  : </p><br><p><img src="https://habrastorage.org/web/878/c67/b97/878c67b97a514204b56cd6b477d08bfc.png" alt="Phong Cube Lighting"></p><br><p>      <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting_specular"> </a> ,   <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting%26type%3Dvertex"></a>  <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting%26type%3Dfragment"></a> . </p><br><blockquote><p>   ,      ,          .        ,      ,  ,   ()    .             ,           . ,      ,      : </p><br><p><img src="https://habrastorage.org/web/da3/814/eb5/da3814eb5a744d4c804dba26663bd9ea.png" alt="Phong and Gouro Lighting Models"></p><br><p>        ,      ,   .  ,  -     .  ,       . </p></blockquote><br><p>       ,     .              .        ,     . </p><br><a name="08_exercises"></a><h2>  Exercises </h2><br><ul><li>        .     ,   <b>sin</b>  <b>cos</b> .           : <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting-exercise1"></a> . <br></li><li>        ,    ,  ,     .     .  ,        . </li><li>       ,    : <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting-exercise2"></a> . </li><li>    ,   .     ,         (  ). ,      : <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/basic_lighting-exercise3"></a> . </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333932/">https://habr.com/ru/post/333932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333920/index.html">We raise Linux on MIPSfpga and Altera FPGA</a></li>
<li><a href="../333922/index.html">Release cycle for Infrastructure as Code</a></li>
<li><a href="../333926/index.html">Orchid CMS - another CMS on Laravel</a></li>
<li><a href="../333928/index.html">Integration of Apache CloudStack with third-party systems. Subscribing to events using Apache Kafka</a></li>
<li><a href="../333930/index.html">How the vulnerability of the payment system revealed credit card information</a></li>
<li><a href="../333936/index.html">Is it true that people write insane code with overlapping side effects, while maintaining equanimity?</a></li>
<li><a href="../333938/index.html">The digest of interesting materials for the mobile # 213 developer (July 17 - 23)</a></li>
<li><a href="../333942/index.html">Using VK Streaming API with Telegram Alert</a></li>
<li><a href="../333948/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ272 (July 17 - 23, 2017)</a></li>
<li><a href="../333950/index.html">Creating stones for games using photogrammetry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>