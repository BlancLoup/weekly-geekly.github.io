<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ exception handling under the hood or how exceptions work in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 The world has won high-level languages ‚Äã‚Äãand in the worlds of Ruby-Python-js developers can only rant that in the pluses you should ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ exception handling under the hood or how exceptions work in C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/bae/cb7/772/baecb77727fa49619830c84649d3ab3e.jpg"><br><h3>  From translator </h3><br>  The world has won high-level languages ‚Äã‚Äãand in the worlds of Ruby-Python-js developers can only rant that in the pluses you should not use this or that.  For example, exceptions, because they are slow and generate a lot of extra code.  It was worth asking ‚Äúand what kind of code it generates,‚Äù as a response received a mumbling and a lowing.  And the truth is - how do they work?  Well, let's compile in g ++ with the -S flag, see what happens.  It is not difficult to understand the surface, but the fact that there were any misunderstandings prevented me from sleeping.  Fortunately, the finished article was found. <br><br>  On Habr√© there are several articles, <a href="https://habrahabr.ru/post/208006/">detailed</a> and <a href="https://habrahabr.ru/post/119016/">not very</a> (while still good), on how exceptions work in C ++.  However, there is not one truly deep, so I decided to fill this gap, since there is a good material.  Who cares how exceptions work in C ++ using the example of gcc - reserve yourself with a pocket or evernote, free time and welcome under the cat. <br><a name="habracut"></a><br>  <a href="https://habrahabr.ru/post/279151/">Part 2</a> <br>  <a href="https://habrahabr.ru/post/279149/">3 part</a> <br><br>  PS A few words about the translation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  the translation is very very close to the text, but sometimes I allowed myself to change whole paragraphs </li><li>  I never figured out some terms how to translate, for example, landing pad and call site </li><li>  The works turned out to be much more than it seemed, by the end I even became confused where the translation was, and where the original was, some lines were written at 4 am, in general - if there are some incoherent words or whole sentences somewhere - I'm sorry, I will try soon all correct. </li><li>  In this case, the code is an integral part of the article, so I will not hide anything under the spoiler. </li><li>  As always, spelling, punctuation and minor errors - in a personal.  Factual errors, inaccuracies and omissions are in the comments. </li></ul><br><h1>  C ++ exceptions under the hood </h1><br>  Everyone knows that exception handling is difficult.  There are plenty of reasons for this in every layer of the "life cycle" of exceptions: it is difficult to write code with a strong guarantee of exceptions (exception safe code), exceptions can be thrown from unexpected places, it can be problematic to understand poorly designed exceptions hierarchy, it slowly works for a lot of voodoo magic under the hood, this is dangerous, since improperly throwing an error can lead to an unforgivable call to <code>std::terminate</code> .  And, despite all this, the battle over whether or not to use exceptions in programs still continues.  This is probably due to a shallow understanding of how they work. <br><br>  First you need to ask yourself: how does this all work?  This is the first article in a long series <em>that I write about how exceptions are implemented under the hood in C ++ (under the gcc platform under x86, but should be applicable to other platforms as well).</em>  <em>In these articles, the process of overshooting and catching errors will be explained in detail, but for the impatient: a brief</em> summary of <em>all articles</em> about forwarding exceptions in gcc / x86: <br><br><ol><li>  When we write a throw statement, the compiler translates it into a couple of calls to the <code>libstdc++</code> functions, which place an exception and begin the fast process of unwinding the stack by calling the <code>libstdc</code> library. <br><br></li><li>  For each catch block, the compiler writes some specific information after the method body, an exception table that the method can catch, as well as a cleanup table (more on the cleanup table later). <br><br></li><li>  In the process of unwinding the stack, a special function is called, supplied by <code>libstdc++</code> (called the "personality routine"), which checks each function in the stack for errors it can catch. <br><br></li><li>  If there was no one who could catch this error, <code>std::terminate</code> called. <br><br></li><li>  If someone nevertheless is found, promotion starts again from the top of the stack. <br><br></li><li>  When you re-walk the stack, a ‚Äúpersonal function‚Äù is launched to clean up resources for each method. <br><br></li><li>  The routine checks the cleanup table for the current method.  If it has something to clear, the subroutine "jumps" into the current frame of the stack and runs a cleanup code that calls the destructors for each of the objects located in the current scope. <br><br></li><li>  When the promotion stumbles upon a fragment of the stack that can handle the exception, it "jumps" into the exception handling block. <br><br></li><li>  After the completion of exception processing, the cleanup function is called to free the memory occupied by the exception. </li></ol><br>  * We will have one big article, beaten into pieces, so further the ‚Äúseries of articles‚Äù will be replaced with just the ‚Äúarticle‚Äù in order not to overload it. <br><br>  Even now it looks difficult, but we didn‚Äôt even begin, it was just a short and inaccurate description of the difficulties needed to handle exceptions. <br><br>  To explore all the details that take place under the hood, in the next part we will start with the implementation of our own mini-version of <code>libstdlibc++</code> .  Not all, only parts with error handling.  In reality, not even this whole part, only the necessary minimum for the implementation of the throw / catch block.  You will also need a little assembler, but only quite a bit.  But it will take a lot of patience, unfortunately. <br><br>  If you're too curious, you can start <a href="http://mentorembedded.github.io/cxx-abi/">here</a> .  This is a complete specification of what we will implement in the following sections.  I will try to make this article instructive and simpler, so that next time you will be easier to start with your own ABI (application binary interface). <br><br>  <strong>Notes (disclaimer):</strong> <br>  I am in no way confusing what kind of voodoo-magic happens when an exception is thrown.  In this article I will try to expose the secret and find out how it works.  Some little things and subtleties will not be true.  Please let me know if there is something wrong somewhere. <br><br>  Note  translator: this is also relevant for translation. <br><br><h1>  C ++ exceptions under the hood: small ABI </h1><br>  If we try to understand why exceptions are so complicated and how they work, we can either drown in tons of manuals and documentation, or try to catch exceptions on our own.  In fact, I was surprised by the lack of quality information on the topic (note of the translator - I, by the way, too): everything that can be found either too detailed or too simple.  Of course, there are specifications (most documented: <a href="http://mentorembedded.github.io/cxx-abi/">ABI for C ++</a> , but also <a href="http://www.logix.cz/michal/devel/gas-cfi/">CFI</a> , <a href="http://www.logix.cz/michal/devel/gas-cfi/dwarf-2.0.0.pdf">DWARF,</a> and libstdc), but reading documentation is not enough if you really want to understand what is going on inside. <br><br>  Let's start with the obvious: re-inventing the wheel!  We know that in pure C there are no exceptions, so let's try linking the C ++ program with the pure C linker and see what happens!  I started with something simple like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"throw.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { void seppuku() { throw Exception(); } }</span></span></code> </pre> <br>  Do not forget <code>extern</code> , otherwise G ++ will helpfully cut out our small function and make it impossible to link with our program on pure C. Of course, we need a header file for linking (not a pun) in order to make it possible to connect the C ++ and C worlds: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> void seppuku(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  And a very simple main: <br><br><pre> <code class="hljs kotlin">#include <span class="hljs-string"><span class="hljs-string">"throw.h"</span></span> int main() { seppuku(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  What happens if we try to compile and link this frankino code? <br><br><pre> <code class="bash hljs">&gt; g++ -c -o throw.o -O0 -ggdb throw.cpp &gt; gcc -c -o main.o -O0 -ggdb main.c</code> </pre> <br>  Note: you can download all the source code for this project from <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01">my git repository</a> . <br><br>  So far, so good.  Both g ++ and gcc are happy in their little world.  Chaos will begin as soon as we try to link them together: <br><br><pre> <code class="bash hljs">&gt; gcc main.o throw.o -o app throw.o: In <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> `foo()<span class="hljs-string"><span class="hljs-string">': throw.cpp:4: undefined reference to `__cxa_allocate_exception'</span></span> throw.cpp:4: undefined reference to `__cxa_throw<span class="hljs-string"><span class="hljs-string">' throw.o:(.rodata._ZTI9Exception[typeinfo for Exception]+0x0): undefined reference to `vtable for __cxxabiv1::__class_type_info'</span></span> collect2: ld returned 1 <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> status</code> </pre> <br>  And of course, gcc complains about missing C ++ declarations.  These are very specific C ++ declarations.  Look at the last line of the error: the <code>vtable</code> for <code>cxxabiv1</code> .  <code>cxxabi</code> , declared in <code>libstdc++</code> , refers to ABI for C ++.  We now know that error handling is performed using a standard C ++ library with a declared C ++ ABI interface. <br><br>  C ++ ABI declares a standard binary format with which we can link objects together in one program.  If we compile .o files with two different compilers that use different ABIs, we cannot combine them into one application.  The ABI may also declare various other standards, such as an interface for unwinding a stack or throwing an exception.  In this case, the ABI defines the interface (not necessarily the binary format, just the interface) between C ++ and other libraries in our application that provide stack promotion.  In other words, ABI defines C ++ specific things that allow our application to communicate with non-C ++ libraries: this is what will allow exceptions to be thrown from other languages ‚Äã‚Äãto be captured in C ++, and so many other things. <br><br>  In any case, linker errors are the starting point and the first layer in analyzing the work of exceptions under the hood: the interface we need to implement is <code>cxxabi</code> .  In the next chapter, we will start with our own mini-ABI, defined exactly as <a href="http://mentorembedded.github.io/cxx-abi/">C ++ ABI</a> . <br><br><h1>  C ++ exceptions under the hood: please the linker by punching him ABI </h1><br>  In our journey in understanding exceptions, we discovered that all weightlifting is implemented in <code>libstdc++</code> , the definition of which is given in C ++ ABI.  Looking through the linker errors, we deduced that in order to handle errors, we have to ask for help from C ++ ABI;  we created a spitting C ++ program error, linked it to a pure C program, and found that the compiler somehow translates our throw statements into something that now calls several libstd ++ functions that directly throw an exception. <br><br>  Nevertheless, we want to understand exactly how exceptions work, so let's try to implement our own mini-ABI, which provides a mechanism for forwarding errors.  To do this, we need only <a href="http://mentorembedded.github.io/cxx-abi/abi-eh.html">RTFM</a> , but the full interface can be found <a href="http://libcxxabi.llvm.org/spec.html">here for LLVM</a> .  Recall what specific features are missing: <br><br><pre> <code class="hljs delphi">&gt; gcc main.o throw.o -o app throw.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">':</span></span> throw.cpp:<span class="hljs-number"><span class="hljs-number">4</span></span>: undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__cxa_allocate_exception<span class="hljs-string"><span class="hljs-string">' throw.cpp:4: undefined reference to `__cxa_throw'</span></span> throw.o:(.rodata._ZTI9Exception[typeinfo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Exception]+<span class="hljs-number"><span class="hljs-number">0</span></span>x0): undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `vtable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> __cxxabiv1::__class_type_info<span class="hljs-string"><span class="hljs-string">' collect2: ld returned 1 exit status</span></span></code> </pre> <br><h3>  __cxa_allocate_exception </h3><br>  The name is self-sufficient, I suppose.  <strong>__cxa_allocate_exception</strong> accepts <code>size_t</code> and allocates enough memory to hold the exception while it is being forwarded.  This is more complicated than it seems: when an error is processed, some kind of magic happens with the stack, allocating it (note the translator - excuse me for this word, but sometimes I will use it) on the stack is a bad idea.  Heap memory allocation is also generally a bad idea, because where will we allocate memory when an exception is signaled that the memory has run out?  Static (static) placement in memory is also a bad idea, as long as we need to make it thread-safe (otherwise, two competing streams that would throw exceptions would be catastrophic).  Considering these problems, memory allocation in the local stream storage (heap) seems to be the most advantageous, however, if necessary, contact emergency storage (presumably static) if the memory is out of memory.  We, of course, will not worry about the scary details, so we can simply use a static buffer if necessary. <br><br><h3>  __cxa_throw </h3><br>  This feature does all the magic of forwarding!  According to the ABI, once an exception has been created, <strong>__cxa_throw</strong> should be <strong>called</strong> .  This function is responsible for invoking stack promotion.  Important effect: <strong>__cxa_throw</strong> never assumes a return (return).  It also passes control to the appropriate catch block to handle the exception or calls (by default) <code>std::terminate</code> , but never returns anything. <br><br><h3>  <code>vtable</code> for <code>__cxxabiv1::__class_type_info</code> </h3><br>  Strange ... <strong>__class_type_info is</strong> clearly some kind of RTTI (run-time type information, run-time type identification, Dynamic data type identification), but which one?  For now, it‚Äôs not easy for us to answer this, and it‚Äôs not hellishly important for our mini-ABI;  let's leave this part of the "application", which we give after completing the analysis of the process of throwing an exception, now let's just say that this is the entry point of the ABI definition in runtime, answering the question: "these two types are the same or not."  This is a function that is called to determine whether a given catch block can handle this error or not.  Now we will focus on the main thing: we need to give it as an address for the linker (i.e., it is not enough to define it, we still need to initiate it) and it should have a vtable (yes, yes, it should have a virtual method). <br><br>  A lot of work happens in these functions, but let's try to implement the simplest exception thrower: the one that will make the call exit when an exception is thrown.  Our application is almost complete, but some ABI functions are missing, so let's create mycppabi.cpp.  By reading <a href="http://mentorembedded.github.io/cxx-abi/abi-eh.html">our ABI specification</a> , we can describe our signatures for <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong> : <br><br><pre> <code class="hljs rust">#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; namespace __cxxabiv1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__class_type_info</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void foo() {} } ti; } #define EXCEPTION_BUFF_SIZE <span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> exception_buff[EXCEPTION_BUFF_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { void* __cxa_allocate_exception(size_t thrown_size) { printf(<span class="hljs-string"><span class="hljs-string">"alloc ex %i\n"</span></span>, thrown_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thrown_size &gt; EXCEPTION_BUFF_SIZE) printf(<span class="hljs-string"><span class="hljs-string">"Exception too big"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;exception_buff; } void __cxa_free_exception(void *thrown_exception); #include &lt;unwind.h&gt; void __cxa_throw( void* thrown_exception, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_info</span></span></span></span> *tinfo, void (*dest)(void*)) { printf(<span class="hljs-string"><span class="hljs-string">"throw\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// __cxa_throw never returns exit(0); } } // extern "C"</span></span></code> </pre> <br>  Let me remind you: you can find the source in <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01">my github repository</a> . <br><br>  If we now compile mycppabi.cpp and link to the other two .o files, we will get working binaries, which should output "alloc ex 1 \ n throw" and, after that, exit.  Very simple, but surprisingly: we manage exceptions without calling libc ++: we wrote a (very very small) part of C ++ ABI! <br><br>  Another important part of the wisdom we received when creating our own mini-ABI: the <code>throw</code> keyword is compiled into two function calls from libstdc ++.  There is no voodoo magic here, this is a simple transformation.  We can even disassemble our function to test it.  Run <code>g++ -S throw.cpp</code> <br><br><pre> <code class="hljs perl">seppuku: .LFB3: [...] call __cxa_allocate_exception movl $0, <span class="hljs-number"><span class="hljs-number">8</span></span>(%esp) movl $_ZTI9Exception, <span class="hljs-number"><span class="hljs-number">4</span></span>(%esp) movl %eax, (%esp) call __cxa_throw [...]</code> </pre> <br>  Even more magic: when <code>throw</code> translated to these two calls, the compiler does not even know how the exception will be handled.  As soon as <code>libstdc++</code> determines <code>__cxa_throw</code> and its friends, <code>libstdc++</code> dynamically linked in runtime, the exception handling method can be selected when you first start the application. <br><br>  We are already seeing progress, but we still have to go a long way of learning.  Now our ABI can only throw exceptions.  Can we extend it to catch errors?  Well, let's see how to do this in the next chapter! <br><br><h1>  C ++ exceptions under the hood: catching what we throw </h1><br>  In this article, we slightly lifted the veil of secrecy about exceptions throwing, watching for compiler and linker errors, but we are still far from understanding anything about catching errors.  We summarize what we have already found out: <br><br><ul><li>  The throw declaration will be translated by the compiler into two calls: <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong> . </li><li>  <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong> live in <code>libstdc++</code> . </li><li>  <strong>__cxa_allocate_exception</strong> allocates memory for a new exception. </li><li>  <strong>__cxa_throw</strong> performs the preparation and <strong>throws an</strong> exception in <strong>_Unwind</strong> , into the set of functions that live in <code>libstdc</code> and produces a real stack unfolding ( <a href="http://mentorembedded.github.io/cxx-abi/abi-eh.html">ABI</a> defines the interface of these functions). </li></ul><br>  Until now, it has been quite simple, but catching exceptions is a bit more complicated, especially because it requires a little reflexion (it allows the program to analyze its own code).  Let's use our old method and add some catch block to our code, compile it and see what happens: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"throw.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;stdio.h&gt; //     struct <span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span> {}; void raise() { throw <span class="hljs-type"><span class="hljs-type">Exception</span></span>(); } // ,  ,      catch- void try_but_dont_catch() { try { raise(); } catch(<span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span>&amp;) { printf(<span class="hljs-comment"><span class="hljs-comment">"Running try_but_dont_catch::catch(Fake_Exception)\n"</span></span>); } printf(<span class="hljs-comment"><span class="hljs-comment">"try_but_dont_catch handled an exception and resumed execution"</span></span>); } //   ,   void catchit() { try { try_but_dont_catch(); } catch(<span class="hljs-type"><span class="hljs-type">Exception</span></span>&amp;) { printf(<span class="hljs-comment"><span class="hljs-comment">"Running try_but_dont_catch::catch(Exception)\n"</span></span>); } catch(<span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span>&amp;) { printf(<span class="hljs-comment"><span class="hljs-comment">"Running try_but_dont_catch::catch(Fake_Exception)\n"</span></span>); } printf(<span class="hljs-comment"><span class="hljs-comment">"catchit handled an exception and resumed execution"</span></span>); } extern <span class="hljs-comment"><span class="hljs-comment">"C"</span></span> { void seppuku() { catchit(); } }</code> </pre> <br>  As before, we have a seppuku function that connects the C and C ++ worlds, only this time we added several function calls to make our stack more interesting, we also added branches of try / catch blocks, so now we can analyze how libstdc ++ processes their. <br><br>  And again we get linker errors on missing ABI-functions: <br><br><pre> <code class="hljs delphi">&gt; g++ -c -o throw.o -O0 -ggdb throw.cpp &gt; gcc main.o throw.o mycppabi.o -O0 -ggdb -o app throw.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">':</span></span> throw.cpp:<span class="hljs-number"><span class="hljs-number">12</span></span>: undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__cxa_begin_catch<span class="hljs-string"><span class="hljs-string">' throw.cpp:12: undefined reference to `__cxa_end_catch'</span></span> throw.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catchit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">':</span></span> throw.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>: undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__cxa_begin_catch<span class="hljs-string"><span class="hljs-string">' throw.cpp:20: undefined reference to `__cxa_end_catch'</span></span> throw.o:(.eh_frame+<span class="hljs-number"><span class="hljs-number">0</span></span>x47): undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__gxx_personality_v0<span class="hljs-string"><span class="hljs-string">' collect2: ld returned 1 exit status</span></span></code> </pre><br>  We again see a bunch of interesting things.  We expected the <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong> call, although we don‚Äôt know what they are, but we can assume that they are equivalent to <strong>throw / __ cxa_allocate / throw</strong> .  <strong>__gxx_personality_v0</strong> - something new, and it will be the main theme of the following parts. <br><br>  What does the personal function do?  (when a translator did not come up with a better name, tell me in the comments if you have ideas).  We have already said something about it in the introduction, but next time we will look at it in much more detail, as well as our two new friends: <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong> . <br><br><h1>  C ++ exceptions under the hood: magic around <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong> </h1><br>  After studying how exceptions are thrown, we find ourselves on the path of studying how they are caught.  In the previous chapter, we added a try-catch block to our sample application to see what the compiler does, and also got linker errors just like the last time we looked at what would happen if we added a throw block.  Here is what the linker writes: <br><br><pre> <code class="hljs delphi">&gt; g++ -c -o throw.o -O0 -ggdb throw.cpp &gt; gcc main.o throw.o mycppabi.o -O0 -ggdb -o app throw.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">':</span></span> throw.cpp:<span class="hljs-number"><span class="hljs-number">12</span></span>: undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__cxa_begin_catch<span class="hljs-string"><span class="hljs-string">' throw.cpp:12: undefined reference to `__cxa_end_catch'</span></span> throw.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catchit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">':</span></span> throw.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>: undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__cxa_begin_catch<span class="hljs-string"><span class="hljs-string">' throw.cpp:20: undefined reference to `__cxa_end_catch'</span></span> throw.o:(.eh_frame+<span class="hljs-number"><span class="hljs-number">0</span></span>x47): undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__gxx_personality_v0<span class="hljs-string"><span class="hljs-string">' collect2: ld returned 1 exit status</span></span></code> </pre> <br>  Let me remind you that you can get the code on <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">my git repository</a> . <br><br>  In theory (in our theory, of course), the catch block is translated into a pair of <strong>__cxa_begin_catch / end_catch</strong> from libstdc ++, but also into something new, called a <strong>personal function</strong> , about which we still know nothing. <br><br>  Let's test our theory about <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong> .  Compile throw.cpp with the -S flag and analyze the assembler code.  There is a lot of interesting things, we will cut down to the most necessary: <br><br><pre> <code class="hljs pgsql">_Z5raisev: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> __cxa_allocate_exception <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> __cxa_throw</code> </pre> <br>  Everything is going great: we got the same definition for raise (), just throw an exception: <br><br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">Z18try_but_dont_catchv</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_startproc</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_personality</span></span> 0,__<span class="hljs-selector-tag"><span class="hljs-selector-tag">gxx_personality_v0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_lsda</span></span> 0,<span class="hljs-selector-class"><span class="hljs-selector-class">.LLSDA1</span></span></code> </pre> <br>  The definition for try_but_dont_catch () is truncated by the compiler.  This is something new: a link to <strong>__gxx_personality_v0</strong> and something else called <strong>LSDA</strong> .  This seems like a minor definition, but in reality it‚Äôs very important: <br><br><ul><li>  The linker uses this to specify CFI (call frame information);  CFI stores call frame information, <a href="http://www.logix.cz/michal/devel/gas-cfi/">here is</a> its complete specification.  It is used mainly for unwinding the stack. </li><li>  <strong>LDSA</strong> (language specific data area) is a special area for each language used by a personal function to know which exceptions can be handled by this function. </li></ul><br>  About CFI and LSDA we will talk in the next chapter, do not forget about them, but now let's move on. <br><br><pre> <code class="hljs css"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[...]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">Z5raisev</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L8</span></span></code> </pre> <br>  Another elementary: just call <code>raise</code> and after that jump to L8;  L8 does a normal return from a function.  If <code>raise</code> fails correctly, then execution (somehow, we still do not know how!) Should not continue on the next instruction, but go to the exception handler (which is called <code>landing pads</code> in ABI terms, more on that later). <br><br><pre> <code class="hljs pgsql"> cmpl <span class="hljs-meta"><span class="hljs-meta">$1</span></span>, %edx je .L5 .LEHB1: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _Unwind_Resume .LEHE1: .L5: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> __cxa_begin_catch <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> __cxa_end_catch</code> </pre> <br>  At first glance, this piece is a bit complicated, but in reality everything is simple.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The greatest amount of magic happens here: first we check if we can handle this exception, if not, we call </font></font><code>_Unwind_Resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if we can, we call </font></font><code>__cxa_begin_catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>__cxa_end_catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then the function should continue normally and thus L8 will be executed (L8 right under our catch block ):</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.L8</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_restore</span></span> 5 <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_def_cfa</span></span> 4, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.cfi_endproc</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just a normal function return ... with some CFI garbage in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is all for error handling, however, we still do not know how </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__cxa_begin / end_catch work</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">we have ideas for how this pair forms what the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">landing pad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calls </font><font style="vertical-align: inherit;">- the place in the function where the exception handlers are located. </font><font style="vertical-align: inherit;">What we do not know yet is how landing pads are searched. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unwind</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should somehow go through all the calls on the stack, check if there is any call (stack frame for accuracy) a valid block with a landing pad that can handle this exception, and continue execution there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an important achievement, and we will find out how this works in the next chapter.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++ exceptions under the hood: gcc_except_table and personal function </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Earlier, we found out that throw is translated into </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__cxa_allocate_exception / throw</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the catch block is translated to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__cxa_begin / end_catch</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as to something called CFI (call frame information) for searching for landing pads error handlers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What we don't know so far is how </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Unwind</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finds out where this landing pads are. When an exception is thrown through a bunch of functions in the stack, all CFIs allow the stack deployment program to find out what function is currently being executed, and also it is necessary to find out which of the landing pads functions allows us to handle this exception (and, by the way, we ignore functions with multiple try / catch blocks!).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To find out where this landing pads is located, use something that calls itself </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc_except_table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This table can be found (with CFI garbage) after the end of the function:</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.LFE1</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">gxx_personality_v0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.gcc_except_table</span></span>,"<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>",@<span class="hljs-keyword"><span class="hljs-keyword">progbits</span></span> [...] .LLSDACSE1: .long _ZTI14Fake_Exception</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This section </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.gcc_except_table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - where all the information for detecting landing pads is stored, we will talk about this later when we analyze the personal function. For now, we just say that LSDA means a zone with language-specific data that the personal function checks for landing pads for the function (it is also used to launch destructors in the process of expanding the stack). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize: for each function where there is at least one catch block, the compiler translates it into a couple of calls to </font></font><strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cxa_begin_catch /</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cxa_end_catch</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and then the personal function called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__cxa_throw</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , reads </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc_except_table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for each method in the stack to search for something called LSDA. The personal function then checks if there is a block in LSDA that handles this exception, as well as if there is any cleanup code (which runs the destructors when needed). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also make an interesting conclusion: if we use </font></font><a href="http://www.cplusplus.com/reference/new/nothrow/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nothrow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (or an empty throw statement), the compiler can omit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc_except_table</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the method. </font><font style="vertical-align: inherit;">This way of implementing exceptions in gcc, which does not greatly affect performance, in fact greatly influences the size of the code. </font><font style="vertical-align: inherit;">What about catch blocks? </font><font style="vertical-align: inherit;">If an exception is thrown when the nothrow specifier is declared, LSDA is not generated and the personal function does not know what to do. </font><font style="vertical-align: inherit;">When a personal function does not know what to do, it calls the default error handler, which, in most cases, means that the error from the nothrow method ends with std :: terminate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have an idea of ‚Äã‚Äãwhat a personal function does, can we implement it? </font><font style="vertical-align: inherit;">Well, let's see!</font></font><br><br>  <a href="https://habrahabr.ru/post/279151/">Continuation</a> <br></div><p>Source: <a href="https://habr.com/ru/post/279111/">https://habr.com/ru/post/279111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279101/index.html">Say a word about poor XWiki - 2</a></li>
<li><a href="../279103/index.html">Easy to deploy Meteor applications to your own server</a></li>
<li><a href="../279105/index.html">Containers: The quest for the "magic framework" and why it became Kubernetes</a></li>
<li><a href="../279107/index.html">1.3 SFML and Linux</a></li>
<li><a href="../279109/index.html">KTV. Rake on the way to marshaling</a></li>
<li><a href="../279113/index.html">Observation of internationalized domain names and the letter K</a></li>
<li><a href="../279117/index.html">Linear models: simple regression</a></li>
<li><a href="../279123/index.html">Superscalar stack processor: we continue to cross the grass and the hedgehog</a></li>
<li><a href="../279125/index.html">Dagger 2. Part One. Basics, creating a dependency graph, Scopes</a></li>
<li><a href="../279127/index.html">Nutanix Big Update: NutanixOS 4.6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>