<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reasoned factory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 Task 
 In the current project, I faced the need to generate inheritance objects from a common interface, while generating successors is n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reasoned factory</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br><h5>  Task </h5><br>  In the current project, I faced the need to generate inheritance objects from a common interface, while generating successors is necessary by passing them some constructor initializer to them.  The default constructor of classes may not be.  At the same time, a specific object factory is defined in dynamically loadable plug-ins, therefore it must have a specific interface. <br>  I can offer two ways to solve this problem. <br><a name="habracut"></a><br><h6>  Initial data </h6><br>  Suppose the factory interface should look like this: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFactoryBasic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IFactoryBasic() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IFactoryBasic() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Test* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;args)</span></span></span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      where <code>Test</code> is a certain base class <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: QString _word; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Test(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;word):_word(word) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Test() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"test "</span></span>&lt;&lt;_word; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestChild</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Test { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestChild(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;word): Test(word) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"test child"</span></span>&lt;&lt;_word; } };</code> </pre><br><br>  <code>TestChild</code> - <code>Test</code> heir <br>  Both classes accept the string parameter <code>word</code> in the constructor, which we can then verify in the <code>test()</code> function. <br><br><h5>  First way </h5><br>  The way is simple.  It is based on creating a template framework for a future factory. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFactory</span></span></span><span class="hljs-class"> {</span></span> QMap&lt;QString, C* (T::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A&amp;) &gt; handler; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, C *(T::*func)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A &amp;))</span></span></span><span class="hljs-function"> </span></span>{ handler[key]=func; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IFactory() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IFactory() {} <span class="hljs-function"><span class="hljs-function">C *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A &amp;args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(handler.contains(key)) { T* inheritor = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(inheritor) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (inheritor-&gt;*handler[key])(args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre><br><br>  There is a small obligation for class users.  The first template parameter must be a class that inherits from IFactory.  Further there will be explanations for what it was needed. <br>  <code>handler</code> <code>IFactory</code> class <code>IFactory</code> is an associative container containing a key and the corresponding object creation function.  The signature of the spawning function is described as <code>C* (T::*)(const A&amp;)</code> , that is, the return value will have a pointer to a certain <code>C</code> class, and the function argument is passed a reference to an object of type <code>A</code> <br>  The <code>add(...)</code> function adds a key-function pair <code>&lt;key,func&gt;</code> to the container. <br>  The function <code>make(...)</code> calls the spawn function, if it exists in the container (after dynamically transforming the pointer type of <code>this</code> to the type of the heir, otherwise you cannot call functions that were defined there). <br>  This is the main frame of the factory, it remains to describe a specific factory <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryFst</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IFactory&lt;FactoryFst, Test, QString&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IFactoryBasic { <span class="hljs-function"><span class="hljs-function">Test *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createOrigin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test(args); } <span class="hljs-function"><span class="hljs-function">Test *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestChild(args); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FactoryFst() { add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, &amp;FactoryFst::createOrigin); add(<span class="hljs-string"><span class="hljs-string">"testchild"</span></span>, &amp;FactoryFst::createChild); } <span class="hljs-function"><span class="hljs-function">Test *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make(key, args); } };</code> </pre><br><br>  It is easy to guess that we use multiple inheritance to meet the requirements of the <code>IFactoryBasic</code> interface.  For the other parent, we explicitly specify the heir of the <code>FactoryFst</code> , the returned pointer will be a pointer to an object of the <code>Test</code> class, and a reference to the <code>QString</code> object is passed as an argument. <br>  In accordance with this definition, functions are generated that generate objects of the type <code>Test</code> and <code>TestChild</code> : <br> <code>Test *createOrigin(const QString &amp;args){ return new Test(args); }</code>  <code>Test *createOrigin(const QString &amp;args){ return new Test(args); }</code> - creates an object of type Test, passing the argument <code>QString</code> to it in the constructor. <br> <code>Test *createChild(const QString &amp;args) { return new TestChild(args); }</code>  <code>Test *createChild(const QString &amp;args) { return new TestChild(args); }</code> - similarly creates an object of type <code>TestChild</code> . <br>  It remains only to register these functions in the <code>FactoryFst</code> constructor and define the <code>create(...)</code> <code>IFactoryBasic</code> interface. <br><br><h5>  Second way </h5><br>  This method mostly uses templates. <br>  To build a factory, we need a little preparation.  First you need to define some of the classes used by the factory. <br><br>  To begin with, we define an auxiliary class for storing the values ‚Äã‚Äãof the argument passed.  In order to allow the use of pointers to this class without hindrance, let's make it inheritable from a non-generic base class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Arguments() {} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArguments</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Arguments { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T arg; TArguments(T _arg):arg(_arg) {} };</code> </pre><br><br>  <code>Arguments</code> is the base class, <code>TArguments</code> is the template class for storing the transmitted object. <br><br>  We also need a template wrapper class to call the operator <code>new</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Container() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Arguments* )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><br>  A non-template <code>Container</code> serves the same purpose as <code>Arguments</code> .  So that we could always call the spawning function <code>make(...)</code> for any of its template heirs.  The <code>make(...)</code> function should return a pointer to the created object. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TContainer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Container { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Arguments* args=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ TArguments&lt;A&gt;* a = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt; TArguments&lt;A&gt;* &gt;( args ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(a-&gt;arg); } };</code> </pre><br><br>  The <code>TContainer</code> class <code>TContainer</code> already template, the type of the returned pointer <code>T</code> and the type of the argument for the constructor <code>A</code> passed to it as template arguments. <br>  In the function <code>make(...)</code> , the pointer to <code>Arguments</code> is passed as an argument, but we understand that in fact it must be a pointer to TArguments and try to dynamically convert the type.  If all conversions were successful, we can create an object of a previously defined type. <br><br>  As a result, the frame of the factory will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C=<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A=<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; class TemplateFactory { QMap&lt;QString, Container*&gt; handler; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TemplateFactory() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~TemplateFactory(){ qDeleteAll(handler.values()); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QString</span></span></span><span class="hljs-class"> &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">) {</span></span> handler.insert(name, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TContainer&lt;T, A&gt;()); } <span class="hljs-function"><span class="hljs-function">C *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A &amp;arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(handler.contains(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;C*&gt;(handler.value(name)-&gt;make(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TArguments&lt;A&gt;(arg))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre><br><br>  Here, the arguments of template <code>C</code> are the base class, <code>A</code> is the argument of the constructor of the objects being generated. <br>  The <code>add(...)</code> function registers new classes in the list, <code>make(...)</code> creates a class object, passing the function a key to select the type and the argument of the constructor to the function.  Type <code>static_cast</code> used to convert the type <code>void*</code> to the desired <code>C*</code> . <br>  Everything is ready to create a specific factory. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorySnd</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TemplateFactory&lt;Test, QString&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IFactoryBasic { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FactorySnd() { add&lt;Test&gt;(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); add&lt;TestCild&gt;(<span class="hljs-string"><span class="hljs-string">"testchild"</span></span>); } <span class="hljs-function"><span class="hljs-function">Test* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;arg)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make(name, arg); } };</code> </pre><br><br>  Again, multiple inheritance is used, the <code>create(...)</code> function is overridden.  In the constructor, classes are registered. <br><br><h5>  Result </h5><br><br>  Both factories work in what can be ascertained by executing the following code <br><pre> <code class="cpp hljs"> IFactoryBasic* factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactorySnd(); Test* test = factory-&gt;create(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"A"</span></span>); test-&gt;test(); test = factory-&gt;create(<span class="hljs-string"><span class="hljs-string">"testchild"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>); test-&gt;test(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> factory; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryFst(); Test *stest = factory-&gt;create(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>); stest-&gt;test(); stest = factory-&gt;create(<span class="hljs-string"><span class="hljs-string">"testchild"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>); stest-&gt;test();</code> </pre><br><br>  In the console we get the following exhaust: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"A"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> child <span class="hljs-string"><span class="hljs-string">"B"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> child <span class="hljs-string"><span class="hljs-string">"D"</span></span></code> </pre><br><br><h5>  Conclusion </h5><br>  The same problem, of course, can have more than one solution.  The solutions presented are not the only and infallible.  The first method gives more freedom, since it gives the right to define methods for generating objects, because in the same method, you can link this object with signals (if it is a <code>QObject)</code> heir <code>QObject)</code> or register it with an Observer.  You can also somehow modify the argument passed to the generating method before passing it to the constructor.  But the charge for this is more complex code maintenance, the addition of a new generated object.  The second method is less demanding in this respect, but leaves less freedom for the user.  That is, the creation of an object occurs as described in the base class and nothing else.  Also, factories are focused on creating objects inherited from one class and taking one object as an argument.  In this initializer object, all necessary properties must be encapsulated to create a new object.  This, of course, is not universal (it imposes certain restrictions on the objects being created), but it is quite suitable for solving an applied problem. </div><p>Source: <a href="https://habr.com/ru/post/192520/">https://habr.com/ru/post/192520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192508/index.html">Match Savings, or Elusive Joe Returns</a></li>
<li><a href="../192510/index.html">SoX Spectrum is a handy utility for creating graphic spectra of audio files.</a></li>
<li><a href="../192512/index.html">Python. Unit Test Generation</a></li>
<li><a href="../192516/index.html">The history of a single android application</a></li>
<li><a href="../192518/index.html">Parsing addresses with ‚Äúfuzzy regular expressions‚Äù</a></li>
<li><a href="../192522/index.html">Zend Framework 2 Blog Development Example. Part 1. ZendSkeletonApplication</a></li>
<li><a href="../192524/index.html">Kodak is afloat again, not bankrupt</a></li>
<li><a href="../192526/index.html">Anti-war Open Source</a></li>
<li><a href="../192528/index.html">Discount for the book ‚ÄúHTML5 and CSS3. Website development for any browsers and devices ¬ª</a></li>
<li><a href="../192530/index.html">Nymi: heartbeat authentication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>