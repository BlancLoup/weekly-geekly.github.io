<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Doom 3 BFG - source code review: Multithreading (part 2 of 4)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1: Introduction 
 Part 2: Multithreading 
 Part 3: Rendering (Approx. Translation - in the process of translation) 
 Part 4: Doom classic - integ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Doom 3 BFG - source code review: Multithreading (part 2 of 4)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/7c4/017/eb2/7c4017eb2e6a6141dd35a5023edba68e.jpg" align="right">  <a href="http://habrahabr.ru/post/180973/">Part 1: Introduction</a> <br>  <b>Part 2: Multithreading</b> <br>  Part 3: Rendering (Approx. Translation - in the process of translation) <br>  Part 4: Doom classic - integration (Approx. Translation - in the process of translation) <br><br>  The engine for Doom III was written between 2000 and 2004, at a time when most PCs were single-processor.  Although the idTech4 engine architecture was developed with support for SMP, it ended up with support for multithreading at the last minute ( <a href="http://fabiensanglard.net/doom3/interviews.php">see the interview with John Carmack</a> ). <br><a name="habracut"></a><br>  Since then, much has changed, there is a good article from Microsoft " <a href="http://msdn.microsoft.com/en-ca/library/windows/desktop/ee416321(v%3Dvs.85).aspx">Programming for multi-core systems</a> ": <br><br><blockquote>  For many years, processor performance has steadily increased, and games and other programs have benefited from this increase in power without the need for effort. <br>  The rules have changed.  The performance of single-core processors is currently growing very slowly, if at all.  However, the computing power of personal computers and consoles continues to grow.  The only difference is that basically this increase is now obtained due to the presence of multi-core processors. <br>  The increase in processor power is just as impressive as before, but now developers have to write multi-threaded code in order to unlock the full potential of this power. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Doom III BFG multi-core target platforms: <br><ul><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B8_Xbox_360">The Xbox 360</a> has one Xenon 3 core processor.  Simultaneous multithreading platform is 6 logical cores. </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B8_PlayStation_3">The PS3</a> has a PowerPC-based main unit (PPE) and eight synergistic cores (SPE). </li><li>  The PC often has a quad core processor.  With Hyper-Threading, this platform gets 8 logical cores. </li></ul><br>  As a result, idTech4 was strengthened not only with multi-threading support, but also with the idTech5 ‚ÄúJob Processing System‚Äù component, which adds support for multi-core systems. <br><br>  For your information: the Xbox One and PS4 specifications were announced not so long ago: both will have eight cores.  Another reason for any game developer to understand multi-threaded programming. <br><br><h4>  Doom 3 BFG Thread Model </h4><br><img align="right" src="https://habrastorage.org/storage2/4fe/067/c48/4fe067c489c707ece4ea99868279741d.png">  On the PC, the game starts in three streams: <br><ol><li>  Stream backend rendering interface (Sending GPU commands) </li><li>  The flow of game logic and rendering frontend interface </li><li>  Stream of high frequency joystick data entry (250Hz) </li></ol><br>  In addition, idTech4 creates two more worker threads.  They are needed to help any of the three main streams.  They are managed by the scheduler whenever possible. <br><br><h4>  main idea </h4><br>  Id Software announced the solution to the problems of multi-core programming in 2009 in the presentation " <a href="http://s09.idav.ucdavis.edu/talks/05-JP_id_Tech_5_Challenges.pdf">Beyond Programming Shaders</a> ".  Two main ideas here: <br><ul><li>  Separate task processing for processing by different threads (‚Äújobs‚Äù by ‚Äúworkers‚Äù) </li><li>  Avoid delegating synchronization to the operating system: do it yourself for atomic operations </li></ul><br><br><h4>  System components </h4><br>  The system consists of 3 components: <br><ul><li>  Tasks (Jobs) </li><li>  Handlers (Workers) </li><li>  Synchronization </li></ul><br><br>  Tasks are exactly what one would expect: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">job_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (* function )(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Job instructions void * data; // Job parameters int executed; // Job end marker...Not used. };</span></span></code> </pre> <br><br>  <u>Note:</u> According to the comments in the code, ‚Äúthe task must last at least a <i>couple of 1000 cycles</i> in order to outweigh the switching costs.  On the other hand, a task should not last more than a <i>few 100,000 cycles</i> to maintain a good balance of workload between several processes. <br>  A handler is a stream that will remain inactive pending a signal.  When it is activated it tries to find the task.  Handlers try to avoid synchronization using atomic operations, trying to get a task from the general list. <br><br>  Synchronization is performed through three primitives: signals, mutexes, and atomic operations.  The latter is preferable, as it allows the engine to maintain the focus of the CPU.  Their implementation <a href="https://habr.com/ru/post/181081/">is described in</a> detail <a href="https://habr.com/ru/post/181081/">at the bottom of this page</a> . <br><br><h4>  Architecture </h4><br><img align="left" src="https://habrastorage.org/storage2/9a9/ee4/402/9a9ee4402efc8d923256c22149eb3f13.png">  The brain of the subsystem is ParalleleJobManager.  It is responsible for generating thread handlers and creating queues in which tasks are stored. <br><br>  And the first idea is to bypass the synchronization: divide the task lists into several sections, each of which is addressed only by one thread and, therefore, synchronization is not required.  In the engine, such queues are called idParallelJobList. <br><br>  There are only three sections in Doom III BFG: <br><ul><li>  Render frontend-a </li><li>  Render backend-a </li><li>  Utilities </li></ul><br>  On a PC, two worker threads are created at startup, but probably more are created in XBox360 and PS3. <br><br>  According to the 2009 presentation, more sections have been added to idTech5: <br><ul><li>  Defect detection </li><li>  Animation processing </li><li>  Obstacle avoidance </li><li>  Texture processing </li><li>  Particle Transparency Processing </li><li>  Fabric simulation </li><li>  Water surface simulation </li><li>  Detailed generation of models </li></ul><br><br>  Note: The presentation also mentions the concept of a one-frame delay, but this part of the code does not apply to the Doom III BFG. <br><br><h4>  Distribution of tasks </h4><img align="right" src="https://habrastorage.org/storage2/7af/2ef/47c/7af2ef47cd20ae7cf35258fd7ce3b1e8.png">  Running handlers are constantly waiting for a job.  This process does not require the use of mutexes or monitors: atomic increment distributes tasks without overlapping. <br><br><h4>  Using </h4><br>  Since tasks are divided into sections accessible only to one thread, synchronization is not necessary.  However, giving the task to the system handler does imply a mutex: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//tr.frontEndJobList is a idParallelJobList object. for ( viewLight_t * vLight = tr.viewDef-&gt;viewLights; vLight != NULL; vLight = vLight-&gt;next ) { tr.frontEndJobList-&gt;AddJob( (jobRun_t)R_AddSingleLight, vLight ); } tr.frontEndJobList-&gt;Submit(); tr.frontEndJobList-&gt;Wait();</span></span></code> </pre><br><br><h5>  Methods: </h5><br><img align="right" src="https://habrastorage.org/storage2/e2f/861/036/e2f86103632466baca36b35db897c37b.png"><br><br><ul><li>  <b>Adding task</b> : no synchronization needed, tasks are added to the queue </li><li>  <b>Sending</b> : mutex synchronization, each handler replenishes total JobLists from its local JobLists. </li><li>  <b>Synchronization signal (OS delegation)</b> : </li></ul><br><br><h4>  How the handler is executed </h4><img align="right" src="https://habrastorage.org/storage2/c2d/a9e/ebc/c2da9eebc463f64d181ec3afd39530d4.png"><br>  Handlers are executed in an infinite loop.  In each iteration, the ring buffer is checked, and if the task is found, it is copied to the local stack. <br><br>  Local stack: The stack of the thread is used to store the addresses of joblists to prevent the mechanism from stopping.  If the thread cannot ‚Äúblock‚Äù the JobList, it falls into RUN_STALLED mode.  This stop can be canceled by moving the stack from the local JobLists to the common list. <br><br>  It is interesting that everything will be done without any reciprocal mechanisms: only atomic operations. <br><br><div class="spoiler">  <b class="spoiler_title">Endless cycle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idJobThread::Run() { threadJobListState_t threadJobListState[MAX_JOBLISTS]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !IsTerminating() ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentJobList = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// fetch any new job lists and add them to the local list in threadJobListState {} if ( lastStalledJobList &lt; 0 ) // find the job list with the highest priority else // try to hide the stall with a job from a list that has equal or higher priority currentJobList = X; // try running one or more jobs from the current job list int result = threadJobListState[currentJobList].jobList-&gt;RunJobs( threadNum, threadJobListState[currentJobList], singleJob ); // Analyze how job running went if ( ( result &amp; idParallelJobList_Threads::RUN_DONE ) != 0 ) { // done with this job list so remove it from the local list (threadJobListState[currentJobList]) } else if ( ( result &amp; idParallelJobList_Threads::RUN_STALLED ) != 0 ) { lastStalledJobList = currentJobList; } else { lastStalledJobList = -1; } } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Running Tasks</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idParallelJobList::RunJobs( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadNum, threadJobListState_t &amp; state, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> singleJob ) { <span class="hljs-comment"><span class="hljs-comment">// try to lock to fetch a new job if ( fetchLock.Increment() == 1 ) { // grab a new job state.nextJobIndex = currentJob.Increment() - 1; // release the fetch lock fetchLock.Decrement(); } else { // release the fetch lock fetchLock.Decrement(); // another thread is fetching right now so consider stalled return ( result | RUN_STALLED ); } // Run job jobList[state.nextJobIndex].function( jobList[state.nextJobIndex].data ); // if at the end of the job list we're done if ( state.nextJobIndex &gt;= jobList.Num() ) { return ( result | RUN_DONE ); } return ( result | RUN_PROGRESS ); }</span></span></code> </pre><br></div></div><br><a name="syn_tools"></a><br><br><h4>  Id Software Synchronization Tools </h4><br>  <b>Id Software uses three types of synchronization mechanisms:</b> <br>  <u>1. Monitors (idSysSignal):</u> <br><table><tbody><tr><td>  <b>Abstraction</b> <br></td><td>  <b>Operation</b> <br></td><td>  <b>Implementation</b> <br></td><td>  Note <br></td></tr><tr><td>  <b>idSysSignal</b> <br></td><td><br></td><td>  <b><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686915(v%3Dvs.85).aspx">Event objects</a></b> <br></td><td><br></td></tr><tr><td><br></td><td>  Raise <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686211(v%3Dvs.85).aspx">SetEvent</a> <br></td><td>  Sets the specified object event to an alarm state. <br></td></tr><tr><td><br></td><td>  Clear <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms685081(v%3Dvs.85).aspx">ResetEvent</a> <br></td><td>  Sets the specified object event to a non-alarm state. <br></td></tr><tr><td><br></td><td>  Wait <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v%3Dvs.85).aspx">WaitForSingleObject</a> <br></td><td>  Waits until the specified object is in a signal state or until the wait time has elapsed. <br></td></tr></tbody></table>  Signals are used to stop the flow.  Handlers use idSysSignal.Wait () to remove themselves from the operating system scheduler if there are no jobs. <br><br>  <u>2. Mutexes (idSysMutex):</u> <br><table><tbody><tr><td>  <b>Abstraction</b> <br></td><td>  <b>Operation</b> <br></td><td>  <b>Implementation</b> <br></td><td>  Note <br></td></tr><tr><td>  <b>idSysMutex</b> <br></td><td><br></td><td>  <b><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686915(v%3Dvs.85).aspx">Critical Section Objects</a></b> <br></td><td><br></td></tr><tr><td><br></td><td>  Lock <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682608(v%3Dvs.85).aspx">EnterCriticalSection</a> <br></td><td>  Waits to receive the specified critical section object.  The function returns when the calling thread has received the property. <br><br></td></tr><tr><td><br></td><td>  Unlock <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684169(v%3Dvs.85).aspx">LeaveCriticalSection</a> <br></td><td>  Implements getting the specified object of the critical section. <br></td></tr><tr><td><br></td><td><br></td><td><br></td><td></td></tr></tbody></table><br><br>  <u>3. Atomic operations (idSysInterlockedInteger):</u> <br><table><tbody><tr><td>  <b>Abstraction</b> <br></td><td>  <b>Operation</b> <br></td><td>  <b>Implementation</b> <br></td><td>  Note <br></td></tr><tr><td>  <b>idSysInterlockedInteger</b> <br></td><td><br></td><td>  <b><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684122(v%3Dvs.85).aspx">Interlocked variable</a></b> <br></td><td><br></td></tr><tr><td><br></td><td>  Increment <br></td><td>  <a href="http://msdn.microsoft.com/en-ca/library/windows/desktop/ms683618(v%3Dvs.85).aspx">InterlockedIncrementAcquire</a> <br></td><td>  Incrementing the value of a given 32-bit variable as an atomic operation. The operation has the semantics ‚Äúacquire‚Äù. <br></td></tr><tr><td><br></td><td>  Decrement <br></td><td>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms683586(v%3Dvs.85).aspx">InterlockedDecrementRelease</a> <br></td><td>  Decrementing the value of a given 32-bit variable as an atomic operation.  The operation has the release semantics. <br></td></tr></tbody></table></div><p>Source: <a href="https://habr.com/ru/post/181081/">https://habr.com/ru/post/181081/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181053/index.html">Educational Data Mining: Introduction</a></li>
<li><a href="../181057/index.html">Atmix Recall DCR 300 Recorder Review: Is Happiness for 1,500 Rubles?</a></li>
<li><a href="../181065/index.html">Dynamic Linq Queries or Tame Expression Trees</a></li>
<li><a href="../181071/index.html">Should the printer be printed in white?</a></li>
<li><a href="../181077/index.html">Accounting ... social network</a></li>
<li><a href="../181083/index.html">LESS-Mix - a little about LESS-mixing</a></li>
<li><a href="../181085/index.html">For the suspect in the "piracy" of the Englishman came a whole train of police cars</a></li>
<li><a href="../181089/index.html">MTS asks the state to protect itself from Skype</a></li>
<li><a href="../181091/index.html">Will MySpace ever lose its monopoly?</a></li>
<li><a href="../181093/index.html">Django: Using QR codes to quickly enter the site from mobile devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>