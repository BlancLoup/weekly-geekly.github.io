<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Denormalization DB. What for? When? How?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Is denormalization an evil or just need to be able to cook it? 
 Denormalization is not the result of curved arms. This is not unfinished normalizatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Denormalization DB. What for? When? How?</h1><div class="post__text post__text-html js-mediator-article"><h4>  Is denormalization an evil or just need to be able to cook it? </h4><br>  Denormalization is not the result of curved arms.  This is not unfinished normalization, it is a deliberate violation of normal forms, to increase productivity. <br>  <i>The question of denormalization arose more than once.</i>  <i>Every time when it was necessary to make a deal with conscience, violating the principles of normal forms, there was a feeling of dissatisfaction, a false awareness of their incompetence.</i>  <i>Over time, when working in a team, it turned out that this is not only my problem.</i>  <i>It is time to understand: is denormalization an evil, or just need to be able to cook it?</i> <br><a name="habracut"></a><br><h5>  What I wanted to understand </h5><br><ul><li>  When is denormalization needed?  Signs and smells. </li><li>  How to determine when denormalization is justified? </li><li>  How to correctly implement denormalization </li></ul><br><br><h5>  When is denormalization needed?  Signs and smells. </h5><br>  Consider some common situations in which denormalization may be useful. <br><br><h6>  A large number of table joints. </h6><br>  In queries to a fully normalized database, it is often necessary to connect up to a dozen, if not more, tables.  And each connection is a very resource-intensive operation.  As a result, such requests consume server resources and are executed slowly. <br>  In such a situation can help: <br><ul><li>  denormalization by reducing the number of tables.  It is better to combine several tables with small size, containing rarely changeable (as they often say, conditionally constant, or reference data) information, and information that is closely related to each other. <br>  In general, if a large number of queries are required to combine more than five or six tables, you should consider the option of denormalizing the database. </li><li>  Denormalization by entering an additional field in one of the tables.  In this case, data redundancy appears, additional actions are required to preserve the integrity of the database. <br></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Calculated values. </h6>  Frequently, queries are executed slowly and consume a lot of resources, in which some complex calculations are performed, especially when using groupings and aggregate functions (Sum, Max, etc.).  Sometimes it makes sense to add to the table 1-2 additional columns containing frequently used (and difficult to calculate) calculated data. <br>  Suppose you need to determine the total cost of each order.  To do this, you must first determine the cost of each product (according to the formula "the number of units of the product" * "the price of a unit of product" - a discount).  After that it is necessary to group the costs by orders. <br>  Execution of this query is quite complex and, if the database contains information about a large number of orders, it can take a long time.  Instead of executing such a request, you can determine its cost at the stage of placing an order and save it in a separate column of the order table.  In this case, to obtain the desired result, it suffices to extract the previously calculated values ‚Äã‚Äãfrom this column. <br>  Creating a column containing pre-calculated values ‚Äã‚Äãsaves a lot of time when executing a query, but requires timely changes to the data in this column. <br><br><h6>  Long fields. </h6>  If we have large tables in the database that contain long fields (Blob, Long, etc.), then we can seriously speed up the execution of queries to such a table if we put long fields into a separate table.  We want, for example, to create a catalog of photos in the database, including storing in the blob-fields and the photos themselves (professional quality, high resolution, and the appropriate size).  From the point of view of normalization, the following table structure is absolutely correct: <br>  ID photos <br>  Author ID <br>  Camera model id <br>  photo itself (blob-field). <br>  Now let's imagine how long the query will work, counting the number of photos taken by any author ... <br>  The correct solution (although violating the principles of normalization) in such a situation would be to create another table consisting of only two fields - the photo ID and the blob field with the photo itself.  Then the samples from the main table (in which there is no longer a huge blob-field) will go instantly, but when we want to see the photo itself - well, let's wait ... <br><br><h5>  How to determine when denormalization is justified? </h5><br><br><h6>  Costs and benefits. </h6><br>  One way to determine whether these or other steps are justified is to conduct an analysis in terms of costs and possible benefits.  How much will a denormalized data model cost? <br>  Determine the requirements (what we want to achieve) -&gt; determine the data requirements (which must be met) -&gt; find the minimum step that satisfies these requirements -&gt; calculate the cost of implementation -&gt; implement. <br>  Costs include physical aspects, such as disk space, the resources needed to manage this structure, and lost opportunities due to the time delays associated with maintaining this process.  For denormalization you have to pay.  A denormalized database increases data redundancy, which can improve performance, but will require more effort to control related data.  The process of creating applications will be complicated, since the data will be repeated and more difficult to track.  In addition, the implementation of referential integrity is not a simple matter - the associated data is divided according to different tables. <br>  Benefits include higher performance when executing a request and the ability to get a faster response.  In addition, you can get other benefits, including increased bandwidth, customer satisfaction and productivity, as well as more efficient use of tools from external developers. <br><br><h6>  Frequency requests and sustainability performance. </h6><br>  For example, 70% of the 1000 requests generated daily by an enterprise are requests of the level of summary rather than detailed data.  When using the summary data table, queries are executed in about 6 seconds instead of 4 minutes, i.e.  processing time is shorter by 2730 minutes.  Even adjusting for those 105 minutes that need to be spent weekly to support summary tables, as a result, it saves 2,625 minutes a week, which fully justifies the creation of a summary table.  Over time, it may happen that most of the requests will be addressed not to the summary data, but to the detailed data.  The smaller the number of queries that use the summary data table, the easier it is to drop it without affecting other processes. <br><br><h6>  Other </h6><br>  The criteria listed above are not the only ones that should be considered when deciding whether to take the next step in optimization.  There are other factors to consider, including business priorities and end-user needs.  Users need to understand how, from a technical point of view, the requirement of users who want all requests to be executed in a few seconds affects the system architecture.  The easiest way to achieve this understanding is to outline the costs associated with the creation of such tables and their management. <br><br><h5>  How to correctly implement denormalization. </h5><br><br><h6>  Save detailed tables </h6><br>  In order not to limit the database capabilities important to business, it is necessary to adhere to the strategy of coexistence, not replacement, i.e.  save detailed tables for in-depth analysis, adding to them denormalized structures.  For example, the counter of visits.  For business, you need to know the number of visits to the web page.  But for the analysis (by periods, by countries ...) we are very likely to need detailed data - a table with information about each visit. <br><br><h6>  Use triggers </h6><br>  It is possible to denormalize the structure of the database and at the same time continue to take advantage of the normalization, if you use database triggers to preserve the integrity of the information, the identity of duplicate data. <br>  For example, when adding a calculated field to each of the columns on which the calculated field depends, a trigger is called that calls a <b>single stored procedure</b> (this is important!), Which writes the required data into the calculated field.  It is only necessary not to miss any of the columns on which the calculated field depends. <br><br><h6>  Software support </h6><br>  Naroimer, in MySQL version 4.1, there are no triggers or stored procedures at all.  Therefore, application developers should take care of ensuring the consistency of data in a denormalized database.  By analogy with triggers, there should be one function that updates all fields that depend on the variable field. <br><br><h5>  Summary </h5><br>  Let's sum up.  When denormalizing, it is important to maintain a balance between increasing the speed of the database and increasing the risk of inconsistent data, between making life easier for programmers who write Selects, and complicating the task of those who provide database filling and data updating.  Therefore, it is necessary to carry out denormalization of the base very carefully, very selectively, only where it is impossible to do without it. <br>  If it is impossible to calculate in advance the pros and cons of denormalization, then it is initially necessary to implement a model with normalized tables, and only then, to optimize problem queries, to denormalize. </div><p>Source: <a href="https://habr.com/ru/post/64524/">https://habr.com/ru/post/64524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../64515/index.html">Introduction to google api</a></li>
<li><a href="../64516/index.html">The biggest theft of corporate Twitter documents</a></li>
<li><a href="../64520/index.html">On the basis of Youtube made the world's first interactive advertising from the first person</a></li>
<li><a href="../64521/index.html">Habrayuzer, do you trust your IM passwords to the meebo.com service?</a></li>
<li><a href="../64523/index.html">Michael died, but his work lives</a></li>
<li><a href="../64525/index.html">Google OS Myths</a></li>
<li><a href="../64527/index.html">Perfect set for music lover</a></li>
<li><a href="../64528/index.html">Ballmer screams again</a></li>
<li><a href="../64530/index.html">Alignment of form fields using CSS</a></li>
<li><a href="../64531/index.html">Google Calendar has new features installed.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>