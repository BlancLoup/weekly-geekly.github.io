<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fixie - testing by agreement</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, I got a tweet that my acquaintance began to use the new test open source framework Fixie and was very pleased with it. So, I even decid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fixie - testing by agreement</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/74e/56f/955/74e56f95500c79efd65675810365e6ce.png" alt="01" width="192" height="192">  Some time ago, I got a tweet that my acquaintance began to use the new test open source framework <strong>Fixie</strong> and was very pleased with it.  So, I even decided to fix all the tests in my project for a new engine.  After this, I simply could not stand aside and did not even look at what kind of animal it was and why it pleases others. <br><br>  Next, I want to provide you with an overview of the framework, its capabilities, and to understand whether this is a new word in testing, if you look at it or you can go by and forget. <br><br>  As stated on the <a href="http://fixie.github.io/">site</a> itself, Fixie is Conventional Testing for .NET.  Those.  testing by agreement.  Agreements here means what we are accustomed to in general - all operations are carried out on the basis of an ‚Äúoral‚Äù agreement, a gentleman's naming agreement.  The closest example is scaffolding.  This is when we agreed, for example, that test classes contain the word Test, or that test classes should be public and not return anything.  Then such classes will be recognized as test.  And no more attributes and all that stuff.  Just classes and methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At first glance, it all looks good and even happy.  It turns out that it is only necessary to correctly name the methods and classes and there will be happiness.  At the same time, you can train the team to call test classes as necessary, rather than an arbitrary combination of words, somehow related to the topic of the class under test. <br><a name="habracut"></a><br><h2>  Installation and first test </h2><br>  By default, Fixie is configured so that the test classes are everything that ends in <strong>Tests</strong> .  Test methods - everything inside these classes does not return values.  Those.  theoretically and, in fact, practically, such code will already be recognized as a test: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SuperHeroTests</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NameShouldBeFilled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> superHero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuperHero(); superHero.Name .Should() .NotBeEmpty(); } }</code> </pre> <br>  Before proceeding further, it is worthwhile to say a few words about the installation, and what is necessary for the work of Fixie. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d45/2da/daf/d452dadafe667e7c216db4946283f327.png" alt="02" width="730" height="77"></a> <br><br>  The nuget command to install the framework itself.  But that‚Äôs not the end of it.  <strong>The framework does not provide a built-in method for writing test data in a test.</strong>  To use them, you need to use one of the third-party solutions: <br><ul><li>  FluentAssertions </li><li>  Should </li><li>  Shouldly </li><li>  Something different from this topic </li></ul><br>  This is still set using NuGet.  In the example above, the FluentAssertion package is used, since I personally like it more and there is essentially no big difference compared to other options. <br><br>  That's all, and you can happily and fun to write code.  If you just started your way in development and testing in particular.  If you are an experienced person, there are many questions about how this thing is configured and how convenient it is to drive tests. <br><br><h2>  Integration </h2><br>  By the way about running tests.  The author honestly admits that he had to run tests from the console and therefore he did integrate with the studio last.  There is a plugin for ReSharper, but it is for versions from 8.1 to 8.3, i.e.  With the new version you are a proletarian.  For the sake of tests, I did not want to roll back to version 8, so I can‚Äôt say how comfortable it is. <br><br>  Integration with the studio is performed at the level of detecting tests and running them.  Those.  There will be no highlighting in the editor.  There are in view of special marks of tests. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc2/6b3/e36/bc26b3e3662c3f5633825a0f81c184e2.png" alt="03" width="429" height="193"></a> <br><br>  Here, in my opinion, lies the <strong>potential place of error</strong> .  Ochepyatki.  It is not so difficult to be sealed in the word ‚ÄúTests‚Äù, which will lead to the omission of tests.  Visually, they do not stand out.  For the sake of justice, I must say that such a situation is rare and unlikely if you use the right tools of the studio and run not all the tests, but, for example, only those that have not been run before. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/343/cfa/2c8/343cfa2c8e138c987fd91887434b76f1.png" alt="04" width="325" height="199"></a> <br><br>  In general, it is possible so far to refer to the youth of the framework and relative uncertainty and, as a result, the absence of many tools. <br><br>  In order not to return twice to the topic of detecting tests and generating results, the documentation informs us that Fixie can generate reports in the NUnit and xUnit style, which will make life easier for those who normally have a CI built. <br><br><h2>  Tuning </h2><br>  The main strength of the framework is the ability to flexibly customize how your tests will be identified, how to run and how to be validated, and so on.  By default, nothing comes with the framework.  However, there are many <a href="https://github.com/fixie/fixie/tree/master/src/Fixie.Samples">different examples</a> in the <a href="https://github.com/fixie/fixie">repository</a> . <br><br>  To make things more interesting, let's dig a little bit in how to customize the framework for your needs.  For example, how to say which other classes should be identified as test classes. <br><br>  All settings occur in the constructor class inherited from <strong>Convention.</strong> <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomConvention</span></span> : <span class="hljs-title"><span class="hljs-title">Convention</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomConvention</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  By default, the settings look something like this: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DefaultConvention : Convention { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DefaultConvention () { Classes .NameEndsWith("Tests"); Methods .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.IsVoid()); } }</code> </pre> <br>  The code says that test classes must end with Tests and the test method will be all that returns null.  In general, fit. <br><br>  I try to adhere to the principle when the test class begins with the word <strong>When,</strong> and the tests with the words <strong>Then</strong> .  It turns out quite a slim picture in the testranner and when writing tests you already know what you are testing, i.e.  you only need to think about the effects for the test.  An added bonus is that test classes are short and the responsibility between tests is not mixed. <br><br>  Naturally, any rule only indicates direction, and is not a dogma.  "A Foolish Consistency is the Hobgoblin of Little Minds" - so you should always be guided by common sense. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d36/75b/92a/d3675b92a8600ccc040b12c37bb31940.png" width="866" height="748"></a> <br><br>  Looking at my list of tests, I see that not all classes end with the word <strong>Tests</strong> or begin with <strong>When</strong> . <br><br>  There is no strict naming structure in tests either, in the sense that tests must begin with the word Should, for example.  But in my opinion, reading tests perfectly understand what is happening there.  I say this based on experience.  This project has been simulating for 3-4 years already with varying success, and each time I quickly and successfully recall what has been done and what needs to be done.  It's just some outlet when there is too much paperwork. <br><br>  In this naming mode, I‚Äôm scared (and laziness) to specify keywords by which test classes will be defined.  In addition, the approach When ... Then ... in practice means that there is a configuration method that runs at the beginning of each test and in the test itself either the results are checked or we influence the created object somehow.  Those.  it will be necessary to explicitly mark, or specify the configuration method (SetUp). <br><br>  For implementation, I can explicitly invoke the tuning method in each test.  For example, like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SuperHeroTests</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NameShouldBeFilled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SetUpEnvironment(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> superHero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuperHero(); superHero.Name .Should() .NotBeEmpty(); } }</code> </pre><br>  Of course, in real life, you need to write something more informative than SetUpEnvironment (), but the idea is clear.  With such an implementation, there will be class variables that will save their values ‚Äã‚Äãbetween tests - which can easily lead to dependent tests if I forget to prescribe an initialization string in some test. <br><br>  Fixie offers a solution for this situation.  Here it is: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DefaultConvention</span></span> : <span class="hljs-title"><span class="hljs-title">Convention</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultConvention</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Classes .NameEndsWith(<span class="hljs-string"><span class="hljs-string">"Tests"</span></span>); Methods .Where(method =&gt; method.IsVoid()); CaseExecution .Wrap&lt;HeroUniverseSetup&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HeroUniverseSetup</span></span> : <span class="hljs-title"><span class="hljs-title">CaseBehavior</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Case context, Action next</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre><br>  Those.  it is necessary to implement the successor of <strong>CaseBehavior</strong> and register there everything that is necessary.  Documentation says implementation <br><ul><li>  CaseBehavior = [SetUp] / [TearDown] </li><li>  FixtureExecution = [FixtureSetUp] / [FixtureTearDown] </li></ul><br><br><br>  Well, but even so, in this approach, I see that I need to create many variants of DefaultConvention and prescribe initialization logic far from the test, while starting you will not even know that such a context exists. <br><br>  It is easy to demonstrate.  Let DefaultConvention be as in the example above, then when you run the class <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SuperHeroTests</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NameShouldBeFilled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> superHero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuperHero(); superHero.Name .Should() .NotBeEmpty(); } }</code> </pre><br>  Nothing tells me that there is SetUp / TearDown. <br><br><img src="https://habrastorage.org/files/99f/bdd/1f8/99fbdd1f8fd74ac08595f3f8e0cbd33d.gif"><br><br>  MAGIC!!!  In general, it is interesting, but in this case, not.  I would not want to imagine such magic on the project.  This is completely contrary to the fact that tests should be transparent.  Even if I write an extension for <strong>CaseBehavior</strong> in the same class <strong>,</strong> this is not a solution, since it will not be very obvious where I will look for a class in which all this will be configured.  Doing constant save-paste is also not an option. <br><br>  Compare: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DefaultConvention : Convention { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DefaultConvention () { Classes .InTheSameNamespaceAs(typeof(DefaultConvention)) .NameEndsWith("Tests"); Methods .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.IsVoid()); CaseExecution .Wrap&lt;HeroUniverseSetup&gt;(); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> HeroUniverseSetup : CaseBehavior { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Execute</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> context, Action next) { //  } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SuperHeroTests { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> NameShouldBeFilled() { var superHero = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SuperHero(); superHero.Name .Should() .NotBeEmpty(); } }</code> </pre><br>  Vs: <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SuperHeroTests</span></span> { [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  } [Test] public void NameShouldBeFilled() { var superHero = new SuperHero(); superHero.Name .Should() .NotBeEmpty(); } }</span></span></code> </pre> <br>  The lines of code will somehow be smaller in the case of NUnit, and SetUp from the class will not be lost in the project. <br><br>  Maybe I am biased and write tests incorrectly, but ... I'm not sure about that.  I have not yet met a lot of articles that SetUp is evil.  Those.  everything can be brought to the point of absurdity and initialization in SetUp of half the project, but this is a different matter. <br><br><br><br>  However, in this case there is a solution.  You can use handwritten attributes to determine the desired parts of the test, tests, and classes.  Those.  <a href="http://fixie.github.io/docs/custom-conventions/">You can fully</a> emulate NUnit, xUnit in your project. <br><br>  With the help of attributes you can do <br><ul><li>  category support </li><li>  parameterized tests </li><li>  strict tests </li><li>  all that comes to mind </li></ul><br><br><br>  I will give here a small example of creating categories and launching them. <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CustomConvention : Convention { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> CustomConvention() { var desiredCategories = <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>["include"].ToArray(); var shouldRunAll = !desiredCategories.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>(); Classes .InTheSameNamespaceAs(typeof(CustomConvention)) .NameEndsWith("Tests"); Methods .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.IsVoid()) .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> =&gt; shouldRunAll || MethodHasAnyDesiredCategory(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>, desiredCategories)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shouldRunAll) { Console.WriteLine("Categories: " + string.<span class="hljs-keyword"><span class="hljs-keyword">Join</span></span>(", ", desiredCategories)); Console.WriteLine(); } } static <span class="hljs-type"><span class="hljs-type">bool</span></span> MethodHasAnyDesiredCategory(MethodInfo <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>, string[] desiredCategories) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Categories(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>(testCategory =&gt; desiredCategories.Contains(testCategory.Name)); } static CategoryAttribute[] Categories(MethodInfo <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.GetCustomAttributes&lt;CategoryAttribute&gt;(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).ToArray(); } }</code> </pre><br>  And run tests depending on the category: <br>  <strong>Fixie.Console.exe path / to / your / test / project.dll --include CategoryA</strong> <br><br><h2>  My decision </h2><br>  You can say a lot more about Fixie, give examples of solving various problems, but the first impression is already there.  Therefore it is worth rounding out. <br><br>  It turns out that Fixie is a metaframe for testing.  You are free to build any rules and opportunities for testing, while they are built quite simply, to be honest.  The only question is expediency.  Is it necessary to do it all?  A little scares away, of course, the lack of support for R #, and the fact that I don‚Äôt see that the test is really a test, and it was recognized by the framework.  In production, I would not use it, but for home use and as a promising tool - <b>Fixie is very interesting</b> .  At least, I will definitely remember it if there is some interesting and specific testing task that will be difficult to solve using standard NUnit tools. </div><p>Source: <a href="https://habr.com/ru/post/263057/">https://habr.com/ru/post/263057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263047/index.html">A selection of current and useful materials on Ruby # 1: articles, reports, podcasts, gems</a></li>
<li><a href="../26305/index.html">iPhone in Northern Europe - this year</a></li>
<li><a href="../263051/index.html">Federal Business Intensive Development Program GenerationS has selected IBM Cloud to create an online platform</a></li>
<li><a href="../263053/index.html">How to organize distributed database design?</a></li>
<li><a href="../263055/index.html">#DockerCon #DockerCon #DockerCon Production and Persistence for Containers</a></li>
<li><a href="../263059/index.html">Live Webcast Launch Visual Studio 2015</a></li>
<li><a href="../26306/index.html">Intellectual property and its future: my understanding</a></li>
<li><a href="../263061/index.html">7 rules for creating beautiful interfaces. Part 2</a></li>
<li><a href="../263063/index.html">What else can a browser know about you?</a></li>
<li><a href="../263065/index.html">Release of InterSystems Cach√© 2015.2 DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>