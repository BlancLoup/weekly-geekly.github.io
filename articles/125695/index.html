<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>StructureMap - quick reference for work (2/3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of the first post about StructureMap 

 The first part covered the following topics: 


- Installation 
- Registration (Base, Profiles, P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>StructureMap - quick reference for work (2/3)</h1><div class="post__text post__text-html js-mediator-article">  Continuation of the <a href="http://habrahabr.ru/blogs/net/125613/">first post</a> about StructureMap <br><br>  The first part covered the following topics: <br><ul><li>  Installation </li><li>  Registration (Base, Profiles, Plugins, Crawl, Deployment) </li></ul><br>  In this part we will talk about: <br><ul><li>  Constructors (Simple Types, Default Constructor, Compound Types, Type Casting, Specifying Arguments) </li><li>  Properties (Simple setting of properties, Built-in setting of properties, Setting properties by a framework, Finishing existing classes) </li><li>  Lifetime </li></ul><br><br><h1>  Constructors </h1><br>  A very important question in real programming in relation to resolving dependencies in IoC containers, how to deal with classes that have several constructors.  How to initialize them, how to set parameters, how to modify and so on and so forth.  I hope that most of the questions below will be answered.  StructureMap is really powerful and flexible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before you begin to describe the capabilities of the framework, you need to talk about test classes.  This time they will be more difficult.  Inheritance, constructors with simple types, with composite. <br><br><a name="habracut"></a><br><br>  So, let us have the following classes: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClassA</span></span> : <span class="hljs-title"><span class="hljs-title">IClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClassB</span></span> : <span class="hljs-title"><span class="hljs-title">IClass</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassA</span></span> : <span class="hljs-title"><span class="hljs-title">IClassA</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class1 Class1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [DefaultConstructor] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { A = a; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassB</span></span> : <span class="hljs-title"><span class="hljs-title">IClassB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IClassA ClassA; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassB</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IClassA classA</span></span></span><span class="hljs-function">)</span></span> { ClassA = classA; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassM</span></span> : <span class="hljs-title"><span class="hljs-title">IClassA</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { A = a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { A = a + b; } }</code> </pre> <br>  They are with some redundancy at the moment, which come in handy a little further in the narration. <br><br>  So let's start with the simplest options. <br><br><h2>  Simple types </h2><br>  Let's start with the class ClassA, in which one of the constructors takes an integer parameter. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithSimpeArguments</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithSimpeArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>) ); } }</code> </pre> <br>  As you can see from the example, an indication of the initialization of the constructor by values ‚Äã‚Äãis added to the already familiar declaration.  In this case, the constructor declaration follows the simplified scheme, since there is only one parameter of type int.  During the initialization process, we immediately indicated the value.  In this case, the StructureMap will prompt that the value should be integer. <br><br>  To test the work, you can call the already familiar code <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithSimpleArgumentsExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithSimpeArguments().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classA = (ClassA) container.GetInstance&lt;IClassA&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> classA.A.ToString(); }</code> </pre> <br>  As a result, the number 5 is displayed on the console. <br><br>  Let's complicate the example for the case when we have two parameters of the same type in the constructor.  As an experimental class ClassM. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithMultipleSimpeArguments</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithMultipleSimpeArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassA&gt;().Use&lt;ClassM&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"a"</span></span>).Is(<span class="hljs-number"><span class="hljs-number">6</span></span>) .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"b"</span></span>).Is(<span class="hljs-number"><span class="hljs-number">5</span></span>)); } }</code> </pre> <br>  Now the <strong>.Ctor &lt;int&gt; ("a")</strong> construction <strong>. Is (6) is</strong> supplemented with the name of the argument, so that the framework can match the values ‚Äã‚Äãto the arguments exactly.  The framework always finds the most "greedy" constructor and wants all arguments to be initialized.  You cannot omit the setting of the value for the second argument in the current class implementation.  But you can specify StructureMap, which constructor to use by default, for this you need to use the <strong>DefaultConstructor</strong> attribute. <br><br><h2>  Default constructor </h2><br>  The <strong>DefaultConstructor</strong> attribute allows you to explicitly specify which constructor to use to create an instance of a class.  So that in the previous example it was possible to omit the declaration of the variable b and nothing fell during the work. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassM</span></span> : <span class="hljs-title"><span class="hljs-title">IClassA</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [DefaultConstructor] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { A = a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { A = a + b; } }</code> </pre> <br>  Now you can use the constructor with one parameter. <br><br><h2>  Composite types </h2><br>  Working with composite types is quite easy, because StructureMap itself detects and resolves all dependencies by composite types.  Those.  if you look at the beginning, at the classes, you can see that the class ClassB is initialized by the class ClassA.  Now we will see that nothing special is needed to resolve such dependencies. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithObjectArguments</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;().Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>); x.For&lt;IClassB&gt;().Use&lt;ClassB&gt;(); }); } }</code> </pre> <br>  As you can see from the example, no additional operators are applied.  But you can request the class ClassB, which will be initialized by ClassA. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArgumentsExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithObjectArguments().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classA = (ClassB) container.GetInstance&lt;IClassB&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> classA.ClassA.A.ToString(); }</code> </pre> <br>  The figure 5 will be displayed on the screen. <br><br><h2>  Cast </h2><br>  If you look at the classB declaration of a class, you can see that the variable in the constructor is an interface, not a specific type.  Rewrite the class so that instead of the interface, the constructor accepts the class ClassA <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassB</span></span> : <span class="hljs-title"><span class="hljs-title">IClassB</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassB</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ClassA classA</span></span></span><span class="hljs-function">)</span></span> { ClassA = classA; } }</code> </pre> <br>  Now type binding will not occur because the container registers and returns one data type.  In our case, this is IClassA. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArgumentsForwardingAndWiringExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithObjectArgumentsForwarding().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB = (ClassB) container.GetInstance&lt;IClassB&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> classB.ClassA.A.ToString(); }</code> </pre> <br>  This code will return 0, because the default constructor for the class ClassA will be called, no binding has occurred. <br><br>  As you guessed it is not a problem.  You can specify a StructureMap as to what can be reduced.  This is done with the help of the <strong>Forward</strong> command which needs to specify the source type and the desired one. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithObjectArgumentsForwarding</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArgumentsForwarding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;().Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>); x.Forward&lt;IClassA, ClassA&gt;(); x.For&lt;IClassB&gt;().Use&lt;ClassB&gt;(); }); } }</code> </pre> <br>  Now you can call the WithObjectArgumentsForwardingAndWiringExample method and get 5 in the response. <br><br><h2>  Setting arguments </h2><br>  Most often, it is not possible to know in advance and set the arguments for the class, they become known only at the time of creating the required class.  And since these are working days of writing programs, support for setting arguments at the time of class creation could not appear in StructureMap. <br><br>  The process of invoking a class with new argument values ‚Äã‚Äãis similar to communicating in the Yoda master language, but that is the specifics of DSL.  Technical limitations I mean. <br><br>  So let us want to call the class ClassB with the new class ClassA.  To do this, you need the With operator. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArgumentsOverridingExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithObjectArgumentsForwarding().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB = (ClassB) container .With(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassA(<span class="hljs-number"><span class="hljs-number">8</span></span>)) .GetInstance&lt;IClassB&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> classB.ClassA.A.ToString(); }</code> </pre> <br>  Since the framework, in this case, can uniquely determine which argument to associate with an instance of the class, it is not necessary to specify the name of the argument. <br><br>  If you need to specify a larger number of arguments for the class, then you need to use a larger number of the With method with the indication of the parameter name and its value. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithObjectArgumentsOverridingExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithObjectArgumentsForwarding().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB = (ClassB) container .With(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassA(<span class="hljs-number"><span class="hljs-number">8</span></span>)) .With(<span class="hljs-string"><span class="hljs-string">"s"</span></span>).EqualTo(<span class="hljs-number"><span class="hljs-number">5</span></span>) .GetInstance&lt;IClassB&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> classB.ClassA.A.ToString(); }</code> </pre> <br>  Now, working with designers, I think, is covered sufficiently so that you can solve almost all the architectural approaches that are in your application. <br><br><h1>  Properties </h1><br>  In addition to the required constructor parameters, it is very pleasant to set the class property values ‚Äã‚Äãwhen creating an instance of a class.  Those.  instead of writing <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassA(); classA.A = <span class="hljs-number"><span class="hljs-number">8</span></span>; classA.B = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br>  You can set properties like: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassA { A = <span class="hljs-number"><span class="hljs-number">8</span></span>, B = <span class="hljs-number"><span class="hljs-number">20</span></span> };</code> </pre> <br>  For StuctureMap it is quite capable, all in the same elegant and understandable way. <br><br><h2>  Simple setting of properties </h2><br>  In the simplest case, as in the illustration above, you can set parameters using the <strong>SetProperty</strong> method. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsSetProperty</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsSetProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>) .SetProperty(p =&gt; { pA = <span class="hljs-number"><span class="hljs-number">8</span></span>; pB = <span class="hljs-number"><span class="hljs-number">20</span></span>; })); } }</code> </pre> <br>  As you can see from the example, the properties are strongly typed and you can use intelliSense hints, i.e.  the task of properties proceeds easily and naturally.  It is clear that you can not set all the properties, but only those that you want to initialize at the stage of building an instance of a class. <br><br><h2>  Built-in setting of properties </h2><br>  To use the inline parameter setting, use the <strong>Setter</strong> method.  Using this method, you can set values ‚Äã‚Äãfor one parameter at a time.  Since the argument of the method is a function. <br><br>  The simplest is to explicitly set the parameter for initialization. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsSetterExplicit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsSetterExplicit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>) .Setter(c =&gt; c.Class1).Is(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class1()); }); } }</code> </pre> <br>  The example shows that the Class1 property will always be initialized by the new class Class1.  This entry should be used if the class has more than one property of the same type.  If you have only one property of a given type, then the framework will be able to independently determine which property to assign the value of the passed parameter. <br><br>  So, implicit property initialization. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsSetterImplicit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsSetterImplicit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>) .Setter&lt;Class1&gt;().Is(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class1()); }); } }</code> </pre> <br>  In this example, we did not specify the name of the property, but everything went well, because the property of type Class1 is only one. <br><br><h2>  Setting properties by framework </h2><br>  Since StructureMap can automatically substitute instances of classes into constructor arguments, can it automatically populate the properties of the classes? <br><br>  Of course he can! <br><br>  But of course he will do it not according to his own will and not for all the fields, but only for those that will be indicated as auto-complete. <br><br>  You can modify the previous example, so that property dependencies are resolved by StructureMap and controlled by it. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsSetterImplicitDefault</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsSetterImplicitDefault</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>) .Setter&lt;Class1&gt;().IsTheDefault(); }); } }</code> </pre> <br>  In the example, the new method <strong>IsTheDefault has appeared</strong> , which tells the framework to resolve the dependency with its own means.  Those.  in this case, a property of type Class1 for classA will be created and assigned based on how Class1 is registered. <br><br>  There is also a batch initialization of parameters, when you can say that all properties of a particular type must be initialized with default values.  To do this, use the <strong>SetAllProperties</strong> command. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsSetterBatchImplicitDefault</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsSetterBatchImplicitDefault</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClassA&gt;().Use&lt;ClassA&gt;() .Ctor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Is(<span class="hljs-number"><span class="hljs-number">5</span></span>); x.SetAllProperties(c =&gt; c.OfType&lt;Class1&gt;()); }); } }</code> </pre> <br>  Using this directive, StructureMap automatically initializes all properties of the called classes, for which the property type is Class1. <br><br><h2>  Completion of existing classes </h2><br>  Sometimes it happens that you can only get a ready-made class, without the ability to somehow influence its creation.  At the same time, I want to automate the filling of a heap of class fields in automatic mode.  And this is possible with the help of StructureMap. <br><br>  Let ClassA come to us which is not created in our system.  It is necessary to initialize its property of type Class1.  First we set up StructureMap. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WithArgumentsBuildUp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithArgumentsBuildUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.Forward&lt;IClass1, Class1&gt;(); x.SetAllProperties(c =&gt; c.OfType&lt;Class1&gt;()); }); } }</code> </pre> <br>  Now you can call the <strong>BuildUp</strong> method which will complete the object according to the available configurations. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithArgumentsBuildUp().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassA(<span class="hljs-number"><span class="hljs-number">14</span></span>); container.BuildUp(classA);</code> </pre> <br>  On the second line, the property Class1 = null, after calling BuildUp, the object is completely ready. <br><br><h1>  Lifetime </h1><br>  An important factor is the ability to control the lifetime of the object.  For some classes it is necessary to receive the same copy, for others - each time new ones.  This can also be managed during the process of creating rules in a container. <br><br>  The framework operates seven policies for managing the lifetime of an object: <br><ul><li>  Per reques (default) - a new object is created every time. </li><li>  HttpContextLifecycle </li><li>  Singletonlifecycle </li><li>  ThreadlocalStorageLifecycle </li><li>  UniquePerRequestLifecycle - ensures that the entire chain of objects initializing the requested object will be unique. </li><li>  HttpSessionLifecycle </li><li>  HybridLifecycle is HttpSessionLifecycle or ThreadlocalStorageLifecycle </li><li>  HybridSessionLifecycle - or HttpContextLifecycle, or HttpSessionLifecycle </li></ul><br>  Consider some of them on the example of a simple class <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassX</span></span> : <span class="hljs-title"><span class="hljs-title">IClassX</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClassX</span></span> {}</code> </pre> <br>  First in line will be let <strong>Singleton</strong> . <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LifecycleSingleton</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LifecycleSingleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;().LifecycleIs(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingletonLifecycle()).Use&lt;ClassX&gt;()); Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;().Singleton().Use&lt;ClassX&gt;()); } }</code> </pre> <br>  Abbreviated methods are defined for the basic life policies.  Those.  You can use both <strong>Singleton ()</strong> and <strong>LifecycleIs (new SingletonLifecycle ())</strong> . <br><br>  As a test, you can use a visual example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LifecycleSingleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> singleton = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LifecycleSingleton().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classX = (ClassX) singleton.GetInstance&lt;IClassX&gt;(); classX.Increase(); Console.WriteLine(classX.Counter); classX = (ClassX) singleton.GetInstance&lt;IClassX&gt;(); classX.Increase(); Console.WriteLine(classX.Counter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"done"</span></span>; }</code> </pre> <br>  As a result, the data will be output to the console: ‚Äú1, 2, Done‚Äù.  With a simple ad, we would get: "1, 1, Done." <br><br>  To store an instance of a class within one thread, <strong>ThreadLocalStorageLifecycle is</strong> used, or the abbreviated <strong>HybridHttpOrThreadLocalScoped entry</strong> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LifecycleThreadLocal</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LifecycleThreadLocal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;() .LifecycleIs(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocalStorageLifecycle()) .Use&lt;ClassX&gt;()); Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;() .HybridHttpOrThreadLocalScoped() .Use&lt;ClassX&gt;()); } }</code> </pre> <br>  <strong>HttpContextLifecycle has</strong> an abbreviated <strong>HttpContextScoped</strong> entry <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LifecycleHttpContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LifecycleHttpContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;() .LifecycleIs(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpContextLifecycle()) .Use&lt;ClassX&gt;()); Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClassX&gt;() .HttpContextScoped() .Use&lt;ClassX&gt;()); } }</code> </pre> <br>  Continued in the next part. </div><p>Source: <a href="https://habr.com/ru/post/125695/">https://habr.com/ru/post/125695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125685/index.html">How to create a company with a short history of operating activities</a></li>
<li><a href="../125687/index.html">OpenCL: we waited - version 1.1 from nVidia, but what's new?</a></li>
<li><a href="../125689/index.html">6,000,000,000 photos on Flickr</a></li>
<li><a href="../125690/index.html">Diablo 3 beta test starts</a></li>
<li><a href="../125693/index.html">Google Music Beta gives users two sets of cloud keys for their best friends.</a></li>
<li><a href="../125697/index.html">Several patents. Part 1. Apple</a></li>
<li><a href="../125698/index.html">Introduction to SproutCore Part One</a></li>
<li><a href="../125699/index.html">PyQt: simple threading</a></li>
<li><a href="../125701/index.html">FAS against limiting the length of SMS messages in Cyrillic</a></li>
<li><a href="../125702/index.html">Staff: how not to mess with the management team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>