<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Localization of applications in iOS. Part 1. What do we have?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IOS application localization 
 Part 1. What do we have? 


 Guide for working with localized string resources 
 Introduction 


 A few years ago, I pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Localization of applications in iOS. Part 1. What do we have?</h1><div class="post__text post__text-html js-mediator-article"><h1 id="lokalizaciya-prilozheniy-v-ios">  IOS application localization </h1><br><h2 id="chast-1-chto-my-imeem">  Part 1. What do we have? </h2><br><p>  <strong><em>Guide for working with localized string resources</em></strong> </p><br><h3 id="vvedenie">  Introduction </h3><br><p>  A few years ago, I plunged into the magical world of iOS development, which, with all its essence, promised me a happy future in IT.  However, delving into the particular platform and development environment, I have faced many difficulties and inconveniences in solving seemingly very trivial tasks: Apple's ‚Äúinnovative conservatism‚Äù sometimes makes developers greatly sophisticated in order to satisfy the unbridled customer ‚ÄúI WANT‚Äù. </p><br><p>  One of these problems is the issue of localization of string resources of the application.  I would like to devote some of my first publications to this problem in the open spaces of Habr. </p><a name="habracut"></a><br><p>  Initially, I expected to fit my thoughts in one article, but the amount of information that I would like to explain was quite large.  In this article, I will try to uncover the essence of the standard mechanisms for working with localized resources with an emphasis on some aspects that most guides and tutorials neglect.  The material is focused primarily on novice developers (or those who have not encountered such problems).  For experienced developers, this information may not be of particular value.  But I will tell you about the inconveniences and shortcomings that can be encountered in practice in the future ... </p><br><h3 id="iz-pod-korobki-kak-organizovano-hranenie-strokovyh-resursov-v-ios-prilozheniyah">  From under the box.  How storage of string resources in iOS applications is organized </h3><br><p>  To begin with, we note that the presence of localization mechanisms in the platform is already a huge plus, since  It saves the programmer from additional development and sets a uniform format for working with data.  And often, basic mechanisms are sufficient for the implementation of relatively small projects. </p><br><p>  And so, what possibilities does Xcode provide us from under the box?  To begin, let's understand the standard storage of string resources in a project. </p><br><p> In projects with static content, string data can be stored directly in the interface (markup files <em><code>.storyboard</code></em> and <em><code>.xib</code></em> , which in turn are XML files rendered by <em>Interface Builder</em> ) or in code.  The first approach allows us to simplify and accelerate the process of marking screens and individual displays, because  a developer can observe most changes without building an application.  However, in this case it is not difficult to run into data redundancy (if the same text is used by several elements, mappings).  The second approach eliminates the problem of data redundancy, but leads to the need to fill the screens manually (by setting additional <em><code>IBOutlet</code></em> and assigning corresponding text values ‚Äã‚Äãto them), which in turn leads to code redundancy (of course, except when the text should installed directly by the application code). </p><br><p>  In addition, Apple provides a standard file with the extension <em><code>.strings</code></em> .  This standard regulates the storage format of string data as an associative array ( <code>"-"</code> ): </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"key"</span></span> = <span class="hljs-string"><span class="hljs-string">"value"</span></span>;</code> </pre> <br><p>  The key is case-sensitive, allows for spaces, underscores, punctuation, and special characters. </p><br><p>  It is important to note that, despite its simple syntax, <em>Strings</em> files are regular sources of errors during the compilation, assembly, or operation of the application.  There are several reasons for this. </p><br><p>  First, syntax errors.  Missed semicolons, equal signs, extra or unshielded quotes will inevitably lead to a compiler error.  And Xcode will point to the file with an error, but will not highlight the line in which something is wrong.  Finding such a typo can take a significant amount of time, especially if the file contains a significant amount of data. </p><br><p>  Secondly, duplication of keys.  The application because of it, of course, will not fall, but incorrect data may be displayed to the user.  The thing is that when a string is accessed by a key, the value corresponding to the last occurrence of the key in the file is pulled. </p><br><p>  As a result, a simple structure requires a programmer to be very thorough and careful when filling files with data. </p><br><p><del>  Knowledgeable </del>  developers can immediately exclaim: <em>"But what about JSON and PLIST? Than they did not please?"</em>  Well, firstly, <em><code>JSON</code></em> and <em><code>PLIST</code></em> (in fact, ordinary <em><code>XML</code></em> ) are universal standards that allow storing both strings and numerical, logical ( <em><code>BOOL</code></em> ), binary data, time and date, as well as collections ‚Äî indexed ( <em><code>Array</code></em> ) and associative ( <em><code>Dictionary</code></em> ) arrays.  Accordingly, the syntax of these standards is richer, and therefore easier to put in them.  Secondly, the processing speed of such files is slightly lower than the Strings files, again due to the more complex syntax.  This is not to mention the fact that to work with them you need to carry out a number of manipulations in the code. </p><br><h3 id="lokalizovali-lokalizovali-da-ne-vylokalizovali-lokalizaciya-polzovatelskogo-interfeysa">  Localized, localized, but not dislocated.  User Interface Localization </h3><br><p>  And so, with the standards figured out, let's figure out now how to use it all. </p><br><p>  Let's go in order.  To begin with, we will create a simple <em>Single View Application</em> and in the <em>Main.storyboard</em> on the <em>ViewController</em> we <em>will</em> add several text components. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/310/a0b/c0d/310a0bc0df4192cd2ab87ad46407666a.png" width="50%" height="50%"><br><br><p>  Content in this case is stored directly in the interface.  To localize it you must do the following: </p><br><p>  1) Go to project settings </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/0bb/f6e/b9e0bbf6eb66b5d8acb88ee3b29fd45c.png" width="50%" height="50%"><br><br><p>  2) Then - from <strong><em>Target</em></strong> to <strong><em>Project</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/bf0/334/bb5bf033410cedeb98e3e46399637d7b.png" width="50%" height="50%">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  3) Open the <strong><em>Info</em></strong> tab </p><br><img src="https://habrastorage.org/getpro/habr/post_images/324/5bd/cdd/3245bdcdd605153e52668fd795f65720.png" width="50%" height="50%"><br><br><p>  In the <strong><em>Localizations section</em></strong> , we immediately see that we already have the entry <em>"English - Development language"</em> .  This means that English is set as a development language (or by default). </p><br><p>  Let's add another language now.  To do this, click " <strong>+</strong> " and select the desired language (for example, I chose Russian).  Caring Xcode immediately invites us to choose which files need to be localized for the added language. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/781/801/3ae/7818013aee9b0574048779957404bb31.png" width="50%" height="50%"><br><br><p>  Click <strong>Finish</strong> , see what happened.  In the project navigator, next to the selected files, there are buttons for displaying nestings.  Clicking on them we see that the previously selected files contain created localization files. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/882/089/5b0882089822427b954eb7ce5e497048.png" width="35%" height="35%"><br><br><p>  For example, <strong><em><code>Main.storyboard (Base)</code></em></strong> is the interface markup file created by default in the basic development language, and when localizing it, the associated <strong><em><code>Main.strings (Russian)</code></em></strong> file was created for the Russian localization.  Opening it you can see the following: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>;</code> </pre> <br><p>  Here, in general, everything is simple, but for clarity, let us consider in more detail, drawing attention to the comments generated by the caring Xcode: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>;</code> </pre> <br><p>  Here is an instance of the <strong><em><code>UILabel</code></em></strong> class with the value <strong><em><code>"Label"</code></em></strong> for the <strong><em><code>text</code></em></strong> parameter.  <strong><em><code>ObjectID</code></em></strong> - the object identifier in the markup file is a unique string assigned to any component at the time of its placement on the <em><code>Storyboard/Xib</code></em> .  It is from <em><code>ObjectID</code></em> and the name of the object's parameter (in this case, <em><code>text</code></em> ) that the key is generated, and the record itself can be formally interpreted as: </p><br><p>  Set the "text" parameter of the "tQe-tG-eeo" object to the value "Label". </p><br><p>  In this record, only the " <em>value</em> " is subject to change.  Replace " <em>Label</em> " with " <em>Inscription</em> ".  We will do the same with other objects. </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p>  Run our application. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9e7/85a/332/9e785a3328aff1923329541d31447672.png" width="50%" height="50%"><br><br><p>  But what do we see?  The application uses basic localization.  How to check if we made the translation correctly? </p><br><p>  Here it is worth making a small digression and dig a little towards the features of the iOS platform and the structure of the application. </p><br><p>  To begin, consider the change in the structure of the project in the process of adding localization.  This is how the project directory looks like before adding Russian localization: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/0b2/f07/bb30b2f0799f2c7ce2433aa7ec2350fc.png" width="50%" height="50%"><br><br><p>  And so after: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/a10/b14/ae7a10b14491da04c89ce8e456cf5ac1.png" width="50%" height="50%"><br><br><p>  As we can see, Xcode created a new directory <em><code>ru.lproj</code></em> , in which it placed the created localized strings. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ceb/ca2/ff5/cebca2ff5edaae9d6a1398f9e41e7652.png" width="50%" height="50%"><br><br><p>  And here is the structure of the Xcode project to the finished iOS application?  And despite the fact that it helps to better understand the features of the platform, as well as the principles of the distribution and storage of resources directly in the finished application.  The bottom line is that when building the Xcode project, in addition to generating the executable file, the environment transfers resources ( <em>Storyboard / Xib</em> interface markup files, images, line files, etc.) into the finished application while maintaining the hierarchy specified at the design stage. </p><br><p>  Apple provides the <em><code>Bundle(NSBundle)</code></em> class ( <a href="https://developer.apple.com/documentation/foundation/bundle%3Fchanges%3D_2">free translation</a> ) for working with this hierarchy: </p><br><blockquote>  Apple uses the <strong><code>Bundle</code></strong> to provide access to applications, frameworks, plugins, and many other types of content.  Bundles organize resources into well-defined subdirectories, and bundle structures vary by platform and type.  Using <em><code>bundle</code></em> , you can access the package resources without knowing its structure.  <em><code>Bundle</code></em> is a single interface for searching for items, taking into account the package structure, user needs, available localizations and other relevant factors. <br>  <strong>Search and open a resource</strong> <br>  Before you start working with a resource, you must specify its <em><code>bundle</code></em> .  The <strong><code>Bundle</code></strong> class has many constructors, but the most commonly used is <strong><a href="https://developer.apple.com/documentation/foundation/bundle/1410786-main%3Fchanges%3D_2">main</a></strong> .  <em><code>Bundle.main</code></em> provides the path to directories containing the current executable code.  Thus, <em><code>Bundle.main</code></em> provides access to resources used by the current application. </blockquote><p>  Consider the <em><code>Bundle.main</code></em> structure using the <strong><em><code>FileManager</code></em></strong> class: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/e0f/8b3/60fe0f8b3bb62a0db757f06f999e8065.png" width="65%" height="65%"><br><br><p>  Based on the foregoing, we can conclude that when the application is loaded, its <em><code>Bundle.main</code></em> is formed, the current device localization (system language), application localization and localized resources are analyzed.  Then the application selects from all available localizations the one that matches the current language of the system and pulls the corresponding localized resources.  If there is no match, resources from the default directory are used (in our case, the English localization, since English was defined as the development language, and the need for additional localization of resources can be neglected).  If you change the device language to Russian and restart the application, then the interface will already correspond to the Russian localization. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/47e/e24/6fe/47ee246fec532a890503019af1bfc91c.png" width="50%" height="50%"><br><br><p>  But before you close the theme of localization of the user interface through <em>Interface Builder</em> , it is worth noting another remarkable way.  When creating localization files (by adding a new language to the project or in the localized file inspector), it is easy to see that Xcode allows you to select the type of file to be created: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/272/aa5/cb3/272aa5cb38ea6b2a4178edc911296982.png" width="35%" height="35%"><br><br><p>  Instead of a string file, you can easily create a localized <em><code>Storyboard/Xib</code></em> , which will preserve all the markup of the base file.  The great advantage of this approach is that the developer can immediately see how the content will be displayed in one language or another and immediately correct the screen layout, especially if the text volume varies, or another text direction is used (for example, in Arabic, Hebrew), etc. .  But at the same time, the creation of additional <em>Storyboard / Xib</em> files significantly increases the size of the application itself (all the same, string files take up much less space). </p><br><p>  Therefore, choosing one or another interface localization method should take into account which approach will be more expedient and practical in a specific situation. </p><br><h3 id="do-it-yourself-rabota-s-lokalizovannymi-strokovymi-resursami-v-kode">  Do It Yourself.  Working with localized string resources in code </h3><br><p>  I hope everything is more or less clear with static content.  But what about the text that is specified directly in the code? </p><br><p>  The developers of the iOS operating system have taken care of this. </p><br><p>  For working with localized text resources, the Foundation framework provides the <strong><em><code>NSLocalizedStrings</code></em></strong> family of methods in <strong><em>Swift</em></strong> </p><br><pre> <code class="hljs sql">NSLocalizedString(_ key: String, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) NSLocalizedString(_ <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, tableName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>?, bundle: Bundle, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>)</code> </pre> <br><p>  and macros in <strong><em>objective-c</em></strong> </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedString</span></span>(key, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTable</span></span>(key, tbl, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTableInBundle</span></span>(key, tbl, bundle, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringWithDefaultValue</span></span>(key, tbl, bundle, val, comment)</code> </pre> <br><p>  Let's start with the obvious.  The <strong><em><code>key</code></em></strong> parameter is the string key in the Strings file;  <strong><em><code>val</code></em></strong> (default value) - default value, which is used in case of absence of the specified key in the file;  <strong><em><code>comment</code></em></strong> - (less obvious) a brief description of the localized string (in fact, does not carry useful functionality and is intended to clarify the purpose of using a particular string). </p><br><p>  As for the parameters <em><code>tableName</code></em> ( <em><code>tbl</code></em> ) and <em><code>bunble</code></em> , then they should be considered in more detail. </p><br><p>  <strong><em><code>tableName</code></em></strong> ( <strong><em><code>tbl</code></em></strong> ) is the name of the String file (to be honest, I don‚Äôt know why Apple calls it a table), which contains the string we need by the specified key;  during its transfer the <em><code>.string</code></em> extension <em><code>.string</code></em> not specified.  The ability to navigate between tables allows you not to store string resources in a single file, but to distribute them at your own discretion.  This allows you to get rid of file congestion, simplifies editing, minimizes the chance of errors. </p><br><p>  The <strong><em><code>bundle</code></em></strong> option extends the ability to navigate resources even more.  As mentioned earlier, a <em>bundle</em> is a mechanism for accessing application resources, that is, we can independently determine the source of resources. </p><br><p>  A little more.  Let us go directly to the <strong><em>Foundation</em></strong> and consider the declaration of methods (macros) for a clearer picture, since  the majority of tutorials simply ignore this point.  The <em>Swift</em> framework is not very informative: </p><br><pre> <code class="hljs vhdl">/// Returns a localized <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, using the main bundle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> one <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified. public func NSLocalizedString(_ key: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, tableName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>? = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, bundle: Bundle = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, value: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, comment: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br><p>  <em>"The main bundle returns a localized string"</em> - all we have.  <em>Objective-C</em> is a little different. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:nil] #define NSLocalizedStringFromTable(key, tbl, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \ [bundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \ [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span></span></code> </pre> <br><p>  Here you can clearly see that the string resources work with none other than the <strong><em><code>bundle</code></em></strong> (in the first two cases the <em><code>mainBundle</code></em> ) - just like in the case of interface localization.  Of course, I could immediately say about it, considering the class <em><code>Bundle</code></em> ( <em><code>NSBundle</code></em> ) in the previous paragraph, but at that time this information did not carry much practical value.  But in the context of working with lines in the code, this can not be said.  In fact, the global functions provided by the <strong><em>Foundation</em></strong> are just wrappers over standard bundle methods, the main task of which is to make the code more concise and safe.  Nobody forbids initializing the <em><code>bundle</code></em> manually and directly accessing resources on its behalf, but in this way there appears (albeit very, very small) the probability of generating circular references and memory leaks. </p><br><p>  Further examples will describe the work with global functions and macros. </p><br><p>  Consider how it all works. <br>  First, create a String file that will contain our string resources.  Call it Localizable.strings * and add it to it. </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"testKey"</span></span> = <span class="hljs-string"><span class="hljs-string">"testValue"</span></span>;</code> </pre> <br><p>  ( <em>Localization of String files is done exactly the same way as</em> Storyboard / Xib <em>, so I will not describe this process.</em> Replace <em>the Russian</em> test <em>file "</em> testValue <em>" with "</em> test value *".) </p><br><p>  <strong>Important!</strong>  In iOS, a file with this name is the default string resource file, i.e.  if you do not specify the table name <em><code>tableName</code></em> ( <em><code>tbl</code></em> ), the application will automatically knock on <strong><em><code>Localizable.strings</code></em></strong> . </p><br><p>  Add the following code to our project </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"testKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedString(@"testKey", @""));</span></span></code> </pre> <br><p>  and run the project.  After executing the code, the line will appear in the console </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>: testValue</code> </pre> <br><p>  Everything works right! </p><br><p>  Similarly, with an example of localization of the interface, change the localization and run the application.  The result of the code will be </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>:  </code> </pre> <br><p>  Now let's try to get the value by the key, which is not in the <em><code>Localizable.strings</code></em> file: </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'unknownKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'unknownKey': %@", NSLocalizedString(@"unknownKey", @""));</span></span></code> </pre> <br><p>  The result of this code will be </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'unknownKey'</span></span>: unknownKey</code> </pre> <br><p>  Since there is no key in the file, the method returns the key itself as a result.  If this result is unacceptable, it is better to use the method </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, tableName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: Bundle.main, value: <span class="hljs-string"><span class="hljs-string">"noValue"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedStringWithDefaultValue(@"unknownKey", nil, NSBundle.mainBundle, @"noValue", @""));</span></span></code> </pre> <br><p>  where is the <strong><em><code>value</code></em></strong> parameter ( <em>default value</em> ).  But in this case, be sure to specify the source of resources - <em><code>bundle</code></em> . </p><br><p>  Localized strings support the interpolation mechanism, similar to standard iOS strings.  To do this, you need to add an entry to the string file using string literals ( <em><code>%@</code></em> , <em><code>%li</code></em> , <em><code>%f</code></em> , etc.), for example: </p><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span> = <span class="hljs-string"><span class="hljs-string">"String with %@: %li, %f"</span></span>;</code> </pre> <br><p>  To display such a line, you need to add a code like </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", 123, 123.098]);</span></span></code> </pre> <br><p>  But when using such constructions you need to be very careful!  The fact is that iOS strictly keeps track of the number, the order of the arguments, the correspondence of their types to the specified literals.  So, for example, if you substitute the string as the second argument instead of the integer value </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", @"123", 123.098]);</span></span></code> </pre> <br><p>  then the application substitutes the integer code of the string <strong><em>"123"</em></strong> in the place of inconsistency </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">4307341664</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  If you skip it, you get </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  But if you omit the object corresponding to <strong><em><code>%@</code></em></strong> in the list of arguments </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"123", 123.098]);</span></span></code> </pre> <br><p>  then the application simply falls when the code is executed. </p><br><h3 id="push-me-baby-lokalizaciya-uvedomleniy">  Push me baby!  Localization of notifications </h3><br><p>  Another important task in the issue of working with localized string resources, which I would like to briefly describe, is the task of localizing notifications.  The bottom line is that most tutorials (both on <em><code>Push Notifications</code></em> and on <em><code>Localizable Strings</code></em> ) often neglect this problem, and such tasks are not so rare.  Therefore, when faced with a similar for the first time, the developer may have a reasonable question: is <em>it possible in principle?</em>  I will not consider the mechanism of the <em><code>Apple Push Notification Service</code></em> operation here, especially since starting with iOS 10.0, Push and local notifications are implemented through the same framework, <strong><code>UserNotifications</code></strong> . </p><br><p>  We have to deal with a similar task when developing multi-language client-server applications.  When such a problem first arose before me, the first thing that came to my mind was to throw off the problem of localizing messages to the server side.  The idea was very simple: when the application starts, it sends the current localization to the <em>backend</em> , and the server, when sending a <em>push,</em> selects the appropriate message.  But there was a problem right away: if the device localization changed, and the application was not restarted (did not update the data in the database), the server sent the text corresponding to the last "registered" localization.  And if the application is installed on several devices with different system languages, then the whole implementation would work like the devil knows what.  Since such a solution immediately seemed to me the wildest crutch, I immediately began to look for adequate solutions (funny, but in many forums the "developers" advised to localize the fuses on the <em>backend-</em> e). </p><br><p>  The correct decision turned out to be terribly simple, although not entirely obvious.  Instead of standard <em>JSON</em> sent by the server to <em>APNS</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"body"</span></span> : <span class="hljs-string"><span class="hljs-string">"some message"</span></span>; }; };</code> </pre> <br><p>  it is necessary to send <em>JSON of a</em> type </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; }; };</code> </pre> <br><p>  where the <strong><em><code>loc-key</code></em></strong> is passed to the <strong><em><code>loc-key</code></em></strong> key from the <strong><em><code>Localizable.strings</code></em></strong> file.  Accordingly, the push message is displayed in accordance with the current localization of the device. </p><br><p>  The interpolation mechanism for localized strings in <em>Push</em> notifications works in the same way: </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; <span class="hljs-string"><span class="hljs-string">"loc-args"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"First argument"</span></span>, <span class="hljs-string"><span class="hljs-string">"Second argument"</span></span> ]; }; };</code> </pre> <br><p>  The key <strong><em><code>loc-args</code></em></strong> is an array of arguments that must be embedded in the localized notification text. </p><br><h3 id="podytozhim">  Let's sum up ... </h3><br><p>  And so, what we have in the end: </p><br><ul><li>  the standard for storing string data in specialized <strong><em><code>.string</code></em></strong> files with a simple and accessible syntax; </li><li>  the ability to localize the interface without additional code manipulations; </li><li>  quick access to localized resources from code; </li><li>  automatic generation of localization files and structuring the resources of the project (application) directory using Xcode; </li><li>  the ability to localize text notifications. </li></ul><br><p>  , Xcode           ,          . </p><br><p>               . </p></div><p>Source: <a href="https://habr.com/ru/post/419077/">https://habr.com/ru/post/419077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419063/index.html">Automation of obtaining information from Incorporation using Freepascal</a></li>
<li><a href="../419065/index.html">Intel Virtual World. Practice</a></li>
<li><a href="../419069/index.html">Global warming will make our world more green, but you shouldn't rejoice</a></li>
<li><a href="../419071/index.html">In the wake of tp-link hacking</a></li>
<li><a href="../419075/index.html">On the formation of sequences in the Collatz hypothesis (3n + 1)</a></li>
<li><a href="../419083/index.html">Cursor API as an alternative to standard paging</a></li>
<li><a href="../419085/index.html">The idea of ‚Äã‚Äãa singularity before the Big Bang is outdated</a></li>
<li><a href="../419087/index.html">Understanding someone else's consciousness is a myth</a></li>
<li><a href="../419089/index.html">How to cheat when playing dice - tips game expert</a></li>
<li><a href="../419091/index.html">Radioactive items among us</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>