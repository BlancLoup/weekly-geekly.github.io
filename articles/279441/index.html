<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MSLibrary. Implementing multiple selection of conditions using bitmasks, for iOS and not only ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to publish materials from the developers of the library MSLibrary for iOS. The topic of this article is not accidental; the problem of cho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MSLibrary. Implementing multiple selection of conditions using bitmasks, for iOS and not only ...</h1><div class="post__text post__text-html js-mediator-article">  We continue to publish materials from the developers of the library <a href="https://habrahabr.ru/users/mslibrary/" class="user_link">MSLibrary</a> for iOS.  The topic of this article is not accidental; the problem of choosing several conditions from a given set is not uncommon in our work.  The simplest example is choosing a partner for a game (dating, traveling, etc.).  The choice should be made from several groups formed according to the level of preparedness (there may be age groups and anything else).  The condition is to allow the user to select a partner from one or several groups at the same time.  Another example is the <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSRegularExpression_Class/">NSRegularExpressionOptions</a> data type checking constants for the <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSRegularExpression_Class/">NSRegularExpression</a> class.  When substituting these constants in the class methods, we can write: <br><br><pre>  NSRegularExpressionCaseInsensitive |  NSRegularExpressionDotMatchesLineSeparators </pre><br>  By combining constants with the logical ‚ÄúOR‚Äù sign, we will be sure that we will check the string being analyzed for compliance with both of the specified conditions. <br><br>  One way to accomplish such a task is to use a list of constants in the form of an enum enumeration, in which the elements of the enumeration are binary numbers with one bit set.  This is not very difficult to do, but first a bit of theory.  Recall such bit operations as ‚ÄúSHIFT‚Äù, ‚ÄúAND‚Äù, ‚ÄúOR‚Äù. <br><a name="habracut"></a><br>  <b>Bitwise logical operations with binary numbers</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">LOGICAL BIT "SHIFT)</a> <br><blockquote>  In the case of a logical shift, the value of the last bit in the direction of the shift is lost (copied to the carry bit), and the first one becomes zero. </blockquote><br>  The picture shows a logical left shift by one digit. <br><br><img src="https://habrastorage.org/files/823/402/187/82340218750b410d80c0535c95fb64ee.png"><br><br>  For completeness, we can say that when shifting left by one digit, the original number 01010101 turns into 10101010. In the hexadecimal system (Hex) we are used to, the number 0x55 turns into 0xAA or decimally 85 turns into 170, that is, multiplied by 2, which is quite is logical. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">FAST "OR (OR)"</a> <br><blockquote>  This is a binary operation, the operation of which is equivalent to applying a logical OR to each pair of bits that are at the same positions in the binary representations of the operands.  In other words, if both the corresponding bits of the operands are 0, the binary bit of the result is 0;  if at least one bit of the pair is 1, the binary bit of the result is 1. </blockquote><br>  Visually, it looks like this: <br><br><img src="https://habrastorage.org/files/09e/756/ee9/09e756ee92c34ec2bedd6f821ee5c836.png"><br><br>  Applying the bitwise OR operation to the original numbers 01100110 and 10101010 yields the result 11101110. In the hexadecimal system (Hex), the initial numbers 0x66 and 0xAA, the result 0xEE or in the decimal system, the original numbers 102 and 170, the result 238. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">KILLING "AND (AND)"</a> <br><blockquote>  This is a binary operation, the action of which is equivalent to applying a logical ‚ÄúAND‚Äù to each pair of bits that are at the same positions in the binary representations of the operands.  In other words, if both corresponding bits of the operands are 1, the resulting binary bit is 1;  if at least one bit of the pair is 0, the resulting binary bit is 0. </blockquote><br><img src="https://habrastorage.org/files/0ea/41c/66f/0ea41c66fdd24954a5c4ce96d4672d20.png"><br><br>  Applying the bitwise AND operation to the original numbers 01100110 and 10101010 gives the result 00100010. In the hexadecimal system (Hex), the initial numbers are 0x66 and 0xAA, the result is 0x22 or in the decimal system, the original numbers are 102 and 170, the result is 34. <br><br>  <b>Binary numbers with one bit set</b> <br><br>  Now let's see what happens when these operations are applied to binary numbers with one bit set. <br><br>  PORRIFIED (AFTER) SHIFT <br><br>  The bitwise shift applied to the number 00000001 will give the following result: <br><br><img src="https://habrastorage.org/files/d28/092/39c/d2809239cd1c45e5a3df3d5bd40e066f.png"><br><br>  The operations of bit shifts are indicated, depending on the direction of the shift, by the signs "&lt;&lt;" and "&gt;&gt;": <br><br><pre>  binaryNumber &lt;&lt; n // bit left shift to "n" positions (digits)
	 binaryNumber &gt;&gt; n // bit shift to the right by "n" positions (digits) </pre><br>  The number 00000001 is decimal 1. Therefore, numbers with one bit set and a bit left shift are usually denoted as follows: <br><br><pre>  1 &lt;&lt; n // where "n" is the number of positions (digits) to shift
	 1 &lt;&lt; 0 // 00000001 shift to 0 bits
	 1 &lt;&lt; 1 // 00000001 shift by 1 bits
	 1 &lt;&lt; 3 // 00000001 shift by 3 bits
	 1 &lt;&lt; 5 // 00000001 shift by 5 digits </pre><br><br>  PICTURAL LOGIC "OR (OR)" <br><br>  Let's take several numbers with one set bit and apply the bitwise logical OR operation to them.  This is written like this: <br><br><pre>  1 &lt;&lt; 0 |  1 &lt;&lt; 3 |  1 &lt;&lt; 5 </pre><br>  and it looks like this: <br><br><img src="https://habrastorage.org/files/696/cf6/93e/696cf693eb2d4c638df2f50b79530859.png"><br><br>  A wonderful property of such an operation is the result: a unique value in this range of numbers. <br><br><blockquote><h4>  <i>The result obtained from applying the bitwise logical "OR" operation to different numbers with one set bit from a given set of numbers is always unique</i> </h4></blockquote><br><br>  FASTING LOGICAL "AND (AND)‚Äù <br><br>  The second property of numbers with one set bit - applying the bitwise logical ‚ÄúAND (AND)‚Äù operation to any of the numbers included in the ‚ÄúOR (OR)‚Äù operation and the result obtained, we get the original number: <br><br><pre>  1 &lt;&lt; 0 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) = 1 &lt;&lt; 0
	 1 &lt;&lt; 3 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) = 1 &lt;&lt; 3 
	 1 &lt;&lt; 5 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) = 1 &lt;&lt; 5 </pre><br><br>  While other numbers with one bit set do not satisfy this condition: <br><br><pre>  1 &lt;&lt; 1 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) ‚â† 1 &lt;&lt; 1
	 1 &lt;&lt; 2 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) ‚â† 1 &lt;&lt; 2 
	 1 &lt;&lt; 4 &amp; (1 &lt;&lt; 0 | 1 &lt;&lt; 3 | 1 &lt;&lt; 5) ‚â† 1 &lt;&lt; 4 </pre><br>  For clarity: <br><br><img src="https://habrastorage.org/files/e05/ce4/a04/e05ce4a04d304c2ea4d5f239611df784.png"><br><br>  This property of the number obtained as a result of applying the bitwise logical "OR (OR)" operation allows using it as a "BIT MASK". <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0">BIT MASK</a> <br><blockquote>  This is the specific data that is used for masking ‚Äî the selection of individual bits or fields from several bits from a binary string or number. </blockquote><br>  In other words, the result obtained from applying a bitwise logical "OR" operation to different numbers with one set bit from a given set of numbers can be used as a bitmask. <br><br><blockquote><h4>  <i>By applying the bitwise logical "OR (OR)" operation to several numbers with one bit set, you can use the result as a bit mask to filter the original numbers from many others.</i> </h4></blockquote><br>  Let's go to practice. <br><br>  <b>Enum enumerations with binary numbers with one bit set</b> <br><br>  To define a set of constants, with a specified number of specific values, it is convenient to use an enumerated type or enum enum.  We write the enumeration for the speculative example given at the beginning of the article.  Suppose we need to define five user groups.  This is written like this: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Groups</span></span></span><span class="hljs-class"> </span></span>{ group_0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, group_1 = <span class="hljs-number"><span class="hljs-number">1</span></span> group_2 = <span class="hljs-number"><span class="hljs-number">2</span></span>, group_3 = <span class="hljs-number"><span class="hljs-number">3</span></span>, group_4 = <span class="hljs-number"><span class="hljs-number">4</span></span>, };</code> </pre> <br>  We can use ‚ÄúGroups‚Äù to select the appropriate group of users, but we cannot combine these groups, that is, we cannot select users from the groups ‚Äúgroup_2‚Äù and ‚Äúgroup_3‚Äù and organize filtering of all users by these parameters.  We can calculate the control number by performing the operation (2 + 3) = 5, but it will not be unique, the groups ‚Äúgroup_1‚Äù and ‚Äúgroup_4‚Äù will give the same result: (1 + 4) = 5. Modify the expression, specifying the numbers as with one bit set and using a bitwise left shift. <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml"> enum Groups { group_0 = 1 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">group_1</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">group_2</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">group_3</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">group_4</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag"> };</span></span></span></span></code> </pre> <br>  In this case, we can easily create a ‚ÄúBIT MASK‚Äù by applying bitwise OR operations to the selected parameters.  Suppose we chose the same "group_2" and "group_3": <br><br><pre>  (1 &lt;&lt; 2 | 1 &lt;&lt; 3) = 0x55
	 1 &lt;&lt; 2 &amp; (1 &lt;&lt; 2 | 1 &lt;&lt; 3) = 1 &lt;&lt; 2
	 1 &lt;&lt; 3 &amp; (1 &lt;&lt; 2 | 1 &lt;&lt; 3) = 1 &lt;&lt; 3
	 1 &lt;&lt; 1 &amp; (1 &lt;&lt; 2 | 1 &lt;&lt; 3) ‚â† 1 &lt;&lt; 1
	 1 &lt;&lt; 4 &amp; (1 &lt;&lt; 2 | 1 &lt;&lt; 3) ‚â† 1 &lt;&lt; 4 </pre><br>  or by substituting constants: <br><br><pre>  (group_2 | group_3) = 0x55
	 group_2 &amp; (group_2 | group_3) = group_2
	 group_3 &amp; (group_2 | group_3) = group_3
	 group_1 &amp; (group_2 | group_3) ‚â† group_1
	 group_4 &amp; (group_2 | group_3) ‚â† group_4 </pre><br><br>  Many bit constants are similarly arranged, in particular the NSRegularExpressionOptions mentioned at the beginning of the article: <br><br><pre> <code class="hljs pgsql"> typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) { NSRegularExpressionCaseInsensitive = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, // Match letters <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the pattern independent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NSRegularExpressionAllowCommentsAndWhitespace = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, // Ignore whitespace <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> #-prefixed comments <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the pattern NSRegularExpressionIgnoreMetacharacters = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, // Treat the entire pattern <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a literal string NSRegularExpressionDotMatchesLineSeparators = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, // Allow . <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-type"><span class="hljs-type">character</span></span>, including <span class="hljs-type"><span class="hljs-type">line</span></span> separators NSRegularExpressionAnchorsMatchLines = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>, // Allow ^ <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> match the <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> lines NSRegularExpressionUseUnixLineSeparators = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>, // Treat <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> \n <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> separator (otherwise, <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> standard <span class="hljs-type"><span class="hljs-type">line</span></span> separators are used) NSRegularExpressionUseUnicodeWordBoundaries = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span> // Use Unicode TR#<span class="hljs-number"><span class="hljs-number">29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> specify word boundaries (otherwise, traditional regular expression word boundaries are used) };</code> </pre> <br>  or NSTextCheckingResult: <br><br><pre> <code class="hljs ruby"> typedef NS_OPTIONS(uint64_t, NSTextCheckingType) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> a single type NSTextCheckingTypeOrthography = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> language identification NSTextCheckingTypeSpelling = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> spell checking NSTextCheckingTypeGrammar = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> grammar checking NSTextCheckingTypeDate = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> date/time detection NSTextCheckingTypeAddress = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> address detection NSTextCheckingTypeLink = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> link detection NSTextCheckingTypeQuote = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> smart quotes NSTextCheckingTypeDash = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> smart dashes NSTextCheckingTypeReplacement = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fixed replacements, such as copyright symbol <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c) NSTextCheckingTypeCorrection = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> autocorrection NSTextCheckingTypeRegularExpression = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> regular expression matches NSTextCheckingTypePhoneNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> phone number detection NSTextCheckingTypeTransitInformation = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">12</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ transit (eg flight) info detection };</span></span></code> </pre> <br>  Let's return to our example with user groups.  We created a bitmask, now we need to write code to use it.  If there are two approaches to solving this problem, the first one is using the if () {} operators and the second one, in which a bunch of for () {} and switch () {} operators are used, consider both. <br><br>  <b>Using the if () {} operator</b> <br><br>  This approach is fairly straightforward.  The following code does not need special comments: <br><br><pre> <code class="hljs pgsql"> NSInteger group_masck = (group_2 | group_3) = <span class="hljs-number"><span class="hljs-number">0x55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((group_masck &amp; group_0) == group_0) { // ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((group_masck &amp; group_1) == group_1) { // ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((group_masck &amp; group_2) == group_2) { // ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((group_masck &amp; group_3) == group_3) { // ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((group_masck &amp; group_4) == group_4) { // ,        }</code> </pre><br>  Substituting the values ‚Äã‚Äãof the constants in this code, we will see how it works: <br><br><pre> <code class="hljs ruby"> NSInteger group_masck = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| 1 &lt;&lt; 3) = 0x55 </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (((1 &lt;&lt; 2 |</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| 1 &lt;&lt; 3) &amp; 1 &lt;&lt; 1) == 1 &lt;&lt; 1) { // ,        } </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (((1 &lt;&lt; 2 |</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| 1 &lt;&lt; 3) &amp; 1 &lt;&lt; 3) == 1 &lt;&lt; 3) { // ,        } </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (((1 &lt;&lt; 2 |</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        }</code> </pre><br><br>  Thus, certain actions are performed in all cases of matching constants and masks, in our example, for users from the groups "group_2" and "group_3". <br><br>  <b>Using for () {} and switch () {} operators</b> <br><br>  The second approach is to use a bunch of operators "for () {}" and "switch () {}".  The advantage of this option is that if for different ‚ÄúGroups‚Äù constants it is necessary to perform identical actions, for example, to use the same functions that differ only in certain variables, then this approach allows you to create a more compact and elegant code: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> group_masck = (group_2 | group_3) = <span class="hljs-number"><span class="hljs-number">0x55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> variable; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: { variable = value_0; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: { variable = value_1; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: { variable = value_2; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { variable = value_3; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: { variable = value_4; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { <span class="hljs-comment"><span class="hljs-comment">//,     } break; } if ((group_masck &amp; 1ULL &lt;&lt; i) == 1ULL &lt;&lt; i) { //       "variable" } }</span></span></code> </pre><br><br>  Many of the methods and functions of our <a href="https://habrahabr.ru/users/mslibrary/" class="user_link">MSLibrary</a> for iOS library are organized in the same way.  For example, the function: msfDDstringCheckingStyle () takes the values ‚Äã‚Äã‚ÄúYES‚Äù or ‚ÄúNO‚Äù depending on whether the specified conditions are met in the analyzed string. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> msfDDstringCheckingStyle(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *string, tMSstringCheckingStyle stringCheckingStyle, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> allConditionsIsRequired, <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> minLengthOfString)</code> </pre> <br>  Where <br>  string - analyzed string <br>  stringCheckingStyle - constants that impose some restrictions <br>  allConditionsIsRequired - the flag, in case it has the value ‚ÄúYES‚Äù, the conditions defined by all constants ‚ÄústringCheckingStyle‚Äù are mandatory, if it has the value ‚ÄúNO‚Äù, any one or several specified conditions can be executed <br>  minLengthOfString - minimum string length <br><br>  Constants "stringCheckingStyle" are given as follows: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> tMSstringCheckingStyle: <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> { kMSstringCheckingStyle_digits = <span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">// must-have only a digits kMSstringCheckingStyle_englishLetters = 1ULL &lt;&lt; 1, // must-have only a English letters kMSstringCheckingStyle_russianLetters = 1ULL &lt;&lt; 2, // must-have only a Russian letters kMSstringCheckingStyle_startWithLetter = 1ULL &lt;&lt; 3, // the string necessarily start with a letter kMSstringCheckingStyle_upperAndLowerCaseLetters = 1ULL &lt;&lt; 4, // must-have a uppercase and a lowercase letters kMSstringCheckingStyle_specialSymbols = 1ULL &lt;&lt; 5, // must-have one or more special symbols "-" "." "+" "_" } tMSstringCheckingStyle;</span></span></code> </pre><br>  Thus, for example, writing a function with the form: <br><br><pre> <code class="hljs objectivec"> msfDDstringCheckingStyle(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *string, tMSstringCheckingStyle kMSstringCheckingStyle_digits | kMSstringCheckingStyle_englishLetters, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)</code> </pre> <br>  we will get a positive result only if the string ‚Äústring‚Äù has at least 8 characters and it will necessarily contain letters of the English alphabet and numbers, which is useful, for example, when checking new passwords. <br><br>  As you can see the issue is solved in just one line of code. <br><br><hr><br>  We hope that the material was useful to you, the <a href="https://habrahabr.ru/users/mslibrary/" class="user_link">MSLibrary</a> for iOS team <br><br>  Other articles: <br>  <a href="https://habrahabr.ru/post/278345/"><b>Capture and verify phone numbers using regular expressions, for iOS and not only ... Part 1</b></a> <br>  <a href="https://habrahabr.ru/post/278359/"><b>Capturing and verifying phone numbers using regular expressions, for iOS and not only ... Part 2</b></a> <br>  <a href="https://habrahabr.ru/post/279563/"><b>SIMPLE: remove unnecessary characters from the string, for iOS and not only ...</b></a> <br>  <a href="https://habrahabr.ru/post/280286/"><b>Creating and compiling cross-platform (universal) libraries in Xcode</b></a> </div><p>Source: <a href="https://habr.com/ru/post/279441/">https://habr.com/ru/post/279441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279429/index.html">Three main browsers added support for low-level WebAssembly binary format</a></li>
<li><a href="../279431/index.html">ePMP AP Lite | Use of ePMP 1000 Cambium Networks Licenses</a></li>
<li><a href="../279435/index.html">New ICQ for Windows, open source and something else</a></li>
<li><a href="../279437/index.html">Checking the source code of the PVS-Studio plugin with PVS-Studio</a></li>
<li><a href="../279439/index.html">A simple and not very obvious way to hang chrome, firefox and nodejs inside a native function</a></li>
<li><a href="../279443/index.html">Persistent RAM</a></li>
<li><a href="../279445/index.html">How to turn a conference trip into a cool weekend?</a></li>
<li><a href="../279447/index.html">What to write desktop client for a web service?</a></li>
<li><a href="../279449/index.html">Some thoughts and tips on optimizing C ++ code</a></li>
<li><a href="../279451/index.html">Happy birthday, Richard Stallman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>