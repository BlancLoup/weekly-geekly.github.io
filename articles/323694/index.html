<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Discord stores billions of messages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Discord continues to grow faster than we expected, just like custom content. The more users - the more messages in the chat. In July, we announced 40 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Discord stores billions of messages</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0e4/043/9c1/0e40439c1a3e477dac459b83c6815b85.png"><br><br>  Discord continues to grow faster than we expected, just like custom content.  The more users - the more messages in the chat.  In July, we <a href="https://blog.discordapp.com/11-million-players-in-one-year/">announced 40 million messages per day</a> , in December we <a href="http://venturebeat.com/2016/12/08/discord-hits-25-million-users-and-releases-gamebridge-sdk-for-its-voice-chat/">announced 100 million</a> , and in mid-January we overcame 120 million. We immediately decided to keep the chat history forever, so users can return at any time and get access to their data from anyone devices.  This is a lot of data, the flow and volume of which is growing, and all of them should be accessible.  <i>How do we do it?</i>  <i>Cassandra!</i> <br><a name="habracut"></a><br><h1>  What we did </h1><br>  The initial version of Discord was written in less than two months in early 2015.  Perhaps one of the best DBMSs for fast iteration is MongoDB.  Everything in Discord was specially stored in a single replica (replica set) of MongoDB, but we also prepared everything for simple migration to the new DBMS (we knew that we were not going to use MongoDB sharding because of its complexity and unknown stability).  In fact, it is part of our corporate culture: develop quickly to experience a new product function, but always with a course for a more reliable solution. <br><br>  Messages were stored in the MongoDB collection with a single composite index on <code>channel_id</code> and <code>created_at</code> .  Around November 2015, we reached the milestone of 100 million messages in the database, and then we began to understand the problems that await us: the data and the index are no longer placed in RAM, and the delays become unpredictable.  It's time to migrate to a more suitable DBMS. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Choosing the right DBMS </h1><br>  Before choosing a new DBMS, we needed to understand the existing read / write templates and why there were problems with the current solution. <br><br><ul><li>  It quickly became clear that read operations are purely random, and read / write ratios are approximately 50/50. </li><li>  Heavy Discord voice chat servers almost did not send messages.  That is, they sent one or two messages every few days.  For a year, a server of this type is unlikely to reach the milestone of 1000 messages.  The problem is that even with such a small number of messages, this data is more difficult to deliver to users.  Simply returning 50 messages to the user can result in many random disk searches, which results in crowding out the disk cache. </li><li>  Heavy servers of private text chat Discord send a decent number of messages, easily falling into the range between 100 thousand and 1 million messages per year.  They usually request only the most recent data.  The problem is that there are usually less than 100 participants on these servers, so the data request rate is low and they are unlikely to be in the disk cache. </li><li>  Large public Discord servers send a lot of messages.  There are thousands of contributors sending thousands of messages per day.  Easily recruited millions of messages per year.  They almost always request messages sent in the last hour, and this happens often.  Therefore, the data is usually located in the disk cache. </li><li>  We knew that in the coming year, users will have even more ways to generate random readings: the ability to view their references in the last 30 days and then jump at that moment in history, view and navigate to the attached messages and full-text search.  <i>All this means even more random readings!</i> </li></ul><br>  We then defined our requirements: <br><br><ul><li>  <b>Linear scalability</b> - We do not want to revise the decision later or manually transfer the data to another shard. </li><li>  <b>Automatic failover</b> - We like to sleep at night and make the Discord as self-healing as possible. </li><li>  <b>A little support</b> - It should work as soon as we install it.  All we have to do is add more nodes as data increases. </li><li>  <b>Proven to work</b> - We love to try new technologies, but not too new. </li><li>  <b>Predictable performance</b> - Messages are sent to us if the API response time in 95% of cases exceeds 80 ms.  We also do not want to deal with the need to cache messages in Redis or Memcached. </li><li>  <b>Non blob storage</b> - Writing thousands of messages per second will not work fine if we have to continuously de-serialize blobs and attach data to them. </li><li>  <b>Open source</b> - We believe that we manage our own destiny, and do not want to depend on a third-party company. </li></ul><br>  Cassandra was the only DBMS that met all our requirements.  We can simply add nodes when scaling, and it copes with the loss of nodes without any influence on the application.  In big companies like Netflix and Apple, there are thousands of Cassandra nodes.  Linked data is stored side by side on the disk, ensuring minimal search operations and easy distribution across the cluster.  It is supported by DataStax, but is distributed open-source and community-based. <br><br>  Having made a choice, it was necessary to prove that he was really justified. <br><br><h1>  Data modeling </h1><br>  The best way to describe a newcomer to Cassandra is abbreviation KKV.  The two letters ‚ÄúK‚Äù contain the primary key.  The first ‚ÄúK‚Äù is the partition key.  It helps to determine in which node the data lives and where to find them on disk.  There are many lines inside a section, and the second ‚ÄúK‚Äù, the clustering key, defines a specific line within a section.  It works as a primary key inside a section and determines how to sort the rows.  You can submit a section as an ordered dictionary.  All these qualities combined allow for very powerful data modeling. <br><br>  Remember that messages in MongoDB were indexed using <code>channel_id</code> and <code>created_at</code> ?  <code>channel_id</code> became the partition key, since all messages work on the channel, but <code>created_at</code> does not give a good clustering key, because two messages can be created at the same time.  Fortunately, each ID in Discord is actually created in <a href="https://blog.twitter.com/2010/announcing-snowflake">Snowflake</a> , that is, chronologically sorted.  So it was possible to use them.  The primary key is turned into <code>(channel_id, message_id)</code> , where <code>message_id</code> is Snowflake.  This means that when loading a channel, we can tell Cassandra the exact range where to look for messages. <br><br>  Here is a simplified diagram for our message table (it skips about 10 columns). <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> messages ( channel_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, message_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, author_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (channel_id, message_id) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (message_id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre> <br>  Although the schemas of Cassandra are similar to relational database schemas, they are easy to modify, which does not have any temporary effect on performance.  We took the best from blob storage and relational storage. <br><br>  As soon as the import of existing messages into Cassandra began, we immediately saw warnings in the logs that sections larger than 100 MB were found.  <i>Yah?!</i>  <i>After all, Cassandra declares support for sections 2 GB!</i>  Apparently, the opportunity itself does not mean that it should be done.  Large sections impose a heavy load on the garbage collector in Cassandra during compaction, cluster expansion, etc.  The presence of a large partition also means that the data in it cannot be distributed across the cluster.  It became clear that we will have to somehow limit the size of the sections, because some channels of Discord may exist for years and constantly increase in size. <br><br>  We decided to distribute our messages in blocks (buckets) in time.  We looked at the largest channels in the Discord and determined that if we store messages in blocks of about 10 days, we will comfortably invest in the 100 MB limit.  Blocks must be received from <code>message_id</code> or timestamps. <br><br><pre> <code class="hljs pgsql">DISCORD_EPOCH = <span class="hljs-number"><span class="hljs-number">1420070400000</span></span> BUCKET_SIZE = <span class="hljs-number"><span class="hljs-number">1000</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">24</span></span> * <span class="hljs-number"><span class="hljs-number">10</span></span> def make_bucket(snowflake): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> snowflake <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-type"><span class="hljs-type">timestamp</span></span> = <span class="hljs-type"><span class="hljs-type">int</span></span>(<span class="hljs-type"><span class="hljs-type">time</span></span>.time() * <span class="hljs-number"><span class="hljs-number">1000</span></span>) - DISCORD_EPOCH <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> a Snowflake <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> created it contains the number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> # seconds since the DISCORD_EPOCH. <span class="hljs-type"><span class="hljs-type">timestamp</span></span> = snowflake_id &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>(<span class="hljs-type"><span class="hljs-type">timestamp</span></span> / BUCKET_SIZE) def make_buckets(start_id, end_id=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range(make_bucket(start_id), make_bucket(end_id) + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Cassandra partition keys can be composite, so our new primary key has become <code>((channel_id, bucket), message_id)</code> . <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> messages ( channel_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, bucket <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, message_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, author_id <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ((channel_id, bucket), message_id) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (message_id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre> <br>  To request recent messages in the channel, we generated a range of blocks from the current time to <code>channel_id</code> (it is also sorted chronologically as Snowflake and must be older than the first message).  Then we sequentially query the sections until we collect enough messages.  The downside of this method is that occasionally active instances of Discord will have to poll many different blocks in order to collect enough messages with time.  In practice, it turned out that everything is in order, because for the active Discord instance there are usually enough messages in the first section, and such are the majority. <br><br>  Import messages in Cassandra passed without interference, and we were ready to try it in production. <br><br><h1>  Hard start </h1><br>  Bringing a new system into production is always scary, so a good idea would be to test it without affecting users.  We configured the system to duplicate read / write operations in MongoDB and Cassandra. <br><br>  Immediately after launching, errors appeared in the bug tracker, that <code>author_id</code> is zero.  <i>How can it be zero?</i>  <i>This is a required field!</i> <br><br><h1>  Coherence ultimately </h1><br>  Cassandra is an <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">AP</a> type system, that is, guaranteed integrity is sacrificed for accessibility, which we wanted in general.  In Cassandra, reading before writing is contraindicated (read operations are more expensive) and therefore all that Cassandra does is update and insert (upsert), even if you provide only certain columns.  You can also write to any node, and it will automatically resolve conflicts using the ‚Äúlast record wins‚Äù semantics for each column.  <i>So how did this affect us?</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/287/076/cf1/287076cf1f54572291a609e30b09f1cb.gif"><br>  <i>Sample race status edit / delete</i> <br><br>  If a user edited a message while another user deleted the same message, we had a line with completely missing data, except for the primary key and the text, because Cassandra only writes updates and inserts.  There are two possible solutions for this problem: <br><br><ol><li>  Write back the whole message while editing the message.  Then there is the possibility of resurrecting deleted messages and added chances of conflicts for simultaneous entries in other columns. </li><li>  Identify the damaged message and delete it from the database. </li></ol><br>  We chose the second option by defining the required column (in this case <code>author_id</code> ) and deleting the message if it is empty. <br><br>  Solving this problem, we noticed that we were very inefficient with write operations.  Since Cassandra is ultimately agreed, she cannot take and immediately delete the data.  She needs to replicate deletions to other nodes, and this should be done even if nodes are temporarily unavailable.  Cassandra handles this by equating the deletion to a peculiar form of recording called ‚Äútombstone‚Äù (‚Äúgravestone‚Äù).  During a reading operation, she simply slips through the ‚Äútombstones‚Äù that occur along the way.  The tombstones' lifetime is set up (by default, 10 days), and they are permanently deleted during the compaction of the base, if the term is out. <br><br>  Deleting a column and writing a zero to a column is absolutely the same thing.  In both cases, a "gravestone" is created.  Since all entries in Cassandra are updates and inserts, you create a ‚Äúheadstone‚Äù even if you initially write zero.  In practice, our complete message layout consisted of 16 columns, but the average message had only 4 fixed values.  We recorded 12 "gravestones" in Cassandra, usually for no reason.  The solution to the problem was simple: write only non-zero values ‚Äã‚Äãto the database. <br><br><h1>  Performance </h1><br>  Cassandra is known to perform write operations faster than reads, and we have seen exactly that.  Write operations occurred in the interval of less than a millisecond, and read operations ‚Äî less than 5 milliseconds.  Such indicators were observed regardless of the type of data accessed.  Performance remained unchanged during the week of testing.  <i>No wonder, we got exactly what we expected.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/589/dfe/b86/589dfeb8609651679991a0e510afe859.png"><br>  <i>Delay read / write, according to data from the log</i> <br><br>  In accordance with fast, reliable reading performance, here is an example of a transition to a message a year ago in a channel with millions of messages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/365/327/80b/36532780b6b2f51093a25a84f96b6c29.gif"><br><br><h1>  Big surprise </h1><br>  Everything went smoothly, so we rolled out Cassandra as our main database and disabled MongoDB within a week.  She continued to work flawlessly ... for about 6 months, until one day she stopped reacting. <br><br>  We noticed that Cassandra continuously stops for 10 seconds during garbage collection, but could not understand why.  They started digging and found the Discord channel, which took 20 seconds to load.  The culprit was the public Discord-server of <a href="https://www.reddit.com/r/PuzzleAndDragons/">subddit Puzzles &amp; Dragons</a> .  Since it is public, we are joined to watch.  To our surprise, there was only one message on the channel.  At that moment, it became obvious that they deleted millions of messages through our APIs, leaving only one message on the channel. <br><br>  If you read carefully, remember how Cassandra handles deletions using ‚Äúgravestones‚Äù (mentioned in the ‚ÄúConsistency in the Final Matter‚Äù chapter).  When a user downloads this channel, even though there is one message, Cassandra has to efficiently scan millions of ‚Äúgravestones‚Äù of messages.  Then it generates garbage faster than the JVM can collect it. <br><br>  We solved this problem as follows: <br><br><ul><li>  We reduced the tombstone life from 10 days to 2 days, because every evening we run the <a href="https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsRepair.html">Cassandra</a> (anti-entropy process) <a href="https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsRepair.html">repair</a> on our message cluster. </li><li>  Modified request code to keep track of empty blocks on the channel and avoid them in the future.  This means that if the user initiated this request again, then at worst Cassandra will scan only the most recent block. </li></ul><br><h1>  Future </h1><br>  At the moment, we have a cluster of 12 nodes with a replication rate of 3, and we will continue to add new Cassandra nodes as needed.  We believe that this approach is efficient in the long term, but as Discord grows, the distant future is seen, when you have to save billions of messages per day.  Netflix and Apple have clusters with hundreds of nodes, so for now we have nothing to worry about.  However, I want to have a couple of ideas in reserve. <br><br><h3>  Near future </h3><br><ul><li>  Update our message cluster from Cassandra 2 to Cassandra 3. The <a href="http://www.datastax.com/2015/12/storage-engine-30">new storage format</a> in Cassandra 3 can reduce storage by more than 50%. </li><li>  Newer versions of Cassandra do a better job of handling more data in each node.  We now store approximately 1 TB of compressed data in each of them.  We think that it is safe to reduce the number of nodes in a cluster by increasing this limit to 2 TB. </li></ul><br><br><h3>  Distant future </h3><br><ul><li>  Explore <a href="http://www.scylladb.com/">Scylla</a> is a Cassandra-compatible DBMS and written in C ++.  In normal operation, our Cassandra nodes actually consume few CPU resources, but during off-peak hours during the Cassandra repair (anti-entropy process) they are quite dependent on the CPU, and the repair time increases depending on the amount of data recorded since the last repair.  Scylla promises to significantly increase the repair speed. </li><li>  Create a system to archive unused channels in Google Cloud Storage and download them back on demand.  We want to avoid this and do not think that this will have to do. </li></ul><br><h3>  Conclusion </h3><br>  It has been more than a year since the transition to Cassandra, and despite the <i>‚Äúbig surprise‚Äù</i> , it was a peaceful swim.  We went from more than 100 million total messages to more than 120 million messages per day, while maintaining performance and stability. <br><br>  Thanks to the success of this project, we have since transferred all our other data in production to Cassandra, and also successfully. <br><br>  Over the course of this article, we explore how we perform full-text searches across billions of posts. <br><br>  We still do not have specialized DevOps engineers (only four backend engineers), so it‚Äôs very cool to have a system that you don‚Äôt have to worry about.  <i>We are recruiting staff, so <a href="https://discordapp.com/company">contact us</a> if such tasks tickle your imagination.</i> </div><p>Source: <a href="https://habr.com/ru/post/323694/">https://habr.com/ru/post/323694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323682/index.html">The problem of saving context in asynchronous programming in scala</a></li>
<li><a href="../323684/index.html">Duke Nukem 3D Source Code Analysis: Part 2</a></li>
<li><a href="../323686/index.html">Great overview of the best designers of mobile applications in 2017</a></li>
<li><a href="../323688/index.html">LIFT: Learned Invariant Feature Transform</a></li>
<li><a href="../323692/index.html">Universal grammar analyzer of natural languages ‚Äã‚Äãfrom scratch. Release 1</a></li>
<li><a href="../323696/index.html">Lectures Technopark. The course "Algorithms and data structures" (autumn 2016)</a></li>
<li><a href="../323702/index.html">Find for spy: AAB-testing as the best option for split-test</a></li>
<li><a href="../323704/index.html">Product Design Digest February 2017</a></li>
<li><a href="../323706/index.html">Tips for a novice rocker</a></li>
<li><a href="../323708/index.html">Install and configure Puppet + Foreman on Ubuntu 14.04 (step-by-step tutorial)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>