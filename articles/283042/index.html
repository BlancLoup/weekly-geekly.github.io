<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Towards Full Typing with TypeScript, Swashbuckle, and AutoRest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This article discusses how to implement typed messaging between the Back-End based on ASP.NET Web API and Front-End created using TypeS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Towards Full Typing with TypeScript, Swashbuckle, and AutoRest</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  This article discusses how to implement typed messaging between the Back-End based on ASP.NET Web API and Front-End created using TypeScript.  This is of particular importance when working on bulk projects, and more importantly, if the team is distributed.  For example, when Back-End and Front-End developers work from different places, in different time zones, and do not always have the opportunity to contact and discuss something.  In this case, change tracking is a painstaking job that can be fraught with many subtle errors. <br><br>  For the author of the article, as for the person who came to the development of the Front-End by WPF and Silverlight, the big problem was the lack of static typing.  How many times instead of adding ‚Äú2‚Äù and ‚Äú2‚Äù added ‚Äú2‚Äù and ‚ÄúFunction returning 2‚Äù, or passed a DOM object instead of its jQuery wrapper.  The emergence of static code analyzers, such as JSLint, somewhat eased the problem, but TypeScript was a real breakthrough, especially in team development. <br><br><img src="https://habrastorage.org/files/b0b/c02/9aa/b0bc029aa8f7457784c62d25b8dbb42b.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  The essence of the problem </h2><br>  TypeScript is a language that allows you to achieve static typing, although some people call it ‚Äúillusion‚Äù ( <a href="https://habrahabr.ru/post/258957/">habrahabr.ru/post/258957</a> , <a href="https://habrahabr.ru/post/272055/">habrahabr.ru/post/272055</a> ).  It is curious that critics emphasize working with the Back-End as a <i>typically non-secure</i> scenario. <br>  However, the essence of the problem lies in the fact that when writing Front-End applications in JavaScript before, and in TypeScript at the present time, we do not have such tools for working with metadata and auto-generating client code, as we once had in WCF. <br><br><h2>  Metadata </h2><br>  If we look at the experience of WPF + WCF, then everything is quite good in this respect.  Of course, the data, generally speaking, always travel in an untyped form, but when sent, it remains typed almost to the very end, and only immediately before sending to the other side are serialized into a string or binary stream.  On the other side, again, they end up in some kind of customer who turns them into typed ones.  In order not to write with the hands of such a client and not try to catch multiple errors, and there is metadata.  In the .NET world, in 90% of cases, no work is required at all, neither for their generation, nor for their processing.  You just write your service, do not forget to add the appropriate endpoint, and get auto-generated metadata.  Also in one click you generate a client and as a result you get an exchange of typed messages. <br><br>  When developing Single Page Application on JavaScript / TypeScript, the Web API replaces WCF.  At one time, it was somewhat surprising why there is no way to generate metadata for the Web API out of the box (not to consider the same help-pages as metadata).  Apparently the answer is that the main recipient of the data from the Web API was JavaScript code, in which typing does not make sense.  However, we now have not JavaScript but TypeScript, and the desire to operate with typed data again becomes relevant. <br><br>  A very popular metadata format is now OpenAPI / Swagger.  Not surprisingly, there are opportunities to generate metadata and documentation in this format. <br><br>  Next, we will demonstrate the process of organizing typed interaction. <br>  In short, we will complete the following steps: <br><br><ol><li>  Let's connect and configure the Swashbuckle library </li><li>  Generate documentation / metadata </li><li>  Make sure that the generated file is stored in the version control system </li><li>  Connect AutoRest </li><li>  Generate client models </li><li>  Let's test them in action. </li></ol><br><br><h2>  Swashbuckle </h2><br>  <a href="https://github.com/domaindrivendev/Swashbuckle">github.com/domaindrivendev/Swashbuckle</a> <br><br>  First we want to generate metadata. <br>  So, suppose we have a Web API, and in it is a controller responsible for working with employees. <br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets all employees. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets the list of all employees. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The list of employees. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [Route("api/employees")] [HttpGet] public Employee[] GetEmployees() { return new[] { new Employee { Id = 1, Name = "John Doe" }, new Employee { Id = 2, Name = "Jane Doe" } }; }</span></span></code> </pre> <br>  As you can see, an array of typed objects of type Employee is returned.  Having launched our project, we can request a list of employees: <br>  <a href="http://localhost:1234/api/employees">http: // localhost: 1234 / api / employees</a> <br><br>  Let's connect the Swashbuckle library now.  There are two Swashbuckle.Core and Swashbuckle packages in NuGet.  The difference between the two is that the first is the kernel and contains all the code that does the magic, and the second, in turn, is just the add-on that installs the bootstrapper that configures the kernel. <br><br>  This is written in the documentation <a href="https://github.com/domaindrivendev/Swashbuckle">github.com/domaindrivendev/Swashbuckle#iis-hosted</a> <br><br>  We prefer installing Core and writing the configuration code ourselves, since  it is then more convenient to reuse. <br><br>  Let's install it <br><pre> <code class="bash hljs">PM&gt; Install-Package Swashbuckle.Core</code> </pre><br>  register with WebActivatorEx <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: WebActivatorEx.PreApplicationStartMethod(typeof(FullyTypedExample.WebApi.SwaggerConfig), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RegisterGlobal"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre><br>  and also write the configuration code <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Configures Swagger. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="config"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The Swagger configuration. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public static void ConfigureSwagger(SwaggerDocsConfig config) { config.SingleApiVersion("v1", "FullyTypedExample.WebApi"); config.IncludeXmlComments(GetXmlCommentsPathForControllers()); config.IncludeXmlComments(GetXmlCommentsPathForModels()); config.GroupActionsBy(apiDescription =&gt; apiDescription.ActionDescriptor.ControllerDescriptor.ControllerName); config.OrderActionGroupsBy(Comparer</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">.Default); config.PrettyPrint(); }</span></span></code> </pre><br>  Everything is quite simple here: first we install the version and title of our API.  Further we say that it is necessary to include xml-comments for controllers and models.  Adjust the order and grouping of action inside the swagger document.  Separately, I would like to mention the PrettyPrint option.  It includes JSON formatting for the swagger document.  This option is useful in order to further store the documentation in the version control system and easily view its changes using any diff viewer. <br><br>  Now you can run the project and see the Swagger interface. <br>  <a href="http://localhost:1234/swagger">http: // localhost: 1234 / swagger</a> <br><br><img src="https://habrastorage.org/files/41d/d89/f88/41dd89f886774cb3b52a5b6d4876894b.png"><br><br>  Nearby you can look at the swagger document itself in the form of JSON. <br>  <a href="http://localhost:1234/swagger/docs/v1">http: // localhost: 1234 / swagger / docs / v1</a> <br><br>  Now we need to add the generated documentation to the version control system.  Since Swashbuckle uses IApiExplorer under the hood, in order to generate a swagger file you will have to launch the Web API (for more information, see <a href="https://github.com/domaindrivendev/Swashbuckle/issues/559">github.com/domaindrivendev/Swashbuckle/issues/559</a> ).  That is, each time you want to generate documentation, you have to run the Web API and copy swagger / docs to a file manually.  Of course, I want something more automated. <br><br>  We solved this by launching the Web API in the form of a self-hosted application, sending the request to the endpoint swagger and not writing the response to the file.  This is where it was useful to reuse the Swashbuckle configuration code.  It looks like this: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Generate Swagger JSON document. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="filePath"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The file path where to write the generated document. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void GenerateSwaggerJson(string filePath) { // Start OWIN host using (TestServer server = TestServer.Create</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;WebApiHostStartup&gt;</span></span></span><span class="hljs-comment">()) { HttpResponseMessage response = server.CreateRequest("/swagger/docs/v1").GetAsync().Result; string result = response.Content.ReadAsStringAsync().Result; string path = Path.GetFullPath(filePath); File.WriteAllText(path, result); } }</span></span></code> </pre><br>  Let's run all this now: <br><pre> <code class="bash hljs">nuget.exe restore <span class="hljs-string"><span class="hljs-string">"..\FullyTypedExample.sln"</span></span> <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\MSBuild\12.0\bin\MSBuild.exe"</span></span> <span class="hljs-string"><span class="hljs-string">"..\FullyTypedExample.WebApi.SelfHosted\FullyTypedExample.WebApi.SelfHosted.proj"</span></span> /v:minimal <span class="hljs-string"><span class="hljs-string">"..\FullyTypedExample.WebApi.SelfHosted\bin\Debug\FullyTypedExample.WebApi.SelfHosted.exe"</span></span> --swagger <span class="hljs-string"><span class="hljs-string">"swagger.json"</span></span></code> </pre><br>  So we got the swagger document as a JSON file and put it into the version control system.  Now Front-End developers from our distributed team can easily track changes in endpoint s.  Let's see what it looks like. <br><br>  Suppose we added a new action to get an employee by his ID. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets employee by id. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="employeeId"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The employee id. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets the employee by specified id. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="Employee"/&gt;</span></span></span><span class="hljs-comment">. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [Route("api/employees/{employeeId:int}")] public Employee GetEmployeeById(int employeeId) { return this.GetEmployees().SingleOrDefault(x =&gt; x.Id == employeeId); }</span></span></code> </pre><br>  And re-generated swagger.json.  Let's see what has changed <br><img src="https://habrastorage.org/files/e72/72c/346/e7272c346d144e9aab1f882a2a93aecd.png"><br><br>  As you can see, for this action documentation appeared, which can be easily seen using the diff viewer.  Thanks to the PrettyPrint option, it is formatted and easy to read. <br><br><h2>  AutoRest </h2><br>  So, the first part of our task is completed - we have metadata.  How now to generate the client part, i.e.  data types (obtained from the server) on the client side? <br><br>  I must say that you can generate the code itself for requesting a Web API, it's just a little more complicated and requires more time-consuming work on configuring code generators or writing your own.  Also, a lot depends on which libraries (be it jQuery, SuperAgent or even the new experimental Fetch API <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API">developer.mozilla.org/en/docs/Web/API/Fetch_API</a> ) and approaches (Promises, Rx, etc.) you use in your client code. <br><br>  For code generation, the following options exist: <br><br>  <b>1. Swagger Code Generator</b> <a href="https://github.com/swagger-api/swagger-codegen">github.com/swagger-api/swagger-codegen</a> <br>  The official tool from the Swagger team, written in Java and requires the appropriate infrastructure.  It can also run in Docker.  True, the generation of JavaScript and themes TypeScript is absent.  Although if you need to generate code, for example, in Java - this is your choice.  For us, he did not fit for obvious reasons. <br><br>  <b>2. Swagger JS library</b> <a href="https://github.com/swagger-api/swagger-js">github.com/swagger-api/swagger-js</a> <br>  Also an official tool from the Swagger team.  Already warmer.  Written in JS and generates JS code, respectively.  Installed via npm or bower.  The infrastructure is suitable for us, but alas, there is not the type generation itself. <br><br>  <b>3. Swagger to JS &amp; Typescript Codegen</b> <a href="https://github.com/wcandillon/swagger-js-codegen">github.com/wcandillon/swagger-js-codegen</a> <br>  The project was published a little later than we began to develop this approach.  Perhaps in the near future this will be the most appropriate solution. <br><br>  <b>4. Write your <s>bike</s> code generator.</b>  In general, why not?  But for a start, we decided that we would try AutoRest, and if it does not take off, or does not suit us with opportunities, we‚Äôll write our own, with blackjack and ... Well, you understand. <br><br>  5. <b>AutoRest</b> <a href="https://github.com/Azure/autorest">github.com/Azure/autorest</a> <br>  And finally, Microsoft's Azure AutoRest team.  Now the current version is 0.15.0, and frankly it is not clear if this is considered to be a full release from them or not, but the Pre mark, like the previous ones, is not observed.  In general, everything is simple, we installed and immediately generated * .d.ts files that we needed. <br><br>  So let's go through the final part of our journey with this tool. <br><br>  We connect AutoRest via NuGet: <br><pre> <code class="bash hljs">PM&gt; Install-Package AutoRest</code> </pre><br>  The package is not placed in any particular project, a link to it is added for the entire solution. <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">packages</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">package</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"AutoRest"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.15.0"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">packages</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The package has a console application AutoRest.exe, which, in fact, performs the generation.  To run, we use the following script <br><pre> <code class="bash hljs">nuget.exe restore <span class="hljs-string"><span class="hljs-string">"..\FullyTypedExample.sln"</span></span> <span class="hljs-string"><span class="hljs-string">"..\packages\AutoRest.0.15.0\tools\AutoRest.exe"</span></span> -Input <span class="hljs-string"><span class="hljs-string">"swagger.json"</span></span> -CodeGenerator NodeJS move <span class="hljs-string"><span class="hljs-string">"Generated\models\index.d.ts"</span></span> <span class="hljs-string"><span class="hljs-string">"..\FullyTypedExample.HtmlApp\models.d.ts"</span></span></code> </pre><br>  At the entrance we submit our previously generated swagger.json, and at the output we get models \ index.d.ts - a file with models.  We copy it in the client project. <br><br>  Now in TypeScript we have the following model description: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class * Initializes a new instance of the Employee class. * @constructor * Represents the employee. * @member {number} id Gets or sets the employee identifier. * * @member {string} name Gets or sets the employee name. * */</span></span> export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Employee</span></span> { id: number; name: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; }</code> </pre><br>  Let's try it out in the case: <br><pre> <code class="javascript hljs">public makeRequest() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository.getEmployees() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">employees</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Generate html using tempalte string this.table.innerHTML = employees.reduce&lt;string&gt;((acc, x) =&gt; { return `${acc}&lt;tr&gt;&lt;td&gt;${x.id}&lt;/td&gt;&lt;td&gt;${x.name}&lt;/td&gt;&lt;/tr&gt;`; }, ''); }); }</span></span></code> </pre><br>  Here we refer to the id and name model fields.  We intentionally lowered the request to the server because  as we have said, it may depend on the libraries and approaches chosen. <br><br>  If we try to access the age field, which does not exist, our TS code will not compile.  If the field we addressed earlier disappears in the API, our code will not compile again.  If new fields are added, we will immediately see it using the same diff.  In addition, we automatically receive JSDoc documentation based on metadata.  In general, all the delights of static typing is obvious. <br><br><h2>  ResponseType </h2><br>  Interestingly, if necessary, for documentation, you can specify a different type than the one that is returned.  For example, this may be useful if you have legacy code that works with untyped DataSets;  or if you return the IHttpActionResult from the controllers.  Without affecting the implementation of the methods, we can mark them with the ResponseType attribute and develop special types <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets all departments. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets the list of all departments. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The list of departments. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [Route("api/departments")] [HttpGet] [ResponseType(typeof(DepartmentsResponse))] public DataSet GetDepartments() { var dataTable = new DataTable("Departments"); dataTable.Columns.Add("Id", typeof(int)); dataTable.Columns.Add("Name", typeof(string)); dataTable.Rows.Add(1, "IT"); dataTable.Rows.Add(2, "Sales"); var dataSet = new DataSet(); dataSet.Tables.Add(dataTable); return dataSet; }</span></span></code> </pre><br>  to get typed models on the client side <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class * Initializes a new instance of the Department class. * @constructor * Represents the department. * @member {number} id Gets or sets the department identifier. * * @member {string} name Gets or sets the department name. * */</span></span> export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Department</span></span> { id: number; name: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; }</code> </pre><br><br><h2>  Problems </h2><br>  First, the size of the models.d.ts file increases over time.  While we have not engaged in splitting it into several subfiles, but it certainly will need to be done. <br><br>  There may also be a problem with the incorrect generation of field names if non-standard notation is used, for example, if underscores are used.  The LAST_NAME field from the C # code is generated in Swagger as lasT_NAME, and in TypeScrpt as lasTNAME. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets or sets the last name. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [Required] // ReSharper disable once InconsistentNaming public string LAST_NAME { get; set; }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"lasT_NAME"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Gets or sets the last name."</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }</code> </pre><br><pre> <code class="cs hljs">export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Employee</span></span> { id: number; name: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; firstName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; lasTNAME: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; }</code> </pre><br>  Note that most minor problems are easily solved using the configuration and are not worth special mention. <br><br><h2>  Conclusion </h2><br>  This approach allowed us to organize the exchange of typed messages.  At the same time, he provided for the typing of client models, reduced the likelihood of discrepancies between client and server code, made it easier to track changes in the API and models.  A nice bonus was the convenient manual testing API with a built-in REST client and the ability to generate payload on the fly according to the scheme.  Using this approach also helped to improve the interaction of Back-End and Front-End developers. <br><br>  A working example can be seen here. <br>  <a href="https://github.com/EBTRussia/fully-typed-example/">github.com/EBTRussia/fully-typed-example</a> </div><p>Source: <a href="https://habr.com/ru/post/283042/">https://habr.com/ru/post/283042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283026/index.html">How to replace ELK for viewing logs?</a></li>
<li><a href="../283028/index.html">Squid's serious proxy vulnerability can ‚Äúpoison cache‚Äù</a></li>
<li><a href="../283030/index.html">Once again on minimizing boolean functions</a></li>
<li><a href="../283036/index.html">Means of data collection in computer technical expertise</a></li>
<li><a href="../283038/index.html">Performance without event loop</a></li>
<li><a href="../283044/index.html">How data centers are changing right now: Energy efficiency, data storage and the "clouds"</a></li>
<li><a href="../283046/index.html">Explanation of limitations of the demo version of PVS-Studio</a></li>
<li><a href="../283050/index.html">Creating RESTful services on Meteor</a></li>
<li><a href="../283052/index.html">How to hack Telegram and WhatsApp: special services are not needed</a></li>
<li><a href="../283054/index.html">Using the ES2015 standard in the Backbone.js library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>