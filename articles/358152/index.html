<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part XXIII: Application Programming Interfaces (APIs)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(edition 2018) 
 Miguel grinberg 



 There 


 This is the twenty-third part of the Mega-Tutorial, in which I will tell you how to expand microbloggi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part XXIII: Application Programming Interfaces (APIs)</h1><div class="post__text post__text-html js-mediator-article"><h2 id="izdanie-2018">  (edition 2018) </h2><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/354752/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This is the twenty-third part of the Mega-Tutorial, in which I will tell you how to expand microblogging using the application programming interface (or API), which customers can use to work with the application in a more direct way than the traditional web browser workflow. </p><a name="habracut"></a><br><p>  Under the spoiler is a list of all articles in the 2018 series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354322/"><strong>Chapter 21: User Notifications</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354752/"><strong>Chapter 22: Background Tasks</strong></a> </li><li>  <a href="https://habrahabr.ru/post/358152/"><strong>Chapter 23: Application Programming Interfaces (APIs)</strong></a> (This article) </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  All the functionality I have built so far for this application is designed for one specific type of client: a web browser.  But what about other types of customers?  For example, if I wanted to create an application for Android or iOS, I have two main ways to solve it.  The simplest solution would be to create an application using a web component that fills the entire screen and loads the Microblog website, but this will not be qualitatively better than opening the application in the device‚Äôs web browser.  The best solution (albeit much more time consuming) would be to create your own application, but how can this application interact with a server that returns only HTML pages? </p><br><p>  This is a problem area in which <em>Application Programming Interfaces</em> (or APIs) can help.  The API is a collection of HTTP routes that are developed as low-level entry points to the application.  Instead of defining routes and viewing the functions that return HTML to be used by web browsers, the API allows the client to work directly with application resources, leaving the decision on how to present the information to the user completely to the client.  For example, a microblog API can provide a client with user information and blog entries, and also allow the user to edit an existing blog entry, but only at the data level, without mixing this logic with HTML. </p><br><p> If you examine all the routes currently defined in the application, you will notice that there are several that may correspond to the API definition that I used above.  Did you find them?  I'm talking about several routes that return JSON, such as the <em>/ translate</em> route defined in <a href="https://habrahabr.ru/post/350626/">chapter 14</a> .  This is the route that accepts the text, source and destination languages, all data in JSON format in the <code>POST</code> request.  The answer to this request is the translation of this text, also in JSON format.  The server returns only the requested information, leaving the client responsible to present this information to the user. </p><br><p>  While the JSON routes in the application have an API to "feel" to them, they were designed to support a web application running in a browser. <br>  Although the JSON routes in the application have an API, there remains a ‚Äúfeel‚Äù that they were designed to support a web application running in a browser.  Please note that if the application for smartphones wanted to use these routes, it would not be able to, because they need a registered user, and access to the system is possible only through an HTML form.  In this chapter, I will explain how to create APIs that do not rely on a web browser, and not make any assumptions about which client connects to them. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="rest-kak-osnova-proektirovaniya-api">  REST as the basis for API design </h2><br><p>  Someone may strongly disagree with my statement above that <em>/ translate</em> and other JSON routes are API routes.  Others may agree with the caveat that they consider them a poorly designed API.  So, what are the characteristics of a well-developed API, and why are JSON routes outside this category? </p><br><p>  You may have heard the term rest api.  REST, which means Representational State Transfer, is the architecture proposed by Dr. Roy Fielding in his doctoral dissertation.  In his work, Dr. Fielding presents the six defining characteristics of REST in a rather abstract and general form. </p><br><p>  Other than Dr. Fielding‚Äôs thesis, there is no other authoritative REST specification, which leaves much for free interpretation by the reader.  The topic of whether this API is consistent with REST or not is often a source of heated debate between REST ‚Äúpurists‚Äù, who believe that the REST API must comply with all six characteristics and do it in a well-defined way compared to the REST ‚Äúpragmatists‚Äù who take the ideas presented by Dr. Fielding in his dissertation as guidelines or recommendations.  Dr. Fielding himself took the side of the purist camp and gave some additional insight into his vision in blogs and online comments. </p><br><p>  The vast majority of APIs currently implemented adhere to the ‚Äúpragmatic‚Äù REST implementation.  This includes most APIs from ‚Äúbig players,‚Äù such as Facebook, GitHub, Twitter, etc.  There are very few public APIs that are unanimously considered to be pure REST, since most APIs skip some implementation details that purists consider mandatory.  Despite the rigorous views of Dr. Fielding and other REST purists that the REST API is or is not, the software industry usually refers to REST in a pragmatic sense. </p><br><p>  To give you an idea of ‚Äã‚Äãwhat's in the REST dissertation, the following sections describe the six principles listed by Dr. Fielding. </p><br><h3 id="client-server">  Client server </h3><br><p>  The principle of client-server is quite simple, as it simply states that in the REST API, the roles of the client and server must be clearly differentiated.  In practice, this means that the client and server are in separate processes that interact through a transport, which in most cases is the HTTP protocol over the TCP network. </p><br><h3 id="layered-system">  Layered system </h3><br><p>  The Layered System principle ( <em>multi-level system</em> ) says that when a client needs to interact with a server, it can be associated with an intermediary, and not with an actual server.  The idea is that for the client there should be absolutely no difference in how he sends requests, if not connected directly to the server, in fact he may not even know whether he is connected to the target server or not.  Similarly, this principle states that a server can receive client requests from an intermediary, and not directly from a client, so it should never assume that the other side of the connection is a client. </p><br><p>  This is an important REST feature, because the ability to add intermediate nodes allows application architects to develop large and complex networks that can satisfy a large volume of requests using a load balancer, caches, proxy servers, etc. </p><br><h3 id="cache">  Cache </h3><br><p>  This principle extends the layered system, explicitly indicating that a server or an intermediary can cache responses to requests that often arrive to improve system performance.  There is a cache implementation that you are probably familiar with: one in all web browsers.  The web browser's cache layer is often used to avoid having to request the same files, such as images, over and over. </p><br><p>  For API purposes, the target server must specify using the cache controls whether the response can be cached by intermediaries when it is returned to the client.  Note that because, for security reasons, APIs deployed in a production environment must use encryption, caching is usually not performed at the smart host unless this node terminates the SSL connection or performs decryption and re-encryption. </p><br><h3 id="code-on-demand">  Code on demand </h3><br><p>  This is an optional requirement indicating that the server can provide executable code in responses to the client.  Since this principle requires an agreement between the server and the client about which executable code the client can execute, this is rarely used in the API.  You might think that the server can return JavaScript code to launch web browsers, but REST is not specifically intended for web browser clients.  For example, executing JavaScript can be difficult if the client is an iOS or Android device. </p><br><h3 id="stateless">  Stateless </h3><br><p>  The stateless principle is one of two at the center of most debates between REST purists and pragmatists.  It states that the REST API should not save any client state that will be triggered each time the client sends a request.  This means that none of the mechanisms that are common in web development for ‚Äúremembering‚Äù users when navigating through the pages of an application cannot be used.  In a stateless API, each request must include information that the server must identify and authenticate the client and execute the request.  It also means that the server cannot store data related to a client connection in a database or other form of storage. </p><br><p>  If you are wondering why REST requires a stateless server, the main reason is that stateless servers are very easy to scale, all you need to do is run several server instances behind the load balancer.  If the server stores the state of the client, the situation becomes more complicated, as you need to figure out how several servers can access and update this state, or ensure that this client is always processed by the same server, which is usually called sticky sessions. </p><br><p>  If you again consider the / translate route discussed at the beginning of the chapter, you will realize that it cannot be considered RESTful, because the view function associated with this route relies on the <code>@login_required</code> decoder from Flask-Login, which in turn stores the registered as a user in a Flask user session. </p><br><h3 id="uniform-interface">  Uniform interface </h3><br><p>  The last, most important, most discussed and most vaguely documented REST principle is a single interface.  Dr. Fielding lists four distinctive aspects of a single REST interface: unique resource identifiers, resource representations, self-descriptive messages, and hypermedia. </p><br><p>  Unique resource identifiers are obtained by assigning a unique URL to each resource.  For example, the URL associated with this user could be / api / users / &lt;user-id&gt;, where &lt;user-id&gt; is the identifier assigned to the user as the primary key of the database table.  This is quite acceptable implemented by most APIs. </p><br><p>  Using resource representations means that if the server and the client exchange information about the resource, they must use the agreed Format.  For most modern APIs, JSON format is used to construct resource representations.  The API can support several resource presentation formats, in which case the content negotiation parameters in the HTTP protocol are the mechanism by which the client and the server can agree on a format that both like. </p><br><p>  Self-descriptive messages mean that requests and responses exchanged between clients and the server should include all the information needed by the other party.  A typical example is the HTTP request method used to specify which operation the client wants to receive from the server.  A <code>GET</code> indicates that the client wants to get information about the resource, a <code>POST</code> request indicates that the client wants to create a new resource, <code>PUT</code> or <code>PATCH</code> requests determine changes to existing resources, and a <code>DELETE</code> request indicates that the resource has been deleted.  The target resource is specified as the URL of the request with additional information provided in the HTTP headers, part of the URL request string, or request body. </p><br><p>  The hypermedia requirement is the most controversial of many, and one that is implemented by few APIs, and those APIs that implement it, rarely do so to satisfy REST purists.  Since all the resources in an application are interconnected, it requires that links be included in resource views so that clients can discover new resources by circumventing links, much like you discover new pages in a web application by clicking links that lead you from one page to other.  The idea is that the client can enter the API without any prior knowledge of the resources in it and learn about them, simply by following hypermedia links.  One aspect that makes it difficult to fulfill this requirement is that, unlike HTML and XML, the json format, which is usually used to represent resources in the API, does not define a standard way to include links, so you have to use special custom structures, or one of the proposed JSON extensions that try to fill this gap, such as <a href="http://jsonapi.org/">JSON-API</a> , <a href="http://stateless.co/hal_specification.html">HAL</a> , <a href="https://json-ld.org/">JSON-LD,</a> or similar. </p><br><h2 id="realizaciya-koncepcii-api-blueprint">  Implementing the Blueprint API concept </h2><br><p>  To give you an idea of ‚Äã‚Äãwhat is involved in API development, I'm going to add it to microblogging.  It will not be a complete API, I am going to implement all the functions associated with users, leaving the implementation of other resources, such as blog posts to the reader, as an exercise. </p><br><p>  So that everything is organized and structured in accordance with the concept described in <a href="https://habrahabr.ru/post/351218/">Chapter 15</a> , I am going to create a new project that will contain all the API routes.  So let's start by creating a directory in which this project will live: </p><br><pre> <code class="plaintext hljs">(venv) $ mkdir app/api</code> </pre> <br><p>  Blueprint file <code>__init __. py</code>  <code>__init __. py</code> creates a blueprint object, similar to other blueprint applications: </p><br><blockquote>  <strong><code>app/api/__init__.py:</code></strong> API blueprint constructor. </blockquote><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Blueprint bp = Blueprint(<span class="hljs-string"><span class="hljs-string">'api'</span></span>, __name__) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> users, errors, tokens</code> </pre> <br><p>  You probably remember that sometimes it is necessary to move the import to the very bottom of the module in order to avoid cyclic dependency errors.  This is the reason why the <em>app / api / users.py</em> , <em>app / api / errors.py</em> and <em>app / api / tokens.py</em> modules (what I have yet to write) are imported after creating the project. </p><br><p>  The main content of the API will be stored in the <em>app / api / users.py module</em> .  The following table lists the routes that I am going to implement: </p><br><table><thead><tr><th>  HTTP Method </th><th>  Resource URL </th><th>  Notes </th></tr></thead><tbody><tr><td>  Get </td><td> <code>/api/users/&lt;id&gt;</code> </td> <td>  Returns the user. </td></tr><tr><td>  Get </td><td> <code>/api/users</code> </td> <td>  Returns a collection of all users. </td></tr><tr><td>  Get </td><td> <code>/api/users/&lt;id&gt;/followers</code> </td> <td>  Returns followers of this user. </td></tr><tr><td>  Get </td><td> <code>/api/users/&lt;id&gt;/followed</code> </td> <td>  Will return users subscribed by this user. </td></tr><tr><td>  POST </td><td> <code>/api/users</code> </td> <td>  Registers a new user account. </td></tr><tr><td>  PUT </td><td> <code>/api/users/&lt;id&gt;</code> </td> <td>  Changes user. </td></tr></tbody></table><br><p>  The framework of the module with placeholders for all these routes will be as follows: </p><br><blockquote>  <strong><code>app/api/users.py:</code></strong> User API resource placeholders. </blockquote><br><pre> <code class="plaintext hljs">from app.api import bp @bp.route('/users/&lt;int:id&gt;', methods=['GET']) def get_user(id): pass @bp.route('/users', methods=['GET']) def get_users(): pass @bp.route('/users/&lt;int:id&gt;/followers', methods=['GET']) def get_followers(id): pass @bp.route('/users/&lt;int:id&gt;/followed', methods=['GET']) def get_followed(id): pass @bp.route('/users', methods=['POST']) def create_user(): pass @bp.route('/users/&lt;int:id&gt;', methods=['PUT']) def update_user(id): pass</code> </pre> <br><p>  In the <em>app / api / errors.py module,</em> you need to define several helper functions that deal with error responses.  But now, I will create a placeholder that I fill in later: </p><br><blockquote>  <strong><code>app/api/errors.py:</code></strong> Error handling placeholder. </blockquote><br><pre> <code class="plaintext hljs">def bad_request(): pass</code> </pre> <br><p>  <em>app / api / tokens.py</em> module in which the authentication subsystem will be defined.  This will provide an alternative login method for clients that are not web browsers.  Let's write a placeholder for this module: </p><br><blockquote>  <strong><code>app/api/tokens.py:</code></strong> handling. </blockquote><br><pre> <code class="plaintext hljs">def get_token(): pass def revoke_token(): pass</code> </pre> <br><p>  The new Blueprint API elements scheme should be registered in the application factory function: </p><br><blockquote>  <strong><code>app/__init__.py:</code></strong> Register the schema of the API elements in the application. </blockquote><br><pre> <code class="plaintext hljs"># ... def create_app(config_class=Config): app = Flask(__name__) # ... from app.api import bp as api_bp app.register_blueprint(api_bp, url_prefix='/api') # ...</code> </pre> <br><h2 id="predstavlenie-polzovateley-v-vide-obektov-json">  Representation of users as JSON objects </h2><br><p>  The first aspect to consider when implementing an API is to decide what the presentation of its resources will be.  I'm going to implement an API that works with users, so the view for my user resources is what I need to solve.  After some brainstorming, I came up with the following json view: </p><br><pre> <code class="plaintext hljs">{ "id": 123, "username": "susan", "password": "my-password", "email": "susan@example.com", "last_seen": "2017-10-20T15:04:27Z", "about_me": "Hello, my name is Susan!", "post_count": 7, "follower_count": 35, "followed_count": 21, "_links": { "self": "/api/users/123", "followers": "/api/users/123/followers", "followed": "/api/users/123/followed", "avatar": "https://www.gravatar.com/avatar/..." } }</code> </pre> <br><p>  Many of the fields come directly from the user database model.  The <code>password</code> field is different in that it will only be used when registering a new user.  As you remember from <a href="https://habrahabr.ru/post/346346/">Chapter 5</a> , user passwords are not stored in the database, but only a hash, so the password never returns.  The <code>email</code> field is also specially processed, because I do not want to disclose the email addresses of users.  The email field will be returned only when users request their own record, but not when receiving records from other users.  The fields <code>post_count</code> , <code>follower_count</code> and <code>follow_count</code> are ‚Äúvirtual‚Äù fields that do not exist as fields in the database, but are provided to the client as a convenience.  This is a great example that demonstrates that the resource representation does not have to match the way the actual resource is defined on the server. </p><br><p>  Check out the <code>_links</code> section, which implements hypermedia requirements.  Certain links include links to the current resource, a list of users following this user, a list of users followed by the user, and finally, a link to the user's avatar image.  In the future, if I decide to add messages to this API, the link to the user's message list should also be included here. </p><br><p>  One of the nice features of the JSON format is that it is always translated as a representation in the form of a dictionary or a Python list.  The <code>json</code> package from the standard Python library takes care of converting Python data structures to and from JSON.  Therefore, to generate these views, I'm going to add a method to the <code>User</code> model, called <code>to_dict()</code> , which the Python dictionary returns: </p><br><blockquote>  <strong><code>app/models.py:</code></strong> User model for the view. </blockquote><br><pre> <code class="plaintext hljs">from flask import url_for # ... class User(UserMixin, db.Model): # ... def to_dict(self, include_email=False): data = { 'id': self.id, 'username': self.username, 'last_seen': self.last_seen.isoformat() + 'Z', 'about_me': self.about_me, 'post_count': self.posts.count(), 'follower_count': self.followers.count(), 'followed_count': self.followed.count(), '_links': { 'self': url_for('api.get_user', id=self.id), 'followers': url_for('api.get_followers', id=self.id), 'followed': url_for('api.get_followed', id=self.id), 'avatar': self.avatar(128) } } if include_email: data['email'] = self.email return data</code> </pre> <br><p>  This method should not cause any special questions and be generally understandable.  The dictionary with the user view that I‚Äôve stopped at is simply generated and returned.  As I mentioned above, the <code>email</code> field needs special processing, because I only want to enable email when users request their own data.  Therefore, I use the <code>include_email</code> flag to determine whether this field is included in the view or not. </p><br><p>  Notice how the <code>last_seen</code> field is <code>last_seen</code> .  For date and time fields, I'm going to use the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> Format, which can generate Python <code>datetime</code> using the <code>isoformat()</code> method.  But since I use naive <code>datetime</code> objects that are UTC but do not have a time zone recorded in their state, I need to add a <code>Z</code> at the end, which is the ISO 8601 time zone code for UTC. </p><br><blockquote>  <em>Explanation by <a href="https://habr.com/ru/users/Amikko/">amkko</a> :</em> In python, datetime objects can be ‚Äúnaive‚Äù or ‚Äúnaive / aware‚Äù relative to the time zone. </blockquote><p>  Finally, check out how I implemented hipermedia links.  For the three links that point to other application routes, I use <code>url_for()</code> to generate URLs (which currently point to the lookup function of the replacement elements defined in <em>app / api / users.py</em> ).  The avatar link is special because it is a Gravatar URL that is external to the application.         <code>avatar()</code> ,        -. </p><br><p>  <code>to_dict()</code>      Python,      JSON.       ,       ,          <code>User</code> .   <code>from_dict()</code> ,      Python  : </p><br><blockquote> <strong><code>app/models.py:</code></strong>   . </blockquote><br><pre> <code class="plaintext hljs">class User(UserMixin, db.Model): # ... def from_dict(self, data, new_user=False): for field in ['username', 'email', 'about_me']: if field in data: setattr(self, field, data[field]) if new_user and 'password' in data: self.set_password(data['password'])</code> </pre> <br><p>            ,    : <code>username</code> , <code>email</code>  <code>about_me</code> .     ,      <code>data</code> ,   ,   <code>setattr()</code> Python,         . </p><br><p>  <code>password</code>    ,       .  <code>new_user</code> ,      ,  ,   .   <code>password</code>   ,    <code>set_password()</code> ,    . </p><br><h2 id="predstavlenie-kollekciy-polzovateley">    </h2><br><p>      ,  API       .   , , ,       .     : </p><br><pre> <code class="plaintext hljs">{ "items": [ { ... user resource ... }, { ... user resource ... }, ... ], "_meta": { "page": 1, "per_page": 10, "total_pages": 20, "total_items": 195 }, "_links": { "self": "http://localhost:5000/api/users?page=1", "next": "http://localhost:5000/api/users?page=2", "prev": null } }</code> </pre> <br><p>    <code>items</code> -   ,    ,     .  <code>_meta</code>     ,             .   <code>_links</code>   ,     ,        ,       . </p><br><p>      -    ,       ,  , ,     API  ,        ,        .   <a href="https://habrahabr.ru/post/351900/"> 16</a>         ,   ,       ,        . ,   ,   ,    <code>SearchableMixin</code> ,      ,    .        ,     mixin,    <code>PaginatedAPIMixin</code> : </p><br><blockquote> <strong><code>app/models.py:</code></strong>      mixin. </blockquote><br><pre> <code class="plaintext hljs">class PaginatedAPIMixin(object): @staticmethod def to_collection_dict(query, page, per_page, endpoint, **kwargs): resources = query.paginate(page, per_page, False) data = { 'items': [item.to_dict() for item in resources.items], '_meta': { 'page': page, 'per_page': per_page, 'total_pages': resources.pages, 'total_items': resources.total }, '_links': { 'self': url_for(endpoint, page=page, per_page=per_page, **kwargs), 'next': url_for(endpoint, page=page + 1, per_page=per_page, **kwargs) if resources.has_next else None, 'prev': url_for(endpoint, page=page - 1, per_page=per_page, **kwargs) if resources.has_prev else None } } return data</code> </pre> <br><p>  <code>to_collection_dict()</code>      ,   <code>items</code> , <code>_meta</code>  <code>_links</code> .       ,  ,   .   -  Flask-SQLAlchemy,     .   ,    .    <code>paginate()</code>  ,     ,       ,     -. </p><br><p>      ,            .       ,    , ,  <code>url_for ('api.get_users', id = id, page = page)</code>    .   <code>url_for()</code>      ,             ,    <code>url_for()</code> .       ,          <code>kwargs</code>    <code>url_for()</code> .    <code>page</code>  <code>per_page</code>  ,          API. </p><br><p>   mixin      <code>User</code>    : </p><br><blockquote> <strong><code>app/models.py:</code></strong>  PaginatedAPIMixin   . </blockquote><br><pre> <code class="plaintext hljs">class User(PaginatedAPIMixin, UserMixin, db.Model): # ...</code> </pre> <br><p>         ,       ,      . </p><br><h2 id="obrabotka-oshibok">   </h2><br><p>  ,     <a href="https://habrahabr.ru/post/346880/"> 7</a> ,    ,    ,  -.  API   ,    ¬´ ¬ª  , ,      .          API  JSON,           API.   ,    : </p><br><pre> <code class="plaintext hljs">{ "error": "short error description", "message": "error message (optional)" }</code> </pre> <br><p>              HTTP     .        ,     <code>error_response()</code>  <em>app/api/errors.py</em> : </p><br><blockquote> <strong><code>app/api/errors.py:</code></strong>   . </blockquote><br><pre> <code class="plaintext hljs">from flask import jsonify from werkzeug.http import HTTP_STATUS_CODES def error_response(status_code, message=None): payload = {'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')} if message: payload['message'] = message response = jsonify(payload) response.status_code = status_code return response</code> </pre> <br><p>      <code>HTTP_STATUS_CODES</code>  <code>Werkzeug</code> (  Flask),          HTTP.       <code>error</code>    ,             .  <code>jsonify()</code>   <code>Response</code> Flask      200,            . </p><br><p>   ,  API  ,   400,     " ". -,  ,    ,      .      ,      ,         .   <code>bad_request()</code> ,    : </p><br><blockquote> <strong><code>app/api/errors.py:</code></strong>    . </blockquote><br><pre> <code class="plaintext hljs"># ... def bad_request(message): return error_response(400, message)</code> </pre> <br><h2 id="konechnye-tochki-polzovatelskih-resursov">     </h2><br><p> ,         JSON,  ,        API. </p><br><h2 id="poluchenie-polzovatelya">   </h2><br><p>       ,  <code>id</code> : </p><br><blockquote> <strong><code>app/api/users.py:</code></strong>  . </blockquote><br><pre> <code class="plaintext hljs">from flask import jsonify from app.models import User @bp.route('/users/&lt;int:id&gt;', methods=['GET']) def get_user(id): return jsonify(User.query.get_or_404(id).to_dict())</code> </pre> <br><p>  view          URL-.  <code>get_or_404()</code>        <code>get()</code> ,    ,       ,   ,   ,   <code>None</code> ,  <code>id</code>  ,       404 .  <code>get_or_404()</code>  <code>get()</code>   ,       ,     . </p><br><p>  <code>to_dict()</code> ,     <code>User</code> ,          ,    Flask <code>jsonify()</code>      JSON   . </p><br><p>    ,      API,  ,     URL-    : </p><br><pre> <code class="plaintext hljs">http://localhost:5000/api/users/1</code> </pre> <br><p>      ,    JSON.      <code>id</code> ,  ,   <code>get_or_404()</code>   SQLAlchemy   404 (   ,    ,        JSON). </p><br><p>     ,   <a href="httpie.org/">HTTPie</a> , HTTP-  ,   Python,     API: </p><br><pre> <code class="plaintext hljs">(venv) $ pip install httpie</code> </pre> <br><p>          1 (, ,    )    : </p><br><pre> <code class="plaintext hljs">(venv) $ http GET http://localhost:5000/api/users/1 HTTP/1.0 200 OK Content-Length: 457 Content-Type: application/json Date: Mon, 27 Nov 2017 20:19:01 GMT Server: Werkzeug/0.12.2 Python/3.6.3 { "_links": { "avatar": "https://www.gravatar.com/avatar/993c...2724?d=identicon&amp;s=128", "followed": "/api/users/1/followed", "followers": "/api/users/1/followers", "self": "/api/users/1" }, "about_me": "Hello! I'm the author of the Flask Mega-Tutorial.", "followed_count": 0, "follower_count": 1, "id": 1, "last_seen": "2017-11-26T07:40:52.942865Z", "post_count": 10, "username": "miguel" }</code> </pre> <br><h2 id="poluchenie-kollekciy-polzovateley">    </h2><br><p>     ,       <code>to_collection_dict()</code> PaginatedAPIMixin: </p><br><blockquote> app/api/users.py:    . </blockquote><br><pre> <code class="plaintext hljs">from flask import request @bp.route('/users', methods=['GET']) def get_users(): page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) data = User.to_collection_dict(User.query, page, per_page, 'api.get_users') return jsonify(data)</code> </pre> <br><p>       <code>page</code>  <code>per_page</code>   ,     1  10 ,    . <code>per_page</code>   ,    100.             ,          .  <code>page</code>  <code>per_page</code>    <code>to_collection_query()</code>   ,       <code>User.query</code> -  ,   .  - <code>api.get_users</code> ,    ,            . </p><br><p>        HTTPie,   : </p><br><pre> <code class="plaintext hljs">(venv) $ http GET http://localhost:5000/api/users The next two endpoints are the ones that return the follower and followed users. These are fairly similar to the one above: app/api/users.py: Return followers and followed users. @bp.route('/users/&lt;int:id&gt;/followers', methods=['GET']) def get_followers(id): user = User.query.get_or_404(id) page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) data = User.to_collection_dict(user.followers, page, per_page, 'api.get_followers', id=id) return jsonify(data) @bp.route('/users/&lt;int:id&gt;/followed', methods=['GET']) def get_followed(id): user = User.query.get_or_404(id) page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) data = User.to_collection_dict(user.followed, page, per_page, 'api.get_followed', id=id) return jsonify(data)</code> </pre> <br><p>       ,      <code>id</code> .        ,     <code>user.followers</code>  <code>user.followed</code>      <code>to_collection_dict()</code> ,  , ,    ,             .    <code>to_collection_dict()</code> ‚Äî      ,            <code>kwargs</code> ,      <code>url_for()</code>     . </p><br><p>     ,        HTTPie  : </p><br><pre> <code class="plaintext hljs">(venv) $ http GET http://localhost:5000/api/users/1/followers (venv) $ http GET http://localhost:5000/api/users/1/followed</code> </pre> <br><p>   ,   hypermedia      URL-,      <code>_links</code>  . </p><br><h2 id="registraciya-novyh-polzovateley">    </h2><br><p>  <code>POST</code>   /users        .       : </p><br><blockquote> <strong><code>app/api/users.py:</code></strong>   . </blockquote><br><pre> <code class="plaintext hljs">from flask import url_for from app import db from app.api.errors import bad_request @bp.route('/users', methods=['POST']) def create_user(): data = request.get_json() or {} if 'username' not in data or 'email' not in data or 'password' not in data: return bad_request('must include username, email and password fields') if User.query.filter_by(username=data['username']).first(): return bad_request('please use a different username') if User.query.filter_by(email=data['email']).first(): return bad_request('please use a different email address') user = User() user.from_dict(data, new_user=True) db.session.add(user) db.session.commit() response = jsonify(user.to_dict()) response.status_code = 201 response.headers['Location'] = url_for('api.get_user', id=user.id) return response</code> </pre> <br><p>         JSON  ,    . Flask   <code>request.get_json()</code> ,   JSON         Python.    <code>None</code> ,   JSON    ,    ,     ,   <code>request.get_json()</code>  <code>{}</code> . </p><br><p>      ,   ,      ,      ,     .  <code>username</code> , <code>email</code>  <code>password</code> .  -   ,      <code>bad_request()</code>  <em>app/api/errors.py</em>    .        ,   <code>username</code>  <code>email</code>     ,                ,   -     ,      . </p><br><p>  ,     ,            .       <code>from_dict()</code>   .  <code>new_user</code>   <code>True</code> ,      <code>password</code> ,       . </p><br><p> ,      ,    ,  <code>to_dict()</code>    .     <code>POST</code> ,   ,   <code>201</code> ,  ,      .  ,   HTTP ,   <code>201</code>   Location,   URL-  . </p><br><p>    ,         HTTPie: </p><br><pre> <code class="plaintext hljs">(venv) $ http POST http://localhost:5000/api/users username=alice password=dog \ email=alice@example.com "about_me=Hello, my name is Alice!"</code> </pre> <br><h2 id="redaktirovanie-polzovateley">   </h2><br><p>   ,       API, ‚Äî  ,    : </p><br><blockquote> <strong><code>app/api/users.py:</code></strong>  . </blockquote><br><pre> <code class="plaintext hljs">@bp.route('/users/&lt;int:id&gt;', methods=['PUT']) def update_user(id): user = User.query.get_or_404(id) data = request.get_json() or {} if 'username' in data and data['username'] != user.username and \ User.query.filter_by(username=data['username']).first(): return bad_request('please use a different username') if 'email' in data and data['email'] != user.email and \ User.query.filter_by(email=data['email']).first(): return bad_request('please use a different email address') user.from_dict(data, new_user=False) db.session.commit() return jsonify(user.to_dict())</code> </pre> <br><p>      <code>id</code>     URL,          <code>404</code> ,    .       ,   ,   <code>username</code>  <code>email</code> ,  ,     ,      ,       .  ,       ,    ,   .     ,         , ,    ,       ,   ,     .  -     ,     <code>400</code> ,   . </p><br><p>        <code>From_dict()</code>      ,  ,       .               <code>200</code> . </p><br><p>   ,    <code>about_me</code>  HTTPie: </p><br><pre> <code class="plaintext hljs">(venv) $ http PUT http://localhost:5000/api/users/2 "about_me=Hi, I am Miguel"</code> </pre> <br><h2 id="api-autentifikaciya"> API  </h2><br><p>   API,      ,       . ,        ,       <em></em>  <em></em> ,  ¬´AuthN¬ª  ¬´AuthZ¬ª  .    ,  ,  ,   ,    ,    ,   ,        . </p><br><p>        API    <code>@login_required</code>  Flask-Login,       .      ,     HTML    .  API    HTML    ,          ,     ,    401.    ,   API  -                 HTML.  API     401,  ,        ,    ,       . </p><br><h2 id="markerytokeny-v-polzovatelskoy-modeli"> ()    </h2><br><p>    API       .       API,     ,      .      API,     ,   ,   .         .         <code>User</code> : </p><br><blockquote> <strong><code>app/models.py:</code></strong>   . </blockquote><br><pre> <code class="plaintext hljs">import base64 from datetime import datetime, timedelta import os class User(UserMixin, PaginatedAPIMixin, db.Model): # ... token = db.Column(db.String(32), index=True, unique=True) token_expiration = db.Column(db.DateTime) # ... def get_token(self, expires_in=3600): now = datetime.utcnow() if self.token and self.token_expiration &gt; now + timedelta(seconds=60): return self.token self.token = base64.b64encode(os.urandom(24)).decode('utf-8') self.token_expiration = now + timedelta(seconds=expires_in) db.session.add(self) return self.token def revoke_token(self): self.token_expiration = datetime.utcnow() - timedelta(seconds=1) @staticmethod def check_token(token): user = User.query.filter_by(token=token).first() if user is None or user.token_expiration &lt; datetime.utcnow(): return None return user</code> </pre> <br><p>       <code>token</code>   ,          ,      .    <code>token_expiration</code> ,          .    ,          ,     . </p><br><p>        .  <code>get_token()</code>    .     ,   base64,        .       ,             ,       . </p><br><p>           ,         .      ,     .  <code>revoke_token()</code>  ,  , ,            . </p><br><p>  <code>check_token()</code>   ,          ,       .     ,   None. </p><br><p>       ,       ,    : </p><br><pre> <code class="plaintext hljs">(venv) $ flask db migrate -m "user tokens" (venv) $ flask db upgrade</code> </pre> <br><h2 id="zaprosy-markerovtokenov">  () </h2><br><p>    API,   ,       -,   -.   API ,   ,                .          API,     ,        -. </p><br><p>           ,     Flask   <a href="httpauth.readthedocs.io/">Flask-HTTPAuth</a> . Flask-HTTPAuth   pip: </p><br><pre> <code class="plaintext hljs">(venv) $ pip install flask-httpauth</code> </pre> <br><p> Flask-HTTPAuth     ,  API .      <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic Authentication</a>  <a href="http://lib.ru/WEBMASTER/rfc2068/section-11.html"> 11.1</a> ,           http .    Flask-HTTPAuth     : ,         ,  ,  ,         .     Flask-HTTPAuth  ,             .    : </p><br><blockquote> <strong><code>app/api/auth.py:</code></strong>    . </blockquote><br><pre> <code class="plaintext hljs">from flask import g from flask_httpauth import HTTPBasicAuth from app.models import User from app.api.errors import error_response basic_auth = HTTPBasicAuth() @basic_auth.verify_password def verify_password(username, password): user = User.query.filter_by(username=username).first() if user is None: return False g.current_user = user return user.check_password(password) @basic_auth.error_handler def basic_auth_error(): return error_response(401)</code> </pre> <br><p>  <code>HTTPBasicAuth</code>  Flask-HTTPAuth- ,     .        <code>verify_password</code>  <code>error_handler</code> . </p><br><p>       ,  ,   <code>True</code> ,    ,  <code>False</code> ,  .        <code>check_password()</code>  <code>User</code> ,    Flask-Login    -.      <code>g.current_user</code> ,            API. </p><br><p>       401,   <code>error_response()</code>  <em>app/api/errors.py</em> .  401    HTTP  "Unauthorized"  (" ").  HTTP ,                . </p><br><p>       ,       ,    ,      : </p><br><blockquote> <strong><code>app/api/tokens.py:</code></strong> Generate user tokens. </blockquote><br><pre> <code class="plaintext hljs">from flask import jsonify, g from app import db from app.api import bp from app.api.auth import basic_auth @bp.route('/tokens', methods=['POST']) @basic_auth.login_required def get_token(): token = g.current_user.get_token() db.session.commit() return jsonify({'token': token})</code> </pre> <br><p>      <code>@basic_auth.login_required</code>   HTTPBasicAuth,    Flask-HTTPAuth    (      )      ,      .        <code>get_token()</code>     .       ,  ,            . </p><br><p>     POST   API   : </p><br><pre> <code class="plaintext hljs">(venv) $ http POST http://localhost:5000/api/tokens HTTP/1.0 401 UNAUTHORIZED Content-Length: 30 Content-Type: application/json Date: Mon, 27 Nov 2017 20:01:00 GMT Server: Werkzeug/0.12.2 Python/3.6.3 WWW-Authenticate: Basic realm="Authentication Required" { "error": "Unauthorized" }</code> </pre> <br><p>  HTTP      401   ,       <code>basic_auth_error()</code> .    ,       : </p><br><pre> <code class="plaintext hljs">(venv) $ http --auth &lt;username&gt;:&lt;password&gt; POST http://localhost:5000/api/tokens HTTP/1.0 200 OK Content-Length: 50 Content-Type: application/json Date: Mon, 27 Nov 2017 20:01:22 GMT Server: Werkzeug/0.12.2 Python/3.6.3 { "token": "pC1Nu9wwyNt8VCj1trWilFdFI276AcbS" }</code> </pre> <br><p>    200,      ,         .  ,        <code>&lt;username&gt;:&lt;password&gt;</code>   .           . </p><br><h2 id="zaschita-marshrutov-api-s-pomoschyu-tokenov">   API    </h2><br><p>           API,         .  ,  Flask-HTTPAuth     .           <code>HTTPTokenAuth</code>      : </p><br><blockquote> <strong><code>app/api/auth.py:</code></strong>   Token. </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_httpauth import HTTPTokenAuth # ... token_auth = HTTPTokenAuth() # ... @token_auth.verify_token def verify_token(token): g.current_user = User.check_token(token) if token else None return g.current_user is not None @token_auth.error_handler def token_auth_error(): return error_response(401)</code> </pre> <br><p>      Flask-HTTPAuth   <code>verify_token</code> ,        ,    .     <code>User.check_token()</code> ,   ,    .      ,     <code>None</code> .   <code>True</code>  <code>False</code> ,   Flask-HTTPAuth      . </p><br><p>    API   ,    <code>@token_auth.login_required</code> : </p><br><blockquote> <strong><code>app/api/users.py:</code></strong> Protect user routes with token authentication. </blockquote><br><pre> <code class="plaintext hljs">from app.api.auth import token_auth @bp.route('/users/&lt;int:id&gt;', methods=['GET']) @token_auth.login_required def get_user(id): # ... @bp.route('/users', methods=['GET']) @token_auth.login_required def get_users(): # ... @bp.route('/users/&lt;int:id&gt;/followers', methods=['GET']) @token_auth.login_required def get_followers(id): # ... @bp.route('/users/&lt;int:id&gt;/followed', methods=['GET']) @token_auth.login_required def get_followed(id): # ... @bp.route('/users', methods=['POST']) def create_user(): # ... @bp.route('/users/&lt;int:id&gt;', methods=['PUT']) @token_auth.login_required def update_user(id): # ...</code> </pre> <br><p>  ,        API,  <code>create_user()</code> ,     ,   ,   ,    . </p><br><p>          ,   ,      401.   ,     <code>Authorization</code>  ,       <em>/api/tokens</em> . Flask-HTTPAuth ,      -,     HTTPie.         HTTPie   <code>--auth</code> ,        .     -: </p><br><pre> <code class="plaintext hljs">(venv) $ http GET http://localhost:5000/api/users/1 \ "Authorization:Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"</code> </pre> <br><h2 id="otmena-tokenov">   </h2><br><p>  ,   ,    , ‚Äî   ,     : </p><br><blockquote> <strong><code>app/api/tokens.py:</code></strong> Revoke tokens. </blockquote><br><pre> <code class="plaintext hljs">from app.api.auth import token_auth @bp.route('/tokens', methods=['DELETE']) @token_auth.login_required def revoke_token(): g.current_user.revoke_token() db.session.commit() return '', 204</code> </pre> <br><p>     <code>DELETE</code>    URL- <em>/tokens</em> ,   .        ,    ,    <code>Authorization</code> ,  .        <code>User</code> ,       .      ,       .       ,      .     return     204,     ,    . </p><br><p>      ,   HTTPie: </p><br><pre> <code class="plaintext hljs">(venv) $ http DELETE http://localhost:5000/api/tokens \ Authorization:"Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"</code> </pre> <br><h2 id="soobscheniya-ob-oshibkah-api">    API </h2><br><p>  ,      ,       API     URL- ?    404,          404 HTML.  ,     API,     JSON    API,    ,  Flask,  -    ,    ,     HTML. </p><br><p>  HTTP  ,           ,   .     <code>Accept</code>  ,   .       ,   ,     ,  . </p><br><p>       ,         HTML  JSON     .       Flask <code>request.accept_mimetypes</code> : </p><br><blockquote> <strong><code>app/errors/handlers.py:</code></strong>      . </blockquote><br><pre> <code class="plaintext hljs">from flask import render_template, request from app import db from app.errors import bp from app.api.errors import error_response as api_error_response def wants_json_response(): return request.accept_mimetypes['application/json'] &gt;= \ request.accept_mimetypes['text/html'] @bp.app_errorhandler(404) def not_found_error(error): if wants_json_response(): return api_error_response(404) return render_template('errors/404.html'), 404 @bp.app_errorhandler(500) def internal_error(error): db.session.rollback() if wants_json_response(): return api_error_response(500) return render_template('errors/500.html'), 500</code> </pre> <br><p>   <code>wants_json_response()</code>    JSON  HTML,      .   JSON ,  HTML,     JSON.       HTML-   .   JSON      <code>error_response</code>    API,        <code>api_error_response()</code> ,   ,     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358152/">https://habr.com/ru/post/358152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358142/index.html">What is the difference Smoke, Sanity, Regression, Re-test and how to distinguish them?</a></li>
<li><a href="../358144/index.html">We invite you on May 26 to Unreal Engine Meetup # 3</a></li>
<li><a href="../358146/index.html">Image Processing: Tensorflow Object Detection API</a></li>
<li><a href="../358148/index.html">From right to left. What is dir = rtl and how to tame Arabic</a></li>
<li><a href="../358150/index.html">Roskomnadzor: Telegram lock affects 400 resources</a></li>
<li><a href="../358154/index.html">We brought this day as we could - a notepad in Windows 10 began to understand the unix line feed</a></li>
<li><a href="../358158/index.html">SAS BASE procedures with direct control of the number of processor cores</a></li>
<li><a href="../358160/index.html">In Russia, they want to introduce fines for downloading pirated content</a></li>
<li><a href="../358162/index.html">They want to register in social networks using a passport, but children shouldn‚Äôt be allowed at all</a></li>
<li><a href="../358164/index.html">State Duma proposes to penalize those who refuse to decipher their traffic. Update: amendments accepted</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>