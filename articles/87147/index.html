<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How FriendFeed uses MySQL to store data without a schema</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conditions 
 We use MySQL to store any FriendFeed data. Our database grows with the number of users. Now we have more than 250 million records, these ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How FriendFeed uses MySQL to store data without a schema</h1><div class="post__text post__text-html js-mediator-article"><h4>  Conditions </h4><br>  We use MySQL to store any <a href="http://friendfeed.com/">FriendFeed</a> data.  Our database grows with the number of users.  Now we have more than 250 million records, these are user records (post'y), comments, ratings ("likes") <br><br>  As the database grew, we occasionally dealt with scalability issues.  We solved problems in standard ways: read-only slave servers, memcache to increase read throughput and partitioning to increase write throughput.  However, as it grows, the scalability methods used have made it difficult to add new functionality. <br><br>  In particular, changing the database schema or adding indexes to the existing 10-20 million records resulted in a complete blocking of the server for several hours.  Deleting old indexes took time, and not deleting hit performance, as the database continued to use them on each INSERT.  There are complex procedures that can be used to circumvent these problems (for example, creating a new index on the slave server, and then swapping master and slave places), but these procedures are so difficult and dangerous that they completely deprived us of the desire to add something new. requiring a schema or index change.  And since our databases are highly distributed, MySQL relational things like JOIN never worked for us.  Then we decided to look for a solution to the problems that lies outside the relational databases. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are many projects designed to solve the problem of storing data with a flexible scheme and building indexes on the fly (for example, <a href="http://couchdb.apache.org/">CouchDB</a> ).  However, apparently none of them are used by large sites.  In the tests about which we read and chased ourselves, none of the projects proved to be stable, mature enough for our purposes (see <a href="http://userprimary.net/user/2007/12/16/a-quick-look-at-couchdb-performance/">this article outdated on CouchDB</a> , for example).  And all this time, MySQL worked.  He did not spoil the data.  Replication worked.  We already sufficiently understood all his bottlenecks.  We liked MySQL exactly as a repository, outside relational templates. <br><br>  Having weighed everything, we decided to create a storage system without a schema over MySQL, instead of using a completely new solution.  In this article I will try to describe the main details of the system.  We are also curious how other sites solved these problems.  Well, we think that our work will be useful to other developers. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Our database stores data without a schema as a set of fields (for example, JSON objects or dictionary (dictionary) in Python).  The only required field is the id, a 16-byte UUID.  The rest should not be important for our repository, it is for this that it is created.  We "change" the scheme by simply adding new fields. <br><br>  We will index the data records and save the index in a separate MySQL table.  If we want to index 3 fields of each record, we will get 3 MySQL tables - one for each index.  If we no longer need an index, we stop writing to the index table, and we can delete the table if desired.  If a new index is required, we create a new MySQL table for it and start an asynchronous process to populate the index without interrupting the rest of the tasks. <br><br>  As a result, we get more tables than before, but adding and removing indexes is easier.  We have seriously optimized the process for populating indexes (which we called ‚ÄúThe Cleaner‚Äù) so that it creates indexes quickly without disrupting the site.  Now we can add new properties and index for days, not weeks.  Also now no master exchange for slave or other dangerous operations is required. <br><br><h4>  Details </h4><br>  In MySQL, our records are stored as follows: <br><blockquote><code><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> <font color="black">Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> <ol> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5917/s"></a> <a href="http://s-c.me/5917/h"></a> Copy Source | Copy HTML <font color="#0000ff">CREATE TABLE</font> entities ( added_id <font color="#0000ff">INT NOT NULL</font> AUTO_INCREMENT <font color="#0000ff">PRIMARY KEY</font> , id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , updated <font color="#0000ff">TIMESTAMP NOT NULL</font> , body MEDIUMBLOB, <font color="#0000ff">UNIQUE KEY</font> (id), <font color="#0000ff">KEY</font> (updated) ) ENGINE=InnoDB;</font></code> </li> </ol></blockquote><br>  The added_id column is needed because InnoDB physically stores data in the order of the primary key.  AUTO_INCREMENT keys ensure that new records are written to the hard disk after the old ones, which helps both reading and writing (access to new records usually occurs more often than old records, so FriendFeed pages are sorted in reverse chronological order).  The body of the record is stored as a compressed (zlib) Python- <a href="http://docs.python.org/library/pickle.html">pickled</a> dictionary. <br><br>  Indexes are stored in separate tables.  For the new index, we create a table with the attributes by which we want to search.  For example, writing to FriendFeed looks like this: <br><blockquote> <code><a href="http://s-c.me/5918/s"></a> <a href="http://s-c.me/5918/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  { </li><li>  <font color="#A31515">"id"</font> : <font color="#A31515">"71f0c4d2291844cca2df6f486e96e37c"</font> , </li><li>  <font color="#A31515">"user_id"</font> : <font color="#A31515">"f48b0440ca0c4f66991c4d5f6a078eaf"</font> , </li><li>  <font color="#A31515">"feed_id"</font> : <font color="#A31515">"f48b0440ca0c4f66991c4d5f6a078eaf"</font> , </li><li>  <font color="#A31515">"title"</font> : <font color="#A31515">"We just launched a new backend system for FriendFeed!"</font>  , </li><li>  <font color="#A31515">"link"</font> : <font color="#A31515">"http://friendfeed.com/e/71f0c4d2-2918-44cc-a2df-6f486e96e37c"</font> , </li><li>  <font color="#A31515">"published"</font> : <font color="#A31515">1235697046</font> , </li><li>  <font color="#A31515">"updated"</font> : <font color="#A31515">1235697046</font> , </li><li>  } </li></ol></blockquote><br>  We want to index by user_id field to display all the records that the user has done.  Our index table looks like this: <br><blockquote> <code><a href="http://s-c.me/5919/s"></a> <a href="http://s-c.me/5919/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">CREATE TABLE</font> index_user_id ( </li><li>  user_id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL</font> , </li><li>  entity_id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL UNIQUE</font> , </li><li>  <font color="#0000ff">PRIMARY KEY</font> (user_id, entity_id) </li><li>  ) ENGINE = InnoDB; </li></ol></blockquote><br>  Our library automatically creates indexes.  To start our repository, which saves such records with the index described above, we write (in Python): <br><blockquote> <code><a href="http://s-c.me/5920/s"></a> <a href="http://s-c.me/5920/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  user_id_index = friendfeed.datastore.Index ( </li><li>  table = <font color="#008000">"index_user_id"</font> , properties = [ <font color="#008000">"user_id"</font> ], shard_on = <font color="#008000">"user_id"</font> ) </li><li></li><li>  datastore = friendfeed.datastore.DataStore ( </li><li>  mysql_shards = [ <font color="#008000">"127.0.0.1</font>Â§©306 <font color="#008000">"</font> , <font color="#008000">"127.0.0.1:330307"</font> ], </li><li>  indexes = [user_id_index]) </li><li></li><li>  new_entity = { </li><li>  <font color="#008000">"id"</font> : <b>binascii</b> .a2b_hex ( <font color="#008000">"71f0c4d2291844cca2df6f486e96e37c"</font> ), </li><li>  <font color="#008000">"user_id"</font> : <b>binascii</b> .a2b_hex ( <font color="#008000">"f48b0440ca0c4f66991c4d5f6a078eaf"</font> ), </li><li>  <font color="#008000">"feed_id"</font> : <b>binascii</b> .a2b_hex ( <font color="#008000">"f48b0440ca0c4f66991c4d5f6a078eaf"</font> ), </li><li>  <font color="#008000">"title"</font> : u <font color="#008000">"We just launched a new backend system for FriendFeed!"</font>  , </li><li>  <font color="#008000">"link"</font> : u <font color="#008000">"http://friendfeed.com/e/71f0c4d2-2918-44cc-a2df-6f486e96e37c"</font> , </li><li>  <font color="#008000">"published"</font> : <font color="#008000">1235697046</font> , </li><li>  <font color="#008000">"updated"</font> : <font color="#008000">1235697046</font> , </li><li>  } </li><li></li><li>  datastore.put (new_entity) </li><li></li><li>  entity = datastore.get ( <b>binascii</b> .a2b_hex ( <font color="#008000">"71f0c4d2291844cca2df6f486e96e37c"</font> )) </li><li>  entity = user_id_index.get_all (datastore, user_id = <b>binascii</b> .a2b_hex ( <font color="#008000">"f48b0440ca0c4f66991c4d5f6a078eaf"</font> )) </li><li></li></ol></blockquote><br>  The index class looks at the user_id field in all records and automatically creates an index in the index_user_id table.  Since our database is partitioned (sharding), the shard_on argument is used to determine which segment the index will be stored in (in our case, entity ["user_id"]% num_shards) <br><br>  To execute a query using the created index, an Index class object is used (see user_id_index.get_all).  The ‚Äúrepository‚Äù algorithm makes the ‚Äújoin‚Äù of the index_user_id tables and tables with records, first going over all the index_user_id tables on all database segments to get a list of record IDs and then retrieves these records from the entities table. <br><br>  To create a new index, for example, using the link attribute, we will create a table: <br><blockquote> <code><a href="http://s-c.me/5921/s"></a> <a href="http://s-c.me/5921/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">CREATE TABLE</font> index_link ( </li><li>  link <font color="#0000ff">VARCHAR</font> (735) <font color="#0000ff">NOT NULL</font> , </li><li>  entity_id <font color="#0000ff">BINARY</font> (16) <font color="#0000ff">NOT NULL UNIQUE</font> , </li><li>  <font color="#0000ff">PRIMARY KEY</font> (link, entity_id) </li><li>  ) ENGINE = InnoDB <font color="#0000ff">DEFAULT</font> CHARSET = utf8; </li></ol></blockquote><br>  The inclusion code for the new index will be: <br><blockquote> <code><a href="http://s-c.me/5922/s"></a> <a href="http://s-c.me/5922/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  user_id_index = friendfeed.datastore.Index ( </li><li>  table = <font color="#008000">"index_user_id"</font> , properties = [ <font color="#008000">"user_id"</font> ], shard_on = <font color="#008000">"user_id"</font> ) </li><li>  link_index = friendfeed.datastore.Index ( </li><li>  table = <font color="#008000">"index_link"</font> , properties = [ <font color="#008000">"link"</font> ], shard_on = <font color="#008000">"link"</font> ) </li><li>  datastore = friendfeed.datastore.DataStore ( </li><li>  mysql_shards = [ <font color="#008000">"127.0.0.1</font>Â§©306 <font color="#008000">"</font> , <font color="#008000">"127.0.0.1:330307"</font> ], </li><li>  indexes = [user_id_index, link_index]) </li></ol></blockquote><br>  We can also fill the index asynchronously (even during real work) using the process: <br><br>  ./rundatastorecleaner.py --index = index_link <br><br><h4>  Consistency and atomicity </h4><br>  Due to the fact that the database is segmented, the index for a particular record may be on different segments.  What happens if the process ends unexpectedly before it writes down all the indexes on the tables? <br><br>  The most ambitious FriendFeed engineers thought that transactions were necessary in this situation.  However, we wanted to keep our system as simple as possible.  We decided to relax the restrictions: <br><ul><li>  The attribute set stored in the main record table is canonical. </li><li>  Index may return inappropriate entries. </li></ul><br>  As a result, we create a new entry in the following order: <br><ol><li>  We save the record to the main table, using the InnoDB ACID guarantees (Atomicity, Consistency, Isolation, Durability). </li><li>  Save indexes to all index tables on all segments. </li></ol><br>  When we read from the index tables, we know that the result may be inaccurate (that is, the result may contain unnecessary objects if the recording was not completed in step 2).  To make sure that we return the correct records, we re-filter the result obtained from the table index: <br><ol><li>  Read entity_id from all index tables participating in the query. </li><li>  We read all records by received id </li><li>  We filter (in Python) all records that do not match the query criteria. </li></ol><br>  To fix the indexes, the ‚ÄúCleaner‚Äù process (cleaner) was created, which was mentioned earlier.  It runs on the table of records, recording the missing indexes, deleting old ones and correcting the wrong ones.  He starts with new records, in practice, all inaccuracies are corrected very quickly (within a few seconds). <br><br><h4>  Performance </h4><br>  We have slightly optimized our primary keys in the new system and are happy with the result.  Below is a chart of delays before returning the FriendFeed page for the last month (we launched a new backend a few days ago): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/453/ce2/4e2/453ce24e2aafc0819cfdf5c4bdcc3e69.png"><br><br>  In particular, the latency of our system is stable, even during mid-day peaks.  Below is a chart for the last 24 hours: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/8f3/e19/1518f3e19cf5c0c100c2fa5e93ef71f1.png"><br><br>  Compare with delays a week ago: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/e76/5a2/46ce765a27da094a5a6d45a76cc6c364.png"><br><br>  With the new system it has become much easier to work with.  We have already changed the indexes several times on the working system, and now we are starting to migrate our main tables in order to move on. <br><br>  <i><a href="http://bret.appspot.com/entry/how-friendfeed-uses-mysql">How FriendFeed uses MySQL to store schema-less data</a> , by Bret Taylor ‚Ä¢ February 27, 2009</i> <i><br></i>  <i>I also recommend reading the <a href="http://www.mysqlperformanceblog.com/2010/01/21/when-should-you-store-serialized-objects-in-the-database/">discussion of this article</a> on the popular <a href="http://www.mysqlperformanceblog.com/">mysqlperformanceblog.com</a></i> </div><p>Source: <a href="https://habr.com/ru/post/87147/">https://habr.com/ru/post/87147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../87136/index.html">Phone selection: freedom and reality</a></li>
<li><a href="../87140/index.html">Spying on employees through accelerometers</a></li>
<li><a href="../87142/index.html">And to perists and javistams - RUP and SCRUM, RUP and SCRUM. :)</a></li>
<li><a href="../87144/index.html">Using DynDNS for reliable website mirroring</a></li>
<li><a href="../87145/index.html">HDD evolution will hit Windows XP</a></li>
<li><a href="../87149/index.html">We control the computer from iphone</a></li>
<li><a href="../87153/index.html">Ribbon Development ("Why" Interface, parts 4 through 8)</a></li>
<li><a href="../87155/index.html">Computer Management with iPhone</a></li>
<li><a href="../87156/index.html">Nokia has closed for Ukraine the purchase of applications in OVI</a></li>
<li><a href="../87159/index.html">Parking.ru - we increase reliability. Start Cluster for Hyper-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>