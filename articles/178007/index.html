<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study the debugger, part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think you know that software is not cracked by some kind of mystical ‚Äúhackers‚Äù - it is implemented by the same programmers as most people who read t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study the debugger, part one</h1><div class="post__text post__text-html js-mediator-article">  I think you know that software is not cracked by some kind of mystical ‚Äúhackers‚Äù - it is implemented by the same programmers as most people who read this article.  At the same time, they use the same tools as the software developers themselves.  Of course, with reservations, since for the most part the toolkit is quite specific, but, one way or another, a debugger is used in software analysis. <br><br>  Since most of my articles are focused on people interested in applying protection in their software, I decided that submitting material with specific pieces of protection code (like those previously published) will only confuse the reader.  It is much easier to start from the basics and slowly give new material on the already prepared base. <br><br>  Therefore, this article will be considered one of the basic tools of the programmer - debugger. <br>  Objectives of the article: consider the basic methods of working with the debugger, show its advanced and rarely used features, give an insight into the operation of the debugger mechanisms with examples and consider a certain set of countermeasures. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The volume of the article turned out unexpectedly large, so I divided it into three parts: <br><br><ul><li>  In the first part, the possibilities of the debugger integrated into IDE Delphi will be considered, recommendations on its optimal use and general tips on environment configuration are given.  The material in this section is intended for both novice developers and more trained professionals. </li><li>  <a href="http://habrahabr.ru/post/178159/">In the second part of the article,</a> the reverse side of the debugger will be examined using the example of its source code, the mechanisms used by it for debugging the application are described in detail, and the options for modifying the application memory made by the debugger during operation are shown. </li><li>  <a href="http://habrahabr.ru/post/178183/">The third part of the article</a> will discuss the practical use of a debugger by the example of circumventing the protection of an application using a certain set of anti-debugging tricks. </li></ul><br>  Actually, let's get started. <br><a name="habracut"></a><br><br><h4>  1.1.  Applying breakpoints and modifying local variables </h4><br>  One of the most commonly used tools of the integrated debugger is a breakpoint (BreakPoint - hereafter BP).  After installing BP, the program will work until it reaches a stopping point, after which its work will be interrupted and control will be transferred to the debugger. <br><br>  The easiest way to install and remove BP is the F5 hot key (or its equivalent in the Debug-&gt; Toggle breakpoint menu).  There are other ways, but about them later. <br><br>  After the program is stopped, we can examine the values ‚Äã‚Äãof the local variables of the procedure in which the execution of the application was stopped, as well as analyze the stack of calls preceding the call of this procedure.  Here we can change the values ‚Äã‚Äãof these variables. <br><br>  Where to put BP - of course there is no general answer.  In fact, BP is designed to facilitate the study of the operation of the code, the correctness of which we are not sure of, or explicitly containing an error, which we cannot immediately detect. <br><br>  It is much easier to set a stopping point and consistently execute each line of code than to spend hours studying the same code, trying to figure out where it started to work in a different way than we intended. <br><br>  Let's consider the following example. <br><br>  There is a task: to write code that will increase the value of the initially numbered variable by one 5 times and one more time by the number 123, after which it will display the result as a 10-bit and hexadecimal value.  Expected values ‚Äã‚Äãwill be as follows: 128 and 00000080. <br><br>  Let's say the code will be written with an error: <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> B: Integer = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(A); Inc(A); Inc(A, B); Inc(A); Inc(A); Inc(A); ShowMessage(IntToStr(A)); ShowMessage(IntToHex(A, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  This code will output any values, but not the ones we wanted, because we did not initialize the variable ‚ÄúA‚Äù to zero.  And since the variable "A" is local, it means that it is located on the stack, and we can never predict what value it will take at the beginning of this procedure.  But we will assume that it is already the end of the working day, we are really tired (our eyes are blurred) and just forgot to write a line with variable initialization. <br><br>  As a result, we have code that displays incorrect values, and we want to quickly understand the reason for this behavior.  We put BP in the procedure body and run the program for execution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/243/931/7c3243931f68122538461c4794d5cbe0.png" alt="image"><br><br>  It should look something like the picture.  BP is set to Inc (A).  At the bottom left you can observe the value of all local variables of the FormCreate procedure (the window is called ‚ÄúLocal Variables‚Äù), namely, the Self variable (it is implicitly transmitted and always present in the class methods), the Sender parameter, and the local A variable itself.  Its value is 19079581. On the left in the center in ‚ÄúWatchList‚Äù the value of the variable ‚ÄúB‚Äù. <br><br>  Even a quick glance at the values ‚Äã‚Äãof both variables and the three lines of code executed, we can understand that the value of the variable ‚ÄúA‚Äù does not correspond to the expected one.  Since there had to be two increments per unit and another increase of 123, we had to see the value of the variable ‚ÄúA‚Äù, the number 125, and if there was a different value, it could mean only one thing - the initial value of the variable ‚ÄúA‚Äù was not true to. <br><br>  To check the correctness of our assumption, let's change the current value of the variable ‚ÄúA‚Äù to the correct one and continue the program execution to check whether those results will return the procedure that was expected. <br><br>  To change the values ‚Äã‚Äãof variables in the debugger there are two tools. <br><br>  The first one is ‚ÄúEvaluate / Modify‚Äù, it is called either via the menu or by pressing the ‚ÄúCtrl + F7‚Äù hot key.  This is a very simple tool with a minimum of functionality, it is most often used. <br><br>  Looks like that: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9d/762/f32/f9d762f32e6e753669a44e582d7f83f6.png" alt="image"><br><br>  To change the value of a variable in it, it is enough to specify a new value in the ‚ÄúNew value‚Äù field and press the ‚ÄúEnter‚Äù key or the ‚ÄúModify‚Äù button. <br>  The second tool, Inspect, is also available through the Run menu or directly from the Evaluate / Modify dialog.  This is a more advanced parameter editor, about it a bit later. <br><br>  After changing the value of the variable "A", notice the changes in the list of values ‚Äã‚Äãof local variables: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/5d8/9f0/5085d89f0c7623bdff0c7dd3f99ed690.png" alt="image"><br><br>  The variable "A" took the correct value, and now we can continue the execution of our application by pressing "F9" or through the menu by selecting the "Run" item.  As a result of such intervention using the debugger, the procedure will give us the expected numbers 128 and 00000080, and we can safely correct the procedure code, since we found the cause of the error in it and checked its execution with the correctly set value of the variable "A". <br><br>  Now back to Inspect.  In addition to these two ways to call it, it is also called by double-clicking on a variable in the ‚ÄúLocal Variables‚Äù window, or through the context menu when right-clicking on it, or by pressing the ‚ÄúAlt + F5‚Äù hot key. <br><br>  This is a more ‚Äúadvanced‚Äù property variable editor, but its use is justified when changing the properties of objects.  It is somewhat inconvenient for changing a regular variable, and here‚Äôs why. <br><br>  When you call it, first you will see the following dialog: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/d41/dbf/5d0d41dbf89cd60bbafb14acaf734cf4.png" alt="image"><br><br>  It will contain the description of the variable, its location in memory and its current value, and to change, you will need to press the button with the three-point one more time, after which an additional window will appear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/230/3ff/f85/2303fff856e920f0a094c95740c9d77b.png" alt="image"><br><br>  The extra gestures for such a simple operation as changes in the value of a normal variable are clearly redundant.  But if you use it to change the properties of objects, the picture will change a bit. <br><br>  Through Evaluate / Modify, access to the properties of the object is somewhat hampered by the fact that it does not provide information directly about the object under study.  For example, to get the handle of a form, we‚Äôll have to type the following text in it: ‚Äú(Sender as TForm1) .Canvas.Handle‚Äù - which is somewhat inconvenient, because we can be sealed, and it‚Äôs just banal to forget the name of one or another property. <br><br>  In the case of Inspect, there will be no such problem. <br><br>  For example, let's open the ‚ÄúInspect‚Äù dialog not for the variable ‚ÄúA‚Äù, but for the variable Self (which, as I said earlier, is always implicitly present for all methods of objects). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a6/785/7f7/1a67857f712c5b5dd6ac4e7603ec9321.png" alt="image"><br><br>  As you can see, in this case, we have access to almost all fields of the object, which can be changed as we like, and we will not be confused in the names of properties. <br><br><h4>  1.2.  Trace (step by step debugging) </h4><br>  The essence of tracing is to step through each line of code. <br><br>  Suppose we stopped at a preset BP, we analyzed the code and want to go to the next line.  In principle, we can also put BP on it and run the program.  And for the next, and for those after it. <br>  Practically, exposing the BP on each line of the procedure code, we manually imitate what the debugger can do (in more detail in the second section). <br><br>  <b>And he can do the following:</b> <br><br><ol><li>  ‚ÄúTrace Into‚Äù command (‚ÄúF7‚Äù) - the debugger will execute the code of the current line of code and stop at the next one.  If the current line of code calls any procedure, then the next line will be the first line of the called procedure. </li><li>  The ‚ÄúStep Over‚Äù command (‚ÄúF8‚Äù) is similar to the first command, but the input to the body of the called procedure does not occur. </li><li>  The ‚ÄúTrace to Next Source Line‚Äù command (‚ÄúShift + F7‚Äù) is also a practically complete analogue of the first command, but is used in the ‚ÄúCPU-View‚Äù window (this debug mode is not covered in the article). </li><li>  ‚ÄúRun to Cursor‚Äù command (‚ÄúF4‚Äù) - the debugger will execute the program code up to the line where the cursor is located (with the condition that no other BPs were encountered during execution). </li><li>  ‚ÄúRun Until Return‚Äù command (‚ÄúShift + F8‚Äù) - the debugger will execute the code of the current procedure until it exits.  (Often used as a counter-reception on a randomly pressed ‚ÄúF7‚Äù and also with the condition that no other BPs were encountered during the execution). </li><li>  In older versions of Delphi, the ‚ÄúSet Next Statement‚Äù command is available, with which we can change the course of the program execution by setting any line of code as the current one.  This feature is also available in the code editor where you can drag the arrow pointing to the current active line to a new position. </li></ol><br>  These teams do not require detailed consideration.  Let's stop only on the ‚ÄúTrace Into‚Äù team (‚ÄúF7‚Äù). <br><br>  For example, take the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: TStringList; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> S := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> S.Add(<span class="hljs-string"><span class="hljs-string">'My value'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> S.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  When performing tracing, at the moment when we are on the line S.Add (), we can have two options for the debugger reaction: <br><br><ol><li>  we will go inside the TStringList.Add method, </li><li>  we will not go there. </li></ol><br>  This behavior is due to the settings of your compiler.  The fact is that Delphi ships with two sets of DCUs for system modules.  One with debug information, the second without.  If we have a second module connected, then the ‚ÄúTrace Into‚Äù (‚ÄúF7‚Äù) command in this case will work as ‚ÄúStep Over‚Äù (‚ÄúF8‚Äù).  Switching between modules in the compiler settings is configured: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7b/974/09e/b7b97409e39221e148718b1c075a9e0f.png" alt="image"><br><br>  And the parameter ‚ÄúUse Debug DCUs‚Äù is responsible for this functionality. <br><br><h4>  1.3.  More on compiler settings </h4><br>  The options in the tab with the compiler settings directly affect what code will be generated when building your project.  It is very important not to forget that when changing any of the items in this tab, a complete reassembly of the project (‚ÄúProject&gt; Build‚Äù) is required in order for the changes to take effect.  These settings directly affect the behavior of your code in various situations, as well as the composition of the information available to you when debugging a project. <br><br>  Consider them in more detail: <br><br>  <b>Group "Code generation"</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a00/9ba/be1/a009babe1d7d898c3e4cd5b415a38c7b.png" alt="image"><br><br>  <b>Optimization Parameter</b> <br><br>  This parameter directly affects code optimization: when enabled, the code will be generated in the most optimal way, taking into account both its size and the speed of execution.  This can lead to loss of accessibility (even for reading) to some local variables, because due to the optimization of the code, they can already be removed from memory at the moment when we broke off at BP. <br><br>  As an example, let's take the code from the first chapter and dwell on the same BP, but with optimization turned on. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65e/fb0/0dc/65efb00dcc21ef3fe1d48d327847218c.png" alt="image"><br><br>  As you can see, the values ‚Äã‚Äãof previously available Self and Sender variables are no longer available.  Also, due to the disabled parameter ‚ÄúUse Debug DCUs‚Äù, there was a cardinal change in the ‚ÄúCall Stack‚Äù window, previously filled with more detailed information about the call list. <br>  Moreover, the Inspect tool also refuses to work with the Self object, producing the following error: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f08/fda/d8d/f08fdad8d48b00c2529d3b97fc50918b.png" alt="image"><br><br>  <b>‚ÄúStack Frames‚Äù and ‚ÄúPentiom-safe FDIV‚Äù parameters</b> <br><br>  I‚Äôll skip the description of these parameters - they are not interesting at the debugging stage.  In short: the first will help with the independent analysis of the stack, the second is responsible for the nuances when working with the mathematical coprocessor.  If someone is interested in nuances, then my coordinates for communication in the profile. <br><br>  <b>‚ÄúRecord field alignment‚Äù parameter</b> <br><br>  Global alignment of unpacked records, which can be changed locally within the module by the directive "{$ Align x}" or "{$ A x}" <br><br>  For example, consider the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> a: Int64; b: Byte; c: Integer; d: Byte; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  The size of this record, which we can get through SizeOf (T), will be different for each of the alignment settings: <br><br>  {$ Align 1} = 14 <br>  {$ Align 2} = 16 <br>  {$ Align 4} = 20 <br>  {$ Align 8} = 24 <br><br>  <b>Group "Syntax options"</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c7/01d/32f/8c701d32f5d0d6d85ca32d51f065c7ac.png" alt="image"><br><br>  It's better not to touch anything at all.  For if you try, you can even make it so that the standard VCL refuses to assemble. <br><br>  The only focus on the parameter ‚ÄúComplete boolen eval‚Äù, for periodically, some include it.  It faces an error when executing the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsListDataPresent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TList)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (Value &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Value.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsListDataPresent(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ShowMessage(<span class="hljs-string"><span class="hljs-string">'boo...'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Since, when this setting is turned on, the boolean expression will be checked in its entirety, an error will occur when accessing Value.Count, despite the fact that the first check determined that the Value parameter is nullified.  And if you turn on (for example) the ‚ÄúExtended syntax‚Äù parameter, then this code will not be collected at all by complaining about the undeclared Result variable. <br><br>  <b>Group "Runtime errors"</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/582/3fa/ee1/5823faee144d1b45ff1676a83c655db8.png" alt="image"><br><br>  <b>‚ÄúRange checking‚Äù parameter</b> <br><br>  This is one of the most requested parameters when debugging an application.  He is responsible for checking boundaries when accessing an array of data. <br><br>  In the simplest case, you will get an exception when executing this code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Char = (<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Caption := Caption + A[I]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Here we are just trying to turn to an element of the array, and in principle, with the ‚ÄúRange checking‚Äù option disabled, if we don‚Äôt go beyond the bounds of the allocated memory, this code threatens us only with a kind of incomprehensible line appearing in the form header. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14d/38a/c9b/14d38ac9b216b10fbecfe0686916f1d0.png" alt="image"><br><br>  Which is unpleasant, but uncritical for program execution.  It is much worse if you make a mistake with the block boundaries when attempting to write to it - in this case, the application memory may be destroyed. <br><br>  Consider this example, disable the optimization: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TMyEnum1 = (en1, en2, en3, en4, en5); TMyEnum2 = en1..en3; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: TMyEnum1; HazardVariable: Integer; Buff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [TMyEnum2] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> HazardVariable := <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := Low(I) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> High(I) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Buff[I] := Integer(I); ShowMessage(IntToStr(HazardVariable)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  What do you think, what will the value of the HazardVariable number be after the execution of this code?  No, not 100. It will be equal to 4. Since we made a mistake when choosing the type of iterator and instead of TMyEnum2 we wrote TMyEnum1, we went beyond the range of the array boundaries and got the data on the stack, changing the values ‚Äã‚Äãof local variables stored on it. <br><br>  With optimization turned on, the situation will be even worse.  We will get the following error: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/162/be7/fad162be7ced9e7dfec31d76125fe123.png" alt="image"><br><br>  According to this description, we can‚Äôt even guess where exactly the exception occurred, and why it happened, because the addresses mentioned in the error text do not belong to the application memory, and if, God forbid, the client‚Äôs error will be corrected by this error. description we can not. <br><br>  Therefore, make it a rule - debugging of the application should always occur with the ‚ÄúRange checking‚Äù setting enabled! <br><br>  Also, this parameter controls the overshooting of the permissible values ‚Äã‚Äãwhen the values ‚Äã‚Äãof variables change.  For example, an exception will be raised when trying to assign a negative value to unsigned types like Cardinal / DWORD, or when trying to assign a value greater than a variable of this type can contain, for example, when assigning 500 to a Byte variable, etc. <br><br>  <b>Parameter "I / O cheking"</b> <br><br>  Responsible for validating I / O results when working with Pascal-style files. <br><br>  I'm not sure that there is still software using this approach, but if you are still working with Append / Assign / Rewrite, etc., then enable this option when debugging the application. <br><br>  <b>‚ÄúOverflow cheking‚Äù parameter</b> <br><br>  Monitors the results of arithmetic operations and raises an exception in cases where the result is outside the range of a variable. <br><br>  To make it easier to understand the differences between this parameter and ‚ÄúRange checking‚Äù, consider the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> C: Cardinal; B: Byte; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> I := -<span class="hljs-number"><span class="hljs-number">1</span></span>; B := I; C := I; ShowMessage(IntToStr(C - B)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  This code will not raise an exception when the ‚ÄúOverflow cheking‚Äù parameter is enabled.  Although here variables are assigned not valid values, but no mathematical operations are performed on them.  However, an exception will be raised when the ‚ÄúRange checking‚Äù parameter is enabled. <br><br>  And now consider the second version of the code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> C: Cardinal; B: Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> B := <span class="hljs-number"><span class="hljs-number">255</span></span>; Inc(B); C := <span class="hljs-number"><span class="hljs-number">0</span></span>; C := C - <span class="hljs-number"><span class="hljs-number">1</span></span>; ShowMessage(IntToStr(C - B)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  There will no longer be a reaction from the ‚ÄúRange checking‚Äù parameter, but an EIntegerOverflow exception will be raised, for which ‚ÄúOverflow cheking‚Äù is responsible, on the lines Inc (B) and C: = C - 1 due to the fact that the result of an arithmetic operation cannot be stored in the corresponding variable. <br>  Thus, when working with variables, both parameters complement each other. <br><br>  ‚ÄúOverflow cheking‚Äù is not as critical as ‚ÄúRange checking‚Äù, but it is still advisable to keep it turned on when debugging an application. <br><br>  A small nuance: if you suddenly implement cryptographic algorithms, then, as a rule, the overflow operation is regular.  In such situations, take the code to a separate module and, at the beginning of the module, write the directive "{$ OVERFLOWCHECKS OFF}" to disable overflow checking in the current module. <br><br>  <b>Debugging Group</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89f/15b/176/89f15b1768717c9ce8d78bc1ef6d6b6c.png" alt="image"><br><br>  With this tab, everything is very simple.  All parameters, with the exception of the ‚ÄúAssertions‚Äù parameter, do not in any way affect the final code of your application.  Depending on the activity of certain parameters, the completeness of debugging information in the DCU file for each module changes.  Based on this information, the debugger synchronizes the assembler listing of the program with its real code, implemented by the programmer, recognizes local variables, etc. When compiling an application, this debugging information does not fit in the body of the application. <br>  The only exception is the ‚ÄúAssertions‚Äù parameter - it is responsible for the operation of the Assert () procedure.  If this parameter is disabled, Assert is not executed; otherwise, it is executed, and its code will also be placed in the application body at the compilation stage. <br><br>  <b>Summarizing.</b> <br><br>  At the stage of debugging the application, it is desirable to keep all the parameters from the ‚ÄúRuntime errors‚Äù and ‚ÄúDebugging‚Äù groups enabled, and disable them during the final compilation of the release application.  In Delphi 7 and below, this will have to be done by hand, but, starting with Delphi 2005 and above, there is a normal support for project builds, in which you can specify these flag combinations personally for each type of assembly. <br><br><h4>  1.4.  Call Stack Window ("Call Stack") </h4><br>  If BP is our main tool when debugging an application, then ‚ÄúCall Stack‚Äù is the second in importance. <br><br>  This window looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/037/69c/86d/03769c86de61bbe39210b2a620ab3f2b.png" alt="image"><br><br>  It contains a complete description of the calls that were made before the debugger interrupted the execution of the program on the installed BP (or stopped due to an error).  For example, the screenshot shows a stack of calls that occurred when a button was pressed on a form.  It began with the arrival of the WM_COMMAND (273) message in the TWinControl.DefaultHandler procedure. <br><br>  Having this list in hand, we can quickly switch between calls by double-clicking (or through the ‚ÄúView Source‚Äù menu), view the list of local variables for each call (‚ÄúView Locals‚Äù), and set BP on any call. <br><br>  Of course, there are not many possibilities, but nevertheless, it greatly simplifies the work during debugging, as in most cases it allows you to quickly localize the location of the error. <br><br>  For example, the call stack will look like this when an EAbstractError error occurs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc4/411/3a5/dc44113a50100640bfd6be6c67cb8a33.png" alt="image"><br><br>  In this case, it is enough to find the first call from above, whose code is located not in the Delphi system modules, in order to most likely say that the error is in it.  This call is Unit1.TForm1.Button1Click () - this is the handler of the Button1 button in which the following code was executed: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TStrings.Create.Add(<span class="hljs-string"><span class="hljs-string">'qwe'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Another use case is to track calls to certain functions.  For example, we have a very large application code, and somewhere deep inside it there is a call to MessageBox, but we cannot find this place with a hitch to locate the place to call this particular MessageBox.  To do this, you can use the following method: <br><ol><li>  go to the module where the call of the function of interest is announced (in this case, it is windows.pas), </li><li>  find its announcement (line with blue dot function MessageBox; external user32 ...), </li><li>  install on this line BP and run the program. </li></ol><br>  As soon as the MessageBox is called from any place in the program, our BP will work and we will be able, on the basis of the ‚ÄúCall Stack‚Äù data, to find out the exact place of its call. <br><br><h4>  1.5.  Work with extended stopping point properties </h4><br> ,           ,      ,         ,             ,      ,        ,   . <br><br>        .      BP   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/065/7b6/251/0657b6251ad7f8bb042f8e836f6c4001.png" alt="image"><br><br>    ¬´Breakpoint list¬ª      BP. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f59/bfc/aae/f59bfcaaed9b073165690a28048b4331.png" alt="image"><br><br>     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/818/9a9/20d/8189a920d5efefb20ac58798740b124d.png" alt="image"><br><br>  ¬´Condition¬ª      . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ‚ÄúPass count‚Äù parameter indicates how many such conditions need to be skipped before BP is activated, and the number of positives is counted from the very first one, taking into account the value of the ‚ÄúCondition‚Äù parameter. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider an abstract example:</font></font></b> <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, RandomValue: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RandomValue := Random(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> RandomValue := RandomValue + I; ShowMessage(IntToStr(RandomValue)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose BP is installed on the seventh line (RandomValue: = ...). If we just start the program, we will receive exactly 100 BP triggers. In order for this BP to trigger every tenth call, it is necessary to set the value of the Pass count property to 10. In this case, we will get exactly ten BP triggerings, at that moment the iterator of the code ‚ÄúI‚Äù will be a multiple of ten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose now we want to start the analysis after the 75th iteration, inclusive, for this we set the following condition in the ‚ÄúCondition‚Äù parameter: I&gt; 75. In this case, this BP will work only two times: at that moment, when the iterator ‚ÄúI‚Äù will be equal to 85, and the second time, with a value of 95. This </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">happened for the following reasons:</font></font></b> <br><br>   ,      ,      ,  . .    ¬´Pass count¬ª,     ,           ,         ¬´Pass count¬ª.         (   ). <br><br>              ¬´Condition¬ª, . .,   ¬´I¬ª      75,  ,        .     ,    ,      ¬´Pass count¬ª    ,   ¬´I¬ª   85. <br><br> ,   ,         ¬´I¬ª  75,   ¬´Pass count¬ª    . <br><br>             . <br><br> <b>    .</b> <br><br>    ,    ,   .  Those.  (    ),    ,         , <b>      100 </b> ,        ,      . <br><br> <b>  :</b>          (,      ),         . <br><br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, RandomValue: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RandomValue := Random(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> RandomValue := RandomValue + I; ShowMessage(IntToStr(RandomValue)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We set the BP on the same seventh line and specify the value I = 9999 in the ‚ÄúCondition‚Äù parameter. Even on such a small cycle we will have to wait for the condition to trigger in the region of 3-5 seconds. Of course, this is not convenient. In such cases, it is easier to modify the code as follows:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, RandomValue: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RandomValue := Random(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RandomValue := RandomValue + I; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF DEBUG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> I = <span class="hljs-number"><span class="hljs-number">9999</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Beep; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ShowMessage(IntToStr(RandomValue)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br> ‚Ä¶     Beep,     .         . <br> (     DEBUG         ,  ,  ,         Beep-. ) <br><br>  ¬´¬ª  ,              (SEH),   Delphi         try..finally..except.   SEH     ¬´¬ª   .            ,   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := GetTickCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">100000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(Value); Result := GetTickCount - Result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := GetTickCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">100000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Inc(Value); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := GetTickCount - Result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := <span class="hljs-number"><span class="hljs-number">0</span></span>; ShowMessage(IntToStr(Test1(A))); A := <span class="hljs-number"><span class="hljs-number">0</span></span>; ShowMessage(IntToStr(Test2(A))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>   Test1  Test2     100  . <br><br>        210 ,      ‚Äì      ,        ‚Äì    try..finally. <br><br> ,     ¬´¬ª ‚Äì        ,     ‚Ä¶ <br><br>       ¬´Group¬ª,     BP     .  ‚Äì  ,      ,   ,    ,            BP,    . <br><br>       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/876/0d2/106/8760d21067dcfdca066f55eb07277055.png" alt="image"><br><br>    : ¬´Enable group¬ª ‚Äì    ,  ¬´Disable group¬ª ‚Äì      . <br><br>         ¬´Break¬ª,        .     ,          . <br>  ‚Äì      . <br><br>    ‚Äì       ,        . <br><br>       ,              . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Before compiling the example, be sure to enable the ‚ÄúOverflow cheking‚Äù option in the compiler settings and disable optimization. </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Level3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Level2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(Result, Level3(Result) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Level1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(Result, Level2(Result) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(IntToStr(Level1(<span class="hljs-number"><span class="hljs-number">0</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After running this code, an exception will occur on the sixteenth line </font></font><br><br><pre> <code class="delphi hljs">Inc(Result, Level3(Result) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>);.</code> </pre><br><br> ,       ,    ,     ,         .  :        , ,      ,         ¬´F9¬ª   ,       . <br><br>        , ,     ,         ,      . <br><br> <b>   :</b> <br><br><ol><li>          ¬´level2BP¬ª. </li><li>   ,       .     FormCreate     ShowMessage    ¬´Disable group¬ª   ¬´level2BP¬ª.      ,      ¬´Break¬ª. </li><li>   Level1     ‚Ññ25. ,        . </li><li> ,   9  ( I     ). ,     8 ,     ,        ¬´level2BP¬ª.            ¬´Condition¬ª  I=8,          ¬´Break¬ª    ¬´Enable group¬ª  ¬´level2BP¬ª. </li><li>  ,      Level2,       ‚Äì     .    F9,   ,  ,      ,   I   5.   ¬´Condition¬ª     I=5,      . </li><li>           ,         . </li></ol><br><br>        ‚Äî  ,    : <br> <a href="">rouse.drkb.ru/blog/bp3.mp4</a> (17 ). <br> ( ,    ,       ,    ,   ) <br><br>  ,         ,           . <br><br>       ¬´Pass Count¬ª,      ¬´Condition¬ª?   ,  ¬´Pass Count¬ª     .     (. .       ¬´Condition¬ª)    ,      . <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to consider a few more options. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ‚ÄúIgnorecelation exceptions‚Äù option disables the debugger's response to any exception that occurred after executing the BP with this option turned on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The parameter ‚ÄúHandlelative exceptions‚Äù cancels the effect of the previous parameter, returning the debugger to normal operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To see what this looks like, create the following code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(<span class="hljs-string"><span class="hljs-string">'All exceptions ignored'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PInteger(<span class="hljs-number"><span class="hljs-number">0</span></span>)^ := <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button3Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: TStrings; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> S := TStrings.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> S.Add(<span class="hljs-string"><span class="hljs-string">'abstract'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> S.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button4Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(<span class="hljs-string"><span class="hljs-string">'All exceptions handled'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the first ShowMessage, set BP, disable it by unchecking the ‚ÄúBreak‚Äù parameter, and enable the ‚ÄúIgnore subsequent exceptions‚Äù parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the second ShowMessage, do the same, just turn on the ‚ÄúHandle subsequent exceptions‚Äù option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start the application from the debugger and click the buttons in the following order:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button3 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button4 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Button3 </font></font></li></ol><br>    ,   Button2  Button3  ,   2  3      ,         5  6  ,        Button4. <br><br> <b> 2 :</b> <br><br> ¬´Log message¬ª ‚Äì   ,         . <br><br> ¬´Eval expression¬ª ‚Äì   ,       (     ¬´Log result¬ª)     .      ,    ¬´123 * 2¬ª. <br><br><h4>  1.6.  ¬´Data breakpoint¬ª, ¬´Watch List¬ª  ¬´Call Stack¬ª </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that we considered earlier belonged to the so-called ‚ÄúSource Breakpoint‚Äù. That is, to the breakpoints set directly in the application code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, in addition to the code, we work with data (variables, arrays, just with allocated memory areas) and the debugger has the ability to set BP to the addresses at which this data is located in memory, using the ‚ÄúData breakpoint‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP is set to a memory address via the Watch List (not in all Delphi versions) or in the Breakpoint List window using Add Breakpoint-&gt; Data Breakpoint, where, in the dialog that appears, specify the required address, size of the monitored area or variable name. If you specify a variable name, the debugger will try to calculate its location in memory and (if possible) set BP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The trouble is that getting this value is quite difficult due to the fact that every time the application starts, the address where the variable is located will be different each time.</font></font><br><br>      ‚Äì   .     , ,    ,      ¬´Data breakpoint¬ª     . ,             ,   ,         .      .    ‚Äì      ,     , ,       , ,   ,      .    ¬´Data breakpoint¬ª        ,       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Those who have previously worked with professional debuggers will probably find out in the ‚ÄúData breakpoint‚Äù one of the basic analysis tools of the application - ‚ÄúMemory Breakpoint‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, the Delphi debugger is not positioned as a professional tool for debugging third-party applications, so such a useful tool as the ‚ÄúMemory Breakpoint‚Äù is presented in it in a truncated version, where only the control of the memory address is recorded from it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But even in this limited version, it remains an excellent tool for monitoring changes in the application's memory, especially for tracking errors in address arithmetic.</font></font><br><br>  Consider the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TTest = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Data: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Char; Caption: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; Description: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowCaption</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowDescription</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowData</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FT: TTest; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.DFM}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TTest }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowCaption</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(Caption); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowData</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(PChar(@Data[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowDescription</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(Description); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TForm1 }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FT := TTest.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> FT.Caption := <span class="hljs-string"><span class="hljs-string">'Test caption'</span></span>; FT.Description := <span class="hljs-string"><span class="hljs-string">'Test Description'</span></span>; InitData(@FT.Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]); FT.ShowCaption; FT.ShowDescription; FT.ShowData; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FT.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValueData = <span class="hljs-string"><span class="hljs-string">'Test data value'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(ValueData) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Value^ := ValueData[I]; Inc(Value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>       ,          : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/980/bbe/8de/980bbe8de2859645c9d1647754778178.png" alt="image"><br><br>   ¬´Break¬ª,   -   ¬´system¬ª: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/7fe/8f7/e787fe8f7a5a0b0e1324ca928e0fe580.png" alt="image"><br><br> ,    ,         ,      ¬´Call Stack¬ª,       ,       ShowCaption    . <br>   BP      ,  ,   ,    Caption,       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/988/1a2/819/9881a2819f7f8a2948c3f96a686c925a.png" alt="image"><br><br>  ,  -          Caption.      ¬´Data breakpoint¬ª. <br><br><ol><li>    Caption,       FT.Description := 'Test Description';. </li><li>   ,   FP.Caption  ¬´Watch List¬ª       ¬´Break When Changed¬ª.        (,  Delphi 2010  ),   ¬´Data breakpoint¬ª   .  ¬´Breakpoint List¬ª  ¬´Add-&gt;Data Breakpoint¬ª,       FP.Caption   . </li><li>    . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After performing these actions, the program will stop at line 68 - Inc (Value). The peculiarity of the ‚ÄúData breakpoint‚Äù is that it stops immediately after the changes, and not when trying to change the monitored memory, so the place where it writes to the address of the FP.Caption variable is located above - this is the string Value ^: = ValueData [I ]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, having found a problem place, we can correct the error itself. It lies in the fact that the length of the ValueData string, which we write to the Data buffer, exceeds the buffer size, which is why memory is overwritten, in which the Caption and Description variables are located.</font></font><br><br><h4>  1.7.  Finally </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This concludes a brief overview of the features of the integrated debugger. There are a few pending nuances, such as: setting ignored exceptions, BP when loading a module, etc., but they are insignificant and are rarely used in practice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, the debugging mode in the ‚ÄúCPU-View‚Äù window and the Address Breakpoint associated with it remained unresolved. I also decided to skip it, because to readers who are not familiar with assembler, my explanation will not give anything, but more savvy specialists will know what CPU-View is and without me how to apply it correctly :) </font></font><br><br> <a href="http://habrahabr.ru/post/178159/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second part of the article</font></font></a> ,     .    ,      BreakPoint,    Data Breakpoint,     Delphi,       ( ,   TF     GUARD ),      Hardware Breakpoint,      Delphi. <br><br>     <a href="http://www.delphimaster.ru/">¬´ ¬ª</a>     ,       aka Inovet,   aka Palladin   aka        . <br><br>  Alexander (Rouse_) Bagel <br> ,  2012 </div><p>Source: <a href="https://habr.com/ru/post/178007/">https://habr.com/ru/post/178007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177989/index.html">Aerobia - cool continuation</a></li>
<li><a href="../177991/index.html">Image hosting for half an hour</a></li>
<li><a href="../177995/index.html">New 3D water simulation algorithm</a></li>
<li><a href="../178003/index.html">Control I SPY TANK via computer</a></li>
<li><a href="../178005/index.html">Pixtr: automatic portrait enhancement</a></li>
<li><a href="../178009/index.html">Prism Developer Guide - Part 8, Navigation</a></li>
<li><a href="../178011/index.html">"Tax on discs" may cancel</a></li>
<li><a href="../178013/index.html">Shoemaker without boots, or accounting equipment in the IT department. Part I</a></li>
<li><a href="../178019/index.html">The vital position of users of VKontakte, depending on gender and age</a></li>
<li><a href="../178021/index.html">New CSS directive @supports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>