<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overload and inheritance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a certain set of features in any programming language for which you just need to know how they are implemented. For example, closures ; This ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overload and inheritance</h1><div class="post__text post__text-html js-mediator-article">  There is a certain set of features in any programming language for which you just need to know how they are implemented.  For example, <a href="http://sergeyteplyakov.blogspot.com/2010/04/c.html">closures</a> ;  This is not beyond a complex concept, but knowledge of how this beast is structured allows certain conclusions to be drawn regarding the behavior of closures with loop variables.  The same goes for calling virtual methods in the constructor of the base class: there is no one correct solution and you just need to know what the language developers have decided and whether the method of the successor will be called (as in Java or C #), or the ‚Äúpolymorphic‚Äù behavior in the constructor does not work and the base class method will be called (as in C ++). <br><br>  Another type of problem that does not have an ideal solution is the combination of overloading (overloading) and overriding (overriding) of the method.  Let's consider the following example in C #.  Suppose we have a pair of classes, <b>Base</b> and <b>Derived</b> , with the virtual method <b>Foo (</b> <b>int)</b> and the non-virtual method <b>Foo (</b> <b>object)</b> in the class <b>Derived</b> : <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Base.Foo(int)"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Derived.Foo(int)"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Derived.Foo(object)"</span></span>); } }</code> </pre> <br><br>  The question is which method will be called in the following case: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">42</span></span>; Derived d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived(); d.Foo(i);</code> </pre><br><br>  The first and very reasonable assumption is that the <b>Derived</b> method will be called <b>.</b>  <b>Foo (</b> <b>int)</b> , because 42 is an <b>int</b> , and the class <b>Derived</b> contains the method <b>Foo (</b> <b>int)</b> .  However, in reality this is not the case and the <b>Derived</b> method will be called <b>.</b>  <b>Foo (</b> <b>object)</b> . <br><br>  Of course, smart people will immediately get into the specification and give the following conclusion: the compiler, they say, treats the declaration and method redefinition in different ways and he, damn, first looks for a suitable method in the class of the current variable (ie, in the class <b>Derived</b> ) will be found (even if implicit type conversions are required), it will calm down and consider base classes (ie, the <b>Base</b> class), even if there is a more appropriate version of the method, which will be overridden by the heir. <br><br>  However, in this case, it‚Äôs not just the fact that the declaration and redefinition of methods is interpreted differently and that the methods of the base class are ‚Äúmethods‚Äù of the second kind, and the compiler analyzes them secondarily, how many reasons that the compiler (or rather its developers) decided implement exactly this behavior. <br>  To answer the question of how logical the current behavior is, let's take a step back and consider the following case.  Suppose that in our class hierarchy there is only one method <b>Foo (</b> <b>object)</b> , and it is located in the class <b>Derived</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Derived.Foo(object)"</span></span>); } }</code> </pre><br><br>  Yes, not very useful class hierarchy, but nonetheless.  The most important thing about it is that no one will raise questions about which call to <b>Foo</b> will be called in the following case (there is only one variant): new Derived (). Foo (42). <br>  But let's assume that the development of the <b>Base</b> and <b>Derived</b> classes is done by different organizations or at least different developers.  Since the developer of the <b>Base</b> class doesn‚Äôt really know what the <b>Derived</b> class developer is doing, at one point he can add the <b>Foo</b> method to the base class without the knowledge of the heir class developers: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Base.Foo(int)"</span></span>); } }</code> </pre><br><br>  If we follow the common sense that was said in our answer to the original question, then we have a more appropriate overload of the <b>Foo</b> method and the following code: new Derived (). Foo (42) should now call the base class method and output <b>Base.</b>  <b>Foo (</b> <b>int)</b> .  However, how logical is it that without the knowledge of the developer of the class <b>Derived</b> after changes in the base class, a well-tested code suddenly stops working?  Of course, one could say that in this case, let's not call the base class method and call it only if there is an overload in the <b>Derived</b> class.  But this behavior will be even stranger. <br>  This problem is known in wide circles of readers of the C # language specification and Eric Lippert‚Äôs blog as the problem of <b>‚Äúfragile base classes‚Äù</b> (brittle base classes syndrome), which most developers of programming languages ‚Äã‚Äãtry to solve.  In this particular case, it is solved by the fact that the <b>compiler first analyzes the methods directly declared in the class of the variable used and only in the absence of a suitable method considers the methods declared in the base classes.</b> <br><br><h5>  <b>What about other programming languages?</b> </h5><br>  Yes, it would be very interesting to learn how this problem is solved in other programming languages, for example, in C ++, Java or, maybe, in Eiffel (in the opinion of many of the most advanced OO programming language). <br><br>  Let me start from the end, because it will be a little easier.  In Eiffel, the problem is solved very simply: in spite of the many labor of OO chips in Eiffel, there is simply no method overload and you cannot declare a method with the same name as the base class method in the heir.  This means that the diagnosis of this problem is postponed at compile time and simply does not exist at run time.  (By the way, although this sounds ridiculous, it is a very effective way of dealing with many problems; the same Eiffel successfully solves a number of non-trivial problems simply because it does not allow them. And although this approach is far from ideal, sometimes it may well be applied to solving many problems in the domain area: sometimes it‚Äôs easier to prohibit some possibility for the user rather than kill him for half a year to solve it). <br><br>  <b>NOTE</b> <b><br></b>  In fact, this trick is not only used in the Eiffel language;  for example, in C # there is some problem with <a href="http://sergeyteplyakov.blogspot.com/2011/02/c.html">virtual events</a> , which is solved in VB.NET quite elegantly - virtual events are <a href="http://blogs.msdn.com/b/lucian/archive/2010/03/05/req28-override-events.aspx">simply forbidden</a> in it. <br><br>  In Java and C ++, things are somewhat different and this is connected, first of all, with the way in which these languages ‚Äã‚Äãdeclare the method redefinition in the class of the heir.  In these languages, a different approach to virtuality is used by default (in Java, all methods are virtual by default, and in C ++ the method must be explicitly declared explicitly), but initially they used the same approach to redefining virtual methods in the heir class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer&amp; i)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// : // virtual void Foo(Integer&amp; i) //  // void Foo(Integer&amp; i) override // C++11 //    ! void Foo(Integer&amp; i) {} void Foo(Object&amp; o) {} };</span></span></code> </pre><br><br>  To override the method in Java and C ++ languages, no additional keywords are required: it is sufficient to implement a method with the same signature in the derived class.  And since from the point of view of syntax, the redefined method is no different from the declaration of a new method (compare two methods of the <b>Derived</b> class), then the behavior here will <b>not</b> be the <b>same</b> as in C #: <br><br><pre> <code class="cpp hljs">Integer i; Derived *pd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived; pd-&gt;Foo(i);</code> </pre><br><br>  In this case, as we initially expected, the <b>Foo (</b> <b>Integer &amp;)</b> method will be called. <br>  In the Java language and in the C ++ language, the programmer was later able to more accurately convey his intentions from the point of view of overriding methods in the successor.  In Java, starting from the 5th version, a special annotation appeared - <a href="http://habrahabr.ru/users/override/" class="user_link">Override</a> , and in C ++ 11 a new keyword ‚Äúoverride‚Äù appeared.  However, for obvious reasons, the behavior in these languages ‚Äã‚Äãremained unchanged. <br><br>  <b>NOTE</b> <br>  By the way, for more details on what's new in C ++ 11 compared to the previous standard, you can find in the translation of the Bjarne Straustrup <a href="http://sergeyteplyakov.blogspot.com/2012/05/c-11-faq.html">FAQ</a> : <a href="http://sergeyteplyakov.blogspot.com/2012/05/c-11-faq.html">C ++ 11 FAQ</a> . <br>  The truth is that the similarities between Java and C ++ end there.  If you comment out the <b>Foo (</b> <b>Integer &amp;)</b> method in the <b>Derived</b> class, then C ++ will <b>call Derived ::</b> <b>Foo (</b> <b>Object &amp;)</b> (that is, a more appropriate base class method will not be considered as a candidate), and in Java it will be called <b>Base.</b>  <b>Foo (</b> <b>Integer)</b> . <br><br><h5>  <b>Conclusion</b> </h5><br>  Overload resolution is an interesting thing in and of itself ( <a href="http://rsdn.ru/forum/dotnet/3272728.flat.aspx">here‚Äôs</a> one of Nikov‚Äôs etudes as a confirmation), but it is even more complicated if you add inheritance to it.  On the one hand, the current behavior in C # may seem to be wrong, but if you weigh the pros and cons, it will be quite logical and not so bad. <br>  In any case, regardless of the programming language used, there will be one advice: if possible, it‚Äôs better not to mix method overloading and redefining them (remember what kind of zoo we got in three rather popular programming languages). </div><p>Source: <a href="https://habr.com/ru/post/149287/">https://habr.com/ru/post/149287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149276/index.html">Feel like a rover! Interactive panoramas of Mars</a></li>
<li><a href="../149277/index.html">C ++ ActiveX Controls Guide with ATL</a></li>
<li><a href="../149278/index.html">Old maps and GoogleMaps</a></li>
<li><a href="../149279/index.html">Sony VAIO Z Ultrabook (SVZ-1311V) Ultra Video Review</a></li>
<li><a href="../149282/index.html">Scouting Robot on Ubuntu and Node.js</a></li>
<li><a href="../149289/index.html">Manage the kettle from the browser or as I did the Internet outlet</a></li>
<li><a href="../149290/index.html">The history of mobile OS: from programmable calculators to PalmOS</a></li>
<li><a href="../149291/index.html">AI - G√∂del v Turing or the critic of artificial intelligence. Tech Viewer</a></li>
<li><a href="../149292/index.html">Chrome's P2P YouTube is nailed in the Chrome Market</a></li>
<li><a href="../149293/index.html">Analysis of the Wi-Fi signal allows you to monitor people who are on the other side</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>