<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Saturday Notes: On Dead Languages ‚Äã‚Äãand Living Practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all know that several thousand programming languages ‚Äã‚Äãhave been created in the world. Only the list of programs Hello, world from the site Wikiboo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Saturday Notes: On Dead Languages ‚Äã‚Äãand Living Practice</h1><div class="post__text post__text-html js-mediator-article">  We all know that several thousand programming languages ‚Äã‚Äãhave been created in the world.  Only the <a href="http://en.wikibooks.org/wiki/List_of_hello_world_programs">list of programs Hello, world from the site Wikibooks</a> includes 230 categories (the full list today consists of 402 items).  At the same time, the well-known <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">TIOBE rating</a> confirms an obvious consideration: the majority of these languages ‚Äã‚Äãare more likely dead than alive.  Already the top ten languages ‚Äã‚Äãaccount for 76.77% of all projects taken into account by TIOBE.  The second ten increases this share to 85.61%.  Therefore, the remaining 30 languages ‚Äã‚Äã(TIOBE takes into account only the first 50 languages ‚Äã‚Äãwhen calculating percentages) account for less than 15% of references. <br><br>  It is clear that the ratings imply a certain amount of cunning, since even a language that is unpopular in general terms can be extremely important for any narrow sphere.  Take the favorite one here by many Erlang or Haskell (39th and 41st places in the ranking) or even more obvious Simulink and LabVIEW, which were not in the Top 50 at all, but irreplaceable in their fields.  On the other hand, it is obvious that languages ‚Äã‚Äãreally come and go, and the popularity of, say, Pascal is doomed to decline, since more progressive languages ‚Äã‚Äãare replacing, marking in the same niche.  (Let us not mention Delphi here, in which only the basic syntax remains of Pascal. For a traditional Pascalist, Delphi listing can cause the same stupor that I had the first Visual Basic 6 program that I saw, with these Private and Public, Option Strict and Dim As, completely absent in his native BASIC ZX Spectrum.) <br><br>  However, all languages ‚Äã‚Äãwere created for something, and not just.  And before finally sending one or another language to the archive of history, one should fully understand its legacy used in current programming practice.  And it may be that some languages ‚Äã‚Äãare generally written off for nothing.  The only question is how to competently conduct an audit, an inventory of all this stuff from hundreds and thousands of languages, how to extract nuggets of meaning from the mountains of waste rock?  I would like to talk about this.  I must say, I have no good answers, but there are good questions. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Duck Syndrome and Winning Peepers </h1>  To begin with, I would like to put forward the thesis that the most popular languages ‚Äã‚Äãtoday are not objectively the best.  My former <a href="http://en.wikipedia.org/wiki/Mordechai_Ben-Ari">supervisor</a> once said gloomily: "It seems that the worse the language, the more popular it is."  I will not go so far in my conclusions.  Suffice it to say that the popularity of any language is really largely due to external factors. <br><br>  The most obvious is <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B0%25D1%2582%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">duck syndrome</a> .  What we were shown in childhood is what we love.  And the longer we work with any system, the better we understand it and, therefore, the less we have the motivation to switch to something else.  I could bring my own story here, but I don‚Äôt see much sense in it: most likely, most programmers are familiar with this phenomenon from personal experience.  For the sake of truth, it should be noted that the holy war "language vs.  language "little understood.  Research clearly demonstrates that the productivity of development is almost entirely provided by the programmer, and not by language (this is, of course, about languages ‚Äã‚Äãof about the same level that can compete with each other). <br><br>  Raised "duckling" can contribute to the victory of a particular party.  So, at one time Microsoft made a bet on Basic and C ++, and in Borland - on Pascal (their solutions in C ++ clearly lagged behind), the consequences of which we have been seeing for the past two decades.  A more recent example is Objective-C (5th place in the TIOBE ranking).  Who would have remembered him if it were not for Apple?  In 2007, Objective-C was in a lowly honorable 46th place and, I would venture to say, could be considered relatively dead.  Being a solution to far from the first freshness (1983), this language was learned by ducklings from Apple and is now included in the list of the most popular languages ‚Äã‚Äãin the world. <br><br>  The argument about the right way to break an egg is meaningless, and the victory of the party of little-pointed people does not mean the superiority of their ideas.  Just so the stars were formed.  If, when learning a new programming language, I set a goal to increase my chances in the labor market, the TIOBE rating is useful.  If I want to dig deeper, study the best examples of the architecture of the language, other selection criteria are required.  In general, do not dismiss the half-forgotten languages.  Blunt-knots are capable of taking revenge, and it may be that tomorrow they will begin to praise completely different languages ‚Äã‚Äãeverywhere than today. <br><br><h1>  Fort assault </h1>  Under the strong influence of my <a href="http://www.apmath.spbu.ru/ru/info/tuzov/">other supervisor,</a> I had long been eyeing FORTH language (38th position in the TIOBE list).  My experiments have not yet gone beyond the simplest exercises, but I can already draw some conclusions for myself.  I think my experience is quite indicative, so I want to dwell on it in a bit more detail. <br><br>  For a start, what is the Fort language?  In short, a unique system of almost missing syntax is implemented in Forte.  The program is essentially a sequence of names, separated by spaces: <br><blockquote>  w1 w2 w3 ... <br></blockquote><br>  Each name (in the terminology of the Fort - "word") - it's just a call to the appropriate procedure, built-in or user-defined.  That is, in C, the same program would look like <br><blockquote>  w1 ();  w2 ();  w3 (); ... <br></blockquote><br>  Words (procedures, I mean) can be defined using the following simple syntax: <br><blockquote>  : NewWord w1 w2 w3 ...;  \ when calling NewWord w1, w2, w3, ... are called in sequence ... <br></blockquote><br>  There are two stacks in the system: one of them (the return stack) is designed to store the return address from a called procedure, and the second (it is usually called just the ‚Äústack‚Äù) exchanges data.  Any function can read and write data stored on stacks. <br><br>  Another important point: in principle, the program on the Forte is compiled into some intermediate code (usually using <a href="http://en.wikipedia.org/wiki/Threaded_code">embroidered code</a> ), and then executed.  But at the same time, the compiler is part of the system and is always available.  Inside the procedure, you can switch to compilation mode and compile a new fragment (for example, loaded from disk).  In addition, any word can be assigned two different actions: the action at the time of compilation and the action at the time of execution.  Say, constants in Forte are also implemented through procedures.  In C, it would look something like this: <br><blockquote>  double PI () {return 3.14;  } <br></blockquote><br>  At the time of compilation, the word-constant must allocate memory for itself, and at the time of the call, it must return the stored value. <br><br>  All these opportunities are realized by literally five to ten keywords embedded in the general flow of words separated by spaces.  Everything else can theoretically be implemented by the user.  For example, you need a loop of the form DO ... LOOP.  You can program it yourself.  The word DO puts its return address on the stack.  Then the words between DO and LOOP are executed.  The word LOOP checks the condition of the loop, and if the loop must be repeated, LOOP puts the address stored by the word DO on the return stack.  Thus, instead of a normal return from the procedure, the system jumps again to DO.  Similarly, you can implement IF ... THEN, SWITCH ... CASE, any data structures. <br><br>  In fact, any text consisting of words separated by spaces can be interpreted as a correct FORTH program.  Therefore, with the help of the Fort, you can implement a particularly brain-consuming idea of ‚Äã‚Äãdomain-specific language: you turn the input data into an executable program!  In other words, the data interprets itself.  For example, let the word A type the text ".-", and the word B - the text "-...".  Then the execution of the correct ABABB Fort program will result in the printing of the corresponding sequence in Morse code. <br><br>  Often FORTH is remembered as the <a href="http://bash.org.ru/quote/5592">language of Master Yoda</a> because of the reverse Polish record used.  In fact, this is just a consequence of the general syntax as a stream of procedural calls separated by spaces.  A record of the form ‚Äú5 2 +‚Äù is interpreted as a procedure call with the name ‚Äú5‚Äù, putting the number 5 on the stack, then ‚Äú2‚Äù (by convention, any procedure with a numeric name simply puts the number on the stack).  Then the "+" procedure takes two numbers from the stack and puts the result back.  The implementation of a full-fledged infix notation would be contrary to the general spirit of the language. <br><br>  In general, this is inconsequential detail.  Much more serious criticism of the Fort as a <a href="http://en.wikipedia.org/wiki/Write-only_language">write-only language</a> .  Experts will argue that unreadable nonsense can be written in any language, but the reality is that at Forte it is much easier to make it.  For unsurpassed flexibility you have to pay a lot.  Say, taking the arguments through the stack, you have to remember their order.  It is possible to describe function signatures unless in comments.  In mathematical expressions, it looks especially wild.  Let's say to calculate the value (a - b) / (a ‚Äã‚Äã+ b) for a and b on the stack, you need to run the sequence <br><blockquote>  OVER OVER + ROT ROT - / <br></blockquote><br>  You need to be a complete fortor to find this code readable.  However, enough about the fort.  If you are interested in this language, you can discuss it another time.  We have to move on. <br><br><h1>  Debriefing </h1>  Of course, I am not writing this article to introduce you to the basics of FORTH.  I just wanted to demonstrate that even the language of the fourth dozen TIOBE, and the language alone in its ideology (as opposed to Haskell and Erlang, having a lot of relatives) can teach a completely different programming process, indicate a non-standard approach to the way a software system is designed.  This method is more than the Fort language; it is a style of thinking that is gained by practice.  One of the participants of a fort forum noticed that he wrote a lot more fort programs in C than in Fort. <br><br>  And now the questions.  With and without answers. <br><br>  <strong>1. Is it necessary?</strong>  At first glance it seems that from ‚Äúnon-mainstream‚Äù languages ‚Äã‚Äãlike the Fort you can extract a lot of useful for professional growth.  But where to get an independent review of programming approaches (books like <a href="http://www.williamspublishing.com/Books/Concept_Of_PL.html">Sebesta</a> are good, but not quite so)?  Maybe some kind of decision only seems original and reasonable, but in practice it is a long time past stage, which proved its inconsistency? <br><br>  <strong>2. What languages?</strong>  The fort is an unusual language, clearly capable of giving food for thought to the modern programmer.  But Algol, for example, turned out to be so influential that all its elements somehow migrated to other languages.  Unless it is worth studying separate mechanisms like <a href="http://en.wikipedia.org/wiki/Evaluation_strategy">call by name</a> . <br><br>  <strong>3. What to study?</strong>  Let's face it: it is unlikely that in all seriousness tomorrow I will start programming exclusively on Forte.  Rather, I would be interested in a certain minimum basis, which would allow me to penetrate the ideology of the language, but at the same time not to spend months on total immersion.  I could have written separate modules on Forte and connected them to my C ++ projects. <br><br>  <strong>4. Where to get the literature?</strong>  Decent textbooks for newbies around the Fort were published <a href="http://books.google.co.jp/books/about/Starting_FORTH.html%3Fid%3DJKlQAAAAMAAJ%26redir_esc%3Dy">under Brezhnev</a> .  Now they either publish educational articles suffering from a lack of systematicity, or serious books for serious specialists.  Old books are no good: the authors focus their attention not on those things that would be worth it (in accordance with modern concepts).  A new book is missing. <br><br>  <strong>5. How to overcome yourself?</strong>  Reading classic textbooks is also difficult because you have to go to the first grade again.  It is hard to spend the whole weekend programming a solution to a quadratic equation or implementing the simplest card file.  I would like specialized training materials designed for people like me.  Where they will not describe in detail what a stack or a function is, but immediately proceed to discuss the principal things for which I am ready to dive into this topic. <br><br>  Well, in general, is there any point in my reasoning? <br><br>  <b>Upd</b> : I want to emphasize that the Fort here is given only as an example, we are not discussing it. </div><p>Source: <a href="https://habr.com/ru/post/136706/">https://habr.com/ru/post/136706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136694/index.html">Uploading images to the server using HTML5 + jQuery + PHP</a></li>
<li><a href="../136695/index.html">Zadolbali!</a></li>
<li><a href="../136696/index.html">Simplex Sierpinski</a></li>
<li><a href="../136701/index.html">Simpliste: just one week</a></li>
<li><a href="../136705/index.html">Adding Scala support with a few clicks to your Android project (Eclipse)</a></li>
<li><a href="../136708/index.html">Sky Map give in open source, Picnik photo editor close</a></li>
<li><a href="../136709/index.html">Iranian web developer sentenced to death</a></li>
<li><a href="../136710/index.html">Ericsson and ZTE were able to negotiate</a></li>
<li><a href="../136712/index.html">Toshiba introduced a waterproof tablet with wireless charging</a></li>
<li><a href="../136714/index.html">Developing a compiler for the cool language in C # language under .NET (Part 2 + Bonuses)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>