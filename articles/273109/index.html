<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mix colors correctly or optimize AlphaBlend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am writing a multiprotocol (but not multiplatform, alas, now only windows) messenger, which so far only supports the TOX protocol. But it's not abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mix colors correctly or optimize AlphaBlend</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e3b/52c/f99/e3b52cf9991d47c6b0fb774ffac630a4.jpg" align="right">  I am writing a multiprotocol (but not multiplatform, alas, now only windows) messenger, which so far only supports the TOX protocol.  But it's not about the messenger, but about its interface, and more specifically, about its main function - AlphaBlend.  Yes, I decided to write my <s>bike</s> GUI.  Well, what modern GUI without translucent elements and smooth curves?  Therefore, there is an urgent need to mix images with translucency, i.e.  alpha blending or alpha blending.  Fortunately, in windows GDI there is such a function - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183351%2528v%3Dvs.85%2529.aspx">AlphaBlend</a> .  It works as it should, it does what it needs.  But I'm still the builder of bicycles, and I wondered if I could write the same function, but faster.  The result of my work under the cut. <br><a name="habracut"></a><br><h4>  Alpha blending theory </h4><br>  Most likely you know this theory, so I will not paint it in detail, I will only note the main points. <br><br>  So, we have 2 pixels - the source and destination pixels.  They need to mix and get a new destination pixel.  Each pixel is represented by 4 bytes A, R, G, B, where A is the (non) transparency value of the pixel (0 is completely transparent, 255 is completely opaque), RGB are color components.  The classic blending formula is: <br><br><pre><code class="hljs lisp">TGT_COLOR = TGT_COLOR * (<span class="hljs-number"><span class="hljs-number">1</span></span> - SRC_ALPHA) + SRC_COLOR * SRC_ALPHA</code> </pre> <br>  An important point!  The unit is in the formula.  In our life, the value 255 stands for one. That is,  in order to apply the formula, we must first divide the value of each byte by 255. As it is not difficult to see, 255 and 256 are fairly close values, and the division by 256 is just an 8-bit right shift.  Therefore, such a simplification is often encountered: instead of operation 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">X</span></span>) * (<span class="hljs-name"><span class="hljs-name">A/255</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre>  do the following: <pre> <code class="hljs ruby"> (X * A) <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  It works well (and most importantly, much faster than honest division), but in the case of alpha blending, the result is not quite correct, namely, the resulting pixel is slightly darker.  Next, I will show how you can perform calculations accurately and without loss in speed. <br><br>  Another important point!  Look at the formula.  In the second part there is SRC_COLOR * SRC_ALPHA.  This multiplication of 3D accelerators is performed by millions and even billions without blinking an eye.  But then we are trying to solve the problem using the central processor, and too much multiplication (more precisely 4 extra multiplications) per pixel is not very good.  Why superfluous?  Because this multiplication can be done in advance by converting the original image.  Such images even have a name: <i>premultiplied</i> .  I do not know the term in Russian, but translating literally we get "pre-multiplied."  And exactly, the GDI function of AlphaBlend requires strictly premultiplied as the source image.  It is reasonable. <br><br>  Well, with the theory finished.  In practice, we will work with 32-bit color.  One pixel is represented by a 32-bit number, in which 4 bytes, starting from the youngest, mean: B (lue), G (reen), R (ed), A (lpha).  Go. <br><br><h4>  First implementation </h4><br>  My first implementation was: <br><br><pre> <code class="hljs pgsql">uint32 ALPHABLEND_PM(uint32 dst, uint32 src) { uint8 ba = ALPHA(src); //  ALPHA    <span class="hljs-number"><span class="hljs-number">32</span></span>-  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ba == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; //  == <span class="hljs-number"><span class="hljs-number">0</span></span>,     == <span class="hljs-number"><span class="hljs-number">0</span></span>,      <span class="hljs-type"><span class="hljs-type">float</span></span> a = (<span class="hljs-type"><span class="hljs-type">float</span></span>)((<span class="hljs-type"><span class="hljs-type">double</span></span>)(ba)* (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">255.0</span></span>)); //        :) <span class="hljs-type"><span class="hljs-type">float</span></span> not_a = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - a; //   :   uint B = lround(<span class="hljs-type"><span class="hljs-type">float</span></span>(BLUE(dst)) * not_a) + BLUE(src); //  BLUE  <span class="hljs-number"><span class="hljs-number">0</span></span>-  <span class="hljs-number"><span class="hljs-number">32</span></span>-  uint G = lround(<span class="hljs-type"><span class="hljs-type">float</span></span>(GREEN(dst)) * not_a) + GREEN(src); //  GREEN  <span class="hljs-number"><span class="hljs-number">1</span></span>-  <span class="hljs-number"><span class="hljs-number">32</span></span>-  uint R = lround(<span class="hljs-type"><span class="hljs-type">float</span></span>(RED(dst)) * not_a) + RED(src); //  RED  <span class="hljs-number"><span class="hljs-number">2</span></span>-  <span class="hljs-number"><span class="hljs-number">32</span></span>-  uint A = lround(<span class="hljs-type"><span class="hljs-type">float</span></span>(ALPHA(dst)) * not_a) + ALPHA(src); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B | (G &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (R &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (A &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>); //  <span class="hljs-number"><span class="hljs-number">32</span></span>-    }</code> </pre><br>  I agree, it does not look very.  4 real (more precisely, 5) multiplications and 4 roundings per pixel is too much.  Not surprisingly, this monster lost AlphaBlend approximately 7 times in speed. <br><br>  Let's try to improve.  We will get rid of real multiplications. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> ALPHABLEND_PM(<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> dst, <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> src) { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> not_a = <span class="hljs-number"><span class="hljs-number">256</span></span> - ALPHA(src); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = src + (((not_a * BLUEx256(dst))&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>) | (((not_a * GREENx256(dst))&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>00) | (((not_a * REDx256(dst))) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>0000) | (((not_a * ALPHAx256(dst))&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>000000)); }</code> </pre><br>  Here, the functions BLUEx256, GREENx256, etc.  return the corresponding component shifted left by 8 bits, i.e.  multiplied by 256. <br><br>  This function is remarkable in that it compensates for replacing the division by 255 by shifting 8 bits to the right.  Did you notice?  If not, be patient, I will describe this point in more detail below. <br><br>  This implementation is inferior to AlphaBlend by about 3 times in speed.  Already better, but still very far from ideal. <br><br><h4>  Unexpected result </h4><br>  How can the previous function be improved?  It seems we did everything we can.  However, I managed to improve this function in a way that came as a surprise to me.  I tried it just to make sure that nothing happens.  However, it turned out. <br>  What if we carry out the operation of multiplying bytes per byte in the table.  Not very much will turn out - only 65536 byte.  Penny. <br><br>  We get the following label: <br><br><pre> <code class="hljs markdown">uint8 __declspec(align(256)) multbl[<span class="hljs-string"><span class="hljs-string">256</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">256</span></span>];</code> </pre><br>  Fill in: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) { int k = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span>; multbl[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>][<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] = (uint8)k; }</code> </pre><br>  We try: <br><br><pre> <code class="hljs markdown">uint32 ALPHABLEND<span class="hljs-emphasis"><span class="hljs-emphasis">_PM(uint32 dst, uint32 src) { uint8 not_</span></span>a = 255 - ALPHA(src); return src + ((multbl[<span class="hljs-string"><span class="hljs-string">not_a</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">dst &amp; 0xff</span></span>]) | (((uint)multbl[<span class="hljs-string"><span class="hljs-string">not_a</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">(dst &gt;&gt; 8) &amp; 0xff</span></span>]) <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">8</span></span></span></span><span class="xml"><span class="hljs-tag">) | (((</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint</span></span></span></span><span class="xml"><span class="hljs-tag">)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">multbl</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">not_a</span></span></span></span><span class="xml"><span class="hljs-tag">][(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dst</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>&gt; 16) &amp; 0xff]) <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">16</span></span></span></span><span class="xml"><span class="hljs-tag">) | (((</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint</span></span></span></span><span class="xml"><span class="hljs-tag">)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">multbl</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">not_a</span></span></span></span><span class="xml"><span class="hljs-tag">][(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dst</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>&gt; 24) &amp; 0xff]) <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">24</span></span></span></span><span class="xml"><span class="hljs-tag">)); }</span></span></span></span></code> </pre><br>  Surprisingly, this function worked one and a half times faster than the previous implementation.  True, there is one subtlety - the compiler (in my case it was msvc 2013) worked very well in memory operations.  When I tried to write this function on a bare assembler, making, as it seemed to me, everything is much better than the optimizer, I got a function that worked twice as slow as this one.  It was a failure.  I didn‚Äôt understand what exactly I was wrong about - apparently I couldn‚Äôt correctly parallelize all the operations - I just left this function to the optimizer. <br><br>  So.  There is nothing more to optimize.  Nothing comes to my mind anymore.  But AlphaBlend is still two times faster.  How did they do it?  It seems it's time to retire? <br><br><h4>  O Compensation for replacing division by 255 shift </h4><br>  There are many ways to quickly divide by 255. I have met this: <br><br><pre> <code class="hljs lisp">X/255 == (<span class="hljs-name"><span class="hljs-name">X+1+</span></span>(<span class="hljs-name"><span class="hljs-name">X&gt;&gt;8</span></span>)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  That's not bad.  This is faster than honest division by 255. But this is still too cumbersome.  I thought for a long time how to quickly divide by 255 and not lose in quality or speed.  How to compensate for color degradation when using shear? <br><br>  Suppose we have a color component equal to <b>0xff</b> (255) and we have another component also equal to <b>0xff</b> (255).  Multiplying them, we get: <br><br>  <b>0xff * 0xff = 0xfe01</b> .  Moving 8 bits to the right, we get <b>0xfe</b> - the brightness of the component is reduced.  Poorly. <br>  But what if we increase one of the components by 1 before multiplying? <br>  <b>0xff * 0x100 = 0xff00</b> .  Hmm, that seems to be it.  Check the case when one of the components is 0: <br>  <b>0xff * 1 = 0x00ff</b> , shift to the right by 8 bits, we get 0. Voila!  With other components, the result will also be correct. <br>  Now it is easy to find the place of compensation in the second function: uint not_a = 256 - ALPHA (src); <br>  Not 255 - A, but 256 - A, i.e.  +1 component before multiplication.  For the tabular multiplication method, compensation is not required, since  in the table, all values ‚Äã‚Äãare calculated as necessary. <br><br><h4>  Heavy Artillery - SSSE3 instructions </h4><br>  It's time to think about optimizing using simd.  They say that the Intel compiler can do this without human intervention.  Maybe.  But I doubt that Intel will cope with AlphaBlend.  Well, the maximum - equal to her.  But I need to do something faster.  Open the <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">directory</a> and go. <br><br>  The first question that should be asked is what instructions should be used for optimization?  I have a suspicion that AlphaBlend is optimized for MMX, otherwise I cannot explain its superiority over the pure x86 implementation.  MMX is good, but it is the last century.  Now it is difficult to find a computer where there is no support for SSE4.  And under SSE, you can optimize it at all, even without bothering to check for the presence of support for these instructions - the probability that your program will run on something below the Pentium 3 is close to zero.  I, of course, talk about desktop applications.  Exotic beyond the scope of this article. <br><br>  I opted for SSSE3.  This set of instructions is quite common to be confused by optimizing it for it, given the presence in it of very very convenient instructions. <br><br>  The most useful instruction, which will form the basis of all optimizations, is <b>pshufb</b> ( <b>_mm_shuffle_epi8</b> intrinsic).  It is for her sake and chosen SSSE3.  What is her strength?  The fact that this instruction allows you to scatter the bytes of the source 16-byte register in any random order, or even throw out these bytes as unnecessary.  Those.  I can use this instruction in one movement to prepare everything necessary for the necessary calculations.  Another important instruction is <b>pmulhuw</b> (intrinsic <b>_mm_mulhi_epu16</b> ) - this is 8 multiplications and 8 shifts to the right by 16 bits.  As if specifically for alpha blending operations.  Those.  I actually calculate 2 pixels at once with this command. <br><br>  Well, let's go: <br><br><div class="spoiler">  <b class="spoiler_title">Bed sheet asm code</b> <div class="spoiler_text"><pre> <code class="hljs 1c"> lddqu xmm5, [eax] ;   xmm5 <span class="hljs-number"><span class="hljs-number">16</span></span> , <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   premultiplied  movdqa xmm6, xmm5 ;   xmm6 <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    <span class="hljs-number"><span class="hljs-number">2</span></span>-  ;  :  ;        <span class="hljs-number"><span class="hljs-number">16</span></span>    pshufb xmm5, preparesrcs_1 pshufb xmm6, preparesrcs_2 ;  ; xmm5   <span class="hljs-number"><span class="hljs-number">2</span></span> ,     <span class="hljs-number"><span class="hljs-number">16</span></span>  ; xmm6   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  ;  :  <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>  ;      <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>-  (<span class="hljs-number"><span class="hljs-number">256</span></span>-A) ;    xmm7 movdqa xmm2, xmm5 ;   <span class="hljs-number"><span class="hljs-number">2</span></span>   xmm2 pshufb xmm2, preparealphas ;         : A0 A0 A0 A0 A1 A1 A1 A1 movdqa xmm7, sub256 ;  xmm7  <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>-  <span class="hljs-number"><span class="hljs-number">256</span></span> psubw xmm7, xmm2 ;    movdqu xmm0, [edx] ; <span class="hljs-number"><span class="hljs-number">4</span></span>   movdqa xmm1, xmm0 ;   xmm1 <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span> pshufb xmm0, preparetgtc_1 ;   <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">16</span></span>- ,    <span class="hljs-number"><span class="hljs-number">8</span></span> pmulhuw xmm0, xmm7 ;     <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">16</span></span>-  paddw xmm0, xmm5 ;      <span class="hljs-type"><span class="hljs-type"></span></span>   pshufb xmm0, packcback_1 ;     <span class="hljs-number"><span class="hljs-number">8</span></span>  xmm0 ;   -  ,    <span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    movdqa xmm2, xmm6 pshufb xmm2, xmm3 movdqa xmm7, xmm4 psubw xmm7, xmm2 pshufb xmm1, preparetgtc_2 pmulhuw xmm1, xmm7 paddw xmm1, xmm6 pshufb xmm1, packcback_2 por xmm0, xmm1 ;   xmm0 <span class="hljs-number"><span class="hljs-number">4</span></span>   movdqu [edx], xmm0 ;       </code> </pre><br></div></div><br>  As you can see, the simd implementation mixes 4 source pixels at once with 4 destination pixels.  Well, then she simd.  Behind the <s>frame in</s> this article I will leave the description of the solution to the problem, when you want to mix not a multiple of 4 pixels.  Personally, I use for this "single-pixel" calls c ++ implementation. <br><br><h4>  Results </h4><br>  As a result, this ssse3 implementation works almost 4 times faster (in 3.78 on my hardware) than the AlphaBlend function.  This is a very good result.  Many programmers (including me) are skeptical of such ‚Äúbikes‚Äù.  As a rule, the result is obviously worse than the work of a team of highly qualified specialists.  I took up writing my own implementation of the AlphaBlend function, not believing that I could defeat the guys from Microsoft.  It was just a sporting interest, which, nevertheless, gave the result. <br><br>  But that's not all.  The fact is that in this article I gave the code for a simple case - when the original image is mixed with the resulting one as it is.  But if you read the documentation for the function <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183351%2528v%3Dvs.85%2529.aspx">AlphaBlend</a> , you might have noticed that this function can do additional multiplication by a constant alpha (passed through parameters).  I wrote an ssse3 implementation for this case too.  An interesting result: AlphaBlend works almost 2 times slower if the constant alpha is not equal to 255, i.e.  additional color multiplication required.  My implementation degrades in speed by only 4%, which also distinguishes it from the creation of Microsoft. <br><br><h4>  Links </h4><br>  The code in the article is given only for familiarization with the very principle ssse3 optimization.  I did not give here the value of the used constants.  If you want to use optimized AlphaBlend in your project, you will have to extract the working code directly from the Isotoxin source code (this is the name of my development). <br><br>  The Isotoxin repository <a href="https://github.com/isotoxin/isotoxin">on the githaba</a> . <br>  Directly the file in which the desired function is located <a href="">here</a> . <br><br>  I apologize for not having prepared working examples and did not bring everything into a separate library.  If you really need this function, and you have difficulty in getting it yourself from my sources, write me a personal message and I will tell you in detail how to do it. </div><p>Source: <a href="https://habr.com/ru/post/273109/">https://habr.com/ru/post/273109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273093/index.html">How to replace a domain controller and not break the current infrastructure</a></li>
<li><a href="../273095/index.html">Content filtering: why and how to do it</a></li>
<li><a href="../273101/index.html">Moscow Python Meetup ‚Ññ31</a></li>
<li><a href="../273103/index.html">How to auto-sync data while editing Kendo Grid cells</a></li>
<li><a href="../273107/index.html">OpenSource.Mail.Ru: open projects of our employees</a></li>
<li><a href="../273111/index.html">Checking Microsoft Code Contracts</a></li>
<li><a href="../273113/index.html">Using Google Analytics in games</a></li>
<li><a href="../273115/index.html">Selenium for Python. Chapter 6. Page Objects</a></li>
<li><a href="../273117/index.html">Data Festival in the Museum of Moscow, or how Big Data helps to live and work</a></li>
<li><a href="../273125/index.html">DB hacking or excursion into the world of DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>