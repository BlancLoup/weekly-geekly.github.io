<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust Style C ++ Mutexes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello Habrahabr! 

 I often develop programs in C ++ and I love this language, no matter what they say about it. Probably because in many areas there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust Style C ++ Mutexes</h1><div class="post__text post__text-html js-mediator-article"> Hello Habrahabr! <br><br>  I often develop programs in C ++ and I love this language, no matter what they say about it.  Probably because in many areas there is no replacement for it.  However, this language, as we all know, is not without flaws, and therefore I always follow with interest the new approaches, patterns, or even programming languages, designed to solve some of these problems. <br><br>  So, recently, I looked with interest at Stepan Koltsov‚Äôs <a href="https://habrahabr.ru/users/stepancheg/" class="user_link">stepancheg presentation</a> on the Rust programming language, and I really liked the idea of ‚Äã‚Äãimplementing myutexes in this language.  Moreover, I did not see any obstacles to the implementation of such a primitive in C ++ and immediately opened the IDE, in order to put this into practice. <br><a name="habracut"></a><br>  Immediately I warn you that I will write using the C ++ 11 standard, therefore, if you are going to compile the proposed code, you should do it with the <code>-std=c++11</code> flag.  I also want to immediately warn you that I do not pretend to originality, and I fully admit that such a primitive already exists in any library or framework. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So let's get started.  To begin with, let's imagine what we want to get in the end.  The same mutex in Rust, which will serve as a prototype for us, works as follows: This is a template class that is parameterized by the type of data that it must protect.  That is, in fact, it is not a mutex in the sense to which we are all accustomed, but rather some kind of protected resource that contains not only the mutex itself, but also the value it protects.  At the same time, this type is designed in such a way that access to protected data was in principle impossible without prior capture of a mutex. <br><br>  Thus, the result should be a template class, parameterized by type, with the properties described above.  Let's call it conditionally SharedResource.  Working with him should end up looking something like this: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SharedResource&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; shared_int(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... // -   { //      , //         auto shared_int_accessor = shared_int.lock(); *shared_int_accessor = 10; //   ,  shared_int_accessor //        //   }</span></span></code> </pre></div></div><br>  As you can see, everything is simple, but safe.  With this approach, it is impossible to forget to capture the mutex when accessing the protected resource or release it after all operations with the shared resource are completed.  Let's get down to implementation.  So let's start with the routine: the stub class itself, containing standard constructors, destructors, and operators. <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedResource</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SharedResource() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ~SharedResource() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; SharedResource(SharedResource&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SharedResource&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(SharedResource&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SharedResource&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: };</code> </pre></div></div><br>  So far everything is trite.  For now, copying and moving will be prohibited, then we will change this if the need or desire arises.  But we still have not implemented the features described even here in this line of our usage example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedResource</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedResource</span></span></span><span class="hljs-class">&lt;int&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_int</span></span></span><span class="hljs-class">(5);</span></span></code> </pre><br>  We are not able to initialize the resource we are protecting.  Let's try to fix it.  When using the C ++ 03 standard or below, it would be quite problematic for us (although it is possible) for obvious reasons - the designers of the protected resource can take any number of arguments of arbitrary types.  However, with the advent in C ++ 11 Variadic Templates, this problem has disappeared.  All the functionality we need is implemented easily and simply as follows: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedResource</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; SharedResource(Args ...args) : m_resource(args...) { } ~SharedResource() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; SharedResource(SharedResource&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SharedResource&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(SharedResource&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SharedResource&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SharedResource&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T m_resource; };</code> </pre></div></div><br>  Now we have the m_resource field in the class - this is the same resource we are protecting.  And now we can initialize it in any way we like.  It remains only to realize the possibility of seizing control over the resource and gaining access to it ‚Äî that is, the most interesting.  Let's get started: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; template&lt;typename T&gt; class SharedResource { public: template&lt;typename ...Args&gt; SharedResource(Args ...args) : m_resource(args...) { } ~SharedResource() = default; SharedResource(SharedResource&amp;&amp;) = delete; SharedResource(const SharedResource&amp;) = delete; SharedResource&amp; operator=(SharedResource&amp;&amp;) = delete; SharedResource&amp; operator=(const SharedResource&amp;) = delete; class Accessor { friend class SharedResource&lt;T&gt;; public: ~Accessor() { m_shared_resource.m_mutex.unlock(); } private: Accessor(SharedResource&lt;T&gt; &amp;resource) : m_shared_resource(resource) { m_shared_resource.m_mutex.lock(); } SharedResource&lt;T&gt; &amp;m_shared_resource; }; Accessor lock() { return Accessor(*this); } private: T m_resource; std::mutex m_mutex; };</span></span></span></span></code> </pre></div></div><br>  So, as we see, we have a new class - SharedResource :: Accessor.  This class is the same proxy that provides access to a shared resource while it is captured.  The SharedResource class is declared friendly to it so that this class can be called by its constructor.  The important point is that no one except the parent class can create instances of this class directly.  The only way to do this is to call the SharedResource :: lock () method.  We also see that when constructing an instance of this class, a mutex is captured, and if destroyed, it is released.  Everything is clear here - we want the mutex for the resource to be captured all the time while we have access to it, the presence of which should be provided by the SharedResource :: Accessor class. <br><br>  However, in the current state, the class is very insecure.  It is about copying or moving instances of this class.  Neither the former nor the latter are not explicitly declared, which means that constructors and operators will be used by default.  In this case, they will work incorrectly - for example, when copying, the mutex will not be captured again (which is correct), but it will be released upon destruction.  Thus, if an instance of the class is copied, the mutex will be released one time more than it was captured, and we get our favorite Undefined Behavior.  Let's try to fix this: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; template&lt;typename T&gt; class SharedResource { public: template&lt;typename ...Args&gt; SharedResource(Args ...args) : m_resource(args...) { } ~SharedResource() = default; SharedResource(SharedResource&amp;&amp;) = delete; SharedResource(const SharedResource&amp;) = delete; SharedResource&amp; operator=(SharedResource&amp;&amp;) = delete; SharedResource&amp; operator=(const SharedResource&amp;) = delete; class Accessor { friend class SharedResource&lt;T&gt;; public: ~Accessor() { if (m_shared_resource) { m_shared_resource-&gt;m_mutex.unlock(); } } Accessor(const Accessor&amp;) = delete; Accessor&amp; operator=(const Accessor&amp;) = delete; Accessor(Accessor&amp;&amp; a) : m_shared_resource(a.m_shared_resource) { a.m_shared_resource = nullptr; } Accessor&amp; operator=(Accessor&amp;&amp; a) { if (&amp;a != this) { if (m_shared_resource) { m_shared_resource-&gt;m_mutex.unlock(); } m_shared_resource = a.m_shared_resource; a.m_shared_resource = nullptr; } return *this; } private: Accessor(SharedResource&lt;T&gt; *resource) : m_shared_resource(resource) { m_shared_resource-&gt;m_mutex.lock(); } SharedResource&lt;T&gt; *m_shared_resource; }; Accessor lock() { return Accessor(this); } private: T m_resource; std::mutex m_mutex; };</span></span></span></span></code> </pre></div></div><br>  We banned copying, but allowed the move.  The negative consequence of this decision was that our proxy can now be invalid (after moving), and it can not be used to gain access to the resource.  This is not very good, but not fatal - the displaced objects are not intended for further use.  In addition, crashes when using such objects will be reproduced in 100% of cases, thanks to nullptr, which makes the detection of such errors not very difficult in most cases.  However, it would be nice to give the user the opportunity to check the object for validity.  Let's do this by adding this method: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_shared_resource != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre></div></div><br>  Now the user can always check his copy of proxy for validity.  Optionally, you can add an operator bool, although I did not do that.  So, it remains to implement only the very access to the shared resource.  We do this by adding the following operators for the SharedResource :: Accessor class: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;m_shared_resource-&gt;m_resource; } T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_shared_resource-&gt;m_resource; }</code> </pre></div></div><br>  Completely class will look like this: <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; template&lt;typename T&gt; class SharedResource { public: template&lt;typename ...Args&gt; SharedResource(Args ...args) : m_resource(args...) { } ~SharedResource() = default; SharedResource(SharedResource&amp;&amp;) = delete; SharedResource(const SharedResource&amp;) = delete; SharedResource&amp; operator=(SharedResource&amp;&amp;) = delete; SharedResource&amp; operator=(const SharedResource&amp;) = delete; class Accessor { friend class SharedResource&lt;T&gt;; public: ~Accessor() { if (m_shared_resource) { m_shared_resource-&gt;m_mutex.unlock(); } } Accessor(const Accessor&amp;) = delete; Accessor&amp; operator=(const Accessor&amp;) = delete; Accessor(Accessor&amp;&amp; a) : m_shared_resource(a.m_shared_resource) { a.m_shared_resource = nullptr; } Accessor&amp; operator=(Accessor&amp;&amp; a) { if (&amp;a != this) { if (m_shared_resource) { m_shared_resource-&gt;m_mutex.unlock(); } m_shared_resource = a.m_shared_resource; a.m_shared_resource = nullptr; } return *this; } bool isValid() const noexcept { return m_shared_resource != nullptr; } T* operator-&gt;() { return &amp;m_shared_resource-&gt;m_resource; } T&amp; operator*() { return m_shared_resource-&gt;m_resource; } private: Accessor(SharedResource&lt;T&gt; *resource) : m_shared_resource(resource) { m_shared_resource-&gt;m_mutex.lock(); } SharedResource&lt;T&gt; *m_shared_resource; }; Accessor lock() { return Accessor(this); } private: T m_resource; std::mutex m_mutex; };</span></span></span></span></code> </pre></div></div><br>  Is done.  All the basic functionality for this class is implemented and the class is ready for use.  Of course, it would be nice to implement also an analogue of the Rust method new_with_condvars, which, when creating a class, associates a mutex with a transmitted list of condition variables (condvars).  In C ++, mutexes and condition variables are bound differently when waiting on a condvar instance.  To do this, an instance of the unique_lock class is passed to the condition_variable :: wait method, which is an abstraction of owning a mutex without providing access to the resource. <br><br>  It would be possible to change our implementation so that interaction with condvars is possible, but I am afraid that in this case the implementation will cease to be simple and reliable, and in fact this was the original idea.  However, those who wish can find the implementation that works with condvars below. <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; template&lt;typename T&gt; class SharedResource { public: template&lt;typename ...Args&gt; SharedResource(Args ...args) : m_resource(args...) { } ~SharedResource() = default; SharedResource(SharedResource&amp;&amp;) = delete; SharedResource(const SharedResource&amp;) = delete; SharedResource&amp; operator=(SharedResource&amp;&amp;) = delete; SharedResource&amp; operator=(const SharedResource&amp;) = delete; class Accessor { friend class SharedResource&lt;T&gt;; public: ~Accessor() = default; Accessor(const Accessor&amp;) = delete; Accessor&amp; operator=(const Accessor&amp;) = delete; Accessor(Accessor&amp;&amp; a) : m_lock(std::move(a.m_lock)), m_shared_resource(a.m_shared_resource) { a.m_shared_resource = nullptr; } Accessor&amp; operator=(Accessor&amp;&amp; a) { if (&amp;a != this) { m_lock = std::move(a.m_lock); m_shared_resource = a.m_shared_resource; a.m_shared_resource = nullptr; } return *this; } bool isValid() const noexcept { return m_shared_resource != nullptr; } T* operator-&gt;() { return m_shared_resource; } T&amp; operator*() { return *m_shared_resource; } std::unique_lock&lt;std::mutex&gt;&amp; get_lock() noexcept { return m_lock; } private: Accessor(SharedResource&lt;T&gt; *resource) : m_lock(resource-&gt;m_mutex), m_shared_resource(&amp;resource-&gt;m_resource) { } std::unique_lock&lt;std::mutex&gt; m_lock; T *m_shared_resource; }; Accessor lock() { return Accessor(this); } private: T m_resource; std::mutex m_mutex; };</span></span></span></span></code> </pre></div></div><br>  On this we can consider the implementation of our class completed. <br>  Now a couple of comments on how this class <b>cannot be</b> used in order not to shoot yourself a leg or something else vital: <br><ul><li>  You can not save links and pointers to the protected resource, so that there is no opportunity to access it bypassing the proxy. </li><li>  You cannot call the SharedResource :: lock () method more than once in the same block. </li><li>  You can not use a proxy after moving it. </li><li>  Well, if you are going to use an implementation with condvars support, then it is not recommended to use the unique_lock available through a proxy except for passing to the wait methods of the std :: condition_variable class. </li></ul><br><br>  Many thanks to all for your attention. <br>  Link to github code: <a href="https://github.com/isapego/shared-resource">https://github.com/isapego/shared-resource</a> . <br>  The code is published under the public domain license, so you can do with it everything that you just come to mind. <br>  I would be glad if the article would be useful to someone. <br><br>  PS <br>  Thanks to everyone who pointed out errors, gave advice here and on the githaba and helped to make the article and code better. </div><p>Source: <a href="https://habr.com/ru/post/237941/">https://habr.com/ru/post/237941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237929/index.html">Quadrocopters starred in the film Cirque du Soleil and PTI Zurich</a></li>
<li><a href="../237931/index.html">DPI designer guide</a></li>
<li><a href="../237933/index.html">[Selection] Melchior.js, ng-admin, Hello.js, ineed</a></li>
<li><a href="../237937/index.html">The specifics of the technical support of the modular system</a></li>
<li><a href="../237939/index.html">"Radar Detector" for a penny: a review of a GPS informant iconBIT TRACKER MINI</a></li>
<li><a href="../237943/index.html">Juniper ipsec tunnel tracing</a></li>
<li><a href="../237947/index.html">How does the chosen LTE network affect the power consumption of the phone, or the disadvantages of LTE networks in the CIS</a></li>
<li><a href="../237951/index.html">VoIP Zoo - Provisioning</a></li>
<li><a href="../237955/index.html">Router from DAP-1160</a></li>
<li><a href="../237959/index.html">[Translation] The problem of JavaScript constructors and three ways to solve it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>