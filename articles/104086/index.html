<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>pdb - Interactive debugger</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="pdb - Interactive debugger 
 Python versions: 1.4 and higher 

 pdb is an interactive debugging environment for Python programs. It includes the abili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>pdb - Interactive debugger</h1><div class="post__text post__text-html js-mediator-article"><h4>  pdb - Interactive debugger </h4><br>  Python versions: 1.4 and higher <br><br>  <b>pdb</b> is an interactive debugging environment for Python programs.  It includes the ability to pause program execution, view variable values, line-by-line code execution so that you can understand what your program actually does and find logical errors. <br><a name="habracut"></a><br><h5>  Running debugger </h5><br>  To start using <b>pdb,</b> you need to tell the interpreter how and when we want to see the debugger.  There are several ways to do this, depending on the launch conditions, as well as debugging requirements. <br><br><h6>  From command line </h6><br>  The most obvious method of using a debugger is to run it from the command line, passing your program as a parameter so that it knows what to run. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"># encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go()</font> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> <ol><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li></li><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li></li><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li></li><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><font color="#0000ff"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i return <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></font></code> </li> <li></li><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> <li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> # encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go() <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> </ol> <code><font color="gray"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"># encoding: utf-8 # # Copyright (c) 2010 Doug Hellmann. All rights reserved. # <font color="#0000ff">class</font> MyObj( <font color="#0000ff">object</font> ): def __init__(self, num_loops): self.count = num_loops def go(self): <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range(self.count): print i <font color="#0000ff">return</font> <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : MyObj(5).go()</font> * This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  When you start the debugger from the command line, it loads your source code and stops execution on the first expression found.  In our case, it will stop before performing the definition of the class MyObj in the seventh line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>$ python -m pdb pdb_script.py <br> &gt; .../pdb_script.py(7)&lt;module&gt;() <br> -&gt; class MyObj(object): <br> (Pdb) <br></code> <br><blockquote>  Note: <br>  Usually <b>pdb</b> includes the full path to each module when displaying the file path.  For the sake of brevity of examples in the debugger output, these paths are replaced by ... <br></blockquote><br><h6>  From the interpreter </h6><br>  Many developers work with an interactive interpreter in the early stages of developing modules, as this allows them to experiment more iteratively without having to repeat the save / run / repeat loop, which is necessary when creating stand-alone scripts.  To run the debugger from an interactive session, use <i>run</i> () or <i>runeval</i> (). <br><br> <code>$ python <br> Python 2.7 (r27:82508, Jul 3 2010, 21:12:11) <br> [GCC 4.0.1 (Apple Inc. build 5493)] on darwin <br> Type "help", "copyright", "credits" or "license" for more information. <br> &gt;&gt;&gt; import pdb_script <br> &gt;&gt;&gt; import pdb <br> &gt;&gt;&gt; pdb.run('pdb_script.MyObj(5).go()') <br> &gt; &lt;string&gt;(1)&lt;module&gt;() <br> (Pdb)</code> <br> <br>  The run () argument is a string expression that can be executed by the Python interpreter.  The debugger parses it and stops execution just before running the first expression.  You can use the commands described below to navigate and control the execution. <br><br><h6>  From your program </h6><br>  Both of the previous examples were based on the fact that you want to start the debugger at the very beginning of your program.  For more complex processes in which the problem occurs much later, at run time, it is more convenient to start the debugger from within the program using <i>set_trace</i> (). <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import pdb </li><li></li><li>  <font color="#0000ff">class</font> MyObj ( <font color="#0000ff">object</font> ): </li><li></li><li>  def __init __ (self, num_loops): </li><li>  self.count = num_loops </li><li></li><li>  def go (self): </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (self.count): </li><li>  pdb.set_trace () </li><li>  print i </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  MyObj (5) .go () </li></ol></blockquote><br>  In line 16, the test script invokes the debugger. <br><br> <code>$ python ./pdb_set_trace.py <br> &gt; .../pdb_set_trace.py(17)go() <br> -&gt; print i <br> (Pdb)</code> <br> <br>  set_trace () is just a function in Python, so it can be called at any time during program execution.  This allows you to get into debug mode, depending on the conditions prevailing within the program, for example, when handling exceptions, or in a special branch of a control expression <br><br><h6>  After failure </h6><br>  Debugging a program after its completion is called post-mortem debugging.  <b>pdb</b> supports this debugging using the <i>pm</i> () and <i>post_mortem</i> () functions. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  <font color="#0000ff">class</font> MyObj ( <font color="#0000ff">object</font> ): </li><li></li><li>  def __init __ (self, num_loops): </li><li>  self.count = num_loops </li><li></li><li>  def go (self): </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (self.num_loops): </li><li>  print i </li><li>  return </li></ol></blockquote><br>  Here, on the 13th line, an incorrect field name will cause an AttributeError exception, this will stop execution.  pm () looks at interactive traceback and runs the debugger in the stack frame where the exception occurred. <br><br> <code>$ python <br> Python 2.7 (r27:82508, Jul 3 2010, 21:12:11) <br> [GCC 4.0.1 (Apple Inc. build 5493)] on darwin <br> Type "help", "copyright", "credits" or "license" for more information. <br> &gt;&gt;&gt; from pdb_post_mortem import MyObj <br> &gt;&gt;&gt; MyObj(5).go() <br> Traceback (most recent call last): <br> File "&lt;stdin&gt;", line 1, in &lt;module&gt; <br> File "pdb_post_mortem.py", line 13, in go <br> for i in range(self.num_loops): <br> AttributeError: 'MyObj' object has no attribute 'num_loops' <br> &gt;&gt;&gt; import pdb <br> &gt;&gt;&gt; pdb.pm() <br> &gt; .../pdb_post_mortem.py(13)go() <br> -&gt; for i in range(self.num_loops): <br> (Pdb)</code> <br> <br><h5>  Debugger Management </h5><br>  Interaction with the debugger is reduced to a small command language that allows you to navigate the stack, view and change the values ‚Äã‚Äãof variables, control how the debugger will execute your program.  The debugger uses readline to read commands.  Entering an empty line repeats the previous command, except when viewing the source. <br><br><h6>  Call Stack Navigation </h6><br>  At any time during the debugger, you can use <i>where</i> (or simply <i>w</i> ) to clarify which line is currently running and where you are on the call stack.  In this case, the pdb_set_trace.py module is line 17 in the go () method. <br><br> <code>$ python pdb_set_trace.py <br> &gt; .../pdb_set_trace.py(17)go() <br> -&gt; print i <br> (Pdb) where <br> .../pdb_set_trace.py(21)&lt;module&gt;() <br> -&gt; MyObj(5).go() <br> &gt; .../pdb_set_trace.py(17)go() <br> -&gt; print i</code> <br> <br>  To view the context of the current location, use <i>list</i> ( <i>l</i> ). <br><br> <code>(Pdb) list <br> 12 self.count = num_loops <br> 13 <br> 14 def go(self): <br> 15 for i in range(self.count): <br> 16 pdb.set_trace() <br> 17 -&gt; print i <br> 18 return <br> 19 <br> 20 if __name__ == '__main__': <br> 21 MyObj(5).go() <br> [EOF] <br> (Pdb)</code> <br> <br>  By default, 11 lines are displayed around the current one (5 above and 5 below).  When calling list with a single argument, it will output 11 lines adjacent to the given one, instead of the current one. <br><br> <code>(Pdb) list 14 <br> 9 class MyObj(object): <br> 10 <br> 11 def __init__(self, num_loops): <br> 12 self.count = num_loops <br> 13 <br> 14 def go(self): <br> 15 for i in range(self.count): <br> 16 pdb.set_trace() <br> 17 -&gt; print i <br> 18 return <br> 19</code> <br> <br>  If you pass two arguments to the list, they will be processed as the first and last lines that will be displayed. <br><br> <code>(Pdb) list 5, 19 <br> 5 # <br> 6 <br> 7 import pdb <br> 8 <br> 9 class MyObj(object): <br> 10 <br> 11 def __init__(self, num_loops): <br> 12 self.count = num_loops <br> 13 <br> 14 def go(self): <br> 15 for i in range(self.count): <br> 16 pdb.set_trace() <br> 17 -&gt; print i <br> 18 return <br> 19</code> <br> <br>  Navigate the call stack using <i>up</i> and <i>down</i> .  up (shortly <i>u</i> ) moves to earlier calls on the stack.  down (or <i>d</i> ) transfers to deeper calls. <br><br> <code>(Pdb) up <br> &gt; .../pdb_set_trace.py(21)&lt;module&gt;() <br> -&gt; MyObj(5).go() <br> <br> (Pdb) down <br> &gt; .../pdb_set_trace.py(17)go() <br> -&gt; print i</code> <br> <br>  Each time you move through the stack, the debugger displays the current location in the same format as where. <br><br><h6>  View variables on the stack </h6><br>  A set of variables is associated with each frame of the stack, including values ‚Äã‚Äãlocal to the function being executed and information about the global state.  <b>pdb</b> allows you to view the contents of these variables in several ways. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import pdb </li><li></li><li>  def recursive_function (n = 5, output = <font color="#A31515">'to be printed'</font> ): </li><li>  <font color="#0000ff">if</font> n&gt; 0: </li><li>  recursive_function (n-1) </li><li>  <font color="#0000ff">else</font> : </li><li>  pdb.set_trace () </li><li>  print output </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  recursive_function () </li></ol></blockquote><br><br>  The <i>args</i> command (also <i>known</i> as <i>a</i> ) displays all the arguments of the function that is active in the current frame.  This example also uses the recursive function to show how the deep stack looks in the where output. <br><br> <code>$ python pdb_function_arguments.py <br> &gt; .../pdb_function_arguments.py(14)recursive_function() <br> -&gt; return <br> (Pdb) where <br> .../pdb_function_arguments.py(17)&lt;module&gt;() <br> -&gt; recursive_function() <br> .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> &gt; .../pdb_function_arguments.py(14)recursive_function() <br> -&gt; return <br> <br> (Pdb) args <br> n = 0 <br> output = to be printed <br> <br> (Pdb) up <br> &gt; .../pdb_function_arguments.py(11)recursive_function() <br> -&gt; recursive_function(n-1) <br> <br> (Pdb) args <br> n = 1 <br> output = to be printed <br> <br> (Pdb)</code> <br> <br>  The <i>p</i> command executes the expression given by the argument and prints the result.  You can also use the <i>print</i> statement, but it is passed to the Python interpreter for execution, instead of being executed, as a debugger command. <br><br> <code>(Pdb) pn <br> 1 <br> <br> (Pdb) print n <br> 1</code> <br> <br>  Similarly, starting the expression with <i>!</i>  you immediately send it to the Python interpreter for execution.  This feature can be used to execute arbitrary Python commands, including changing variables.  In this example, the output value is changed before allowing the debugger to continue executing the program.  The next call, after set_trace (), outputs output, displaying the modified value. <br><br> <code>$ python pdb_function_arguments.py <br> &gt; .../pdb_function_arguments.py(14)recursive_function() <br> -&gt; print output <br> <br> (Pdb) !output <br> 'to be printed' <br> <br> (Pdb) !output='changed value' <br> <br> (Pdb) continue <br> changed value</code> <br> <br>  For more complex values, such as nested or large data structures, use <i>pp</i> (pretty print) for ‚Äúnice‚Äù output.  This program reads several lines of text from a file. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import pdb </li><li></li><li>  with open ( <font color="#A31515">'lorem.txt'</font> , <font color="#A31515">'rt'</font> ) <font color="#0000ff">as</font> f: </li><li>  lines = f.readlines () </li><li></li><li>  pdb.set_trace () </li></ol></blockquote><br>  Outputting lines with p is difficult to read, because  he is transferred unnaturally.  pp uses pprint to format values ‚Äã‚Äãbefore output. <br><br> <code>$ python pdb_pp.py <br> --Return-- <br> &gt; .../pdb_pp.py(12)&lt;module&gt;()-&gt;None <br> -&gt; pdb.set_trace() <br> (Pdb) p lines <br> ['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\n', 'egestas, enim <br> et consectetuer ullamcorper, lectus ligula rutrum leo, a\n', 'elementum elit tortor <br> eu quam.\n'] <br> <br> (Pdb) pp lines <br> ['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\n', <br> 'egestas, enim et consectetuer ullamcorper, lectus ligula rutrum leo, a\n', <br> 'elementum elit tortor eu quam.\n'] <br> <br> (Pdb)</code> <br> <br><h6>  Pacing on the program </h6><br>  In addition to navigating up and down the stack while the program is paused, you can also continue execution step by step from where the debugger is invoked. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import pdb </li><li></li><li>  def f (n): </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (n): </li><li>  j = i * n </li><li>  print i, j </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  pdb.set_trace () </li><li>  f (5) </li></ol></blockquote><br>  Use <i>step</i> to execute the current line and stop before the next executable point ‚Äî either the first expression inside the function being called, or the next line in the current function. <br><br> <code>$ python pdb_step.py <br> &gt; /Users/dhellmann/Documents/PyMOTW/src.pdb/PyMOTW/pdb/pdb_step.py(17)&lt;module&gt;() <br> -&gt; f(5)</code> <br> <br>  The interpreter stops at the call to set_trace () and transfers control to the debugger.  As a result of the first step call, the f () call is made. <br><br> <code>(Pdb) step <br> --Call-- <br> &gt; .../pdb_step.py(9)f() <br> -&gt; def f(n):</code> <br> <br>  Once again step, and the current line becomes the first in the f () function and starts the loop. <br><br> <code>(Pdb) step <br> &gt; .../pdb_step.py(10)f() <br> -&gt; for i in range(n):</code> <br> <br>  Stepping over again, we get to the first line inside the loop, where j is defined. <br><br> <code>(Pdb) step <br> &gt; /Users/dhellmann/Documents/PyMOTW/src.pdb/PyMOTW/pdb/pdb_step.py(11)f() <br> -&gt; j = i * n <br> (Pdb) pi <br> 0</code> <br> <br>  The value of i is 0, so after this step the value of j must also be 0. <br><br> <code>(Pdb) step <br> &gt; /Users/dhellmann/Documents/PyMOTW/src.pdb/PyMOTW/pdb/pdb_step.py(12)f() <br> -&gt; print i, j <br> <br> (Pdb) pj <br> 0 <br> <br> (Pdb)</code> <br> <br>  Stepping over again and again can be tedious if you have to overcome a lot of code to the point of error, or if the function is re-called. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import pdb </li><li></li><li>  def calc (i, n): </li><li>  j = i * n </li><li>  <font color="#0000ff">return</font> j </li><li></li><li>  def f (n): </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (n): </li><li>  j = calc (i, n) </li><li>  print i, j </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  pdb.set_trace () </li><li>  f (5) </li></ol></blockquote><br>  In this example, there are no problems with calc (), so going through all its lines, with each call in a cycle in f (), only clogs the useful output, displaying all the lines of calc () as they are executed. <br><br> <code>$ python pdb_next.py <br> &gt; .../pdb_next.py(21)&lt;module&gt;() <br> -&gt; f(5) <br> (Pdb) step <br> --Call-- <br> &gt; .../pdb_next.py(13)f() <br> -&gt; def f(n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(14)f() <br> -&gt; for i in range(n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(15)f() <br> -&gt; j = calc(i, n) <br> <br> (Pdb) step <br> --Call-- <br> &gt; .../pdb_next.py(9)calc() <br> -&gt; def calc(i, n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(10)calc() <br> -&gt; j = i * n <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(11)calc() <br> -&gt; return j <br> <br> (Pdb) step <br> --Return-- <br> &gt; .../pdb_next.py(11)calc()-&gt;0 <br> -&gt; return j <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(16)f() <br> -&gt; print i, j <br> <br> (Pdb) step <br> 0 0</code> <br> <br>  The <i>next</i> command is similar to step, but is not included in the functions called by the current expression.  As a result, after executing this command, the debugger proceeds to the next expression of the current function. <br><br> <code>&gt; .../pdb_next.py(14)f() <br> -&gt; for i in range(n): <br> (Pdb) step <br> &gt; .../pdb_next.py(15)f() <br> -&gt; j = calc(i, n) <br> <br> (Pdb) next <br> &gt; .../pdb_next.py(16)f() <br> -&gt; print i, j <br> <br> (Pdb)</code> <br> <br>  The <i>u</i> ntil command is like next, only it continues execution until it reaches the line of the current function located below (with a number higher than that of the current one).  This means that, for example, until can be used to exit loops. <br><br> <code>$ python pdb_next.py <br> &gt; .../pdb_next.py(21)&lt;module&gt;() <br> -&gt; f(5) <br> (Pdb) step <br> --Call-- <br> &gt; .../pdb_next.py(13)f() <br> -&gt; def f(n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(14)f() <br> -&gt; for i in range(n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(15)f() <br> -&gt; j = calc(i, n) <br> <br> (Pdb) next <br> &gt; .../pdb_next.py(16)f() <br> -&gt; print i, j <br> <br> (Pdb) until <br> 0 0 <br> 1 5 <br> 2 10 <br> 3 15 <br> 4 20 <br> &gt; .../pdb_next.py(17)f() <br> -&gt; return <br> <br> (Pdb)</code> <br> <br>  Before the execution of until, the current line was 16 - the last line of the loop.  After the start of until, the execution reached the 17th line and the cycle was exhausted. <br><br>  <i>return</i> is another way to skip parts of a function.  It continues execution until the moment when the return from the current function is to be performed, and suspends the program.  This gives time to look at the return value before returning from a function. <br><br> <code>$ python pdb_next.py <br> &gt; .../pdb_next.py(21)&lt;module&gt;() <br> -&gt; f(5) <br> (Pdb) step <br> --Call-- <br> &gt; .../pdb_next.py(13)f() <br> -&gt; def f(n): <br> <br> (Pdb) step <br> &gt; .../pdb_next.py(14)f() <br> -&gt; for i in range(n): <br> <br> (Pdb) return <br> 0 0 <br> 1 5 <br> 2 10 <br> 3 15 <br> 4 20 <br> --Return-- <br> &gt; .../pdb_next.py(17)f()-&gt;None <br> -&gt; return <br> <br> (Pdb)</code> <br> <br><h6>  Stopping points </h6><br>  When programs get even bigger, even using next and until will become slow and boring.  Instead of line-by-step stepping through the program, there is a better solution ‚Äî letting it run normally until it reaches the point where you need to interrupt it.  You can use set_trace () to start the debugger, but this only works if you want to stop the program in one place.  A more convenient solution is to run the entire program in the debugger, but tell him in advance where to stop using breakpoints.  The debugger monitors the execution of the program, and when it reaches the location described by the breakpoint, it stops execution in front of the designated line. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  def calc (i, n): </li><li>  j = i * n </li><li>  print <font color="#A31515">'j ='</font> , j </li><li>  <font color="#0000ff">if</font> j&gt; 0: </li><li>  print <font color="#A31515">'Positive!'</font> </li><li>  <font color="#0000ff">return</font> j </li><li></li><li>  def f (n): </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (n): </li><li>  print <font color="#A31515">'i ='</font> , i </li><li>  j = calc (i, n) </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  f (5) </li></ol></blockquote><br>  The <i>break</i> command accepts several options for setting breakpoints.  You can specify the line number, file, or function where the execution should stop.  To set a breakpoint on a specific line in the current file, use <i>break lineno</i> : <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 11 <br> Breakpoint 1 at .../pdb_break.py:11 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> j = 5 <br> &gt; .../pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb)</code> <br>  The <i>continue</i> command informs the debugger about the continuation of the program execution until the next breakpoint.  In this case, the first iteration of the loop in f () will pass, and stop in calc () at the second iteration. <br><br>  Breakpoints can also be set to the first line of the function if you specify its name instead of the line number.  The following example will show what happens if you add a breakpoint to the calc () function. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break calc <br> Breakpoint 1 at .../pdb_break.py:7 <br> <br> (Pdb) continue <br> i = 0 <br> &gt; .../pdb_break.py(8)calc() <br> -&gt; j = i * n <br> <br> (Pdb) where <br> .../pdb_break.py(21)&lt;module&gt;() <br> -&gt; f(5) <br> .../pdb_break.py(17)f() <br> -&gt; j = calc(i, n) <br> &gt; .../pdb_break.py(8)calc() <br> -&gt; j = i * n <br> <br> (Pdb)</code> <br> <br>  To specify a breakpoint in another file, precede the line number, or the function name with the file name. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  <font color="#0000ff">from</font> pdb_break import f </li><li></li><li>  f (5) </li></ol></blockquote><br>  Here we set the breakpoint on the 11th line of the pdb_break.py after the launch of the main program pdb_break_remote.py. <br><br> <code>$ python -m pdb pdb_break_remote.py <br> &gt; .../pdb_break_remote.py(7)&lt;module&gt;() <br> -&gt; from pdb_break import f <br> (Pdb) break pdb_break.py:11 <br> Breakpoint 1 at .../pdb_break.py:11 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> j = 5 <br> &gt; .../pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb)</code> <br> <br>  The file name can be the full path to the source, or a relative path to the file available in sys.path. <br><br>  To view the currently set breakpoints, use <i>break</i> with no arguments.  The output includes the file and line number of each breakpoint, as well as information about how many times it has been hit. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 11 <br> Breakpoint 1 at .../pdb_break.py:11 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:11 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> j = 5 <br> &gt; .../pdb/pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb) continue <br> Positive! <br> i = 2 <br> j = 10 <br> &gt; .../pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:11 <br> breakpoint already hit 2 times <br> <br> (Pdb)</code> <br> <br><h6>  Breakpoint management </h6><br>  Each added breakpoint is assigned a numeric identifier.  These identifiers are used to interactively enable, disable, and delete breakpoint. <br><br>  Turning off breakpoint with the help <i>disable</i> tells the debugger not to stop when this line is reached.  Breypoint is remembered, but ignored. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break calc <br> Breakpoint 1 at .../pdb_break.py:7 <br> <br> (Pdb) break 11 <br> Breakpoint 2 at .../pdb_break.py:11 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:7 <br> 2 breakpoint keep yes at .../pdb_break.py:11 <br> <br> (Pdb) disable 1 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep no at .../pdb_break.py:7 <br> 2 breakpoint keep yes at .../pdb_break.py:11 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> j = 5 <br> &gt; .../pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb)</code> <br> <br>  The debugging session from the following example installs two breakpoints in the program, then one of them disables.  The program is executed until the remaining breakpoint is reached, then another breakpoint is turned on and execution continues. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break calc <br> Breakpoint 1 at .../pdb_break.py:7 <br> <br> (Pdb) break 16 <br> Breakpoint 2 at .../pdb_break.py:16 <br> <br> (Pdb) disable 1 <br> <br> (Pdb) continue <br> &gt; .../pdb_break.py(16)f() <br> -&gt; print 'i =', i <br> <br> (Pdb) list <br> 11 print 'Positive!' <br> 12 return j <br> 13 <br> 14 def f(n): <br> 15 for i in range(n): <br> 16 B-&gt; print 'i =', i <br> 17 j = calc(i, n) <br> 18 return <br> 19 <br> 20 if __name__ == '__main__': <br> 21 f(5) <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> &gt; .../pdb_break.py(16)f() <br> -&gt; print 'i =', i <br> <br> (Pdb) list <br> 11 print 'Positive!' <br> 12 return j <br> 13 <br> 14 def f(n): <br> 15 for i in range(n): <br> 16 B-&gt; print 'i =', i <br> 17 j = calc(i, n) <br> 18 return <br> 19 <br> 20 if __name__ == '__main__': <br> 21 f(5) <br> <br> (Pdb) pi <br> 1 <br> <br> (Pdb) enable 1 <br> <br> (Pdb) continue <br> i = 1 <br> &gt; .../pdb_break.py(8)calc() <br> -&gt; j = i * n <br> <br> (Pdb) list <br> 3 # <br> 4 # Copyright (c) 2010 Doug Hellmann. All rights reserved. <br> 5 # <br> 6 <br> 7 B def calc(i, n): <br> 8 -&gt; j = i * n <br> 9 print 'j =', j <br> 10 if j &gt; 0: <br> 11 print 'Positive!' <br> 12 return j <br> 13 <br> <br> (Pdb)</code> <br> <br>  The lines before which B is indicated in the output of the list show the program places where the breakpoint is set (lines 9 and 18). <br><br>  Use <i>clear</i> to completely remove breakpoint. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break calc <br> Breakpoint 1 at .../pdb_break.py:7 <br> <br> (Pdb) break 11 <br> Breakpoint 2 at .../pdb_break.py:11 <br> <br> (Pdb) break 16 <br> Breakpoint 3 at .../pdb_break.py:16 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:7 <br> 2 breakpoint keep yes at .../pdb_break.py:11 <br> 3 breakpoint keep yes at .../pdb_break.py:16 <br> <br> (Pdb) clear 2 <br> Deleted breakpoint 2 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:7 <br> 3 breakpoint keep yes at .../pdb_break.py:16 <br> <br> (Pdb)</code> <br> <br>  The remaining breypoint will retain their identifiers and are not renumbered. <br><br><h6>  Temporary breakpoints </h6><br>  Temporary breakpoints are automatically cleared after the first hit.  Using a temporary breakpoint, you can quickly reach a certain point of program execution, as with a normal breakpoint, however, since  it is immediately cleared, it does not interfere with further work, if this piece of the program will be re-executed. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) tbreak 11 <br> Breakpoint 1 at .../pdb_break.py:11 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> j = 5 <br> Deleted breakpoint 1 <br> &gt; .../pdb_break.py(11)calc() <br> -&gt; print 'Positive!' <br> <br> (Pdb) break <br> <br> (Pdb) continue <br> Positive! <br> i = 2 <br> j = 10 <br> Positive! <br> i = 3 <br> j = 15 <br> Positive! <br> i = 4 <br> j = 20 <br> Positive! <br> The program finished and will be restarted <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> <br> (Pdb)</code> <br> <br>  After the execution has reached the 11th row for the first time, the breakpoint is removed and the program runs non-stop to the end. <br><br><h6>  Conditional breakpoints </h6><br>  Rules can also be applied to breakpoints so that program execution will stop only if conditions are met.  Using conditional breakpoints allows for finer control of stops than manual switching on and off of breakpoints. <br><br>  Conditional breakpoints can be set in one of two ways.  The first is to specify a condition at the time of creating a breakpoint using break. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 9, j&gt;0 <br> Breakpoint 1 at .../pdb_break.py:9 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:9 <br> stop only if j&gt;0 <br> <br> (Pdb) continue <br> i = 0 <br> j = 0 <br> i = 1 <br> &gt; .../pdb_break.py(9)calc() <br> -&gt; print 'j =', j <br> <br> (Pdb)</code> <br> <br>  The condition argument must be an expression using variable names, visible in the stack frame in which the breakpoint is defined.  If the expression is reduced to the value True, then the program execution stops at breakpoint. <br><br>  The condition can also be applied to an existing breakpoint using the <i>condition</i> command.  The argument is a breakpoint id and an expression. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 9 <br> Breakpoint 1 at .../pdb_break.py:9 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:9 <br> <br> (Pdb) condition 1 j&gt;0 <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:9 <br> stop only if j&gt;0 <br> <br> (Pdb)</code> <br> <br><h6>  Ignore breakpoints </h6><br>  Programs with a large number of cycles or recursive calls are often easier to debug by ‚Äúscrolling‚Äù through certain stages of the program, instead of viewing each call and breakpoint.  The <i>ignore</i> command tells the debugger to skip some breakpoint.  With each breakpoint passing, it decreases the ignore counter.  When it reaches 0, breakpoint is activated again. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 17 <br> Breakpoint 1 at .../pdb_break.py:17 <br> <br> (Pdb) continue <br> i = 0 <br> &gt; .../pdb_break.py(17)f() <br> -&gt; j = calc(i, n) <br> <br> (Pdb) next <br> j = 0 <br> &gt; .../pdb_break.py(15)f() <br> -&gt; for i in range(n): <br> <br> (Pdb) ignore 1 2 <br> Will ignore next 2 crossings of breakpoint 1. <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:17 <br> ignore next 2 hits <br> breakpoint already hit 1 time <br> <br> (Pdb) continue <br> i = 1 <br> j = 5 <br> Positive! <br> i = 2 <br> j = 10 <br> Positive! <br> i = 3 <br> &gt; .../pdb_break.py(17)f() <br> -&gt; j = calc(i, n) <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:17 <br> breakpoint already hit 4 times</code> <br> <br>  Explicitly setting the counter to zero immediately activates the breakpoint. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 17 <br> Breakpoint 1 at .../pdb_break.py:17 <br> <br> (Pdb) ignore 1 2 <br> Will ignore next 2 crossings of breakpoint 1. <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:17 <br> ignore next 2 hits <br> <br> (Pdb) ignore 1 0 <br> Will stop next time breakpoint 1 is reached. <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_break.py:17</code> <br> <br><h6>  Starting breakpoint operations </h6><br>  In addition to the interactive mode, <b>pdb</b> supports simple scripting.  Using commands, you can determine the sequence of interpreter actions, including Python expressions, that will be executed when it hits any breakpoint.  After the <i>commands are</i> executed with the line number argument, the debugger prompt changes to (com).  Enter the commands one at a time, and at the end enter <i>end</i> to save the script and return to the main debugger mode. <br><br> <code>$ python -m pdb pdb_break.py <br> &gt; .../pdb_break.py(7)&lt;module&gt;() <br> -&gt; def calc(i, n): <br> (Pdb) break 9 <br> Breakpoint 1 at .../pdb_break.py:9 <br> <br> (Pdb) commands 1 <br> (com) print 'debug i =', i <br> (com) print 'debug j =', j <br> (com) print 'debug n =', n <br> (com) end <br> <br> (Pdb) continue <br> i = 0 <br> debug i = 0 <br> debug j = 0 <br> debug n = 5 <br> &gt; .../pdb_break.py(9)calc() <br> -&gt; print 'j =', j <br> <br> (Pdb) continue <br> j = 0 <br> i = 1 <br> debug i = 1 <br> debug j = 5 <br> debug n = 5 <br> &gt; .../pdb_break.py(9)calc() <br> -&gt; print 'j =', j <br> <br> (Pdb)</code> <br> <br>  This function is especially useful for debugging code that uses many data structures, variables, because  allows you to output all values ‚Äã‚Äãautomatically, instead of doing it manually on each breakpoint. <br><br><h5>  Manage progress </h5><br>  The <i>jump</i> command allows you to control program execution on the fly without changing the source code.  You can skip part of the program forward, avoiding the execution of some code, or backward, to re-execute it.  A simple program to generate a list of numbers. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  def f (n): </li><li>  result = [] </li><li>  j = 0 </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (n): </li><li>  j = i * n + j </li><li>  j + = n </li><li>  result.append (j) </li><li>  <font color="#0000ff">return</font> result </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  print f (5) </li></ol></blockquote><br>  When started without intervention, the output is an increasing sequence of numbers divisible by 5. <br><br> <code>$ python pdb_jump.py <br> <br> [5, 15, 30, 50, 75]</code> <br> <br><h6>  Go forward </h6><br>  Going forward transfers the execution to a point, then the current line, without executing the commands located before it.  Skipping the 13th line in the example below, the value of j is not incremented and all subsequent values ‚Äã‚Äãthat depend on it become slightly smaller. <br><br> <code>$ python -m pdb pdb_jump.py <br> &gt; .../pdb_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 12 <br> Breakpoint 1 at .../pdb_jump.py:12 <br> <br> (Pdb) continue <br> &gt; .../pdb_jump.py(12)f() <br> -&gt; j += n <br> <br> (Pdb) pj <br> 0 <br> <br> (Pdb) step <br> &gt; .../pdb_jump.py(13)f() <br> -&gt; result.append(j) <br> <br> (Pdb) pj <br> 5 <br> <br> (Pdb) continue <br> &gt; .../pdb_jump.py(12)f() <br> -&gt; j += n <br> <br> (Pdb) jump 13 <br> &gt; .../pdb_jump.py(13)f() <br> -&gt; result.append(j) <br> <br> (Pdb) pj <br> 10 <br> <br> (Pdb) disable 1 <br> <br> (Pdb) continue <br> [5, 10, 25, 45, 70] <br> <br> The program finished and will be restarted <br> &gt; .../pdb_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb)</code> <br> <br><h6>  Go back </h6><br>  Jumps can also transfer program execution to expressions that have already been executed to restart.  Here the value of j is incremented once again so that as a result, the numbers go out more than they would otherwise. <br><br> <code>$ python -m pdb pdb_jump.py <br> &gt; .../pdb_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 13 <br> Breakpoint 1 at .../pdb_jump.py:13 <br> <br> (Pdb) continue <br> &gt; .../pdb_jump.py(13)f() <br> -&gt; result.append(j) <br> <br> (Pdb) pj <br> 5 <br> <br> (Pdb) jump 12 <br> &gt; .../pdb_jump.py(12)f() <br> -&gt; j += n <br> <br> (Pdb) continue <br> &gt; .../pdb_jump.py(13)f() <br> -&gt; result.append(j) <br> <br> (Pdb) pj <br> 10 <br> <br> (Pdb) disable 1 <br> <br> (Pdb) continue <br> [10, 20, 35, 55, 80] <br> <br> The program finished and will be restarted <br> &gt; .../pdb_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb)</code> <br> <h6>  Forbidden transitions </h6><br>  Transitions "in" and "from" some expressions that control the flow of calculations are dangerous or ambiguous, and, therefore, prohibited by the debugger. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  def f (n): </li><li>  <font color="#0000ff">if</font> n &lt;0: </li><li>  raise ValueError ( <font color="#A31515">'Invalid n:% s'</font> % n) </li><li>  result = [] </li><li>  j = 0 </li><li>  <font color="#0000ff">for</font> i <font color="#0000ff">in</font> range (n): </li><li>  j = i * n + j </li><li>  j + = n </li><li>  result.append (j) </li><li>  <font color="#0000ff">return</font> result </li><li></li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  <font color="#0000ff">try</font> : </li><li>  print f (5) </li><li>  <font color="#0000ff">finally</font> : </li><li>  print <font color="#A31515">'Always printed'</font> </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  print f (-5) </li><li>  except: </li><li>  print <font color="#A31515">'There was an error'</font> </li><li>  <font color="#0000ff">else</font> : </li><li>  print <font color="#A31515">'There was no error'</font> </li><li></li><li>  print <font color="#A31515">'Last statement'</font> </li></ol></blockquote><br>  You can go inside the function, but if you do, the arguments will not be defined and the code is unlikely to work. <br><br> <code>$ python -m pdb pdb_no_jump.py <br> &gt; .../pdb_no_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 21 <br> Breakpoint 1 at .../pdb_no_jump.py:21 <br> <br> (Pdb) jump 8 <br> &gt; .../pdb_no_jump.py(8)&lt;module&gt;() <br> -&gt; if n &lt; 0: <br> <br> (Pdb) pn <br> *** NameError: NameError("name 'n' is not defined",) <br> <br> (Pdb) args <br> <br> (Pdb)</code> <br> <br>  You cannot go inside blocks such as for loops or a try: except statement. <br><br> <code>$ python -m pdb pdb_no_jump.py <br> &gt; .../pdb_no_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 21 <br> Breakpoint 1 at .../pdb_no_jump.py:21 <br> <br> (Pdb) continue <br> &gt; .../pdb_no_jump.py(21)&lt;module&gt;() <br> -&gt; print f(5) <br> <br> (Pdb) jump 26 <br> *** Jump failed: can't jump into the middle of a block <br> <br> (Pdb)</code> <br> <br>  The code in the finally block must be executed without fail, so you cannot jump out of it. <br> <code>$ python -m pdb pdb_no_jump.py <br> &gt; .../pdb_no_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 23 <br> Breakpoint 1 at .../pdb_no_jump.py:23 <br> <br> (Pdb) continue <br> [5, 15, 30, 50, 75] <br> &gt; .../pdb_no_jump.py(23)&lt;module&gt;() <br> -&gt; print 'Always printed' <br> <br> (Pdb) jump 25 <br> *** Jump failed: can't jump into or out of a 'finally' block <br> <br> (Pdb)</code> <br> <br>  And the main limitation - the transitions are limited to the lower frame of the stack.  If you go up the stack to view variables, you cannot change the progress in this level. <br><br> <code>$ python -m pdb pdb_no_jump.py <br> &gt; .../pdb_no_jump.py(7)&lt;module&gt;() <br> -&gt; def f(n): <br> (Pdb) break 11 <br> Breakpoint 1 at .../pdb_no_jump.py:11 <br> <br> (Pdb) continue <br> &gt; .../pdb_no_jump.py(11)f() <br> -&gt; j = 0 <br> <br> (Pdb) where <br> /Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/bdb.py(379)run() <br> -&gt; exec cmd in globals, locals <br> &lt;string&gt;(1)&lt;module&gt;() <br> .../pdb_no_jump.py(21)&lt;module&gt;() <br> -&gt; print f(5) <br> &gt; .../pdb_no_jump.py(11)f() <br> -&gt; j = 0 <br> <br> (Pdb) up <br> &gt; .../pdb_no_jump.py(21)&lt;module&gt;() <br> -&gt; print f(5) <br> <br> (Pdb) jump 25 <br> *** You can only jump within the bottom frame <br> <br> (Pdb)</code> <br> <br><h6>  Restart the program </h6><br>  When the debugger reaches the end of the program, it automatically starts it first.  You can also restart it yourself, without leaving the debug mode, and without losing breakpoints or other settings. <br><blockquote><ol><li>  #! / usr / bin / env python </li><li>  # encoding: utf-8 </li><li>  # </li><li>  # Copyright (c) 2010 Doug Hellmann.  All rights reserved. </li><li>  # </li><li></li><li>  import sys </li><li></li><li>  def f (): </li><li>  print <font color="#A31515">'Command line args:'</font> , sys.argv </li><li>  <font color="#0000ff">return</font> </li><li></li><li>  <font color="#0000ff">if</font> __name__ == <font color="#A31515">'__main__'</font> : </li><li>  f () </li></ol></blockquote><br>  Running the above program in the debugger will print the name of the script, since no other arguments were given on the command line. <br><br> <code>$ python -m pdb pdb_run.py <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> (Pdb) continue <br> <br> Command line args: ['pdb_run.py'] <br> The program finished and will be restarted <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> <br> (Pdb)</code> <br> <br>  You can restart the program using <i>run</i> .  The run arguments are parsed with shlex, and passed to the program as if they were from the command line, so you can restart your program with different parameters. <br><br> <code>(Pdb) run abc "this is a long value" <br> Restarting pdb_run.py with arguments: <br> abc this is a long value <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> <br> (Pdb) continue <br> Command line args: ['pdb_run.py', 'a', 'b', 'c', 'this is a long value'] <br> The program finished and will be restarted <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> <br> (Pdb)</code> <br> <br>  run can also be used elsewhere to restart the program. <br><br> <code>$ python -m pdb pdb_run.py <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> (Pdb) break 10 <br> Breakpoint 1 at .../pdb_run.py:10 <br> <br> (Pdb) continue <br> &gt; .../pdb_run.py(10)f() <br> -&gt; print 'Command line args:', sys.argv <br> <br> (Pdb) run one two three <br> Restarting pdb_run.py with arguments: <br> one two three <br> &gt; .../pdb_run.py(7)&lt;module&gt;() <br> -&gt; import sys <br> <br> (Pdb)</code> <br> <br><h5>  Configuring the debugger using aliases </h5><br>  There is a way to avoid re-typing complex commands - to define an alias.  The alias expansion is applied to the first word of each command.  The alias body can contain any command allowed by the debugger interpreter, including debugger commands and Python expressions.  In the definitions of aliases recursion is allowed, so that some aliases can cause others. <br><br> <code>$ python -m pdb pdb_function_arguments.py <br> &gt; .../pdb_function_arguments.py(7)&lt;module&gt;() <br> -&gt; import pdb <br> (Pdb) break 10 <br> Breakpoint 1 at .../pdb_function_arguments.py:10 <br> <br> (Pdb) continue <br> &gt; .../pdb_function_arguments.py(10)recursive_function() <br> -&gt; if n &gt; 0: <br> <br> (Pdb) pp locals().keys() <br> ['output', 'n'] <br> <br> (Pdb) alias pl pp locals().keys() <br> <br> (Pdb) pl <br> ['output', 'n']</code> <br> <br>  Running <i>alias</i> without arguments displays a list of defined aliases.  With one argument - the name of the alias, its definition is displayed. <br><br> <code>(Pdb) alias <br> pl = pp locals().keys() <br> <br> (Pdb) alias pl <br> pl = pp locals().keys() <br> (Pdb)</code> <br> <br>  The alias arguments can be accessed using% n, where n is the number of the argument, starting with 1. To refer to all the arguments, use <i>% *</i> . <br><br> <code>$ python -m pdb pdb_function_arguments.py <br> &gt; .../pdb_function_arguments.py(7)&lt;module&gt;() <br> -&gt; import pdb <br> (Pdb) alias ph !help(%1) <br> <br> (Pdb) ph locals <br> Help on built-in function locals in module __builtin__: <br> <br> locals(...) <br> locals() -&gt; dictionary <br> <br> Update and return a dictionary containing the current scope's local variables.</code> <br> <br>  Remove the alias definition with <i>unalias</i> . <br><br> <code>(Pdb) unalias ph <br> <br> (Pdb) ph locals <br> *** SyntaxError: invalid syntax (&lt;stdin&gt;, line 1) <br> <br> (Pdb)</code> <br> <br><h5>  Saving configuration settings </h5><br>  Debugging a program requires a lot of repetition;  running the code, analyzing the output, correcting the code and input, and running it again.  <b>pdb</b> tries to cut the number of repetitions needed for the debugging process to allow you to concentrate on your code, not on the debugger.  To help reduce the number of commands given to the debugger, <b>pdb</b> allows you to save the configuration, then read it again at startup. <br><br>  First, the ~ / .pdbrc file is read, allowing you to specify personal preferences for all debugging sessions.  After that, ./.pdbrc is read from the current directory so that you can specify settings for a specific project. <br><br> <code>$ cat ~/.pdbrc <br> # Show python help <br> alias ph !help(%1) <br> # Overridden alias <br> alias redefined p 'home definition' <br> <br> $ cat .pdbrc <br> # Breakpoints <br> break 10 <br> # Overridden alias <br> alias redefined p 'local definition' <br> <br> $ python -m pdb pdb_function_arguments.py <br> Breakpoint 1 at .../pdb_function_arguments.py:10 <br> &gt; .../pdb_function_arguments.py(7)&lt;module&gt;() <br> -&gt; import pdb <br> (Pdb) alias <br> ph = !help(%1) <br> redefined = p 'local definition' <br> <br> (Pdb) break <br> Num Type Disp Enb Where <br> 1 breakpoint keep yes at .../pdb_function_arguments.py:10 <br> <br> (Pdb)</code> <br> <br>  Any configuration commands that can be entered into the debugger shell can be stored in one of these files, but the execution control commands (continue, jump, etc.) cannot.  The exception is run, that is, you can set the command line arguments for debugging sessions in ./.pdbrc so that they will remain unchanged throughout subsequent runs. </div><p>Source: <a href="https://habr.com/ru/post/104086/">https://habr.com/ru/post/104086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104080/index.html">Vanity: a community for advertisers</a></li>
<li><a href="../104081/index.html">About persistent stirring in the right places</a></li>
<li><a href="../104083/index.html">What does the Chinese keyboard look like?</a></li>
<li><a href="../104084/index.html">Unusual congratulations on the day of the programmer</a></li>
<li><a href="../104085/index.html">And about the "home" Asterisk</a></li>
<li><a href="../104087/index.html">Ultralight startups in Runet: already possible ... but lazy?</a></li>
<li><a href="../104089/index.html">HTC Desire vs. Wildfire</a></li>
<li><a href="../104092/index.html">Android 2.x is currently used on 70% of all active Android devices.</a></li>
<li><a href="../104093/index.html">Interview: Jim Johnson from Standish Group</a></li>
<li><a href="../104094/index.html">Base of images in any formats and resolutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>