<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make your application fast: profile optimization C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Profile optimization is a very interesting way to optimize application code at runtime (in the Visual C development team, this method is called POGO o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make your application fast: profile optimization C ++</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://msdn.microsoft.com/ru-ru/library/vstudio/e7k32f4k.aspx">Profile optimization</a> is a very interesting way to optimize application code at <i>runtime</i> (in the Visual C development team, this method is called POGO or PGO, from the English Profile Guided Optimization).  For the first time, profile optimization was applied in the late 90s by research teams in Visual C and Microsoft.  Then it was calculated for the Itanium architecture.  Then PGO was incorporated into Visual Studio C / C ++ 2005. Today, this is the main optimization process that significantly improves the performance of Microsoft applications and other developers. <br>  This post will explain how to create faster and more high-performance native applications.  First, let's take a closer look at PGO, and then look at an example (NBody simulation), how with a few simple steps you can apply this optimization process in your applications.  To work, use the source code from the <a href="">example</a> .  To build a project, you will need <a href="http://blogs.msdn.com/controlpanel/blogs/posteditor.aspx/DirectX%2520SDK">DirectX SDK</a> . <br><a name="habracut"></a><br><br><h4>  How to make a native application faster </h4><br>  Traditional compilers work with optimization based on static source files.  They analyze the text of the source file, but do not take into account the data entered by users, which is simply impossible to know from the code.  Consider this pseudocode: <br><img src="https://habrastorage.org/storage2/e3b/3e7/a1b/e3b3e7a1b0a2ba54134961d2d9fe8693.png"><br><br>  When working with the function whichBranchIsTaken, the compiler does not know how often the parameter ‚Äúa‚Äù will be less than the parameter ‚Äúb‚Äù, and how many times the condition ‚Äúif‚Äù will be applied (that is, the compiler cannot predict branching).  When working with devirtualization functions and switchCaseExpansion, the compiler does not know enough about the values ‚Äã‚Äãof * p and i, which makes it impossible to optimize devirtualization and parameter extensions.  These problems will appear even brighter if we substitute this code fragment into different modules (for example, different object files), since the traditional compilation functions cannot be optimized for operation within the original modules. <br>  The basic compiler and linker model is not so bad, but it lacks two main possibilities for optimization.  Firstly, it does not use information that could be obtained from the analysis of all source files (traditional compilers optimize only individual object files).  Secondly, it does not optimize based on the expected or profile response of the application.  The first flaw can be fixed with the compiler switch ( <a href="http://msdn.microsoft.com/en-us/library/0zza0de8.aspx">/ GL</a> ) or the linker switch ( <a href="http://msdn.microsoft.com/en-us/library/xbf3tbeh.aspx">/ LTCG</a> ), which performs the full optimization of the program and is necessary for the profile optimization of the application.  After optimization of the full program is enabled, you can apply profile optimization.  Let us dwell on it in more detail. <br>  PGO is a compiler optimization process in a runtime environment that uses profile data collected during the execution of important or demanding high-performance user scripts in order to optimize the application.  Profile optimization has several advantages over traditional static optimization, since it takes into account how the application will behave in a working environment.  This allows the optimizer to optimize for speed (for frequent user scenarios) or optimize for size (for rare scenarios).  As a result, the code becomes more concise, which ultimately improves application performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/1d4/def/43a/1d4def43a3670f6755be780c907054f0.png"><br><br>  Currently, PGO can only be used on classic desktop applications and is supported on x86 and x64 platforms.  PGO is a process consisting of three stages, as shown in the figure above. <br><br><ul><li>  The first stage is usually called the <b>phase of instrumentation</b> .  During this phase, an application is assembled with a given set of compilation flags.  During the build process, the internal compiler adds test instructions (probes) to the generated code that are used to record the training data needed in the next step.  In total, three types of probes are added (function entry, transition, and values).  A function entry probe measures how often a function was requested.  The transition probe allows you to know how many times a particular branch of code has been reached.  Thus, during the learning phase, the compiler receives information about how often ‚Äúa&gt; b‚Äù is in the code fragment whichBranchisTaken in a given learning scenario.  Probe values ‚Äã‚Äãallows you to get data to build a histogram of values.  For example, a value probe added to the switchCaseExpansion code snippet will provide data for constructing a histogram of values ‚Äã‚Äãfor the switch case index variable i.  Having received information about what values ‚Äã‚Äãthe variable ‚Äúi‚Äù will take during the training, the compiler will be able to optimize for the most frequent values, as well as functions such as switchCaseExpansion.  Thus, at the end of the phase, we will have an instrumented version of the application (with probes) and an empty database file (.pgd), into which the information obtained during the next phase will be entered. </li><li>  <b>The learning phase</b> .  During this phase, the user launches the instrumented version of the application and plays standard user scripts that require high performance.  At the output, we have .pgc files containing information related to various user scripts.  In the process of learning, information passes through probes added during the first phase.  At the output, we get the pgc-files appname! # (Where appname corresponds to the name of the application, and # - one plus the number of pgc-files appname! # In the output build directory). </li><li>  <b>The last phase of PGO is optimization</b> .  During this phase, an optimized version of the application is created.  In addition, the information from the pgc files obtained during the training phase is entered in the background into the database (the .pgd file) created during the instrumentation.  The internal compiler then uses this database to further optimize the code and build an even more advanced version of the application. </li></ul><br><br>  PGO users often mistakenly believe that all three phases (instrumentation, training and optimization) should be carried out each time a project is built.  In fact, the first two phases can be eliminated when building subsequent versions, and the code can undergo significant changes compared to the version obtained after the application learning phase.  In large teams, one developer may be responsible for conducting the PGO and maintaining the training database (.pgd) in the source code repository.  Other developers can synchronize their code repositories with this database and use training files to build PGO-optimized versions of applications.  After a certain number of recompilations, the application will be finally optimized. <br><br><h4>  Application profile optimization </h4><br>  Now, when we know a little more about profile optimization, let's consider its application on a concrete example.  Profile optimization of the application can be done using Visual Studio or the developer‚Äôs command line.  Below is an example of working in Visual Studio with an application under the conditional name "Nbody Simulation".  If you want to learn more about PGO on the command line, refer to <a href="http://msdn.microsoft.com/ru-ru/library/aa289170(v%3Dvs.71).aspx">these articles</a> .  To get started, load the solution in Visual Studio and select the build configuration to work with (i.e. ‚ÄúRelease‚Äù). <br><br><img src="https://habrastorage.org/storage2/9da/0ad/0cf/9da0ad0cffcd5f70dc448c539414eeed.png"><br><br>  As mentioned above, PGO consists of three stages: instrumentation, training, and optimization.  To create an instrumented version of the application, right-click on the project name (‚ÄúNBodyGravityCPU‚Äù) and select the ‚ÄúInstrument‚Äù section in the ‚ÄúProfile Guided Optimization‚Äù menu. <br><br><img src="https://habrastorage.org/storage2/75c/6c1/333/75c6c13339783c818f2291ae3d469a6f.png"><br><br>  Visual Studio will build an instrumented version of the application.  After that, you can proceed to the learning phase.  Run the instrumented version of the application.  To do this, go to the Profile Guided Optimization menu and select Run Instrumented / Optimized Application.  In our case, the application runs with the largest code body (15360), since a stable user script will be implemented that requires high performance.  After the two main performance indicators of the application - FPS (frames per second) and GFlop - take stable values, you can close the application.  At this point, the learning phase will be completed, and the resulting data will be saved in a .pgc file.  By default, the .pgc file will be included in your build configuration, i.e.  directory "Release".  For example, as a result of this training, an NBodyGravityCPU! 1.pgc file is created. <br><br><img src="https://habrastorage.org/storage2/93c/bd8/dae/93cbd8dae442b8d9fa2857429615d389.png"><br><br>  NBody Simulation is a very simple application created solely to illustrate the PGO process.  In fact, there may be many variations of application learning scenarios.  In particular, it is possible to conduct training in several stages, separated by time.  To record such learning scenarios, it is best to use the <a href="http://msdn.microsoft.com/ru-ru/library/9hwkw6e8.aspx">pgosweep</a> command in the developer‚Äôs command line after the instrumented version has already been created (for example, in Visual Studio). <br><br><img src="https://habrastorage.org/storage2/373/812/4e7/3738124e725ac44b322bb78d30e1c406.png"><br><br>  During the last phase of PGO, an optimized version of the application is created.  In the Profile Guided Optimization menu, select Optimize.  An optimized version of the application will be created.  In the output log of PGO-building you will see a summary of the operation. <br>  As mentioned above, the information from the .pgc files obtained during the learning phase is included in the .pgd database, which is then used by the internal compiler optimization matrix.  In most cases (with the exception of small fast applications), the speed / size optimization criterion is determined by the ratio of dynamic instructions for a particular function.  Functions with a large number of instructions (so-called "hot") are optimized for speed, and with a small number of instructions (so-called "cold") for size. <br>  This is almost all you need to start profile optimization in your applications.  Try PGO for your applications and see the results!  And be sure to check out the <a href="http://blogs.msdn.com/b/developer-tools-rus/">Developer Tools</a> blog, maybe you will find some interesting solutions there! <br>  The author of the post - Ankit Asthana ( <a href="http://blogs.msdn.com/487959/ProfileUrlRedirect.ashx">Ankit Asthana</a> ) - Program Manager for the internal compiler Microsoft Visual C + +. </div><p>Source: <a href="https://habr.com/ru/post/180777/">https://habr.com/ru/post/180777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180761/index.html">What is Slow Protocols</a></li>
<li><a href="../180763/index.html">FlexPod: Cloupia Unified Infrastructure Controller (CUIC) - New Acquisition of Cisco</a></li>
<li><a href="../180765/index.html">‚ÄúParlez vous Francais ?!‚Äù Or how to make your application speak many languages</a></li>
<li><a href="../180769/index.html">IIS 7: JSON Response Compression</a></li>
<li><a href="../180771/index.html">Summer 2013: Roaming Guide for all mobile operators</a></li>
<li><a href="../180779/index.html">Lessons learned: Year with a big project on AngularJS</a></li>
<li><a href="../180781/index.html">Domain vk.com was included in the unified register of prohibited sites</a></li>
<li><a href="../180787/index.html">The path of a business samurai: the maximum effect for one weekend</a></li>
<li><a href="../180789/index.html">Google Code does not allow file placement.</a></li>
<li><a href="../180791/index.html">40 years of Ethernet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>