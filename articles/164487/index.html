<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java multithreading</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article I will briefly tell you about the processes, threads, and the basics of multi-threaded programming in the Java language. 
 The ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java multithreading</h1><div class="post__text post__text-html js-mediator-article">  Hello!  In this article I will briefly tell you about the processes, threads, and the basics of multi-threaded programming in the Java language. <img src="https://habrastorage.org/storage2/b5c/4b5/11a/b5c4b511ab0e9f4356df2bad7bb4b5f3.png" align="left"><br>  The most obvious area of ‚Äã‚Äãapplication for multithreading is programming interfaces.  Multithreading is indispensable when it is necessary that the graphical interface continues to respond to user actions during the execution of some information processing.  For example, a thread that is responsible for the interface may wait for the completion of another thread that downloads a file from the Internet, and at this time output some animation or update the progress bar.  In addition, it can stop the download file if the ‚Äúcancel‚Äù button was pressed. <br><br>  Another popular and perhaps one of the most hardcore applications of multithreading is games.  In games, various streams may be responsible for working with the network, animation, physics, etc. <br><br>  Let's start.  First about the processes. <br><a name="habracut"></a><br><h4>  Processes </h4><br>  A process is a collection of code and data that shares a common virtual address space.  Most often, one program consists of one process, but there are exceptions (for example, the Chrome browser creates a separate process for each tab, which gives it some advantages, such as the independence of tabs from each other).  Processes are isolated from each other, therefore direct access to the memory of another process is impossible (interaction between processes is carried out using special means). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For each process, the OS creates a so-called ‚Äúvirtual address space‚Äù to which the process has direct access.  This space belongs to the process, contains only its data and is at its complete disposal.  The operating system is responsible for how the virtual space of the process is projected onto the physical memory. <br><br>  The scheme of this interaction is presented in the picture.  The operating system operates on so-called memory pages, which are simply an area of ‚Äã‚Äãa certain fixed size.  If the process becomes out of memory, the system allocates additional pages to it from the physical memory.  Virtual memory pages can be projected onto physical memory in random order. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/c37/835/c12/c37835c1280215a60671823d0007e41f.png"></div><br><br>  When the program is started, the operating system creates a process, loading the code and data of the program into its address space, and then starts the main thread of the created process. <br><br><h4>  Streams </h4><br>  One thread is one unit of code execution.  Each thread sequentially executes instructions of the process to which it belongs, in parallel with other threads of this process. <br><br>  It is necessary to separately discuss the phrase ‚Äúin parallel with other streams‚Äù.  It is known that there is one execution unit per processor core at a time.  That is, a single-core processor can process commands only sequentially, one at a time (in the simplified case).  However, the launch of several parallel threads is possible in systems with single-core processors.  In this case, the system will periodically switch between threads, alternately letting it run one or the other.  Such a scheme is called pseudo-parallelism.  The system remembers the state (context) of each thread before switching to another thread, and restores it on returning to the execution of the thread.  The context of the thread includes such parameters as the stack, the set of values ‚Äã‚Äãof the processor registers, the address of the command being executed, and so on ... <br><br>  Simply put, with pseudo-parallel execution of threads, the processor is torn between executing multiple threads, performing part of each of these in turn. <br><br>  Here's what it looks like: <br><br><img src="https://habrastorage.org/storage2/b26/e6d/c2c/b26e6dc2c8fb51acc03a76ead0c3abd8.png"><br><br>  The colored squares in the figure are processor instructions (green is the main thread's instructions, blue ones are side).  The execution goes from left to right.  After launching a sidestream, its instructions begin to run along with the instructions of the main thread.  The number of instructions to be executed for each approach is not defined. <br><br>  The fact that the instructions of parallel streams are executed interleaved, in some cases, can lead to data access conflicts.  The following article will be devoted to the problems of thread interaction, but for now on how threads are started in Java ... <br><br><h4>  Running threads </h4><br>  Each process has at least one running thread.  The thread that starts the program is called the main one.  In Java, after creating a process, the execution of the main thread begins with the main () method.  Then, as required, in other places specified by the programmer, and when the conditions set by him are fulfilled, other side threads are launched. <br><br>  In Java, a stream is represented as a child object of the class Thread.  This class encapsulates the standard thread handling mechanisms. <br><br>  You can launch a new stream in two ways: <br><br><h6>  Method 1 </h6><br>  Create an object of the class Thread, passing to it in the constructor something that implements the Runnable interface.  This interface contains the run () method that will be executed in the new thread.  The thread finishes execution when its run () method completes. <br><br>  It looks like this: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeThing</span></span></span><span class="hljs-class"> //,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> //(  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run</span></span></span><span class="hljs-class">()) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//       { System.out.println("   !"); } } public class Program //   main() { static SomeThing mThing; //mThing -  ,   Runnable public static void main(String[] args) { mThing = new SomeThing(); Thread myThready = new Thread(mThing); //  "myThready" myThready.start(); //  System.out.println("  ..."); } }</span></span></span></span></code> </pre> <br><br>  To heighten the shortening of the code, you can pass into the constructor of the Thread class an object of an unnamed inner class that implements the Runnable interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(). </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Thread myThready = new Thread(new Runnable() { public void run() //       { System.out.println("   !"); } }); myThready.start(); //  System.out.println("  ..."); } }</span></span></code> </pre><br><br><h6>  Method 2 </h6><br>  Create a descendant of the class Thread and override its run () method: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AffableThread</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//       { System.out.println("   !"); } } public class Program { static AffableThread mSecondThread; public static void main(String[] args) { mSecondThread = new AffableThread(); //  mSecondThread.start(); //  System.out.println("  ..."); } }</span></span></span></span></code> </pre><br><br>  In the example above, another stream is created and started in the main () method.  It is important to note that after calling the mSecondThread.start () method, the main thread continues its execution, not waiting for the thread generated by it to end.  And those instructions that follow the start () method call will be executed in parallel with the mSecondThread flow instructions. <br><br>  To demonstrate the parallel work of streams, let's consider a program in which two streams argue on the philosophical question ‚Äúwhat was before, an egg or a chicken?‚Äù.  The main stream is sure that the first was a chicken, which he will report every second.  The second stream once a second will refute his opponent.  Total dispute will last 5 seconds.  The stream that is the last to speak its answer to this, without a doubt, burning philosophical question will win.  The example uses tools that have not yet been mentioned (isAlive () sleep () and join ()).  They are given comments, and in more detail they will be further disassembled. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EggVoice</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   1  }catch(InterruptedException e){} System.out.println("!"); } // ¬´¬ª  5  } } public class ChickenVoice //   main() { static EggVoice mAnotherOpinion; //  public static void main(String[] args) { mAnotherOpinion = new EggVoice(); //  System.out.println(" ..."); mAnotherOpinion.start(); //  for(int i = 0; i &lt; 5; i++) { try{ Thread.sleep(1000); //   1  }catch(InterruptedException e){} System.out.println("!"); } // ¬´¬ª  5  if(mAnotherOpinion.isAlive()) //       { try{ mAnotherOpinion.join(); //    . }catch(InterruptedException e){} System.out.println("  !"); } else //     { System.out.println("  !"); } System.out.println(" !"); } } :  ... ! ! ! ! ! ! ! ! ! !   !  !</span></span></code> </pre><br><br>  In the above example, two streams in parallel within 5 seconds output information to the console.  It is impossible to accurately predict which thread will finish speaking last.  You can try, and you can even guess, but there is a high probability that the same program will have another ‚Äúwinner‚Äù at the next launch.  This is due to the so-called "asynchronous code execution."  Asynchrony means that it cannot be said that any instruction of one thread will be executed sooner or later than another instruction.  Or, in other words, parallel threads are independent of each other, except when the programmer himself describes dependencies between threads using the means of the language provided for this. <br><br>  Now a little about the completion of the processes ... <br><br><h4>  Process Completion and Demons </h4><br>  In Java, a process terminates when its last thread terminates.  Even if the main () method has already completed, but the threads generated by it are still running, the system will wait for them to complete. <br><br>  However, this rule does not apply to a special type of thread - demons.  If the last normal process thread has ended, and only the daemons have remained, they will be forcibly terminated and the process will end.  Most often, daemon threads are used to perform background tasks that serve the process throughout its life. <br><br>  It is quite simple to declare a thread as a daemon - you need to call its <b><code>setDaemon(true)</code></b> method before starting the stream; <br>  You can check whether a thread is a daemon by calling its <b><code>boolean isDaemon()</code></b> method; <br><br><h4>  Termination of threads </h4><br>  In Java, there are (existed) means to force a thread to terminate.  In particular, the Thread.stop () method terminates the thread immediately after its execution.  However, this method, as well as Thread.suspend (), which suspends the thread, and Thread.resume (), which continues to execute the thread, have been declared obsolete and their use is now highly undesirable.  The fact is that the flow can be ‚Äúkilled‚Äù during the execution of the operation, the break of which in half a word will leave some object in the wrong state, which will lead to the appearance of a hard-to-catch and randomly occurring error. <br><br>  Instead of the forced termination of a stream, a scheme is used in which each thread is responsible for its termination.  A thread can stop either when it finishes the execution of the run () method, (main () for the main thread) or by a signal from another thread.  And how to react to such a signal is, again, the flow itself.  After receiving it, the thread can perform some operations and complete the execution, or it can completely ignore it and continue execution.  Description of the response to the signal to terminate the stream lies on the programmer‚Äôs shoulders. <br><br>  Java has a built-in stream notification mechanism called Interruption, and we‚Äôll soon consider it, but first look at the following program: <br><br>  Incremenator - a stream that every second adds or subtracts one from the value of the static variable Program.mValue.  The Incremenator contains two closed fields, mIsIncrement and mFinish.  What action is performed is determined by the mIsIncrement boolean variable - if it is true, then one is added, otherwise - subtraction.  And thread termination occurs when the mFinish value becomes true. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Incremenator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   volatile -   private volatile boolean mIsIncrement = true; private volatile boolean mFinish = false; public void changeAction() //    { mIsIncrement = !mIsIncrement; } public void finish() //   { mFinish = true; } @Override public void run() { do { if(!mFinish) //    { if(mIsIncrement) Program.mValue++; // else Program.mValue--; // //    System.out.print(Program.mValue + " "); } else return; //  try{ Thread.sleep(1000); //   1 . }catch(InterruptedException e){} } while(true); } } public class Program { //,    public static int mValue = 0; static Incremenator mInc; //   public static void main(String[] args) { mInc = new Incremenator(); //  System.out.print(" = "); mInc.start(); //  //    //   i*2  for(int i = 1; i &lt;= 3; i++) { try{ Thread.sleep(i*2*1000); //   i*2 . }catch(InterruptedException e){} mInc.changeAction(); //  } mInc.finish(); //    } } :  = 1 2 1 0 -1 -2 -1 0 1 2 3 4</span></span></code> </pre><br><br>  You can interact with the stream using the changeAction () method (for changing from subtraction to addition and vice versa) and using the finish () method (to end the stream). <br><br>  In the declaration of the variables mIsIncrement and mFinish, the keyword volatile (changeable, not permanent) was used.  It must be used for variables that are used by different threads.  This is due to the fact that the value of a variable declared without volatile may be cached separately for each thread, and the value from this cache may differ for each of them.  Declaring a variable with the volatile keyword disables such caching for it and all requests to the variable will be sent directly to memory. <br><br>  This example shows how to organize the interaction between threads.  However, there is one problem with this approach to terminating the stream ‚Äî the Incremenator checks the value of the mFinish field once a second, so it can take up to a second of time between the finish () method and the actual completion of the stream.  It would be great if, when receiving a signal from the outside, the sleep () method returned execution and the thread immediately started its completion.  To perform such a scenario, there is a built-in flow alert tool called Interruption. <br><br><h4>  Interruption </h4><br>  The Thread class contains a hidden Boolean field, similar to the mFinish field in the Incremenator program, which is called the interrupt flag.  You can set this flag by calling the thread's interrupt () method.  There are two ways to check if this flag is set.  The first way is to call the bool isInterrupted () method of the thread object, the second is to call the static method bool Thread.interrupted ().  The first method returns the state of the interrupt flag and leaves this flag intact.  The second method returns the state of the flag and resets it.  Notice that Thread.interrupted () is a static method of the Thread class, and calling it returns the value of the interrupt flag of the thread from which it was called.  Therefore, this method is called only from within the thread and allows the thread to check its interrupt state. <br><br>  So back to our program.  The interrupt mechanism will allow us to solve the problem of falling asleep flow.  Methods that suspend the execution of a thread, such as sleep (), wait () and join (), have one feature - if the interrupt () method of this thread is called during their execution, they will wait for the end of the wait time to throw an InterruptedException exception. <br><br>  Alter the program Incremenator - now instead of terminating the stream using the finish () method, we will use the standard interrupt () method.  And instead of checking the mFinish flag, we will call the bool Thread.interrupted () method; <br>  This is what the Incremenator class will look like after adding interrupt support: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Incremenator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> mIsIncrement = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    { mIsIncrement = !mIsIncrement; } @Override public void run() { do { if(!Thread.interrupted()) //  { if(mIsIncrement) Program.mValue++; // else Program.mValue--; // //    System.out.print(Program.mValue + " "); } else return; //  try{ Thread.sleep(1000); //   1 . }catch(InterruptedException e){ return; //    } } while(true); } } class Program { //,    public static int mValue = 0; static Incremenator mInc; //   public static void main(String[] args) { mInc = new Incremenator(); //  System.out.print(" = "); mInc.start(); //  //    //   i*2  for(int i = 1; i &lt;= 3; i++) { try{ Thread.sleep(i*2*1000); //   i*2 . }catch(InterruptedException e){} mInc.changeAction(); //  } mInc.interrupt(); //   } } :  = 1 2 1 0 -1 -2 -1 0 1 2 3 4</span></span></span></span></code> </pre><br><br>  As you can see, we got rid of the finish () method and implemented the same thread termination mechanism using the built-in interrupt system.  In this implementation, we have one advantage - the sleep () method will return control (generate an exception) immediately after the thread is interrupted. <br><br>  Notice that the sleep () and join () methods are wrapped in try-catch constructs.  This is a necessary condition for the operation of these methods.  The code that calls them must catch the InterruptedException exception, which they throw when interrupted while waiting. <br><br>  With the start and end of the threads figured out, then I will talk about the methods used when working with threads. <br><br><h4>  Thread.sleep () method </h4><br>  Thread.sleep () is a static method of class Thread, which suspends the execution of the thread in which it was called.  During the execution of the sleep () method, the system stops allocating CPU time to the thread, distributing it among other threads.  The sleep () method can be executed either for a specified amount of time (milliseconds or nanoseconds) or until it is stopped by an interrupt (in this case, it throws an InterruptedException exception). <br><br><pre> <code class="java hljs">Thread.sleep(<span class="hljs-number"><span class="hljs-number">1500</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   Thread.sleep(2000, 100); // 2   100 </span></span></code> </pre><br><br>  Although the sleep () method can take a nanosecond waiting time, you should not take it seriously.  In many systems, the waiting time is still rounded to milliseconds or even to their tens. <br><br><h4>  Yield () method </h4><br>  The static method Thread.yield () forces the processor to switch to processing other system threads.  The method can be useful, for example, when the flow is waiting for the occurrence of an event and it is necessary that the test of its occurrence occurs as often as possible.  In this case, you can put the event check and the Thread.yield () method into a loop: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   while(!msgQueue.hasMessages()) //     { Thread.yield(); //    }</span></span></code> </pre><br><br><h4>  Join () method </h4><br>  Java has a mechanism that allows one thread to wait for the completion of another.  For this, the join () method is used.  For example, in order for the main thread to wait for the completion of the side stream myThready, you need to execute the instruction myThready.join () in the main thread.  As soon as the stream myThready is completed, the join () method returns control and the main thread can continue execution. <br><br>  The join () method has an overloaded version that takes a wait time as a parameter.  In this case, join () returns control either when the expected stream ends, or when the wait time ends.  Like the Thread.sleep () method, the join method can wait for milliseconds and nanoseconds - the arguments are the same. <br><br>  Using the task to wait for a stream, you can, for example, update an animated picture while the main (or any other) stream is waiting for the completion of a sidestream that performs resource-intensive operations: <br><br><pre> <code class="java hljs">Thinker brain = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thinker(); <span class="hljs-comment"><span class="hljs-comment">//Thinker -   Thread. brain.start(); // "". do { mThinkIndicator.refresh(); //mThinkIndicator -  . try{ brain.join(250); //    . }catch(InterruptedException e){} } while(brain.isAlive()); // brain ... //brain   ( ).</span></span></code> </pre><br><br>  In this example, the brain stream thinks about something, and it is assumed that it takes him a long time.  The main stream waits for it a quarter of a second and, in the event that there is not enough time for meditation, it updates the ‚Äúreflection indicator‚Äù (some animated picture).  As a result, while thinking, the user observes on the screen an indicator of the thinking process, which lets him know that the electronic brains are busy with something. <br><br><h4>  Thread priorities </h4><br>  Each thread in the system has its own priority.  The priority is a number in the thread object, a higher value of which means a higher priority.  The system primarily performs threads with a higher priority, and threads with a lower priority receive CPU time only when their more privileged brethren are idle. <br><br>  You can work with the priorities of the stream using two functions: <br><br>  <b><code>void setPriority(int priority)</code></b> - sets the priority of the stream. <br>  Possible priority values ‚Äã‚Äãare MIN_PRIORITY, NORM_PRIORITY, and MAX_PRIORITY. <br><br>  <b><code>int getPriority()</code></b> - gets the priority of the stream. <br><br><h4>  Some useful methods of the class Thread </h4><br>  This is almost everything.  Finally, here are some useful methods for working with threads. <br><br>  <b><code>boolean isAlive()</code></b> - returns true if myThready () is executed and false if the stream has not been started yet or has been terminated. <br><br>  <b><code>setName(String threadName)</code></b> - Sets the name of the thread. <br>  <b><code>String getName()</code></b> - Get the name of the stream. <br>  The name of the thread is its associated string, which in some cases helps to understand which thread performs some action.  Sometimes it is useful. <br><br>  <b><code>static Thread Thread.currentThread()</code></b> is a static method that returns the thread object in which it was called. <br><br>  <b><code>long getId()</code></b> - returns the stream identifier.  The identifier is a unique number assigned to the stream. <br><br><h4>  Conclusion </h4><br>  I note that the article does not talk about all the nuances of multi-threaded programming.  And the code given in the examples, for complete correctness lacks some of the nuances.  In particular, synchronization is not used in the examples.  Synchronization of threads is a topic, without studying which, programming the correct multithreaded applications will not work.  You can read about it, for example, in the book ‚ÄúJava Concurrency in Practice‚Äù or <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/">here</a> (all in English). <br><br>  The article examined the main means of working with threads in Java.  If this article turns out to be useful, then in the next one I will talk about the problems of sharing flows to resources and methods for solving them. <br><br>  All the best. </div><p>Source: <a href="https://habr.com/ru/post/164487/">https://habr.com/ru/post/164487/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164477/index.html">Drawing Snowflakes with SVG</a></li>
<li><a href="../164479/index.html">Multiple Assertions without interruption in one unit test using NUnit as an example</a></li>
<li><a href="../164481/index.html">Happy new year, Habr!</a></li>
<li><a href="../164483/index.html">Another look at the Entity Framework: performance and pitfalls</a></li>
<li><a href="../164485/index.html">We follow the comments on the site in the widget "Comments" from VKontakte</a></li>
<li><a href="../164489/index.html">Ways of moving computer characters (Part 1)</a></li>
<li><a href="../164491/index.html">Homemade lights on quadrocopter</a></li>
<li><a href="../164493/index.html">Directives in AngularJS</a></li>
<li><a href="../164495/index.html">Analysis and optimization of a single query in EclipseLink</a></li>
<li><a href="../164497/index.html">Online IDE - a tribute to cloud fashion or the inevitability of the development environment?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>