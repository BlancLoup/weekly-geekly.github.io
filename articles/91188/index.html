<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a SAMBA Resilient File Service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the organization of a fault-tolerant file server based on the Samba package. To understand the material, you need to have a gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a SAMBA Resilient File Service</h1><div class="post__text post__text-html js-mediator-article">  This article describes the organization of a fault-tolerant file server based on the Samba package.  To understand the material, you need to have a general understanding of the administration of the Linux operating system, as well as have experience with the regular version of Samba. <br><br><img src="https://habrastorage.org/storage2/081/e5e/431/081e5e4311f024e715e3046a7ce869e2.gif"><br><br>  Samba is a CIFS service designed to provide the semantics of the CIFS protocol (and therefore access from machines running Windows) to an environment that uses the POSIX file system.  The main function of Samba is to translate the rich semantics that Windows-based clients use to the much poorer semantics of the POSIX file system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  To produce such conversions, Samba uses a variety of internal metadata databases containing additional information used in converting semantics. <br><br>  Additional parameters in particular are responsible for such a thing as the simultaneous opening of the same file from different clients and much more. <br>  This information is necessarily processed before directly opening the file in POSIX. <br>  Thus, transparent access from Windows clients to the POSIX file system is performed. <br><br>  Fault tolerance Samba is based on three provisions: <br><ul><li>  Samba Metadata Database Recovery </li><li>  Availability of user files based on cluster file system </li><li>  Network mechanism of protection against failures, which consists in transferring an IP address from a failed node to a working node </li></ul><br><br><img src="https://habrastorage.org/storage2/1f8/b7a/d5a/1f8b7ad5aa2f3feb9f9e2b8d92f3f109.png"><br><br>  This article describes only the mechanism for creating a fault-tolerant CIFS service.  A prerequisite for its implementation is the use of a parallel cluster file system, which is used directly to store files. <br><br>  The description of cluster systems is beyond the scope of this article.  As an example, you can use the GPFS or Luster file systems. <br><br><h4>  Metadata Bases - Trivial Database </h4><br>  Normal non-clustered versions of Samba use a very simple and resource-intensive database called the Trivial Database (TDB) to store data. <br><br>  TDB is organized on a key-value basis and is similar in organization to Berkley DB.  TDB provides very fast multiple read and write access from various processes on a POSIX system.  Memory reflection (mmap) is supported on most architectures. <br><br>  Each client connection to the file system is serviced by its own smbd daemon process.  Between themselves, these processes interact through the TDB database. <br><br>  The first attempts to implement a cluster version of SAMBA were simply to place files containing TDB on a cluster file system, such as GPFS or Luster. <br><br>  Such SAMBA implementations worked, but were extremely slow.  The reduction in speed was due to high overhead and latency in the synchronization protocols of cluster file systems.  At the same time, in order for Samba to work successfully, it is necessary to provide very fast access to TDB. <br><br>  The foundation of the functioning of cluster file systems is that they prevent data from being lost.  Even if the client started recording data, and the node where it was supposed to be recorded, failed, they will not be lost. <br><br>  Thus, the cluster file system must either write data to the shared storage or send changes to all nodes of the cluster. <br><br>  However, this statement is not quite true for Samba metadata.  In a certain situation, the loss of this data will not affect the ability to perform the necessary semantics conversion between CIFS and POSIX. <br><br>  Thus, it becomes possible to implement a cluster system that does not require shared storage of metadata and data replication when writing. <br><br>  Just say that this does not apply to all metadata. <br><br>  There are two types of TDB databases - permanent and non-permanent. <br><br>  <b>Permanent</b> (Persistent) - contain long-term information that should be preserved even after a restart.  These databases are more often used for reading than for writing.  The speed of access to write to this type of database is not critical.  The main thing here is reliability. <br><br>  <b>Non</b> - <b>persistent</b> ‚Äî such as a lock or session database.  The data stored here has a short life cycle.  The frequency of writing to these databases is very high.  They are also often referred to as ‚Äúnormal TDB.‚Äù <br><br>  For successful Samba operation, high performance is especially important when working with ‚Äúnormal TDB‚Äù. <br><br>  Loss of information is possible only for non-permanent databases. <br><br>  The tables below list and describe the bases used in the cluster implementation of Samba. <br><br>  <strong>Table 1 Constant (Persistent) TDB Base</strong> <table border="1"><tbody><tr><td>  <strong>Name</strong> </td><td>  <strong>DESCRIPTION</strong> </td></tr><tr><td>  <strong>account_policy</strong> </td><td>  Samba / NT account policy settings, including password expiration settings. </td></tr><tr><td>  <strong>group_mapping</strong> </td><td>  Table of group mapping / SID Windows groups UNIX. </td></tr><tr><td>  <strong>passdb</strong> </td><td>  Exists only when using tdbsam.  This file stores SambaSAMAccount information.  It must be remembered that this file requires that information about POSIX user accounts is available from the / etc / passwd file, or from another system source. </td></tr><tr><td>  <strong>registry</strong> </td><td>  A read-only Samba database that stores the skeleton of the Windows registry, which provides support for exporting various database tables through winreg RPC (remote procedure calls). </td></tr><tr><td>  <strong>secrets</strong> </td><td>  This file stores the SID of the workgroup / domain / computer, the LDAP directory update password, and other important environmental information that Samba needs to work.  This file contains very important information that needs to be protected.  It is stored in the PRIVATE_DIR directory. </td></tr><tr><td>  <strong>share_info</strong> </td><td>  Stores the ACL information for each resource. </td></tr><tr><td>  <strong>Idmap2</strong> </td><td>  IDMAP Winbindd Database. </td></tr></tbody></table><br><br>  <strong>Table 2 Temporary (Normal) TDB Bases</strong> <table border="1"><tbody><tr><td>  <strong>Name</strong> </td><td>  <strong>DESCRIPTION</strong> </td></tr><tr><td>  <strong>brlock</strong> </td><td>  Information about locking byte ranges. </td></tr><tr><td>  <strong>Locking</strong> </td><td>  File system lock table </td></tr><tr><td>  <strong>connections</strong> </td><td>  A temporary cache of current connection information used to track the maximum number of connections. </td></tr><tr><td>  <strong>Notify_onelevel</strong> </td><td>  Presumably used for messaging between ctdb daemons </td></tr><tr><td>  <strong>notify</strong> </td><td>  Presumably used for messaging between ctdb daemons </td></tr><tr><td>  <strong>sessionid</strong> </td><td>  Temporary cache for various utmp session information and maintenance. </td></tr></tbody></table><br><br>  Thus, we see what information we can lose.  This is information about sessions, locks, as well as, apparently (no data on the Internet), specific information necessary for the operation of the cluster. <br><br>  When a node fails, all open files on it will be closed, respectively, the loss of the above information will not be critical. <br><br><h4>  CTDBD daemon and TDB database operation in a cluster </h4><br>  The key component in the Samba cluster is the CTDBD daemon.  It provides support for a cluster version of the TDB database, called CTDB (Cluster Trivial DataBase), with the possibility of automatic recovery. <br><br>  CTDBD also monitors the cluster nodes and performs its automatic reconfiguration in case of failure. <br>  Providing load balancing is another CTDBD task. <br><br>  Depending on the type of database, it is processed differently. <br><br><h5>  Work with temporary TDB </h5><br>  A key feature of temporary TDB is that they do not need to contain all the records within the cluster.  In most cases, temporary TDBs contain only entries related to the connections of this particular node.  Accordingly, when it falls, only this data will be lost. <br><br>  The CTDB system uses a distributed protocol for operations on metadata databases between the CTDBD daemons on each node, as well as a local protocol for intra-node communication between the Samba daemons and the CTDBD daemons. <br><br>  The CTDB design uses a two-tier record storage system.  At the first level, the location master is defined for each entry.  This host is attached to the record by its key. <br><br>  At the second level, the roving "data master" (roaming or roaming data master) is defined.  This is the last node that modified the record. <br><br><img src="https://habrastorage.org/storage2/58c/096/621/58c096621bb5ce95530d0f06427cf0eb.png"><br><br>  The ‚ÄúLocation master‚Äù always knows on which node the record is located and, accordingly, which node is the ‚Äúdata master‚Äù.  The ‚Äúdata master‚Äù in turn contains the most current copy of the record. <br><br>  Each record contains a global sequence number - RSN (record sequence number) - a 64-bit integer that is incremented each time the ‚Äúdata master‚Äù is moved from one node to another.  The change of ownership of the ‚ÄúData Master‚Äù entry always occurs via the ‚ÄúLocation master‚Äù. <br><br>  The node contains only those records in the local TDB to which it already had access.  Data is not automatically distributed to other nodes, and can be transferred only on request. <br><br>  Only one node contains the current copy of the record - ‚ÄúData Master‚Äù.  When a node wants to write or read a record, it first checks whether it is a ‚Äúdata master‚Äù for that node.  If so, it records directly in TDB.  If not, then it requests the current contents of the record from the current data master, takes the data master role for itself and then makes a direct recording. <br><br>  Thus, writing and reading data always happens locally, which significantly improves performance. <br><br>  When a node dies, the records for which it was a ‚Äúdata master‚Äù are lost. <br><br>  CTDBD starts the recovery process.  To do this, select the node master of the recovery process - ¬´recovery master¬ª.  After a node is selected, on the cluster file system, it sets a lock on a specific file (which is specified in the configuration) so that other nodes can no longer claim the role of ‚Äúrecovery master‚Äù. <br><br>  Recover Master collects the most current versions of records from all sites.  Relevance is determined by the RSN value.  The most relevant is a record with a large RSN. <br><br><h5>  Work with constant TDB </h5><br>  For this database, each node always has a complete, up-to-date copy of the database. <br><br>  Reading is always from a local copy.  When a node needs to write, it performs a transaction that completely blocks the entire database on all nodes. <br><br>  Then he performs the necessary write operations.  After that, the changes are written to the local copies of the database on all nodes and the transaction is completed. <br><br>  Thus, on all nodes of the cluster always contains a complete and current copy of the database.  Delays that occur during the synchronization process are not critical, due to the non-high frequency of changes in these databases. <br><br>  If one of the nodes fails, all the necessary information is on the rest of the cluster members. <br><br><h4>  Network failure protection mechanism </h4><br>  In addition to protecting metadata databases, CTDBD uses an integrated TCP / IP protocol failover protection mechanism. <br>  It consists of using a cluster of a set of public IP addresses that are distributed among the cluster nodes.  These addresses can be transferred from node to node by updating the Address Resolution Protocol (ARP). <br><br>  In case of failure of a node, all its public ip addresses will be transferred to the working nodes. <br><br>  Public are the addresses through which the customer calls.  For communications between the nodes of the cluster, internal ip addresses are used. <br><br>  The host that took over the IP address of the other knows only what they were about old TCP connections, and does not know the ‚ÄúTCP squence number‚Äù connections.  Accordingly, they can not continue.  As well as the client, does not know anything about the fact that connections are now made with another node. <br><br>  In order to avoid delays associated with switching the connection, the following method is used.  To understand this technique, you need to understand the basic principles of the TCP protocol. <br><br>  The new node, receiving its ip address, sends the client a packet with the ACK flag and the deliberately incorrect ‚ÄúSquence number‚Äù equal to zero.  In response, the client, in accordance with the rules of the TCP protocol, sends back an ACK Reply packet with the correct ‚Äúsquence number‚Äù.  Having received the correct ‚Äúsquence number‚Äù node forms a packet with the RST flag and this ‚Äúsquence number‚Äù.  Upon receiving it, the client immediately restarts the connection. <br><br>  Delays are very minimal.  Without using this technique, the client can wait for a long time from the server of the TCP ACK packet. <br><br><h4>  On practice </h4><br>  As mentioned above, if one of the nodes fails and the ip address is transferred, the entire responsibility for continuing work after the failure lies with the client.  All open files associated with the failed node are closed. <br><br>  If you copy or read any file in Windows Explorer, then you will get an error if it fails.  However, if you use tools that can re-connect after losing the connection, everything will go smoothly.  For example, the xcopy utility with the ‚Äú/ z‚Äù key.  When copying files using this utility, you will get only a small delay at the time of switching the ip address.  Then, continue copying. <br><br>  Connection to network resources is also not lost. <br><br>  If you open any file in the editor, and the moment of saving does not occur at the ip address relocation, then the failures also do not affect the work. <br><br>  Thus, part of the responsibility for restoring work after a failure in this case is transferred to the client. <br>  Configuring Samba Cluster <br><br>  Setting up a cluster consists of two steps: <br><ul><li>  Configuring the Samba daemon to work in a cluster </li><li>  CTDB Setup </li></ul><br><br><h4>  Configuring Samba and Related Services </h4><br><br>  Starting with version 3.3, Samba source tests have built-in clustering support.  However, to work in a cluster, you must compile the package using special keys. <br><br>  From <a href="http://enterprisesamba.com/">enterprisesamba.com</a> you can download a compiled version of Samba with clustering support for popular distributions: RHEL, SLES, Debian. <br><br>  Important note.  In order for Windows clients to successfully authenticate to the Samba cluster, it is advisable to use external authorization.  For example, through Active Directory. <br><br>  For Windows users accessing the Posix file system, Samba establishes a correspondence between the Windows user and the POSIX system user (for example, Linux).  A Windows user must access the POSIX file system from the name of any known POSIX user‚Äôs operating system.  Windows user authorization occurs regardless of user authorization in the POSIX OS. <br><br>  Those.  In order for a Windows user to access, you must: <br><ul><li>  Create a local user in POSIX operating system on behalf of which the Windows user will work </li><li>  Create a Windows user in the Samba database and set a password for it </li><li>  Establish communication between these users. </li></ul><br><br>  The table of relationships between users and passwords can be stored in the CTDB database and distributed within the cluster.  However, the local user base does not have this capability.  Those.  Every time we create users in Samba, we will need to create corresponding local accounts on all nodes in the cluster. <br><br>  It is not comfortable.  In order to avoid this, it makes sense to use an external database in conjunction with the local user base.  In our case, integration with Active Directoty is used.  Samba cluster is a member of the domain. <br><br>  In the /etc/nsswitch.conf file you need to register: <br>  passwd: files winbind <br>  group: files winbind <br>  shadow: files winbind <br><br>  This means that in addition to local files, the search for users and groups will be carried out in the Active Directory through winbind.  The winbind service allows Windows domain users to authenticate on Unix machines.  Thus, transparent access control is performed. <br>  Authorization in the Active Directory domain is carried out using the Kerberos protocol.  You must make the appropriate settings for the Kerberos library - /etc/krb5.conf. <br><br>  [logging] <br>  default = FILE: /var/log/krb5libs.log <br>  kdc = FILE: /var/log/krb5kdc.log <br>  admin_server = FILE: /var/log/kadmind.log <br><br>  [libdefaults] <br>  default_realm = IT-DYNAMICS.RU - Active Directory Domain <br>  dns_lookup_realm = true - eliminates the need to manually register the server <br>  dns_lookup_kdc = true - eliminates the need to manually register the server <br>  ticket_lifetime = 24h <br>  forwardable = yes <br><br>  [domain_realm] <br>  .it-dynamics.ru = IT-DYNAMICS.RU <br>  .it-dynamics.ru = IT-DYNAMICS.RU <br><br>  [appdefaults] <br>  pam = { <br>  debug = false <br>  ticket_lifetime = 36000 <br>  renew_lifetime = 36000 <br>  forwardable = true <br>  krb4_convert = false <br>  } <br>  And finally, you need to configure Samba itself. <br>  [global] <br>  clustering = yes <br>  netbios name = smbcluster <br>  workgroup = otd100 <br><br>  security = ADS <br>  realm = IT-DYNAMICS.RU <br>  encrypt passwords = yes <br>  client lanman auth = no <br>  client ntlmv2 auth = yes <br><br>  passdb backend = tdbsam <br>  groupdb: backend = tdb <br>  idmap backend = tdb2 <br>  idmap uid = 1000000-2000000 <br>  idmap gid = 1000000-2000000 <br>  fileid: algorithm = fsname <br>  vfs objects = gpfs ‚Äã‚Äãfileid <br>  gpfs: sharemodes = No <br>  force unknown acl user = yes <br>  nfs4: mode = special <br>  nfs4: chown = yes <br>  nfs4: acedub = merge <br>  registry shares = yes <br><br>  The key parameter in /etc/samba/smb.conf is ‚Äúclustering = yes‚Äù.  Enable clustering support.  In the parameters "netbios name" we register the name of our cluster, which will be common to all nodes. <br><br>  In order to implement transparent management of shared resources, it is necessary to enable registry - ‚Äúregistry shares = yes‚Äù in the Samba settings.  Otherwise, if the settings of public folders are contained in smb.conf, we will be forced to synchronize this file between all nodes in the cluster. <br><br>  In any case, ‚Äú/etc/samba/smb.conf‚Äù should be the same on all nodes. <br><br>  To successfully authorize users, a Samba cluster must be entered into an Active Directory domain with the command: net ads join -U Administrator <br>  Where is ‚ÄúAdministrator‚Äù, a user with rights to add computers to the domain. <br><br><h4>  CTDB Setup </h4><br>  CTDB is delivered as a separate package.  Source code can be downloaded from <a href="http://ctdb.samba.org/">ctdb.samba.org</a> .  There are also compiled versions for RHEL x64.  For x86, you can download src.rpm and compile it yourself. <br><br>  The CTDB parameters are in the /etc/sysconfig/ctdb.conf file. <br><br>  This file should also be the same on all nodes of the cluster. <br><br>  The most important parameters: <br><br>  CTDB_RECOVERY_LOCK = / gpfs-storage / ctdb / lock <br>  Specifies the location of the lock file that is used when selecting ‚Äúrecovery master‚Äù when recovering from a crash.  Must be located on a cluster file system with lock support. <br><br>  CTDB_PUBLIC_INTERFACE = eth1 <br>  The interface through which clients will interact with the cluster. <br><br>  CTDB_PUBLIC_ADDRESSES = / etc / ctdb / public_addresses the path to the file containing the possible public ip addresses through which the cluster will be operated. <br><br>  CTDB_MANAGES_SAMBA = yes <br>  The CTDB daemon manages Samba services.  This is convenient for Samba to work correctly in a cluster.  CTDB will start or shut down Samba itself when necessary.  At the same time, Samba should be removed from startup. <br><br>  CTDB_MANAGES_WINBIND = yes <br>  Similar to the previous case - Winbind control. <br><br>  CTDB_NODES = / etc / ctdb / nodes <br>  List of internal addresses of the catch cluster.  The nodes file must be unique on all nodes. <br><br>  In the file / etc / ctdb / public_addresses it is necessary to register all possible public ip addresses for connecting clients. <br><br>  In the / etc / ctdb / nodes file, you need to register internal ip addresses of all cluster nodes. <br><br><h4>  Load balancing </h4><br>  There are two ways to load balance: <br><ol><li>  Using Round-Robin DNS </li><li>  Lvs </li></ol><br><br>  Immediately, we note that none of the methods allows balancing depending on server load.  Balancing by and large comes down to alternately redirecting clients to different nodes in the cluster. <br><br><h5>  Balancing Round-Robin DNS </h5><br>  In this case, several ip addresses are assigned to the DNS for a single cluster name.  When clients call, the DNS server in turn gives them different cluster ip addresses.  Thus, each next client connects to a new ip address and so on in a circle. <br><br><h5>  LVS Balancing </h5><br>  In this case, the entire cluster is presented to clients through one ip address.  One of the nodes is selected as LVSMaster.  It is assigned an ip address of the cluster.  All customers send a request to this address.  Then LVSMaster forwards the request to one of the nodes.  The node, in turn, directly responds to the client without the involvement of LVSMaster. <br><br>  A scheme using LVS can give very good results with multiple reads.  While in write operations, everything will rest on the speed and network bandwidth of LVSMaster. <br><br><h4>  Cluster management </h4><br>  Control is done using the ctdb command.  The default is run on the current node.  Using the "-n" key, you can specify another node. <br><br>  <b>Ctdb status</b> - shows the status of the cluster <br>  Number of nodes: 2 <br>  pnn: 0 172.0.16.101 OK <br>  pnn: 1 172.0.16.102 OK (THIS NODE) <br>  Generation: 985898984 <br>  Size: 2 <br>  hash: 0 lmaster: 0 <br>  hash: 1 lmaster: 1 <br>  Recovery mode: NORMAL (0) <br>  Recovery master: 0 <br><br>  The state of the node can be: <br><ul><li>  OK - normal operation </li><li>  DISCONNECTED - the node is not physically accessible. </li><li>  DISABLED - the node is disabled by the administrator.  At the same time, it functions within the cluster, but its public ip address is transferred to other nodes and no services on it are executed.  However, the node is able to serve parts of the TDB database. </li><li>  UNHEALTHY - problems in the work node.  The CTDB daemon is functioning normally, but the public ip is transferred to other nodes and no services are working. </li><li>  BANNED - Node made too frequent attempts to recover and was disabled for a certain period.  After the end of this period, the node will automatically try to return to the system. </li><li>  STOPPED - The node is stopped and does not participate in the cluster, but is able to receive control commands. </li><li>  PARTIALLYONLINE - The node is working, but some of the interfaces serving public ip addresses are disabled.  At least one interface must be available. </li><li>  Recovery mode - cluster operation mode: </li><li>  NORMAL - working mode </li><li>  RECOVERY - the cluster is in recovery mode.  All cluster databases are locked.  Services do not work. </li></ul><br><br>  RECOVERY MASTER ‚Äî The node selected by the Recovery Wizard. <br><br>  <b>Ctdb ip</b> shows public ip addresses of the cluster and their distribution among nodes <br><br>  Public IPs on node 1 <br>  128.0.16.110 node [1] active [eth0] available [eth0] configured [eth0] <br>  128.0.16.111 node [0] active [] available [eth0] configured [eth0] <br><br>  The first line is the current node on which the command is executed. <br><br>  <b>Ctdb pnn</b> - displays the node number on which the command is executed <br><br>  <b>Ctdb disable</b> - set the current node to Disable <br><br>  <b>Ctdb enable</b> - return from the Disable position <br><br>  <b>Ctdb stop</b> - move the current node to the Stop position (the cluster will reconfigure) <br><br>  <b>Ctdb continue</b> - return from the Stop position (the cluster will be reconfigured) <br><br>  <b>moveip public_ip node</b> manually transfers a public ip address from one node to another <br><br>  <b>ctdb getdbmap</b> - displays a list of CTDB databases. <br><br>  Number of databases: 13 <br>  dbid: 0x1c904dfd name: notify_onelevel.tdb path: /var/ctdb/notify_onelevel.tdb.0 <br>  dbid: 0x435d3410 name: notify.tdb path: /var/ctdb/notify.tdb.0 <br>  dbid: 0x42fe72c5 name: locking.tdb path: /var/ctdb/locking.tdb.0 <br>  dbid: 0x1421fb78 name: brlock.tdb path: /var/ctdb/brlock.tdb.0 <br>  dbid: 0xc0bdde6a name: sessionid.tdb path: /var/ctdb/sessionid.tdb.0 <br>  dbid: 0x17055d90 name: connections.tdb path: /var/ctdb/connections.tdb.0 <br>  dbid: 0xf2a58948 name: registry.tdb path: /var/ctdb/persistent/registry.tdb.0 PERSISTENT <br>  dbid: 0x63501287 name: share_info.tdb path: /var/ctdb/persistent/share_info.tdb.0 PERSISTENT <br>  dbid: 0x92380e87 name: account_policy.tdb path: /var/ctdb/persistent/account_policy.tdb.0 PERSISTENT <br>  dbid: 0x7bbbd26c name: passdb.tdb path: /var/ctdb/persistent/passdb.tdb.0 PERSISTENT <br>  dbid: 0x2672a57f name: idmap2.tdb path: /var/ctdb/persistent/idmap2.tdb.0 PERSISTENT <br>  dbid: 0xe98e08b6 name: group_mapping.tdb path: /var/ctdb/persistent/group_mapping.tdb.0 PERSISTENT <br>  dbid: 0xb775fff6 name: secrets.tdb path: /var/ctdb/persistent/secrets.tdb.0 PERSISTENT <br>  ctdb shutdown - stop the ctdb daemon (equivalent to service stdb stop) <br><br><h4>  Cluster Monitoring </h4><br>  In the folder "/ etc / ctdb" is the script "notify.sh".  It is called each time when the health condition of the node changes.  You can write to it, for example, sending an SNMP Trap or sending messages by email to the administrator. <br><br><h4>  Conclusion </h4><br><br>  The article showed the principles of organization of the Samba failover service.  Key points are: <br><ul><li>  The possibility of losing certain metadata without disrupting the process of converting CIFS to POSIX semantics </li><li>  Part of responsibility for continuing work after a failure has been transferred to the client‚Äôs side. </li><li>  Files opened on a cluster node are closed at the time of failure </li><li>  Load balancing is performed by successive redirection of clients to different nodes of the cluster, regardless of the load. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/91188/">https://habr.com/ru/post/91188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../91174/index.html">Count how much alcohol you drink</a></li>
<li><a href="../91175/index.html">Automatic switching of embedded and discrete graphics in MacBook Pro</a></li>
<li><a href="../91177/index.html">What infuriates the customer</a></li>
<li><a href="../91178/index.html">Are there people on Habr√© with their opinions?</a></li>
<li><a href="../91181/index.html">Created the first in Russia rating of popular blog entries on music</a></li>
<li><a href="../91190/index.html">Using Snapshots in Hyper-V</a></li>
<li><a href="../91193/index.html">Canobuvosti, 35th edition</a></li>
<li><a href="../91194/index.html">Tips & Tricks</a></li>
<li><a href="../91201/index.html">I didn‚Äôt expect it myself</a></li>
<li><a href="../91203/index.html">The serial number</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>