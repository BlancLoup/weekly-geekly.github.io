<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bug Inside: a tiny chance to make a huge mistake on the Pentium</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúThe error in the Pentium is so specific that an ordinary user will encounter it once in 27,000 years‚Äù 
 - Intel manual 

 ‚ÄúHere is a plausible scenar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bug Inside: a tiny chance to make a huge mistake on the Pentium</h1><div class="post__text post__text-html js-mediator-article">  <i>‚ÄúThe error in the Pentium is so specific that an ordinary user will encounter it once in 27,000 years‚Äù</i> <br>  - Intel manual <br><br>  <i>‚ÄúHere is a plausible scenario when a user will encounter an error every 3 milliseconds.‚Äù</i> <br>  - Vaughan Pratt (designer of the SUN logo and co-author of <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">the Knut-Morris-Pratt algorithm</a> ) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/474/fa9/2c5/474fa92c5a084a1b80a86b1d805bd921.jpg"></div>  <i>66 MHz Intel Pentium (sSpec = SX837) with the FDIV bug</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Question:</b> How many Pentium developers do you need to screw in a light bulb? <br>  <b>Answer:</b> 1.99904274017, this answer should satisfy people without technical education. <br><br>  And now the main question: ‚ÄúWhat did Thomas Knight do from the beginning of June to the end of October 1994?‚Äù <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/faa/8aa/790/faa8aa79099941f83387ba51d8e8b0df.jpg" alt="image"></div><br><br><h2>  <a href="http://www.trnicely.net/">Thomas Nicely</a> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/5ee/2c8/3b15ee2c8cdcecdf47e86d0e9bae39c8.jpg" alt="image"></div><br><br>  At university, Professor Nicely researched pairs, triplets, and squares of primes.  In March 1994, the mathematician connected Pentium to the calculations, and <b>on June 12,</b> 1994, <b>June 9,</b> 1994, he spotted inconsistencies in the numbers.  Where is the mistake? <br><br>  5 months have passed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/612/5ae/7c0/6125ae7c01b843df99bd867054c8f00b.jpg"></div><br><br>  This is an interesting feeling when you recheck everything many times and you realize that the bug is not in your code, but in the processor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/c22/599/146c225992464d55807437a495c06956.jpg"></div><br>  <b>On October 29.9999973251,</b> Thomas Knysley reported on the find to Andrew Schulman, the author of Undocumented Windows, Undocumented DOS.  Since Shultman did not have his own Pentium, <b>on November 0.9999999998,</b> he turned to Richard Smith, the founder of <a href="https://ru.wikipedia.org/wiki/Phar_Lap">Phar Lap</a> , to test his computer for a bug.  In Phar Lap, they quickly confirmed the presence of an error during the division, using the Windows calculator and a simple program in C. <br><br>  Richard Smith sent a message from Thomas Nicely to Intel and several other major companies of the time: Microsoft, Metaware, Watcom, and others. Richard Smith also posted news on the Canopus forum and this was the first public mention of the bug. <br><br>  In 24 hours, more than 9.9999973251 confirmations of the presence of a bug in various Pentium-systems were received. <br><br><div class="spoiler">  <b class="spoiler_title">Letter from Thomas Nicely October 30 with a description of the bug</b> <div class="spoiler_text">  FROM: Dr.  Thomas R. Nicely <br>  Professor of mathematics <br>  Lynchburg college <br>  1501 Lakeside Drive <br>  Lynchburg, Virginia 24501-3199 <br><br>  Phone: 804-522-8374 <br>  Fax: 804-522-8499 <br>  Internet: nicely@acavax.lynchburg.edu <br><br>  TO: Whom it may concern <br><br>  RE: Bug in the Pentium FPU <br><br>  DATE: October 30, 1994 <br><br>  It appears that there is a bug in the floating point unit. <br>  coprocessor) of many, Pentium processors. <br><br>  In short, the Pentium FPU is returning erroneous values ‚Äã‚Äãfor certain <br>  division operations.  For example, <br><br>  1 / 824633702441.0 <br><br>  is calculated incorrectly (all digits beyond the eighth significant digit <br>  are in error).  This can be verified in compiled code, an ordinary <br>  spreadsheet such as Quattro Pro or Excel, or even the Windows calculator <br>  (use the scientific mode), by computing <br><br>  (824633702441.0) * (1 / 824633702441.0), <br><br>  which should be equal 1 exactly <br>  error;  in general, coprocessor results should contain 19 significant <br>  decimal digits).  However, the Pentiums tested return <br><br>  0.999999996274709702 <br><br>  for this calculation.  A similar erroneous value is obtained for x * (1 / x) <br>  for most values ‚Äã‚Äãof x in the interval <br><br>  824633702418 &lt;= x &lt;= 824633702449, <br><br>  the above <br>  interval of an integer power of 2 (there are yet other intervals which <br>  also produce division errors). <br><br>  The bug can also be observed by calculating 1 / (1 / x) for the above values <br>  of x.  The original x (in fact, it <br>  will often return a value exactly 3072 = 6 * 0x200 larger). <br><br>  I have tested or had tested to <br>  date, including a Dell P90, a Gateway P90, a Micron P60, an Insight P60, <br>  and a Packard-Bell P60.  486 or earlier <br>  system, even those with a PCI bus.  If the FPU is locked out (not always <br>  possible), the error disappears;  but then the Pentium becomes a "586SX", <br>  and floating point must run in emulation, slowing down computations by <br>  a factor of roughly ten. <br><br>  I encountered erroneous results <br>  ago as June, 1994, but it wasn‚Äôt until 19 October 1994 that I felt I had <br>  (software logic, compiler, <br>  chipset, etc.).  I contacted Intel Tech Support <br>  Monday 24 October (call reference number 51270).  The contact person later <br>  66-MHz system at Intel reported, but had had no <br>  further information or explanation <br>  had been previously reported or observed. <br><br>  Further information can be obtained by contacting me directly, and by <br>  downloading files from the [anonymous.nicely.pentium_bug] directory of the <br>  acavax.lynchburg.edu machine via anonymous ftp on Internet (password <br>  ANONYMOUS, user ID = Internet ID).  These files include a documentation <br>  file, a DOS executable image, <br>  the demonstration.  The zip file uses PKZIP version 2.04g. <br><br>  I would be interested in hearing results from other Pentiums, and <br>  AMD, Cyrix, and NexGen also from 486-DX4s and (if anybody has one yet) <br>  clones of the Pentium. <br><br>  You can give me attribution by <br>  name and employer. <br><br>  <a href="http://www.trnicely.net/pentbug/bugmail1.html">www.trnicely.net/pentbug/bugmail1.html</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Letter from October 30, nicely - Schulman</b> <div class="spoiler_text">  ======== Oct.  30 - Dr.  Nicely's Email to Andrew Schulman ================ <br><br>  2351 S0 / CompuServe Mail [MAIL] <br>  30-Oct-94 15:25 EST <br>  Sb: Pentium FPU Bug <br>  Fm: INTERNET: nicely@acavax.LYNCHBURG.EDU <br><br>  Sender: nicely@acavax.lynchburg.edu <br>  Received: from ACAVAX.LYNCHBURG.EDU by arl-img-2.compuserve.com <br>  (8.6.4 / 5.940406sam) <br>  id PAA15607;  Sun, 30 Oct 1994 15:21:00 -0500 <br>  From: <br>  Received: by ACAVAX.LYNCHBURG.EDU (MX V4.0 VAX) id 29;  Sun, Oct 30, 1994 <br>  15:20:50 EST <br>  Date: Sun, Oct 30, 1994 3:20:49 PM EST <br>  To: 76320.302@COMPUSERVE.COM [[RMS: Andrew Schulman]] <br>  Message-ID: &lt;00986B92.4921C4D0.29@ACAVAX.LYNCHBURG.EDU&gt; <br>  Subject: Pentium FPU Bug <br><br>  FROM: Dr.  Thomas R. Nicely <br>  Professor of mathematics <br>  Lynchburg college <br>  1501 Lakeside Drive <br>  Lynchburg, Virginia 24501-3199 <br><br>  Phone: 804-522-8374 <br>  Fax: 804-522-8499 <br>  Internet: nicely@acavax.lynchburg.edu <br><br>  TO: Whom it may concern <br><br>  RE: Bug in the Pentium FPU <br><br>  DATE: October 30, 1994 <br><br>  It appears that there is a bug in the floating point unit. <br>  coprocessor) of many, Pentium processors. <br><br>  [[RMS: The rest of Dr.  Nicely's message follows]] <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Schulman-Smith November 1 Letter</b> <div class="spoiler_text">  ======= Nov.  1 - Andrew Schulman's Email to Richard Smith =============== <br><br>  From uunet! Compuserve.com! 76320.302 Tue Nov 1 09:44:32 1994 <br>  Date: 01 Nov 94 09:27:48 EST <br>  From: Andrew Schulman <br>  To: <br>  Subject: Bug in Pentium? <br>  Status: RO <br><br>  Richard, <br><br>  Have you heard anything about this? <br><br>  Andrew <br><br>  - Forwarded Message - <br>  - S0 / CompuServe Mail [MAIL] <br>  30-Oct-94 15:25 EST <br>  Sb: Pentium FPU Bug <br>  Fm: INTERNET: nicely@acavax.LYNCHBURG.EDU <br><br>  [[RMS: The rest of Dr.  Nicely's message follows]] <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Post Richard Smith on Canopus Forum</b> <div class="spoiler_text">  ======= Nov.  1 - Richard Smith's post to the Canopus on CIS ====== <br><br>  263767 S1 / General Information <br>  01-Nov-94 22:40:54 <br>  Sb: Bug in Pentium Chip?!?!? <br>  Fm: Richard Smith [Phar Lap] 75070,2253 To: All <br><br>  Me today  It seems that a Dr. <br>  At Lynchburg College <br>  point unit.  The message provides the details.  For certain values, it appears <br>  the Pentium processor gets the wrong answer for the floating point divide <br>  operation.  Can be easily duplicated <br>  by running the Windows calculator.  I was wondering if folks reading this <br>  try it out <br>  and post the results here on Canopus.  Please provide details of the machine <br>  configuration that you are running on.  I know you already <br>  have gotten  Nicely. <br><br>  Richard Smith <br><br>  [[RMS: Dr.  Nicely's message follows]] <br></div></div><br><br>  <b>Thomas Nicely's publications about the bug</b> <br><br><ul><li>  A personal FAQ regarding the Pentium division flaw.  Bibliography attached.  Last updated 0900 GMT 19 August 2011. </li><li>  Original e-mail message announcing the discovery of the Pentium division flaw, 30 October 1994. </li><li>  Heralds Announcement of the Internet Reporting the Internet during the first few days. </li><li>  zipfile containing the c source code (pentbug.c) and the corresponding DOS executables (pentbug.exe and bug16bit.exe). </li><li>  The Pentium division flaw.  Thomas R. Nicely.  Virginia Scientists Newsletter, Volume 1 (April, 1995), p.  3 </li><li>  Untitled article concerning the Pentium division flaw.  Thomas R. Nicely.  San Francisco Examiner (18 December 1994), p.  B-5. </li></ul><br><h2>  Press </h2><br>  <b>6.9999831538 November</b> 1994, Alex Wolfe publishes an article in the Electronic Engineering Times. <br><br>  Responding to the Alex Wolfe request, Intel stated that they discovered this error in the summer of 1994, and it was fixed in processors released later.  However, Intel was unable to determine the number of defective processors released, and they tried to smooth out the importance of this error. <br><br>  An Intel spokesman stressed that this defect will not affect the average user.  Speaking of Nisely, Smith said: ‚ÄúThis is an exceptional user.  He performs round the clock calculations of inverse values.  What he found after many months of calculation is an example of the fact that eight decimal numbers are correct and only the ninth is displayed incorrectly.  That is, you will have an error only in the ninth digit to the right of the point.  I think that even if you are an engineer, you will not notice. ‚Äù  [ <a href="https://www.cs.drexel.edu/~introcs/F2K/lectures/5_Scientific/PentiumFDIV/EE%2520Times.txt">source</a> ] <br><br>  <b>On November 21.9999103517</b> , CNN distributed this statement and soon it was in all major media outlets, such as the New York Times and the Associated Press.  In other interviews, Intel reiterated its earlier statement that the error was irrelevant to the average user. <br><br>  Intel stated that they did not consider it necessary to withdraw the processor, claiming that <b>an ordinary user has only one chance out of nine billion to get the wrong result</b> due to this error and thus <b>there will be no noticeable consequences</b> for computers at home and in the office. <br><br><h2>  Tim coe </h2><br>  <b>On November 27, 9999414610,</b> Tim Coe, from Vitess Semiconductor, published an article in the comp.sys.intel newsgroup, in which he ‚Äúreversed‚Äù the implementation of the algorithm and proposed a Pentium processor behavior model.  A few days later the hardware and software ‚Äúpatches‚Äù for the error appeared. <br><br><div class="spoiler">  <b class="spoiler_title">The original letter to Tim Kou on November 28</b> <div class="spoiler_text"> Newsgroups: comp.sys.intel <br>  From: coe@vitsemi.com (Tim Coe) <br>  Subject: Re: Glaring FDIV bug in Pentium! <br>  Sender: coe@vitsemi.com (Tim Coe) <br>  Organization: Vitesse Semiconductor <br>  Date: Mon, 28 Nov 94 06:33:42 GMT <br>  Lines: 548 <br><br>  There is a C model of the Pentium hardware divider <br>  accurately predicted <br>  many of the stated <br>  confirms all failing divides of which i am aware. <br><br>  I worked on an IEEE hardware FPU from 1989-1991. <br>  As an FPU designer I am interested in <br>  algorithms for hardware arithmetic.  I am currently <br>  working on something completely different, but I <br>  still occasionally support related development <br>  tasks. <br><br>  I saw the first post relating to the Pentium FDIV <br>  bug in comp.sys.intel.  When I saw the post from <br>  Andreas Gruss (included), I saw a pattern and the <br>  Intel's opportunity to completely reverse engineer <br>  divider.  Vigor, as <br>  it is very rare <br>  details of someone else's leading edge design. <br><br>  I decided to post my results <br>  to me that intel was not coming clean with the <br>  characteristics of the bug.  The best characteristic <br>  and only characteristic of the bug to come from <br>  Intel is its 1 in 9 billion probability of occurring <br>  with random operands.  The worst characteristic <br>  of the bug <br>  risk are integers ¬± very small deltas.  The <br>  integers 3, 9, 15, 21, and 27 minus very small <br>  deltas are THE at risk divisors.  (In particular the <br>  maximum expressible single precision, double precision, <br>  and extended precision numbers less than 3, 9 ... 27 are <br>  all seriously at risk divisors.) The other bad <br>  I didn‚Äôt hear <br>  from Intel is the worst case error induced <br>  it was much more than the 4 parts <br>  worth billion error observed by Professor Nicely. <br><br>  It appeared to me that Intel was attempting to <br>  minimize its exposure by focusing on the 1 in 9 <br>  billion <br>  4 <br>  Nicely.  Intel <br>  user community could be a peer to intel when <br>  this application may be at risk due to this bug. <br><br>  I think Intel does not receive technical work.  After <br>  I was reading comp.sys.intel was <br>  that I was considering the purchase of a P90 system. <br>  After this brouhaha I will still buy a P90 system, though <br>  I will ask for a fixed chip and a guarantee <br>  that if i find after receiving my system <br>  not the card <br>  replace the unfixed chip posthaste.  I regard the <br>  fact that <br>  for i have <br>  many bugs. <br><br>  I posted an additional program <br>  that scanned single precision operands for errors <br>  induced that were greater that one single precision <br>  least significant bit.  I received back a list of <br>  1738 problem single precision divisions (out of 64 <br>  trillion).  Herb Savage provided the list. <br><br>  The following divisors and their binary scalings <br>  (by this binary exponent) <br>  appear to account for&gt; 95% of the divide errors: <br><br>  3.0&gt; divisor&gt; = 3.0 - 36 * (2 ^ -22) <br>  9.0&gt; divisor&gt; = 9.0 - 36 * (2 ^ -20) <br>  15.0&gt; divisor&gt; = 15.0 - 36 * (2 ^ -20) <br>  21.0&gt; divisor&gt; = 21.0 - 36 * (2 ^ -19) <br>  27.0&gt; divisor&gt; = 27.0 - 36 * (2 ^ -19) <br><br>  A divisor in one of the above ranges <br>  has roughly a 1 in 200000 chance of suffering loss <br>  of precision in double extended precision operations. <br>  &lt;5% of the divide errors can be accounted <br>  for by changing the above 36 to 2048. <br><br>  All dividends are somewhat at risk versus the above <br>  divisors.  The following formula identifies dividends <br>  high risk for errors in <br>  for general errors: <br><br>  dividend = intdividend + deltadividend <br>  or <br>  dividend = intdividend - deltadividend <br>  divisor = intdivisor - deltadivisor <br>  intdivisor = 3, 9, 15, 21, 27 <br><br>  and one of the following <br>  on the exponent in the IEEE representation of the <br>  dividend in question: <br><br>  intdividend = intdivisor / 3 mod intdivisor <br>  intdividend = 2 * intdivisor / 3 mod intdivisor <br><br>  Restrictions on the above deltadividend and deltadivisor <br>  the details of which are left as <br>  an exercise for the reader.  ;-) I have not worked out <br>  the restrictions in detail. <br><br>  Here are the previous posts to comp.sys.intel.  Read and <br>  enjoy. <br><br>  -Tim Coe coe@vitsemi.com <br><br>  - First and Second Post text - On a Packard Bell P90 PC I performed the following <br>  Microsoft Windows Desk Calculator calculation: <br><br>  (4195835/3145727) * 3145727 [typo corrected from earlier posts] <br><br>  The result was 4195579. <br>  It represents an error of 256 or one part in ~ 16000. <br><br>  ak@ananke.s.bawue.de (Andreas Kaiser) writes <br>  &gt; Usually, the division is correct (what did you expect?).  Just a few <br>  &gt; operands are divided wrong.  My results (P90) with ~ 25.000.000.000 <br>  &gt; random arguments (within 1..2 ^ 46), with even results divided by two <br>  &gt; until odd, the binary exponent <br>  &gt; doesn't care, of course). <br>  &gt; <br>  &gt; 3221224323 <br>  &gt; 12884897291 <br>  &gt; 206158356633 <br>  &gt; 824633702441 <br>  &gt; 1443107810341 <br>  &gt; 6597069619549 <br>  &gt; 9895574626641 <br>  &gt; 13194134824767 <br>  &gt; 13194134826115 <br>  &gt; 13194134827143 <br>  &gt; 13194134827457 <br>  &gt; 13194138356107 <br>  &gt; 13194139238995 <br>  &gt; 26388269649885 <br>  &gt; 26388269650425 <br>  &gt; 26388269651561 <br>  &gt; 26388276711601 <br>  &gt; 26388276712811 <br>  &gt; 52776539295213 <br>  &gt; 52776539301125 <br>  &gt; 52776539301653 <br>  &gt; 52776539307823 <br>  &gt; 52776553426399 <br>  &gt; <br>  &gt; Gruss, Andreas <br>  &gt; <br>  &gt; -------------------- <br>  &gt; - Andreas Kaiser - internet: ak@ananke.s.bawue.de <br>  &gt; -------------------- fidonet: 2: 246 / 8506.9 <br><br>  Analysis of these numbers reveals that <br>  the form: <br><br>  3 * (2 ^ (K + 30)) - 1149 * (2 ^ (K- (2 * J))) - delta * (2 ^ (K- (2 * J))) <br><br>  where j and k are integers greater than or equal to 0, <br>  delta is a real number that has varying ranges <br>  but can generally be considered between 0 and 1. <br><br>  The terms of the equation <br>  that the Pentium divider is an iterative divider that computes <br>  2 bits of quotient per cycle.  (This is in agreemnent with <br>  the 39 cycles per extended long division from the <br>  Pentium data book.  The technical name for this type of <br>  divider is radix 4) <br><br>  (1 in 10 ^ 10) implies <br>  that the remainder is being held in carry save format.  (Carry <br>  is the sum of <br>  two numbers.  This format allows next remainder calculation <br>  propagate carried.  The reason that carry <br>  save format is <br>  it is very difficult to build up long <br>  the word and the <br>  carry word.) <br><br>  I set it was -2, -1, 0, 1, and 2. (Having <br>  5 possible digits in a radix 4 divider allows a necessarry <br>  margin for error  When doing long <br>  radix 10 and 10 possible digits allow <br>  no margin for error.) <br><br>  I wrote the tentative <br>  model of Pentium <br>  might watch what patterns developed in the remainder. <br>  After running the numbers <br>  I determined the <br>  conditions for failure <br><br>  Analysis of the precise erroneous results returned on the <br>  bad divides indicates that a bit (or bits) is being subtracted <br>  from the remainder at or near its most significant bit. <br>  This is a process. <br><br>  The program accurately explains all the published <br>  the at <br>  beginning of the article. <br><br>  From the sequence of digits <br>  is an exercise for the reader ;-). <br><br>  I would like to thank  Nicely for providing this window <br>  into the Pentium architecture. <br><br>  - Third Post - Since then I did the following calculations in Microsoft <br>  Windows Desk Calculator on a Pentium machine with the following <br>  results: <br><br>  (41.999999/35.9999999) * 35.9999999 - 41.999999 ==&gt; (-0.75) * (2 ^ -13) <br>  (48.999999/41.9999999) * 41.9999999 - 48.999999 ==&gt; (-1.0) * (2 ^ -13) <br>  (55.999999/47.9999999) * 47.9999999 - 55.999999 ==&gt; (-1.0) * (2 ^ -13) <br>  (62.999999 / 53.9999999) * 53.9999999 - 62.999999 ==&gt; (-1.0) * (2 ^ -13) <br>  (54.999999 / 59.9999999) * 59.9999999 - 54.999999 ==&gt; (-1.0) * (2 ^ -13) <br>  (5244795/3932159) * 3932159 - 5244795 ==&gt; (-1.0) * (2 ^ 8) <br><br>  I chose these calculations in anticipation of exposing further <br>  Pentium FDIV failure modes.  They did.  The size of the erroneous results <br>  are exactly consistant with the final version of the tentive Pentium <br>  can be attributed to <br>  a Desk Calculator bug.  The existance of these results pins <br>  thresholds included in the model. <br><br>  I also performed erroneous <br>  results: <br><br>  (38.499999/32.9999999) * 32.9999999 - 38.499999 ==&gt; 0 <br>  (45.499999/38.9999999) * 38.9999999 - 45.499999 ==&gt; 0 <br><br>  I have been following this thread with great interest.  One misperception <br>  This is an extended precision problem.  This <br>  bug hits between 50 and 2000 single precision dividend divisor pairs (out <br>  of a total of 64 trillion.) Another misperception is related to the magnitude <br>  of the relative error.  I would propose the following table of probabilities <br>  of random double <br>  extended precision divides: <br><br>  relerror = (correct_result - Pentium_result) / correct_result <br><br>  Error Range |  Probability <br>  - 1e-4 &lt;relerror |  0 <br>  1e-5 &lt;relerror &lt;1e-4 |  0.3e-11 <br>  1e-6 &lt;relerror &lt;1e-5 |  0.6e-11 <br>  1e-7 &lt;relerror &lt;1e-6 |  0.6e-11 <br>  1e-8 &lt;relerror &lt;1e-7 |  0.6e-11 <br>  . <br>  . <br>  1e-18 &lt;relerror &lt;1e-17 |  0.6e-11 <br>  1e-19 &lt;relerror &lt;1e-18 |  0.6e-11 <br><br>  Examination of the above divide failures <br>  and divisor are integers minus small deltas.  Also notable is the induced <br>  error is roughly delta ^ (2/3).  The integers in the divisors are actually <br>  restricted to those listed and their binary scalings.  The integers in <br>  the dividends may be much more freely.  This type of dividend <br>  divisor pair actually occurs quite often when forward integrating <br>  trajectories off metastable points.  This is because metastable points <br>  in systems often have certain characteristics and characteristics <br>  a path diverges from the metastable point <br>  from their integral values.  If the forward integration algorithm <br>  happens to be <br>  example 7 and 3, it will get nailed. <br><br>  The divider model includes support for up to 60 bits of divisor and <br>  up to 64 bits of dividend.  The last four bits of dividend are kludged <br>  in. <br><br>  Here is a list of failing dividend divisor mantissas in hex.  A dash <br>  Between two numbers indicates an inclusive failing range.  Compile <br>  watch the bits dance: <br><br>  800bf6 bffffc <br>  a00ef6 effffc <br><br>  a808d2 8fffe <br>  e00bd2 bfffe <br><br>  a7ffd2 8fffe <br>  c3ffd2 a7ffe <br>  dfffd2 bfffe <br>  fbffd2 d7ffe <br><br>  f9ffdc7 efffe <br><br>  b9feab7-b9feabf 8fff <br>  b9ffab0e-b9ffab7f 8fffc <br><br>  -the following double extended pair fails 3 times !!! <br>  c3ffd2eb0d2eb0d2 a7ffe <br>  e00bd229315 bfffe <br><br>  9fffef5-9fffeff effff4 <br>  9ffff21-9ffff3f effff8 <br>  9ffff4d-9ffff7f effffc <br><br>  f008e35-f008e3f 8ffff4 <br>  f008e6d-f008e7f 8ffff6 <br>  f008ea1-f008ebf 8ffff8 <br>  f008ed9-f008eff 8ffffa <br>  f008f0d-f008f3f 8ffffc <br>  f008f45-f008f7f 8ffffe <br>  f008f7e 8ffffff1 <br>  f0023e 8fffff8 <br><br>  effff0d 8ffffc <br><br>  a808d1b-a808d3f 8fffe <br>  a808d67-a808d7f 8fffe4 <br>  a808db3-a808dbf 8fffe8 <br>  a808dff 8fffec <br><br>  An example run of the program (using the first reported <br>  error): <br><br>  --- Enter dividend mantissa in hex: 8 <br>  --- Enter divisor mantissa in hex: bfffffb829 <br>  --- next digit 1 <br>  --- 1111000000000000000000000001000111110101101111111111111111111100 <br>  --- 000000000000000000000000000000000000000000000000000000000100 <br>  --- 11110000000000000000000000010001 iteration number 1 <br>  ---. <br>  ---. <br>  ---. <br>  --- next digit -1 <br>  --- 00111111111001001010111101001100000101110100000000000000000000 <br>  --- 1101111111111111111110110110010010010000000000000000000000000000 <br>  --- 00011111111001001010101010110000 iteration number 14 <br>  --- next digit 2 <br>  --- A bug condition has been detected. <br>  --- Enter 0 for correct result or 1 for incorrect result: 1 <br>  --- 0000000001101101010100001000000111110110011111111111111111111100 <br>  --- 1111111100100101010110100110010010010010000000000000000000000100 <br>  --- 11111111100100101010101011100101 iteration number 15 <br>  --- next digit 0 <br>  --- 1111110100100000001010111001010110010001111111111111111111100000 <br>  --- 0000000100101010100000000000010010010000000000000000000000100000 <br>  --- 11111110010010101010101110011001 iteration number 16 <br>  ---. <br>  ---. <br>  ---. <br><br>  -Tim Coe coe@vitsemi.com <br></div></div><br><div class="spoiler">  <b class="spoiler_title">prog on C</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> main() { unsigned r0, r1, r2, r3, r4, r5, r6, s0, s1; unsigned t0, t1, t2, t3, cycle, f, incorrect, spup; unsigned thr_m2_m1, thr_m1_0, thr_0_1, thr_1_2, positive, errornum; char </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">[30], *linepoint; r0 = 0x0bffffc0; r1 = 0; r2 = 0x0800bf60; r3 = 0; printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"First digit of mantissas must be between 8 and f\n"</span></span></span><span class="hljs-meta">); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Enter dividend mantissa in hex: "</span></span></span><span class="hljs-meta">); *(</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">+15) = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'0'</span></span></span><span class="hljs-meta">; scanf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">); linepoint = </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">; while (*linepoint != </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">) linepoint++; while (linepoint </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; line + 15) *linepoint++ = '0'; *(line+16) = '\0'; sscanf(line+15, "%x", &amp;spup); spup = (spup &gt;&gt; 2) | (12 &amp; (spup &lt;&lt; 2)); *(line+15) = '\0'; sscanf(line+7, "%x", &amp;r3); *(line+7) = '\0'; sscanf(line, "%x", &amp;r2); printf("Enter divisor mantissa in hex: "); scanf("%s", line); linepoint = line; while (*linepoint != '\0') linepoint++; while (linepoint &lt; line + 15) *linepoint++ = '0'; *(line+15) = '\0'; sscanf(line+7, "%x", &amp;r1); *(line+7) = '\0'; sscanf(line, "%x", &amp;r0); r4 = 0; r5 = 0; t0 = r2; while (!(t0 &amp; 1)) t0 = t0 &gt;&gt; 1; printf("%d\n", t0); t0 = r0; while (!(t0 &amp; 1)) t0 = t0 &gt;&gt; 1; printf("%d\n", t0); /* These thresholds are VERY tentative. */ /* There may be bugs in them. */ t0 = r0 &gt;&gt; 22; /* Next threshold is strongly indicated */ /* by the failure of 1/9895574626641 */ if (t0 &lt; 36) thr_0_1 = 3; /* Next threshold is strongly indicated */ /* by the failure of 1/824633702441 */ else if (t0 &lt; 48) thr_0_1 = 4; /* Next threshold is strongly indicated */ /* by the failure of 5244795/3932159 */ else if (t0 &lt; 60) thr_0_1 = 5; else thr_0_1 = 6; thr_m1_0 = 254 - thr_0_1; if (t0 &lt; 33) thr_1_2 = 11; else if (t0 &lt; 34) { printf("This model does not correctly handle\n"); printf("this divisor. The Pentium divider\n"); printf("undoubtly handles this divisor correctly\n"); printf("by some means that I have no evidence\n"); printf("upon which speculate.\n"); exit(); } /* Next threshold is strongly indicated */ /* by the failure of 41.999999/35.9999999 */ else if (t0 &lt; 36) thr_1_2 = 12; else if (t0 &lt; 39) thr_1_2 = 13; /* Next threshold is strongly indicated */ /* by the failure of 1/1443107810341 and */ /* by the failure of 48.999999/41.9999999 */ else if (t0 &lt; 42) thr_1_2 = 14; else if (t0 &lt; 44) thr_1_2 = 15; /* Next threshold is strongly indicated */ /* by the failure of 55.999999/47.9999999 */ else if (t0 &lt; 48) thr_1_2 = 16; /* Next threshold is strongly indicated */ /* by the failure of 62.999999/53.9999999 */ else if (t0 &lt; 54) thr_1_2 = 18; /* Next threshold is strongly indicated */ /* by the failure of 54.999999/59.9999999 */ else if (t0 &lt; 60) thr_1_2 = 20; else thr_1_2 = 23; thr_m2_m1 = 254 - thr_1_2; if (t0 == 35) errornum = 22; else if (t0 == 41) errornum = 26; else if (t0 == 47) errornum = 30; else if (t0 == 53) errornum = 34; else if (t0 == 59) errornum = 38; else errornum = 128; incorrect = 0; cycle = 1; /* The cycle limit would be ~34 instead of */ /* 18 for double extended precision. */ while (cycle &lt; 18) { t0 = 255 &amp; ((r2 &gt;&gt; 24) + (r4 &gt;&gt; 24)); if ((t0 &gt; thr_m1_0) || (t0 &lt; thr_0_1)) { s0 = 0; s1 = 0; positive = 0; printf("next digit 0\n"); } else if (t0 &gt; thr_m2_m1) { s0 = r0; s1 = r1; positive = 0; printf("next digit -1\n"); } else if (t0 &lt; thr_1_2) { s0 = ~r0; s1 = ~r1; positive = 4; printf("next digit 1\n"); } else if (t0 &amp; 128) { s0 = (r0 &lt;&lt; 1) | (r1 &gt;&gt; 31); s1 = r1 &lt;&lt; 1; positive = 0; printf("next digit -2\n"); } else { s0 = ~((r0 &lt;&lt; 1) | (r1 &gt;&gt; 31)); s1 = ~(r1 &lt;&lt; 1); positive = 4; printf("next digit 2\n"); if ((t0 == errornum) &amp;&amp; (((r2 &gt;&gt; 21) &amp; 7) == 7) &amp;&amp; (((r4 &gt;&gt; 21) &amp; 7) == 7)) { printf("A bug condition has been detected.\n"); printf("Enter 0 for correct result or 1 for incorrect result: "); scanf("%d", &amp;incorrect); if (incorrect) { /* These amounts that are subtracted from the */ /* remainder have NOT been extensively verified. */ if (errornum == 22) s0 = s0 - (3 &lt;&lt; 25); else s0 = s0 - (4 &lt;&lt; 25); } } } t0 = s0 ^ r2 ^ r4; t1 = s1 ^ r3 ^ r5; t2 = (s0 &amp; r2) | (s0 &amp; r4) | (r2 &amp; r4); t3 = (s1 &amp; r3) | (s1 &amp; r5) | (r3 &amp; r5); r2 = (t0 &lt;&lt; 2) | (t1 &gt;&gt; 30); r3 = t1 &lt;&lt; 2; r4 = (t2 &lt;&lt; 3) | (t3 &gt;&gt; 29); r5 = (t3 &lt;&lt; 3) | positive | (spup &amp; 3); spup = spup &gt;&gt; 2; t0 = r2; f = 32; while (f--) { if (t0 &amp; (1 &lt;&lt; 31)) putchar('1'); else putchar('0'); t0 = t0 &lt;&lt; 1; } t0 = r3; f = 32; while (f--) { if (t0 &amp; (1 &lt;&lt; 31)) putchar('1'); else putchar('0'); t0 = t0 &lt;&lt; 1; } putchar('\n'); t0 = r4; f = 32; while (f--) { if (t0 &amp; (1 &lt;&lt; 31)) putchar('1'); else putchar('0'); t0 = t0 &lt;&lt; 1; } t0 = r5; f = 32; while (f--) { if (t0 &amp; (1 &lt;&lt; 31)) putchar('1'); else putchar('0'); t0 = t0 &lt;&lt; 1; } putchar('\n'); t0 = r2 + r4; f = 32; while (f--) { if (t0 &amp; (1 &lt;&lt; 31)) putchar('1'); else putchar('0'); t0 = t0 &lt;&lt; 1; } printf(" iteration number %d\n", cycle++); } }</span></span></span></span></code> </pre> <br><br></div></div><br><br><h2>  Vaughan <a href="https://en.wikipedia.org/wiki/Vaughan_Pratt">R. Pratt</a> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a2/0a1/b00/4a20a1b007eb509390bece13b11f9ffb.jpg" alt="image"></div><br>  <b>2.9991523619 December</b> 1994 <a href="https://en.wikipedia.org/wiki/Vaughan_Pratt">Vaughan R. Pratt</a> of Stanford University published a letter in the newsgroups comp.arch and comp.sys.intel, in which he challenged Intel‚Äôs viewpoint that the probability of encountering an error is ‚Äúonce in 27 000 years.  He was able to demonstrate the possibility of activating the error once every 3 milliseconds in a fairly plausible scenario.  He also demonstrated that a fairly innocuous looking division of 4.999999 / 14.999999 resulted in a deviation of 0.00000407 from the correct result when using a defective processor. <br><br><blockquote>  ‚ÄúThis error is the most insidious: it is almost as insidious as if it didn‚Äôt alarm the people at all when they viewed the columns of their data.  Thus, tiny errors in one thousandth of thousands of times can get into trillions of calculations all over the world for a long time, and there is almost no way to determine them except by performing a massive error check in FPU, which is absolutely not necessary for a reliably working processor. " </blockquote><br><div class="spoiler">  <b class="spoiler_title">Original letter from Vaughan Pratt</b> <div class="spoiler_text">  From: pratt@Sunburn.Stanford.EDU (Vaughan R. Pratt) <br>  Newsgroups: comp.arch, comp.sys.intel <br>  Subject: A natural scenario with high FDIV bug probability (was: Intel's Defense ...) <br>  Date: 3 Dec 1994 15:20:17 GMT <br>  Organization: Computer Science Department, Stanford University. <br>  Lines: 194 <br>  Message-ID: &lt;3bq2bh$ohc@Radon.Stanford.EDU&gt; <br>  References: &lt;3bdieq$lqf@engnews2.Eng.Sun.COM&gt; &lt;3bf666$6k4@hpsystem1.informatik.tu-muenchen.de&gt; &lt;3bnrgo$4gf@hermes.synopsys.com&gt; <br>  NNTP-Posting-Host: sunburn.stanford.edu <br>  Xref: Radon.Stanford.EDU comp.arch: 15209 comp.sys.intel:20065 <br>  In this case, it‚Äôs not possible to say that we‚Äôve seen it at all.  If you‚Äôve been bruised rationals like 5/15, which is bridged as 4.999999 / 14.999999 yields 0.333329 on the Pentium and 0.33333329 elsewhere.  Moreover, it‚Äôs not so large.  We leave the plausibility of our scenario for the reader to judge;  it could be well happen. <br><br>  By way of motivation: In article &lt;3bnrgo$4gf@hermes.synopsys.com&gt;, Joe Buck wrote: <br><br>  &gt; I really quite amazed at all of this fuss.  In one case out of nine <br>  &gt; billion, you get a single-precision division instead of <br>  &gt; a double-precision division.  The Pentium Users <br>  &gt; anything that requires even full single-precision: they run spreadsheets, <br>  &gt; write documents, and play games.  Why should Intel pay about 1 billion <br>  &gt; (that's nine zeros) dollars to get these lusers a new chip? <br>  One in nine billion, NOT.  It is a common fallacy that real numbers are arising.  It follows the scenario described below. <br><br>  Correct to within single-precision, NOT.  You had in mind a 16-bit word length;  We give you here in particular. 4.999999 / 14.999999. <br><br>  For example, it‚Äôs not a problem, but it‚Äôs not a problem. all of us have seen many times.  It was not once every 27,000 years that it had been encountered. <br><br>  It would not be necessary to meet the number of decimal digits, the * precision *.  For all fixed precision.  Thus, if we are dividing say 6 by 18, then we‚Äôre actually 6.999999 and 18 is 17.999999, that is, the same quantity, here 10 ^ -6, is subtracted from both operands. <br><br>  There are a few pairs of integers i. J with 1 &lt;= i, j &lt;= 1000. counting a couple of possible divisions i / j are wrong.  IEEE-correct answers can not be expected 10 ^ -17.  At least 10 ^ -15 for the first column, at least 10 ^ -13 for the second, etc.  (That is, we‚Äôre going to be less fussy and hence recognize fewer as wrong.) <br><br><img src="https://habrastorage.org/files/d0c/c64/7dd/d0cc647dd0ca4b3ba59882c06f27a333.jpg"><br><br>  With 6 digits of precision, it is one millionth, an easily readable quantity.  If you are for a drink at a cocktail party. <br><br>  My favorite is 5/15, that is, 4.999999 / 14.999999, appraised by the Pentium at 0.33332922 when other appraisers would insist on 0.33333329 as a fairer answer. <br><br>  Another bad case is 7/48 (6.999999 / 47.999999), for which the most inspired would be 0.14583332. <br><br>  One more candidate: 9/54 (8.999999 / 53.999999), where the Pentium gambles on 0.16666439 and loses petulantly to 0.16666665. <br><br>  The three features of examples such as these.  It is important to make it possible.  It is not necessary to make a number of people who want to make it. .  It is not necessary to make any mistakes, so that it can be a bit different. <br><br>  It has been noted that it has been remarked that it has been remarked. with ^^ in the above.  The following is a question: calculate 4.999999 / 14.999999, then delete it out;  beyond the repeating string (actually two in the 5/15 case). <br><br>  It should be noted. <br><br>  Only 26 pairs survive at tolerance 10 ^ -5.  Here for the record are the 14 wrong'uns for precision 6: 5/15, 5/30, 5/60, 5/120, 9/54, 9/108, 9/216, 9/432, 9/864, 10/60, 10/120, 10/240, 10/480, and 10/960.  (7/48 is off from only 0.9 * 10 ^ -5, just barely missing out on tolerance 10 ^ -5.) For precision 5 the 10 bad guys are 18/27, 20/30, 33/144, 36/108 , 40/120, 44/192, 72/432, 72/864, 80/480, and 80/960.  And for precision 4 the two divisions are 82/96 and 120/288;  specifically, 81.9999 / 95.9999 yields 0.854156 when we expected 0.8541665, while 119.9999 / 287.9999 yields 0.416656 and we wanted 0.4166665.  (Hmm, the delete-two-repeats rule works here too; very interesting ...) <br><br>  It should be noted that it was not a special case.  Digits down to 3 digits at tolerance 10 ^ -9 would have been 0, 31, 211, 547, 802, 784, 417, 109, 0. <br><br>  It‚Äôs a bit of a bad light for me.  It is a fact that a number of factors are in the real world.  The ‚Äúdamage index‚Äù is the product of those two factors.  There are no clues about the number of triggers that can be seen. uncertainty as in practice.  However, it‚Äôs not a completely implausible scenario. <br><br>  -ooooooooooooooooooooo-ooooooooooo <br><br>  I‚Äôm looking at the above table.  For those who think they are not harmonized in C, this is where the "precision" and "tolerance" means. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> main(argc, argv) char *argv[]; { int i, j, cnt, digits; double prec, tol, ibruis, jbruis, pent, true; for (digits = 15, prec = 1e-15; digits &gt; 2; digits--, prec *= 10) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%4.d\t\t"</span></span></span><span class="hljs-meta">, digits); for (tol = 1e-15; tol </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 1e-4; tol *= 100) { cnt = 0; for (i = 1; i &lt;= 1000; i++) for (j = 1; j &lt;= 1000; j++) { ibruis = i - prec, jbruis = j - prec; pent = ibruis/jbruis; true = (1.11*ibruis)/(1.11*jbruis); cnt += (fabs(pent - true) &gt; tol*true); } printf("%4d ", cnt); } printf("\n"); } }</span></span></span></span></code> </pre><br><br>  I like it, I‚Äôm looking for it, I‚Äôm looking for it, I‚Äôm looking for it, I‚Äôm not really interested in it. estimate of once in 27,000 years.  When I replaced 1.11 by 1.01, the results were identical. <br><br>  Vaughan pratt <br><br>  [ <a href="http://boole.stanford.edu/bug1.html">source</a> ] <br></div></div><br>  <b>11.9999103517 December</b> 1994, IBM released the "Pentium Study, IBM Memo" where it challenged Intel's statement. <br><br>  <b>December 19.9999973251,</b> Intel announced that it was starting to replace the Pentium processors on demand.  Andy Grove made a public apology.  The story cost Intel more than half the profits for the last quarter of 1994 ‚Äî $ 475,000,000. <br><br>  The press did not subside, but the people wanted fatality. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e64/9ff/b38/e649ffb388727e99bcbcaf4797d67dce.jpg" alt="image"></div><br><br><h2>  Alan Edelman </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/20c/c3e/ba120cc3e5f59053c311e718283cd7ce.png" alt="image"></div><br><br>  <b>18.9999163362 September</b> 1995, Alan Edelman published a <a href="http://www-math.mit.edu/~edelman/homepage/papers/pentiumbug.pdf">report</a> in which he conducted a detailed analysis of this error. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/d55/0ce/d37d550ce05bd8b74e1f0a11e0df2bf6.gif" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b7a/10a/107/b7a10a1078554bf893f617defebb477b.jpg" alt="image"></div><br><br><h2>  Read more </h2><br><ul><li>  <a href="http://download.intel.com/support/processors/pentium/sb/FDIV_Floating_Point_Flaw_Pentium_Processor.pdf">Statistical Analysis of Floating Point Flaw: Intel White Paper</a> </li><li>  <a href="http://mtarchive.blogspot.ru/2016/08/pentium-bug-revisited.html">Pentium Bug Revisited</a> </li><li>  <a href="https://de.mathworks.com/company/newsletters/news_notes/pdf/win95cleve.pdf">A Tale of Two Numbers</a> </li><li>  <a href="http://davefaq.com/Opinions/Stupid/Pentium.html">"United we stand, divided we fall"</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">Wikipedia: Pentium FDIV bug</a> </li><li>  <a href="http://citforum.ru/programming/digest/scofdebug/">"Debug Science"</a> </li></ul><br><br><h2>  PS </h2><br>  <b>Top 10 Intel slogans "from fans"</b> <br><br><ul><li>  9.9999973251 It's a FLAW, Dammit, not a Bug </li><li>  8.9999163362 It's Close Enough, We Say So </li><li>  7.9999414610 Nearly 300 Correct Opcodes </li><li>  6.9999831538 </li><li>  5.9999835137 Redefining the PC - and Mathematics As Well </li><li>  4.9999999021 We Fixed It, Really </li><li>  3.9998245917 Division Considered Harmful </li><li>  2.9991523619 Floating * Point? </li><li>  1.9999103517 We're Looking for a Few Good Flaws </li><li>  0.9999999998 The Errata Inside </li></ul></div><p>Source: <a href="https://habr.com/ru/post/314534/">https://habr.com/ru/post/314534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314520/index.html">Measurement of resistance and inductance of a DC motor</a></li>
<li><a href="../314522/index.html">Auto-collection of data about database files and logical disks of the operating system in MS SQL Server</a></li>
<li><a href="../314524/index.html">.NET Tools. Interview with Sergey Shkredov (JetBrains), Pavel Avsenin and Alexander Zakharov (DevExpress)</a></li>
<li><a href="../314528/index.html">The power of ITIL and the problem with the guru</a></li>
<li><a href="../314532/index.html">Procedural vegetation on OpenGL and GLSL</a></li>
<li><a href="../314536/index.html">Mars Rover, Introduction</a></li>
<li><a href="../314538/index.html">The digest of interesting materials for the mobile developer # 178 (October 31-November 6)</a></li>
<li><a href="../314540/index.html">Installing node.js on Raspberry Pi</a></li>
<li><a href="../314542/index.html">54th terabit highway in Asia commissioned</a></li>
<li><a href="../314544/index.html">Mars rover Initialization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>