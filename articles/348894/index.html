<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to background work in Android. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many articles about the background work of applications in Android, but I did not manage to find a detailed guide on how to work in the back...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to background work in Android. Part 1</h1><div class="post__text post__text-html js-mediator-article"><p>  There are many articles about the background work of applications in Android, but I did not manage to find a detailed guide on how to work in the background - I think, due to the fact that there are more and more new tools for such work.  Therefore, I decided to write a series of articles on the principles, tools and methods of asynchronous work in Android applications. </p><br><p><img src="https://habrastorage.org/webt/y1/1d/gi/y11dginajoj4p_mtyutoa1a1xzg.gif"></p><a name="habracut"></a><br><p>  There will be several parts: </p><br><ol><li>  The main thread, the implementation of background work using AsyncTask, the publication of the results in the main thread. </li><li>  Difficulty in using AsyncTask.  Loaders as one of the ways to avoid them. </li><li>  Work in the background using ThreadPools and EventBus. </li><li>  RxJava 2 as an asynchronous work method. </li><li>  Korutin in Kotlin as a method of asynchronous work. </li></ol><br><p>  Let's start with the first part. </p><br><h1 id="osnovy-ui">  UI Basics </h1><br><p>  The first thing to understand is why we generally worry about working in the background in mobile applications. </p><br><p>  In all applications for Android, there is at least one stream on which the UI is drawn and the user input is processed.  Therefore, it is called a UI thread or main stream. </p><br><p>  <strong>Each lifecycle method of each component of your application, including Activity, Service and BroadcastReceiver, is executed on the UI stream.</strong> </p><br><p>  The human eye converts shifting images into smooth video if the shift frequency reaches 60 frames per second (yes, this magic number is taken from here), giving the main stream only 16 ms to draw the entire screen. </p><br><p>  <strong>The duration of a network call can be thousands of times longer.</strong> </p><br><p>  When we want to download something from the Internet (weather forecast, traffic jams, how much your bitcoin costs at the moment), we should not do it from the main stream.  Moreover, Android will not allow us, throwing a <a href="https://developer.android.com/reference/android/os/NetworkOnMainThreadException.html">NetworkOnMainThreadException</a> . </p><br><p>  Seven years ago, when I developed my first Android apps, Google‚Äôs approach was limited to using AsyncTasks.  Let's see how we wrote the code to communicate with the server (mostly pseudocode): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadWeatherForecastTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Forecast</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... params)</span></span></span><span class="hljs-function"> </span></span>{ HttpClient client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); HttpGet request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(params[<span class="hljs-number"><span class="hljs-number">0</span></span>]); HttpResponse response = client.execute(request); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parse(response); } }</code> </pre> <br><p>  The doInBackground () method is guaranteed to be called not on the main thread.  But which one?  Depends on the implementation.  Here's how Android selects the stream (this is part of the source code for the AsyncTask class): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> AsyncTask&lt;Params, Progress, Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeOnExecutor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Executor exec, Params... params)</span></span></span><span class="hljs-function"> </span></span>{ ... mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- mFuture contains a Runnable with our doInBackgroundMethod return this; }</span></span></code> </pre> <br><p>  Here you can see that the execution depends on the Executor parameter.  Let's see where it comes from: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Executor SERIAL_EXECUTOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerialExecutor(); ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Executor sDefaultExecutor = SERIAL_EXECUTOR; ... <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> AsyncTask&lt;Params, Progress, Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Params... params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executeOnExecutor(sDefaultExecutor, params); }</code> </pre> <br><p>  As indicated here, by default executor refers to a pool of size 1 threads. This means that all AsyncTasks in your application are launched sequentially.  This was not always true, since for OS versions from DONUT to HONEYCOMB, a pool from 2 to 4 was used (depending on the number of processor cores).  After HONEYCOMB, AsyncTasks are again executed sequentially by default. </p><br><p>  So, the work is done, the bytes have completed their long journey from the other hemisphere.  You need to turn them into something understandable and place on the screen.  Fortunately, our Activity is right there.  Let's put the result in one of our View. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadWeatherForecastTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Forecast</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... params)</span></span></span><span class="hljs-function"> </span></span>{ HttpClient client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ... Forecast forecast = parse(response); mTemperatureView.setText(forecast.getTemp()); } }</code> </pre> <br><p>  Oh shit!  Again an exception! </p><br><blockquote>  android.view.ViewRoot $ CalledFromWrongThreadException: </blockquote><p>  But we did not make any network calls on the main thread!  That's right, but we tried to break another UI law.  The user interface can only be changed from the UI stream.  This is true not only for Android, but also for virtually any system that you come across.  The reason for this is well explained in the Java Concurrency In Practice.  In short - the architects wanted to avoid complex blocking when changing from multiple sources (user input, binding, and other changes).  Using a single thread solves this problem. </p><br><p>  Yes, but the UI still needs to be updated.  AsyncTask has another method onPostExecute, which is called on the UI thread: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPostExecutre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast forecast)</span></span></span><span class="hljs-function"> </span></span>{ mTemperatureView.setText(forecast.getTemp()); }</code> </pre> <br><p>  How does this magic work?  Let's look in the source code of AsyncTask: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Result result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCancelled()) { onCancelled(result); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { onPostExecute(result); } mStatus = Status.FINISHED; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InternalHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Looper looper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(looper); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message msg)</span></span></span><span class="hljs-function"> </span></span>{ AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (msg.what) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_POST_RESULT: <span class="hljs-comment"><span class="hljs-comment">// There is only one result result.mTask.finish(result.mData[0]); break; } } }</span></span></code> </pre> <br><p>  AsyncTask uses Handler to call onPostExecute in the UI, exactly like the postOnUiThread method in Android components. </p><br><p>  Handler hides the entire domestic kitchen.  Which one?  The idea is to have an infinite loop of checking messages arriving on a UI thread and processing them accordingly.  Nobody invents bicycles here, although there was some torsion of the pedals. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a41/828/074/a418280740e1f7a1a20f34490c82ea7e.gif" alt="image"></p><br><p>  For Android, this is implemented by the Looper class, which is passed to InternalHandler in the code above.  The essence of the Looper class is in the loop method: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { Message msg = queue.next(); .... msg.target.dispatchMessage(msg); } ... }</code> </pre> <br><p>  It simply polls the incoming message queue in an infinite loop and processes these messages.  This means that there must be an initialized Looper instance on the UI thread.  You can access it using a static method: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Looper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMainLooper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br><p>  By the way, you just learned how to check if your code is called in a UI thread: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Looper.myLooper() === Looper.getMainLooper()) { <span class="hljs-comment"><span class="hljs-comment">// we are on the main thread }</span></span></code> </pre> <br><p>  If you try to create an instance of Handler in the doInBackground method, you will get another exception.  It will report the need for a Looper for the stream.  Now you know what that means. </p><br><p>  It should be noted that AsyncTask can only be created in the UI stream for the reasons stated above. <br>  You might think that AsyncTask is a convenient way to do background work, as it hides complexity and requires a bit of effort when used, but there are a few problems that have to be solved along the way: </p><br><ul><li>  Every time you need to write a lot of code to solve a relatively simple task. </li><li>  AsyncTasks know nothing about the life cycle.  When mishandled, the best thing you get is a memory leak, at worst a failure. </li><li>  AsyncTask does not support the preservation of state of progress and the reuse of download results. </li></ul><br><p>  In the next part, I will examine these problems in detail and show how Loaders can help solve them. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348894/">https://habr.com/ru/post/348894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348882/index.html">Market as a stereotype regarding segment, need, supply</a></li>
<li><a href="../348884/index.html">KODOS: stay alive</a></li>
<li><a href="../348886/index.html">See the world through the eyes of animals: new horizons of eytreking</a></li>
<li><a href="../348890/index.html">Regular expressions: no magic</a></li>
<li><a href="../348892/index.html">Information Security Recommendations for Small and Medium Business (SMB)</a></li>
<li><a href="../348896/index.html">Cradle: Rave. Two hackathons + conference, with emphasis on Big Data & ML, Blockchain, Quantum Computing, DevOps and Mobile</a></li>
<li><a href="../348898/index.html">Slack is the opposite of organizational memory.</a></li>
<li><a href="../348900/index.html">Blockchain and medicine: 4 startups in the field of health care that are worth following</a></li>
<li><a href="../348902/index.html">Slightly reduce the action</a></li>
<li><a href="../348906/index.html">Dynamic generation of proxy classes in Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>