<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile devices from the inside. The image structure of partitions containing the file system. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents  Part 1 
 1. Introduction. 
 2. Cutting into pieces (chunks). 
 3. Compression of images. 
 3.1.Sparse files. 

 Part 2 
 3.2._spars...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile devices from the inside. The image structure of partitions containing the file system. Part 1</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  Part 1 <br>  1. Introduction. <br>  2. Cutting into pieces (chunks). <br>  3. Compression of images. <br>  3.1.Sparse files. <br></div></div><br>  Part 2 <br>  3.2._sparsechunk files. <br>  4. Creating <b>dat</b> files. <br>  5. Sources of information. <br><br><h2>  The image structure of partitions containing the file system. </h2><br><h2>  1. Introduction </h2><br>  Images of sections of mobile devices (MU) containing ext4 file system (FS) are large, for example, the size of the image of the system partition can reach several GB, and the size of the image of the userdata partition is already several dozen GB. <br><br>  These features require from the developer of firmware the use of "tricks" when performing operations of the initial download of firmware MU or installing updates, because  the dimensions of the partition images become not only commensurate with the volume of the RAM of the ME, but also significantly exceed them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The developers of stock (factory) firmware to reduce the size of images of partitions currently use the following methods: <br><br><ul><li>  dividing (cutting) the image into parts (chunks); </li><li>  compressing the whole image; </li><li>  use <b>dat</b> files. </li></ul><br>  The first method is based on reducing the size of an image by dividing it into several parts, called <b>chunks</b> , and the size of each piece should not exceed the pre-selected acceptable value.  This allows you to reduce the size of the piece of information transmitted to the MU in one session. <br><a name="habracut"></a><br>  In the second method, the property of the FS image is used, which is a sparse file [1].  This allows you to apply coding without data loss, which leads to a reduction in the size of the entire partition image by reducing the amount of ‚Äúempty‚Äù blocks containing either zero or duplicate data. <br><br>  The peculiarity of the third method is that after encoding all ‚Äúempty‚Äù blocks are deleted from the image (when installing the firmware) or only changes of images are transferred (when updating is performed). <br><br>  I think that, as an upgrade, the developers of custom firmware will be interested in becoming familiar with the internal structure of images of this type and clarifying some aspects of working with them ... <br><br><h2>  2. Cutting into pieces (chunks) </h2><br>  This method implies that the source image, which has ext4-format, is divided into parts no larger than a predetermined value, called the <b>boundary</b> .  Most often, the <b>border</b> is set to 128 or 256 MB.  At the same time, for the reverse recovery, an additional so-called allocation file is created, describing the location of these parts in the original image. <br><br>  The process of cutting an image of a section into parts can be described by the following algorithm: <br><br><ol><li>  the <b>boundary</b> value is selected, which must satisfy the following criteria: <br><br><ul><li>  multiple of FS block size; </li><li>  Do not exceed the allowable size of files for transfer during OTA-update or boot in <b>fastboot</b> mode; </li></ul></li><li>  the image of the section is viewed in the RAW format and is divided into parts with a size not exceeding the <b>border</b> ; </li><li>  from each part an output piece (chunk) is formed according to special rules: <br><br><ul><li>  if the piece in question contains non-zero data, they are completely copied to the output piece (type 1 chunk); </li><li>  if the piece in question contains only zero data, then the output piece will have a size of one block, consisting of zeros (type 2 chunk); </li><li>  if the piece in question contains some information and a lot of null data, then the output piece will contain only the information part (type 3 chunk); </li><li>  the size of a piece of any type is always a multiple of the size of the block. </li></ul></li><li>  the entire cutting process is recorded in the location file.  The name of the piece, the offset in the firmware, and the size of the original input piece corresponding to the created piece are saved in the form of attributes. </li></ol><br>  After such a partitioning of the partition image and due to the truncation of the zero data, there is a significant decrease in the sum of the lengths of the pieces, i.e.  total output file size. <br><br>  The recovery process is very simple and is performed according to the following algorithm: <br><br><ul><li>  creates a new blank image that has the size of the original; </li><li>  then chunks are sequentially read and arranged in it according to the information from the allocation file. </li></ul><br>  For example, let's consider the process of restoring the original partition image using the firmware for the Lenovo s90 MU based on the Qualcomm MSM8916 processor [2], which contains the rawprogram0.xml placement file.  And for the "border" part of Qualcomm accepted the value of 128 MB. <br><br>  The placement file rawprogram0.xml is an xml file, a quote from which is shown below: <br><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" ?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> This is an ** Autogenerated file **--&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> Sector size is 512bytes--&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">program</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filename</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache_1.img"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start_sector</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"6193152"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">program</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filename</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache_2.img"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start_sector</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"6455296"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">program</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filename</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache_3.img"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start_sector</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"6455496"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">program</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filename</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache_4.img"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cache"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start_sector</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"6717440"</span></span></span><span class="hljs-tag"> /&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Strictly speaking, this is a MU memory markup description file based on Qualcomm chips.  I will not describe all the parameters of this file, because  we only need the following: <br><br><ul><li>  <b>filename</b> - the name of the file; </li><li>  <b>label</b> - section label; </li><li>  <b>start_sector</b> - file offset in memory, expressed in 512 byte sectors. </li></ul><br>  The <b>filename</b> parameter indicates the name of the file containing the image or its part, the label of which is represented by the <b>label</b> parameter. <br><br>  The <b>start_sector</b> parameter contains the ABSOLUTE offset of the beginning of the file in the MU memory. <br><br>  Since  Since we are not going to flash part files into memory, we‚Äôll only collect a whole file-image of a partition from them, then we need to use relative offset to place each part in this image file.  The basis is the beginning of the image of a specific section, i.e.  image offset in the memory MU.  The calculation is made according to the following formula: <br><br><blockquote>  Relative displacement = abs. Offset of part_part - abs. Offset_start_of_part </blockquote><br>  There are several files in the firmware body containing ext4 filesystems: <br><br><ul><li>  <b>cache.img</b> , consisting of 4 parts (cache_1.img - cache_4.img); </li><li>  <b>preload.img</b> , consisting of 6 parts (preload_1.img - preload_6.img); </li><li>  <b>system.img</b> , consisting of 29 parts (system_1.img - system_29.img). </li></ul><br>  Let's try to build an image of the <b>cache</b> partition, i.e.  from parts cache_1.img - cache_4.img we will collect one file cache.img.  Specifically, for it, we will select the following values ‚Äã‚Äãfrom the rawprogram0.xml above file: <br><br><ul><li>  the absolute offset of the beginning of the <b>cache</b> section is 6193152; </li><li>  the beginning of the first part of the <b>cache</b> image has an absolute offset of 6193152, respectively, the relative offset is zero; </li><li>  the beginning of the second part 6455296, respectively, the relative offset 262144. </li><li>  the beginning of the third part 6455496, respectively, the relative offset 262344; </li><li>  the beginning of the fourth part of 6717440, respectively, the relative offset 524288; </li></ul><br>  To recover, do the following: <br><br><ul><li>  open the first part with any hex editor, i.e.  cache_1.img file and read the value of the uint32 type at the address 0x0404, which is the size of the FS image of the type ext4 of the cache section, expressed in blocks.  In Figure 1 it is marked in red: <br><br><img src="https://habrastorage.org/webt/ii/j8/bu/iij8buuvf5tgx4zryycle8e_ib4.png"><br>  <b>fig.1.</b>  Cache partition image size <br></li><li>  create a new empty file containing filesystems of type ext4, size 0x010600 blocks, i.e.  0x010600 * 0x1000 = 0x010600000 (274,726,912 bytes or 262MB), calling it cache.img; </li><li>  copy the entire contents of the first part and paste it into a new file, starting with the relative offset calculated above, i.e.  0x0000; </li><li>  open the file containing the next part of the file is cache_2.img. </li><li>  copy the entire contents of this part and paste it into the created file, starting also with the relative offset of the second part (262144), calculated above; </li><li>  repeat the previous two steps for all other parts of the cache.img file, taking into account their order. </li></ul><br>  After completing all the steps, you will receive a file, <b>cache.img</b> , <b>262MB</b> in size, containing an image of a <b>cache</b> partition in the form of an ext4 file system. <br><br><h2>  3. Image compression </h2><br>  Cutting into parts partially solves the problems of the developers, reducing the size of one part transmitted during the transfer session during the firmware update.  However, the total file size does not change. <br><br>  The problem of reducing the size of the image can be solved by its compression (coding).  To do this, use the following methods: <br><br><ul><li>  converting a raw format file to a <b>sparse</b> file; </li><li>  <b>Converting a</b> raw format file to <b>_sparsechunk</b> files. </li></ul><br>  <b>Sparse</b> files are actively used, for example, in a Lenovo Moto G device, and <b>_sparsechunk</b> files are used in <b>Moto Z.</b> <br><br><h3>  3.1.Sparse files </h3><br>  To remove ‚Äúempty‚Äù values, the number of which in partition images can reach 90%, the images themselves convert (compress) into <b>Sparse</b> files, the structure of which is described in [3].  In this case, the source file is considered as an array of elements representing four-byte numbers, and the array is scanned block by block, i.e.  4096 bytes each or 1024 elements each. <br><br>  Depending on the content, the blocks are divided into the following types: <br><br><ul><li>  blocks with repeating elements, i.e.  containing zeros or the same (duplicate) elements, i.e.  <b>Fill</b> blocks; </li><li>  blocks with information elements, i.e.  containing different data within the whole block, i.e.  <b>Raw</b> blocks. </li></ul><br><h4>  3.1.1.The structure of sparse files </h4><br>  The sparse image of the partition with the FS after converting it into a <b>sparse</b> file is a sequence (list) of <b>Raw</b> and <b>Fill</b> pieces, interleaved.  To identify and provide a reverse transformation (image restoration), all this is supplemented with a header. <br><br>  So, the <b>Sparse</b> file consists of: <br><br><ul><li>  file header; </li><li>  data areas, i.e.  list of pieces. </li></ul><br>  Despite the fact that when converting the image of the <b>Raw</b> format in <b>sparse</b> , only two types of pieces are used, there are 4 types of pieces of <b>sparse</b> files, which will be discussed below. <br><br><h5>  Sparse file header </h5><br>  The header has the following structure: <br><br><img src="https://habrastorage.org/webt/at/0v/73/at0v73ldfaskm9_eej4djvi-pba.png"><br>  <b>fig.2.</b>  Sparse file header <br><br>  Briefly consider all the header fields. <br><br>  The <b>Magic</b> field is 4 bytes long and contains a signature (the number 0xed26ff3a) and is used to identify the <b>sparse</b> file as a file type. <br><br>  The <b>Major Version</b> and <b>Minor Version</b> fields are 2 bytes long and contain the version number of the <b>sparse</b> file format.  Now it is version 1.0. <br><br>  The <b>FileHeaderSize</b> field is 2 bytes long and contains the size of the <b>sparse</b> file header in bytes.  Currently, there are two versions of the header, differing only in its size: 0x1C (28) bytes and 0x20 (32) bytes.  Accordingly, this field contains the number or 0x1C, or 0x20. <br><br>  The <b>ChunkHeaderSize</b> field is 2 bytes long and contains the size of the header of the <b>sparse</b> file.  Regardless of the type of pieces, it contains the number 0x0C (12). <br><br>  The <b>Block_Size</b> field is 4 bytes long and contains the block size of the <b>sparse</b> file.  For compression into a sparse FS image file of type ext2-ext4, the value of this field is 0x1000 (4096). <br><br>  The <b>Total_Blk</b> field is 4 bytes long and contains the size of the source file (img) in blocks. <br><br>  The <b>Total_Chunks</b> field is 4 bytes long and contains the number of parts into which the source (input) file was divided.  The same number of pieces is contained in the output file ( <b>sparse</b> ). <br><br>  The <b>Image_Checksum</b> field contains the checksum of the output file data (sparse) calculated by the <b>Crc32</b> algorithm for the entire file (header + data). <br><br><h5>  The structure of the data area of ‚Äã‚Äãthe sparse file pieces </h5><br>  Following the header is the data area, consisting of a list of pieces of a <b>sparse</b> file. <br><br>  Each piece has a piece header and piece data. <br><br>  The header has a length of 0x0C (12) bytes, as indicated in the <b>ChunkHeaderSize</b> field of the <b>sparse</b> file header and contains the following fields: <br><br><img src="https://habrastorage.org/webt/tr/vh/nr/trvhnrx4oeknpzzjphhgjrueygg.png"><br>  <b>Fig.3.</b>  Piece Header Structure <br><br>  The <b>Chunk_Type</b> field is 2 bytes long and contains a chunk identifier and can have the following values: <br><br><ul><li>  0xCAC1 is a piece of <b>Raw</b> type intended for storing non-repeating data.  The size of the piece is equal to the amount of data in bytes + the size of the piece header; </li><li>  0xCAC2 - a piece of type <b>Fill</b> describes the repeating part of the input data, contains zero or duplicate data in coded form.  The size of the piece is equal to the size of the header + 4 bytes per placeholder element; </li><li>  0xCAC3 - a piece of type <b>DontCare</b> contains no data at all.  The size of the piece is equal to the size of the piece header, i.e.  12 bytes; </li><li>  0xCAC4 - a piece of type <b>Crc</b> contains the checksum of the file, calculated by the algorithm Crc32.  The chunk size is equal to the header size + 4 bytes per checksum value. </li></ul><br>  The <b>Reserved</b> field is 2 bytes long, is not used and is always zero. <br><br>  The <b>Chunk_Size</b> field is 4 bytes long and contains the size of the original piece in the input file (img), expressed in blocks. <br><br>  The <b>Total_Size</b> field is 4 bytes long and contains the size of the resulting piece in the output sparse file, expressed in bytes.  The calculation takes into account both the length of the header and the length of the piece data. <br><br>  Following the header are data that differs depending on the type of piece. <br><br>  Since  a piece of type <b>Raw is</b> intended to store non-repeating data, then the data of the piece completely coincides with the data of the corresponding part of the input file.  It has the largest size, because  the amount of data can reach the value of the selected <b>boundary</b> . <br><br>  A piece of the <b>Fill</b> type contains only one four-byte number (4-byte placeholder) as data, repeated in the corresponding part of the input file.  It replaces the entire area occupied by these repetitive data without enumerating them, which leads to their compression. <br><br>  A piece of type <b>Crc</b> as data contains a checksum of a piece, calculated using the <b>Crc32</b> algorithm <b>for all the piece data</b> . <br><br>  The exception is a piece of the <b>DontCare</b> type, which contains no data at all, but the <b>Chunk_Size</b> field is still filled.  It represents a pointer (offset) at the beginning of the next piece of data in the input file. <br><br><h4>  3.1.2. Algorithms for working with sparse files </h4><br>  When working with sparse files, the operations are performed to encode the raw ( <b>Raw</b> ) img file into a <b>sparse</b> file and decode the <b>sparse</b> file into the original file. <br><br>  The coding of the input <b>Raw</b> image of the <b>sparse</b> section of the format is performed according to the following algorithm: <br><br><ol><li>  Block by block the input image of the section is viewed and the type of each block is determined. </li><li>  Contracting blocks of the same type are combined into groups.  The current group ends when a block type changes, and a new one begins. <br><br>  Contracting <b>Fill</b> blocks are combined into <b>Fill</b> groups.  This takes into account the repeated value, which must be the same within the same group.  If the next going <b>Fill</b> block has another repeated value, a new <b>Fill</b> group is created. <br><br>  <b>Raw</b> raw blocks are combined into <b>Raw</b> groups. </li><li>  All resulting groups are converted into chunks of the <b>sparse</b> format file.  At the same time, the <b>Raw</b> group containing non-repeating data is completely, unchanged, copied into the data area of ‚Äã‚Äãthe <b>Raw</b> .  And the entire <b>Fill</b> group is replaced with one piece of the <b>Fill</b> type, containing one repeating element in the data area of ‚Äã‚Äãthis piece. </li><li>  The <b>sparse</b> file header is filled. </li></ol><br>  Decoding of the <b>sparse</b> file into the original image is performed according to the following algorithm: <br><br><ol><li>  A new empty file is created, the size of which in blocks is taken from the <b>Total_Blk</b> field of the <b>sparse</b> file header. </li><li>  Each piece of the list from the data field of the <b>sparse</b> file is sequentially decoded, filling the output file sequentially, starting at address 0x0000.  At the same time for the piece read the title, and then: <br><ul><li>  These pieces of type <b>Raw are</b> completely copied from the input file to the output. <br>  In this case, the read pointer for the input file and the write pointer for the output file are moved by the number of bytes to be copied. </li><li>  For a piece of type <b>Fill</b> in the output file, the filler element is copied <b>Total_Size</b> , divided by 4, times. <br>  In this case, the read pointer of the input file is moved to 4 bytes of a placeholder.  The record pointer of the output file is moved by the number of bytes occupied by the placeholders. </li><li>  For pieces of type <b>DontCare,</b> the input file read pointer does not move, and in the output file the write pointer is moved to the number of byte blocks specified in the <b>chunk_Size</b> field of the piece. </li></ul></li></ol><br><h4>  3.1.3. Examples of working with sparse files </h4><br>  When working with sparse files, two questions most often arise: <br><br><ul><li>  How to restore the original image from a sparse file? </li><li>  How to convert source image to sparse file? </li></ul><br>  Consider them according to the receipt ... <br><br><h5>  How to restore the original image from a sparse file? </h5><br>  For example, consider the process of restoring an image of an <b>oem</b> partition from a <b>sparse</b> file of MU Moto Z from Lenovo [4].  All actions are performed using a hex editor, for example, WinHex. <br><br>  The original oem.img file containing the compressed image of the <b>oem</b> partition has a size of 69MB.  Let's see his title: <br><br><img src="https://habrastorage.org/webt/mk/nh/of/mknhofik14urbumqcwhgqee-5xy.png"><br>  <b>Fig.4.</b>  Heading moto z <br><br>  From the address 0x0000 there is a file signature indicating that the file is of type sparse file and consists of pieces.  The signature is marked in blue. <br><br>  Then the fields with the version of the sparse file (1.0) are highlighted in green. <br><br>  Then the fields <b>FileHeaderSize</b> and <b>ChunkHeaderSize</b> are highlighted in red, containing the size of the file header (0x001C) and the size of the piece header (0x000C), respectively. <br><br>  At offset 0x000C there is a <b>Block_Size</b> field indicating the block size of the sparse file.  The size of the block is 0x00001000. <br><br>  At offset 0x0010 is the <b>Total_Blk</b> field, which contains the size of the source file in blocks.  It is highlighted in yellow and has the value 0x0000C021. <br><br>  At offset 0x0014 is the <b>Total_Chunks</b> field, which contains the number of pieces contained in the sparse file.  It is highlighted in purple and has the value 0x0000001F. <br><br>  At offset 0x0018, the <b>Image_Checksum</b> field is <b>located</b> , containing the checksum of the sparse file.  This field contains 0, which means that the CS was not calculated and is not taken into account when loading this file into the memory of the ME. <br><br>  Starting at address 0x001C, the header of the first piece of the sparse file is located: <br><br><img src="https://habrastorage.org/webt/fa/tj/0o/fatj0o3nt9hitnre8ygmcbkr-58.png"><br>  <b>fig.5.</b>  CAC1 piece header <br><br>  You can see that the <b>Chunk_Type</b> field contains the value 0xCAC1, highlighted in blue.  The next 2 bytes are empty, and then the <b>Chunk_Size</b> field is marked in red, containing the number of blocks of the input file (0x00000001) encoded in the piece. <br><br>  Next is the <b>Total_Size</b> field, which contains the length of the piece along with the header, expressed in bytes (0x0000100C).  It is highlighted in green.  We always need the size without a header, so the length of the data only: 0x100C - 0x000C = 0x1000. <br><br>  Immediately after the heading, starting at address 0x0028, there is an array of chunk data. <br><br>  So, to restore the original image, perform the following steps: <br><br><ul><li>  open the original sparse oem.img file in a hex editor; </li><li>  choose field values ‚Äã‚Äãfrom the file header, create a new empty size file <br><pre> <code class="html hljs xml">Total_Blk * Block_Size = 0x000C021 * 0x1000 = 00C021000  (192)</code> </pre>  and save under the name, for example, oem_ext4.img; </li><li>  go to the processing of the first piece; </li><li>  its type is CAC1, so we copy the data array (starting at offset 0x0028, 0x1000 in size) and paste it into the created output file; </li><li>  move on to the next piece.  Its type is CAC2, respectively, the placeholder is 0xFFFFFFFF, and the number of placeholders is 0x1D blocks: <br><br><img src="https://habrastorage.org/webt/el/uj/sm/elujsmkukjwfnagab-cda4hrla0.png"><br>  <b>Fig.6.</b>  The second piece of CAC2 <br><br>  Insert the number of placeholders in the created file <br><pre> <code class="html hljs xml">0x001D * 0x1000 = 0x01D000  118784 </code> </pre> </li><li>  Etc.  We will perform the described steps to decode the pieces to the end of the source file. </li></ul><br>  The result will be a file containing filesystems of type ext4, 192MB in size. <br><br><h5>  How to convert source image to sparse file? </h5><br>  For simplicity, take the <b>oem_ext4.img</b> image <b>you</b> just received and try to turn it into a <b>sparse</b> file.  In this case, you need to create a new file of size 0x001C (28) bytes, place the header of the <b>sparse</b> file into it and then sequentially review the source file, dividing it into pieces and encoding them, place all the created <b>sparse</b> files in the new file.  And, of course, save the new file under the name, for example, <b>oem_sparse.img</b> . <br><br>  To fill in the file header, enter the signature of the <b>sparse</b> file in the first 4 bytes: <br><br><img src="https://habrastorage.org/webt/5o/oh/8f/5ooh8fjd6vl370jvt65-imxpfg4.png"><br>  <b>fig.7.</b>  Sparse file header <br><br>  Next, write the values ‚Äã‚Äãin succession: <br><br><ul><li>  version numbers of the sparse file (takes 4 bytes): <br><br><img src="https://habrastorage.org/webt/le/f7/uc/lef7ucsxpwnvdngkxkf8ecdigf8.png"><br>  <b>Fig.8</b> Version number of the sparse file <br></li><li>  sparse file header size (2 bytes): <br><br><img src="https://habrastorage.org/webt/pq/uu/bg/pquubgv0palbhqetgubd92vjlv0.png"><br>  <b>Fig.9 Sparse</b> file header size <br></li><li>  size of chunk header (2 bytes): <br><br><img src="https://habrastorage.org/webt/qq/ia/tb/qqiatb8ml5iskf9xxparsxvk9z0.png"><br>  <b>fig.10</b> Size of the piece header <br></li><li>  block size in bytes (4 bytes): <br><br><img src="https://habrastorage.org/webt/hr/xc/m6/hrxcm6shvt98zeymeqtiinxwhps.png"><br>  <b>fig.11</b> block size <br></li></ul><br>  The remaining fields are left free, because  their values ‚Äã‚Äãwill appear with us only after the final creation of the output file. <br><br>  Let's now look at how to encode, i.e.  create, different types of pieces. <br>  Any type of piece has a header.  Therefore, we create it first: create a 12-byte file in a hex editor: <br><br><img src="https://habrastorage.org/webt/km/ol/uf/kmolufkqkyu6bkasgjjm8kfk7qu.png"><br>  <b>fig.12</b> Empty piece header <br><br>  Next, consider how and what to fill in the pieces. <br><br>  <b>Raw type slice</b> <br>  In the first 2 bytes of the header, we write its type (CAC1): <br><br><img src="https://habrastorage.org/webt/by/ze/ib/byzeibyf2n4dorfoa3tjp9cbpo0.png"><br>  <b>fig.13</b> Type of piece CAC1 <br><br>  Then in the field we insert the size of the data (0x00000001), expressed in blocks: <br><br><img src="https://habrastorage.org/webt/xj/8_/k8/xj8_k8bjndz7zmf83eck3bllbtk.png"><br>  <b>fig.14</b> Size in blocks <br><br>  And finally, the size of the piece in bytes (0x0000100C), i.e.  header length + data length: <br><br><img src="https://habrastorage.org/webt/k4/xv/pf/k4xvpfms9r-7n1dncj6kr48nesg.png"><br>  fig.15 CAC1 piece size <br><br>  After the header we insert the data, i.e.  0x1000 (4096) bytes from the source file: <br><br><img src="https://habrastorage.org/webt/o5/fw/fe/o5fwfefxnsxbwjflqdpzha-f054.png"><br>  <b>Fig.16</b> Data piece SAS1 <br><br>  Let's proceed to the creation of the next piece. <br><br>  <b>Fill Piece</b> <br>  In the first 2 bytes of the header, write its type (CAC2): <br><br><img src="https://habrastorage.org/webt/56/hz/m0/56hzm0pxp8yr6hsb8kq6bf1ufna.png"><br>  <b>Figure 17.</b> Type of piece CAC2 <br><br>  Insert the data size of the piece (0x001D), expressed in blocks: <br><br><img src="https://habrastorage.org/webt/hr/yh/9a/hryh9aq1xehu-hwiw6hv-taq0oi.png"><br>  <b>Fig.18</b> Size in CAC2 blocks <br><br>  Insert the size of the piece in bytes (0x0010), i.e.  header length + data length: <br><br><img src="https://habrastorage.org/webt/-7/s4/cr/-7s4crrkdn8rwghizzvavjpqodi.png"><br>  <b>Fig.19</b> Size of piece SAS2 <br><br>  Add the piece data.  For CAC2, this is a placeholder element (0xFFFFFFFF): <br><br><img src="https://habrastorage.org/webt/ue/h-/f7/ueh-f7v8z049134riquobokmzku.png"><br>  <b>fig.20</b> Data piece SAS2 <br><br>  Let's proceed to the creation of the next piece. <br><br>  <b>DontCare Piece</b> <br>  In the first 2 bytes of the header, write its type (CAC3): <br><br><img src="https://habrastorage.org/webt/xj/dv/ab/xjdvab_cpmwoxbjalgqyvyb8jle.png"><br>  <b>fig.21</b> Type of piece CAC3 <br><br>  Insert the offset value to the next piece (0xxxxxx), expressed in blocks, at the address 0x0004 header. <br><br>  Insert the size of the piece in bytes (0x000C), i.e.  just the length of the title, because  A piece of this data type does not have at the address 0x0008 header: <br><br><img src="https://habrastorage.org/webt/ev/ig/x_/evigx_q3z9y4kbe6tshmrji1zce.png"><br>  <b>fig.22</b> Size of piece SAS3 <br><br>  Let's proceed to the creation of the next piece. <br><br>  <b>Crc Piece</b> <br><br>  In the first 2 bytes of the header, write its type (CAC4): <br><br><img src="https://habrastorage.org/webt/dy/1h/en/dy1henadkeomxibtccyyblotskk.png"><br>  Figure <b>23</b> Piece Type CAC4 <br><br>  Insert the data size of the piece (0x001D), expressed in blocks: <br><br><img src="https://habrastorage.org/webt/1c/v6/tu/1cv6tuvfuugbuwskytm90ohhhh8.png"><br>  <b>Fig.24</b> Size in CAC4 blocks <br><br>  Insert the size of the piece in bytes (0x0010), i.e.  header length + data length: <br><br><img src="https://habrastorage.org/webt/in/eg/js/inegjs7h6yzy-o1ljovp3wo3iy8.png"><br>  <b>fig.25</b> CAC4 piece size <br><br>  Add the piece data.  For CAC4, this is a check sum of a piece calculated using the CRC32 algorithm: <br><br><img src="https://habrastorage.org/webt/6m/pl/0w/6mpl0wpzhizx_3x03bwpgyivcjg.png"><br>  <b>fig.26</b> Data piece CAC4 <br><br>  Actually, we have already sorted out everything by bone: we create a <b>sparse</b> header ‚Äî a slice;  and immediately after him add the data he needs. <br><br>  Now the process of encoding the source file in a <b>sparse</b> file is as follows: <br><br><ul><li>  create an output file of 0x001C bytes in the hex editor, and fill in the header fields of the <b>sparse</b> file in it as described above; </li><li>  open the source file in a hex editor; </li><li>  scan 4096 bytes (one block) and determine the type of the piece. </li><li>  create a piece of type CAC1 in the output file; </li><li>  we scan the following 4096 bytes (one block) and determine the type of the piece. </li><li>  create a piece of type CAC2 in the output file; </li><li>  perform block-by-block viewing of the source file to the end.  All blocks are encoded into pieces and put them in the output file. </li><li>  view the output file and merge pieces of one type, arranged in series, into one group, and pieces of another type into another group.  In the group there is one header from the first piece, in which the values ‚Äã‚Äãof two fields are corrected: <br><ul><li>  <b>Chunk_Size</b> is the total size of the group of source pieces of the input file (img), expressed in blocks; </li><li>  <b>Total_Size</b> - the size of the resulting group in the output sparse file, expressed in bytes. </li></ul></li><li>  we add the size of the source file in blocks in the <b>Total_Blk</b> header field, and the number of pieces in the <b>Total_Chunks</b> file header field; </li></ul><br>  <b>To be continued...</b> <br><br><h2>  3.2._sparsechunk files </h2><br><h2>  4. Creating <b>dat</b> files </h2><br><h2>  5. Sources of information </h2><br>  1. <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B5%25D0%25B6%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25B0%25D0%25B9%25D0%25BB">"Sparse_file"</a> . <br>  2. <a href="https://firmwarefile.com/lenovo-s90-a">"s90-a_row_s125_141114_pc_qpst - firmware"</a> . <br>  3. system / core / libsparse / sparse_format.h <br>  4. <a href="http://lenovo-forums.ru/topic/21233-moto-z-xt1650-03-griffin-reteu-emea-mpl24246-17_rooted/">"Firmware device Lenovo Moto Z"</a> . <br>  5. Victara_Retail_China_XT1085_5.1_LPE23.32-53_CFC.xml.zip - firmware of the Lenovo Moto X device. </div><p>Source: <a href="https://habr.com/ru/post/345726/">https://habr.com/ru/post/345726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345710/index.html">Unity newbie bugs tested in their own skin</a></li>
<li><a href="../345712/index.html">New to the New Year: a review of Veeam Backup & Replication 9.5 Update 3</a></li>
<li><a href="../345714/index.html">Mathematical models of relay-pulse regulators</a></li>
<li><a href="../345716/index.html">SAP Cloud Platform Webinar Library: from Internet of Things services to machine learning and UX</a></li>
<li><a href="../345724/index.html">Efficient use of process.env</a></li>
<li><a href="../345728/index.html">Employees and business: and not a friend, and not an enemy, but how?</a></li>
<li><a href="../345730/index.html">Useful to the designer - issue number 3. Needed community news to improve your workflow</a></li>
<li><a href="../345732/index.html">Git: Newbies Tips - Part 1</a></li>
<li><a href="../345734/index.html">Bloomberg: in search of new markets, high-frequency traders master cryptocurrency</a></li>
<li><a href="../345736/index.html">IL2CPP: generalized implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>