<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous PHP and the story of one bike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After the release of PHP7, it became possible to write long-lived applications at a relatively low price. Projects such as prooph , broadway , tactici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous PHP and the story of one bike</h1><div class="post__text post__text-html js-mediator-article"><p> After the release of PHP7, it became possible to write long-lived applications at a relatively low price.  Projects such as <code>prooph</code> , <code>broadway</code> , <code>tactician</code> , <code>messenger</code> became available to <code>tactician</code> , whose authors take on the solution of the most frequent problems.  But what if you make a small step forward, delving into the question? </p><br><p>  Let's try to make out the fate of another bike that allows you to implement the Publish / Subscribe application. </p><a name="habracut"></a><br><p>  To begin with, we will try to briefly review current trends in the PHP world, as well as superficially touch on asynchronous work. </p><br><h3 id="php-sozdan-chtoby-umirat">  PHP is created to die. </h3><br><p>  For a long time, PHP was used mainly in the request / response workflow.  From the point of view of developers, this is quite convenient, because there is no need to worry about memory leaks, monitor connections. </p><br><p>  All requests will be executed in isolation from each other, the occupied resources will be released, and connections, for example, to the database will be closed at the end of the process. </p><br><p>  As an example, you can take the usual CRUD application written on the basis of the symfony framework.  In order to read from the database and return JSON, you must perform a number of steps (to save space and time, eliminate the steps to generate / execute opcodes): </p><br><ul><li>  Parsing configuration; </li><li>  Container compilation; </li><li>  Request routing; </li><li>  Performance; </li><li>  Rendering the result. </li></ul><br><p>  As in the case of PHP (using accelerators), the framework actively uses caching (some of the tasks will not be executed at the next request), as well as deferred initialization.  Starting with version 7.4, <a href="https://wiki.php.net/rfc/preload">preload</a> will be available, which will further optimize the initialization of the application. </p><br><p>  Nevertheless, it will not be possible to completely remove all overhead costs for initialization. </p><br><h3 id="pomozhem-php-vyzhit">  Help PHP survive </h3><br><p>  The solution to the problem looks quite simple: if you launch the application every time is too expensive, then you need to initialize it once and then just pass requests to it, controlling their execution. </p><br><p>  In the PHP ecosystem there are projects such as <a href="https://github.com/php-pm/php-pm">php-pm</a> and <a href="https://github.com/spiral/roadrunner">RoadRunner</a> .  Both conceptually do the same thing: </p><br><ul><li>  A parent process is created that performs the role of supervisor; </li><li>  A pool of child processes is created; </li><li>  Upon receiving a request, the master retrieves the process from the pool, passes the request to it.  The client is kept on hold at this time; </li><li>  Once the task is completed, the master returns the result to the client, and the child process is sent back to the pool. </li></ul><br><p>  If any child process dies, the supervisor creates it again and adds it to the pool.  We made a daemon from our application with a single purpose: to remove the initialization overhead, significantly increasing the speed of processing requests.  This is the most painless way to improve performance, but not the only one. </p><br><blockquote>  Note: <br>  A lot of examples from the series ‚ÄúTake ReactPHP and accelerate Laravel N times.‚Äù  It is important to understand the difference between demonization (and, consequently, saving time on bootstrapping the application) and multitasking. <br>  When using php-pm or roadrunner, your code does not become non-blocking.  You just save time on initialization. <br>  Comparing php-pm, roadrunner and ReactPHP / Amp / Swoole is incorrect by definition. </blockquote><br><h5 id="php-i-io">  PHP and I / O </h5><br><p>  Interacting with I / O in PHP is by default executed in blocking mode.  This means that if we execute a request to update the information in the table, the execution thread will pause waiting for a response from the database.  The more such calls during the processing of the request, the longer the server resources are idle.  After all, in the course of processing the request, we need to go several times to the database, write something to the log, and return the result to the client, in the end - also a blocking operation. </p><br><blockquote>  Imagine that you are a call center operator and you have to call 50 customers in an hour. <br>  You dial the first number, and there it is occupied (the subscriber discusses by phone the latest series of the Game of Thrones and what the series has rolled into). <br>  And here you sit and try to reach him before the victory.  Time passes, the change comes to an end.  Having lost 40 minutes to try to reach the first subscriber, you missed the opportunity to contact others and naturally received from the boss. <br>  But you can do otherwise: do not wait until the first subscriber is free and as soon as they heard the beeps, hang up and start dialing the next number.  You can return to the first one a little later. <br>  With this approach, the chances of ringing the maximum number of people greatly increase, and the speed of your work does not rest on the slowest task. </blockquote><p>  Code that does not block the thread of execution (does not use blocking I / O calls, as well as functions like <code>sleep()</code> ), is called asynchronous. </p><br><p>  Let's return to our symfony CRUD application.  It is almost impossible to force it to work in asynchronous mode due to the abundance of using blocking functions: all work with configs, caches, logging, response rendering, interaction with the database. </p><br><p>  But these are all conventions, let's try to throw out Symfony and use <a href="https://amphp.org/amp/">Amp</a> , which provides the implementation of the Event Loop (including a number of binders), Promises and Coroutines as a cherry on the cake, to solve our problem. </p><br><p>  Promise is one of the ways to organize asynchronous code.  For example, we need to make a call to any http resource. </p><br><p>  We create the request object and pass it to the transport, which returns us a Promise containing the current state.  There are three possible states: </p><br><ul><li>  Success: our request was successfully completed; </li><li>  Error: in the process of executing the request, something went wrong (for example, the server returned a 500 response); </li><li>  Waiting: request processing has not yet begun. </li></ul><br><p>  Each Promise has one method ( <a href="https://amphp.org/amp/promises/">Promise from Amp</a> understands the example) - <code>onResolve()</code> , to which a callback function with two arguments is passed. </p><br><pre> <code class="php hljs">$promise-&gt;onResolve( <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(?/Throwable $throwable, $result)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> !== $throwable) { <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> } );</code> </pre> <br><p>  After we received the Promise, the question arises: who will monitor its status and inform us about the status change? </p><br><p>  To do this, use the Event Loop. </p><br><p>  In essence, an Event Loop is a scheduler that controls execution.  As soon as the task is completed (no matter how), the callable will be called, which we transferred to Promise. </p><br><p>  As for the nuances, I would recommend reading the article from Nikita Popov: <a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines</a> .  It will help to bring some clarity about what is happening and where does the generators. </p><br><p>  Armed with new knowledge, let's try to return to our task of rendering JSON. <br>  <a href="http-server/blob/master/examples/hello-world.php">An example of</a> processing an incoming http request using <a href="http-server">amphp / http-server</a> . <br>  As soon as we receive a request, an asynchronous reading from the database is performed (we get Promise), and upon its completion, the cherished JSON will be given to the user, formed on the basis of the received data. </p><br><blockquote>  If we need to listen to one port from several processes, we can look towards <a href="https://github.com/amphp/cluster">amphp / cluster</a> </blockquote><p>  The main difference is that a single process can serve several requests at a time because the thread is not blocked.  The client will receive his answer when the reading from the database is completed, but for now there is no answer, you can take care of the next request. </p><br><h3 id="divnyy-mir-asinhronnogo-php">  Brave world of asynchronous php </h3><br><blockquote>  Disclaimer <br>  Asynchronous PHP is considered in the context of the exotic and is not considered something healthy / normal.  Most will be waiting for a laugh in the style of "take GO / Kotlin, fool", etc.  I would not say that these people are wrong, but ... </blockquote><p>  There are a number of projects that help in writing non-blocking PHP code.  Within the framework of this article, I will not begin to fully analyze all the pros and cons, and I will try only to superficially examine each of them. </p><br><h5 id="swoolehttpswwwswoolecouk">  <a href="https://www.swoole.co.uk/">Swoole</a> </h5><br><p>  Asynchronous framework, written in contrast to the rest of C and delivered as an extension to PHP.  It has, perhaps, the best performance indicators for the current moment. </p><br><p>  There is a realization of channels, korutin and other tasty pieces, but he has 1 big minus - documentation.  Although it is partly in English, it is not very detailed in my opinion, and the api itself is not very obvious. </p><br><p>  As for the community, it is also not all simple and straightforward.  Personally, I do not know of a single living person who uses Swoole in battle.  Perhaps I will overcome my fears and migrate to it, but this will not happen in the near future. </p><br><p>  It is also possible to add to the minuses that it is also difficult to contribute to the project (with the help of a pull request) with any changes if you don‚Äôt know C at the proper level. </p><br><h5 id="workermanhttpsgithubcomwalkorworkerman">  <a href="https://github.com/walkor/Workerman">Workerman</a> </h5><br><p>  If it loses in speed to its competitor (we are talking about Swoole), then it is not very noticeable and the difference in a number of scenarios can be neglected. </p><br><p>  It has integration with ReactPHP, which in turn expands the number of implementation points of infrastructure.  To save space, I will describe the drawbacks with ReactPHP. </p><br><h5 id="reactphphttpsreactphporg">  <a href="https://reactphp.org/">ReactPHP</a> </h5><br><p>  The advantages include a fairly large community and a huge number of examples.  Cons are beginning to manifest in the process of use - this is the concept of Promise. <br>  If you need to perform several asynchronous operations, the code turns into an endless then call wrapper (here's <a href="https://github.com/jakubkulhan/bunny">an example of a simple connection to RabbiqMQ</a> without creating exchange / queue and their binding). </p><br><p>  With some modification by a file (considered normal), you can get a coruntine implementation that will help get rid of Promise hell. </p><br><p>  Without the <a href="https://github.com/recoilphp">recoilphp / recoil project,</a> using ReactPHP, in my opinion, is not possible in any sane application. </p><br><p>  Also, among other things, it seems that its development has slowed down very much.  Not enough, for example, normal operation with PostgreSQL. </p><br><h5 id="amphttpsamphporgamp">  <a href="https://amphp.org/amp/">Amp</a> </h5><br><p>  In my opinion the best of the options that exist at the current time. <br>  In addition to the usual Promise, there is an implementation of Coroutine, which greatly simplifies the development process and the code looks most familiar to PHP programmers. </p><br><p>  Developers are constantly complementing and improving the project, with feedback there are also no problems. </p><br><p>  Unfortunately, with all the advantages of the framework, the community is relatively small, but there are implementations, for example, working with PostgreSQL, as well as all the basic things (file system, http client, DNS, etc). </p><br><p>  I still do not quite understand the fate of the ext-async project, but the guys keep up with it.  What will come of this in version 3, time will tell. </p><br><h3 id="pristupaem-k-realizacii">  We start implementation </h3><br><p>  So, we have a little dismantled the theoretical part, it's time to move on to practice and fill the bumps. </p><br><p>  First, let's formalize the requirements a bit: </p><br><ul><li>  Asynchronous messaging (the very concept of <code>message</code> can be divided into 2 types) <br><ul><li>  <code>command</code> : indicates the need to perform a task.  Does not return a result (at least in the case of asynchronous communication); </li><li>  <code>event</code> : reports any state change (for example, as a result of a command). </li></ul></li><li>  Non-blocking format for working with I / O; </li><li>  The ability to easily increase the number of handlers; </li><li>  Ability to write message handlers in any language. </li></ul><br><blockquote>  Any message is essentially a simple structure and is separated only by semantics.  The naming of messages is extremely important from the point of view of understanding the type and purpose (although in the example this moment is ignored). </blockquote><p>  According to the list of requirements, a simple implementation of the <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber">Publish / Subscribe</a> pattern is best suited. <br>  To ensure distributed execution, we use RabbitMQ as the message broker. </p><br><p>  The prototype was written using <a href="https://reactphp.org/">ReactPHP</a> , <a href="https://github.com/jakubkulhan/bunny">Bunny,</a> and <a href="https://github.com/doctrine/dbal">DoctrineDBAL</a> . <br>  The attentive reader may have noticed that Dbal uses blocking calls pdo / mysqli inside, but at the current stage it was not particularly important, as it was necessary to understand what should happen in the end. </p><br><p>  One of the problems was the lack of libraries to work with PostgreSQL.  There are some sketches, but this is not enough to complete the work (see below). </p><br><p>  After a brief survey, ReactPHP was removed in favor of Amp, since it is relatively simple and is developing very actively. </p><br><h5 id="rabbitmq-transport">  RabbitMQ transport </h5><br><p>  But with all the advantages of Amp there was 1 problem: there is no ready driver for RabbitMQ ( <a href="https://github.com/jakubkulhan/bunny">Bunny</a> supports only ReactPHP). </p><br><p>  In theory, Amp allows you to use Promise from a competitor.  It would seem that everything should be simple, but the ReactPHP Event Loop is used to work with sockets in the library. <br>  At one point in time, obviously, there cannot be two different Event Loops running, so I could not use the <a href="https://github.com/Amphp/Amp/blob/master/lib/functions.php">adapt ()</a> function. </p><br><p>  Unfortunately, the quality of the code in bunny left much to be desired and it was not possible to adequately replace one implementation with another.  In order not to stop the work, it was decided to rewrite the library a little so that it would work with Amp and not lead to blocking the flow of execution. </p><br><p>  This adaptation looked very scary, all the time I was extremely ashamed of her, but most importantly - she worked.  Well, since there is nothing more permanent than temporary, the adapter is waiting for a person who is not too lazy to implement the driver. </p><br><p>  And such a person was found.  The <a href="https://github.com/phpinnacle">PHPinnacle</a> project, among other things, provides an <a href="https://github.com/phpinnacle/ridge">adapter</a> implementation sharpened by using Amp. </p><br><blockquote>  The author's name is Anton Shabovt, who <a href="https://phprussia.ru/2019/abstracts/5013">will talk about asynchronous php</a> within <a href="https://phprussia.ru/2019">PHP Russia</a> and about <a href="https://fwdays.com/en/event/php-fwdays-2019/review/implementing-async-binary-clients-in-php">developing drivers</a> for <a href="https://fwdays.com/en/event/php-fwdays-2019">PHP fwdays</a> . </blockquote><br><h5 id="postgresql">  PostgreSQL </h5><br><p>  The second feature of the work is interaction with the database.  Under the conditions of ‚Äútraditional‚Äù PHP, everything is simple: we have a connection and all requests are executed sequentially. </p><br><p>  In the case of asynchronous execution, we should be able to execute several requests at a time (for example, 3 transactions).  In order to be able to do this, a connection pool is needed. </p><br><p>  The mechanism of operation is quite simple: </p><br><ul><li>  we open <em>N</em> connections at startup (or deferred initialization, not the point); </li><li>  if necessary, we take a connection from the pool, ensuring that no one else can use it; </li><li>  execute the request and either destroy the connection or return it to the pool (preferably). </li></ul><br><p>  Firstly, it allows us to start several transactions at one time, and, secondly, it speeds up work due to the presence of already open connections.  Amp has a component <a href="https://github.com/amphp/postgres">amphp / postgres</a> .  It takes over work with connections: it monitors their number, lifetime and all this without blocking the flow of execution. </p><br><p>  By the way, when using, for example, ReactPHP, you have to implement this yourself if you want to work with the database. </p><br><h5 id="mutex">  Mutex </h5><br><p>  For effective and, most importantly, proper operation of the application, you need to implement something like mutexes.  We can identify 3 scenarios for their use: </p><br><ul><li>  Within one process, a simple in-memory mechanism is suitable without any surplus; </li><li>  If we want to provide blocking in several processes, then we can use the file system (of course, in non-blocking mode); </li><li>  If in the context of several servers, then there is already a need to think about something like Zookeeper. </li></ul><br><p>  Mutexes are needed to solve <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8">race condition</a> related problems.  After all, we do not know (and cannot know) in which order our tasks will be performed, but nevertheless we must ensure the integrity of the data. </p><br><h5 id="logirovaniekonteksty">  Logging / Contexts </h5><br><p>  <a href="https://github.com/Seldaek/monolog">Monolog is</a> used for logging, but with some reservations: we cannot use the built-in handlers, as they will lead to locks. <br>  To write to stdOut, you can take <a href="https://github.com/amphp/log">amphp / log</a> , or write a simple sending of messages to some Graylog. </p><br><p>  Since at one point in time we can handle many tasks and when writing logs it is necessary to understand the context in which the data is written.  During the experiments, it was decided to do <code>trace_id</code> ( <a href="https://microservices.io/patterns/observability/distributed-tracing.html">Distributed tracing</a> ).  The bottom line is that the entire call chain must be accompanied by a pass-through identifier that can be tracked.  Additionally, at the time of receiving the message, a <code>package_id</code> generated, which indicates exactly the received message. </p><br><p>  Thus, with the use of both identifiers, we can easily track to what a particular entry refers.  The thing is that in traditional PHP all the records we get in the log mainly in the order in which they were recorded.  In the case of asynchronous execution, there is no pattern in the order of records. </p><br><h5 id="terminating">  Terminating </h5><br><p>  Another of the nuances of asynchronous development is control over the disabling of our daemon.  If you just kill the process, then all the running tasks will not be completed, and the data will be lost. In the usual approach, there is also such a problem, but it is not so great, because only one task is being performed at the same time. </p><br><p>  To complete the execution correctly, we need to: </p><br><ul><li>  Unsubscribe from the queue.  In other words, to make it impossible to receive new messages; </li><li>  Finish all remaining tasks (wait for re-resolution of promises); </li><li>  And only after that, complete the script. </li></ul><br><h5 id="utechki-otladka">  Leaks, debugging </h5><br><p>  Contrary to popular belief, in modern PHP it‚Äôs not so easy to face situations where a memory leak occurs.  It is necessary to do something completely wrong. </p><br><p>  However, once faced with this, but because of the banal inattention.  During implementation, heartbeat made it so that every 40 seconds a new timer was added to poll the connection.  It is not difficult to guess that after a while memory usage began to creep up and quite quickly. </p><br><p>  Also, among other things, I wrote a simple watcher, which will optionally run every 10 minutes and call <a href="https://www.php.net/manual/ru/function.gc-collect-cycles.php">gc_collect_cycles ()</a> and <a href="https://php.net/manual/ru/function.gc-mem-caches.php">gc_mem_caches ()</a> . <br>  But the forced launch of the garbage collector is not something necessary and important. </p><br><p>  In order to constantly see the memory usage, a standard <a href="https://github.com/Seldaek/monolog/blob/master/src/Monolog/Processor/MemoryUsageProcessor.php">MemoryUsageProcessor</a> was added to the <a href="https://github.com/Seldaek/monolog/blob/master/src/Monolog/Processor/MemoryUsageProcessor.php">logging</a> . </p><br><p>  If the thought arises that the Event Loop is blocked by something, it can also be easily checked: just connect <a href="https://github.com/php-service-bus/service-bus/blob/v3.2/src/Infrastructure/Watchers/LoopBlockWatcher.php">LoopBlockWatcher</a> . </p><br><p>  But you need to make sure that this observer does not start in the production environment.       . </p><br><h3 id="rezultaty">  results </h3><br><p>     : <a href="https://github.com/php-service-bus">php-service-bus</a> ,    Message Based . </p><br><p>    ,         : </p><br><pre> <code class="plaintext hljs">composer create-project php-service-bus/skeleton pub-sub-example cd pub-sub-example docker-compose up --build -d</code> </pre> <br><p>   ,      ,   . </p><br><p>   <code>/bin/consumer</code>   ,    . <br>   <code>/src</code>  3 : <code>Ping</code>   ; <code>Pong</code> :    ; <code>PingService</code> : ,   . <br>     <code>PingService</code> ,      2 : </p><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@CommandHandler</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ping $command, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $context-&gt;delivery(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pong()); } <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@EventListener</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenPong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pong $event, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $context-&gt;logContextMessage(<span class="hljs-string"><span class="hljs-string">'Pong message received'</span></span>); }</code> </pre> <br><ul><li> <code>handle</code>    (        1 ).      <code>@CommandHandler</code> ; <br><ul><li>   Promise ,        RabbitMQ (   <code>delivery()</code> ).       ,   RabbitMQ    . </li></ul></li><li> <code>whenPong</code> ‚Äî   <code>Pong</code> .            .     <code>@EventListener</code> ; <br><blockquote>  ,     ‚Äî   . , , ,     .     php-service-bus  , ,            . <br></blockquote></li></ul><br><p>     2 : ,   (  )  .          ,     ,     (, ). </p><br><p>     <code>Ping</code> ,      <code>Pong</code> .     . </p><br><p>    ,       RabbitMQ: </p><br><pre> <code class="plaintext hljs">tools/ping</code> </pre> <br><p>    ,  php-service-bus     ,  Message based . </p><br><p> Ping\Pong,    ‚Äî ,  ,  <code>Hello, world</code>       . </p><br><p>     ,    <a href="https://github.com/php-service-bus/documentation"></a> . </p><br><p>     - ,    , , Saga pattern (Process manager)        . </p><br><h3 id="nu-i-kak-zhe-ne-pomeryatsya">       </h3><br><p>   ,   <a href="https://github.com/php-service-bus/performance-comparison">  symfony/messenger</a> . </p><br><p>    ,      ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/451916/">https://habr.com/ru/post/451916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451902/index.html">Microsoft Azure Developer Camp Russia</a></li>
<li><a href="../451904/index.html">Sometimes more is less. When reducing the load increases the delay</a></li>
<li><a href="../451906/index.html">Exchange Vulnerability: How to Detect Privilege Elevation by Domain Administrator</a></li>
<li><a href="../451908/index.html">The history of computers: night at the Yandex Museum</a></li>
<li><a href="../451912/index.html">MuseNet Deep Neural Network Writes Music</a></li>
<li><a href="../451918/index.html">On the issue of TI</a></li>
<li><a href="../45192/index.html">Ltsp. We connect Flash-carriers for clients</a></li>
<li><a href="../451920/index.html">Optimization of mail storage in the Zimbra Collaboration Suite</a></li>
<li><a href="../451922/index.html">Fixed point arithmetic in C ++</a></li>
<li><a href="../451926/index.html">About live-code after 130 streams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>