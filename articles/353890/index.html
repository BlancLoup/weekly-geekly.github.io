<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple filter to automatically remove the background from images</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many ways to remove a background from an image of an object by making it transparent (in graphic editors, special services). But sometimes i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple filter to automatically remove the background from images</h1><div class="post__text post__text-html js-mediator-article">  There are many ways to remove a background from an image of an object by making it transparent (in graphic editors, special services).  But sometimes it may be necessary to remove the background from a variety of photos with minimal human involvement. <br><br>  I want to share a way based on creating a transparency mask using <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258F">the Sobel operator</a> and some other transformations.  The basic idea is not new at all, but the use of some additional techniques in the right order made it possible to improve the results, which this note will be about. <br><br><img src="https://habrastorage.org/webt/qy/au/gj/qyaugjh84pei6weajkflho6sdag.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Implementation became possible thanks to <a href="https://opencv.org/">OpenCV</a> and C # wrapper <a href="https://github.com/shimat/opencvsharp">OpenCVSharp</a> . <br><a name="habracut"></a><br><h2>  General scheme </h2><br>  The main task is to form an alpha channel based on the input image, thus leaving only the object of interest on it. <br><br><ol><li>  <b>Edge detection</b> : We create the basis for the future mask by acting on the original image using the gradient calculation operator. </li><li>  <b>Fill</b> : we fill the outer area with black color. </li><li>  <b>Noise</b> removal: we remove the non-filled islands of pixels, smooth the borders. </li><li>  <b>Final stage</b> : We perform binarization of the mask, slightly blur and get the output alpha channel. </li></ol><br>  Consider each item in detail on the example of my mouse with KDPV.  The full filter code can be found in the <a href="https://github.com/ArXen42/BackgroundRemovalSample">repository</a> . <br><br><h3>  Preliminary preparation </h3><br>  Under the spoiler, there is a base filter class that defines its interface, we will inherit from it.  Introduced for convenience, it does not require special explanation, it is made in the image of BaseFilter from Accord .NET, another very worthy .NET library for image processing and more. <br><br>  I will only note that the <b>Mat</b> used here is the universal OpenCV entity, representing a matrix with elements of a certain type (MatType) and with a certain number of channels.  For example, a matrix with elements of type CV_8U3 is suitable for storing images in the RGB (BGR) format, one byte per color.  And CV_32FC1 is for storing a single-channel image with float values. <br><br><div class="spoiler">  <b class="spoiler_title">Opencvfilter</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Base class for custom OpenCV filters. More convenient than plain static methods. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class OpenCvFilter { static OpenCvFilter() { Cv2.SetUseOptimized(true); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Supported depth types of input array. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;MatType&gt;</span></span></span><span class="hljs-comment"> SupportedMatTypes { get; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Applies filter to </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="src" /&gt;</span></span></span><span class="hljs-comment"> and returns result. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="src"&gt;</span></span></span><span class="hljs-comment">Source array.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Result of processing filter.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public Mat Apply(Mat src) { var dst = new Mat(); ApplyInPlace(src, dst); return dst; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Applies filter to </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="src" /&gt;</span></span></span><span class="hljs-comment"> and writes to </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="dst" /&gt;</span></span></span><span class="hljs-comment">. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="src"&gt;</span></span></span><span class="hljs-comment">Source array.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="dst"&gt;</span></span></span><span class="hljs-comment">Output array.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;exception cref="ArgumentException"&gt;</span></span></span><span class="hljs-comment">Provided image does not meet the requirements.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/exception&gt;</span></span></span><span class="hljs-comment"> public void ApplyInPlace(Mat src, Mat dst) { if (!SupportedMatTypes.Contains(src.Type())) throw new ArgumentException("Depth type of provided Mat is not supported"); ProcessFilter(src, dst); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Actual filter. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="src"&gt;</span></span></span><span class="hljs-comment">Source array.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="dst"&gt;</span></span></span><span class="hljs-comment">Output array.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected abstract void ProcessFilter(Mat src, Mat dst); }</span></span></code> </pre> <br></div></div><br><h3>  Edge detection </h3><br>  The fundamental stage of the filter.  In the most basic version can be implemented as: <br><br><div class="spoiler">  <b class="spoiler_title">As in tutorials</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Performs edges detection. Result will be used as base for transparency mask. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private Mat GetGradient(Mat src) { using (var preparedSrc = new Mat()) { Cv2.CvtColor(src, preparedSrc, ColorConversionCodes.BGR2GRAY); preparedSrc.ConvertTo(preparedSrc, MatType.CV_32F, 1.0 / 255); // From 0..255 bytes to 0..1 floats using (var gradX = preparedSrc.Sobel(ddepth: MatType.CV_32F, xorder: 0, yorder: 1, ksize: 3, scale: 1 / 4.0)) using (var gradY = preparedSrc.Sobel(ddepth: MatType.CV_32F, xorder: 1, yorder: 0, ksize: 3, scale: 1 / 4.0)) { var result = new Mat(); Cv2.Magnitude(gradX, gradY, result); return result; } } }</span></span></code> </pre><br></div></div><br>  This is a typical example of using the Sobel function: <br><br><ol><li>  Let's discolor the image (there is practically no sense in the calculation of the gradient for all three channels - the result will be very little different). </li><li>  Calculate the vertical and horizontal components. </li><li>  We calculate the final result using the <a href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html">Magnitude</a> function. </li></ol><br>  Here you should pay attention to the following: <br><br><ul><li>  The kernel size (ksize) is transferred to the Sobel function. 3. A kernel of this size is used most often. </li><li>  A 1/4 normalization factor is also transmitted.  Normalization is required to obtain a clean image with optimal brightness and minimal noise.  More details can be found in <a href="https://stackoverflow.com/questions/40444560/opencvs-sobel-filter-why-does-it-look-so-bad-especially-compared-to-gimp/40575153">this</a> question (the value of the accepted answer to which, perhaps, exceeds the value of the entire given post). </li></ul><br>  Unfortunately, this simple code is not always suitable.  The problem is that the Sobel operator is resolution-dependent.  The left half of the image below is the result for an image size of 1280x853.  Right - the result for the original photos 5184x3456. <br><br><img src="https://habrastorage.org/webt/ue/zf/qm/uezfqmu6hbfrpwszkbomrb2bkhw.png"><br><br>  The lines of the edges of objects have become much less pronounced, since, with the same core size, the pixel distances between the same points of the image have become several times larger.  For less successful photographs (the object is worse to separate from the background) important details may be completely lost. <br><br>  The Sobel function can accept other kernel sizes.  But to use it anyway will not work for the following reasons: <br><br><ul><li>  Kernels of arbitrary sizes inside are generated by integers and require normalization, otherwise the range of the values ‚Äã‚Äãobtained will be different from 0..1 and it will be difficult to work with them further, the image will be very noisy and overexposed after applying magnitude. </li><li>  What specific kernels were chosen by the OpenCV developers for sizes larger than 5 is undocumented.  You can find <a href="https://stackoverflow.com/questions/9567882/sobel-filter-kernel-of-large-size">discussions</a> of larger kernels, but not all of them coincide with what is used in OpenCV. </li><li>  Internal functions in <a href="">deriv.cpp</a> have a normalize boolean parameter, but the cv :: sobel function calls them with the false parameter. </li></ul><br>  Fortunately, OpenCV allows you to independently call these functions with automatic normalization, so you don‚Äôt have to invent your own generation of cores: <br><br><div class="spoiler">  <b class="spoiler_title">What happened</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGradient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mat src</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> preparedSrc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat()) { Cv2.CvtColor(src, preparedSrc, ColorConversionCodes.BGR2GRAY); preparedSrc.ConvertTo(preparedSrc, MatType.CV_32F, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Calculate Sobel derivative with kernel size depending on image resolution Mat Derivative(Int32 dx, Int32 dy) { Int32 resolution = preparedSrc.Width * preparedSrc.Height; // Larger image --&gt; larger kernel Int32 kernelSize = resolution &lt; 1280 * 1280 ? 3 : resolution &lt; 2000 * 2000 ? 5 : resolution &lt; 3000 * 3000 ? 9 : 15; // Compensate lack of contrast on large images Single kernelFactor = kernelSize == 3 ? 1 : 2; using (var kernelRows = new Mat()) using (var kernelColumns = new Mat()) { // Get normalized Sobel kernel of desired size Cv2.GetDerivKernels(kernelRows, kernelColumns, dx, dy, kernelSize, normalize: true ); using (var multipliedKernelRows = kernelRows * kernelFactor) using (var multipliedKernelColumns = kernelColumns * kernelFactor) { return preparedSrc.SepFilter2D( MatType.CV_32FC1, multipliedKernelRows, multipliedKernelColumns ); } } } using (var gradX = Derivative(1, 0)) using (var gradY = Derivative(0, 1)) { var result = new Mat(); Cv2.Magnitude(gradX, gradY, result); //Add small constant so the flood fill will perform correctly result += 0.15f; return result; } } }</span></span></code> </pre><br></div></div><br>  The code has become somewhat more complicated and has not been without small props.  Instead of using Sobel, a local Derivative function is declared, using GetDerivKernels to get normalized kernels and SepFilter2D to use them.  For larger images, larger kernel sizes are selected (GetDerivKernels supports sizes up to 31).  In order for the results between different sizes to have a minimum of differences, already normalized large kernels are additionally multiplied by 2 (the same backup). <br><br>  Let's look at the result: <br><br><img src="https://habrastorage.org/webt/4u/2e/up/4u2eupryihsb0igx5r-ms7stz2i.png"><br><br>  The picture is somewhat ‚Äúgrayed out‚Äù due to the added constant at the end.  The reason for such a strange action will be understood in the next step. <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  In addition to the operator Sobel there are others that give a slightly better result.  For example, in OpenCV from box Scharr is available.  But only for Sobel there is a built-in generator of nuclei of arbitrary size, so I used it. <br></div></div><br><h3>  Fill </h3><br>  Actually, fill in the simplest way - from the corner of the image.  FloodFillRelativeSeedPoint is just a constant that defines the relative indentation from the corner, and FloodFillTolerance is the ‚Äúgreed‚Äù of the fill: <br><br><div class="spoiler">  <b class="spoiler_title">Floodfill</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mat src, Mat dst</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Mat alphaMask = GetGradient(src)) { Cv2.FloodFill( <span class="hljs-comment"><span class="hljs-comment">// Flood fill outer space image: alphaMask, seedPoint: new Point( (Int32) (FloodFillRelativeSeedPoint * src.Width), (Int32) (FloodFillRelativeSeedPoint * src.Height)), newVal: new Scalar(0), rect: out Rect _, loDiff: new Scalar(FloodFillTolerance), upDiff: new Scalar(FloodFillTolerance), flags: FloodFillFlags.FixedRange | FloodFillFlags.Link4); ... } }</span></span></code> </pre><br></div></div><br>  And we get: <br><br><img src="https://habrastorage.org/webt/bf/o7/ze/bfo7ze7yub1jzwkt_-x44lkpi0m.png"><br><br>  I think it is now clear why the addition of a constant was required.  It is seen that there are noises, but this is the subject of the next item.  But before that, let's look at a less successful outcome of events for some other image ‚Äî say, a camera photo: <br><br><img src="https://habrastorage.org/webt/l8/y-/fw/l8y-fwbhuytiawdkxskmlic7wn4.png"><br><br>  It is seen that the black color "flowed" through a small gap to where it was not worth it.  Of course, you can try to lower FloodFillTolerance (here is 0.04), but in this case there are more pieces of background and noise that we don‚Äôt need.  And here, another very useful type of image operations is useful: <b>morphological transformations</b> .  The <a href="https://docs.opencv.org/trunk/d9/d61/tutorial_py_morphological_ops.html">documentation</a> has a great example of their actions, so I will not repeat.  Add one dilatation pass before pouring to close possible gaps in the contours: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mat src, Mat dst</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Mat alphaMask = GetGradient(src)) { <span class="hljs-comment"><span class="hljs-comment">// Performs morphology operation on alpha mask with resolution-dependent element size void PerformMorphologyEx(MorphTypes operation, Int32 iterations) { Double elementSize = Math.Sqrt(alphaMask.Width * alphaMask.Height) / 300; if (elementSize &lt; 3) elementSize = 3; if (elementSize &gt; 20) elementSize = 20; using (var se = Cv2.GetStructuringElement( MorphShapes.Ellipse, new Size(elementSize, elementSize))) { Cv2.MorphologyEx(alphaMask, alphaMask, operation, se, null, iterations); } } PerformMorphologyEx(MorphTypes.Dilate, 1); // Close small gaps in edges Cv2.FloodFill(...); } ... }</span></span></code> </pre><br></div></div><br>  Got better: <br><br><img src="https://habrastorage.org/webt/du/ix/tr/duixtr-wowrfnms8-7yg6lnurku.png"><br><br>  The local function PerformMorphologyEx simply applies the specified morphological operation to the image.  In this case, an ellipsoidal structural element is selected (it can be taken rectangular, but in this case sharp right angles will appear) with a size dependent on resolution (so that the results remain consistent on different image sizes).  The formula for choosing the size can still twist, it was chosen "by eye". <br><br><h3>  Noise reduction </h3><br>  Here we have the perfect polygon for the application of morphological opening - in one or two passes, all these islands of gray pixels are perfectly removed, and even the remnants of many shadows.  Add these three lines after the fill: <br><br><pre> <code class="cs hljs">PerformMorphologyEx(MorphTypes.Erode, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Compensate initial dilate PerformMorphologyEx(MorphTypes.Open, 2); // Remove not filled small spots (noise) PerformMorphologyEx(MorphTypes.Erode, 1); // Final erode to remove white fringes/halo around objects</span></span></code> </pre><br>  First, we do erosion to compensate for the dilation from the previous step, after which two iterations of erosion and dilation (morphological contraction and expansion, respectively).  While we receive the following: <br><br><img src="https://habrastorage.org/webt/oq/p_/35/oqp_35csf2ha9gh7mlr2fvmhjjy.png"><br><br>  The third line (passage by erosion) is needed in order to avoid the end result <br><br><div class="spoiler">  <b class="spoiler_title">such a stroke</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/fi/2l/akfi2lgnpn2zb9ia7wbftytfdnc.png"><br></div></div><br><h3>  Final stage </h3><br>  By and large, the mask is ready.  Add to the end of the filter: <br><br><div class="spoiler">  <b class="spoiler_title">Following code</b> <div class="spoiler_text"><pre> <code class="cs hljs">Cv2.Threshold( src: alphaMask, dst: alphaMask, thresh: <span class="hljs-number"><span class="hljs-number">0</span></span>, maxval: <span class="hljs-number"><span class="hljs-number">255</span></span>, type: ThresholdTypes.Binary); <span class="hljs-comment"><span class="hljs-comment">// Everything non-filled becomes white alphaMask.ConvertTo(alphaMask, MatType.CV_8UC1, 255); if (MaskBlurFactor &gt; 0) Cv2.GaussianBlur(alphaMask, alphaMask, new Size(MaskBlurFactor, MaskBlurFactor), MaskBlurFactor); AddAlphaChannel(src, dst, alphaMask);</span></span></code> </pre><br>  AddAlphaChannel simply adds an alpha channel to the input image and writes the result to the output: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Adds transparency channel to source image and writes to output image. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private static void AddAlphaChannel(Mat src, Mat dst, Mat alpha) { var bgr = Cv2.Split(src); var bgra = new[] {bgr[0], bgr[1], bgr[2], alpha}; Cv2.Merge(bgra, dst); }</span></span></code> </pre><br></div></div><br>  Here is the final result <br><br><img src="https://habrastorage.org/webt/be/td/d1/betdd1dpnoaimq66l22mmfjdlje.png"><br><br>  Of course, the method is not ideal.  The most notable problems: <br><br><ul><li>  If you try to remove the background from a donut or similar object, the inner region will not be cut (since the fill will not go inside). </li><li>  Shadows.  Partially overcome by sensitivity, partially removed along with noise, but, often, one way or another get into the final result.  It remains to either live with them, or additionally implement the search and removal of shadows. </li></ul><br>  However, for many images the result is acceptable, maybe this method will be useful to someone ( <a href="https://github.com/ArXen42/BackgroundRemovalSample">source</a> ).  My goal was to remove the background from photographs of objects taken using such <a href="http://photomechanics.ru/3d-%25D0%25BF%25D0%25BE%25D0%25B2%25D0%25BE%25D1%2580%25D0%25BE%25D1%2582%25D0%25BD%25D1%258B%25D0%25B5-%25D1%2581%25D1%2582%25D0%25BE%25D0%25BB%25D1%258B">turntables</a> . </div><p>Source: <a href="https://habr.com/ru/post/353890/">https://habr.com/ru/post/353890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353878/index.html">How to hide DNS requests from the prying eyes of the provider</a></li>
<li><a href="../353880/index.html">Telegram and AWS Blocking - Morning does not start with coffee</a></li>
<li><a href="../353884/index.html">Sophisticated javascript call center</a></li>
<li><a href="../353886/index.html">Asynchronous Loops and Stream APIs in Node.js 10</a></li>
<li><a href="../353888/index.html">Where and how to grow talents?</a></li>
<li><a href="../353892/index.html">Splunk Scripted Input. Or how to use scripts to obtain data on the operation of systems and analyze them in Splunk</a></li>
<li><a href="../353896/index.html">SvelteJS: Second Version Release</a></li>
<li><a href="../353898/index.html">From custom websites to enterprise products</a></li>
<li><a href="../353902/index.html">Newman and Continuous Integration on the example of Atlassian Bamboo. The invention of the bicycle</a></li>
<li><a href="../353904/index.html">Pedro Uria: "The problem for information security will not be malware, but hackers"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>