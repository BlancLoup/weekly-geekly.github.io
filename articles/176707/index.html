<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to run a program without an operating system: part 3: Graphics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this part we will try to do the ‚Äúimpossible‚Äù: learn how to use a graphic display without an operating system. In fact, this is not an easy task, es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to run a program without an operating system: part 3: Graphics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/8f0/4e4/3fb/8f04e43fb5a6c190278c961f1f968d7b.jpg"><br><br>  In this part we will try to do the ‚Äúimpossible‚Äù: learn how to use a graphic display without an operating system.  In fact, this is not an easy task, especially when working in 32-bit protected mode, and especially if you want to use a decent screen resolution and not 320x200x8.  But everything is in order: if we want graphics - it means you need to work with a video card. <br><br>  Modern graphics cards are practically full-fledged computers that are as powerful as the main ones: here you can decode MPEG2 as 1080p, support 3D graphics and shaders, technologies like CUDA, and much more.  It all looks very difficult.  On the other hand, the video card is just another PCI device, the same as the rest.  We even ‚Äúfound‚Äù this device <a href="http://habrahabr.ru/company/neobit/blog/174157/">in the previous article</a> with the device class number <i>0x03 (class_name = graphics adapter)</i> .  As with any device, a video card device can be operated using I / O ports or MMIO memory areas, and the video card itself can use DMA and interrupts to interact with the main processor.  If you look at the range of I / O ports that are available for video cards, we see that it is allocated less than 50 bytes - not so much considering the enormous functionality that modern video cards have. <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage2/7b5/493/1b0/7b54931b0c131828626bbe0589878abe.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      According to the VGA standard, two ranges of input / output ports will be used for working with a video card: <b>0x03B0-0x03BB</b> and <b>0x3C0-0x3DF</b> .  In addition to these ranges, there is also a range of video memory ( <b>0xA0000-0xBFFFF</b> ) displayed in the main memory. <br><img src="https://habrastorage.org/storage2/b17/226/321/b172263214908a7d7fe1506fb14654a0.jpg"><br><br>  Video memory is the representation of a graphic screen in the form of conventional memory.  It turns out that to draw a pixel or a character on the screen, you need to write bytes in this memory range. <br>  Since there is a standard to which modern video cards correspond, it is expected that with the help of the standard it will be possible to use a video card without going into details of its implementation. <br><br>  Unfortunately, there is one thing: VGA is an old standard and is designed to use simple graphic displays with a small, by modern standards, screen resolution.  The standard defines a couple of dozens of different graphic and text modes (you can see everything <a href="http://ru.wikipedia.org/wiki/VGA">here</a> ), among which the ‚Äúcoolest‚Äù are: 320x200 in 256 colors and 640x480 in 16 colors.  In this case, the standard includes only the functions of switching modes and functions for working with the palette.  And where are the normal screen resolutions: 1920x1080 24 bits, or at least 800x600 24 bits?  Where is the support for MPEG2 graphics?  Where is 3D graphics?  In the VGA standard this is not.  About the graphics modes, you can still say that they are included in the SVGA standard, which is handled through the BIOS VBE extensions, which will be discussed further.  And 3D, MPEG2, CUDA and other fashionable chips are supported by each video card manufacturer in their own way.  The limiting screen resolution of 640x480 in the VGA standard, in addition to calculating the old displays, is determined by the video memory size: only 128 kilobytes (to work with a higher resolution, much more space is needed: 1920x1080 24bit - this is more than 6Mb).  It means that there is still a large video memory area, and modern video cards have such an area: <br><img src="https://habrastorage.org/storage2/69a/b5b/b60/69ab5bb60e88a368b715aa3dc767f98d.jpg"><br><br>  One of the above ranges is used as the Linear Frame Buffer (LFB) - also the video memory.  The second address range is used to display hundreds of registers and bit fields that are used to configure the video card.  Moreover, the set of registers and the ways of working with them are unique not only for each video card manufacturer - they can differ significantly between the series and even the models of one manufacturer, and all this is necessary to ensure the operation of CUDA, MPEG2, 3D, ... Source codes of all graphic Linux drivers take up more than 8 megabytes: <br><img src="https://habrastorage.org/storage2/d3d/b2b/e4b/d3db2be4b2d56283331e5e0bc04571e9.jpg"><br><br>  Here is an example of a video card driver for one of the manufacturers: <br><br><img src="https://habrastorage.org/storage2/074/b76/fa3/074b76fa338e913ed18e00e062f5cba1.jpg"><br><br>  The rest contain even more code. And this is without the additional Linux libraries that are used in the drivers. <br><br>  So, to provide support for 3D or streaming video, you need a lot of work.  As the saying goes: if you have another life to spend, then ... <br><br>  However, in this article we will focus on simply turning on a decent graphics mode and drawing something beautiful in it: for example, a fractal.  Let's see how easy it is. <br><br>  Let's start with the fact that decent graphics modes belong to the SVGA standard and are available for inclusion through the BIOS VBE extension (VESA BIOS Extension).  VBE is a BIOS extension whose code is located on the video card itself and allows you to work with it.  The standard of extensions VBE includes several functions that can be used: <br>  1. Getting information about the graphics device.  Is VESA supported, the amount of video memory on a video card, and so on. <br>  2. Getting information about it by the mode number: screen resolution, pointer to LFB and bit depth. <br>  3. Turn on the video mode by its number. <br>  4. Turning on the bank for video mode by bank number, about them below. <br>  5. Other functions including palette control, which is needed for 8-bit modes. <br><br>  Full specifications can be found <a href="http://www.phatcode.net/res/221/files/vbe20.pdf">here</a> .  We briefly describe what you have to work with. <br><br>  All modes supported by the video card are numbered in order from 0x000 to 0x1FF.  Not all numbers are occupied and not all numbers after 0x100 have the exact value of the screen resolution in the standard: thus, the number still needs to be found at the required screen resolution.  Mode numbers up to 0x100 are defined by the VGA standard and completely coincide with it.  LFB - Linear Frame Buffer, is an area of ‚Äã‚Äãvideo memory designed for large screen resolutions (usually it is located outside the RAM, but up to 4GB). <br><br>  Without LFB, the standard video memory area from 0xA0000 to 0xC0000 is used to work with all graphics modes.  In this case, the ‚Äúbanks‚Äù mode will be used.  The whole screen is divided into numbered parts (banks) and at each moment of time the video memory area points to one of such parts.  That is, before you draw a pixel on the screen, you will need to set the bank number, then draw a pixel, referring to the video memory.  Thus, the same memory area can be reused to work with different areas on the display. <br><br><img src="https://habrastorage.org/storage2/e36/ef6/e1f/e36ef6e1f07ea326669f8f6f4f7f6d02.jpg"><br><br>  Using LFB is simpler and faster because you don‚Äôt need to switch anything and the entire display is displayed in the LFB.  Video memory in LFB is organized in a linear fashion: the counting of pixels begins line by line from the upper left corner of the screen.  Each pixel is represented by one, two, three or four bytes, depending on the bit depth of the current graphics mode.  The bytes are located in a row and the pixel color is encoded in them.  The simplest and most decent modes are 32-bit and 24-bit (three and four byte).  In these modes, each color channel (Red, Green, Blue) is represented by the 1st byte.  In 32-bit mode, another byte is reserved and not used (we can say that it is used for alignment).  Another feature with LFB: as standard, to enable LFB in the mode number you need to set one more bit: mode_number |  0x4000. <br><br><img src="https://habrastorage.org/storage2/9dd/fdf/34d/9ddfdf34d5a0cd55fad0d460a9fe5fdd.jpg"><br><br>  Thus, using function number 2 (in the list above), you can find the mode number with LFB and enable it with function number 3. Then you can draw on the screen by simply writing down the Baitics with RGB values ‚Äã‚Äãat the desired offset in the LFB buffer. <br>  So far, everything looks promising, but VBE is a BIOS extension and it is a 16-bit code for Real-Mode that processes a specific BIOS function (in our case, 10h).  It turns out that you need to use VBE (16-bit Real Mode) from the usual 32-bit Protected Mode, which we received in the previous article.  There are three ways to do this: <br>  1. Switch to Real Mode, perform the necessary actions, go back to Protected Mode.  It is necessary to write transition functions between modes, save the state of the processor, and, in general, interrupts must also be correctly processed. <br>  2. Use the VBE extension through a 16-bit interface from Protected Mode.  To do this, you need to configure descriptor tables, create a call gate, compile a 16-bit code, and configure another additional structure according to the VBE standard.  It is also not very convenient, besides not all video cards support this extension. <br>  3. Use the 16-bit emulator Real Mode, which works in Protected Mode.  The only limitation of this emulator is that it will be difficult to write interrupt handlers for the video card itself, but we don‚Äôt need it, because all VBE functions do not use video card interrupts. <br><br>  The third way is the easiest, because you can take a ready-made x86emu emulator (simple and well-portable) and use it to call VBE functions. <br>  Of course, we will have to work, but for a relatively small number of actions we will be able to assemble a program that on any modern video card can, <b>without an operating system</b> , turn on the graphics mode and draw a fractal.  So far without shaders and 3D but, but the graphics. <br><br>  <b>!</b>  <b>IMPORTANT!</b>  : All further actions can be successfully carried out only after successful completion of all 6 steps from the first part of the article <a href="http://habrahabr.ru/company/neobit/blog/173263">‚ÄúHow to run a program without an operating system‚Äù</a> <br><br>  Our plan: <br><br>  1. Add a few functions in common that we need for x86emu and drawing fractals. <br>  2. Port x86emu. <br>  3. Write a few functions to work with VBE. <br>  4. Write the function of drawing a fractal. <br>  5. All merge and run. <br><br>  Let's get started <br><br><h5>  Step 1. We supplement common standard functions. </h5><br><br>  First you need to add a few functions to work with 64-bit numbers.  They will need gcc to compile x86emu. <br><br>  1. Add the following files to the common folder: <b>udivdi3.c</b> , <b>umoddi3.c</b> , <b>moddi3.c</b> , <b>qdivrem.c</b> , <b>divdi3.c</b> .  They can be taken <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/quad">here</a> . <br><br>  2. Next you need to add another file <b>quad.h</b> to include.  It can also be obtained from <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/quad/">www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/quad</a> .  In it you need to replace the lines: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/types.h&gt; #if !defined(_KERNEL) &amp;&amp; !defined(_STANDALONE) #include &lt;limits.h&gt; #else #include &lt;sys/limits.h&gt; #endif</span></span></span></span></code> </pre> <br><br>  on the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> ‚Äútypes.h‚Äù</span></span></code> </pre><br><br>  3. Now, download the <a href="">newlib</a> library. It will be needed for one more function.  From the library sources, copy the file <b>newlib-2.0.0 \ newlib \ libm \ math \ s_floor.c</b> to the common folder.  We replace the line in it: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fdlibm.h"</span></span></span></span></code> </pre><br>  per line: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span></span></code> </pre><br>  4. You also need to add the <b>setjmp / longjmp</b> functions.  The x86emu emulator uses these functions to handle errors.  The implementation of these functions is given below; it was created based on the implementation from newlib, but was slightly simplified.  The function allows you to save the state of the processor, and then restore it.  Essentially similar to the manual implementation of C ++ exceptions.  In order for these functions to appear in our code, you need to create a file <b>setjmp.s</b> in common with the following content (a little simple assembler): <br><pre> <code class="bash hljs"> .globl setjmp setjmp: movl 4(%esp),%ecx movl 4(%ebp), %edx movl %edx, 0(%ecx) movl %ebx, 4(%ecx) addl <span class="hljs-variable"><span class="hljs-variable">$4</span></span>,%ebp movl %ebp, 8(%ecx) subl <span class="hljs-variable"><span class="hljs-variable">$4</span></span>,%ebp movl (%ebp),%edx movl %edx,12(%ecx) movl %esi,16(%ecx) movl %edi,20(%ecx) movl %eax,24(%ecx) xorl %eax,%eax ret .globl longjmp longjmp: movl 4(%esp),%edx movl 8(%esp),%eax movl 0(%edx),%ecx movl 4(%edx),%ebx movl 8(%edx),%esp movl 12(%edx),%ebp movl 16(%edx),%esi movl 20(%edx),%edi testl %eax,%eax jnz 1f incl %eax 1: movl %ecx,0(%esp) ret</code> </pre><br><br>  The assembler code simply saves the registers in a certain order, and then restores them. <br>  5. Now you need to declare the functions for C. To do this, create a file <b>setjmp.h</b> in include with the following content: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SETJMP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SETJMP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _JBLEN 10 typedef long jmp_buf[_JBLEN]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int setjmp (jmp_buf); void longjmp (jmp_buf, int); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  6. Another important set of functions that is required is the functions of working with strings and memory (memset, strlen, etc.).  These functions are ready to be taken from <a href="http://www.bitvisor.org/">bitvisor</a> , so you need to download the source of this hypervisor.  From these sources, copy the file c <b>ore \ string.s</b> in common.  In it we replace the line: <br><pre> <code class="cpp hljs">.include <span class="hljs-string"><span class="hljs-string">"longmode.h"</span></span></code> </pre><br>  per line: <br>  l <pre> <code class="cpp hljs">ongmode = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  7. Next, you need to copy the file <b>include \ core \ string.h</b> into include from bitvisor.  In it, replace the line: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;core/types.h&gt;</span></span></span></span></code> </pre><br>  per line: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span></span></code> </pre><br>  8. The last thing you need is the functions of working with I / O ports.  To do this, add the <b>io.h</b> file to the include directory, which can be taken without any changes from the same bitvisor project (in the project sources, it is located in include \ io.h). <br>  9. In order for everything to be copied, we replace the contents of <b>include \ types.h</b> with the following: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _TYPES_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TYPES_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NULL 0 typedef unsigned int size_t; typedef unsigned long ulong; typedef unsigned long u32; typedef unsigned short u16; typedef unsigned char u8; typedef unsigned long long uint64_t; typedef unsigned long long u_int64_t; typedef unsigned long uint32_t; typedef unsigned long u_int32_t; typedef unsigned short uint16_t; typedef unsigned short u_int16_t; typedef unsigned char uint8_t; typedef unsigned char u_int8_t; typedef long __int32_t; typedef unsigned long __uint32_t; typedef unsigned long long u_quad_t; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* quads */</span></span></span><span class="hljs-meta"> typedef long long quad_t; typedef quad_t * qaddr_t; typedef unsigned long u_int; typedef unsigned long uint; typedef long long int64_t; typedef long int32_t; typedef short int16_t; typedef char int8_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _QUAD_HIGHWORD 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _QUAD_LOWWORD 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __BEGIN_DECLS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __END_DECLS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __dead #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __far #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __HI(x) *(1+(int*)&amp;x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __LO(x) *(int*)&amp;x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __P(a) a #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHAR_BIT 8 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* max # of bits in a "char" */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXTRACT_WORDS(i0, i1, x) \ i0 = __HI(x); \ i1 = __LO(x); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INSERT_WORDS(x, i0, i1) \ __HI(x) = i0; \ __LO(x) = i1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BEGIN_STD_C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _END_STD_C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _EXFUN(a,b) ab #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  These changes are necessary to determine the number of types and macros that are needed in the used third-party source code.  As the code shows, all definitions are trivial. <br><br><h5>  Step 2. Porting x86emu </h5><br><br>  X86emu is part of FreeBSD, so you need to take a little bit of it from there.  To do this, create the x86emu directory in the root and from <a href="http://svnweb.freebsd.org/base/vendor-sys/x86emu/dist">http://svnweb.freebsd.org/base/vendor-sys/x86emu/dist</a> / copy the following files into this folder: <b>x86emu.c, x86emu.h, x86emu_regs.h, x86emu_util. c</b> . <br><br>  Now, you need to make a few changes to these sources: <br>  1. In the x86emu \ x86emu.c file, replace the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;dev/x86emu/x86emu.h&gt; #include &lt;dev/x86emu/x86emu_regs.h&gt;</span></span></span></span></code> </pre><br>  On the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86emu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86emu_regs.h"</span></span></span></span></code> </pre><br>  2. In the <b>x86emu \ x86emu.h file,</b> replace the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/types.h&gt; #include &lt;sys/endian.h&gt; #ifdef _KERNEL #include &lt;sys/systm.h&gt; #else #include &lt;setjmp.h&gt; #endif</span></span></span></span></code> </pre><br>  On the lines <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"setjmp.h"</span></span></span></span></code> </pre><br><br>  3. In the <b>x86emu \ x86emu_util.c file,</b> replace the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/param.h&gt; #include &lt;sys/endian.h&gt; #include &lt;dev/x86emu/x86emu.h&gt; #include &lt;dev/x86emu/x86emu_regs.h&gt;</span></span></span></span></code> </pre><br>  On the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86emu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86emu_regs.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Io.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> htole16(x) ((uint16_t)(x)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> htole32(x) ((uint32_t)(x)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> letoh16(x) ((uint16_t)(x)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> letoh32(x) ((uint32_t)(x))</span></span></code> </pre><br><br>  4. Next, you need to add several functions to the <b>x86emu \ x86emu_util.c</b> file before the x86emu_init_default function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_inb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; in8(port, &amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_outb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ out8(port, data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint16_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_inw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; in16(port, &amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_outw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ out16(port, data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_inl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; in32(port, &amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x86emu_outl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct x86emu *emu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ out32(port, data); }</code> </pre><br>  These functions are wrappers for access functions to I / O ports. <br><br>  5. In the x86emu_init_default function itself, add the following definitions: <br><pre> <code class="cpp hljs">emu-&gt;emu_inb = x86emu_inb; emu-&gt;emu_inw = x86emu_inw; emu-&gt;emu_inl = x86emu_inl; emu-&gt;emu_outb = x86emu_outb; emu-&gt;emu_outw = x86emu_outw; emu-&gt;emu_outl = x86emu_outl;</code> </pre><br>  Since the video card is a device and VBE will work with it through the I / O ports using previously defined functions, the emulator should be informed about their presence. <br><br><h5>  Step 3. Adding functions to work with the BIOS. </h5><br><br>  You can now use the VBE BIOS features via x86emu.  It remains to do a few functions that directly perform a request to the BIOS.  To do this, create a file <b>bios.c</b> in the common folder with the following content: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bios.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86emu.h"</span></span></span><span class="hljs-meta"> struct x86emu emulator; void VBE_BiosInit(void) { memset(&amp;emulator, 0, sizeof(emulator)); x86emu_init_default(&amp;emulator); emulator.mem_base = (char *)0; emulator.mem_size = BIOS_SIZE; } void VBE_BiosInterrupt( BIOS_REGS *p_regs, u8 num ) { memcpy(&amp;(emulator.x86), p_regs, sizeof(BIOS_REGS)); x86emu_exec_intr(&amp;emulator, num); memcpy(p_regs, &amp;(emulator.x86), sizeof(BIOS_REGS)); }</span></span></code> </pre><br><br>  And in the include folder file <b>bios.h</b> with the following content: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _BIOS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BIOS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIOS_SIZE 0x100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIOS_HIGH_BASE 0xC0000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIOS_HIGH_SIZE (0x100000 - 0xC0000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIOS_BDA_BASE 0x9fc00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIOS_BDA_SIZE 0x400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VBE_BIOS_INFO_OFFSET 0x70000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VBE_BIOS_MODE_INFO_OFFSET 0x80000 typedef struct _BIOS_REGS { u16 CS; u16 DS; u16 ES; u16 FS; u16 GS; u16 SS; u32 EFLAGS; u32 EAX; u32 EBX; u32 ECX; u32 EDX; u32 ESP; u32 EBP; u32 ESI; u32 EDI; u32 EIP; } BIOS_REGS; void VBE_BiosInit(void); void VBE_BiosInterrupt( BIOS_REGS *p_regs, u8 num ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  Thus, we have defined a function for initializing work with bios (VBE_BiosInit), which must be called at the beginning of work and the function call function bios (VBE_BiosInterrupt).  The name of the latter follows from the fact that it is through the int (interrupt) instruction that the BIOS functions are called in Real-Mode.  Using this function, you can call VBE functions according to the standard.  To call an interrupt, you need to fill in the structure with the processor state and call the emulator.  The emulator will begin to decode and emulate code from the IVT table and the BIOS code itself.  Instructions for instructions emulator will execute all the necessary code handler int 10h.  During operation, the emulator will call the functions of working with I / O ports, which we indicated earlier, in step 2. <br><br><h5>  Step 4. Adding functions to work with VBE. </h5><br><br>  Now everything is ready to write several functions for working with VBE.  First we add the file vbe.h, which will contain the definitions of the necessary structures.  It can be taken from the VirtualBox code (http://www.virtualbox.org/svn/vbox/trunk/src/VBox/Devices/Graphics/BIOS/vbe.h).  Replace the lines in it: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vgabios.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;VBox/Hardware/VBoxVideoVBE.h&gt;</span></span></span></span></code> </pre><br>  On the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span></span></code> </pre><br><br>  Now create a file <b>vbe.c</b> in the common folder with the following content: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"string.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bios.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vbe.h"</span></span></span><span class="hljs-meta"> ulong vbe_lfb_addr = 0; ulong vbe_selected_mode = 0; ulong vbe_bytes = 0; VbeInfoBlock *VBE_GetGeneralInfo() { BIOS_REGS regs; memset(¬Æs, 0, sizeof(BIOS_REGS)); regs.ECX = 0; regs.EAX = 0x4f00; regs.ES = VBE_BIOS_INFO_OFFSET &gt;&gt; 4; regs.EDI = 0x0; VBE_BiosInterrupt(¬Æs, 0x10); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (regs.EAX != 0x4f) return NULL; return (VbeInfoBlock *)(VBE_BIOS_INFO_OFFSET); } ModeInfoBlock *VBE_GetModeInfo( ulong mode ) { BIOS_REGS regs; memset(¬Æs, 0, sizeof(BIOS_REGS)); regs.ECX = mode; regs.EAX = 0x4f01; regs.ES = VBE_BIOS_MODE_INFO_OFFSET &gt;&gt; 4; regs.EDI = 0x0; VBE_BiosInterrupt(¬Æs, 0x10); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (regs.EAX != 0x4f) return NULL; return (ModeInfoBlock *)(VBE_BIOS_MODE_INFO_OFFSET); } int VBE_SetMode( ulong mode ) { BIOS_REGS regs; memset(¬Æs, 0, sizeof(BIOS_REGS)); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mode &gt;= 0x100) { regs.EBX = mode; regs.EAX = 0x4f02; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { regs.EAX = mode; } VBE_BiosInterrupt(¬Æs, 0x10); return (regs.EAX == 0x4f); } int VBE_Setup(int w, int h) { uint32_t m = 0; printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\nVBE: test started"</span></span></span><span class="hljs-meta">); VBE_BiosInit(); memset((char *)VBE_BIOS_INFO_OFFSET, 0, sizeof(VbeInfoBlock)); memset((char *)VBE_BIOS_MODE_INFO_OFFSET, 0, sizeof(ModeInfoBlock)); VbeInfoBlock *p_info = VBE_GetGeneralInfo(); int vbe_support = (p_info != NULL); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vbe_support == 0) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\nVBE: not supported"</span></span></span><span class="hljs-meta">); return 0; } vbe_support = (p_info-&gt;VbeVersion &gt;= 0x200); vbe_support = vbe_support &amp;&amp; (p_info-&gt;VbeSignature.SigChr[0] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'V'</span></span></span><span class="hljs-meta">); vbe_support = vbe_support &amp;&amp; (p_info-&gt;VbeSignature.SigChr[1] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'E'</span></span></span><span class="hljs-meta">); vbe_support = vbe_support &amp;&amp; (p_info-&gt;VbeSignature.SigChr[2] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'S'</span></span></span><span class="hljs-meta">); vbe_support = vbe_support &amp;&amp; (p_info-&gt;VbeSignature.SigChr[3] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'A'</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vbe_support == 0) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\nVBE: not supported"</span></span></span><span class="hljs-meta">); return 0; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Try to find mode int found = 0; for (m = 0x0; m &lt; 0x200; m++) { ModeInfoBlock *p_m_info = VBE_GetModeInfo(m); if (p_m_info != NULL) { printf("\nVBE: %x %dx%dx%d at %x", m, p_m_info-&gt;XResolution, p_m_info-&gt;YResolution, p_m_info-&gt;BitsPerPixel, p_m_info-&gt;PhysBasePtr); if (p_m_info-&gt;PhysBasePtr != 0 &amp;&amp; p_m_info-&gt;XResolution == w &amp;&amp; p_m_info-&gt;YResolution == h &amp;&amp; (p_m_info-&gt;BitsPerPixel == 24 || p_m_info-&gt;BitsPerPixel == 32)) { found = 1; vbe_selected_mode = m; vbe_lfb_addr = p_m_info-&gt;PhysBasePtr; vbe_bytes = p_m_info-&gt;BitsPerPixel / 8; printf("\nVBE: FOUND GOOD %dx%dx%d -&gt; %x at %x", w, h, vbe_bytes, vbe_selected_mode, vbe_lfb_addr); } } } return found; }</span></span></span></span></code> </pre><br><br>  Let us consider in more detail the functions declared in this file: <br>  ‚Ä¢ <b>VBE_GetGeneralInfo</b> .  This function checks the presence of a VBE video card.  It uses the BIOS function and checks the return values ‚Äã‚Äãaccording to the specification. <br>  ‚Ä¢ <b>VBE_GetModeInfo</b> .  This function asks the video card for information about the mode by number.  Returns information about this mode as a structure.  Parameters passed to VBE_BiosInterrupt are determined by the VBE specification. <br>  ‚Ä¢ <b>VBE_SetMode</b> .  This feature simply turns on the desired mode by number.  Parameters passed to VBE_BiosInterrupt are determined by the VBE specification. <br>  ‚Ä¢ <b>VBE_Setup</b> .  The most important function: it goes through all the modes and searches for the one that satisfies the screen resolution specified in the parameters.  Also, the function searches only the 24-bit and 32-bit mode and with LFB support.  As a result of the search, it fills three global variables: <br>  o <b>vbe_lfb_addr</b> is the LFB address.  You can slice it to write data for drawing on the screen. <br>  o <b>vbe_selected_mode</b> - the number of the selected mode so that it can be enabled. <br>  o <b>vbe_bytes</b> - the number of bytes per pixel (3 or 4). <br><br>  Everything is ready for drawing. <br><br><h5>  Step 5. Adding the fractal drawing function. </h5><br>  Getting to the most interesting: draw a fractal.  We will draw a fractal on the <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D0%2596%25D1%258E%25D0%25BB%25D0%25B8%25D0%25B0">Julia set</a> .  The basis for drawing the fractal was the code from <a href="http://lodev.org/cgtutor/juliamandelbrot.html">this wonderful article</a> .  To draw a fractal, you can simply create a file <b>fractal.c</b> in the root directory with the source code, with the following contents: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"string.h"</span></span></span><span class="hljs-meta"> int VBE_SetMode( ulong mode ); int VBE_Setup(int w, int h); double floor(double x); extern ulong vbe_lfb_addr; extern ulong vbe_selected_mode; extern ulong vbe_bytes; int HSVtoRGB(int _h, int _s, int _v) { double h = (double)_h / 255.0, s = (double)_s / 255.0, v = (double)_v / 255.0; double r = 0; double g = 0; double b = 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (s == 0) { r = v; g = v; b = v; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { double varH = h * 6; double varI = floor(varH); double var1 = v * (1 - s); double var2 = v * (1 - (s * (varH - varI))); double var3 = v * (1 - (s * (1 - (varH - varI)))); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (varI == 0) { r = v; g = var3; b = var1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (varI == 1) { r = var2; g = v; b = var1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (varI == 2) { r = var1; g = v; b = var3; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (varI == 3) { r = var1; g = var2; b = v; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (varI == 4) { r = var3; g = var1; b = v; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { r = v; g = var1; b = var2; } } return ((int)(r * 255) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 16) | ((int)(g * 255) &lt;&lt; 8) | (int)(b * 255); } void DrawFractal(void) { int x = 0, y = 0, w= 800, h = 600; if (!VBE_Setup(w, h)) return; if (!VBE_SetMode(vbe_selected_mode | 0x4000)) return; double cRe, cIm; double newRe, newIm, oldRe, oldIm; double zoom = 1, moveX = 0, moveY = 0; int color; int maxIterations = 300; cRe = -0.7; cIm = 0.27015; for(x = 0; x &lt; w; x++) for(y = 0; y &lt; h; y++) { newRe = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX; newIm = (y - h / 2) / (0.5 * zoom * h) + moveY; int i; for(i = 0; i &lt; maxIterations; i++) { oldRe = newRe; oldIm = newIm; newRe = oldRe * oldRe - oldIm * oldIm + cRe; newIm = 2 * oldRe * oldIm + cIm; if((newRe * newRe + newIm * newIm) &gt; 4) break; } color = HSVtoRGB(i % 256, 255, 255 * (i &lt; maxIterations)); // Draw pixel *(int *)((char *)vbe_lfb_addr + y * w * vbe_bytes + x * vbe_bytes + 0) = color &amp; 0xFFFFFF; } }</span></span></span></span></code> </pre><br>  Let's sort this code in a bit more detail.  First, this code contains the necessary definitions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VBE_SetMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ulong mode )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VBE_Setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_lfb_addr; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_selected_mode; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_bytes;</code> </pre><br><br>  Second, the <b>HSVtoRGB</b> color conversion function is <b>defined</b> .  She needs to make everything look beautiful.  Its implementation was taken <a href="http://lotsacode.wordpress.com/2010/03/11/hsvtorgb-and-rgbtohsv-in-c/">from here.</a> <br><br>  Finally, the most important function of drawing fractal is <b>DrawFractal</b> .  There are several points to note: <br><br>  1. First, it defines the screen parameters that will be used for the mode and drawing: <br>  int x = 0, y = 0, w = 800, h = 600; <br>  You can change these functions to your taste. <br><br>  2. Then configure VBE: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!VBE_Setup(w, h)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br><br>  3. Then the found graphic mode turns on: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!VBE_SetMode(vbe_selected_mode | <span class="hljs-number"><span class="hljs-number">0x4000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br><br>  4. Next is drawn fractal.  To set a point on the screen, a simple recording of a number into memory is used, while calculating the correct offset: <br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)vbe_lfb_addr + y * w * vbe_bytes + x * vbe_bytes + <span class="hljs-number"><span class="hljs-number">0</span></span>) = color &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>;</code> </pre><br><br>  Now that everything is ready, we need to call this function from main, otherwise we will not see the results of our labors.  Make changes to <b>kernel.c</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screen.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> void DrawFractal(void); void main() { clear_screen(); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n&gt;&gt;&gt; Hello World!\n"</span></span></span><span class="hljs-meta">); DrawFractal(); }</span></span></code> </pre><br><h5>  Step 6. Refine makefile and run </h5><br><br>  It remains to modify only the makefile, so that everything compiles.  To do this, we make the following changes: <br>  1. Update OBJFILES: <br><br><pre> <code class="cpp hljs">OBJFILES = \ loader.o \ common/<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.o \ common/screen.o \ common/bios.o \ common/vbe.o \ common/qdivrem.o \ common/udivdi3.o \ common/umoddi3.o \ common/divdi3.o \ common/moddi3.o \ common/setjmp.o \ common/<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.o \ common/s_floor.o \ x86emu/x86emu.o \ x86emu/x86emu_util.o \ fractal.o \ kernel.o</code> </pre><br><br>  2. Add another include directory, for this we make a change to the line: <br><pre> <code class="cpp hljs">$(CC) -Ix86emu -Iinclude $(CFLAGS) -o $@ -c $&lt;</code> </pre><br>  3. Add a target to compile the assembler: <br><pre> <code class="cpp hljs">.so: as -o $@ $&lt;</code> </pre><br>  4. Now you can rebuild the project: <br><pre> <code class="bash hljs">make rebuild sudo make image</code> </pre><br><br>  5. Run the project to make sure everything works: <br><pre> <code class="bash hljs">sudo qemu-system-i386 -hda hdd.img</code> </pre><br>  If everything is done correctly, then we should see such beauty here: <br><img src="http://habrastorage.org/storage2/b20/29d/6c4/b2029d6c407bd1c2bc4ed3f52a152627.jpg"><br><br>  As in the previous parts of the article, using the dd command, you can copy the hdd.img image to a USB flash drive and test the operation of the program on a real computer. <br><br>  The result was a program that demonstrates the possibilities of using video cards without an operating system, while using the VBE extension with the usual screen resolutions.  To enable the graphics mode, you had to port a whole instruction emulator, but it was worth it, because otherwise you would have to port some video card driver, and that would take much longer.  Now, based on this program, you can draw anything on the screen, even create your own game or build a window system, but more on that another time. <br><br>  Links to the following articles of the cycle: <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/181626/">part 4. Parallel computing</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/211470/">part 5. Accessing the BIOS from the OS</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/203706/">part 6. Support for working with disks with the FAT file system</a></b> " </div><p>Source: <a href="https://habr.com/ru/post/176707/">https://habr.com/ru/post/176707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176691/index.html">Generate random people in PaperJS</a></li>
<li><a href="../176693/index.html">MiTM attack on ssh</a></li>
<li><a href="../176701/index.html">Space scenes in web design</a></li>
<li><a href="../176703/index.html">Oracle fixes 42 Java vulnerabilities</a></li>
<li><a href="../176705/index.html">Samsung invites you to the presentation of the GALAXY S4 in Moscow!</a></li>
<li><a href="../176711/index.html">How can companies lure IT professionals?</a></li>
<li><a href="../176713/index.html">YouTube introduced the function of "video recorder" to view the video, in honor of the 57th anniversary of the "video"</a></li>
<li><a href="../176715/index.html">Bash completion for Composer</a></li>
<li><a href="../176717/index.html">1C image processing using the .Net framework when uploading to a website</a></li>
<li><a href="../176719/index.html">Setting the environment for building and testing the application in a closed perimeter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>