<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our simplified OpenGL on Rust - part 2 (wire rendering)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, in the continuation of the previous article I am writing the 2nd part, where we will try to get to write a wire render. I remind you that the purp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our simplified OpenGL on Rust - part 2 (wire rendering)</h1><div class="post__text post__text-html js-mediator-article">  So, in the continuation of the previous <a href="http://habrahabr.ru/post/261629/">article</a> I am writing the 2nd part, where we will try to get to write a wire render.  I remind you that the purpose of this series of articles is to write a strongly simplified analogue of OpenGL on Rust.  The <a href="http://habrahabr.ru/post/248153/">‚Äú</a> <a href="https://habrahabr.ru/users/haqreu/" class="user_link">Haqreu</a> <a href="http://habrahabr.ru/post/248153/">Computer Graphics Short Course‚Äù is</a> used as a basis, in my own articles I focus no more on graphics as such, but on implementation features using Rust: problems that arise and their solutions, personal impressions, useful resources for Rust learners.  The resulting program itself has no special value, the benefits of this case are in studying the new prospective PL and the fundamentals of three-dimensional graphics.  Finally, this lesson is quite exciting. <br><br>  I also remind you that since I am not a professional in Rust or in 3D graphics, but I study these things directly as I write this article, there may be blunders and omissions, which I, however, am happy to correct, if I‚Äôm into them will indicate in the comments. <br><br><img src="https://habrastorage.org/files/ee3/92e/45d/ee392e45d85e4b879e559864b2233841.png"><br>  <i>The machine that we get at the end of the article</i> <br><a name="habracut"></a><br><h2>  Put the line in order </h2><br>  Well, let's start by rewriting our dreadful handmade-line function to the normal implementation of the Bresenham algorithm from <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> article.  Firstly, it is faster, secondly more <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25B5%25D0%25B7%25D0%25B5%25D0%25BD%25D1%2585%25D1%258D%25D0%25BC%25D0%25B0">canonical</a> , thirdly we can compare the code on Rust with the <a href="">code in C ++</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">line</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x0: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y0: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> steep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x0-x1).abs() &lt; (y0-y1).abs() { mem::swap(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x0, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y0); mem::swap(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x1, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y1); steep = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x0&gt;x1 { mem::swap(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x0, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x1); mem::swap(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y0, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y1); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dx = x1-x0; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dy = y1-y0; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> derror2 = dy.abs()*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> error2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> y = y0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x0..x1+<span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> steep { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(y, x, color); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(x, y, color); } error2 += derror2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error2 &gt; dx { y += <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y1&gt;y0 { <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { -<span class="hljs-number"><span class="hljs-number">1</span></span> }; error2 -= dx*<span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br>  As you can see, the differences are minimal, and the number of lines relative to the original remains unchanged.  No special difficulties at this stage arose. <br><br><h2>  Do the test </h2><br>  After the line was finished, I decided not to delete the code that had served me so well in testing, which was drawing 3 of our test lines: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> canvas = canvas::Canvas::new(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); canvas.line(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, WHITE); canvas.line(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, RED); canvas.line(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, BLUE);</code> </pre><br>  I don‚Äôt know what experience the author of the original article has, but it turns out that these 3 challenges quite well cover almost the whole range of errors that can be made in the implementation of the line.  And which I, of course, allowed. <br><br>  Moving the code to an unused function will cause Rust to issue a warning at each compilation (the compiler curses each unused function or variable).  Of course, warning can also be suppressed by giving the function a name starting with the bottom dash <code>_test_line()</code> , but it somehow smells bad.  And store potentially useful but now unnecessary code in the comments in general, in my opinion, a bad tone of programming.  A much more reasonable solution is to create a test!  So, for information, refer to the relevant <a href="https://doc.rust-lang.org/book/testing.html">article</a> about testing functionality in Rust to make your first test in this language. <br><br>  This is done elementary.  It is enough to write <code>#[test]</code> line above the function signature.  This turns her into a test.  For such functions, Rust does not display warnings as unused, and the launch of the <code>cargo test</code> causes Cargo to show us statistics on the run of all such functions in the project: <br><br><pre> <code class="bash hljs"> Running target/debug/rust_project-2d87cd565073580b running 1 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_line ... ok <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured</code> </pre><br>  What is interesting, it also displays warning messages for all unused functions and variables, assuming that the input point of the project is functions marked as a test.  In the long term, this helps to determine the coverage of project functions with tests.  It is clear that while our test doesn‚Äôt really test anything, because the window with the results of drawing just appears and immediately disappears.  In an amicable way, there should be a mock-object replacing our Canvas, which allows you to check the sequence of <code>set(x, y, color);</code> function calls <code>set(x, y, color);</code>  for compliance with a given.  Then it will be an automatic unit test.  For now, we just played around with the appropriate compiler functionality.  Here is a <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/59436c6c5fb111319aed86d945093d9dbef12ca4">snapshot of the repository</a> after these changes. <br><br><h2>  Vectors and file reading </h2><br>  Well, it's time to start the implementation of wire rendering.  The first obstacle on this path is we need to read the model file (which is stored in the <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">‚ÄúWavefront .obj file‚Äù</a> format).  <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> in its article provides a ready-made parser for its students, which, when working, uses classes of 2-dimensional and 3-dimensional vectors, also represented by <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> .  Since its implementation is in C ++, we will need to rewrite all this to Rust.  We begin naturally with vectors.  Here is an excerpt of the original vector code (two-dimensional version): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span>tu, v;}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span>tx, y;}; t raw[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; Vec2() : u(<span class="hljs-number"><span class="hljs-number">0</span></span>), v(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} Vec2(t _u, t _v) : u(_u),v(_v) {} <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Vec2&lt;t&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec2&lt;t&gt; &amp;V) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec2&lt;t&gt;(u+Vu, v+Vv); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Vec2&lt;t&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec2&lt;t&gt; &amp;V) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec2&lt;t&gt;(uV.u, vV.v); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Vec2&lt;t&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec2&lt;t&gt;(u*f, v*f); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, Vec2&lt;t&gt;&amp; v); };</code> </pre><br>  In the implementation of vectors in C ++, templates are used.  In Rust, their analogue is generic types (Generics), about which you can read the relevant <a href="https://doc.rust-lang.org/book/generics.html">article</a> , as well as see <a href="http://rustbyexample.com/generics.html">examples of their use</a> on <a href="http://rustbyexample.com/">rustbyexample.com</a> .  In general, this site is a very useful resource in the study of Rust.  For each language opportunity there is an example of use with detailed comments and the ability to edit and run examples directly in the browser window (the code is executed on a remote server). <br><br>  When I tried to make a constructor that takes no arguments, but creates a zero vector (0, 0), I ran into another problem.  As I understand it, the rasta type system cannot be created this way, because we will not be able to initialize the structure with default values ‚Äã‚Äãdue to the lack of implicit type conversion.  Such functionality can be implemented through <a href="https://doc.rust-lang.org/book/generics.html">types (Traits)</a> , but for this you have to write a lot of code or use the standard type <a href="https://doc.rust-lang.org/std/num/trait.Zero.html"><code>std::num::Zero</code></a> , which is unstable.  I did not like both options, so I decided that it was easier to write <code>new(0, 0)</code> in the code. <br><br>  Disassembly with generalized types, types and operator overload took several hours.  When I realized that to implement an analogue of the <a href="">original classes of vectors,</a> I would need to understand more about how to do operator overloading (which itself is constructed using types) for a generalized type, I decided to go from the other side.  It seems that in C ++ it is done with a few lines of code and, in Rust, it is sometimes implemented in times more complicated and long code.  Perhaps this is due to the fact that I am trying to literally translate C ++ code into Rust, instead of comprehending the algorithm and writing its counterpart in a language with a substantially different ideology.  In general, I stopped at making my vector with only those capabilities that, as far as I can tell, I will need to store information from the model file according to my own judgments about it.  The result is such a simple class, which is quite enough at the current stage of the task: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3D</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> z: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Vector3D { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, z: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) -&gt; Vector3D { Vector3D { x: x, y: y, z: z, } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"({},{},{})"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z) } }</code> </pre><br>  Now you can take up the parser, but we have not yet studied working with files in Rust.  Here StackOverflow came to the rescue, where there was an answer with a simple to understand <a href="http://stackoverflow.com/questions/29888088/cannot-compile-code-that-uses-stdio-there-is-no-file-in-stdio/29893524">code example</a> .  Based on it, the following code was obtained: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vertices: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Vector3D&gt;, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> faces : <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>]&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(file_path: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; Model { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = Path::new(file_path); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file = BufReader::new(File::open(&amp;path).unwrap()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vertices = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> faces = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file.lines() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = line.unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.starts_with(<span class="hljs-string"><span class="hljs-string">"v "</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = line.split_whitespace().collect(); vertices.push(Vector3D::new(words[<span class="hljs-number"><span class="hljs-number">1</span></span>].parse().unwrap(), words[<span class="hljs-number"><span class="hljs-number">2</span></span>].parse().unwrap(), words[<span class="hljs-number"><span class="hljs-number">3</span></span>].parse().unwrap())); debug!(<span class="hljs-string"><span class="hljs-string">"readed vertex: {}"</span></span>, vertices.last().unwrap()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.starts_with(<span class="hljs-string"><span class="hljs-string">"f "</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> face: [<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] = [-<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = line.split_whitespace().collect(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> { face[i] = words[i+<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-string"><span class="hljs-string">"/"</span></span>).next().unwrap().parse().unwrap(); face[i] -= <span class="hljs-number"><span class="hljs-number">1</span></span>; debug!(<span class="hljs-string"><span class="hljs-string">"face[{}] = {}"</span></span>, i, face[i]); } faces.push(face); } } Model { vertices: vertices, faces: faces, } } }</code> </pre><br>  There were no particular difficulties with him.  Just reading the file and processing the lines.  Is that only the search for information, how to do this or that thing in the plant is complicated by the fact that the <s>language is rapidly changing</s> on the Internet a lot of information for older versions of Rust &lt;1.0.  (thanks to <a href="https://habrahabr.ru/users/stepik777/" class="user_link">stepik777</a> for <a href="https://habrahabr.ru/users/stepik777/" class="user_link">correcting</a> <a href="http://habrahabr.ru/post/261739/">constructively</a> ) Sometimes you find some answers, try them, but they don‚Äôt work, because this method is renamed, deleted, etc. I <code>from_str()</code> this using the example of <code>from_str()</code> . <br><br>  At first I made a mistake in this code, having forgotten to write the line <code>faces.push(face);</code>  and for a long time could not understand why my render does not even enter a cycle running through all the faces.  Only after I figured out what the problem was, I found an interesting line in the compiler's output. <code>warning: variable does not need to be mutable, #[warn(unused_mut)] on by default</code> regarding the line of declaring the variable face.  I didn‚Äôt notice this warning because I had a bunch of warnings about unused variables, so I scored to view them.  After that, I commented out all the unused variables, so now any warning will be striking.  In Rust, compiler warnings are very useful in finding errors and should not be neglected. <br><br>  It is also worth noting that the code looks quite simple and understandable, unlike the original in C ++.  Approximately it could also be written in some Python or Java.  It is also interesting how it is productive in comparison with the original.  I plan to make measurements of performance, when the whole render from start to finish will be ready. <br><br><h2>  Wire Render </h2><br>  Finally, here it is wire rendering.  Most of the work was done in the previous stages, so the code is simple: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { env_logger::init().unwrap(); info!(<span class="hljs-string"><span class="hljs-string">"starting up"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model = Model::new(<span class="hljs-string"><span class="hljs-string">"african_head.obj"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> canvas = canvas::Canvas::new(WIDTH, HEIGHT); debug!(<span class="hljs-string"><span class="hljs-string">"drawing wireframe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> face <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> model.faces { debug!(<span class="hljs-string"><span class="hljs-string">"processing face:"</span></span>); debug!(<span class="hljs-string"><span class="hljs-string">"({}, {}, {})"</span></span>, face[<span class="hljs-number"><span class="hljs-number">0</span></span>], face[<span class="hljs-number"><span class="hljs-number">1</span></span>], face[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v0 = &amp;model.vertices[face[j] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v1 = &amp;model.vertices[face[(j+<span class="hljs-number"><span class="hljs-number">1</span></span>)%<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x0 = ((v0.x+<span class="hljs-number"><span class="hljs-number">1</span></span>.)*WIDTH <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>.) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y0 = ((v0.y+<span class="hljs-number"><span class="hljs-number">1</span></span>.)*HEIGHT <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>.) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x1 = ((v1.x+<span class="hljs-number"><span class="hljs-number">1</span></span>.)*WIDTH <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>.) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y1 = ((v1.y+<span class="hljs-number"><span class="hljs-number">1</span></span>.)*HEIGHT <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>.) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; debug!(<span class="hljs-string"><span class="hljs-string">"drawing line ({}, {}) - ({}, {})"</span></span>, x0, y0, x1, y1); canvas.line(x0, y0, x1, y1, WHITE); } } info!(<span class="hljs-string"><span class="hljs-string">"waiting for ESC"</span></span>); canvas.wait_for_esc(); }</code> </pre><br>  Apart from minor differences in syntax, it differs from C ++ mainly by a large number of type conversions.  Well, logging, which I poked everywhere, when I was looking for errors.  Here, what picture we get as a result ( <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/558be7bbbca6dd37cbc08b7fad078cc5d23996ff">snapshot code in the repository</a> ): <br><br><img src="https://habrastorage.org/files/b5e/721/693/b5e7216930db402da9cd3d0570fb7f46.png"><br><br>  This is pretty good, but firstly, if I feed my model in its current form, the model of the machine that I plan to draw, it simply will not show it.  Secondly, all these beauties are drawn terribly long (I started the program and you can go and drink coffee).  The first problem is due to the fact that in the model of the machine the vertices are recorded on a completely different scale.  The code above is adjusted to the scale of the head model.  To make it universal, you still need to work with it.  I don‚Äôt know the second problem because of what, but if you think about it, the option is only 2: either an inefficient algorithm is used, or an inefficient implementation of this algorithm is written on this particular technology stack.  In any case, there will be another question, which particular piece of the algorithm (implementation) is inefficient. <br><br>  In general, as you already understood, I decided to start with the question of speed. <br><br><h2>  Measuring performance </h2><br>  Since I still had plans to compare the performance of the <a href="https://github.com/ssloy/tinyrenderer/tree/f6fecb7ad493264ecd15e230411bfb1cca539a12">original project</a> and my implementation at Rust, I decided to just do it early.  However, the principle of the original and my implementation are significantly different.  The original draws in the temporary buffer and only at the end writes the TGA file, while my application executes the commands to draw the SDL directly during the processing of the triangles. <br><br>  The solution is simple - to remake our Canvas, so that the method of drawing the <code>set(x, y, color)</code> point only saves the data to the internal array, and the SDL directly draws at the end of the program, after all the calculations have been done.  We kill 3 birds with this: <br><ol><li>  We get the opportunity to compare the speed of implementations to render / save to a file, i.e. where they essentially do identical things. </li><li>  We get blanks for the future for <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D1%2583%25D1%2584%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">double buffering</a> . </li><li>  We separate our calculations from drawing, which allows us to estimate the overhead imposed by SDL calls. </li></ol><br>  Quickly rewriting Canvas, I saw that the calculation of the lines itself was very fast.  But drawing with SDL was done with snail speed.  There is room for optimization.  It turned out that the point drawing function in Rust-SDL2 was by no means as fast as I expected.  The problem was solved by saving the entire image to a texture and then outputting this texture with this code: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> texture = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderer.create_texture_streaming(PixelFormatEnum::RGB24, (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.xsize <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ysize <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>)).unwrap(); texture.with_lock(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |buffer: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>], pitch: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>| { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ysize) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.xsize) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset = y*pitch + x*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.canvas[x][<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ysize - y - <span class="hljs-number"><span class="hljs-number">1</span></span>]; buffer[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] = (color &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; buffer[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] = (color &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; buffer[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; } } }).unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderer.clear(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderer.copy(&amp;texture, <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Rect::new_unwrap(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.xsize <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ysize <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderer.present(); }</code> </pre><br>  In general, rewriting Canvas did not create anything new from the point of view of programming in Rust, so there‚Äôs nothing to talk about.  The code at this stage is in the corresponding <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/1c26ef3c9af508a2eb102a0fe6ea2f30eaa350eb">snapshot of the repository</a> .  After these changes, the program began to fly.  Drawing took a split second.  There is already an interest in how to measure performance disappeared.  Since the execution of the program took very little time, a simple measurement error due to random processes in the OS could increase this time by 2 times or, on the contrary, reduce it.  In order to somehow fight this, I concluded the main body of the program (reading an .obj-file and calculating a two-dimensional projection) in a cycle that was performed 100 times.  Now it was possible to measure something.  He did the same with the <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> C ++ implementation. <br><br>  Actually, here are the Rust-implementation numbers: <br><br><pre> <code class="bash hljs">cepreu@cepreu-P5K:~//rust-3d-renderer-70de52d8e8c82854c460a41d1b8d8decb0c2e5c1$ time ./rust_project real 0m0.769s user 0m0.630s sys 0m0.137s</code> </pre><br>  Here are the implementation numbers in C ++: <br><pre> <code class="bash hljs">cepreu@cepreu-P5K:~//tinyrenderer-f6fecb7ad493264ecd15e230411bfb1cca539a12$ time ./a.out real 0m1.492s user 0m1.483s sys 0m0.008s</code> </pre><br>  I ran each of the programs 10 times, and then chose the best time (real).  I brought him to you.  I made modifications to my implementation in order to cut out all references to the SDL so that external references did not affect the resulting time.  Actually you can see in the <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/5be011c3e678b617dad9f3bbce2d7a0d3eb3eff9">snapshot of the repository</a> . <br><br>  Here are the modifications I made in C ++ implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle=<span class="hljs-number"><span class="hljs-number">0</span></span>; cycle&lt;<span class="hljs-number"><span class="hljs-number">100</span></span>; cycle++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>==argc) { model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Model(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Model(<span class="hljs-string"><span class="hljs-string">"obj/african_head.obj"</span></span>); } <span class="hljs-function"><span class="hljs-function">TGAImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(width, height, TGAImage::RGB)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model-&gt;nfaces(); i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; face = model-&gt;face(i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { Vec3f v0 = model-&gt;vert(face[j]); Vec3f v1 = model-&gt;vert(face[(j+<span class="hljs-number"><span class="hljs-number">1</span></span>)%<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x0 = (v0.x+<span class="hljs-number"><span class="hljs-number">1.</span></span>)*width/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y0 = (v0.y+<span class="hljs-number"><span class="hljs-number">1.</span></span>)*height/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1 = (v1.x+<span class="hljs-number"><span class="hljs-number">1.</span></span>)*width/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y1 = (v1.y+<span class="hljs-number"><span class="hljs-number">1.</span></span>)*height/<span class="hljs-number"><span class="hljs-number">2.</span></span>; line(x0, y0, x1, y1, image, white); } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> model; } <span class="hljs-comment"><span class="hljs-comment">//image.flip_vertically(); // i want to have the origin at the left bottom corner of the image //image.write_tga_file("output.tga"); return 0; }</span></span></code> </pre><br>  Well, also deleted the debug print in model.cpp.  In general, of course, the result surprised me.  It seemed to me that the Rust compiler still should not be as well optimized as gcc, and I unknowingly probably built up a suboptimal code ... I somehow don‚Äôt even understand why my code was faster.  Or is it Rust so super fast.  Or in C ++, the implementation is not optimal.  In general, those who wish to discuss this - welcome to the comments. <br><br><h2>  Results </h2><br>  Finally, by uncomplicated adjustment of the coefficients (see the <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/d35fe4476dd1ab47e49182e3c38437a01c5d08dd">repository snapshot</a> ), I got a picture of the machine that optimally occupies the space of the window.  You observed it at the beginning of the article. <br><br>  Some impressions: <br><ul><li>  Writing on Rust is becoming easier.  The first days were incessant struggle with the compiler.  Now I just sit down and write the code, from time to time looking on the Internet how to do this or that thing.  In general, for the most part the language is already perceived familiar.  As you can see, it didn't take long. </li><li>  Still delight warning'i rasta.  The fact that in other languages ‚Äã‚Äãonly a very advanced IDE (such as IntelliJ IDEA in Java) is prompted in Rust says the compiler itself.  Helps maintain good style, saves from mistakes. </li><li>  The fact that Rust was faster - shock.  Apparently the compiler is nowhere near as raw as I thought. </li></ul><br><br>  Final - 3rd part of the cycle: <a href="http://habrahabr.ru/post/262235/">We write our simplified OpenGL on Rust - part 3 (rasterizer)</a> </div><p>Source: <a href="https://habr.com/ru/post/261739/">https://habr.com/ru/post/261739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261729/index.html">HP Helion OpenStack Network Infrastructure</a></li>
<li><a href="../261731/index.html">Useful materials for iOS developers for the week</a></li>
<li><a href="../261733/index.html">Invisible File Mystery</a></li>
<li><a href="../261735/index.html">Visualization of geodata of the network of reference stations in St. Petersburg</a></li>
<li><a href="../261737/index.html">Design levels for games in a row</a></li>
<li><a href="../261741/index.html">MySQL performance optimization</a></li>
<li><a href="../261743/index.html">Secrets of lost commits in Git</a></li>
<li><a href="../261745/index.html">DSP to .Net under Windows. Jedi Power Post</a></li>
<li><a href="../261747/index.html">Edison for lifeguard, for pianist, for everyone. Results of Intel IoT Roadshow SPb, part 1 - winners</a></li>
<li><a href="../261749/index.html">Webinar Recording - New Kerio Connect Distribution - Multi-Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>