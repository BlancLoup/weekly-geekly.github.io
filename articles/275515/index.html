<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gradle: managing dependencies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dependency management is one of the most important functions in the arsenal of build systems. With the arrival of Gradle as the main build system for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gradle: managing dependencies</h1><div class="post__text post__text-html js-mediator-article">  Dependency management is one of the most important functions in the arsenal of build systems.  With the arrival of Gradle as the main build system for Android projects in terms of dependency management, a significant shift occurred, the era of manual copying of JAR files and long dances with a tambourine around the failed project configurations is over. <br><br> <a href="http://habrahabr.ru/company/redmadrobot/blog/275515/"><img src="https://habrastorage.org/files/6a6/515/92c/6a651592c2e843e28714951d14bb0f1e.png"></a> <br><br>  The article discusses the basics of dependency management in Gradle, provides in-depth practical examples, small life hacks and links to the right places in the documentation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  <b>Repository</b> </h4><br>  As you know, Gradle does not have its own repositories and uses Maven and Ivy repositories as a source of dependencies.  At the same time, the interface for working with repositories does not differ at the basic level; you can find out more about the differences in parameters using the <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html">IvyArtifactRepository</a> and <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html">MavenArtifactRepository links</a> .  It should be noted that the 'http', 'https' or 'file' protocols can be used as url.  The order in which the repositories are recorded affects the order in which dependencies are searched for in the repositories. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle repositories { maven { url "http://example.com" } ivy { url "http://example.com" } }</span></span></code> </pre> <br><br><h4>  <b>Addiction</b> </h4><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle apply plugin: 'java' repositories { mavenCentral() } dependencies { compile group: 'com.googlecode.jsontoken', name: 'jsontoken', version: '1.1' testCompile group: 'junit', name: 'junit', version: '4.+' }</span></span></code> </pre><br><br>  In the example above, you see a build script in which two dependencies are connected for different configurations (compile and testCompile) to compile the project.  JsonToken will connect during the compilation of the project and compilation of the project tests, jUnit only during the compilation of the project tests.  More details about the compilation configurations - by <a href="https://docs.gradle.org/current/userguide/java_plugin.html">reference</a> . <br><br>  You can also see that we connect jUnit dependencies as dynamic (+), i.e.  the latest available version 4. + will be used, and we will not need to keep track of minor updates (I recommend not to use this feature in the compile-type compilation of the application, as unexpected, possibly difficult to localize problems may appear). <br><br>  Using the jUnit-dependency example, consider the standard Gradle mechanism for finding the necessary dependency: <br><br><pre> <code class="tex hljs">1.  compile ("org.junit:junit:4.+") 2.    group: "org.junit" name: "junit" version: "4.+" 3.      [junit:4.1] ‚Ä¶ [junit:4.12] 4.     [junit:4.12] 5.    [junit:4.12] dependencies { ‚Ä¶ } artifacts { ‚Ä¶ } 6.      junit-4.12.jar junit-4.12-source.jar junit-4.12-javadoc.zip</code> </pre><br><br><h4>  <b>Cache</b> </h4><br>  Gradle implements a caching system that, by default, stores dependencies for 24 hours, but this behavior can be overridden. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle configurations.all { resolutionStrategy.cacheChangingModulesFor 4, 'hours' resolutionStrategy.cacheDynamicVersionsFor 10, 'minutes' }</span></span></code> </pre><br><br>  After the time set for storing data in the cache is out, the system, when running tasks, first checks the possibility of updating dynamic (dynamic) and changeable (changing) dependencies and, if necessary, updates them. <br><br>  Gradle tries not to upload those files that were previously uploaded, and uses a verification system for this, even if the URL / source of files is different.  Gradle always checks the cache (URL, version and module name, cache for other versions of Gradle, Maven cache), HTTP request headers (Date, Content-Length, ETag) and SHA1-hash, if available.  If no match is found, the system will download the file. <br><br>  Also in the assembly system there are two parameters, using which at startup you can change the caching policy for a specific task. <br><br>  - ‚Äìoffline - Gradle will never attempt to contact the network to check for dependency updates. <br>  - ‚Äìrefresh-dependencies ‚Äî Gradle will attempt to update all dependencies.  It is convenient to use if the data in the cache is corrupted.  Verifies the cached data and, if different, updates it. <br><br>  More details about dependency caching can be found in the <a href="https://docs.gradle.org/current/userguide/dependency_management.html">Gradle User Guide</a> . <br><br><h4>  <b>Types of dependencies</b> </h4><br>  There are several types of dependencies in Gradle.  The most commonly used are: <br><br>  - External dependencies of the project - dependencies downloaded from external repositories; <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle dependencies { compile "com.android.support:appcompat-v7:23.1.1" }</span></span></code> </pre><br><br>  - Project dependencies - dependence on the module (subproject) within one project; <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle dependencies { compile project(':subproject') }</span></span></code> </pre><br><br>  - File dependencies - dependencies connected as files (jar / aar archives). <br><pre> <code class="java hljs">build.gradle repositories { flatDir { dirs <span class="hljs-string"><span class="hljs-string">'aarlibs'</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,  aar-   } } dependencies { compile(name:'android_library', ext:'aar') //  aar- compile files('libs/a.jar', 'libs/b.jar') compile fileTree(dir: 'libs', include: '*.jar') }</span></span></code> </pre><br><br>  There are also client module dependencies, Gradle API dependencies, and local Groovy dependencies.  They are rarely used, so within the framework of this article we will not analyze them, but <a href="https://docs.gradle.org/current/userguide/dependency_management.html">you can</a> read the documentation about them <a href="https://docs.gradle.org/current/userguide/dependency_management.html">here</a> . <br><br><h4>  <b>Dependency tree</b> </h4><br>  Each external or project dependency can contain its own dependencies, which must be taken into account and downloaded.  Thus, when compiling, dependencies are loaded for the selected configuration and a dependency tree is built, the human representation of which can be seen by running the Gradle task 'dependencies' in Android Studio or using the command gradle% module_name%: dependencies in the console, being in the project root folder.  In response, you will receive a list of dependency trees for each of the available configurations. <br><br>  Using the configuration parameter, we specify the name of the configuration in order to see the dependency tree of only the specified configuration. <br><br>  Take the specially prepared source code of the repository located on <a href="https://github.com/smred/GradleDependencyManagement">github</a> and try to get the dependency tree for a specific configuration (at the moment the project is in the 0 state, ie, build.gradle.0 is used as build.gradle): <br><br><img src="https://habrastorage.org/files/cbd/2a0/133/cbd2a013397540a1839c832c864608bc.png"><br><br>  After analyzing the dependency tree, you can see that the app module uses two external dependencies (appcompat and guava) as dependencies, as well as two project dependencies (first and second), which in turn use jsontoken versions 1.0 and 1.1 as external dependencies.  Obviously, a project cannot contain two versions of the same library in Classpath, and no need for that.  At this point, Gradle turns on the conflict resolution module. <br><br><h4>  <b>Conflict resolution</b> </h4><br>  Gradle DSL contains a component used <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">to resolve</a> dependency <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">conflicts</a> .  If you look at the dependencies of the jsontoken library on the dependency tree above, we will see them only once.  For the second module, the dependencies of the jsontoken library are not specified, and the output of the dependency itself additionally contains '-&gt; 1.1', which means that version 1.0 of the library is not used, but was automatically replaced with version 1.1 using the Gradle-conflict resolution module. <br><br>  To explain how the conflict was resolved, you can also use Gradle-dependencyInsight, for example: <br><br><img src="https://habrastorage.org/files/083/723/ea2/083723ea25474713b78cd5c62f27e274.png"><br><br>  It is worth paying attention that version 1.1 is selected as a result of conflict resolution, it is also possible to choose as a result of other rules (for example: selected by force or selected by rule).  The article will provide examples of the use of rules that affect the strategy for resolving dependencies, and following the dependencyInsight task, you can see the reason for choosing a specific version of the library at each of the steps below.  To do this, during the transition to each stage, you can independently perform task dependencyInsight. <br><br>  If necessary, it is possible to redefine the logic of the Gradle-module of conflict resolution, for example, by specifying Gradle to fall when conflicts are detected during project configuration.  (state 1) <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle // ‚Ä¶ configurations.compile.resolutionStrategy { failOnVersionConflict() }</span></span></code> </pre><br><br>  After that, even when trying to build a dependency tree, Gradle Tasks will be interrupted due to the presence of a conflict in the application dependencies. <br><br><img src="https://habrastorage.org/files/954/ec4/90e/954ec490e6b34ea389846bef3fe8a330.png"><br><br>  The problem has four solutions: <br><br>  The first option is to remove lines that override the conflict resolution strategy. <br><br>  The second option is to add the rule of mandatory use of the jsonToken library to the conflict resolution strategy, indicating the specific version (state 2): <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle // ‚Ä¶ configurations.compile.resolutionStrategy { force 'com.googlecode.jsontoken:jsontoken:1.1' failOnVersionConflict() }</span></span></code> </pre><br><br>  When applying this solution, the dependency tree will look as follows: <br><br><img src="https://habrastorage.org/files/e67/0cc/6ac/e670cc6ac0944aa2beb365589b781664.png"><br><br>  The third option is to add the jsonToken library explicitly as a dependency for the app project and assign the dependencies to the force parameter, which explicitly indicates which of the library versions to use.  (state 3) <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle // ‚Ä¶ dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.google.guava:guava:+' compile project(":first") compile project(":second") compile ('com.googlecode.jsontoken:jsontoken:1.1') { force = true } }</span></span></code> </pre><br><br>  And the dependency tree will look like this: <br><br><img src="https://habrastorage.org/files/f86/6cb/46d/f866cb46d9174abaac3814af753d4609.png"><br><br>  The fourth option is to exclude from one of the project dependencies jsontoken from its own dependencies using the exclude parameter.  (state 4) <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.google.guava:guava:+' compile project(":first") compile(project(":second")) { exclude group: "com.googlecode.jsontoken", module: 'jsontoken' } }</span></span></code> </pre><br><br>  And the dependency tree will look like this: <br><br><img src="https://habrastorage.org/files/46b/573/190/46b5731908324708a8fea69efc0e7fa7.png"><br><br>  It is worth noting that exclude does not need to pass both parameters at the same time; only one can be used. <br><br>  But despite the correct derivation of the dependency tree, when trying to build the application Gradle will return an error: <br><br><img src="https://habrastorage.org/files/66c/162/cdf/66c162cdfb3242b6baa11ffcc35f03e8.png"><br><br>  The cause of the error can be understood from the output messages of the assembly task execution ‚Äî the GwtCompatible class with the identical package name is contained in several dependencies.  And this is true, the fact is that the app project uses the guava library as a dependency, and the jsontoken library uses outdated Google Collections in dependencies.  Google Collections is included in Guava, and their sharing in one project is impossible. <br><br>  To achieve a successful project build can be in three options: <br><br>  The first is to remove guava from the dependencies of the app module.  If you use only the part of Guava, which is contained in Google Collections, then the proposed solution will be quite good. <br><br>  The second is to exclude Google Collections from the first module.  To achieve this, we can use the previously described exception or configuration rules.  Consider both options, first using exceptions (state 5) <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.google.guava:guava:+' compile(project(":first")) { exclude module: 'google-collections' } compile(project(":second")) { exclude group: "com.googlecode.jsontoken", module: 'jsontoken' } }</span></span></code> </pre><br><br>  An example of using configuration rules (state 6): <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//build.gradle configurations.all { exclude group: 'com.google.collections', module: 'google-collections' } dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.google.guava:guava:+' compile project(":first") compile(project(":second")) { exclude group: "com.googlecode.jsontoken", module: 'jsontoken' } }</span></span></code> </pre><br><br>  The dependency tree for both implementations of the Google Collections exception will be identical. <br><br><img src="https://habrastorage.org/files/a58/57c/399/a5857c399b1549b3a584e84d1a0ba8f2.png"><br><br>  The third option is to use the module substitution functionality (state 7): <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle dependencies { modules { module('com.google.collections:google-collections') { replacedBy('com.google.guava:guava') } } compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.google.guava:guava:+' compile project(":first") compile(project(":second")) { exclude group: "com.googlecode.jsontoken", module: 'jsontoken' } }</span></span></code> </pre><br><br>  The dependency tree will look like this: <br><br><img src="https://habrastorage.org/files/293/c96/b1b/293c96b1bbf54646828938e1957bbefb.png"><br><br>  It should be noted that if you leave the predefined conflict resolution logic, which indicates to interrupt the assembly in the presence of any conflict, then the execution of any task will be interrupted at the configuration stage.  In other words, the use of module replacement rules is one of the rules of conflict resolution strategy between dependencies. <br><br>  It is also important to note that the last of the voiced options is the most flexible, because when you remove guava from the Gradle dependency list, Google Collections will remain in the project, and the functionality depending on it will be able to continue execution.  And the dependency tree will look like this: <br><br><img src="https://habrastorage.org/files/00a/7d4/b0f/00a7d4b0f1404922bb1cdc4252b4fe0b.png"><br><br>  After each of the options we will succeed in the form of an assembled and running application. <br><br>  But let's consider another situation (state 8), we have only one strongly shortened (to reduce the size of screenshots) dynamic wiremock dependency.  We use it purely for training purposes; instead, submit the library that your colleague supplies, it can release a new version at any time, and you will definitely need to use the latest version: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle configurations.all { exclude group: 'org.apache.httpcomponents', module: 'httpclient' exclude group: 'org.json', module: 'json' exclude group: 'org.eclipse.jetty' exclude group: 'com.fasterxml.jackson.core' exclude group: 'com.jayway.jsonpath' } dependencies { compile 'com.github.tomakehurst:wiremock:+' }</span></span></code> </pre><br><br>  The dependency tree looks like this: <br><br><img src="https://habrastorage.org/files/b6c/f3a/643/b6cf3a6430174881b1a5653757591477.png"><br><br>  As you can see, Gradle downloads the latest available version of wiremock, which is beta.  The situation is normal for debug builds, but if we are going to provide the build to users, then we definitely need to use the release version to be sure of the quality of the application.  But at the same time, due to the constant need to use the latest version and frequent releases, there is no way to refuse to specify the wiremock version dynamically.  The solution to this problem is to write your own rules for the strategy of choosing dependency versions: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle //‚Ä¶ configurations.all { //‚Ä¶ resolutionStrategy { componentSelection { all { selection -&gt; if (selection.candidate.version.contains('alpha') || selection.candidate.version.contains('beta')) { selection.reject("rejecting non-final") } } } } }</span></span></code> </pre><br><br>  It is worth repealing that this rule will apply to all dependencies, not just wiremock. <br>  After that, running the task of displaying the dependency tree in the information mode, we will see how the beta versions of the library are discarded, and the reason why they were discarded.  In the end, the stable version 1.58 will be chosen: <br><br><img src="https://habrastorage.org/files/867/1ff/02c/8671ff02c3064e67ad07862038bbb722.png"><br><br>  But during testing it was found that in version 1.58 there is a critical bug, and the assembly cannot be released in this state.  You can solve this problem by writing another rule for choosing the dependency version: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle //‚Ä¶ configurations.all { //‚Ä¶ resolutionStrategy { componentSelection { // ‚Ä¶ withModule('com.github.tomakehurst:wiremock') { selection -&gt; if (selection.candidate.version == "1.58") { selection.reject("known bad version") } } } } }</span></span></code> </pre><br><br>  After that, the version of wiremock 1.58 will also be dropped, and version 1.57 will start to be used, and the dependency tree will look like this: <br><br><img src="https://habrastorage.org/files/aa1/143/1b6/aa11431b61634d6eacb1e8edead735f4.png"><br><br><h4>  <b>Conclusion</b> </h4><br>  Despite the fact that the article turned out to be quite voluminous, the topic Dependency Management in Gradle contains a lot of information that was not voiced within this article.  It‚Äôs best to get deeper into this world using the official <a href="https://docs.gradle.org/current/userguide/dependency_management.html">User Guide</a> paired with the <a href="https://docs.gradle.org/current/dsl/index.html">Gradle DSL</a> documentation, which you will have to invest a lot of time to learn. <br><br>  But as a result, you will be able to save dozens of hours, both thanks to automation, and by understanding what needs to be done when various bugs appear.  For example, lately, bugs with 65K-methods and Multidex have become quite active, but thanks to competent viewing of dependencies and the use of exclude, problems are solved very quickly. <br><br>  See also: <a href="http://habrahabr.ru/company/redmadrobot/blog/271269/">Gradle: 5 Utility for the Developer</a> </div><p>Source: <a href="https://habr.com/ru/post/275515/">https://habr.com/ru/post/275515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275505/index.html">Have you thought about the safety of ... a car?</a></li>
<li><a href="../275507/index.html">Search for a variety of regular expressions using the Hyperscan library</a></li>
<li><a href="../275509/index.html">Used servers as a reasonable alternative</a></li>
<li><a href="../275511/index.html">Using Kanban to Prepare Scrum Backlog</a></li>
<li><a href="../275513/index.html">Docker: Environment for testing</a></li>
<li><a href="../275517/index.html">AnyConnect and Address Space Intersection</a></li>
<li><a href="../275519/index.html">Icons in the bookmarks bar and the weight of everything in the assembly Vivaldi 1.0.375.3</a></li>
<li><a href="../275521/index.html">Mocks, fakes and stubs in C ++</a></li>
<li><a href="../275525/index.html">Corporate Laboratories 2016 - practical training in the field of information security</a></li>
<li><a href="../275527/index.html">What should we build the Zhegalkin polynomial ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>