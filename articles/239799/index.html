<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The myth of the ideal number of lines in the method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a myth that if a function has more than n or less than m lines of code, then there is a design problem with the function. For example, the au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The myth of the ideal number of lines in the method</h1><div class="post__text post__text-html js-mediator-article">  There is a myth that if a function has more than n or less than m lines of code, then there is a design problem with the function.  For example, the author of the publication <a href="http://habrahabr.ru/post/239431/">‚ÄúReflections on Design Principles‚Äù</a> says that ‚Äúthe number of lines of a method ... is a necessary but not sufficient condition for a good design‚Äù.  In this article I will set out the reasons why I consider the need for a function to be a certain size a myth and give examples that prove it, but first let's consider the reasons for the popularity of this myth. <br><a name="habracut"></a><br><h5>  The reasons for the popularity of the myth </h5><br>  If you take almost any algorithm from real life, then it can easily be broken down into a small number of operations, usually from 3 to 10, and these operations serve their unique micro-goals.  For example, to sit at a chair standing near the table, you need to 1) see a chair;  2) go to the chair;  3) move the chair;  4) sit behind the chair.  Such a description of actions is quite understandable and, looking at each action, you can understand what lies behind it and what steps you need to perform to implement it.  This is an example of good design.  If instead of the ‚Äúsee the chair‚Äù step there would be several operations of straining the eye muscles, and instead of ‚Äúapproaching the chair‚Äù there was a cycle of gradual advancement with constant editing of the route, then such an algorithm would be difficult to understand;  even remembering all the details of the algorithm is already problematic.  This is an example of poor design without proper control of complexity.  In this case, it is better to single out the operations that serve the same purpose - to reduce the distance between the chair and the person, into one function. <br><br>  If you take other algorithms, for example, frying eggs or going to the movies - again, you can select up to 10 smaller operations that serve DIFFERENT micro targets.  Agree that it is right to come up with an example, when there are much more than 10 operations, it is rather difficult, isn't it?  If you still get quite a lot of operations, then you can certainly find a common goal for some, or you may be too fixated on error handling, which is actually not the BASIC part of the algorithm. <br><br><h5>  Myth refutation </h5><br>  To come up with an algorithm from life, in which at the top level of abstraction there are a large number of operations that cannot be combined into larger ones (as a result, your main function of the algorithm will swell across many lines of code) is rather difficult, but possible.  For example, the ritual dance of some Aboriginal tribe, which consists of the following actions: 1) sit down;  2) for a while;  3) growl;  4) wave your hands;  5) stand up;  6) jump ... and another 100 or 500 chaotic unsystematic actions. <div class="spoiler">  <b class="spoiler_title">What is the top level of abstraction</b> <div class="spoiler_text">  The first level of abstraction is the global purpose of the code, which, with a good design, coincides with the name of the main function of the algorithm, in this case, let it be "Call rain".  The first level of abstraction is degenerate and there is always one operation on it, therefore we exclude it from consideration and by the highest we mean the second.  At the highest (second) level of abstraction, there are such operations as ‚ÄúCrouch‚Äù and ‚ÄúPokudakhtat‚Äù.  At the same time, the ‚Äúsit down‚Äù goal is to change the position of the body, and the other has to ‚Äúmake the cackle‚Äù make sounds that mimic the sound of a chicken.  These goals are different, and if you look for a common goal between them, then in this context they have only one common goal - ‚ÄúTo cause rain‚Äù, therefore you cannot select them as a separate function that would be triggered inside ‚ÄúTo cause rain‚Äù.  "Crouch" and "crouch" should be in the "cause the rain" directly.  Therefore, they are at the highest level of abstraction. </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Still want your function to be less than n lines of code?  Then you have to break the method into 1) perform the first part of the ritual dance;  2) perform the second part - and so on, and this is an example of poor design, because it is not clear what this or that function hides behind it.  I will give an example of a similar situation, but from the field of programming.  Suppose there is a module that downloads pages from a certain site and distributes them in order to obtain information about the purchase, which has protocols, lots, and much more.  The main module method looks like this: <br><br>  1) Find out information about the supplier; <br>  2) Find out information about the purchase lots; <br>  3) Learn information about the auction of the procurement; <br>  4) Learn information about the procurement protocols; <br>  5) Find out information on the latest date of purchase status change. <br>  ... and similar methods.  In addition, each method downloads different pages and applies different parsing algorithms.  Each operation is worthy of being singled out in a separate method and in no way will it be possible to combine some of them into a separate function with a clear name (the option ‚ÄúCheck information on the supplier and lots and auction‚Äù is not offered).  The subject model and the number of pages on the source site can be increased to infinity (as well as the number of front-end site developers who are adding more and more specifics to different pages of the site).  Another example that refutes a myth is a family of cryptographic algorithms.  The greater the n-maximum number of permissible method size you wouldn‚Äôt name, the longer the cryptographic algorithm can be thought up. <br><br><h5>  The reverse side of the myth </h5><br>  There is another interpretation of this myth - if the method has less than m lines of code (for example, 50), then something is wrong with it.  How could such a point of view originate?  Imagine a code that does not have a coherent architecture, in which the names of classes and methods either do not reflect the purpose of the entities, or are completely misleading.  Perhaps the code was initially good, but then someone made changes to the ‚ÄúGet information about the latest date of purchase status change‚Äù function and now it also saves the information to the database and sends notifications to users by email, but the function name has not changed .  Or someone made changes to the search date search algorithm itself, but made them not in this function, but in some other place, then the function would have to be renamed ‚ÄúFind out information on the last date of change of the PART of purchase status‚Äù or ‚Äú Get information about the event log ‚Äù(now it is the PART of the search operation for the date of the change, and the method should be called accordingly), but, alas, the function was not renamed.  As a result, there is no trust in the names of the methods in this code, and to find out WHAT REALLY HAPPENS HERE, you need to fall into each of them.  And if the code is fragmented into a large number of methods and the depth of nesting is great, then you need to fall deeper and deeper ... As a result, the code is easy to get confused, like in a maze.  But if all the class code were in one giant function, then it would at least be visible, in full view, and obviously false names of functions would not be confusing. <br><br>  Now imagine a fictional programmer named Marcus.  Marcus is not very zealous in the study of design and every day works with the above described awkward code.  Gradually, Marcus begins to notice that ‚Äúbig code is easier to understand‚Äù, and ‚Äúfinely cracked‚Äù code begins to be associated with a headache.  Then someone briefly tells him about the principle ‚Äúdo not produce extra essences‚Äù.  What kind of essence is superfluous, and what is not, Marcus cannot explain, but takes the principle into service.  Then Marcus learns about the KISS principle from somewhere, and decides that once "the smaller the entities, the easier it is to understand", then "the smaller the entities, the more the code corresponds to KISS." <br><br>  Here is <a href="http://habrahabr.ru/post/153225/">an example of an article</a> whose character is also called Markus, and who wrote a class that can bake any sort of bakery product according to any recipe on any stove with any source of fuel, and this class has only one method.  As far as I understand, he has two classes in the whole program - bread (which may in fact be a pie) and Manager (which at a meeting can say ‚ÄúI can do everything!‚Äù And not lie).  Our Marcus (ours, who is from this article) agrees and believes that this is BEST PRACTICE and following the KISS principle, and if you don‚Äôt produce God objects with 1000 lines of code each, then you have something to learn from him. <br>  Personally, I think that there is no rule, that the method must be more than m lines, and that in 99.9% of cases it is very possible to write neat little functions, by the appearance of which one can say what is happening inside them, what is their contract and what purpose they serve.  At the same time, it will not take a lot of time to search for the necessary functionality and you will not have to look through the whole code. <br><br><h5>  And what do you need? </h5><br>  We already know how not to do - blindly trust the number of rows in a method.  A natural question arises - what is needed?  How do I know if I need to add something to a function, or remove something from it?  We can learn the principle of "Low coupling &amp; High cohesion" and two smell-a: "Shooting shot" and "Divergent modifications."  If, when changing some type of functional, you need to correct a piece of this entity and a piece of another entity, then it means that Shooting shot and Low cohesion started up in the code and it would be nice to merge these two entities into one.  If, on changing some type of functionality, we always change that part of the entity, and this part of the entity never changes, then the code smells of ‚ÄúDiverging modification‚Äù and it is possible to break the entity into two.  For clarification, we use a slightly modified example from the beginning of the article: if, when changing the mode of movement of a robot approaching a chair, you constantly change part of the algorithm regarding route selection and movement (depending on whether the robot moves on the ground, underground or land), then you need to allocate a separate function "approach the table."  As a result, where there was one entity, two appear.  It is also necessary to give understandable names of entities, so that by name alone it can be understood what this entity is doing (and what it does not do). <br><br>  PS All of the above is just my personal opinion.  All characters are fictional. <br><br>  Here the article ends and then comes the example of another long algorithm that is difficult to decompose, added at the request of readers.  So, in order to encrypt some text using one known cryptographic algorithm, you need: <br>  1) Break the source code into blocks of 64 bits <br>  2) For each such unit <br>  { <br>  2.1) Rearrange the bits in the block in places according to a certain algorithm <br>  2.2) Break the block into two blocks 32 bits long (hereinafter - left and right) <br>  2.3) Repeat 16 times: <br>  { <br>  2.3.1) Calculate Ki from the encryption key K and the iteration number according to a certain algorithm. <br>  2.3.2) Extract a block E of length 48 from a right block of length 32 according to a certain algorithm. <br>  2.3.3) F = bitwise sum of Ki and E <br>  2.3.4) the left block is 32 length long = the right block is 32 bits long at the last iteration. <br>  2.3.5) right block of length 32 = left block 32 at the last iteration, bitwise folded with F <br>  2.3.6) Add the left block to the end of the encryption result <br>  2.3.7) Add the right block to the end of the encryption result <br>  } <br>  } <br>  I will add that the description of the Ki calculation algorithm on wikipedia did not fit on my monitor, so I don‚Äôt think that in the program it will be a single line of code.  If you create a ‚Äúcalculate Ki‚Äù function, this will be a bad design, since  it is not clear what this function does and it is not clear what Ki is.  However, if Ki has some common name, and Ki is some common abstraction, the function ‚Äúcalculate Ki‚Äù has a right to exist.  In order to make all the same decomposition, the developers of the algorithm of such abstractions themselves and created, and not very well, their names are similar to "The first piece of the algorithm" and "A piece of the name of such and such."  Agree, terrible design.  However, this design is generally accepted and is the subject area, so if you want to use it, then everything is fine.  However, let's imagine that we need to slightly modify the algorithm in order to create our own unique algorithm that has properties similar to the original algorithm (this can be useful, because it is more difficult for an attacker to crack the ‚Äúunknown to science‚Äù algorithm).  In the new algorithm, the ‚ÄúPiece of the name of such and such‚Äù is modified, and it is no longer the ‚ÄúPiece of the name of this‚Äù.  In this case, it is better not to break the above algorithm into small functions, but leave it as it is, otherwise once (a week after writing the code) you will get entangled in this code as in a maze.  The algorithm here is DES.  ‚ÄúThe first piece‚Äù is ‚ÄúInitial permutation‚Äù, ‚ÄúA piece of the name of such a one‚Äù is ‚ÄúThe function of Feistel‚Äù, E is the ‚ÄúFunction of expansion‚Äù.  In a modified algorithm, all this is different.  It is possible to make a partial decomposition of the modified DES, for example, select the ‚ÄúAdd Bitwise Add Up Blocks‚Äù, ‚ÄúPerform Permutation‚Äù methods (for the Block, from the Permutation Matrix), etc., but the ‚ÄúEncrypt 64 block‚Äù method will still be indecently large.  Selecting the ‚ÄúEncrypt block 32 length‚Äù method is a bad idea, because  you cannot decrypt it;  Encryption and decryption are applicable to blocks 64. I am sure that DES is not the longest of the algorithms, it is possible to find (or invent) and longer ones such that they have a high number of operations at the highest level of abstraction, the purposes and purpose of which differ from each other. friend </div><p>Source: <a href="https://habr.com/ru/post/239799/">https://habr.com/ru/post/239799/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239789/index.html">October 21, watch the AzureConf 2014 online conference from Microsoft Azure experts!</a></li>
<li><a href="../239791/index.html">Merge posts</a></li>
<li><a href="../239793/index.html">How to feed the brain of a programmer ... or feed your brain</a></li>
<li><a href="../239795/index.html">Kim Kardashian is boarding Facebook, Disney removes games from stores, smartphone owners in the Russian Federation more and more, but they rarely download - the main mobile news for the week</a></li>
<li><a href="../239797/index.html">Evaluation of search results</a></li>
<li><a href="../239801/index.html">We invite you to the Internet of Things: Intel IoT Roadshow goes to Moscow!</a></li>
<li><a href="../239803/index.html">Optical Character Recognition by .NET</a></li>
<li><a href="../239805/index.html">Resuscitation D-Link NAS DNS-325</a></li>
<li><a href="../239807/index.html">For those who choose the red pill. Neo toolkit</a></li>
<li><a href="../239809/index.html">Work without an office: how to build and maintain cohesion in a distributed team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>