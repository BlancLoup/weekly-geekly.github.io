<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous modes of gRPC framework and principles of their work in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once we decided to try gRPC for our tasks with our team. After some discussions, we came to the conclusion that we will use an asynchronous client and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous modes of gRPC framework and principles of their work in C ++</h1><div class="post__text post__text-html js-mediator-article">  Once we decided to try gRPC for our tasks with our team.  After some discussions, we came to the conclusion that we will use an asynchronous client and server.  However, there was a working example from the documentation for one mode only.  Examples of other modes of interaction, the basic principles of asynchronous operations, the principles of an asynchronous server and client in gRPC and much more under the cat. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  The purpose of this article is to explain the principles of operation of the asynchronous operations of the gRPC framework in C ++ for all four modes of interaction.  Those readers who want to use asynchronous gRPC modes, but do not fully understand how they are implemented on the server and / or client, will be able to find an explanation below.  Readers who understand the principles of asynchronous server and client, but do not have on hand working examples of all four modes of interaction, will also find examples in the article.  Readers who understood everything and got working examples are asked in the comments. <br><br>  The layout of the article is as follows: <br><br><ol><li>  Differences between multi-threaded and asynchronous application models; <br></li><li>  Asynchronous application model for gRPC; <br></li><li>  Terminology used; <br></li><li>  Initial data; <br></li><li>  Examples of asynchronous interaction modes; <br></li><li>  Conclusion and list of references. <br></li></ol><br><h2>  1. Differences between multithreaded and asynchronous application models </h2><br>  Consider the difference between multi-threaded and asynchronous application architectures. <br>  When more than one client connects to the server, there are exactly two options for handling connections.  The first option is to create a separate stream for each connection, i.e.  servicing each client in its own thread.  The second option is to use the asynchronous model of the application.  The asynchronous model of the application is inextricably linked with the concept of an event loop.  An event is some logical operation at the kernel level: a new connection appeared on the socket, a new message was received from the client, a message was sent to the client, etc.  W.R.  Stephens in his book "Unix: Network Application Development" about the asynchronous I / O model writes the following: <br><blockquote>  We tell the kernel to start the operation and notify us when the entire operation (including copying data from the kernel to our buffer) is complete. </blockquote>  Consider a simple example of a server that handles a client connection in three steps.  The first stage is the processing of the connection.  At this stage, there are no operations with the file system, I / O and DB.  The second stage is the synchronous reading of data from the socket.  And the third stage is the processing of the received data.  Conditions are the same as in the first stage.  For simplicity, we assume that the first and third stages take 1 ms, the second stage takes 2 ms. <br>  Now let's say that several clients have connected to the server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With a multi-threaded model, a separate thread is created for each connection.  Each thread spends 4 ms to process a client request.  However, when reading data from a socket, the thread begins to wait for the operation to complete.  As long as data from the socket is not counted in the application buffer, the stream will be blocked.  It turns out that 2ms of the total 4 ms - 50% of the time the thread is running - the processor will be idle. <br><br>  To solve the problem of idle processor, came up with asynchronous I / O operations and the associated asynchronous application models. <br><br>  The asynchronous model of the application is based on the event queue.  When an event occurs, this event is placed at the end of the queue.  While there are events in the queue, the processor will always be busy.  I / O operations associated with events in the queue must be asynchronous. <br><br>  In the example with a three-stage server, you need to replace the synchronous reading of data from the socket with an asynchronous one.  Of course, as long as the data from the socket is not considered, we will not be able to proceed to the third stage.  However, after placing the event of the end of reading data from the socket to the end of the queue, you can retrieve events from the queue and perform related operations.  For example, for those 2 ms, while data is being read from the socket of the first client, you can handle the connection and request to read the data from the socket for the second and third clients.  After that, the queue will receive the event of completion of reading data from the socket for the first client. <br><br>  In general, in an asynchronous model, each client request may be slower than in a multi-threaded model.  However, the overall performance when using the asynchronous model is higher due to a decrease in processor idle time. <br><br>  At this point, you need to pay attention to a few points.  The first point concerns the fact that all operations in the asynchronous model are performed in one thread.  Unlike multi-threaded model.  In connection with this, there is a second point: if resource-intensive operations are in the event queue, then during their execution the remaining operations will be idle in the queue.  There are two options for solving this problem.  The first option is to create separate threads for resource-intensive operations from the queue.  The second option is to split resource-intensive operations into several parts that will be called from the queue. <br><br><h2>  2. Asynchronous application model for gRPC </h2><br>  When using synchronous RPC on the server, gRPC uses a multi-threaded application model.  Each client request is processed in a separate thread. <br><br>  When using asynchronous RPC, gRPC uses an asynchronous model of the application on both the server and the client.  According to the principle of the asynchronous model, there is a queue of events.  In gRPC, the event queue is implemented in the grpc :: CompletionQueue class.  Adding events to the queue occurs inside gRPC, and requests to add and read events from the queue occur in the user application. <br><br>  In gRPC terminology, responder (responder) is a ‚Äúmeans of responding to a client‚Äù on the server, and a ‚Äúmeans of receiving messages from a server‚Äù on the client. <br><br>  A request to add an event to the event queue occurs when any function is called from the responder interface.  The event, as before, is understood as a logically completed operation.  For example, a client connect to server event means that the client has already connected to the server;  the event of receiving a message from a client means that the message is already in the application's buffer, etc. <br><br>  When requesting to add an event to a queue, each event is assigned a tag.  This is done in order to distinguish events read from the queue.  Strictly speaking, it is not the event that is physically read from the queue, but the tag associated with this event.  For example, let the server make a request to add a message receiving event from a client and assign a tag = 1 to this event. When the tag = 1 returns from the queue, this will mean that a message receiving event from the client has occurred, i.e.  message from client read to specified buffer. <br><br><h2>  3. Terminology used </h2><br>  There are four types of <a href="http://www.grpc.io/docs/guides/concepts.html">methods</a> in gRPC that can be defined in a service. <br><br><ul><li>  Unary RPCs.  The client makes a request to the server as a single message and receives a response as a single message from the server.  Further we will call these methods ONE-ONE, and the classes that implement these methods without suffixes. <br></li><li>  Server streaming RPCs.  The client makes a request to the server as a single message and receives a response as a sequence of messages from the server.  Further we will call these methods ONE-MANY, and the classes that implement these methods with the suffix "1M". <br></li><li>  Client streaming RPCs.  The client makes a request to the server as a sequence of messages and receives a response in the form of a single message from the server.  Further we will call these methods MANY-ONE, and the classes that implement these methods with the suffix ‚ÄúM1‚Äù. <br></li><li>  Bidirectional streaming RPCs.  The client makes a request to the server as a sequence of messages and receives a response as a sequence of messages from the server.  Further we will call these methods MANY-MANY, and the classes that implement these methods with the suffix "MM". <br></li></ul><br>  At the terminology level, we will agree that the phrase ‚Äúafter the next receipt of the tag from the queue‚Äù will be omitted.  For asynchronous gRPC operations, there is a rule: one responder operation (including creating and deleting) for one tag retrieval from the queue.  It was said above that when calling the responder functions, a request is made to add an event to the event queue.  Therefore, in the terminology of the asynchronous model, the rule will sound like this: one request to add an event to the queue for one reading of the event from the queue. <br><br>  This means that it will be correct: wait for receiving the tag from the queue - call the function A of the responder - wait for receiving the tag from the queue - call the function B of the responder - wait for receiving the tag from the queue - delete the responder object.  And any of the combinations where there is no ‚Äúgetting a tag from a queue‚Äù between function calls will be wrong, for example: wait for receiving a tag from a queue - call the A function of the responder - call the B function of the responder - wait for receiving the tag from the queue - delete the object.  Therefore, the phrase ‚Äúafter the next receipt of the tag from the queue‚Äù will be omitted as follows. <br>  At the terminology level, we will use ‚Äútypes of methods‚Äù and ‚Äúmodes of interaction‚Äù as synonyms. <br><br><h2>  4. Baseline </h2><br><h3>  File helloworld.proto </h3><br>  We take the <em>Greeter</em> service as source data and add three methods to each type of interaction (file <em>helloworld.proto</em> ): <br><br><pre><code class="cpp hljs">syntax = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; package helloworld; <span class="hljs-comment"><span class="hljs-comment">// The greeting service definition. service Greeter{ rpc SayHello (HelloRequest) returns (HelloReply) {} rpc GladToSeeMe(HelloRequest) returns (stream HelloReply){} rpc GladToSeeYou(stream HelloRequest) returns (HelloReply){} rpc BothGladToSee(stream HelloRequest) returns (stream HelloReply){} } // The request message containing the user's name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; }</span></span></code> </pre> <br>  The GladToSeeMe method implements ONE-MANY mode.  The GladToSeeYou method implements the MANY-ONE mode.  The BothGladToSee method implements the MANY-MANY mode. <br><br><h3>  Base class on the server </h3><br>  The only thing that will differ in all four types of methods is the mode of interaction with the client.  The responder mode of the corresponding type is responsible for the interaction mode.  All other parameters (service, message queue, context, etc.) in this case are common to all four types of methods.  Therefore, common to all four modes of data are placed in the base abstract class, from which the classes of the corresponding modes will be inherited: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommonCallData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Greeter::AsyncService* service_; ServerCompletionQueue* cq_; ServerContext ctx_; HelloRequest request_; HelloReply reply_; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CallStatus { CREATE, PROCESS, FINISH }; CallStatus status_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> prefix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommonCallData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Greeter::AsyncService* service, ServerCompletionQueue* cq)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cq_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cq)</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CREATE)</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Hello "</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~CommonCallData(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  The abstract CommonCallData class contains data common to each of the modes (some of which are initialized in the constructor), a virtual destructor, and the pure virtual function Proceed (). <br><br><h3>  Base class on client </h3><br>  Solely for the convenience of reading the code, the classes for each type of interaction on the client will look similar to the corresponding classes on the server.  Each of the interaction classes is inherited from the CommonAsyncClientCall base abstract class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommonAsyncClientCall</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ClientContext context; HelloReply reply; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CallStatus { CREATE, PROCESS, FINISH }; CallStatus callStatus ; Status status; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* from)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!reply.message().empty()) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; from &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]: reply message = "</span></span> &lt;&lt; reply.message() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; from &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]: reply message empty"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommonAsyncClientCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CREATE)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~CommonAsyncClientCall(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  The CommonAsyncClientCall class contains data common for all types of interaction, a constructor, a virtual destructor, a purely virtual function Proceed () and a function for outputting a response from the server PrintReply (). <br><br><h2>  5. Examples of asynchronous interaction modes </h2><br><h3>  One-to-one interaction mode </h3><br><h4>  Code on the server </h4><br>  The implementation of the CallData class for one-to-one interaction mode will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonCallData { ServerAsyncResponseWriter&lt;HelloReply&gt; responder_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallData(Greeter::AsyncService* service, ServerCompletionQueue* cq): CommonCallData(service, cq), responder_(&amp;ctx_){Proceed();} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status_ == CREATE) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed11]: New responder for 1-1 mode"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; status_ = PROCESS; service_-&gt;RequestSayHello(&amp;ctx_, &amp;request_, &amp;responder_, cq_, cq_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status_ == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallData(service_, cq_); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed11]: request message = "</span></span> &lt;&lt; request_.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; reply_.set_message(prefix + request_.name()); status_ = FINISH; responder_.Finish(reply_, Status::OK, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPR_ASSERT(status_ == FINISH); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed11]: Good Bye"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } };</code> </pre> <br>  The CallData class is inherited from the base class and implements the Proceed () function.  From class members, only the responder of the corresponding type is present in the CallData class (ServerAsyncResponseWriter &lt;HelloReply&gt;).  The arguments of the CallData constructor are passed to the constructor of the CommonCallData base class.  Since all four classes of the corresponding modes will have their own implementation of Proceed (), the pointer void * tag must now be cast not to the type of CallData, but to the type of CommonCallData: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { GPR_ASSERT(cq_-&gt;Next(&amp;tag, &amp;ok)); <span class="hljs-comment"><span class="hljs-comment">//GPR_ASSERT(ok); static_cast&lt;CommonCallData*&gt;(tag)-&gt;Proceed(ok); }</span></span></code> </pre> <br>  Note that now the <code>GPR_ASSERT(ok)</code> check is commented out.  This will be discussed below. <br><br><h4>  Client Code </h4><br>  The implementation of the AsyncClientCall class for the one-to-one interaction mode will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncClientCall</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonAsyncClientCall { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; ClientAsyncResponseReader&lt;HelloReply&gt; &gt; responder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AsyncClientCall(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HelloRequest&amp; request, CompletionQueue&amp; cq_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Greeter::Stub&gt;&amp; stub_):CommonAsyncClientCall() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed11]: new client 1-1"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder = stub_-&gt;AsyncSayHello(&amp;context, request, &amp;cq_); responder-&gt;Finish(&amp;reply, &amp;status, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//callStatus = PROCESS ; } virtual void Proceed(bool ok = true) override { GPR_ASSERT(ok); if(status.ok()) printReply("Proceed11"); std::cout &lt;&lt; "[Proceed11]: Good Bye" &lt;&lt; std::endl; delete this; } };</span></span></code> </pre> <br>  The AsyncClientCall class is inherited from the CommonAsyncClientCall class, just as in the case of a server, has a responder that corresponds to the interaction mode, and implements the purely virtual function Proceed ().  The code of the Proceed () function is the same as the code above for the corresponding mode, which was executed in the function GreeterClient :: AsyncCompleteRpc (). <br><br>  Code that was previously in the function GreeterClient :: SayHello () is now in the constructor class AsyncClientCall.  From the point of view of logic, such an implementation is not correct and is made to ensure the similarity with the implementation of the server.  Further, all classes on the client will be implemented on the same principle.  If you wish, you can always structure the code as it is done in the documentation. <br><br>  Since we transferred the code from the GreeterClient :: SayHello () function to the AsyncClientCall class constructor, the GreeterClient :: SayHello () function code will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; user)</span></span></span><span class="hljs-function"> </span></span>{ HelloRequest request; request.set_name(user); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncClientCall(request, cq_, stub_); }</code> </pre> <br>  The code for the function GreeterClient :: AsyncCompleteRpc () now looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncCompleteRpc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* got_tag; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cq_.Next(&amp;got_tag, &amp;ok)) { <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;CommonAsyncClientCall*&gt;(got_tag)-&gt;Proceed(ok); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Completion queue is shutting down."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Here you can see the obvious similarities with the code on the server.  Similarly, the tag returned from the queue is assigned to the new response from the server.  Similarly, the tag is given to a pointer to the base class CommonAsyncClientCall, and the corresponding mode is also called the implementation of the function Proceed (). <br><br><h4>  One-to-one console and server console output </h4><br>  The console output of the server for one-to-one mode is as follows: <br><br><pre> <code class="cpp hljs">[Proceed11]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> mode [Proceed11]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> mode [Proceed11]: request message = world [Proceed11]: Good Bye</code> </pre> <br>  First, the first responder is created.  After the request is received from the client, a second responder is created that will process the following requests.  The request from the client contains the message ‚Äúworld‚Äù.  A request is made to send a message to the client by the Finish () responder function.  The next time an object is received in the FINISH state from the queue, the object is deleted. <br><br>  Client console output for one-to-one mode is as follows: <br><br><pre> <code class="cpp hljs">[Proceed11]: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> client <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> [Proceed11]: reply message = Hello world [Proceed11]: Good Bye</code> </pre> <br>  First, create a new client.  When a message from the server is received, it is displayed on the screen.  After this, the object is deleted. <br><br><h3>  One-to-many interaction mode </h3><br><h4>  Code on the server </h4><br>  The CallData1M class, which is responsible for the one-to-many interaction mode on the server, looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData1M</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonCallData { ServerAsyncWriter&lt;HelloReply&gt; responder_;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> mcounter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> new_responder_created; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallData1M(Greeter::AsyncService* service, ServerCompletionQueue* cq): CommonCallData(service, cq), responder_(&amp;ctx_), mcounter, new_responder_created(<span class="hljs-literal"><span class="hljs-literal">false</span></span>){ Proceed() ;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == CREATE) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: New responder for 1-M mode"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; service_-&gt;RequestGladToSeeMe(&amp;ctx_, &amp;request_, &amp;responder_, cq_, cq_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); status_ = PROCESS ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!new_responder_created) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallData1M(service_, cq_); new_responder_created = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: request message = "</span></span> &lt;&lt; request_.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; greeting = {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(prefix + request_.name() + <span class="hljs-string"><span class="hljs-string">"!"</span></span>), <span class="hljs-string"><span class="hljs-string">"I'm very glad to see you!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Haven't seen you for thousand years."</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm server now. Call me later."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mcounter &gt;= greeting.size()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: Trying finish"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; status_ = FINISH; responder_.Finish(Status(), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reply_.set_message(greeting.at(mcounter)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: Writing"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder_.Write(reply_, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ++mcounter; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// if(status_ == FINISH) { std::cout &lt;&lt; "[Proceed1M]: Good Bye" &lt;&lt; std::endl; delete this; } } };</span></span></code> </pre> <br>  The CallData1M class is inherited from the CommonCallData base class and contains three class members: <br><br><ul><li>  <code>ServerAsyncWriter&lt;HelloReply&gt;</code> ; <br></li><li>  <code>unsigned mcounter</code> sent messages <code>unsigned mcounter</code> ; <br></li><li>  flag that the new responder was created by <code>bool new_responder_created</code> <br></li></ul><br>  All members of the class are initialized in the initialization list of the constructor, after which the implementation of the Proceed () function is called.  Initially, all responders have the CREATE state, so we fall into the <code>if(status_ == CREATE)</code> condition <code>if(status_ == CREATE)</code> , in which we indicate the current responder as a tag for a new client connection event.  After that, the responder goes to the PROCESS state.  When the next client request is received, the tag associated with this event will be returned from the queue.  The tag received from the queue is initialized with a pointer to the object of the responder with the status PROCESS.  Therefore, we will fall into the <code>else if(status_ == PROCESS)</code> condition <code>else if(status_ == PROCESS)</code> .  When this condition is first hit, a new responder object will be created to handle the following client requests.  After that, a static vector is created with server responses.  Initially, the mcounter variable is zero, so we are in the else condition.  In the else condition, the response text is set to the message from the response vector under the mcounter number, after which the response is sent to the client and the mcounter variable is incremented. <br><br>  Sending messages to the client will occur exactly (greeting.size () - 1) times.  We cannot send all the answers at once, because it contradicts the principles of the asynchronous model, on the basis of which asynchronous modes are implemented in gRPC.  From the documentation: <blockquote>  Only one write may be outstanding at any given time.  This is what you get. </blockquote>  which means something like the following: Only one recording can be performed at a time, i.e.  After calling the Write function, you need to wait for getting the tag from the queue BEFORE calling the Write function again.  That is why the objects of class CallData1M store information about the number of sent messages. <br><br>  After all the messages from the vector are sent, we will get into the condition if (mcounter&gt; = greeting.size ()).  In this condition, the state of the responder is changed to FINISH, after which the Finish () function is called. <br><br>  The next time in the Proceed () function we will get into the <code>else if(status_ == FINISH)</code> condition in which the object will be deleted. <br><br>  To create the very first object of the CallData1M class, add the line to the Run () function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallData1M(&amp;service_, cq_.get());</code> </pre> <br><h4>  Client Code </h4><br>  The AsyncCallData1M class, which is responsible for the one-to-many interaction mode on the client, looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncClientCall1M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonAsyncClientCall { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; ClientAsyncReader&lt;HelloReply&gt; &gt; responder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AsyncClientCall1M(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HelloRequest&amp; request, CompletionQueue&amp; cq_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Greeter::Stub&gt;&amp; stub_) :CommonAsyncClientCall() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: new client 1-M"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder = stub_-&gt;AsyncGladToSeeMe(&amp;context, request, &amp;cq_, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); callStatus = PROCESS ; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(callStatus == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ok) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: Trying finish"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder-&gt;Finish(&amp;status, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); callStatus = FINISH; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } responder-&gt;Read(&amp;reply, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); printReply(<span class="hljs-string"><span class="hljs-string">"Proceed1M"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(callStatus == FINISH) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[Proceed1M]: Good Bye"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } };</code> </pre> <br>  The AsyncClientCall1M class is inherited from CommonAsyncClientCall and contains the corresponding type of responder.  In the class constructor, a request is made to the server and the responder goes to the PROCESS state. <br><br>  When an object of this class returns from the queue, its status will be PROCESS.  The ok flag received from the queue associated with the tag is passed to the Proceed () function.  The value of the ok flag equal to false means that there will be no more messages from the server, i.e.  The Finish () function was called on the server.  When the client-side function needs to be called, the Finish () function is described in the <a href="https://grpc.io/grpc/cpp/classgrpc_1_1_client_async_streaming_interface.html">documentation</a> : <blockquote>  It is appropriate to call it asyncReaderInterface :: Read that message when it was received. result, eg cq-&gt; Next (&amp; read_tag, &amp; ok) filled in 'ok' with 'false'). </blockquote>  which means something like the following: you need to call this method [Finish ()] when there are no more messages from the server (this can be found implicitly from the code or explicitly when a read request (AsyncReaderInterface :: Read) returns a bad result, i.e. ok , returned from the <code>cq-&gt;Next(&amp;read_tag, &amp;ok)</code> queue <code>cq-&gt;Next(&amp;read_tag, &amp;ok)</code> will be false). <br><br>  If ok is true, then we make the next request for reading messages by calling the Read () responder function.  Regarding the Read function, the <a href="https://grpc.io/grpc/cpp/classgrpc_1_1_async_reader_interface.html">documentation</a> states the following: <blockquote>  Read a message of type R into msg.  Completion will be noted on the associated completion queue. </blockquote>  which means: [The Read () function] reads a message of type R into the variable msg.  A notification of the completion of the read operation will be made by the tag from the queue. <br><br>  After the first call of the Read () function, the variable containing the reply (reply) will be still empty, since the event of the end of reading the message has not yet occurred. <br><br>  When all messages from the server have been read, the ok flag will return from the queue with a value of false, the responder‚Äôs Finish () function will be called, after which the responder will go to FINISH state.  After receiving from the queue an object of a class with the state FINISH, this class will be deleted. <br><br>  To create an object of the AsyncClientCall1M class, in the GreeterClient class you need to add the GladToSeeMe () function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GladToSeeMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; user)</span></span></span><span class="hljs-function"> </span></span>{ HelloRequest request; request.set_name(user); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncClientCall1M(request, cq_, stub_); }</code> </pre> <br><h4>  One-to-many console output for server and client </h4><br>  The console output of the server for the one-to-many mode is as follows: <br><br><pre> <code class="cpp hljs">[Proceed1M]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>-M mode [Proceed1M]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>-M mode [Proceed1M]: request message = client [Proceed1M]: Writing [Proceed1M]: Writing [Proceed1M]: Writing [Proceed1M]: Writing [Proceed1M]: Trying finish [Proceed1M]: Good Bye</code> </pre> <br>  First, the first responder is created.  After the request is received from the client, a second responder is created that will process the following requests.  The request from the client contains the message ‚Äúclient‚Äù.  After that, four responses are sent to the client, after which the Finish () responder function is called.  The next time an object is received in the FINISH state from the queue, the object is deleted. <br>  Client console output for one-to-many mode looks like this: <br><pre> <code class="cpp hljs">[Proceed1M]: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> client <span class="hljs-number"><span class="hljs-number">1</span></span>-M [Proceed1M]: reply message empty [Proceed1M]: reply message = Hello client! [Proceed1M]: reply message = I'm very glad to see you! [Proceed1M]: reply message = Haven't seen you <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> thousand years. [Proceed1M]: reply message = I'm server now. Call me later. [Proceed1M]: Trying finish [Proceed1M]: Good Bye</code> </pre> <br>  First, create a new client.  After the first call of the Read () responder function, the variable containing the reply is not yet filled, so the message ‚Äúreply message empty‚Äù is displayed.  The client then receives 4 messages from the server, after which the ok flag is returned from the queue, which is false.  The Finder () responder function is called.  When you next get the object from the queue, the object is deleted. <br><br><h3>  Interaction mode many to one </h3><br><h4>  Code on the server </h4><br>  The CallDataM1 class, responsible for the many-to-one interaction mode on the server, is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallDataM1</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonCallData { ServerAsyncReader&lt;HelloReply, HelloRequest&gt; responder_; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> new_responder_created; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallDataM1(Greeter::AsyncService* service, ServerCompletionQueue* cq): CommonCallData(service, cq), responder_(&amp;ctx_), new_responder_created(<span class="hljs-literal"><span class="hljs-literal">false</span></span>){Proceed();} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == CREATE) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedM1]: New responder for M-1 mode"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; status_ = PROCESS ; service_-&gt;RequestGladToSeeYou(&amp;ctx_, &amp;responder_, cq_, cq_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!new_responder_created) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallDataM1(service_, cq_); new_responder_created = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; } <span class="hljs-comment"><span class="hljs-comment">//It's time to send reply if(!ok) { std::string greeting("Hello, Client!"); reply_.set_message(greeting); std::cout &lt;&lt; "[ProceedM1]: Sending reply" &lt;&lt; std::endl; status_ = FINISH; responder_.Finish(reply_, Status(), (void*)this); return ; } responder_.Read(&amp;request_, (void*)this); if(!request_.name().empty()) std::cout &lt;&lt; "[ProceedM1]: request message =" &lt;&lt; request_.name() &lt;&lt; std::endl; } else // if(status_ == FINISH) { std::cout &lt;&lt; "[ProceedM1]: Good Bye" &lt;&lt; std::endl; delete this; } } };</span></span></code> </pre> <br>  The CallDataM1 class is inherited from the CommonCallData base class and contains two class members: <br><br><ul><li>  <code>ServerAsyncReader&lt;HelloReply, HelloRequest&gt;</code> ; <br></li><li>  flag that the new responder was created by <code>bool new_responder_created</code> <br></li></ul><br>  All members of the class are initialized in the initialization list of the constructor, after which the implementation of the Proceed () function is called.  In the CREATE state, the request for processing the next client request with the responder tag is also given.  After that, the responder goes to the PROCESS state.  The code in the <code>else if(status_ == PROCESS)</code> condition of this class is very similar to the client class class ClientAsyncCall1M. <br><br>  In fact, the working principle of the ClientAsyncCall1M client class and the CallDataM1 server class are exactly the same.  The server reads client requests until a tag with the ok flag is set to false from the queue.  Just as in the one-to-many client class mode, an ok flag with a value of false means that there will be no more messages from the client.  After the ok flag with the value false is received, the Finish responder function is called and the responder enters the FINISH state.  When an object is received from the queue in the FINISH state, the object is deleted. <br><br>  To create the very first object of the CallDataM1 class, add the line to the Run () function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallDataM1(&amp;service_, cq_.get());</code> </pre> <br><br><h4>  Client Code </h4><br>  The AsyncClientCallM1 class, which is responsible for the many-to-one interaction mode on the client, looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncClientCallM1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonAsyncClientCall { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; ClientAsyncWriter&lt;HelloRequest&gt; &gt; responder; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> mcounter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing_mode_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AsyncClientCallM1(CompletionQueue&amp; cq_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Greeter::Stub&gt;&amp; stub_): CommonAsyncClientCall(), mcounter,writing_mode_(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedM1]: new client M-1"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder = stub_-&gt;AsyncGladToSeeYou(&amp;context, &amp;reply, &amp;cq_, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); callStatus = PROCESS ; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(callStatus == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(writing_mode_) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; greeting = {<span class="hljs-string"><span class="hljs-string">"Hello, server!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Glad to see you!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Haven't seen you for thousand years!"</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm client now. Call me later."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mcounter &lt; greeting.size()) { HelloRequest request; request.set_name(greeting.at(mcounter)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedM1]: Writing"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder-&gt;Write(request, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ++mcounter ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { responder-&gt;WritesDone((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedM1]: changing state to reading"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; writing_mode_ = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span><span class="hljs-comment"><span class="hljs-comment">//reading mode { std::cout &lt;&lt; "[ProceedM1]: trying finish" &lt;&lt; std::endl; responder-&gt;Finish(&amp;status, (void*)this); callStatus = FINISH ; } } else if(callStatus == FINISH) { assert(!reply.message().empty()); printReply("ProceedM1"); std::cout &lt;&lt; "[ProceedM1]: Good Bye" &lt;&lt; std::endl; delete this; } return ; } };</span></span></code> </pre> <br>  The AsyncClientCallM1 class is inherited from the CommonAsyncClientCall class and has a corresponding responder and a message counter.  In addition to these two members, the AsyncClientCallM1 class has a status flag.  The principle of operation of the Proceed () function in the PROCESS state in the write mode ( <code>if(writing_mode_)</code> condition <code>if(writing_mode_)</code> ) coincides with the principle of the Proceed () function of the CallData1M class with the difference that here after sending all the messages the WritesDone () responder function is called, whereas CallData1M class calls the Finish () function.  After calling the responder function WritesDone (), the client enters the reading state ( <code>writing_mode_ = false</code> ).  In the read state, the Finish () responder function is called and the responder enters the FINISH state. <br><br>  Here you should pay attention to the fact that here, in addition to calling the responder function WritesDone (), there is a call to the responder function Finish ().  The documentation on this subject states the following: <blockquote>  It is appropriate to call upon this method. ClientAsyncWriterInterface :: WritesDone or ClientAsyncReaderWriterInterface :: WritesDone) </blockquote>  which means something like the following: You need to call this method (Finish ()) when the client does not have more messages to send to the server (which can be declared implicitly simply by calling this method, or explicitly by calling the WritesDone () method).  But since the AsyncClientCallM1 class sends several messages to the server by calling the Write () method, the Respones method of WritesDone () must be called explicitly to inform the server that there will be no more messages (unlike the AsyncClientCall1M class, which sends only one request to the server when calling the AsyncGladToSeeMe ()) function.  Therefore, after calling the WritesDone () method, the responder enters the read state and the Finish () function is called in it.  When an object is received from the queue in the FINISH state, the response from the server is displayed on the screen and the object is deleted. <br><br>  To create an object of class AsyncClientCallM1, in the GreeterClient class, add the GladToSeeYou () function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GladToSeeYou</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncClientCallM1(cq_, stub_); }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output of server and client in many to one mode </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The console output of the server for many-to-one mode is as follows: </font></font><br><br><pre> <code class="cpp hljs">[ProceedM1]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> M<span class="hljs-number"><span class="hljs-number">-1</span></span> mode [ProceedM1]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> M<span class="hljs-number"><span class="hljs-number">-1</span></span> mode [ProceedM1]: request message = Hello, server! [ProceedM1]: request message = Glad to see you! [ProceedM1]: request message = Haven't seen you <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> thousand years! [ProceedM1]: request message = I'm client now. Call me later. [ProceedM1]: Sending reply [ProceedM1]: Good Bye</code> </pre> <br>    .  ,     ,   ,     .      .      Read().  ,       AsyncClientCall1M        .         ok,   false,  ,     WritesDone().    Finish()    .       FINISH  ,  . <br><br>           : <br><br><pre> <code class="cpp hljs">[ProceedM1]: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> client M<span class="hljs-number"><span class="hljs-number">-1</span></span> [ProceedM1]: Writing [ProceedM1]: Writing [ProceedM1]: Writing [ProceedM1]: Writing [ProceedM1]: changing state to reading [ProceedM1]: trying finish [ProceedM1]: reply message = Hello, Client! [ProceedM1]: Good Bye</code> </pre> <br>    . e   ,     WritesDone()      .         (PROCESS),    Finish()      FINISH.        FINISH,          . <br><br><h3>      </h3><br><h4>    </h4><br>  CallDataMM,            : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallDataMM</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonCallData { ServerAsyncReaderWriter&lt;HelloReply, HelloRequest&gt; responder_; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> mcounter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing_mode_; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> new_responder_created; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallDataMM(Greeter::AsyncService* service, ServerCompletionQueue* cq): CommonCallData(service, cq), responder_(&amp;ctx_), mcounter, writing_mode_(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), new_responder_created(<span class="hljs-literal"><span class="hljs-literal">false</span></span>){Proceed();} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == CREATE) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedMM]: New responder for MM mode"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; status_ = PROCESS ; service_-&gt;RequestBothGladToSee(&amp;ctx_, &amp;responder_, cq_, cq_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status_ == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!new_responder_created) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallDataMM(service_, cq_); new_responder_created = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!writing_mode_)<span class="hljs-comment"><span class="hljs-comment">//reading mode { if(!ok) { writing_mode_ = true; ok = true; std::cout &lt;&lt; "[ProceedMM]: changing state to writing" &lt;&lt; std::endl; } else { responder_.Read(&amp;request_, (void*)this); if(!request_.name().empty()) std::cout &lt;&lt; "[ProceedMM]: request message =" &lt;&lt; request_.name() &lt;&lt; std::endl; } } if(writing_mode_)//writing mode { static std::vector&lt;std::string&gt; greeting = {std::string(prefix + "client" "!"), "I'm very glad to see you!", "Haven't seen you for thousand years.", "How are you?", "I'm server now. Call me later."}; if(!ok || mcounter &gt;= greeting.size()) { std::cout &lt;&lt; "[ProceedMM]: Trying finish" &lt;&lt; std::endl; status_ = FINISH; responder_.Finish(Status(), (void*)this); } else { reply_.set_message(greeting.at(mcounter)); responder_.Write(reply_, (void*)this); ++mcounter; } } } else // if(status_ == FINISH) { std::cout &lt;&lt; "[ProceedMM]: Good Bye" &lt;&lt; std::endl; delete this; } } };</span></span></code> </pre> <br>  CallDataMM     CommonCallData,    : <br><br><ul><li>  <code>ServerAsyncReaderWriter&lt;HelloReply, HelloRequest&amp;gt</code> ; <br></li><li>    <code>unsigned mcounter</code> ; <br></li><li>   / <code>bool writing_mode_</code> ; <br></li><li>  ,      <code>bool new_responder_created</code> <br></li></ul><br>        ,      Proceed().   CREATE               .       PROCESS.   Proceed()   PROCESS     ‚Äî        .  ,     : CallData1M     CallDataM1   .     <code>if(!writing_mode_)</code> .      CallDataM1        ,       ok   false.   ok   false   ,      <code>writing_mode_ = true;</code>  .  ,    ,     .   ,                . <br><br>         (greeting.size()-1) .      Finish()      FINISH.        FINISH,  . <br><br>       CallDataM,    Run()  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallDataM(&amp;service_, cq_.get());</code> </pre> <br><h4>    </h4><br>  AsyncClientCallMM,            : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncClientCallMM</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommonAsyncClientCall { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; ClientAsyncReaderWriter&lt;HelloRequest,HelloReply&gt; &gt; responder; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> mcounter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing_mode_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AsyncClientCallMM(CompletionQueue&amp; cq_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Greeter::Stub&gt;&amp; stub_): CommonAsyncClientCall(), mcounter, writing_mode_(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"[ProceedMM]: new client MM"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; responder = stub_-&gt;AsyncBothGladToSee(&amp;context, &amp;cq_, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); callStatus = PROCESS ; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(callStatus == PROCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(writing_mode_) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; greeting = {<span class="hljs-string"><span class="hljs-string">"Hello, server!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Glad to see you!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Haven't seen you for thousand years!"</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm client now. Call me later."</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//std::cout &lt;&lt; "[ProceedMM]: mcounter = " &lt;&lt; mcounter &lt;&lt; std::endl; if(mcounter &lt; greeting.size()) { HelloRequest request; request.set_name(greeting.at(mcounter)); responder-&gt;Write(request, (void*)this); ++mcounter; } else { responder-&gt;WritesDone((void*)this); std::cout &lt;&lt; "[ProceedMM]: changing state to reading" &lt;&lt; std::endl; writing_mode_ = false; } return ; } else //reading mode { if(!ok) { std::cout &lt;&lt; "[ProceedMM]: trying finish" &lt;&lt; std::endl; callStatus = FINISH; responder-&gt;Finish(&amp;status, (void*)this); return; } responder-&gt;Read(&amp;reply, (void*)this); printReply("ProceedMM"); } return; } else if(callStatus == FINISH) { std::cout &lt;&lt; "[ProceedMM]: Good Bye" &lt;&lt; std::endl; delete this; } } };</span></span></code> </pre> <br>  AsyncClientCallMM    CommonAsyncClientCall,   ,      /.       CallDataMM  ,   Proceed()  AsyncClientCallMM   PROCESS    :         .  ,     :  AsyncClientCallM1     AsyncClientCall1M   . <br><br>        <code>if(writing_mode_)</code> .      (greeting.size() ‚Äî 1) ,      WritesDone()      .          Proceed(),     CallDataMM  ,    .   ,        ,       ok   false.   ok   false   ,    Finish()      FINISH.        FINISH,  . <br><br>     AsyncClientCallMM,    GreeterClient   BothGladToSee(): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BothGladToSee</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncClientCallMM(cq_, stub_); }</code> </pre> <br><h4>           </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The console output of the server for many-to-many mode is as follows:</font></font><br><br><pre> <code class="cpp hljs">[ProceedMM]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MM mode [ProceedMM]: New responder <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MM mode [ProceedMM]: request message = Hello, server! [ProceedMM]: request message = Glad to see you! [ProceedMM]: request message = Haven't seen you <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> thousand years! [ProceedMM]: request message = I'm client now. Call me later. [ProceedMM]: changing state to writing [ProceedMM]: Trying finish [ProceedMM]: Good Bye</code> </pre> <br>    .  ,     ,   ,     .      .        Read().         ok,   false,  ,     WritesDone().       .    ,      Finish()      FINISH.       FINISH  ,  . <br><br>           : <br><br><pre> <code class="cpp hljs">[ProceedMM]: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> client MM [ProceedMM]: changing state to reading [ProceedMM]: reply message empty [ProceedMM]: reply message = Hello client! [ProceedMM]: reply message = I'm very glad to see you! [ProceedMM]: reply message = Haven't seen you <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> thousand years. [ProceedMM]: reply message = How are you? [ProceedMM]: reply message = I'm server now. Call me later. [ProceedMM]: trying finish [ProceedMM]: Good Bye</code> </pre> <br>    . e   ,     WritesDone()      .         ,       ok   false,        Finish().    Finish()      FINISH.        FINISH  . <br><br><h2> 6.      </h2><br>  ,         ,      gRPC          .       .   ,     ,  ,        ,    .    ,  ,    .   -    ,          ! <br><br><h4> C  : </h4><br><ul><li> <a href="https://grpc.io/grpc/cpp">  gRPC</a> <br></li><li> <a href="">     gRPC</a> <br></li><li> <a href="https://github.com/Mityuha/grpc_async">    </a> <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/340758/">https://habr.com/ru/post/340758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340746/index.html">Video calls to Zoom video from web pages</a></li>
<li><a href="../340750/index.html">Web application on Node and Vue, part 1: project structure, API, authentication</a></li>
<li><a href="../340752/index.html">Secrets of a developer who has sold half a million copies of games</a></li>
<li><a href="../340754/index.html">Implementing a proxy server on the integration bus</a></li>
<li><a href="../340756/index.html">How quickly can the phone be infected with a virus, and what will happen to it after that?</a></li>
<li><a href="../340760/index.html">Meeting in St. Petersburg November 16: Delivery-infrastructure for companies and individual projects</a></li>
<li><a href="../340764/index.html">Co-Laboratory: Atlassian User Group mitap</a></li>
<li><a href="../340768/index.html">Monitoring git clone and git push events on a local GitLab server</a></li>
<li><a href="../340770/index.html">Introduction to Beautiful Capi, C ++ wrapper creation tool for C ++ libraries</a></li>
<li><a href="../340772/index.html">Evolutionary Computing: Learning to Walk a Stool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>