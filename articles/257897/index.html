<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about real numbers. More precisely, the representation of their processor in the calculation of fractional values. Each of us was f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a29/2ff/aa9/a292ffaa922a4740be0fcc54826a184e.jpg"><br><br>  Today we will talk about real numbers.  More precisely, the representation of their processor in the calculation of fractional values.  Each of us was faced with the conclusion in a row of numbers of the form 3.4999990123 instead of 3.5 or, worse, a huge difference after the calculations between the theoretical result and what was the result of the execution of the program code.  There is no terrible secret in this, and we will discuss the pros and cons of the approach of representing floating-point numbers, consider an alternative fixed-point path, and write the decimal fraction class with fixed precision. <br><a name="habracut"></a><br><h4>  Where the point floats </h4><br>  It is no secret that the processor did not always understand real numbers.  At the dawn of the programming era, before the advent of the first coprocessors, real numbers were not supported at the hardware level and were emulated algorithmically with the help of integers with which the processor got on well.  Thus, the real type in the old good Pascal was the progenitor of the current real numbers, but it was a superstructure over an integer in which the bits were logically interpreted as a mantissa and a real number exponent. <br><br>  A mantissa is essentially a number written without a dot.  The exponent is the degree to which a certain number N must be erected (as a rule, N = 2), so that when multiplied by a mantissa, we obtain the desired number (up to the bit depth of the mantissa).  It looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="markdown hljs">x = m * N ^ e,  m  e ‚Äî  ,         .</code> </pre> <br>  To avoid ambiguity, it is considered that 1 &lt;= | m |  &lt;N, that is, the number is written in the form as if it were with one character before the comma, but the comma was maliciously erased, and the number turned into a whole. <br><br><blockquote>  A mantissa is essentially a number written without a dot.  The exponent is the degree to which you need to build a certain number N (as a rule, N = 2), so that when multiplied by the mantissa you get the desired number </blockquote><br><blockquote>  More recently, floating-point operations, as well as all algorithms with real numbers, the developers tried to avoid.  The coprocessor processing operations with real numbers was not on all processors, and where it was, it did not always work efficiently.  But as time went on, now floating point operations are built into the processor core, moreover, video chips are also actively processing real numbers, parallelizing operations of the same type. </blockquote><br>  Modern real numbers supported by hardware at the processor level are also broken down into a mantissa and an exponent.  Of course, all operations familiar to the arithmetic of integers are also supported by processor commands for real numbers and are performed as quickly as possible. <br><br>  Everything is so difficult because, first of all, such a recording format allows multiplication and division operations with such numbers to be quite effective; besides, it is also easy to get the initial real number represented by such a format.  This representation of numbers is called <b>a floating point number</b> . <br><br><h4>  Point swimming standard </h4><br>  Floating-point real numbers supported at the processor level are described by a special international standard <b>IEEE 754</b> .  The main two types for any calculation are <b>single-precision</b> (single precision) and <b>double-precision</b> (double precision) <b>floating-point</b> (floating point numbers).  These names directly reflect the bitness of the binary representation of single and double precision numbers: 32 bits are allocated to the single-precision representation, and 64 bits, to double, oddly enough, exactly twice as large. <br><br><blockquote>  In addition to single and double precision, the new edition of the IEEE 754-2008 standard also provides for types of extended precision, quadruple and even half precision.  However, in C / C ++, besides float and double, there is perhaps another type of long double, persistently not supported by Microsoft, which in Visual C ++ substitutes the usual double instead.  The processor core is also currently, as a rule, not yet supported types of half and quadruple precision.  Therefore, choosing floating-point representations, we have to choose only from float and double. </blockquote><br>  The basis for the exponent of the number according to the standard is taken 2, respectively, the above formula reduces to the following: <br><br><pre> <code class="markdown hljs">x = m * (2 ^ e),  1 <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> |</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span></span><span class="xml"><span class="hljs-tag">| &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">e</span></span></span></span><span class="xml"><span class="hljs-tag"> ‚Äî </span></span></span></span></code> </pre><br>  The alignment in bits in single precision numbers looks like this: <br><br>  |  1 bit under the sign |  8 bit exponent |  23 bits mantissa | <br><br>  For double precision, we can use more bits: <br><br>  |  1 bit under the sign |  11 bit exhibitors |  52 bits mantissa | <br><br>  In both cases, if the sign bit is 0, then the number is positive and 1 is set for negative numbers.  This rule is similar to integers with the only difference that, unlike integers, in order to get the number inverse to the addition, it is enough to invert one bit of the sign. <br><br>  Since the mantissa is written in binary form, the integer part is already equal to 1, therefore in the record of the mantissa one bit is always implied, which is not stored in the binary record.  The fractional part of the normalized number is stored in bits of the mantissa in binary notation. <br><br><blockquote>  The mantissa is written in binary form, and the whole part, which is obviously equal to 1, is discarded; therefore, we never forget that the mantissa is one bit longer than it is stored in binary form </blockquote><br>  You do not need to have a doctoral degree in order to calculate the accuracy in decimal places of numbers that can be represented by this standard: 2 ^ (23 + 1) = 16,777,216;  this clearly indicates to us that the accuracy of the representation of real numbers with single precision reaches slightly more than seven decimal places.  This means that we will not be able to save in this format, for example, the number 123,456.78 is a small number, in general, but starting from the hundredth we will get the wrong number.  The situation is complicated by the fact that for large numbers of the form 1 234 567 890, which perfectly fits even into a 32-bit integer, we will get an error in hundreds of units!  Therefore, for example, in C ++ for real numbers, the <b>double</b> type is used by default.  The double-precision mantissa already exceeds 15 characters: 2 ^ 52&gt; = 4 503 599 627 370 496 and quietly contains all 32-bit integers, failing only on really large 64-bit integers (19 decimal places), where the error in hundreds of units already, as a rule, irrelevant.  If greater accuracy is needed, then we will definitely help with this article. <br><br>  Now for the exponent.  This is the usual binary representation of an integer in which you need to build 10 so that when multiplied by the mantissa in a normalized form, you get the original number.  Here, only in the standard, in addition, we introduced an offset, which must be subtracted from the binary representation, in order to obtain the desired degree of tens (the so-called <b>biased exponent</b> is an offset exponent).  The exponent is shifted to simplify the comparison operation, that is, for single precision, the value 127 is taken, and for double 1023. This all sounds extremely difficult, so many skip the chapter on floating point type.  And in vain! <br><br><h4>  Approximate swimming </h4><br>  To make it a little clearer, consider an example.  Encode the number <b>640</b> (= 512 + 128) in binary form as a real number of single precision: <br><br><ul><li>  the number is positive - the sign bit will be 0; </li><li>  to get a normalized mantissa, we need to divide the number by 512 - the maximum power of two, the smaller number, we get 640/512 = 512/512 + 128/512 or 1 + 1/4, which gives the binary record 1.01, respectively the bits of the mantis will be 0100000 00000000 00000000; </li><li>  to get 640 from 1 + 1/4 again, we need to specify an exponent equal to 9, just 2 ^ 9 = 512, the number we divided the number when normalizing the mantissa, but in the binary form there must be a representation in the shifted form, and for real numbers of single precision, you need to add 127, we get 127 + 9 = 128 + 8, which in binary form will be written as: 10001000. </li></ul><br>  For double precision, almost everything will be the same, but the mantissa will contain even more zeros on the right in the fractional part, and the exponent will be 1023 + 9 = 1024 + 8, that is, slightly more than zeros between the high bit and the number of exponents: 100 00001000. In general , it's not so scary, if you carefully understand. <br><br>  Home task: understand the binary constants of the following constants: plus and minus infinity ( <b>INF</b> - infinity), zero, minus zero and non-integer number ( <b>NaN</b> - not-a-number). <br><br><h4>  For the buoys do not swim! </h4><br>  There is one important rule: each number representation format has its limits beyond which it is impossible to swim.  Moreover, the programmer himself has to ensure that the programmer does not go beyond these limits, because the behavior of a C / C ++ program is to make an imperturbable person when issuing two large positive integers as an addition as small negative ones.  But if for integers it is necessary to take into account only the maximum and minimum value, then for real numbers in the floating-point representation, more attention should be paid not so much to the maximum values ‚Äã‚Äãas to the number of digits.  Thanks to the exponent, the maximum number for a floating-point representation with double precision exceeds 10 <sup>308</sup> , even the single-precision exponent makes it possible to encode numbers above 10 <sup>38</sup> .  If we compare it with the ‚Äúmiserable‚Äù 10 <sup>19</sup> , the maximum for 64-bit integers, we can conclude that the maximum and minimum values ‚Äã‚Äãwill hardly ever have to be taken into account, although you should not forget about them. <br><br><blockquote>  If for integers you need to take into account only the maximum and minimum value, then for real numbers in the floating-point representation, you should pay more attention not so much to the maximum values, but to the number of digits. </blockquote><br>  Another thing is the problem of accuracy.  A pitiful 23 bits under the mantissa give an error already on the 8th decimal place.  For double-precision numbers, the situation is not so deplorable, but 15 decimal places quickly turn into a problem if, for example, data processing requires 6 fixed signs after a point, and numbers to a point are rather large, only 9 digits remain for them.  Accordingly, any multi-billion dollar sums will give a significant error in the fractional part.  With a high intensity of processing such numbers, billions of euros can disappear, simply because they "do not fit", and the fractional error was summed up and accumulated a huge balance of unrecorded data. <br><br>  If only it were a theory!  In practice, even a thousandth of a cent should not disappear, the error of all operations should be strictly zero.  Therefore, for business logic, as a rule, they do not use C / C ++, but take C # or Python, where the standard library already has a Decimal type built in that processes decimal fractions with zero error at the specified accuracy in decimal places after the comma.  What can we, C ++ programmers, do if we are faced with the task of processing numbers of very high resolution without using high-level programming languages?  Yes, the same as usual: fill in the gap by creating one small data type for working with high-precision decimal fractions, similar to the Decimal types of high-level libraries. <br><br><h4>  Add a floating point cement </h4><br>  It's time to fix the floating point.  Since we decided to get rid of the floating-point type because of problems with the accuracy of the calculations, we have integer types, and since we need the maximum bit depth, we also need the whole ones to have a maximum bit depth of 64 bits. <br><br>  Today, for educational purposes, we will look at how to create a representation of real numbers with guaranteed accuracy up to 18 digits after a full stop.  This is achieved by simply combining two 64-bit integers for the integer and fractional parts, respectively.  In principle, no one bothers, instead of a single number for each of the components, to take an array of values ‚Äã‚Äãand get a full-fledged ‚Äúlong‚Äù arithmetic.  But it will be more than enough now to solve the problem of accuracy, making it possible to work with an accuracy of 18 characters before and after the decimal point, fixing the point between these two values ‚Äã‚Äãand filling it with cement. <br><br><h4>  Give me a decimal! </h4><br>  First, a little theory.  Denote our two components, the integer and fractional parts of a number, as n and f, and the number itself will be representable as <br><br>  x = n + f * 10 <sup>-18</sup> , where n, f are integers, 0 &lt;= f &lt;10 <sup>18</sup> . <br><br>  For the integer part, the sign type of a 64-bit integer is best, and for the fractional part it is unsigned, this will simplify many operations in the future. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">decimal</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> m_integral; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m_fractional; };</code> </pre><br>  The integer part in this case is the maximum integer smaller than the number represented, the fractional part is the result of subtracting from this number its integer part multiplied by 10 <sup>18</sup> and reduced to the integer: f = (x - n) * 10 <sup>18</sup> . <br><br>  The integer part for negative numbers will be larger in modulus of the number itself, and the fractional part will not coincide with the decimal notation of the number itself, for example, for the number ‚Äì1.67 components will be: n = ‚Äì2 and f = 0.33 * 10 <sup>18</sup> .  But such a record allows us to simplify and speed up the algorithms of addition and multiplication, since no branching is necessary for negative numbers. <br><br><h4>  Decimal type operations </h4><br>  Of course, the type of number with high accuracy will be useless without arithmetic operations.  Addition is implemented relatively simply: <br><br><pre> <code class="cpp hljs">x = a + b * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>, y = c + d * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>, z = x + y = e + f * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>, a, c, e: <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>; b, d ,f: <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>; <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= b, d, f &lt; <span class="hljs-number"><span class="hljs-number">1e+18</span></span>, z = (a + b * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>) + (c + d * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>) e = a + c + [b * <span class="hljs-number"><span class="hljs-number">1e-18</span></span> + d * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>] f = {b * <span class="hljs-number"><span class="hljs-number">1e-18</span></span> + d * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>} * <span class="hljs-number"><span class="hljs-number">1e+18</span></span></code> </pre><br>  <b>NB:</b> hereinafter all the records in the form 1e are integers. <br><br>  Here [n] is getting the integer part of a number, and {n} is getting the fractional part.  Everything is good, but remember about the restriction of integers.  The value of 1e + 18 is already close to the verge of an unsigned 64-bit integer type uint64_t (that is why we chose it), but no one bothers to simplify the expression a bit to ensure that we stay within the bounds of the type based on the initial conditions: <br><br><pre> <code class="cpp hljs">e = a + c + (b + d) div <span class="hljs-number"><span class="hljs-number">1e+18</span></span>, f = (b + d) mod <span class="hljs-number"><span class="hljs-number">1e+18</span></span>.</code> </pre><br><blockquote>  Two things should always be taken into account when implementing operations with numbers, since they imply intensive use: first, you should always optimize the algorithm, minimizing multiplication and division operations, so you should simplify the expression mathematically in advance so that the first paragraph is easily executed.  In our case, everything needs to be minimized integer divisions with the remainder.  Secondly, it is imperative to check all possible situations of overflow of a number with going beyond the boundaries of the calculated type, otherwise you will get very unobvious errors when using your type. </blockquote><br>  Of course, it is worth checking the boundary values ‚Äã‚Äãwhen adding a and c.  Also, assuming that b and d are less than 1e + 18, we know that (b + d) &lt;2 * 1e + 18, which means that the last addition will add a maximum of one, therefore, algorithmically, the division can not be considered to optimize the execution speed operations: <br><br><pre> <code class="cpp hljs">e = a + c; f = b + d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f &gt;= <span class="hljs-number"><span class="hljs-number">1e+18</span></span>) f -= <span class="hljs-number"><span class="hljs-number">1e+18</span></span>, ++e;</code> </pre><br>  Here, the checks on the maximum integer for the value of e are omitted for simplicity. <br><br>  To subtract everything a bit more complicated, here you need to take into account the transition below zero for an unsigned integer.  That is, you need to compare two numbers before subtraction. <br><br><pre> <code class="cpp hljs">e = a - c; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &gt;= d) f = b - d; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f = (<span class="hljs-number"><span class="hljs-number">1e+18</span></span> - d) + b, --e;</code> </pre><br>  In general, everything is easy.  Before multiplication and division, everything is always easy. <br><br><h4>  Multiplication of numbers with fixed precision </h4><br>  Consider multiplication first.  Since the numbers in the fractional part are quite large and, as a rule, are in the nearest neighborhood of 1e + 18, we will have to either use assembly language and operations with Q-registers, or bypass the integers, breaking each component into two parts, 1e + 9.  In this case, the multiplication will give no more than 1e + 18 and we will not need the assembler yet, it will not be so fast, but we have enough of a 64-bit integer, and we will remain inside C ++.  Do you remember the school and the multiplication column?  If not, it's time to remember: <br><br>  a = s <sub>a</sub> * a <sub>1</sub> - a <sub>2</sub> * 10 <sup>-9</sup> ;  b = b <sub>1</sub> - b <sub>2</sub> * 10 <sup>-9</sup> ; <br>  c = s <sub>c</sub> * c <sub>1</sub> - c <sub>2</sub> * 10 <sup>-9</sup> ;  d = d <sub>1</sub> - d <sub>2</sub> * 10 <sup>-9</sup> ; <br>  0 &lt;= a <sub>2</sub> , b <sub>2</sub> , c <sub>1,2</sub> , c <sub>1,2</sub> &lt;10 <sup>9</sup> ; <br>  s <sub>a, c</sub> = sign (a), sign (c) <br>  0 &lt;= a <sub>1</sub> , with <sub>1</sub> &lt;MAX_INT64 / 10 <sup>9</sup> <br><br>  We introduce a matrix to simplify the calculation of multiplication: <br><br>  U = (a <sub>1</sub> , a <sub>2</sub> , b <sub>1</sub> , b <sub>2</sub> ), <br>  V = (c <sub>1</sub> , c <sub>2</sub> , d <sub>1</sub> , d <sub>2</sub> ) <sup>T</sup> , <br>  A = V * U, <br>  A = <br>  |  a <sub>1</sub> * c <sub>1</sub> a <sub>1</sub> * c <sub>1</sub> b <sub>1</sub> * c <sub>1</sub> b <sub>2</sub> * c <sub>1</sub> | <br>  |  a <sub>1</sub> * c <sub>2</sub> a <sub>1</sub> * c <sub>2</sub> b <sub>1</sub> * c <sub>2</sub> b <sub>2</sub> * c <sub>2</sub> | <br>  |  a <sub>1</sub> * d <sub>1</sub> a <sub>1</sub> * d <sub>1</sub> b <sub>1</sub> * d <sub>1</sub> b <sub>2</sub> * d <sub>1</sub> | <br>  |  a <sub>1</sub> * d <sub>2</sub> a <sub>1</sub> * d <sub>2</sub> b <sub>1</sub> * d <sub>2</sub> b <sub>2</sub> * d <sub>2</sub> | <br><br>  The matrix is ‚Äã‚Äãintroduced not so much for convenience of calculation, but for convenience of verification.  After all, A <sub>11</sub> = a <sub>1</sub> * c <sub>1</sub> should be strictly less than MAX_INT64 / 10 <sup>18</sup> , and the values ‚Äã‚Äãwith a diagonal below: A <sub>12</sub> = a <sub>1</sub> * c <sub>2</sub> and A <sub>21</sub> = a <sub>2</sub> * c <sub>1</sub> should be strictly less than MAX_INT64 / 109. Just because that we will multiply by these coefficients when adding components: <br><br>  e = A <sub>11</sub> * 10 <sup>18</sup> + (A <sub>12</sub> + A <sub>21</sub> ) * 10 <sup>9</sup> + (A <sub>13</sub> + A <sub>22</sub> + A <sub>31</sub> ) + (A <sub>14</sub> + A <sub>23</sub> + A <sub>32</sub> + A <sub>41</sub> ) div 10 <sup>18</sup> , <br>  f = (A <sub>14</sub> + A <sub>23</sub> + A <sub>32</sub> + A <sub>41</sub> ) mod 10 <sup>18</sup> + (A <sub>24</sub> + A <sub>33</sub> + A <sub>42</sub> ) + (A <sub>34</sub> + A <sub>43</sub> ) div 10 <sup>9</sup> <br><br>  Here we omit the term A <sub>44</sub> div 10 <sup>18</sup> simply because it is zero.  Of course, before each addition it is worth checking whether we go beyond the limits of MAX_INT64.  Fortunately, we can operate on the unsigned uint64_t type for all matrix components and for the intermediate result.  All that needs to be done at the end is to determine the sign of the result s <sub>e</sub> = s <sub>a</sub> xor s <sub>c</sub> and, for a negative number, correct the integral and fractional parts: reduce the whole by one, subtract the fractional from one.  In general, and all multiplication, the main thing - to be very careful.  With an assembler, everything is an order of magnitude simpler, but this material goes beyond the framework of the C ++ Academy. <br><br><h4>  Algorithm of division without registration and SMS </h4><br>  If you remember the column division algorithm - well done, but here it will not be needed.  Thanks to mathematics and a little witchcraft with inequalities, it will be easier for us to calculate the inverse number x <sup>‚Äì1</sup> and perform the multiplication by x <sup>‚Äì1</sup> .  So, we solve the problem <br><br>  y = x <sup>-1</sup> = 1 / (a ‚Äã‚Äã+ b * 10 <sup>-18</sup> ) = c + d * 10 <sup>-18</sup> . <br><br>  For simplicity, consider finding the inverse of a positive x.  If at least one of the components x is zero (but not both), the calculations are greatly simplified.  If a = 0, then: <br><br><pre> <code class="markdown hljs">y = 1 / (b * 1e-18) = 1e+18 / b, e = 1e+18 div b, f = 1e+18 mod b;  b = 0, a = 1,  y = e = 1, f = 0; ec b = 0, a &gt; 1, : y = 1 / a, e = 0, f = 1e+18 div a.</code> </pre><br>  For the more general case, when x contains non-zero fractional and integer parts, in this case the equation reduces to the following: <br><br><pre> <code class="markdown hljs"> a &gt; 1, b != 0 : y = 1 / (a + b <span class="hljs-bullet"><span class="hljs-bullet">* 1e-18) &lt; 1,  e = 0, f = 1e+18 / (a + b *</span></span> 1e-18).</code> </pre><br>  Now you need to find the maximum degree of 10, which will not be greater than a, and iteratively perform the following action: <br><br><pre> <code class="cpp hljs">k = max(k): <span class="hljs-number"><span class="hljs-number">1</span></span>e+k &lt;= a, u = <span class="hljs-number"><span class="hljs-number">1e+18</span></span>, v = (a * <span class="hljs-number"><span class="hljs-number">1e+18</span></span>-k + b div <span class="hljs-number"><span class="hljs-number">1</span></span>e+k); f = (u / v) * <span class="hljs-number"><span class="hljs-number">1e+18</span></span>-k, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (++k; k &lt;=<span class="hljs-number"><span class="hljs-number">18</span></span>; ++k) { u = (u % v) * <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!u) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    f += u / v * 1e+(18-k); }</span></span></code> </pre><br>  Here we just use the multiplication and division of a fraction into the same factor - the power of tens, and then we calculate the division and the remainder of the division for the next power of ten in steps. <br><br>  It will be very useful to have an array of ten degrees from 0 to 18, inclusive, since it is completely unnecessary to calculate them, we know them in advance and we will often need them. <br><br><h4>  Type conversion </h4><br>  We know and are able enough to now turn the vague float and double into our new decimal. <br><br><pre> <code class="cpp hljs">decimal::decimal(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value) : m_integral(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(value)) m_fractional(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>( (value - m_integral) * <span class="hljs-number"><span class="hljs-number">1e+18</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)) { normalize(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> decimal::normalize() { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tail = m_fractional % <span class="hljs-number"><span class="hljs-number">1e+3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tail) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tail &gt; <span class="hljs-number"><span class="hljs-number">103</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>) m_fractional += <span class="hljs-number"><span class="hljs-number">1e+3</span></span> - tail; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_fractional -= tail; } }</code> </pre><br>  Here 103 is, in fact, the error beyond which a double ceases to be exact.  If desired, the error can still be reduced, here 10 <sup>18-15 is</sup> needed for clarity of presentation.  Normalization after conversion will be needed anyway, since exactly double is obviously lower than even the decimal fractional part.  In addition, we must take into account the case when double goes beyond the limits of int64_t, under such conditions our decimal will not be able to correctly convert the integer part of a number. <br><br>  For float, everything looks similar, but the error is much higher: 10 <sup>18-7</sup> = 10 <sup>11</sup> . <br><br>      decimal  ,    m_integral.            m_integral,    m_fractional. <br><br>   decimal  double  float    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_integral + m_fractional * <span class="hljs-number"><span class="hljs-number">1e-18</span></span>;</code> </pre><br>         .  ,  ,     ,      decimal separator      ,   .     ¬´¬ª m_precision           . <br><br>     ,    .     ,   ,   ,      ,     ‚Äî    ,    . <br><br>            ,                decimal,           . <br><br><blockquote><h4> GITHUB </h4><br>            decimal,           . </blockquote><br><h4>  ,  ! </h4><br>     ,     C/C++      .  ,         Python  C#,      15‚Äì18     ,     . <br><br>   decimal            ,  int64_t.   ,  double  float              ,    .     ,    decimal  .       ,        . <br><br>           ,    .       double  float,     ,   . , ,      ,      ,   .    ,      ! <br><br><img src="https://xakep.ru/wp-content/uploads/2015/01/xakep-01-2015_COVER_mid-326x420.png" alt="image"><br><br> <i>     #192. <br></i>  <i>Author: Vladimir <a href="http://habrahabr.ru/users/qualab/" class="user_link">Qualab</a> Kerimov, Lead C ++ Developer, Parallels</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/257897/">https://habr.com/ru/post/257897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257887/index.html">Python nightmares: the implicit `this`</a></li>
<li><a href="../257889/index.html">Fast cross-platform HTML5 application on Framework7</a></li>
<li><a href="../257891/index.html">Escape from the dungeon types. We work with data, the type of which is determined dynamically.</a></li>
<li><a href="../257893/index.html">Place and conquer! Use host new to optimize C ++ code.</a></li>
<li><a href="../257895/index.html">The sad story of forgotten characters. How not to go crazy when working with encodings in C ++</a></li>
<li><a href="../257899/index.html">Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</a></li>
<li><a href="../257903/index.html">Introduction to functional programming in Python</a></li>
<li><a href="../257905/index.html">Travel SIM + cloud PBX and new approaches to the IP-PBX interface</a></li>
<li><a href="../257909/index.html">Sergey Borisyuk: ‚ÄúThe most important thing in startups is the focus‚Äù</a></li>
<li><a href="../257911/index.html">Determining network topology at OSI levels 2/3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>